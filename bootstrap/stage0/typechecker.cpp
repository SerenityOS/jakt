#include "typechecker.h"
namespace Jakt {
namespace typechecker {
ErrorOr<JaktInternal::Dictionary<ByteString,ByteString>> defines_from(JaktInternal::DynamicArray<parser::IncludeAction> const actions) {
{
JaktInternal::Dictionary<ByteString,ByteString> defines = (TRY((Dictionary<ByteString, ByteString>::create_with_entries({}))));
{
JaktInternal::ArrayIterator<parser::IncludeAction> _magic = ((actions).iterator());
for (;;){
JaktInternal::Optional<parser::IncludeAction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::IncludeAction action = (_magic_value.value());
{
if (((action).__jakt_init_index() == 0 /* Define */)){
ByteString const name = (action).as.Define.name;
ByteString const value = (action).as.Define.value;
TRY((((defines).set(name,value))));
}
}

}
}

return defines;
}
}

ErrorOr<void> dump_scope(ids::ScopeId const scope_id,NonnullRefPtr<types::CheckedProgram> const& program,i64 const indent) {
{
NonnullRefPtr<types::Scope> scope = TRY((((((program)))->get_scope(scope_id))));
warnln((StringView::from_string_literal("{: >{}}Scope (ns={}) {}"sv)),(ByteString::must_from_utf8(""sv)),indent,((scope)->namespace_name),((scope)->debug_name));
i64 const cindent = JaktInternal::checked_add(indent,static_cast<i64>(2LL));
warnln((StringView::from_string_literal("{: >{}}Types:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,ids::TypeId> _magic = ((((scope)->types)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::TypeId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::TypeId> name__type_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::TypeId> const jakt__name__type_id__ = name__type_id__;
ByteString const name = ((jakt__name__type_id__).template get<0>());
ids::TypeId const type_id = ((jakt__name__type_id__).template get<1>());

NonnullRefPtr<typename types::Type> const type = ((((program)))->get_type(type_id));
warnln((StringView::from_string_literal("{: >{}}{}: {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),name,TRY((((((program)))->type_name(type_id,true)))));
}

}
}

warnln((StringView::from_string_literal("{: >{}}Specializations:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,types::SpecializedType> _magic = ((((scope)->explicitly_specialized_types)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,types::SpecializedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,types::SpecializedType> name__type__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,types::SpecializedType> const jakt__name__type__ = name__type__;
ByteString const name = ((jakt__name__type__).template get<0>());
types::SpecializedType const type = ((jakt__name__type__).template get<1>());

ByteString const type_name = TRY((((((program)))->type_name(((type).type_id),true))));
ByteString args = (ByteString::must_from_utf8(""sv));
{
JaktInternal::ArrayIterator<ids::TypeId> _magic = ((((type).arguments)).iterator());
for (;;){
JaktInternal::Optional<ids::TypeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::TypeId arg = (_magic_value.value());
{
(args = TRY((((TRY((((args) + (TRY((((((program)))->type_name(arg,true))))))))) + ((ByteString::must_from_utf8(", "sv)))))));
}

}
}

warnln((StringView::from_string_literal("{: >{}}{}<{}> = {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),name,args,type_name);
}

}
}

warnln((StringView::from_string_literal("{: >{}}Variables:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,ids::VarId> _magic = ((((scope)->vars)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::VarId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::VarId> name__var_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::VarId> const jakt__name__var_id__ = name__var_id__;
ByteString const name = ((jakt__name__var_id__).template get<0>());
ids::VarId const var_id = ((jakt__name__var_id__).template get<1>());

NonnullRefPtr<types::CheckedVariable> const var = ((((program)))->get_variable(var_id));
warnln((StringView::from_string_literal("{: >{}}{}: {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),name,TRY((((((program)))->type_name(((var)->type_id),true)))));
}

}
}

warnln((StringView::from_string_literal("{: >{}}Functions:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> _magic = ((((scope)->functions)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> name__ids__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> const jakt__name__ids__ = name__ids__;
ByteString const name = ((jakt__name__ids__).template get<0>());
JaktInternal::DynamicArray<ids::FunctionId> const ids = ((jakt__name__ids__).template get<1>());

warnln((StringView::from_string_literal("{: >{}}{}:"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),name);
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((ids).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const function = ((((program)))->get_function(id));
ByteString args = (ByteString::must_from_utf8(""sv));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((function)->params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter arg = (_magic_value.value());
{
(args = TRY((((TRY((((args) + (TRY((((((program)))->type_name(((((arg).variable))->type_id),true))))))))) + ((ByteString::must_from_utf8(", "sv)))))));
}

}
}

ByteString generics = (ByteString::must_from_utf8(""sv));
{
JaktInternal::ArrayIterator<types::FunctionGenericParameter> _magic = ((((((function)->generics))->params)).iterator());
for (;;){
JaktInternal::Optional<types::FunctionGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::FunctionGenericParameter generic = (_magic_value.value());
{
(generics = TRY((((TRY((((generics) + (TRY((((((program)))->type_name(((generic).type_id()),true))))))))) + ((ByteString::must_from_utf8(", "sv)))))));
}

}
}

if ((!(((generics).is_empty())))){
(generics = TRY((__jakt_format((StringView::from_string_literal("<{}>"sv)),generics))));
}
warnln((StringView::from_string_literal("{: >{}}fn{}({}) -> {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(4LL)),generics,args,TRY((((((program)))->type_name(((function)->return_type_id),true)))));
}

}
}

}

}
}

warnln((StringView::from_string_literal("{: >{}}Structs:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,ids::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::StructId> name__id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::StructId> const jakt__name__id__ = name__id__;
ByteString const name = ((jakt__name__id__).template get<0>());
ids::StructId const id = ((jakt__name__id__).template get<1>());

types::CheckedStruct const struct_ = ((((program)))->get_struct(id));
warnln((StringView::from_string_literal("{: >{}}{}@{}: {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),((id).id),((id).module),((struct_).name));
}

}
}

warnln((StringView::from_string_literal("{: >{}}Aliases:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::DictionaryIterator<ByteString,ids::ScopeId> _magic = ((((scope)->aliases)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::ScopeId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::ScopeId> name__id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::ScopeId> const jakt__name__id__ = name__id__;
ByteString const name = ((jakt__name__id__).template get<0>());
ids::ScopeId const id = ((jakt__name__id__).template get<1>());

NonnullRefPtr<types::Scope> const scope = TRY((((((program)))->get_scope(id))));
warnln((StringView::from_string_literal("{: >{}}{}: {}"sv)),(ByteString::must_from_utf8(""sv)),JaktInternal::checked_add(cindent,static_cast<i64>(2LL)),name,((scope)->debug_name));
}

}
}

warnln((StringView::from_string_literal("{: >{}}Children:"sv)),(ByteString::must_from_utf8(""sv)),cindent);
{
JaktInternal::ArrayIterator<ids::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
JaktInternal::Optional<ids::ScopeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::ScopeId id = (_magic_value.value());
{
TRY((typechecker::dump_scope(id,program,JaktInternal::checked_add(cindent,static_cast<i64>(2LL)))));
}

}
}

}
return {};
}

ErrorOr<ByteString> typechecker::TraitImplementationDescriptor::debug_description() const { auto builder = ByteStringBuilder::create();TRY(builder.append("TraitImplementationDescriptor("sv));{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("trait_id: {}, ", trait_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("trait_name: \"{}\", ", trait_name));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("implemented_type_args: {}", implemented_type_args));
}
TRY(builder.append(")"sv));return builder.to_string(); }
typechecker::TraitImplementationDescriptor::TraitImplementationDescriptor(ids::TraitId a_trait_id, ByteString a_trait_name, JaktInternal::DynamicArray<ids::TypeId> a_implemented_type_args): trait_id(move(a_trait_id)), trait_name(move(a_trait_name)), implemented_type_args(move(a_implemented_type_args)){}

ErrorOr<ByteString> typechecker::TraitImplCheck::debug_description() const { auto builder = ByteStringBuilder::create();TRY(builder.append("TraitImplCheck("sv));{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("missing_methods: {}, ", missing_methods));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("unmatched_signatures: {}, ", unmatched_signatures));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("private_matching_methods: {}, ", private_matching_methods));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("already_implemented_for: {}", already_implemented_for));
}
TRY(builder.append(")"sv));return builder.to_string(); }
ErrorOr<void> typechecker::TraitImplCheck::throw_errors(utility::Span const record_decl_span,typechecker::Typechecker& typechecker) {
{
{
JaktInternal::DictionaryIterator<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> _magic = ((((*this).missing_methods)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> trait_type_id__missing_methods__ = (_magic_value.value());
{
JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> const jakt__trait_type_id__missing_methods__ = trait_type_id__missing_methods__;
ids::TypeId const trait_type_id = ((jakt__trait_type_id__missing_methods__).template get<0>());
JaktInternal::Dictionary<ByteString,ids::FunctionId> const missing_methods = ((jakt__trait_type_id__missing_methods__).template get<1>());

JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> const trait_id_trait_generic_arguments_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>, ErrorOr<void>>{
auto&& __jakt_match_variant = *((((typechecker))).get_type(trait_type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& trait_id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue((Tuple{trait_id, args}));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& trait_id = __jakt_match_value.value;
JaktInternal::DynamicArray<ids::TypeId> const args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
return JaktInternal::ExplicitValue((Tuple{trait_id, args}));
};/*case end*/
default: {
{
abort();
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
ids::TraitId const trait_id = ((trait_id_trait_generic_arguments_).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const trait_generic_arguments = ((trait_id_trait_generic_arguments_).template get<1>());

ByteString const trait_name = ((((((typechecker))).get_trait(trait_id)))->name);
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>>> const unmatched_signatures = ((((*this).unmatched_signatures))[trait_type_id]);
JaktInternal::Dictionary<ByteString,utility::Span> const private_matching_methods = ((((*this).private_matching_methods))[trait_type_id]);
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((missing_methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> method_name__trait_method_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__method_name__trait_method_id__ = method_name__trait_method_id__;
ByteString const method_name = ((jakt__method_name__trait_method_id__).template get<0>());
ids::FunctionId const trait_method_id = ((jakt__method_name__trait_method_id__).template get<1>());

JaktInternal::Optional<typechecker::AlreadyImplementedFor> const already_implemented_for = ((((*this).already_implemented_for)).get(method_name));
JaktInternal::Optional<JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>>> const unmatched_signature = ((unmatched_signatures).get(method_name));
JaktInternal::Optional<utility::Span> const private_matching_method = ((private_matching_methods).get(method_name));
if (((already_implemented_for).has_value())){
TRY((((((typechecker))).error(TRY((__jakt_format((StringView::from_string_literal("Cannot implement ‘{}’ for ‘{}’ because it's already implementing ‘{}’"sv)),method_name,trait_name,(((already_implemented_for.value())).trait_name)))),(((already_implemented_for.value())).encounter_span)))));
}
else if (((private_matching_method).has_value())){
utility::Span const span = (private_matching_method.value());
TRY((((((typechecker))).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Implementation of ‘{}’ for trait ‘{}’ is valid but is not public"sv)),method_name,trait_name))),span,(ByteString::must_from_utf8("Consider adding ‘public’ to make the method accessible"sv)),span))));
}
else {
NonnullRefPtr<types::CheckedFunction> const func = ((((typechecker))).get_function(trait_method_id));
if ((!(((((((func)->block)).statements)).is_empty())))){
continue;
}
if (((unmatched_signature).has_value())){
JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>> const method_span_errors_ = (unmatched_signature.value());
utility::Span const method_span = ((method_span_errors_).template get<0>());
JaktInternal::DynamicArray<error::JaktError> const errors = ((method_span_errors_).template get<1>());

TRY((((((typechecker))).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Missing implementation for method ‘{}’ of trait ‘{}’ on type ‘{}’"sv)),method_name,trait_name,TRY((((((typechecker))).type_name(trait_type_id,false))))))),record_decl_span,(ByteString::must_from_utf8("The method is declared here, but its signature doesn't match"sv)),method_span))));
TRY((((((((((typechecker))).compiler))->errors)).push_values(((errors))))));
}
else {
utility::Span const trait_method_span = ((((((typechecker))).get_function(trait_method_id)))->name_span);
TRY((((((typechecker))).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Missing implementation for method ‘{}’ of trait ‘{}’"sv)),method_name,trait_name))),record_decl_span,(ByteString::must_from_utf8("Consider implementing the method with the signature specified here"sv)),trait_method_span))));
}

}

}

}
}

}

}
}

}
return {};
}

ErrorOr<void> typechecker::TraitImplCheck::ensure_capacity(size_t const count) {
{
TRY((((((*this).missing_methods)).ensure_capacity(count))));
TRY((((((*this).unmatched_signatures)).ensure_capacity(count))));
TRY((((((*this).private_matching_methods)).ensure_capacity(count))));
TRY((((((*this).already_implemented_for)).ensure_capacity(count))));
}
return {};
}

ErrorOr<void> typechecker::TraitImplCheck::register_method(ids::TypeId const self_type_id,ByteString const method_name,ids::FunctionId const method_id,typechecker::Typechecker& typechecker) {
{
NonnullRefPtr<types::CheckedFunction> const method = ((((typechecker))).get_function(method_id));
{
JaktInternal::DictionaryIterator<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> _magic = ((((*this).missing_methods)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> trait_type_id__methods__ = (_magic_value.value());
{
JaktInternal::Tuple<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> const jakt__trait_type_id__methods__ = trait_type_id__methods__;
ids::TypeId const trait_type_id = ((jakt__trait_type_id__methods__).template get<0>());
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = ((jakt__trait_type_id__methods__).template get<1>());

JaktInternal::Optional<ids::FunctionId> const trait_method_id = ((methods).get(method_name));
if (((trait_method_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const trait_method = ((((typechecker))).get_function((trait_method_id.value())));
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> const trait_id_trait_generic_arguments_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>, ErrorOr<void>>{
auto&& __jakt_match_variant = *((((typechecker))).get_type(trait_type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& trait_id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue((Tuple{trait_id, args}));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& trait_id = __jakt_match_value.value;
JaktInternal::DynamicArray<ids::TypeId> const args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
return JaktInternal::ExplicitValue((Tuple{trait_id, args}));
};/*case end*/
default: {
{
abort();
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
ids::TraitId const trait_id = ((trait_id_trait_generic_arguments_).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const trait_generic_arguments = ((trait_id_trait_generic_arguments_).template get<1>());

NonnullRefPtr<types::CheckedTrait> const trait_ = ((((typechecker))).get_trait(trait_id));
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((((typechecker))).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_429([&] {
((((((typechecker))).generic_inferences)).restore(old_generic_inferences));
});
if (((((((trait_)->generic_parameters)).size())) == (((trait_generic_arguments).size())))){
TRY((((((((typechecker))).generic_inferences)).set_all(((trait_)->generic_parameters),trait_generic_arguments))));
JaktInternal::Tuple<bool,JaktInternal::DynamicArray<error::JaktError>> const matches_errors_ = TRY((((((typechecker))).signatures_match(self_type_id,trait_method,method))));
bool const matches = ((matches_errors_).template get<0>());
JaktInternal::DynamicArray<error::JaktError> const errors = ((matches_errors_).template get<1>());

if (matches){
if (((((method)->visibility)).__jakt_init_index() == 0 /* Public */)){
((((((*this).missing_methods))[trait_type_id])).remove(method_name));
TRY(((*this).already_implemented_for).set(method_name, typechecker::AlreadyImplementedFor(((trait_)->name),((method)->name_span))));
break;
}
else {
TRY((((((((*this).private_matching_methods))[trait_type_id])).set(method_name,((method)->name_span)))));
continue;
}

}
else {
TRY((((((((*this).unmatched_signatures))[trait_type_id])).set(method_name,(Tuple{((method)->name_span), errors})))));
continue;
}

}
else {
TRY((((((((*this).unmatched_signatures))[trait_type_id])).set(method_name,(Tuple{((method)->name_span), (TRY((DynamicArray<error::JaktError>::create_with({error::JaktError::Message(TRY((__jakt_format((StringView::from_string_literal("Expected {} generic arguments, but got {}"sv)),((((trait_)->generic_parameters)).size()),((trait_generic_arguments).size())))),((method)->name_span))}))))})))));
continue;
}

}
else {
continue;
}

}

}
}

}
return {};
}

ErrorOr<typechecker::TraitImplCheck> typechecker::TraitImplCheck::make() {
{
return typechecker::TraitImplCheck((TRY((Dictionary<ids::TypeId, JaktInternal::Dictionary<ByteString,ids::FunctionId>>::create_with_entries({})))),(TRY((Dictionary<ids::TypeId, JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>>>>::create_with_entries({})))),(TRY((Dictionary<ids::TypeId, JaktInternal::Dictionary<ByteString,utility::Span>>::create_with_entries({})))),(TRY((Dictionary<ByteString, typechecker::AlreadyImplementedFor>::create_with_entries({})))));
}
}

typechecker::TraitImplCheck::TraitImplCheck(JaktInternal::Dictionary<ids::TypeId,JaktInternal::Dictionary<ByteString,ids::FunctionId>> a_missing_methods, JaktInternal::Dictionary<ids::TypeId,JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>>>> a_unmatched_signatures, JaktInternal::Dictionary<ids::TypeId,JaktInternal::Dictionary<ByteString,utility::Span>> a_private_matching_methods, JaktInternal::Dictionary<ByteString,typechecker::AlreadyImplementedFor> a_already_implemented_for): missing_methods(move(a_missing_methods)), unmatched_signatures(move(a_unmatched_signatures)), private_matching_methods(move(a_private_matching_methods)), already_implemented_for(move(a_already_implemented_for)){}

ErrorOr<void> typechecker::TraitImplCheck::register_trait(ids::TypeId const trait_type_id,ByteString const trait_name,types::CheckedTraitRequirements const requirements) {
{
if (((requirements).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const trait_methods = (requirements).as.Methods.value;
TRY(((*this).private_matching_methods).set(trait_type_id, (TRY((Dictionary<ByteString, utility::Span>::create_with_entries({}))))));
TRY(((*this).unmatched_signatures).set(trait_type_id, (TRY((Dictionary<ByteString, JaktInternal::Tuple<utility::Span,JaktInternal::DynamicArray<error::JaktError>>>::create_with_entries({}))))));
JaktInternal::Dictionary<ByteString,ids::FunctionId> missing_methods = (TRY((Dictionary<ByteString, ids::FunctionId>::create_with_entries({}))));
TRY((((missing_methods).ensure_capacity(((trait_methods).size())))));
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((trait_methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> method_name__method_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__method_name__method_id__ = method_name__method_id__;
ByteString const method_name = ((jakt__method_name__method_id__).template get<0>());
ids::FunctionId const method_id = ((jakt__method_name__method_id__).template get<1>());

TRY((((missing_methods).set(method_name,method_id))));
}

}
}

TRY((((((*this).missing_methods)).set(trait_type_id,missing_methods))));
}
else {
return {};
}

}
return {};
}

ErrorOr<ByteString> typechecker::AlreadyImplementedFor::debug_description() const { auto builder = ByteStringBuilder::create();TRY(builder.append("AlreadyImplementedFor("sv));{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("trait_name: \"{}\", ", trait_name));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("encounter_span: {}", encounter_span));
}
TRY(builder.append(")"sv));return builder.to_string(); }
typechecker::AlreadyImplementedFor::AlreadyImplementedFor(ByteString a_trait_name, utility::Span a_encounter_span): trait_name(move(a_trait_name)), encounter_span(move(a_encounter_span)){}

ErrorOr<ByteString> typechecker::ImportRestrictions::debug_description() const { auto builder = ByteStringBuilder::create();TRY(builder.append("ImportRestrictions("sv));{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("functions: {}, ", functions));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("structs: {}, ", structs));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("enums: {}, ", enums));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("types: {}, ", types));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("traits: {}, ", traits));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("namespaces: {}", namespaces));
}
TRY(builder.append(")"sv));return builder.to_string(); }
typechecker::ImportRestrictions::ImportRestrictions(bool a_functions, bool a_structs, bool a_enums, bool a_types, bool a_traits, bool a_namespaces): functions(move(a_functions)), structs(move(a_structs)), enums(move(a_enums)), types(move(a_types)), traits(move(a_traits)), namespaces(move(a_namespaces)){}

typechecker::ImportRestrictions typechecker::ImportRestrictions::all() {
{
return typechecker::ImportRestrictions(true,true,true,true,true,true);
}
}

ErrorOr<ByteString> typechecker::Typechecker::debug_description() const { auto builder = ByteStringBuilder::create();TRY(builder.append("Typechecker("sv));{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("compiler: {}, ", *compiler));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("program: {}, ", *program));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("current_module_id: {}, ", current_module_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("current_struct_type_id: {}, ", current_struct_type_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("current_function_id: {}, ", current_function_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("inside_defer: {}, ", inside_defer));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("checkidx: {}, ", checkidx));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("ignore_errors: {}, ", ignore_errors));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("dump_type_hints: {}, ", dump_type_hints));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("dump_try_hints: {}, ", dump_try_hints));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("lambda_count: {}, ", lambda_count));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("generic_inferences: {}, ", generic_inferences));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("self_type_id: {}, ", self_type_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("root_module_name: \"{}\", ", root_module_name));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("in_comptime_function_call: {}, ", in_comptime_function_call));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("had_an_error: {}, ", had_an_error));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("cpp_import_cache: {}, ", cpp_import_cache));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));TRY(builder.appendff("cpp_import_processor: {}", cpp_import_processor));
}
TRY(builder.append(")"sv));return builder.to_string(); }
ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl_initial(parser::ParsedRecord const parsed_record,size_t const struct_index,size_t const module_struct_len,ids::ScopeId const scope_id) {
{
ids::ModuleId const module_id = ((*this).current_module_id);
ids::StructId const struct_id = ids::StructId(((*this).current_module_id),JaktInternal::checked_add(struct_index,module_struct_len));
NonnullRefPtr<types::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
ids::TypeId const struct_type_id = ids::TypeId(module_id,JaktInternal::checked_sub(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL)));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),struct_type_id,((parsed_record).name_span)))));
ids::ScopeId const struct_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((__jakt_format((StringView::from_string_literal("struct({})"sv)),((parsed_record).name)))),false))));
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(struct_scope_id))));
(((scope)->namespace_name) = ((parsed_record).name));
(((scope)->external_name) = ((parsed_record).external_name));
(((scope)->relevant_type_id) = struct_type_id);
TRY((((((module)->structures)).push(types::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((DynamicArray<types::CheckedGenericParameter>::create_with({})))),JaktInternal::OptionalNone(),(TRY((DynamicArray<types::CheckedField>::create_with({})))),struct_scope_id,((parsed_record).definition_linkage),(TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>::create_with_entries({})))),((parsed_record).record_type),struct_type_id,JaktInternal::OptionalNone(),((parsed_record).external_name),JaktInternal::OptionalNone())))));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;JaktInternal::DynamicArray<parser::ParsedField> const& fields = __jakt_match_value.fields;
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const field_names_and_spans = TRY((utility::map<parser::ParsedField, JaktInternal::Tuple<ByteString,utility::Span>>(fields,(([](parser::ParsedField item) -> ErrorOr<JaktInternal::Tuple<ByteString,utility::Span>> {
{
return (Tuple{((((item).var_decl)).name), ((((item).var_decl)).span)});
}
}
)))));
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const method_names_and_spans = TRY((utility::map<parser::ParsedMethod, JaktInternal::Tuple<ByteString,utility::Span>>(((parsed_record).methods),(([](parser::ParsedMethod item) -> ErrorOr<JaktInternal::Tuple<ByteString,utility::Span>> {
{
return (Tuple{((((item).parsed_function)).name), ((((item).parsed_function)).name_span)});
}
}
)))));
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = ((field_names_and_spans).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> x = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = ((method_names_and_spans).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> y = (_magic_value.value());
{
if (((((x).template get<0>())) == (((y).template get<0>())))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Can't have a member variable and member function both named `{}`"sv)),((x).template get<0>())))),utility::Span::last(((x).template get<1>()),((y).template get<1>())),TRY((__jakt_format((StringView::from_string_literal("`{}` is first defined here"sv)),((x).template get<0>())))),utility::Span::first(((x).template get<1>()),((y).template get<1>()))))));
}
}

}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Class */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Class;JaktInternal::DynamicArray<parser::ParsedField> const& fields = __jakt_match_value.fields;
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const field_names_and_spans = TRY((utility::map<parser::ParsedField, JaktInternal::Tuple<ByteString,utility::Span>>(fields,(([](parser::ParsedField item) -> ErrorOr<JaktInternal::Tuple<ByteString,utility::Span>> {
{
return (Tuple{((((item).var_decl)).name), ((((item).var_decl)).span)});
}
}
)))));
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const method_names_and_spans = TRY((utility::map<parser::ParsedMethod, JaktInternal::Tuple<ByteString,utility::Span>>(((parsed_record).methods),(([](parser::ParsedMethod item) -> ErrorOr<JaktInternal::Tuple<ByteString,utility::Span>> {
{
return (Tuple{((((item).parsed_function)).name), ((((item).parsed_function)).name_span)});
}
}
)))));
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = ((field_names_and_spans).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> x = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = ((method_names_and_spans).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> y = (_magic_value.value());
{
if (((((x).template get<0>())) == (((y).template get<0>())))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Can't have a member variable and member function both named `{}`"sv)),((x).template get<0>())))),utility::Span::last(((x).template get<1>()),((y).template get<1>())),TRY((__jakt_format((StringView::from_string_literal("`{}` is first defined here"sv)),((x).template get<0>())))),utility::Span::first(((x).template get<1>()),((y).template get<1>()))))));
}
}

}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<void> typechecker::Typechecker::ensure_type_implements_trait(ids::TypeId const type_id,ByteString const trait_name,JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const filter_for_generics,ids::ScopeId const scope_id,utility::Span const span) {
{
if (((((*this).get_type(type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
return {};
}
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const implementation = TRY((((*this).find_any_singular_trait_implementation(type_id,(TRY((DynamicArray<ByteString>::create_with({trait_name})))),scope_id,span,filter_for_generics))));
if ((!(((implementation).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ does not implement trait ‘{}’"sv)),TRY((((*this).type_name(type_id,false)))),trait_name))),span))));
}
}
return {};
}

ErrorOr<JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>>> typechecker::Typechecker::typecheck_match_body(parser::ParsedMatchBody const body,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,types::GenericInferences& generic_inferences,JaktInternal::Optional<ids::TypeId> const final_result_type,utility::Span const span) {
{
JaktInternal::Optional<ids::TypeId> result_type = final_result_type;
types::CheckedMatchBody const checked_match_body = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedMatchBody, ErrorOr<JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Block */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Block;parser::ParsedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedMatchBody> __jakt_var_430; {
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode,final_result_type))));
if ((((((checked_block).control_flow)).may_return()) || ((((checked_block).yielded_type)).has_value()))){
ids::TypeId const block_type_id = ((checked_block).yielded_type).value_or_lazy_evaluated([&] { return types::void_type_id(); });
utility::Span const yield_span = ((block).find_yield_span()).value_or_lazy_evaluated([&] { return span; });
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),block_type_id,generic_inferences,yield_span))));
}
else {
(result_type = block_type_id);
}

}
JaktInternal::Optional<types::CheckedMatchBody> final_body = JaktInternal::OptionalNone();
if ((((((checked_block).yielded_type)).has_value()) && (!(((((checked_block).control_flow)).never_returns()))))){
(final_body = types::CheckedMatchBody::Expression(TRY((types::CheckedExpression::Block(JaktInternal::OptionalNone(),checked_block,span,(((checked_block).yielded_type).value()))))));
}
else {
(final_body = types::CheckedMatchBody::Block(checked_block));
}

__jakt_var_430 = (final_body.value()); goto __jakt_label_405;

}
__jakt_label_405:; __jakt_var_430.release_value(); }));
};/*case end*/
case 0 /* Expression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Expression;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedMatchBody> __jakt_var_431; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expression = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,result_type))));
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),((checked_expression)->type()),generic_inferences,span))));
}
else {
(result_type = ((checked_expression)->type()));
}

__jakt_var_431 = types::CheckedMatchBody::Expression(checked_expression); goto __jakt_label_406;

}
__jakt_label_406:; __jakt_var_431.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return (Tuple{checked_match_body, result_type});
}
}

ErrorOr<ByteString> typechecker::Typechecker::type_name(ids::TypeId const type_id,bool const debug_mode) const {
{
ids::TypeId id = type_id;
if ((((((((*this).program))->get_type(id)))->__jakt_init_index() == 31 /* Self */) && ((((*this).self_type_id)).has_value()))){
(id = (((*this).self_type_id).value()));
}
return TRY((((((*this).program))->type_name(id,debug_mode))));
}
}

ErrorOr<ids::ScopeId> typechecker::Typechecker::create_scope(JaktInternal::Optional<ids::ScopeId> const parent_scope_id,bool const can_throw,ByteString const debug_name,bool const for_block) {
{
return TRY((((((*this).program))->create_scope(parent_scope_id,can_throw,debug_name,((*this).current_module_id),for_block))));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_return(JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const expr,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode) {
{
if (((*this).inside_defer)){
TRY((((*this).error((ByteString::must_from_utf8("‘return’ is not allowed inside ‘defer’"sv)),span))));
}
if ((!(((expr).has_value())))){
if (((((*this).current_function_id)).has_value())){
NonnullRefPtr<types::CheckedFunction> const current_function = ((*this).get_function((((*this).current_function_id).value())));
NonnullRefPtr<typename types::Type> const return_type = ((*this).get_type(((current_function)->return_type_id)));
if (((!(((return_type)->__jakt_init_index() == 0 /* Void */))) && (!(((return_type)->__jakt_init_index() == 16 /* Unknown */))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("’return’ with no value in function ’{}’ returning ’{}’"sv)),((current_function)->name),TRY((((*this).type_name(((current_function)->return_type_id),false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Add return value of type ’{}’ here"sv)),TRY((((*this).type_name(((current_function)->return_type_id),false))))))),span))));
}
}
return TRY((types::CheckedStatement::Return(JaktInternal::OptionalNone(),span)));
}
if (((!((((((*this).current_function_id)).has_value()) && ((((*this).get_function((((*this).current_function_id).value()))))->is_comptime)))) && (((expr.value()))->__jakt_init_index() == 25 /* Function */))){
TRY((((*this).error((ByteString::must_from_utf8("Returning a function is not currently supported"sv)),span))));
}
JaktInternal::Optional<ids::TypeId> type_hint = JaktInternal::OptionalNone();
if (((((*this).current_function_id)).has_value())){
(type_hint = static_cast<JaktInternal::Optional<ids::TypeId>>(((((*this).get_function((((*this).current_function_id).value()))))->return_type_id)));
}
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>> const new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings((expr.value()),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),scope_id,span))));
NonnullRefPtr<typename parser::ParsedExpression> const new_condition = ((new_condition_new_then_block_new_else_statement_).template get<0>());
JaktInternal::Optional<parser::ParsedBlock> const new_then_block = ((new_condition_new_then_block_new_else_statement_).template get<1>());
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const new_else_statement = ((new_condition_new_then_block_new_else_statement_).template get<2>());

NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,type_hint,span))));
if (((type_hint).has_value())){
if (((checked_expr)->__jakt_init_index() == 25 /* OptionalNone */)){
utility::Span const span = (checked_expr)->as.OptionalNone.span;
if (((((*this).get_type((type_hint.value()))))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type((type_hint.value()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type((type_hint.value()))))->as.GenericInstance.args;
if (((!(((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv)))))))))) && (!(((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv)))))))))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}

}
TRY((((*this).unify_with_type(((checked_expr)->type()),(type_hint.value()),span))));
}
return TRY((types::CheckedStatement::Return(checked_expr,span)));
}
}

NonnullRefPtr<types::CheckedTrait> typechecker::Typechecker::get_trait(ids::TraitId const id) const {
{
return ((((*this).program))->get_trait(id));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_function_predecl(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id,bool const comptime_pass,bool const generic_pass) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_function_predecl(child_namespace,child_namespace_scope_id,comptime_pass,generic_pass))));
}

}
}

{
JaktInternal::ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedFunction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
if ((((((fun).is_comptime)) == (comptime_pass)) && ((generic_pass) == ((!(((((fun).generic_parameters)).is_empty()))))))){
TRY((((*this).typecheck_function_predecl(fun,scope_id,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
}
}

}
}

NonnullRefPtr<types::Module> module = ((*this).current_module());
AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const record = ((record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((record_scope_id_).template get<1>());

ids::ScopeId const record_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_432; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
return JaktInternal::LoopContinue{};
}
__jakt_var_432 = ((((*this).get_struct((struct_id.value())))).scope_id); goto __jakt_label_407;

}
__jakt_label_407:; __jakt_var_432.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_433; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
return JaktInternal::LoopContinue{};
}
__jakt_var_433 = ((((*this).get_struct((struct_id.value())))).scope_id); goto __jakt_label_408;

}
__jakt_label_408:; __jakt_var_433.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_434; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
return JaktInternal::LoopContinue{};
}
__jakt_var_434 = ((((*this).get_enum((enum_id.value())))).scope_id); goto __jakt_label_409;

}
__jakt_label_409:; __jakt_var_434.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord nested_record = (_magic_value.value());
{
TRY((((*this).warn_about_unimplemented_nested_record(nested_record))));
((records_to_process).enqueue((Tuple{nested_record, record_scope_id})));
}

}
}

{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((((((method).parsed_function)).is_comptime)) != (comptime_pass))){
continue;
}
if (((generic_pass) == ((!(((((((method).parsed_function)).generic_parameters)).is_empty())))))){
continue;
}
if (((!(((((record).generic_parameters)).is_empty()))) || (!(((((((method).parsed_function)).generic_parameters)).is_empty()))))){
NonnullRefPtr<types::CheckedFunction> func = ((*this).get_function((TRY((((*this).find_function_matching_signature_in_scope(record_scope_id,((method).parsed_function))))).value())));
ids::ScopeId const method_scope_id = ((func)->function_scope_id);
ids::ScopeId const check_scope = TRY((((*this).create_scope(method_scope_id,((func)->can_throw),TRY((__jakt_format((StringView::from_string_literal("method-checking({}::{})"sv)),((record).name),((func)->name)))),true))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((func)->params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((*this).add_var_to_scope(check_scope,((((param).variable))->name),TRY((((module)->add_variable(((param).variable))))),((((param).variable))->definition_span)))));
}

}
}

bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
types::CheckedBlock const block = TRY((((*this).typecheck_block(((((method).parsed_function)).block),check_scope,types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
ids::TypeId const function_return_type_id = ((func)->return_type_id);
ids::TypeId return_type_id = types::builtin(types::BuiltinType::Void());
if (((function_return_type_id).equals(types::unknown_type_id()))){
if ((!(((((block).statements)).is_empty())))){
if ((((((((block).statements)).last()).value()))->__jakt_init_index() == 8 /* Return */)){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const val = ((((((block).statements)).last()).value()))->as.Return.val;
if (((val).has_value())){
(return_type_id = TRY((((*this).resolve_type_var((((val.value()))->type()),method_scope_id)))));
}
}
}
}
else {
(return_type_id = TRY((((*this).resolve_type_var(function_return_type_id,scope_id)))));
}

(((func)->block) = block);
(((func)->return_type_id) = return_type_id);
}
}

}
}

}
if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_435([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_function_predecl(((chunk).parsed_namespace),((((chunk).generated_scopes))[i]),comptime_pass,generic_pass))));
}

}
}

}

}
}

}
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_set(JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedExpression>> const values,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
if ((!(((TRY((((*this).get_scope(scope_id)))))->can_throw)))){
TRY((((*this).error((ByteString::must_from_utf8("Set initialization needs to be in a try statement or a function marked as throws"sv)),span))));
}
ids::TypeId inner_type_id = types::unknown_type_id();
JaktInternal::Optional<utility::Span> inner_type_span = JaktInternal::OptionalNone();
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> output = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedExpression>>::create_with({}))));
ids::StructId const set_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Set"sv))))));
JaktInternal::Optional<ids::TypeId> inner_hint = JaktInternal::OptionalNone();
JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const type_hint_ids = TRY((((*this).get_type_ids_from_type_hint_if_struct_ids_match(type_hint,set_struct_id))));
if (((type_hint_ids).has_value())){
(inner_hint = (((type_hint_ids.value()))[static_cast<i64>(0LL)]));
}
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedExpression> value = (_magic_value.value());
{
NonnullRefPtr<typename types::CheckedExpression> const checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
ids::TypeId const current_value_type_id = ((checked_value)->type());
if (((inner_type_id).equals(types::unknown_type_id()))){
if ((((current_value_type_id).equals(types::void_type_id())) || ((current_value_type_id).equals(types::unknown_type_id())))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot create a set with values of type void"sv)),((value)->span())))));
}
(inner_type_id = current_value_type_id);
(inner_type_span = ((value)->span()));
}
else if ((!(((inner_type_id).equals(current_value_type_id))))){
ByteString const set_type_name = TRY((((*this).type_name(inner_type_id,false))));
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type '{}' does not match type '{}' of previous values in set"sv)),TRY((((*this).type_name(current_value_type_id,false)))),set_type_name))),((value)->span()),TRY((__jakt_format((StringView::from_string_literal("Set was inferred to store type '{}' here"sv)),set_type_name))),(inner_type_span.value())))));
}
TRY((((output).push(checked_value))));
}

}
}

if (((inner_type_id).equals(types::unknown_type_id()))){
if (((inner_hint).has_value())){
(inner_type_id = (inner_hint.value()));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot infer generic type for Set<T>"sv)),span))));
}

}
if ((!(((inner_type_id).equals(types::unknown_type_id()))))){
TRY((((*this).ensure_type_implements_trait(inner_type_id,(ByteString::must_from_utf8("Hashable"sv)),JaktInternal::OptionalNone(),scope_id,span))));
TRY((((*this).ensure_type_implements_trait(inner_type_id,(ByteString::must_from_utf8("Equal"sv)),(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id})))),scope_id,span))));
}
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),set_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id})))))))))));
return TRY((types::CheckedExpression::JaktSet(JaktInternal::OptionalNone(),output,span,type_id,inner_type_id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_methods_predecl(parser::ParsedRecord const parsed_record,ids::StructId const struct_id,ids::ScopeId const scope_id,bool const comptime_pass,bool const generic_pass) {
{
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(true))));
ScopeGuard __jakt_var_436([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(struct_type_id))));
ScopeGuard __jakt_var_437([&] {
(((*this).self_type_id) = old_self_type_id);
});
ids::ScopeId const struct_scope_id = ((((((((*this).current_module()))->structures))[((struct_id).id)])).scope_id);
NonnullRefPtr<types::Module> module = ((*this).current_module());
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((((((method).parsed_function)).is_comptime)) != (comptime_pass))){
continue;
}
if (((generic_pass) != ((!(((((((method).parsed_function)).generic_parameters)).is_empty())))))){
continue;
}
ids::FunctionId const function_id = TRY((((*this).typecheck_function_predecl(((method).parsed_function),struct_scope_id,struct_type_id,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
NonnullRefPtr<types::CheckedFunction> checked_function = ((*this).get_function(function_id));
(((checked_function)->is_override) = ((method).is_override));
(((checked_function)->is_virtual) = ((method).is_virtual));
(((checked_function)->visibility) = TRY((((*this).typecheck_visibility(((method).visibility),struct_scope_id)))));
if ((((checked_function)->is_virtual) && TRY((((checked_function)->is_static()))))){
TRY((((*this).error((ByteString::must_from_utf8("Functions cannot be both virtual and static"sv)),((checked_function)->name_span)))));
}
if ((((checked_function)->is_override) && TRY((((checked_function)->is_static()))))){
TRY((((*this).error((ByteString::must_from_utf8("Functions cannot be both override and static"sv)),((checked_function)->name_span)))));
}
}

}
}

if (((!(comptime_pass)) && ((((parsed_record).implements_list)).has_value()))){
TRY((((*this).fill_trait_implementation_list((((parsed_record).implements_list).value()),((((((((module)->structures))[((struct_id).id)])).trait_implementations))),struct_scope_id,JaktInternal::OptionalNone()))));
{
JaktInternal::ArrayIterator<parser::ParsedNameWithGenericParameters> _magic = (((((parsed_record).implements_list).value())).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedNameWithGenericParameters> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNameWithGenericParameters implements_entry = (_magic_value.value());
{
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((*this).find_trait_in_scope(scope_id,((implements_entry).name)))));
if (((trait_id).has_value())){
NonnullRefPtr<types::CheckedTrait> const trait_ = ((((((((((*this).program))->modules))[(((((trait_id.value())).module)).id)]))->traits))[(((trait_id.value())).id)]);
if (((((trait_)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = (((trait_)->requirements)).as.Methods.value;
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> name__function_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__name__function_id__ = name__function_id__;
ByteString const name = ((jakt__name__function_id__).template get<0>());
ids::FunctionId const function_id = ((jakt__name__function_id__).template get<1>());

if (((TRY((((*this).find_functions_with_name_in_scope(struct_scope_id,name,JaktInternal::OptionalNone()))))).has_value())){
continue;
}
NonnullRefPtr<types::CheckedFunction> const function = ((((((((((*this).program))->modules))[((((function_id).module)).id)]))->functions))[((function_id).id)]);
if (((((((function)->block)).statements)).is_empty())){
continue;
}
TRY((((*this).add_function_to_scope(struct_scope_id,name,(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((implements_entry).name_span)))));
}

}
}

}
else {
continue;
}

}
else {
continue;
}

}

}
}

}
}
return {};
}

ErrorOr<JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>>> typechecker::Typechecker::find_functions_with_name_in_scope(ids::ScopeId const parent_scope_id,ByteString const function_name,JaktInternal::Optional<ids::ScopeId> const root_scope_id) const {
{
return TRY((((((*this).program))->find_functions_with_name_in_scope(parent_scope_id,function_name,false,JaktInternal::OptionalNone()))));
}
}

bool typechecker::Typechecker::is_class(ids::TypeId const type_id) const {
{
if (((((*this).get_type(type_id)))->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const struct_id = (((*this).get_type(type_id)))->as.Struct.value;
return ((((((*this).get_struct(struct_id))).record_type)).__jakt_init_index() == 1 /* Class */);
}
else {
return false;
}

}
}

ErrorOr<types::CheckedVisibility> typechecker::Typechecker::typecheck_visibility(parser::Visibility const visibility,ids::ScopeId const scope_id) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedVisibility, ErrorOr<types::CheckedVisibility>>{
auto&& __jakt_match_variant = visibility;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Private */: {
return JaktInternal::ExplicitValue(types::CheckedVisibility::Private());
};/*case end*/
case 0 /* Public */: {
return JaktInternal::ExplicitValue(types::CheckedVisibility::Public());
};/*case end*/
case 2 /* Restricted */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Restricted;JaktInternal::DynamicArray<parser::VisibilityRestriction> const& whitelist = __jakt_match_value.whitelist;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedVisibility> __jakt_var_438; {
JaktInternal::DynamicArray<NonnullRefPtr<typename types::MaybeResolvedScope>> restricted_scopes = (TRY((DynamicArray<NonnullRefPtr<typename types::MaybeResolvedScope>>::create_with({}))));
{
JaktInternal::ArrayIterator<parser::VisibilityRestriction> _magic = ((whitelist).iterator());
for (;;){
JaktInternal::Optional<parser::VisibilityRestriction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::VisibilityRestriction entry = (_magic_value.value());
{
NonnullRefPtr<typename types::MaybeResolvedScope> parent_scope = TRY((types::MaybeResolvedScope::Resolved(scope_id)));
{
JaktInternal::ArrayIterator<ByteString> _magic = ((((entry).namespace_)).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString ns = (_magic_value.value());
{
(parent_scope = TRY((types::MaybeResolvedScope::Unresolved(parent_scope,ns))));
}

}
}

NonnullRefPtr<typename types::MaybeResolvedScope> unresolved = TRY((types::MaybeResolvedScope::Unresolved(parent_scope,((entry).name))));
TRY((((restricted_scopes).push(TRY((((unresolved)->try_resolve(((*this).program)))))))));
}

}
}

__jakt_var_438 = types::CheckedVisibility::Restricted(restricted_scopes,span); goto __jakt_label_410;

}
__jakt_label_410:; __jakt_var_438.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<types::Value>> typechecker::Typechecker::find_comptime_binding_in_scope(ids::ScopeId const scope_id,ByteString const name) const {
{
return TRY((((((*this).program))->find_comptime_binding_in_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_try_block(NonnullRefPtr<typename parser::ParsedStatement> const stmt,ByteString const error_name,utility::Span const error_span,parser::ParsedBlock const catch_block,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
ids::ScopeId const try_scope_id = TRY((((*this).create_scope(scope_id,true,(ByteString::must_from_utf8("try"sv)),true))));
NonnullRefPtr<typename types::CheckedStatement> const checked_stmt = TRY((((*this).typecheck_statement(stmt,try_scope_id,safety_mode,JaktInternal::OptionalNone()))));
ids::StructId const error_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Error"sv))))));
NonnullRefPtr<types::CheckedVariable> const error_decl = TRY((types::CheckedVariable::__jakt_create(error_name,((((*this).get_struct(error_struct_id))).type_id),false,error_span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const error_id = TRY((((module)->add_variable(error_decl))));
NonnullRefPtr<types::Scope> const parent_scope = TRY((((*this).get_scope(scope_id))));
ids::ScopeId const catch_scope_id = TRY((((*this).create_scope(scope_id,((parent_scope)->can_throw),(ByteString::must_from_utf8("catch"sv)),true))));
TRY((((*this).add_var_to_scope(catch_scope_id,error_name,error_id,error_span))));
types::CheckedBlock const checked_catch_block = TRY((((*this).typecheck_block(catch_block,catch_scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((((checked_catch_block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("A ‘catch’ block as part of a try block is not allowed to yield values"sv)),(((catch_block).find_yield_span()).value())))));
}
return TRY((types::CheckedExpression::TryBlock(JaktInternal::OptionalNone(),checked_stmt,checked_catch_block,error_name,error_span,span,types::void_type_id())));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_trait(parser::ParsedTrait const parsed_trait,ids::TraitId const trait_id,ids::ScopeId const scope_id,bool const comptime_pass) {
{
NonnullRefPtr<types::CheckedTrait> checked_trait = ((((((((((*this).program))->modules))[((((trait_id).module)).id)]))->traits))[((trait_id).id)]);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(TRY((((*this).find_or_add_type_id(TRY((types::Type::Trait(parser::CheckedQualifiers(false),trait_id)))))))))));
ScopeGuard __jakt_var_439([&] {
(((*this).self_type_id) = old_self_type_id);
});
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_trait).requirements);
switch(__jakt_match_variant.__jakt_init_index()) {
case 2 /* ComptimeExpression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ComptimeExpression;NonnullRefPtr<typename parser::ParsedExpression> const& expression = __jakt_match_value.value;
{
if (comptime_pass){
NonnullRefPtr<typename types::CheckedExpression> const checked_expression = TRY((((*this).typecheck_expression(expression,((checked_trait)->scope_id),types::SafetyMode::Safe(),types::builtin(types::BuiltinType::Bool())))));
(((checked_trait)->requirements) = types::CheckedTraitRequirements::ComptimeExpression(checked_expression));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_constructor(parser::ParsedRecord const parsed_record,ids::EnumId const enum_id,ids::ScopeId const parent_scope_id) {
{
u64 next_constant_value = static_cast<u64>(0ULL);
JaktInternal::Set<ByteString> seen_names = (TRY((Set<ByteString>::create_with_values({}))));
types::CheckedEnum enum_ = ((*this).get_enum(enum_id));
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(((enum_).type_id)))));
ScopeGuard __jakt_var_440([&] {
(((*this).self_type_id) = old_self_type_id);
});
JaktInternal::Set<ByteString> common_seen_fields = (TRY((Set<ByteString>::create_with_values({}))));
JaktInternal::DynamicArray<ids::VarId> common_fields = (TRY((DynamicArray<ids::VarId>::create_with({}))));
JaktInternal::DynamicArray<types::CheckedParameter> common_params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((enum_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const variable = ((*this).get_variable(((field).variable_id)));
TRY((((common_params).push(types::CheckedParameter(true,variable,((field).default_value_expression))))));
TRY((((common_seen_fields).add(((variable)->name)))));
TRY((((common_fields).push(((field).variable_id)))));
}

}
}

({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 2 /* ValueEnum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ValueEnum;NonnullRefPtr<typename parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
JaktInternal::DynamicArray<parser::ValueEnumVariant> const& variants = __jakt_match_value.variants;
{
ids::TypeId const underlying_type_id = TRY((((*this).typecheck_typename(underlying_type,parent_scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<types::Module> module = ((*this).current_module());
{
JaktInternal::ArrayIterator<parser::ValueEnumVariant> _magic = ((variants).iterator());
for (;;){
JaktInternal::Optional<parser::ValueEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ValueEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant '{}' is defined more than once"sv)),((variant).name)))),((variant).span)))));
}
else {
TRY((((seen_names).add(((variant).name)))));
NonnullRefPtr<typename types::CheckedExpression> const expr = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>,ErrorOr<void>>{
auto __jakt_enum_value = (((((variant).value)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_441; {
NonnullRefPtr<typename types::CheckedExpression> const value_expression = TRY((((*this).cast_to_underlying((((variant).value).value()),parent_scope_id,underlying_type))));
JaktInternal::Optional<types::NumberConstant> const number_constant = ((value_expression)->to_number_constant(((*this).program)));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<void>>{
auto __jakt_enum_value = (((number_constant).has_value()));
if (__jakt_enum_value == true) {
{
(next_constant_value = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<u64, ErrorOr<void>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Signed */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Signed;i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<u64>((JaktInternal::checked_add(val,static_cast<i64>(1LL))))));
};/*case end*/
case 1 /* Unsigned */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Unsigned;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JaktInternal::checked_add(val,static_cast<u64>(1ULL)));
};/*case end*/
case 2 /* Floating */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Floating;f64 const& val = __jakt_match_value.value;
{
utility::todo((ByteString::must_from_utf8("Implement floats"sv)));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
}));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant '{}' in enum '{}' has a non-constant value: {}"sv)),((variant).name),((enum_).name),value_expression))),((variant).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
});
__jakt_var_441 = value_expression; goto __jakt_label_411;

}
__jakt_label_411:; __jakt_var_441.release_value(); }));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(TRY((((*this).cast_to_underlying(TRY((parser::ParsedExpression::NumericConstant(parser::NumericConstant::U64(((next_constant_value++))),((variant).span)))),parent_scope_id,underlying_type)))));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((((enum_).variants)).push(types::CheckedEnumVariant::WithValue(enum_id,((variant).name),expr,((variant).span))))));
ids::VarId const var_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create(((variant).name),((enum_).type_id),false,((variant).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))))));
TRY((((*this).add_var_to_scope(((enum_).scope_id),((variant).name),var_id,((variant).span)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3 /* SumEnum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.SumEnum;bool const& is_boxed = __jakt_match_value.is_boxed;
JaktInternal::DynamicArray<parser::SumEnumVariant> const& variants = __jakt_match_value.variants;
{
NonnullRefPtr<types::Module> module = ((*this).current_module());
{
JaktInternal::ArrayIterator<parser::SumEnumVariant> _magic = ((variants).iterator());
for (;;){
JaktInternal::Optional<parser::SumEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::SumEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant '{}' is defined more than once"sv)),((variant).name)))),((variant).span)))));
continue;
}
TRY((((seen_names).add(((variant).name)))));
bool const is_structlike = ((((((variant).params)).has_value()) && [](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
((((((variant).params).value())).size()),static_cast<size_t>(0ULL))) && [](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
((((((((variant).params).value()))[static_cast<i64>(0LL)])).name),(ByteString::must_from_utf8(""sv))));
bool const is_typed = ((((((variant).params)).has_value()) && (((((((variant).params).value())).size())) == (static_cast<size_t>(1ULL)))) && (((((((((variant).params).value()))[static_cast<i64>(0LL)])).name)) == ((ByteString::must_from_utf8(""sv)))));
if (is_structlike){
JaktInternal::Set<ByteString> seen_fields = (TRY((Set<ByteString>::create_with_values({}))));
{
JaktInternal::SetIterator<ByteString> _magic = ((common_seen_fields).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString name = (_magic_value.value());
{
TRY((((seen_fields).add(name))));
}

}
}

JaktInternal::DynamicArray<types::CheckedParameter> params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((common_params).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((params).push(param))));
}

}
}

JaktInternal::DynamicArray<ids::VarId> fields = (TRY((DynamicArray<ids::VarId>::create_with({}))));
{
JaktInternal::ArrayIterator<ids::VarId> _magic = ((common_fields).iterator());
for (;;){
JaktInternal::Optional<ids::VarId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::VarId field = (_magic_value.value());
{
TRY((((fields).push(field))));
}

}
}

if (((((variant).params)).has_value())){
JaktInternal::DynamicArray<parser::ParsedVarDecl> const variant_params = (((variant).params).value());
if (((((variant).default_values)).has_value())){
JaktInternal::DynamicArray<JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>>> const variant_default_values = (((variant).default_values).value());
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((variant_params).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedVarDecl const param = ((variant_params)[i]);
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const default_value = ((variant_default_values)[i]);
if (((seen_fields).contains(((param).name)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant '{}' has a member named '{}' more than once"sv)),((variant).name),((param).name)))),((param).span)))));
continue;
}
TRY((((seen_fields).add(((param).name)))));
ids::TypeId const type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
NonnullRefPtr<types::CheckedVariable> const checked_var = TRY((types::CheckedVariable::__jakt_create(((param).name),type_id,((param).is_mutable),((param).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
TRY((((params).push(types::CheckedParameter(true,checked_var,({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>,ErrorOr<void>>{
auto __jakt_enum_value = (((default_value).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((Tuple{(default_value.value()), ((enum_).scope_id)}));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
}))))));
if ((((*this).dump_type_hints) && ((((param).parsed_type))->__jakt_init_index() == 15 /* Empty */))){
TRY((((*this).dump_type_hint(type_id,((param).span)))));
}
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const var_id = TRY((((module)->add_variable(checked_var))));
TRY((((fields).push(var_id))));
}

}
}

}
}
TRY((((((enum_).variants)).push(types::CheckedEnumVariant::StructLike(enum_id,((variant).name),fields,((variant).span))))));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const maybe_enum_variant_constructor = TRY((((*this).find_functions_with_name_in_scope(((enum_).scope_id),((variant).name),JaktInternal::OptionalNone()))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
bool const can_function_throw = is_boxed;
ids::ScopeId const function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor({}::{})"sv)),((enum_).name),((variant).name)))),true))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor-block({}::{})"sv)),((enum_).name),((variant).name)))),true))));
NonnullRefPtr<types::CheckedFunction> const checked_function = TRY((types::CheckedFunction::__jakt_create(((variant).name),((variant).span),types::CheckedVisibility::Public(),TRY((((*this).find_or_add_type_id(TRY((types::Type::Enum(parser::CheckedQualifiers(false),enum_id))))))),JaktInternal::OptionalNone(),params,TRY((types::FunctionGenerics::__jakt_create(function_scope_id,params,(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::MayReturn(),ids::TypeId::none(),false),can_function_throw,parser::FunctionType::ImplicitEnumConstructor(),parser::FunctionLinkage::Internal(),function_scope_id,JaktInternal::OptionalNone(),true,JaktInternal::OptionalNone(),false,false,false,false,false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
ids::FunctionId const function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((variant).span)))));
}
}
else if (is_typed){
JaktInternal::DynamicArray<types::CheckedParameter> params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((common_params).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((params).push(param))));
}

}
}

parser::ParsedVarDecl const param = (((((variant).params).value()))[static_cast<i64>(0LL)]);
ids::TypeId const type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
TRY((((((enum_).variants)).push(types::CheckedEnumVariant::Typed(enum_id,((variant).name),type_id,((variant).span))))));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const maybe_enum_variant_constructor = TRY((((*this).find_functions_with_name_in_scope(((enum_).scope_id),((variant).name),JaktInternal::OptionalNone()))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
bool const can_function_throw = is_boxed;
ids::ScopeId const function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor({}::{})"sv)),((enum_).name),((variant).name)))),true))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor-block({}::{})"sv)),((enum_).name),((variant).name)))),true))));
NonnullRefPtr<types::CheckedVariable> const variable = TRY((types::CheckedVariable::__jakt_create((ByteString::must_from_utf8("value"sv)),type_id,false,((param).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
TRY((((params).push(types::CheckedParameter(false,variable,JaktInternal::OptionalNone())))));
NonnullRefPtr<types::CheckedFunction> const checked_function = TRY((types::CheckedFunction::__jakt_create(((variant).name),((variant).span),types::CheckedVisibility::Public(),TRY((((*this).find_or_add_type_id(TRY((types::Type::Enum(parser::CheckedQualifiers(false),enum_id))))))),JaktInternal::OptionalNone(),params,TRY((types::FunctionGenerics::__jakt_create(function_scope_id,params,(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::AlwaysReturns(),ids::TypeId::none(),false),can_function_throw,parser::FunctionType::ImplicitEnumConstructor(),parser::FunctionLinkage::Internal(),function_scope_id,JaktInternal::OptionalNone(),true,JaktInternal::OptionalNone(),false,false,false,false,false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
ids::FunctionId const function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((variant).span)))));
}
}
else {
JaktInternal::DynamicArray<types::CheckedParameter> params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((common_params).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((params).push(param))));
}

}
}

TRY((((((enum_).variants)).push(types::CheckedEnumVariant::Untyped(enum_id,((variant).name),((variant).span))))));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const maybe_enum_variant_constructor = TRY((((*this).find_functions_with_name_in_scope(((enum_).scope_id),((variant).name),JaktInternal::OptionalNone()))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
bool const can_function_throw = is_boxed;
ids::ScopeId const function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor({}::{})"sv)),((enum_).name),((variant).name)))),true))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((__jakt_format((StringView::from_string_literal("enum-variant-constructor-block({}::{})"sv)),((enum_).name),((variant).name)))),true))));
NonnullRefPtr<types::CheckedFunction> const checked_function = TRY((types::CheckedFunction::__jakt_create(((variant).name),((variant).span),types::CheckedVisibility::Public(),TRY((((*this).find_or_add_type_id(TRY((types::Type::Enum(parser::CheckedQualifiers(false),enum_id))))))),JaktInternal::OptionalNone(),params,TRY((types::FunctionGenerics::__jakt_create(function_scope_id,params,(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::AlwaysReturns(),ids::TypeId::none(),false),can_function_throw,parser::FunctionType::ImplicitEnumConstructor(),parser::FunctionLinkage::Internal(),function_scope_id,JaktInternal::OptionalNone(),true,JaktInternal::OptionalNone(),false,false,false,false,false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
ids::FunctionId const function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((variant).span)))));
}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<typechecker::FunctionMatchResult> typechecker::Typechecker::match_function_and_resolve_args(parser::ParsedCall const call,ids::ScopeId const caller_scope_id,ids::FunctionId const candidate,types::SafetyMode const safety_mode,utility::Span const span,JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const this_expr) {
{
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> args = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedExpression>>::create_with({}))));
JaktInternal::Optional<ids::TypeId> maybe_this_type_id = JaktInternal::OptionalNone();
JaktInternal::DynamicArray<error::JaktError> argument_errors = (TRY((DynamicArray<error::JaktError>::create_with({}))));
size_t const num_old_compiler_errors = ((((((*this).compiler))->errors)).size());
NonnullRefPtr<types::CheckedFunction> const callee_candidate = ((*this).get_function(candidate));
ids::ScopeId const scope_containing_callee = (((TRY((((*this).get_scope(((callee_candidate)->function_scope_id))))))->parent).value());
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const generic_inference_checkpoint = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
if (((callee_candidate)->is_instantiated)){
TRY((((((*this).generic_inferences)).perform_checkpoint(true))));
}
ScopeGuard __jakt_var_442([&] {
{
((((*this).generic_inferences)).restore(generic_inference_checkpoint));
}

});
if (((((callee_candidate)->type)).__jakt_init_index() == 2 /* ImplicitConstructor */)){
types::CheckedStruct const struct_ = ((*this).get_struct((((callee_candidate)->struct_id).value())));
TRY((((*this).check_implicit_constructor_argument_access(caller_scope_id,call,struct_))));
}
else {
TRY((((*this).check_method_access(caller_scope_id,scope_containing_callee,callee_candidate,span))));
}

size_t type_arg_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> parsed_type = (_magic_value.value());
{
ids::TypeId const checked_type = TRY((((*this).typecheck_typename(parsed_type,caller_scope_id,JaktInternal::OptionalNone()))));
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((((((callee_candidate)->generics))->params)).size()),type_arg_index)){
TRY((((*this).error((ByteString::must_from_utf8("Trying to access generic parameter out of bounds"sv)),((parsed_type)->span())))));
continue;
}
ids::TypeId const typevar_type_id = ((((((((callee_candidate)->generics))->params))[type_arg_index])).type_id());
if ((!(((typevar_type_id).equals(checked_type))))){
TRY((((((*this).generic_inferences)).set(typevar_type_id,checked_type))));
}
((type_arg_index) += (static_cast<size_t>(1ULL)));
}

}
}

size_t arg_offset = static_cast<size_t>(0ULL);
if (((this_expr).has_value())){
ids::TypeId const type_id = (((this_expr.value()))->type());
(maybe_this_type_id = type_id);
NonnullRefPtr<typename types::Type> const param_type = ((*this).get_type(type_id));
if (((param_type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (param_type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (param_type)->as.GenericInstance.args;
types::CheckedStruct const structure = ((*this).get_struct(id));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((structure).generic_parameters)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (((((((((structure).generic_parameters))[i])).type_id)).equals(((args)[i])))){
continue;
}
TRY((((((*this).generic_inferences)).set(((((((structure).generic_parameters))[i])).type_id),((args)[i])))));
}

}
}

}
if (TRY((((callee_candidate)->is_static())))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot call static method on an instance of an object"sv)),span))));
}
else {
(arg_offset = static_cast<size_t>(1ULL));
}

if ((TRY((((callee_candidate)->is_mutating()))) && (!((((this_expr.value()))->is_mutable(((*this).program))))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating method on an immutable object instance"sv)),span))));
}
}
else if ((!(TRY((((callee_candidate)->is_static())))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Cannot call an instance method statically"sv)),span,(ByteString::must_from_utf8("Add a dot before the method name to call an instance method"sv)),span))));
}
i64 total_function_specificity = static_cast<i64>(0LL);
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>> const resolved_args = TRY((((*this).resolve_default_params(((((callee_candidate)->generics))->base_params),((callee_candidate)->has_varargs),((call).args),caller_scope_id,safety_mode,arg_offset,span))));
JaktInternal::DynamicArray<ids::TypeId> params_to_compare = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
bool is_specialized_comptime_function = false;
if ((((callee_candidate)->is_comptime) && ((((callee_candidate)->specialization_index)).has_value()))){
size_t const index = (((callee_candidate)->specialization_index).value());
(params_to_compare = ((((((callee_candidate)->generics))->specializations))[index]));
(is_specialized_comptime_function = true);
}
else {
TRY((((params_to_compare).ensure_capacity(((((((callee_candidate)->generics))->base_params)).size())))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((((callee_candidate)->generics))->base_params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((params_to_compare).push(((((param).variable))->type_id)))));
}

}
}

}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((params_to_compare).size()),JaktInternal::checked_add(((resolved_args).size()),arg_offset))){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(JaktInternal::checked_sub(((params_to_compare).size()),arg_offset))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>> const name_span_checked_arg_ = ((resolved_args)[i]);
ByteString const name = ((name_span_checked_arg_).template get<0>());
utility::Span const span = ((name_span_checked_arg_).template get<1>());
NonnullRefPtr<typename types::CheckedExpression> const checked_arg = ((name_span_checked_arg_).template get<2>());

NonnullRefPtr<typename types::Type> const type_to = ((*this).get_type(((params_to_compare)[JaktInternal::checked_add(i,arg_offset)])));
((total_function_specificity) += (((type_to)->specificity(((*this).program),(static_cast<i64>(1LL) << static_cast<i64>(31LL))))));
if (is_specialized_comptime_function){
TRY((((*this).check_types_for_compat(((((((((((callee_candidate)->generics))->base_params))[JaktInternal::checked_add(i,arg_offset)])).variable))->type_id),((checked_arg)->type()),((((*this).generic_inferences))),((checked_arg)->span())))));
}
TRY((((*this).check_types_for_compat(((params_to_compare)[JaktInternal::checked_add(i,arg_offset)]),((checked_arg)->type()),((((*this).generic_inferences))),((checked_arg)->span())))));
TRY((((args).push(checked_arg))));
}

}
}

if (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((params_to_compare).size()),JaktInternal::checked_add(((resolved_args).size()),arg_offset)) && ((callee_candidate)->has_varargs))){
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>> _magic = ((((resolved_args)[(JaktInternal::Range<size_t>{static_cast<size_t>(JaktInternal::checked_sub(((params_to_compare).size()),arg_offset)),static_cast<size_t>(9223372036854775807LL)})])).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((args).push(((arg).template get<2>())))));
}

}
}

}
}
size_t const num_match_errors = JaktInternal::checked_sub(((((((*this).compiler))->errors)).size()),num_old_compiler_errors);
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(num_match_errors,static_cast<size_t>(0ULL))){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(num_match_errors)});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t error_index = (_magic_value.value());
{
TRY((((argument_errors).push((((((((*this).compiler))->errors)).pop()).value())))));
}

}
}

return typechecker::FunctionMatchResult::MatchError(argument_errors);
}
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const used_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
if (is_specialized_comptime_function){
((total_function_specificity) += (static_cast<i64>(1LL)));
((total_function_specificity) *= (static_cast<i64>(2LL)));
}
return typechecker::FunctionMatchResult::MatchSuccess(args,maybe_this_type_id,used_inferences,total_function_specificity);
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::unify_with_type(ids::TypeId const found_type,JaktInternal::Optional<ids::TypeId> const expected_type,utility::Span const span) {
{
if ((!(((expected_type).has_value())))){
return found_type;
}
if ((((expected_type.value())).equals(types::unknown_type_id()))){
return found_type;
}
if (TRY((((*this).check_types_for_compat((expected_type.value()),found_type,((((*this).generic_inferences))),span))))){
return found_type;
}
return TRY((((*this).substitute_typevars_in_type(found_type,((*this).generic_inferences)))));
}
}

ErrorOr<ids::StructId> typechecker::Typechecker::find_struct_in_prelude(ByteString const name) const {
{
return TRY((((((*this).program))->find_struct_in_prelude(name))));
}
}

bool typechecker::Typechecker::is_numeric(ids::TypeId const type_id) const {
{
return ((((*this).program))->is_numeric(type_id));
}
}

ErrorOr<ByteString> typechecker::Typechecker::debug_description_of(ids::ScopeId const scope_id) const {
{
JaktInternal::DynamicArray<ByteString> ss = (TRY((DynamicArray<ByteString>::create_with({}))));
ids::ScopeId current_scope_id = scope_id;
for (;;){
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(current_scope_id))));
ByteString const d = TRY((__jakt_format((StringView::from_string_literal("{} (named {})"sv)),((scope)->debug_name),((scope)->namespace_name))));
TRY((((ss).insert(static_cast<size_t>(0ULL),d))));
if (((((scope)->parent)).has_value())){
(current_scope_id = (((scope)->parent).value()));
}
else {
break;
}

}
return TRY((utility::join(ss,(ByteString::must_from_utf8(" -> "sv)))));
}
}

types::CheckedStruct typechecker::Typechecker::get_struct(ids::StructId const id) const {
{
return ((((*this).program))->get_struct(id));
}
}

types::CheckedEnum typechecker::Typechecker::get_enum(ids::EnumId const id) const {
{
return ((((*this).program))->get_enum(id));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::dereference_if_needed(NonnullRefPtr<typename types::CheckedExpression> const checked_expr,utility::Span const span) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((checked_expr)->type())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 28 /* Reference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reference;ids::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,types::CheckedUnaryOperator::Dereference(),span,type_id))));
};/*case end*/
case 29 /* MutableReference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MutableReference;ids::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,types::CheckedUnaryOperator::Dereference(),span,type_id))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(checked_expr);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<void> typechecker::Typechecker::dump_type_hint(ids::TypeId const type_id,utility::Span const span) const {
{
outln((StringView::from_string_literal("{{\"type\":\"hint\",\"file_id\":{},\"position\":{},\"typename\":\"{}\"}}"sv)),((((span).file_id)).id),((span).end),TRY((((*this).type_name(type_id,false)))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_entity_trait_implementations(ids::ScopeId const scope_id,ids::TypeId const type_id,JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const trait_implementations,ByteString const name,utility::Span const name_span) {
{
typechecker::TraitImplCheck checks = TRY((typechecker::TraitImplCheck::make()));
TRY((((checks).ensure_capacity(((trait_implementations).size())))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((trait_implementations).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> trait_name__trait_ids_and_generic_params__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt__trait_name__trait_ids_and_generic_params__ = trait_name__trait_ids_and_generic_params__;
ByteString const trait_name = ((jakt__trait_name__trait_ids_and_generic_params__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_ids_and_generic_params = ((jakt__trait_name__trait_ids_and_generic_params__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_ids_and_generic_params).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_id_and_generic_params = (_magic_value.value());
{
TRY((((checks).register_trait(TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericTraitInstance(parser::CheckedQualifiers(false),((trait_id_and_generic_params).template get<0>()),((trait_id_and_generic_params).template get<1>())))))))),trait_name,((((((*this).program))->get_trait(((trait_id_and_generic_params).template get<0>()))))->requirements)))));
}

}
}

}

}
}

{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((trait_implementations).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> trait_name__trait_ids_and_generic_params__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt__trait_name__trait_ids_and_generic_params__ = trait_name__trait_ids_and_generic_params__;
ByteString const trait_name = ((jakt__trait_name__trait_ids_and_generic_params__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_ids_and_generic_params = ((jakt__trait_name__trait_ids_and_generic_params__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_ids_and_generic_params).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_id_and_generic_params = (_magic_value.value());
{
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_443([&] {
((((*this).generic_inferences)).restore(old_generic_inferences));
});
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> const trait_id_generic_params_ = trait_id_and_generic_params;
ids::TraitId const trait_id = ((trait_id_generic_params_).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const generic_params = ((trait_id_generic_params_).template get<1>());

NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(trait_id));
if (((((((trait_)->generic_parameters)).size())) != (((generic_params).size())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Trait ‘{}’ expects {} generic parameters, but {} were given"sv)),trait_name,((((trait_)->generic_parameters)).size()),((generic_params).size())))),((trait_)->name_span)))));
continue;
}
TRY((((*this).specialize_trait(trait_id,generic_params))));
if (((((trait_)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = (((trait_)->requirements)).as.Methods.value;
TRY((((((*this).generic_inferences)).set_all(((trait_)->generic_parameters),generic_params))));
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> method_name__method_function_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__method_name__method_function_id__ = method_name__method_function_id__;
ByteString const method_name = ((jakt__method_name__method_function_id__).template get<0>());
ids::FunctionId const method_function_id = ((jakt__method_name__method_function_id__).template get<1>());

NonnullRefPtr<types::CheckedFunction> const method = ((*this).get_function(method_function_id));
if (((!(((((method)->parsed_function)).has_value()))) || (((((((((method)->parsed_function).value())).block)).stmts)).is_empty()))){
continue;
}
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const ids = TRY((((*this).find_functions_with_name_in_scope(scope_id,method_name,JaktInternal::OptionalNone()))));
JaktInternal::Optional<ids::FunctionId> this_function = JaktInternal::OptionalNone();
if (((ids).has_value())){
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = (((ids.value())).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId id = (_magic_value.value());
{
if (((((((((*this).get_function(id)))->parsed_function)).map([](auto& _value) { return _value.id; }))) == (((((method)->parsed_function)).map([](auto& _value) { return _value.id; }))))){
(this_function = id);
break;
}
}

}
}

if ((!(((this_function).has_value())))){
continue;
}
}
if ((((this_function).has_value()) && ((((*this).get_function((this_function.value()))))->is_fully_checked))){
continue;
}
TRY((((*this).typecheck_function((((method)->parsed_function).value()),scope_id))));
}

}
}

}
else {
continue;
}

}

}
}

}

}
}

NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> _magic = ((((scope)->functions)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> name__overload_set__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> const jakt__name__overload_set__ = name__overload_set__;
ByteString const name = ((jakt__name__overload_set__).template get<0>());
JaktInternal::DynamicArray<ids::FunctionId> const overload_set = ((jakt__name__overload_set__).template get<1>());

{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((overload_set).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId function_id = (_magic_value.value());
{
TRY((((checks).register_method(type_id,name,function_id,((*this))))));
}

}
}

}

}
}

TRY((((checks).throw_errors(name_span,((*this))))));
}
return {};
}

ErrorOr<JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> typechecker::Typechecker::fill_trait_implementation_list(JaktInternal::DynamicArray<parser::ParsedNameWithGenericParameters> const parsed_impl_list,JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>& trait_implementations,ids::ScopeId const scope_id,JaktInternal::Optional<ids::ScopeId> const trait_name_scope_id_override) {
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> result = (TRY((DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>::create_with({}))));
ids::ScopeId type_scope = scope_id;
if (((trait_name_scope_id_override).has_value())){
ids::ScopeId const id = (trait_name_scope_id_override.value());
ids::ScopeId const aliased_scope_id = TRY((((*this).create_scope(id,false,TRY((__jakt_format((StringView::from_string_literal("trait-alias-mixin({})"sv)),((TRY((((*this).get_scope(id)))))->debug_name)))),false))));
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((((scope)->resolution_mixins)).push(aliased_scope_id))));
}
ids::ScopeId const trait_name_scope_id = trait_name_scope_id_override.value_or_lazy_evaluated([&] { return scope_id; });
{
JaktInternal::ArrayIterator<parser::ParsedNameWithGenericParameters> _magic = ((parsed_impl_list).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedNameWithGenericParameters> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNameWithGenericParameters trait_name = (_magic_value.value());
{
JaktInternal::Optional<ids::TypeId> const maybe_type_id = TRY((((*this).find_type_in_scope(trait_name_scope_id,((trait_name).name)))));
if (((maybe_type_id).has_value())){
if (((((*this).get_type((maybe_type_id.value()))))->__jakt_init_index() == 27 /* Trait */)){
ids::TraitId const trait_id = (((*this).get_type((maybe_type_id.value()))))->as.Trait.value;
JaktInternal::DynamicArray<ids::TypeId> generic_arguments = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((((trait_name).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> argument = (_magic_value.value());
{
ids::TypeId const argument_type_id = TRY((((*this).typecheck_typename(argument,type_scope,JaktInternal::OptionalNone()))));
TRY((((generic_arguments).push(argument_type_id))));
}

}
}

JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> existing_list = ((((trait_implementations))).get(((trait_name).name)));
if (((existing_list).has_value())){
bool found = false;
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = (((existing_list.value())).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> id__args__ = (_magic_value.value());
{
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> const jakt__id__args__ = id__args__;
ids::TraitId const id = ((jakt__id__args__).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const args = ((jakt__id__args__).template get<1>());

if (((id).equals(trait_id))){
if (((((args).size())) != (((generic_arguments).size())))){
continue;
}
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((args).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (((((args)[i])).equals(((generic_arguments)[i])))){
}
else {
continue;
}

}

}
}

(found = true);
break;
}
else {
continue;
}

}

}
}

if ((!(found))){
TRY(((((existing_list.value())).push((Tuple{trait_id, generic_arguments})))));
}
}
else {
TRY((((((trait_implementations))).set(((trait_name).name),(TRY((DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>::create_with({(Tuple{trait_id, generic_arguments})}))))))));
}

TRY((((result).push((Tuple{trait_id, generic_arguments})))));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Expected ‘{}’ to be a trait"sv)),((trait_name).name)))),((trait_name).name_span)))));
continue;
}

}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Cannot find trait ‘{}’"sv)),((trait_name).name)))),((trait_name).name_span)))));
continue;
}

}

}
}

return result;
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_statement(NonnullRefPtr<typename parser::ParsedStatement> const statement,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedStatement>, ErrorOr<NonnullRefPtr<typename types::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Expression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Expression;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Expression(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,ids::TypeId::none())))),span))));
};/*case end*/
case 2 /* UnsafeBlock */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnsafeBlock;parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Block(TRY((((*this).typecheck_block(block,scope_id,types::SafetyMode::Unsafe(),JaktInternal::OptionalNone())))),span))));
};/*case end*/
case 14 /* Yield */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Yield;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Yield(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,type_hint)))),span))));
};/*case end*/
case 12 /* Return */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Return;JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_return(expr,span,scope_id,safety_mode)))));
};/*case end*/
case 6 /* Block */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Block;parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_block_statement(block,scope_id,safety_mode,span)))));
};/*case end*/
case 15 /* InlineCpp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.InlineCpp;parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_inline_cpp(block,span,safety_mode)))));
};/*case end*/
case 1 /* Defer */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Defer;NonnullRefPtr<typename parser::ParsedStatement> const& statement = __jakt_match_value.statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_defer(statement,scope_id,safety_mode,span)))));
};/*case end*/
case 7 /* Loop */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Loop;parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_loop(block,scope_id,safety_mode,span)))));
};/*case end*/
case 13 /* Throw */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Throw;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_throw(expr,scope_id,safety_mode,span)))));
};/*case end*/
case 8 /* While */: {
auto&& __jakt_match_value = __jakt_match_variant.as.While;NonnullRefPtr<typename parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_while(condition,block,scope_id,safety_mode,span)))));
};/*case end*/
case 11 /* Continue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Continue;utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Continue(span))));
};/*case end*/
case 10 /* Break */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Break;utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Break(span))));
};/*case end*/
case 4 /* VarDecl */: {
auto&& __jakt_match_value = __jakt_match_variant.as.VarDecl;parser::ParsedVarDecl const& var = __jakt_match_value.var;
NonnullRefPtr<typename parser::ParsedExpression> const& init = __jakt_match_value.init;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_var_decl(var,init,scope_id,safety_mode,span)))));
};/*case end*/
case 3 /* DestructuringAssignment */: {
auto&& __jakt_match_value = __jakt_match_variant.as.DestructuringAssignment;JaktInternal::DynamicArray<parser::ParsedVarDecl> const& vars = __jakt_match_value.vars;
NonnullRefPtr<typename parser::ParsedStatement> const& var_decl = __jakt_match_value.var_decl;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_destructuring_assignment(vars,var_decl,scope_id,safety_mode,span)))));
};/*case end*/
case 5 /* If */: {
auto&& __jakt_match_value = __jakt_match_variant.as.If;NonnullRefPtr<typename parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& then_block = __jakt_match_value.then_block;
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const& else_statement = __jakt_match_value.else_statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_if(condition,then_block,else_statement,scope_id,safety_mode,span)))));
};/*case end*/
case 17 /* Garbage */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Garbage;utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedStatement::Garbage(span))));
};/*case end*/
case 9 /* For */: {
auto&& __jakt_match_value = __jakt_match_variant.as.For;ByteString const& iterator_name = __jakt_match_value.iterator_name;
utility::Span const& name_span = __jakt_match_value.name_span;
bool const& is_destructuring = __jakt_match_value.is_destructuring;
NonnullRefPtr<typename parser::ParsedExpression> const& range = __jakt_match_value.range;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_for(iterator_name,name_span,is_destructuring,range,block,scope_id,safety_mode,span)))));
};/*case end*/
case 16 /* Guard */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Guard;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedBlock const& else_block = __jakt_match_value.else_block;
parser::ParsedBlock const& remaining_code = __jakt_match_value.remaining_code;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_guard(expr,else_block,remaining_code,scope_id,safety_mode,span)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_unary_negate(NonnullRefPtr<typename types::CheckedExpression> const expr,utility::Span const span,ids::TypeId const type_id) {
{
if (((!(((((*this).program))->is_integer(type_id)))) || ((((*this).program))->is_signed(type_id)))){
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),expr,types::CheckedUnaryOperator::Negate(),span,type_id)));
}
ids::TypeId const flipped_sign_type = TRY((((((*this).get_type(type_id)))->flip_signedness())));
types::CheckedNumericConstant const constant = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* NumericConstant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NumericConstant;types::CheckedNumericConstant const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(val);
};/*case end*/
default: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),expr,types::CheckedUnaryOperator::Negate(),span,type_id)));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
types::NumberConstant const number = (((constant).number_constant()).value());
size_t const raw_number = TRY((((number).to_usize())));
size_t const max_signed = (infallible_integer_cast<size_t>((((TRY((types::Type::I64(parser::CheckedQualifiers(false)))))->max()))));
i64 negated_number = static_cast<i64>(0LL);
if (((raw_number) == (JaktInternal::checked_add(max_signed,static_cast<size_t>(1ULL))))){
(negated_number = ((TRY((types::Type::I64(parser::CheckedQualifiers(false)))))->min()));
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(raw_number,max_signed)){
(negated_number = JaktInternal::checked_sub(static_cast<i64>(0LL),(infallible_integer_cast<i64>((raw_number)))));
}
types::NumberConstant const negated_number_constant = types::NumberConstant::Signed((infallible_integer_cast<i64>((negated_number))));
if (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(raw_number,JaktInternal::checked_add(max_signed,static_cast<size_t>(1ULL))) || (!(TRY((((negated_number_constant).can_fit_number(flipped_sign_type,((*this).program))))))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Negative literal -{} too small for type ‘{}’"sv)),raw_number,TRY((((*this).type_name(flipped_sign_type,false))))))),span))));
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),expr,types::CheckedUnaryOperator::Negate(),span,type_id)));
}
types::CheckedNumericConstant const new_constant = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(flipped_sign_type));
switch(__jakt_match_variant.__jakt_init_index()) {
case 6 /* I8 */: {
return JaktInternal::ExplicitValue(types::CheckedNumericConstant::I8((infallible_integer_cast<i8>((negated_number)))));
};/*case end*/
case 7 /* I16 */: {
return JaktInternal::ExplicitValue(types::CheckedNumericConstant::I16((infallible_integer_cast<i16>((negated_number)))));
};/*case end*/
case 8 /* I32 */: {
return JaktInternal::ExplicitValue(types::CheckedNumericConstant::I32((infallible_integer_cast<i32>((negated_number)))));
};/*case end*/
case 9 /* I64 */: {
return JaktInternal::ExplicitValue(types::CheckedNumericConstant::I64((infallible_integer_cast<i64>((negated_number)))));
};/*case end*/
default: {
{
utility::panic((ByteString::must_from_utf8("Unreachable"sv)));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),new_constant,span,type_id))),types::CheckedUnaryOperator::Negate(),span,flipped_sign_type)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_function(parser::ParsedFunction const parsed_function,ids::ScopeId const parent_scope_id) {
{
bool const in_comptime_function_call = ((*this).in_comptime_function_call);
ScopeGuard __jakt_var_444([&] {
(((*this).in_comptime_function_call) = in_comptime_function_call);
});
(((*this).in_comptime_function_call) = ((parsed_function).is_comptime));
if (((!(((((parsed_function).generic_parameters)).is_empty()))) && (!(((parsed_function).must_instantiate))))){
return {};
}
JaktInternal::Optional<ids::FunctionId> const function_id = TRY((((*this).find_function_matching_signature_in_scope(parent_scope_id,parsed_function))));
if (((function_id).has_value())){
(((*this).current_function_id) = (function_id.value()));
if (((((parsed_function).name)) == ((ByteString::must_from_utf8("main"sv))))){
TRY((((*this).typecheck_jakt_main(parsed_function,parent_scope_id))));
}
NonnullRefPtr<types::CheckedFunction> checked_function = ((*this).get_function((function_id.value())));
ids::ScopeId const function_scope_id = ((checked_function)->function_scope_id);
parser::FunctionLinkage const function_linkage = ((checked_function)->linkage);
if (((checked_function)->is_fully_checked)){
if ((!(((TRY((((*this).get_scope(parent_scope_id)))))->is_from_generated_code)))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Function ‘{}’ is already defined"sv)),((parsed_function).name)))),((parsed_function).name_span),(ByteString::must_from_utf8("Try removing this definition"sv)),(((((checked_function)->parsed_function).value())).name_span)))));
}
return {};
}
ScopeGuard __jakt_var_445([&] {
(((checked_function)->is_fully_checked) = true);
});
NonnullRefPtr<types::Module> module = ((*this).current_module());
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const variable = ((param).variable);
ids::VarId const var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope(function_scope_id,((variable)->name),var_id,((variable)->definition_span)))));
}

}
}

ids::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),function_scope_id,JaktInternal::OptionalNone()))));
if (((!(((parsed_function).is_fat_arrow))) && (((((parsed_function).return_type))->__jakt_init_index() == 15 /* Empty */) && [](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(((parsed_function).name),(ByteString::must_from_utf8("main"sv)))))){
(function_return_type_id = types::void_type_id());
}
if (((function_return_type_id).equals(types::never_type_id()))){
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(function_scope_id))));
(((scope)->can_throw) = true);
}
types::CheckedBlock const block = TRY((((*this).typecheck_block(((parsed_function).block),function_scope_id,types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
if (((((block).yielded_type)).has_value())){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Functions are not allowed to yield values"sv)),(((((parsed_function).block)).find_yield_span()).value()),(ByteString::must_from_utf8("You might want to return instead"sv)),(((((parsed_function).block)).find_yield_keyword_span()).value())))));
}
ids::TypeId const return_type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((function_return_type_id).equals(types::unknown_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).infer_function_return_type(block)));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).resolve_type_var(function_return_type_id,function_scope_id)))));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if (((!(((function_linkage).__jakt_init_index() == 1 /* External */))) && ((!(((return_type_id).equals(types::void_type_id())))) && (!(((((block).control_flow)).always_transfers_control())))))){
if ((((return_type_id).equals(types::never_type_id())) && (!(((((block).control_flow)).never_returns()))))){
TRY((((*this).error((ByteString::must_from_utf8("Control reaches end of never-returning function"sv)),((parsed_function).name_span)))));
}
else if (((!(((((block).control_flow)).never_returns()))) && (!(((parsed_function).is_jakt_main))))){
TRY((((*this).error((ByteString::must_from_utf8("Control reaches end of non-void function"sv)),((parsed_function).name_span)))));
}
}
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
(((*this).current_function_id) = JaktInternal::OptionalNone());
}
else {
TRY((((((*this).compiler))->panic(TRY((__jakt_format((StringView::from_string_literal("Previously defined function {} not found in scope {}"sv)),((parsed_function).name),parent_scope_id)))))));
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_declarations(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id,bool const comptime_pass,bool const generic_pass) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_declarations(child_namespace,child_namespace_scope_id,comptime_pass,generic_pass))));
}

}
}

if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_446([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_declarations(((chunk).parsed_namespace),((((chunk).generated_scopes))[i]),comptime_pass,generic_pass))));
}

}
}

}

}
}

}
if (((!(comptime_pass)) && (!(generic_pass)))){
AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const record = ((record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((record_scope_id_).template get<1>());

types::StructLikeId const id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::StructLikeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_447; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find struct that has been previous added"sv))))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
__jakt_var_447 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_412;

}
__jakt_label_412:; __jakt_var_447.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_448; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find struct that has been previous added"sv))))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
__jakt_var_448 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_413;

}
__jakt_label_413:; __jakt_var_448.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_449; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find enum that has been previous added"sv))))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
__jakt_var_449 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_414;

}
__jakt_label_414:; __jakt_var_449.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_450; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find enum that has been previous added"sv))))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
__jakt_var_450 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_415;

}
__jakt_label_415:; __jakt_var_450.release_value(); }));
};/*case end*/
default: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord nested_record = (_magic_value.value());
{
TRY((((*this).warn_about_unimplemented_nested_record(nested_record))));
((records_to_process).enqueue((Tuple{nested_record, TRY((((id).scope_id(((((*this).program)))))))})));
}

}
}

}
{
JaktInternal::ArrayIterator<parser::ParsedTrait> _magic = ((((parsed_namespace).traits)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedTrait> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedTrait parsed_trait = (_magic_value.value());
{
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((*this).find_trait_in_scope(scope_id,((parsed_trait).name)))));
if (((trait_id).has_value())){
TRY((((*this).typecheck_trait(parsed_trait,(trait_id.value()),scope_id,false))));
}
else {
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find trait that has been previous added"sv))))));
}

}

}
}

TRY((((*this).typecheck_namespace_trait_implementations_predecl(scope_id))));
}
{
JaktInternal::ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedFunction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
if ((((((fun).is_comptime)) == (comptime_pass)) && ((generic_pass) == ((!(((((fun).generic_parameters)).is_empty()))))))){
TRY((((*this).typecheck_function(fun,scope_id))));
}
}

}
}

if (((!(comptime_pass)) && (!(generic_pass)))){
{
JaktInternal::ArrayIterator<parser::ParsedExternalTraitImplementation> _magic = ((((parsed_namespace).external_trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternalTraitImplementation> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternalTraitImplementation implementation = (_magic_value.value());
{
ids::TypeId for_type = TRY((((*this).typecheck_typename(((implementation).for_type),scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(for_type));
if (((type)->is_builtin())){
ids::StructId const struct_id = TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))));
(for_type = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id))))))));
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((*this).get_type(for_type));
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
types::CheckedStruct struct_ = ((*this).get_struct(struct_id));
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((implementation).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((TRY((((((((((((method).parsed_function)).params)).first())).map([](auto& _value) { return _value.variable; }))).map([](auto& _value) { return _value.name; })).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); })))) == ((ByteString::must_from_utf8("this"sv))))){
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Struct(JaktInternal::OptionalNone(),struct_id)))));
}
else {
TRY((((*this).typecheck_function(((method).parsed_function),((struct_).scope_id)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
{
types::CheckedStruct struct_ = ((*this).get_struct(struct_id));
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((implementation).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((TRY((((((((((((method).parsed_function)).params)).first())).map([](auto& _value) { return _value.variable; }))).map([](auto& _value) { return _value.name; })).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); })))) == ((ByteString::must_from_utf8("this"sv))))){
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Struct(JaktInternal::OptionalNone(),struct_id)))));
}
else {
TRY((((*this).typecheck_function(((method).parsed_function),((struct_).scope_id)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((implementation).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((TRY((((((((((((method).parsed_function)).params)).first())).map([](auto& _value) { return _value.variable; }))).map([](auto& _value) { return _value.name; })).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); })))) == ((ByteString::must_from_utf8("this"sv))))){
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Enum(JaktInternal::OptionalNone(),enum_id)))));
}
else {
TRY((((*this).typecheck_function(((method).parsed_function),((enum_).scope_id)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
{
types::CheckedEnum enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((implementation).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
if (((TRY((((((((((((method).parsed_function)).params)).first())).map([](auto& _value) { return _value.variable; }))).map([](auto& _value) { return _value.name; })).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); })))) == ((ByteString::must_from_utf8("this"sv))))){
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Enum(JaktInternal::OptionalNone(),enum_id)))));
}
else {
TRY((((*this).typecheck_function(((method).parsed_function),((enum_).scope_id)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}
if (((!(comptime_pass)) && (!(generic_pass)))){
TRY((((*this).typecheck_namespace_trait_implementations(scope_id))));
}
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_constructor(parser::ParsedRecord const parsed_record,ids::StructId const struct_id,ids::ScopeId const scope_id) {
{
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(struct_type_id))));
ScopeGuard __jakt_var_451([&] {
(((*this).self_type_id) = old_self_type_id);
});
types::CheckedStruct const struct_ = ((*this).get_struct(struct_id));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const constructor_ids = TRY((((*this).find_functions_with_name_in_scope(((struct_).scope_id),((parsed_record).name),JaktInternal::OptionalNone()))));
if (((constructor_ids).has_value())){
if ((((((parsed_record).record_type)).__jakt_init_index() == 1 /* Class */) && ((((parsed_record).definition_linkage)).__jakt_init_index() == 1 /* External */))){
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = (((constructor_ids.value())).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId constructor_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> func = ((*this).get_function(constructor_id));
(((func)->linkage) = parser::FunctionLinkage::External());
}

}
}

}
}
else if ((!(((((parsed_record).definition_linkage)).__jakt_init_index() == 1 /* External */)))){
bool const constructor_can_throw = ((((parsed_record).record_type)).__jakt_init_index() == 1 /* Class */);
ids::ScopeId const function_scope_id = TRY((((*this).create_scope(((struct_).scope_id),constructor_can_throw,TRY((__jakt_format((StringView::from_string_literal("generated-constructor({})"sv)),((parsed_record).name)))),true))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(function_scope_id,constructor_can_throw,TRY((__jakt_format((StringView::from_string_literal("generated-constructor-block({})"sv)),((parsed_record).name)))),true))));
JaktInternal::DynamicArray<ids::StructId> const inheritance_chain = TRY((((*this).struct_inheritance_chain(struct_id))));
JaktInternal::DynamicArray<types::CheckedParameter> constructor_parameters = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
size_t const parent_index_in_chain = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t,ErrorOr<void>>{
auto __jakt_enum_value = ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(((inheritance_chain).size()),static_cast<size_t>(2ULL)));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JaktInternal::checked_sub(((inheritance_chain).size()),static_cast<size_t>(2ULL)));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(static_cast<size_t>(0ULL));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<ids::StructId> _magic = ((((inheritance_chain)[(JaktInternal::Range<size_t>{static_cast<size_t>(parent_index_in_chain),static_cast<size_t>(9223372036854775807LL)})])).iterator());
for (;;){
JaktInternal::Optional<ids::StructId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::StructId parent_struct_id = (_magic_value.value());
{
types::CheckedStruct const parent_struct = ((*this).get_struct(parent_struct_id));
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(((parent_struct).scope_id)))));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const parent_constructors = ((((scope)->functions)).get(((parent_struct).name)));
if (((parent_constructors).has_value())){
ids::FunctionId const id = (((parent_constructors.value()))[static_cast<i64>(0LL)]);
NonnullRefPtr<types::CheckedFunction> const ctor = ((*this).get_function(id));
TRY((((constructor_parameters).push_values(((((ctor)->params)))))));
}
else {
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((((*this).get_struct(parent_struct_id))).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const variable = ((*this).get_variable(((field).variable_id)));
TRY((((constructor_parameters).push(types::CheckedParameter(true,variable,((field).default_value_expression))))));
}

}
}

}

}

}
}

NonnullRefPtr<types::CheckedFunction> checked_constructor = TRY((types::CheckedFunction::__jakt_create(((parsed_record).name),((parsed_record).name_span),types::CheckedVisibility::Public(),struct_type_id,JaktInternal::OptionalNone(),constructor_parameters,TRY((types::FunctionGenerics::__jakt_create(function_scope_id,constructor_parameters,(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::MayReturn(),ids::TypeId::none(),false),constructor_can_throw,parser::FunctionType::ImplicitConstructor(),parser::FunctionLinkage::Internal(),function_scope_id,struct_id,true,JaktInternal::OptionalNone(),false,false,false,false,false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,((parsed_record).external_name),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::FunctionId const function_id = TRY((((module)->add_function(checked_constructor))));
TRY((((*this).add_function_to_scope(((struct_).scope_id),((parsed_record).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((parsed_record).name_span)))));
}
(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<ids::TypeId> typechecker::Typechecker::resolve_type_var(ids::TypeId const type_var_type_id,ids::ScopeId const scope_id) const {
{
ids::TypeId current_type_id = type_var_type_id;
for (;;){
(current_type_id = ((((*this).generic_inferences)).map(current_type_id)));
NonnullRefPtr<typename types::Type> const type_var_type = ((*this).get_type(current_type_id));
if (((type_var_type)->__jakt_init_index() == 18 /* TypeVariable */)){
ByteString const type_name = (type_var_type)->as.TypeVariable.name;
JaktInternal::Optional<ids::TypeId> const maybe_found_type_id = TRY((((*this).find_type_in_scope(scope_id,type_name))));
if (((maybe_found_type_id).has_value())){
ids::TypeId const found_type_id = ((maybe_found_type_id).value());
if (((found_type_id).equals(current_type_id))){
return current_type_id;
}
(current_type_id = found_type_id);
}
else {
return current_type_id;
}

}
else {
return current_type_id;
}

}
return current_type_id;
}
}

ErrorOr<void> typechecker::Typechecker::check_type_argument_requirements(ids::TypeId const generic_argument,JaktInternal::DynamicArray<ids::TraitId> const constraints,utility::Span const arg_span) {
{
if ((!(((constraints).is_empty())))){
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(generic_argument));
JaktInternal::Tuple<JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>,utility::Span> const implemented_traits_decl_span_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>,utility::Span>, ErrorOr<void>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_enum(id))).trait_implementations), ((((*this).get_enum(id))).name_span)}));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_enum(id))).trait_implementations), ((((*this).get_enum(id))).name_span)}));
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_struct(id))).trait_implementations), ((((*this).get_struct(id))).name_span)}));
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_struct(id))).trait_implementations), ((((*this).get_struct(id))).name_span)}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>,utility::Span>,ErrorOr<void>>{
auto __jakt_enum_value = (((type)->is_builtin()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>,utility::Span>> __jakt_var_452; {
ids::StructId const struct_id = TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))));
__jakt_var_452 = (Tuple{((((*this).get_struct(struct_id))).trait_implementations), ((((*this).get_struct(struct_id))).name_span)}); goto __jakt_label_416;

}
__jakt_label_416:; __jakt_var_452.release_value(); }));
}
else if (__jakt_enum_value == false) {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Cannot use ‘{}’ here as only enums, structs and classes can implement the required traits"sv)),TRY((((*this).type_name(generic_argument,false))))))),arg_span))));
{
return ErrorOr<void>{};
}

abort();
}
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const implemented_traits = ((implemented_traits_decl_span_).template get<0>());
utility::Span const decl_span = ((implemented_traits_decl_span_).template get<1>());

{
JaktInternal::ArrayIterator<ids::TraitId> _magic = ((constraints).iterator());
for (;;){
JaktInternal::Optional<ids::TraitId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::TraitId constraint = (_magic_value.value());
{
NonnullRefPtr<types::CheckedTrait> const trait_ = ((((*this).program))->get_trait(constraint));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((trait_)->requirements);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Nothing */: {
{
ByteString const trait_name = ((trait_)->name);
JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const implemented_trait = ((implemented_traits).get(trait_name));
if (((!(((implemented_trait).has_value()))) || (!((((((((implemented_trait.value())).first())).map([](auto& _value) { return _value.template get<0>(); }))).map([&](auto& _value) { return _value.equals(constraint); })).value_or_lazy_evaluated([&] { return false; }))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Cannot use ‘{}’ here as it doesn't implement the trait ‘{}’"sv)),TRY((((*this).type_name(generic_argument,false)))),trait_name))),arg_span,(ByteString::must_from_utf8("Consider implementing the required trait for this type"sv)),decl_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Methods */: {
{
ByteString const trait_name = ((trait_)->name);
JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const implemented_trait = ((implemented_traits).get(trait_name));
if (((!(((implemented_trait).has_value()))) || (!((((((((implemented_trait.value())).first())).map([](auto& _value) { return _value.template get<0>(); }))).map([&](auto& _value) { return _value.equals(constraint); })).value_or_lazy_evaluated([&] { return false; }))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Cannot use ‘{}’ here as it doesn't implement the trait ‘{}’"sv)),TRY((((*this).type_name(generic_argument,false)))),trait_name))),arg_span,(ByteString::must_from_utf8("Consider implementing the required trait for this type"sv)),decl_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* ComptimeExpression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ComptimeExpression;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.value;
{
NonnullRefPtr<interpreter::Interpreter> interpreter = TRY((((*this).interpreter())));
NonnullRefPtr<interpreter::InterpreterScope> scope = TRY((interpreter::InterpreterScope::create((TRY((Dictionary<ByteString, types::Value>::create_with_entries({})))),JaktInternal::OptionalNone(),(TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({{TRY((((*this).find_or_add_type_id(TRY((types::Type::Self(parser::CheckedQualifiers(false)))))))), generic_argument}})))))));
JaktInternal::Optional<interpreter::StatementResult> const result = ({ Optional<interpreter::StatementResult> __jakt_var_453;
auto __jakt_var_454 = [&]() -> ErrorOr<interpreter::StatementResult> { return TRY((((interpreter)->execute_expression(expr,scope)))); }();
if (!__jakt_var_454.is_error()) __jakt_var_453 = __jakt_var_454.release_value();
__jakt_var_453; });
bool meets_requirement = false;
if (((result).has_value())){
(meets_requirement = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.__jakt_init_index()) {
case 5 /* JustValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JustValue;types::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Bool */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Bool;bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_455; {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Invalid result type for comptime requirements in trait ‘{}’, expected ‘bool’ but got ‘{}’"sv)),((trait_)->name),((value).impl)))),arg_span))));
__jakt_var_455 = false; goto __jakt_label_417;

}
__jakt_label_417:; __jakt_var_455.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_456; {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Invalid result type for comptime requirements in trait ‘{}’, expected ‘bool’ but got ‘{}’"sv)),((trait_)->name),result))),arg_span))));
__jakt_var_456 = false; goto __jakt_label_418;

}
__jakt_label_418:; __jakt_var_456.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
}));
}
if ((!(meets_requirement))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Cannot use ‘{}’ here as it doesn't meet the comptime requirements for ‘{}’"sv)),TRY((((*this).type_name(generic_argument,false)))),((trait_)->name)))),arg_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}
else {
return {};
}

}
return {};
}

ErrorOr<ByteString> typechecker::Typechecker::stringify_function_prototype(ids::FunctionId const function_id) {
{
NonnullRefPtr<types::CheckedFunction> const function = ((*this).get_function(function_id));
ByteStringBuilder builder = ByteStringBuilder::create();
TRY((((builder).append((StringView::from_string_literal("fn "sv))))));
TRY((((builder).append(((function)->name)))));
if ((!(((((((function)->generics))->params)).is_empty())))){
TRY((((builder).append((StringView::from_string_literal("<"sv))))));
bool first = true;
{
JaktInternal::ArrayIterator<types::FunctionGenericParameter> _magic = ((((((function)->generics))->params)).iterator());
for (;;){
JaktInternal::Optional<types::FunctionGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::FunctionGenericParameter param = (_magic_value.value());
{
if (first){
(first = false);
}
else {
TRY((((builder).append((StringView::from_string_literal(", "sv))))));
}

TRY((((builder).append(TRY((((*this).type_name(((param).type_id()),false))))))));
}

}
}

TRY((((builder).append((StringView::from_string_literal(">"sv))))));
}
TRY((((builder).append((StringView::from_string_literal("("sv))))));
bool first = true;
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((function)->params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
if (first){
(first = false);
}
else {
TRY((((builder).append((StringView::from_string_literal(", "sv))))));
}

if ((!(((param).requires_label)))){
TRY((((builder).append((StringView::from_string_literal("anon "sv))))));
}
TRY((((builder).append(((((param).variable))->name)))));
TRY((((builder).append((StringView::from_string_literal(": "sv))))));
TRY((((builder).append(TRY((((*this).type_name(((((param).variable))->type_id),false))))))));
if (((((param).default_value_expression)).has_value())){
TRY((((builder).append((StringView::from_string_literal(" = ..."sv))))));
}
}

}
}

TRY((((builder).append((StringView::from_string_literal(")"sv))))));
if (((function)->can_throw)){
TRY((((builder).append((StringView::from_string_literal(" throws"sv))))));
}
TRY((((builder).append((StringView::from_string_literal(" -> "sv))))));
TRY((((builder).append(TRY((((*this).type_name(((function)->return_type_id),false))))))));
if (((((function)->specialization_index)).has_value())){
size_t const index = (((function)->specialization_index).value());
TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal(" [specialization {}: <"sv)),index)))))));
JaktInternal::DynamicArray<ids::TypeId> const type_ids = ((((((function)->generics))->specializations))[index]);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((type_ids).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (((i) != (static_cast<size_t>(0ULL)))){
TRY((((builder).append((StringView::from_string_literal(", "sv))))));
}
TRY((((builder).append(TRY((((*this).type_name(((type_ids)[i]),false))))))));
}

}
}

TRY((((builder).append((StringView::from_string_literal(">]"sv))))));
}
return TRY((((builder).to_string())));
}
}

ErrorOr<JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>>> typechecker::Typechecker::get_type_ids_from_type_hint_if_struct_ids_match(JaktInternal::Optional<ids::TypeId> const type_hint,ids::StructId const expected_struct_id) const {
{
if ((!(((type_hint).has_value())))){
return JaktInternal::OptionalNone();
}
if (((TRY((((*this).unwrap_type_from_optional_if_needed(((*this).get_type((type_hint.value()))))))))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (TRY((((*this).unwrap_type_from_optional_if_needed(((*this).get_type((type_hint.value()))))))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (TRY((((*this).unwrap_type_from_optional_if_needed(((*this).get_type((type_hint.value()))))))))->as.GenericInstance.args;
if (((id).equals(expected_struct_id))){
return args;
}
}
return JaktInternal::OptionalNone();
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_generic_arguments_method_call(NonnullRefPtr<typename types::CheckedExpression> const checked_expr,parser::ParsedCall const call,ids::ScopeId const scope_id,utility::Span const span,bool const is_optional,types::SafetyMode const safety_mode) {
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>> checked_args = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({}))));
TRY((((checked_args).ensure_capacity(((((call).args)).size())))));
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> name_____expr__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> const jakt__name_____expr__ = name_____expr__;
ByteString const name = ((jakt__name_____expr__).template get<0>());
utility::Span const _ = ((jakt__name_____expr__).template get<1>());
NonnullRefPtr<typename parser::ParsedExpression> const expr = ((jakt__name_____expr__).template get<2>());

NonnullRefPtr<typename types::CheckedExpression> const checked_arg_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((checked_args).push((Tuple{name, checked_arg_expr})))));
}

}
}

JaktInternal::DynamicArray<ids::TypeId> checked_type_args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

return TRY((types::CheckedExpression::MethodCall(JaktInternal::OptionalNone(),checked_expr,types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),((call).name),checked_args,checked_type_args,JaktInternal::OptionalNone(),types::unknown_type_id(),false,JaktInternal::OptionalNone(),parser::InlineState::Default()),span,is_optional,types::unknown_type_id())));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_loop(parser::ParsedBlock const parsed_block,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("A ‘loop’ block is not allowed to yield values"sv)),(((parsed_block).find_yield_span()).value())))));
}
return TRY((types::CheckedStatement::Loop(checked_block,span)));
}
}

ErrorOr<NonnullRefPtr<types::Scope>> typechecker::Typechecker::get_scope(ids::ScopeId const id) const {
{
return TRY((((((*this).program))->get_scope(id))));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_indexed_tuple(NonnullRefPtr<typename parser::ParsedExpression> const expr,size_t const index,ids::ScopeId const scope_id,bool const is_optional,types::SafetyMode const safety_mode,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::StructId const tuple_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Tuple"sv))))));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
ids::TypeId expr_type_id = types::unknown_type_id();
if (((((*this).get_type(((checked_expr)->type()))))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(((checked_expr)->type()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type(((checked_expr)->type()))))->as.GenericInstance.args;
if (((id).equals(tuple_struct_id))){
if (is_optional){
TRY((((*this).error((ByteString::must_from_utf8("Optional chaining is not allowed on a non-optional tuple type"sv)),span))));
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(index,((args).size()))){
TRY((((*this).error((ByteString::must_from_utf8("Tuple index past the end of the tuple"sv)),span))));
}
else {
(expr_type_id = ((args)[index]));
}

}
else if ((is_optional && ((id).equals(optional_struct_id)))){
ids::TypeId const inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((((*this).get_type(inner_type_id)))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(inner_type_id)))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type(inner_type_id)))->as.GenericInstance.args;
if (((id).equals(tuple_struct_id))){
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(index,((args).size()))){
TRY((((*this).error((ByteString::must_from_utf8("Optional-chained tuple index past the end of the tuple"sv)),span))));
}
else {
(expr_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({((args)[index])}))))))))))));
}

}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Optional-chained tuple index used on non-tuple value"sv)),span))));
}

}
}
else if (is_optional){
TRY((((*this).error((ByteString::must_from_utf8("Optional-chained tuple index used on non-tuple value"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Tuple index used on non-tuple value"sv)),span))));
}

return TRY((types::CheckedExpression::IndexedTuple(JaktInternal::OptionalNone(),checked_expr,index,span,is_optional,expr_type_id)));
}
}

ErrorOr<JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<utility::Span,ids::TypeId>>>> typechecker::Typechecker::typecheck_forall_chunk_parameters(JaktInternal::DynamicArray<parser::ParsedGenericParameter> const chunk_parameters,ids::ScopeId const scope_id) {
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>>> named_requirements = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>>>::create_with({}))));
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((chunk_parameters).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter parameter = (_magic_value.value());
{
if (((((parameter).requires_list)).has_value())){
JaktInternal::DynamicArray<parser::ParsedNameWithGenericParameters> const requires_list = (((parameter).requires_list).value());
if ((!(((requires_list).is_empty())))){
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
JaktInternal::DynamicArray<ids::TraitId> trait_requirements = (TRY((DynamicArray<ids::TraitId>::create_with({}))));
TRY((((*this).fill_trait_requirements(requires_list,((trait_requirements)),((trait_implementations)),scope_id))));
if (((trait_requirements).is_empty())){
continue;
}
TRY((((named_requirements).push((Tuple{((parameter).name), ((parameter).span), trait_requirements})))));
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("forall type '{}' is not allowed to be unconditional"sv)),((parameter).name)))),((parameter).span),(ByteString::must_from_utf8("Try adding a 'requires' clause to the this type"sv)),((parameter).span)))));
continue;
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("forall type '{}' is not allowed to be unconditional"sv)),((parameter).name)))),((parameter).span),(ByteString::must_from_utf8("Try adding a 'requires' clause to the this type"sv)),((parameter).span)))));
continue;
}

}

}
}

bool const old_ignore_errors = ((*this).ignore_errors);
ScopeGuard __jakt_var_457([&] {
(((*this).ignore_errors) = old_ignore_errors);
});
JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<utility::Span,ids::TypeId>>> results = (TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<utility::Span,ids::TypeId>>>::create_with_entries({}))));
NonnullRefPtr<types::Module> const module = ((*this).current_module());
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>>> _magic = ((named_requirements).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>> name__span__traits__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,utility::Span,JaktInternal::DynamicArray<ids::TraitId>> const jakt__name__span__traits__ = name__span__traits__;
ByteString const name = ((jakt__name__span__traits__).template get<0>());
utility::Span const span = ((jakt__name__span__traits__).template get<1>());
JaktInternal::DynamicArray<ids::TraitId> const traits = ((jakt__name__span__traits__).template get<2>());

{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((module)->types)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t type_index = (_magic_value.value());
{
ids::TypeId type_id = ids::TypeId(((module)->id),type_index);
(((*this).ignore_errors) = true);
TRY((((*this).check_type_argument_requirements(type_id,traits,span))));
bool const matches = (!(((*this).had_an_error)));
(((*this).had_an_error) = false);
(((*this).ignore_errors) = false);
if ((!(matches))){
continue;
}
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(type_id));
if (((type)->is_builtin())){
(type_id = types::builtin(((type)->as_builtin_type())));
}
if (((results).contains(name))){
TRY((((((results)[name])).push((Tuple{span, type_id})))));
}
else {
TRY(results.set(name, (TRY((DynamicArray<JaktInternal::Tuple<utility::Span,ids::TypeId>>::create_with({(Tuple{span, type_id})}))))));
}

}

}
}

}

}
}

return results;
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_while(NonnullRefPtr<typename parser::ParsedExpression> const condition,parser::ParsedBlock const block,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((((checked_condition)->type())).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("Condition must be a boolean expression"sv)),((condition)->span())))));
}
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("A ‘while’ block is not allowed to yield values"sv)),(((block).find_yield_span()).value())))));
}
return TRY((types::CheckedStatement::While(checked_condition,checked_block,span)));
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::prelude_struct_type_named(ByteString const name) {
{
ids::StructId const struct_id = TRY((((*this).find_struct_in_prelude(name))));
NonnullRefPtr<typename types::Type> const type = TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)));
return TRY((((*this).find_or_add_type_id(type))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_alias(parser::ParsedAlias const alias,ids::ScopeId const scope_id,typechecker::ImportRestrictions const allow) {
{
parser::ParsedName const aliased_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedName,ErrorOr<void>>{
auto __jakt_enum_value = (((((alias).alias_name)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((((alias).alias_name).value()));
}
else {
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedName> __jakt_var_458; {
parser::ParsedNameWithGenericParameters const name = (((((alias).target)).last()).value());
if ((!(((((name).generic_parameters)).is_empty())))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Cannot alias a generic instance of a type to the type itself"sv))))),((name).name_span),TRY((__jakt_format((StringView::from_string_literal("Add an alias name here: 'as <name>'"sv))))),((name).name_span)))));
}
__jakt_var_458 = parser::ParsedName(((name).name),((name).name_span)); goto __jakt_label_419;

}
__jakt_label_419:; __jakt_var_458.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
ids::ScopeId resolved_scope_id = scope_id;
JaktInternal::DynamicArray<types::ResolvedNamespace> alias_path = (TRY((DynamicArray<types::ResolvedNamespace>::create_with({}))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(JaktInternal::checked_sub(((((alias).target)).size()),static_cast<size_t>(1ULL)))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>> const namespace_ = TRY((((*this).find_namespace_in_scope(resolved_scope_id,((((((alias).target))[i])).name),false,JaktInternal::OptionalNone()))));
if ((!(((namespace_).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown namespace '{}'"sv)),((((((alias).target))[i])).name)))),((((((alias).target))[i])).name_span)))));
return {};
}
(resolved_scope_id = (((namespace_.value())).template get<0>()));
TRY((((alias_path).push(types::ResolvedNamespace(((((((alias).target))[i])).name),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))));
}

}
}

NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
ids::ScopeId const alias_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId,ErrorOr<void>>{
auto __jakt_enum_value = (((((scope)->alias_scope)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((((scope)->alias_scope).value()));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_459; {
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((__jakt_format((StringView::from_string_literal("alias-scope({})"sv)),((scope)->debug_name)))),false))));
NonnullRefPtr<types::Scope> new_scope = TRY((((*this).get_scope(new_scope_id))));
(((new_scope)->alias_path) = alias_path);
TRY((((((TRY((((*this).get_scope(scope_id)))))->children)).push(new_scope_id))));
__jakt_var_459 = new_scope_id; goto __jakt_label_420;

}
__jakt_label_420:; __jakt_var_459.release_value(); }));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
TRY((((*this).find_and_import_name_from_scope((((((((alias).target)).last()).value())).name),(((((((alias).target)).last()).value())).name_span),((aliased_name).name),((aliased_name).span),resolved_scope_id,alias_scope_id,allow))));
}
return {};
}

ErrorOr<types::CheckedUnaryOperator> typechecker::Typechecker::typecheck_is_enum_variant(NonnullRefPtr<typename types::CheckedExpression> const checked_expr,NonnullRefPtr<typename parser::ParsedType> const inner,JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const bindings,ids::ScopeId const scope_id) {
{
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
ids::TypeId const type_id = TRY((((*this).typecheck_typename(inner,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
types::CheckedUnaryOperator checked_op = types::CheckedUnaryOperator::Is(type_id);
ids::TypeId const expr_type_id = ((checked_expr)->type());
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<types::CheckedUnaryOperator>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* NamespacedName */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NamespacedName;ByteString const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if (((((*this).get_type(expr_type_id)))->__jakt_init_index() == 25 /* Enum */)){
ids::EnumId const enum_id = (((*this).get_type(expr_type_id)))->as.Enum.value;
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::Optional<types::CheckedEnumVariant> const variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
JaktInternal::Optional<JaktInternal::DynamicArray<types::CheckedEnumVariantBinding>> const checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = types::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant {} does not exist on {}"sv)),variant_name,TRY((((*this).type_name(type_id,false))))))),span))));
return checked_op;
}

}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type or invalid type name: {}"sv)),variant_name))),span))));
return checked_op;
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Name */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Name;ByteString const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if (((((*this).get_type(expr_type_id)))->__jakt_init_index() == 25 /* Enum */)){
ids::EnumId const enum_id = (((*this).get_type(expr_type_id)))->as.Enum.value;
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::Optional<types::CheckedEnumVariant> const variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
JaktInternal::Optional<JaktInternal::DynamicArray<types::CheckedEnumVariantBinding>> const checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = types::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant {} does not exist on {}"sv)),variant_name,TRY((((*this).type_name(type_id,false))))))),span))));
return checked_op;
}

}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type or invalid type name: {}"sv)),variant_name))),span))));
return checked_op;
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return checked_op;
}
}

ErrorOr<bool> typechecker::Typechecker::add_var_to_scope(ids::ScopeId const scope_id,ByteString const name,ids::VarId const var_id,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<ids::VarId> const existing_var = ((((scope)->vars)).get(name));
if (((existing_var).has_value())){
NonnullRefPtr<types::CheckedVariable> const variable_ = ((*this).get_variable((existing_var.value())));
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Redefinition of variable ‘{}’"sv)),name))),span,(ByteString::must_from_utf8("previous definition here"sv)),((variable_)->definition_span)))));
}
TRY((((((scope)->vars)).set(name,var_id))));
TRY((((((*this).program))->set_owner_scope_if_needed(scope_id,var_id))));
return true;
}
}

ErrorOr<bool> typechecker::Typechecker::add_comptime_binding_to_scope(ids::ScopeId const scope_id,ByteString const name,types::Value const value,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<types::Value> const existing_binding = ((((scope)->comptime_bindings)).get(name));
if (((existing_binding).has_value())){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Redefinition of comptime variable ‘{}’"sv)),name))),span,(ByteString::must_from_utf8("previous definition here"sv)),(((existing_binding.value())).span)))));
}
TRY((((((scope)->comptime_bindings)).set(name,value))));
return true;
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_match(NonnullRefPtr<typename parser::ParsedExpression> const expr,JaktInternal::DynamicArray<parser::ParsedMatchCase> const cases,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId const subject_type_id = ((checked_expr)->type());
NonnullRefPtr<typename types::Type> const type_to_match_on = ((*this).get_type(subject_type_id));
JaktInternal::DynamicArray<types::CheckedMatchCase> checked_cases = (TRY((DynamicArray<types::CheckedMatchCase>::create_with({}))));
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_460([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
JaktInternal::Optional<ids::TypeId> final_result_type = JaktInternal::OptionalNone();
if ((((type_hint).has_value()) && ((!((((type_hint.value())).equals(types::unknown_type_id())))) && (!(((((*this).get_type((type_hint.value()))))->__jakt_init_index() == 18 /* TypeVariable */)))))){
(final_result_type = type_hint);
}
if (((type_to_match_on)->__jakt_init_index() == 21 /* GenericEnumInstance */)){
ids::EnumId const id = (type_to_match_on)->as.GenericEnumInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (type_to_match_on)->as.GenericEnumInstance.args;
types::CheckedEnum const enum_ = ((*this).get_enum(id));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((enum_).generic_parameters)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
ids::TypeId const generic = ((((((enum_).generic_parameters))[i])).type_id);
ids::TypeId const argument_type = ((args)[i]);
if ([](ids::TypeId const& self, ids::TypeId rhs) -> bool {
{
return (!(((self).equals(rhs))));
}
}
(generic,argument_type)){
TRY((((((*this).generic_inferences)).set(generic,argument_type))));
}
}

}
}

}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *type_to_match_on;
switch(__jakt_match_variant.__jakt_init_index()) {
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
bool expanded_catch_all = false;
JaktInternal::Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
JaktInternal::Set<ByteString> covered_variants = (TRY((Set<ByteString>::create_with_values({}))));
size_t const case_count = ((cases).size());
size_t current_case_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchCase> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchPattern> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* EnumVariant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.EnumVariant;JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const& variant_names = __jakt_match_value.variant_names;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> variant_names_ = variant_names;
if (((((variant_names_).size())) == (static_cast<size_t>(1ULL)))){
JaktInternal::Tuple<ByteString,utility::Span> const temp = ((variant_names_)[static_cast<i64>(0LL)]);
(variant_names_ = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names_)[static_cast<i64>(0LL)])).template get<1>())}), temp})))));
}
if (((variant_names_).is_empty())){
return JaktInternal::LoopContinue{};
}
if ([](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(((((variant_names_)[static_cast<i64>(0LL)])).template get<0>()),((enum_).name))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case '{}' does not match enum '{}'"sv)),((((variant_names_)[static_cast<i64>(0LL)])).template get<0>()),((enum_).name)))),((((variant_names_)[static_cast<i64>(0LL)])).template get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
JaktInternal::Optional<types::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
JaktInternal::Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant v = (_magic_value.value());
{
if (((((v).name())) == (((((variant_names_)[static_cast<i64>(1LL)])).template get<0>())))){
(matched_variant = v);
(variant_index = i);
}
((i++));
}

}
}

if ((!(((matched_variant).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum '{}' does not contain a variant named '{}'"sv)),((enum_).name),((((variant_names_)[static_cast<i64>(1LL)])).template get<0>())))),((case_).marker_span)))));
return TRY((types::CheckedExpression::Match(JaktInternal::OptionalNone(),checked_expr,(TRY((DynamicArray<types::CheckedMatchCase>::create_with({})))),span,types::unknown_type_id(),false)));
}
JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>> const covered_name_checked_match_case_result_type_ = TRY((((*this).typecheck_match_variant(case_,subject_type_id,(variant_index.value()),final_result_type,(matched_variant.value()),variant_arguments,((pattern).common.init_common.defaults),arguments_span,scope_id,safety_mode))));
JaktInternal::Optional<ByteString> const covered_name = ((covered_name_checked_match_case_result_type_).template get<0>());
types::CheckedMatchCase const checked_match_case = ((covered_name_checked_match_case_result_type_).template get<1>());
JaktInternal::Optional<ids::TypeId> const result_type = ((covered_name_checked_match_case_result_type_).template get<2>());

if (((covered_name).has_value())){
TRY((((covered_variants).add((covered_name.value())))));
}
(final_result_type = result_type);
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* CatchAll */: {
auto&& __jakt_match_value = __jakt_match_variant.as.CatchAll;JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
if (((current_case_index) != (JaktInternal::checked_sub(case_count,static_cast<size_t>(1ULL))))){
TRY((((*this).error((ByteString::must_from_utf8("Match else case is only allowed as the last case"sv)),((case_).marker_span)))));
}
if (seen_catch_all){
TRY((((*this).error((ByteString::must_from_utf8("Multiple catch-all cases in match are not allowed"sv)),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((variant_arguments).size()),static_cast<size_t>(0ULL))){
size_t variant_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(((variant).name())))))){
(expanded_catch_all = true);
JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>> const covered_name_checked_match_case_result_type_ = TRY((((*this).typecheck_match_variant(case_,subject_type_id,variant_index,final_result_type,variant,variant_arguments,((pattern).common.init_common.defaults),arguments_span,scope_id,safety_mode))));
JaktInternal::Optional<ByteString> const covered_name = ((covered_name_checked_match_case_result_type_).template get<0>());
types::CheckedMatchCase const checked_match_case = ((covered_name_checked_match_case_result_type_).template get<1>());
JaktInternal::Optional<ids::TypeId> const result_type = ((covered_name_checked_match_case_result_type_).template get<2>());

if (((covered_name).has_value())){
TRY((((covered_variants).add((covered_name.value())))));
}
(final_result_type = result_type);
TRY((((checked_cases).push(checked_match_case))));
}
((variant_index++));
}

}
}

}
else {
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),(ByteString::must_from_utf8("catch-all"sv)),true))));
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> defaults = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,parser::ParsedPatternDefault> _magic = ((((pattern).common.init_common.defaults)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> ___default___ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> const jakt_____default___ = ___default___;
ByteString const _ = ((jakt_____default___).template get<0>());
parser::ParsedPatternDefault const default_ = ((jakt_____default___).template get<1>());

NonnullRefPtr<typename types::CheckedStatement> const checked_var_decl = TRY((((*this).typecheck_var_decl(((default_).variable),((default_).value),new_scope_id,safety_mode,((((default_).variable)).span)))));
TRY((((defaults).push(checked_var_decl))));
}

}
}

JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::CatchAll(defaults,false,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

((current_case_index++));
}

}
}

JaktInternal::DynamicArray<ByteString> enum_variant_names = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::DynamicArray<ByteString> missing_variants = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
JaktInternal::ArrayIterator<ByteString> _magic = ((enum_variant_names).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(variant))))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((missing_variants).size()),static_cast<size_t>(0ULL))){
if ((!(seen_catch_all))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match expression is not exhaustive, missing variants are: {}"sv)),TRY((utility::join(missing_variants,(ByteString::must_from_utf8(", "sv)))))))),span))));
}
}
else if ((seen_catch_all && (!(expanded_catch_all)))){
TRY((((*this).error((ByteString::must_from_utf8("All variants are covered, but an irrefutable pattern is also present"sv)),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
bool expanded_catch_all = false;
JaktInternal::Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
JaktInternal::Set<ByteString> covered_variants = (TRY((Set<ByteString>::create_with_values({}))));
size_t const case_count = ((cases).size());
size_t current_case_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchCase> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchPattern> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* EnumVariant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.EnumVariant;JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const& variant_names = __jakt_match_value.variant_names;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> variant_names_ = variant_names;
if (((((variant_names_).size())) == (static_cast<size_t>(1ULL)))){
JaktInternal::Tuple<ByteString,utility::Span> const temp = ((variant_names_)[static_cast<i64>(0LL)]);
(variant_names_ = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names_)[static_cast<i64>(0LL)])).template get<1>())}), temp})))));
}
if (((variant_names_).is_empty())){
return JaktInternal::LoopContinue{};
}
if ([](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(((((variant_names_)[static_cast<i64>(0LL)])).template get<0>()),((enum_).name))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case '{}' does not match enum '{}'"sv)),((((variant_names_)[static_cast<i64>(0LL)])).template get<0>()),((enum_).name)))),((((variant_names_)[static_cast<i64>(0LL)])).template get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
JaktInternal::Optional<types::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
JaktInternal::Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant v = (_magic_value.value());
{
if (((((v).name())) == (((((variant_names_)[static_cast<i64>(1LL)])).template get<0>())))){
(matched_variant = v);
(variant_index = i);
}
((i++));
}

}
}

if ((!(((matched_variant).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum '{}' does not contain a variant named '{}'"sv)),((enum_).name),((((variant_names_)[static_cast<i64>(1LL)])).template get<0>())))),((case_).marker_span)))));
return TRY((types::CheckedExpression::Match(JaktInternal::OptionalNone(),checked_expr,(TRY((DynamicArray<types::CheckedMatchCase>::create_with({})))),span,types::unknown_type_id(),false)));
}
JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>> const covered_name_checked_match_case_result_type_ = TRY((((*this).typecheck_match_variant(case_,subject_type_id,(variant_index.value()),final_result_type,(matched_variant.value()),variant_arguments,((pattern).common.init_common.defaults),arguments_span,scope_id,safety_mode))));
JaktInternal::Optional<ByteString> const covered_name = ((covered_name_checked_match_case_result_type_).template get<0>());
types::CheckedMatchCase const checked_match_case = ((covered_name_checked_match_case_result_type_).template get<1>());
JaktInternal::Optional<ids::TypeId> const result_type = ((covered_name_checked_match_case_result_type_).template get<2>());

if (((covered_name).has_value())){
TRY((((covered_variants).add((covered_name.value())))));
}
(final_result_type = result_type);
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* CatchAll */: {
auto&& __jakt_match_value = __jakt_match_variant.as.CatchAll;JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
if (((current_case_index) != (JaktInternal::checked_sub(case_count,static_cast<size_t>(1ULL))))){
TRY((((*this).error((ByteString::must_from_utf8("Match else case is only allowed as the last case"sv)),((case_).marker_span)))));
}
if (seen_catch_all){
TRY((((*this).error((ByteString::must_from_utf8("Multiple catch-all cases in match are not allowed"sv)),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((variant_arguments).size()),static_cast<size_t>(0ULL))){
size_t variant_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(((variant).name())))))){
(expanded_catch_all = true);
JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>> const covered_name_checked_match_case_result_type_ = TRY((((*this).typecheck_match_variant(case_,subject_type_id,variant_index,final_result_type,variant,variant_arguments,((pattern).common.init_common.defaults),arguments_span,scope_id,safety_mode))));
JaktInternal::Optional<ByteString> const covered_name = ((covered_name_checked_match_case_result_type_).template get<0>());
types::CheckedMatchCase const checked_match_case = ((covered_name_checked_match_case_result_type_).template get<1>());
JaktInternal::Optional<ids::TypeId> const result_type = ((covered_name_checked_match_case_result_type_).template get<2>());

if (((covered_name).has_value())){
TRY((((covered_variants).add((covered_name.value())))));
}
(final_result_type = result_type);
TRY((((checked_cases).push(checked_match_case))));
}
((variant_index++));
}

}
}

}
else {
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),(ByteString::must_from_utf8("catch-all"sv)),true))));
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> defaults = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,parser::ParsedPatternDefault> _magic = ((((pattern).common.init_common.defaults)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> ___default___ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> const jakt_____default___ = ___default___;
ByteString const _ = ((jakt_____default___).template get<0>());
parser::ParsedPatternDefault const default_ = ((jakt_____default___).template get<1>());

NonnullRefPtr<typename types::CheckedStatement> const checked_var_decl = TRY((((*this).typecheck_var_decl(((default_).variable),((default_).value),new_scope_id,safety_mode,((((default_).variable)).span)))));
TRY((((defaults).push(checked_var_decl))));
}

}
}

JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::CatchAll(defaults,false,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

((current_case_index++));
}

}
}

JaktInternal::DynamicArray<ByteString> enum_variant_names = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::DynamicArray<ByteString> missing_variants = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
JaktInternal::ArrayIterator<ByteString> _magic = ((enum_variant_names).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(variant))))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((missing_variants).size()),static_cast<size_t>(0ULL))){
if ((!(seen_catch_all))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match expression is not exhaustive, missing variants are: {}"sv)),TRY((utility::join(missing_variants,(ByteString::must_from_utf8(", "sv)))))))),span))));
}
}
else if ((seen_catch_all && (!(expanded_catch_all)))){
TRY((((*this).error((ByteString::must_from_utf8("All variants are covered, but an irrefutable pattern is also present"sv)),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Void */: {
{
TRY((((*this).error((ByteString::must_from_utf8("Can't match on 'void' type"sv)),((checked_expr)->span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((type_to_match_on)->is_boxed(((*this).program))));
if (__jakt_enum_value == true) {
{
JaktInternal::Tuple<ids::StructId,JaktInternal::DynamicArray<ids::StructId>> const struct_to_match_on_struct_inheritance_chain_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<ids::StructId,JaktInternal::DynamicArray<ids::StructId>>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *type_to_match_on;
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{id, TRY((((*this).struct_inheritance_chain(id))))}));
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue((Tuple{id, TRY((((*this).struct_inheritance_chain(id))))}));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("Expected struct or generic instance in inheritance-style match expression"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
ids::StructId const struct_to_match_on = ((struct_to_match_on_struct_inheritance_chain_).template get<0>());
JaktInternal::DynamicArray<ids::StructId> const struct_inheritance_chain = ((struct_to_match_on_struct_inheritance_chain_).template get<1>());

bool seen_catch_all = false;
bool catch_all_matches_original_type = false;
JaktInternal::Optional<utility::Span> catch_all_marker_span = JaktInternal::OptionalNone();
JaktInternal::Set<ids::StructId> covered_cases = (TRY((Set<ids::StructId>::create_with_values({}))));
{
JaktInternal::ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchCase> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchPattern> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* EnumVariant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.EnumVariant;JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const& variant_names = __jakt_match_value.variant_names;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
JaktInternal::DynamicArray<ByteString> names = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = ((variant_names).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> name = (_magic_value.value());
{
TRY((((names).push(((name).template get<0>())))));
}

}
}

ids::TypeId const type = TRY((((*this).typecheck_typename(TRY((parser::ParsedType::NamespacedName(JaktInternal::OptionalNone(),(((names).last()).value()),TRY((((((names)[(JaktInternal::Range<size_t>{static_cast<size_t>(0LL),static_cast<size_t>(JaktInternal::checked_sub(((names).size()),static_cast<size_t>(1ULL)))})])).to_array()))),(TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedType>>::create_with({})))),((case_).marker_span)))),scope_id,JaktInternal::OptionalNone()))));
if (seen_catch_all){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("This case is unreachable because a catch-all case is present before it"sv)),((case_).marker_span),({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (catch_all_matches_original_type);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("Catch-all case matching the original subject type seen here"sv)));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("Catch-all case seen here"sv)));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
}),(catch_all_marker_span.value())))));
}
Function<ErrorOr<void>(ids::StructId)> const check_cover_overlap = [this, &type, &case_, &covered_cases](ids::StructId id) -> ErrorOr<void> {
{
{
JaktInternal::SetIterator<ids::StructId> _magic = ((covered_cases).iterator());
for (;;){
JaktInternal::Optional<ids::StructId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::StructId covered_case = (_magic_value.value());
{
if (TRY((((*this).struct_inherits_from(id,covered_case,JaktInternal::OptionalNone()))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ used as a match case at this position is redundant"sv)),TRY((((*this).type_name(type,false))))))),((case_).marker_span),TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ (a supertype of ‘{}’) has been covered by a case above"sv)),((((*this).get_struct(covered_case))).name),TRY((((*this).type_name(type,false))))))),((case_).marker_span)))));
}
}

}
}

}
return {};
}
;
if (((type).equals(subject_type_id))){
if (seen_catch_all){
TRY((((*this).error((ByteString::must_from_utf8("Multiple catch-all cases in match are not allowed"sv)),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_marker_span = ((case_).marker_span));
(catch_all_matches_original_type = true);
TRY((check_cover_overlap(struct_to_match_on)));
}

}
else {
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(type));
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
{
if (((!(TRY((((*this).struct_inherits_from(struct_to_match_on,id,struct_inheritance_chain)))))) && (!(TRY((((*this).struct_inherits_from(id,struct_to_match_on,JaktInternal::OptionalNone())))))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ cannot be used as a match case for ‘{}’"sv)),TRY((((*this).type_name(type,false)))),TRY((((*this).type_name(subject_type_id,false))))))),((case_).marker_span),TRY((__jakt_format((StringView::from_string_literal("Neither ‘{}’ nor ‘{}’ are super types of the other"sv)),TRY((((*this).type_name(type,false)))),TRY((((*this).type_name(subject_type_id,false))))))),((case_).marker_span)))));
}
else {
TRY((check_cover_overlap(id)));
TRY((((covered_cases).add(id))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
{
if (((!(TRY((((*this).struct_inherits_from(struct_to_match_on,id,struct_inheritance_chain)))))) && (!(TRY((((*this).struct_inherits_from(id,struct_to_match_on,JaktInternal::OptionalNone())))))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ cannot be used as a match case for ‘{}’"sv)),TRY((((*this).type_name(type,false)))),TRY((((*this).type_name(subject_type_id,false))))))),((case_).marker_span),TRY((__jakt_format((StringView::from_string_literal("Neither ‘{}’ nor ‘{}’ are super types of the other"sv)),TRY((((*this).type_name(type,false)))),TRY((((*this).type_name(subject_type_id,false))))))),((case_).marker_span)))));
}
else {
TRY((check_cover_overlap(id)));
TRY((((covered_cases).add(id))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type ‘{}’ cannot be used as a match case for ‘{}’"sv)),TRY((((*this).type_name(type,false)))),TRY((((*this).type_name(subject_type_id,false))))))),((case_).marker_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        return JaktInternal::LoopBreak {};
    if (_jakt_value.is_loop_continue())
        return JaktInternal::LoopContinue {};
    _jakt_value.release_value();
});
}

ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((__jakt_format((StringView::from_string_literal("class-variant({})"sv)),names))),true))));
JaktInternal::Optional<types::ClassInstanceRebind> rebind_name = JaktInternal::OptionalNone();
if ((!(((variant_arguments).is_empty())))){
if (((((variant_arguments).size())) != (static_cast<size_t>(1ULL)))){
TRY((((*this).error((ByteString::must_from_utf8("Class instance matches may only have one match argument (the name to rebind to)"sv)),arguments_span))));
}
parser::EnumVariantPatternArgument const arg = ((variant_arguments)[static_cast<i64>(0LL)]);
(rebind_name = types::ClassInstanceRebind(((arg).name_in_enum()),((arg).name_in_enum_span()),((arg).is_mutable),((arg).is_reference)));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const variable_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create((((rebind_name.value())).name),type,(((rebind_name.value())).is_mutable),(((rebind_name.value())).name_span),((case_).marker_span),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))))));
if (((((rebind_name.value())).is_mutable) && (!(((checked_expr)->is_mutable(((*this).program))))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating method on an immutable object instance"sv)),span))));
}
TRY((((*this).add_var_to_scope(new_scope_id,(((rebind_name.value())).name),variable_id,(((rebind_name.value())).name_span)))));
}
JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
TRY((((checked_cases).push(types::CheckedMatchCase::ClassInstance((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),type,checked_body,rebind_name,((case_).marker_span))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* CatchAll */: {
auto&& __jakt_match_value = __jakt_match_variant.as.CatchAll;JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
if (seen_catch_all){
TRY((((*this).error((ByteString::must_from_utf8("Multiple catch-all cases in match are not allowed"sv)),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_marker_span = ((case_).marker_span));
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),(ByteString::must_from_utf8("class-variant(else)"sv)),true))));
if ((!(((variant_arguments).is_empty())))){
TRY((((*this).error((ByteString::must_from_utf8("Catch-all cases in class instance matches cannot have arguments"sv)),arguments_span))));
}
JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
TRY((((checked_cases).push(types::CheckedMatchCase::CatchAll((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),false,checked_body,((case_).marker_span))))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error((ByteString::must_from_utf8("Only named types and 'else' patterns are allowed in class instance match expressions"sv)),((case_).marker_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}

}
}

if ((!(seen_catch_all))){
JaktInternal::Set<ByteString> missing = (TRY((Set<ByteString>::create_with_values({}))));
{
JaktInternal::ArrayIterator<ids::StructId> _magic = ((struct_inheritance_chain).iterator());
for (;;){
JaktInternal::Optional<ids::StructId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::StructId struct_id = (_magic_value.value());
{
if ((!(((covered_cases).contains(struct_id))))){
ByteString const struct_name = ((((*this).get_struct(struct_id))).name);
TRY((((missing).add(TRY((__jakt_format((StringView::from_string_literal("‘{}’"sv)),struct_name)))))));
}
}

}
}

if ((!(((missing).is_empty())))){
ByteStringBuilder builder = ByteStringBuilder::create();
TRY((((builder).append((StringView::from_string_literal("Missing match cases for "sv))))));
bool first = true;
{
JaktInternal::SetIterator<ByteString> _magic = ((missing).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString name = (_magic_value.value());
{
if (first){
(first = false);
}
else {
TRY((((builder).append((StringView::from_string_literal(", "sv))))));
}

TRY((((builder).append(name))));
}

}
}

TRY((((*this).error(TRY((((builder).to_string()))),span))));
}
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == false) {
{
bool const is_boolean_match = ((type_to_match_on)->__jakt_init_index() == 1 /* Bool */);
bool seen_true = false;
bool seen_false = false;
JaktInternal::Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
bool is_enum_match = false;
bool is_value_match = false;
bool seen_catch_all = false;
bool all_variants_constant = true;
size_t const case_count = ((cases).size());
size_t current_case_index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchCase> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMatchPattern> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* EnumVariant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.EnumVariant;JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> const& variant_names = __jakt_match_value.variant_names;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
if (is_value_match){
TRY((((*this).error((ByteString::must_from_utf8("Cannot have an enum match case in a match expression containing value matches"sv)),((case_).marker_span)))));
}
if (((((variant_names).size())) == (static_cast<size_t>(0ULL)))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("typecheck_match - else - EnumVariant - variant_names.size() == 0"sv))))));
}
(is_enum_match = true);
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((__jakt_format((StringView::from_string_literal("catch-enum-variant({})"sv)),variant_names))),true))));
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> defaults = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,parser::ParsedPatternDefault> _magic = ((((pattern).common.init_common.defaults)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> ___default___ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> const jakt_____default___ = ___default___;
ByteString const _ = ((jakt_____default___).template get<0>());
parser::ParsedPatternDefault const default_ = ((jakt_____default___).template get<1>());

NonnullRefPtr<typename types::CheckedStatement> const checked_var_decl = TRY((((*this).typecheck_var_decl(((default_).variable),((default_).value),new_scope_id,safety_mode,((((default_).variable)).span)))));
TRY((((defaults).push(checked_var_decl))));
}

}
}

JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::EnumVariant(defaults,(((((variant_names).last()).value())).template get<0>()),variant_arguments,subject_type_id,static_cast<size_t>(0ULL),new_scope_id,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* CatchAll */: {
auto&& __jakt_match_value = __jakt_match_variant.as.CatchAll;JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
{
if (((current_case_index) != (JaktInternal::checked_sub(case_count,static_cast<size_t>(1ULL))))){
TRY((((*this).error((ByteString::must_from_utf8("Match else case is only allowed as the last case"sv)),((case_).marker_span)))));
}
(catch_all_span = ((case_).marker_span));
if (seen_catch_all){
TRY((((*this).error((ByteString::must_from_utf8("Multiple catch-all cases in match are not allowed"sv)),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
}

if (((((variant_arguments).size())) != (static_cast<size_t>(0ULL)))){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = false);
TRY((((*this).error((ByteString::must_from_utf8("Bindings aren't allowed in a generic else"sv)),((case_).marker_span)))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
}
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),(ByteString::must_from_utf8("catch-all"sv)),true))));
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> defaults = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,parser::ParsedPatternDefault> _magic = ((((pattern).common.init_common.defaults)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> ___default___ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> const jakt_____default___ = ___default___;
ByteString const _ = ((jakt_____default___).template get<0>());
parser::ParsedPatternDefault const default_ = ((jakt_____default___).template get<1>());

NonnullRefPtr<typename types::CheckedStatement> const checked_var_decl = TRY((((*this).typecheck_var_decl(((default_).variable),((default_).value),new_scope_id,safety_mode,((((default_).variable)).span)))));
TRY((((defaults).push(checked_var_decl))));
}

}
}

JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::CatchAll(defaults,((((variant_arguments).size())) != (static_cast<size_t>(0ULL))),checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Expression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Expression;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.value;
{
if (is_enum_match){
TRY((((*this).error((ByteString::must_from_utf8("Cannot have a value match case in a match expression containing enum matches"sv)),((case_).marker_span)))));
}
(is_value_match = true);
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>> const new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(expr,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),scope_id,span))));
NonnullRefPtr<typename parser::ParsedExpression> const new_condition = ((new_condition_new_then_block_new_else_statement_).template get<0>());
JaktInternal::Optional<parser::ParsedBlock> const new_then_block = ((new_condition_new_then_block_new_else_statement_).template get<1>());
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const new_else_statement = ((new_condition_new_then_block_new_else_statement_).template get<2>());

NonnullRefPtr<typename types::CheckedExpression> const checked_expression = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,static_cast<JaktInternal::Optional<ids::TypeId>>(subject_type_id),span))));
if ((is_boolean_match && ((checked_expression)->__jakt_init_index() == 0 /* Boolean */))){
bool const val = (checked_expression)->as.Boolean.val;
if (val){
(seen_true = true);
}
else {
(seen_false = true);
}

}
if ((!(((((checked_expression)->to_number_constant(((*this).program)))).has_value())))){
(all_variants_constant = false);
}
ids::TypeId expression_type = ((checked_expression)->type());
if (((checked_expression)->__jakt_init_index() == 9 /* Range */)){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const from = (checked_expression)->as.Range.from;
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const to = (checked_expression)->as.Range.to;
if ((((from).has_value()) || ((to).has_value()))){
if (((from).has_value())){
(expression_type = (((from.value()))->type()));
}
else if (((to).has_value())){
(expression_type = (((to.value()))->type()));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("There has to be at least a 'from', or a 'to' in a range expression"sv)),((expr)->span())))));
return JaktInternal::LoopContinue{};
}

}
TRY((((*this).check_types_for_compat(expression_type,subject_type_id,((((*this).generic_inferences))),((case_).marker_span)))));
if ((!(((((pattern).common.init_common.defaults)).is_empty())))){
TRY((((*this).error((ByteString::must_from_utf8("Expression patterns cannot have default bindings"sv)),((case_).marker_span)))));
}
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((__jakt_format((StringView::from_string_literal("catch-expression({})"sv)),expr))),true))));
JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

(final_result_type = result_type);
types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::Expression((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),checked_expression,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

((current_case_index++));
}

}
}

if ((is_value_match && (!((seen_catch_all || ((is_boolean_match && seen_true) && seen_false)))))){
TRY((((*this).error((ByteString::must_from_utf8("Match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"sv)),span))));
}
if ((is_value_match && (seen_catch_all && (is_boolean_match && (seen_true && seen_false))))){
TRY((((*this).error((ByteString::must_from_utf8("All cases are covered, but an irrefutable pattern is also present"sv)),(catch_all_span.value())))));
}
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
})), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return TRY((types::CheckedExpression::Match(JaktInternal::OptionalNone(),checked_expr,checked_cases,span,final_result_type.value_or_lazy_evaluated([&] { return types::void_type_id(); }),true)));
}
}

ErrorOr<void> typechecker::Typechecker::map_generic_arguments(ids::TypeId const type_id,JaktInternal::DynamicArray<ids::TypeId> const args) {
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
types::CheckedStruct const struct_ = ((*this).get_struct(id));
TRY((((((*this).generic_inferences)).set_all(((struct_).generic_parameters),args))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
types::CheckedEnum const enum_ = ((*this).get_enum(id));
TRY((((((*this).generic_inferences)).set_all(((enum_).generic_parameters),args))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(id));
TRY((((((*this).generic_inferences)).set_all(((trait_)->generic_parameters),args))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_throw(NonnullRefPtr<typename parser::ParsedExpression> const expr,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId const error_type_id = TRY((((*this).find_type_in_prelude((ByteString::must_from_utf8("Error"sv))))));
if ((!(((((checked_expr)->type())).equals(error_type_id))))){
TRY((((*this).error((ByteString::must_from_utf8("throw expression does not produce an error"sv)),((expr)->span())))));
}
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
if ((!(((scope)->can_throw)))){
TRY((((*this).error((ByteString::must_from_utf8("Throw statement needs to be in a try statement or a function marked as throws"sv)),((expr)->span())))));
}
return TRY((types::CheckedStatement::Throw(checked_expr,span)));
}
}

ErrorOr<void> typechecker::Typechecker::fill_trait_requirements(JaktInternal::DynamicArray<parser::ParsedNameWithGenericParameters> const names,JaktInternal::DynamicArray<ids::TraitId>& trait_requirements,JaktInternal::DynamicArray<ids::TypeId>& trait_implementations,ids::ScopeId const scope_id) {
{
TRY((((((trait_requirements))).ensure_capacity(((names).size())))));
{
JaktInternal::ArrayIterator<parser::ParsedNameWithGenericParameters> _magic = ((names).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedNameWithGenericParameters> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNameWithGenericParameters name = (_magic_value.value());
{
JaktInternal::Optional<ids::TypeId> type_id = TRY((((*this).find_type_in_scope(scope_id,((name).name)))));
if (((type_id).has_value())){
if (((((*this).get_type((type_id.value()))))->__jakt_init_index() == 27 /* Trait */)){
ids::TraitId const trait_id = (((*this).get_type((type_id.value()))))->as.Trait.value;
if ((!(((((name).generic_parameters)).is_empty())))){
JaktInternal::DynamicArray<ids::TypeId> generic_arguments = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((((name).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> argument = (_magic_value.value());
{
TRY((((generic_arguments).push(TRY((((*this).typecheck_typename(argument,scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

NonnullRefPtr<typename types::Type> const final_type = TRY((types::Type::GenericTraitInstance(parser::CheckedQualifiers(false),trait_id,generic_arguments)));
(type_id = TRY((((*this).find_or_add_type_id(final_type)))));
}
TRY((((((trait_implementations))).push((type_id.value())))));
TRY((((((trait_requirements))).push(trait_id))));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Requirement ‘{}’ is not a trait"sv)),((name).name)))),((name).name_span)))));
continue;
}

}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Couldn't find trait ‘{}’"sv)),((name).name)))),((name).name_span)))));
continue;
}

}

}
}

}
return {};
}

ErrorOr<bool> typechecker::Typechecker::struct_inherits_from(ids::StructId const struct_id,ids::StructId const super_struct_id,JaktInternal::Optional<JaktInternal::DynamicArray<ids::StructId>> const struct_inheritance_chain) const {
{
JaktInternal::DynamicArray<ids::StructId> const chain = TRY((struct_inheritance_chain.try_value_or_lazy_evaluated([&]() -> ErrorOr<JaktInternal::DynamicArray<ids::StructId>> { return TRY((((*this).struct_inheritance_chain(struct_id)))); })));
{
JaktInternal::ArrayIterator<ids::StructId> _magic = ((chain).iterator());
for (;;){
JaktInternal::Optional<ids::StructId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::StructId id = (_magic_value.value());
{
if (((id).equals(super_struct_id))){
return true;
}
}

}
}

return false;
}
}

ErrorOr<JaktInternal::Optional<ids::FunctionId>> typechecker::Typechecker::find_function_matching_trait_implementation_in_scope(ids::TypeId const self_type_id,ids::ScopeId const parent_scope_id,ByteString const function_name,typechecker::TraitImplementationDescriptor const& trait_descriptor) {
{
NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(((((trait_descriptor))).trait_id)));
if (((((trait_)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = (((trait_)->requirements)).as.Methods.value;
if (((methods).contains(function_name))){
if (((TRY((((((*this).program))->find_functions_with_name_in_scope(parent_scope_id,function_name,false,JaktInternal::OptionalNone()))))).has_value())){
JaktInternal::DynamicArray<ids::FunctionId> const candidate_ids = (TRY((((((*this).program))->find_functions_with_name_in_scope(parent_scope_id,function_name,false,JaktInternal::OptionalNone())))).value());
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_461([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
TRY((((((*this).generic_inferences)).set_all(((trait_)->generic_parameters),((((trait_descriptor))).implemented_type_args)))));
NonnullRefPtr<types::CheckedFunction> const expected_function = ((*this).get_function(((methods)[function_name])));
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((candidate_ids).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId candidate_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const candidate = ((*this).get_function(candidate_id));
if (((TRY((((*this).signatures_match(self_type_id,candidate,expected_function))))).template get<0>())){
return candidate_id;
}
}

}
}

return JaktInternal::OptionalNone();
}
else {
return JaktInternal::OptionalNone();
}

}
else {
return JaktInternal::OptionalNone();
}

}
else {
return JaktInternal::OptionalNone();
}

}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_dictionary(JaktInternal::DynamicArray<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>>> const values,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
ids::StructId const dictionary_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Dictionary"sv))))));
JaktInternal::DynamicArray<JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>>> checked_kv_pairs = (TRY((DynamicArray<JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({}))));
ids::TypeId key_type_id = types::unknown_type_id();
JaktInternal::Optional<utility::Span> key_type_span = JaktInternal::OptionalNone();
ids::TypeId value_type_id = types::unknown_type_id();
JaktInternal::Optional<utility::Span> value_type_span = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::TypeId> key_hint = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::TypeId> value_hint = JaktInternal::OptionalNone();
JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const type_hint_ids = TRY((((*this).get_type_ids_from_type_hint_if_struct_ids_match(type_hint,dictionary_struct_id))));
if (((type_hint_ids).has_value())){
(key_hint = (((type_hint_ids.value()))[static_cast<i64>(0LL)]));
(value_hint = (((type_hint_ids.value()))[static_cast<i64>(1LL)]));
}
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((values).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>> key__value__ = (_magic_value.value());
{
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>> const jakt__key__value__ = key__value__;
NonnullRefPtr<typename parser::ParsedExpression> const key = ((jakt__key__value__).template get<0>());
NonnullRefPtr<typename parser::ParsedExpression> const value = ((jakt__key__value__).template get<1>());

NonnullRefPtr<typename types::CheckedExpression> const checked_key = TRY((((*this).typecheck_expression(key,scope_id,safety_mode,key_hint))));
ids::TypeId const current_key_type_id = ((checked_key)->type());
NonnullRefPtr<typename types::CheckedExpression> const checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,value_hint))));
ids::TypeId const current_value_type_id = ((checked_value)->type());
ids::TypeId const VOID_TYPE_ID = types::builtin(types::BuiltinType::Void());
if ((((key_type_id).equals(types::unknown_type_id())) && ((value_type_id).equals(types::unknown_type_id())))){
if (((current_key_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error((ByteString::must_from_utf8("Can't create a dictionary with keys of type void"sv)),((key)->span())))));
}
if (((current_value_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error((ByteString::must_from_utf8("Can't create a dictionary with values of type void"sv)),((value)->span())))));
}
(key_type_id = current_key_type_id);
(key_type_span = static_cast<JaktInternal::Optional<utility::Span>>(((key)->span())));
(value_type_id = current_value_type_id);
(value_type_span = static_cast<JaktInternal::Optional<utility::Span>>(((value)->span())));
}
else {
if ((!(((key_type_id).equals(current_key_type_id))))){
ByteString const key_type_name = TRY((((*this).type_name(key_type_id,false))));
ByteString const current_key_type_name = TRY((((*this).type_name(current_key_type_id,false))));
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type '{}' does not match type '{}' of previous keys in dictionary"sv)),current_key_type_name,key_type_name))),((key)->span()),TRY((__jakt_format((StringView::from_string_literal("Dictionary was inferred to store keys of type '{}' here"sv)),key_type_name))),(key_type_span.value())))));
}
if ((!(((value_type_id).equals(current_value_type_id))))){
ByteString const value_type_name = TRY((((*this).type_name(value_type_id,false))));
ByteString const current_value_type_name = TRY((((*this).type_name(current_value_type_id,false))));
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type '{}' does not match type '{}' of previous values in dictionary"sv)),current_value_type_name,value_type_name))),((value)->span()),TRY((__jakt_format((StringView::from_string_literal("Dictionary was inferred to store values of type '{}' here"sv)),value_type_name))),(value_type_span.value())))));
}
}

TRY((((checked_kv_pairs).push((Tuple{checked_key, checked_value})))));
}

}
}

if (((key_type_id).equals(types::unknown_type_id()))){
if (((key_hint).has_value())){
(key_type_id = (key_hint.value()));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot infer key type for Dictionary<K, V>"sv)),span))));
}

}
if ((!(((key_type_id).equals(types::unknown_type_id()))))){
TRY((((*this).ensure_type_implements_trait(key_type_id,(ByteString::must_from_utf8("Hashable"sv)),JaktInternal::OptionalNone(),scope_id,span))));
TRY((((*this).ensure_type_implements_trait(key_type_id,(ByteString::must_from_utf8("Equal"sv)),(TRY((DynamicArray<ids::TypeId>::create_with({key_type_id})))),scope_id,span))));
}
if (((value_type_id).equals(types::unknown_type_id()))){
if (((value_hint).has_value())){
(value_type_id = (value_hint.value()));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot infer value type for Dictionary"sv)),span))));
}

}
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),dictionary_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({key_type_id, value_type_id})))))))))));
return TRY((types::CheckedExpression::JaktDictionary(JaktInternal::OptionalNone(),checked_kv_pairs,span,type_id,key_type_id,value_type_id)));
}
}

ErrorOr<types::CheckedBlock> typechecker::Typechecker::typecheck_block(parser::ParsedBlock const parsed_block,ids::ScopeId const parent_scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const yield_type_hint) {
{
bool const parent_throws = ((TRY((((*this).get_scope(parent_scope_id)))))->can_throw);
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(parent_scope_id,parent_throws,(ByteString::must_from_utf8("block"sv)),true))));
types::CheckedBlock checked_block = types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::MayReturn(),ids::TypeId::none(),false);
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedStatement>> _magic = ((((parsed_block).stmts)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedStatement> parsed_statement = (_magic_value.value());
{
if ((!(((((checked_block).control_flow)).is_reachable())))){
TRY((((*this).error((ByteString::must_from_utf8("Unreachable code"sv)),((parsed_statement)->span())))));
}
NonnullRefPtr<typename types::CheckedStatement> const checked_statement = TRY((((*this).typecheck_statement(parsed_statement,block_scope_id,safety_mode,yield_type_hint))));
(((checked_block).control_flow) = ((((checked_block).control_flow)).updated(TRY((((*this).statement_control_flow(checked_statement)))))));
JaktInternal::Optional<utility::Span> const yield_span = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<utility::Span>, ErrorOr<types::CheckedBlock>>{
auto&& __jakt_match_variant = *parsed_statement;
switch(__jakt_match_variant.__jakt_init_index()) {
case 14 /* Yield */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Yield;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<utility::Span>>(((expr)->span())));
};/*case end*/
case 16 /* Guard */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Guard;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<utility::Span>>(((expr)->span())));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const checked_yield_expression = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>>, ErrorOr<types::CheckedBlock>>{
auto&& __jakt_match_variant = *checked_statement;
switch(__jakt_match_variant.__jakt_init_index()) {
case 12 /* Yield */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Yield;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>>>(expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
if ((((yield_span).has_value()) && ((checked_yield_expression).has_value()))){
ids::TypeId const type_var_type_id = (((checked_yield_expression.value()))->type());
ids::TypeId const type_ = TRY((((*this).resolve_type_var(type_var_type_id,block_scope_id))));
if ((((checked_yield_expression.value()))->__jakt_init_index() == 25 /* OptionalNone */)){
(((checked_block).yielded_none) = true);
}
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).check_types_for_compat(((((checked_block).yielded_type)).value()),type_,((((*this).generic_inferences))),((yield_span).value())))));
}
else {
(((checked_block).yielded_type) = static_cast<JaktInternal::Optional<ids::TypeId>>(type_));
}

}
TRY((((((checked_block).statements)).push(checked_statement))));
}

}
}

if (((((checked_block).yielded_type)).has_value())){
(((checked_block).yielded_type) = static_cast<JaktInternal::Optional<ids::TypeId>>(TRY((((*this).substitute_typevars_in_type(((((checked_block).yielded_type)).value()),((*this).generic_inferences)))))));
}
return checked_block;
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_jakt_main(parser::ParsedFunction const parsed_function,ids::ScopeId const parent_scope_id) {
{
ByteString const param_type_error = (ByteString::must_from_utf8("Main function must take a single array of strings as its parameter"sv));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const func_ids = TRY((((*this).find_functions_with_name_in_scope(parent_scope_id,(ByteString::must_from_utf8("main"sv)),JaktInternal::OptionalNone()))));
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
((((func_ids.value())).size()),static_cast<size_t>(1ULL))){
TRY((((*this).error((ByteString::must_from_utf8("Function 'main' declared multiple times."sv)),((parsed_function).name_span)))));
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((((parsed_function).params)).size()),static_cast<size_t>(1ULL))){
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}
if ((!(((((parsed_function).params)).is_empty())))){
if (((((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type))->__jakt_init_index() == 3 /* JaktArray */)){
NonnullRefPtr<typename parser::ParsedType> const inner = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type))->as.JaktArray.inner;
utility::Span const span = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type))->as.JaktArray.span;
if (((inner)->__jakt_init_index() == 0 /* Name */)){
ByteString const name = (inner)->as.Name.name;
utility::Span const span = (inner)->as.Name.span;
if ([](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(name,(ByteString::must_from_utf8("String"sv)))){
TRY((((*this).error(param_type_error,span))));
}
}
else {
TRY((((*this).error(param_type_error,span))));
}

}
else {
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}

}
ByteString const return_type_error = (ByteString::must_from_utf8("Main function must return c_int"sv));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((parsed_function).return_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 15 /* Empty */: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Name */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Name;ByteString const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ([](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(name,(ByteString::must_from_utf8("c_int"sv)))){
TRY((((*this).error(return_type_error,span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(return_type_error,((parsed_function).return_type_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>> typechecker::Typechecker::typecheck_binary_operation(NonnullRefPtr<typename types::CheckedExpression> const checked_lhs,parser::BinaryOperator const op,NonnullRefPtr<typename types::CheckedExpression> const checked_rhs,ids::ScopeId const scope_id,utility::Span const span) {
{
ids::TypeId const lhs_type_id = ((checked_lhs)->type());
ids::TypeId const rhs_type_id = ((checked_rhs)->type());
utility::Span const lhs_span = ((checked_lhs)->span());
utility::Span const rhs_span = ((checked_rhs)->span());
ids::TypeId type_id = ((checked_lhs)->type());
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
types::CheckedBinaryOperator checked_operator = types::CheckedBinaryOperator(op,JaktInternal::OptionalNone());
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* NoneCoalescing */: {
{
if (((op).__jakt_init_index() == 32 /* NoneCoalescingAssign */)){
if (((checked_lhs)->__jakt_init_index() == 24 /* Var */)){
NonnullRefPtr<types::CheckedVariable> const var = (checked_lhs)->as.Var.var;
utility::Span const span = (checked_lhs)->as.Var.span;
if ((!(((var)->is_mutable)))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("left-hand side of ??= must be a mutable variable"sv)),span,(ByteString::must_from_utf8("This variable isn't marked as mutable"sv)),((var)->definition_span)))));
return (Tuple{checked_operator, types::unknown_type_id()});
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("left-hand side of ??= must be a mutable variable"sv)),span))));
return (Tuple{checked_operator, types::unknown_type_id()});
}

}
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(lhs_type_id)))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type(lhs_type_id)))->as.GenericInstance.args;
if (((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (Tuple{checked_operator, lhs_type_id});
}
ids::TypeId const inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (Tuple{checked_operator, inner_type_id});
}
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,(ByteString::must_from_utf8("Left side of ?? must be an Optional but isn't"sv)),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,(ByteString::must_from_utf8("Left side of ?? must be an Optional but isn't"sv)),lhs_span))));
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return (Tuple{checked_operator, lhs_type_id});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 32 /* NoneCoalescingAssign */: {
{
if (((op).__jakt_init_index() == 32 /* NoneCoalescingAssign */)){
if (((checked_lhs)->__jakt_init_index() == 24 /* Var */)){
NonnullRefPtr<types::CheckedVariable> const var = (checked_lhs)->as.Var.var;
utility::Span const span = (checked_lhs)->as.Var.span;
if ((!(((var)->is_mutable)))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("left-hand side of ??= must be a mutable variable"sv)),span,(ByteString::must_from_utf8("This variable isn't marked as mutable"sv)),((var)->definition_span)))));
return (Tuple{checked_operator, types::unknown_type_id()});
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("left-hand side of ??= must be a mutable variable"sv)),span))));
return (Tuple{checked_operator, types::unknown_type_id()});
}

}
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(lhs_type_id)))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type(lhs_type_id)))->as.GenericInstance.args;
if (((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (Tuple{checked_operator, lhs_type_id});
}
ids::TypeId const inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (Tuple{checked_operator, inner_type_id});
}
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,(ByteString::must_from_utf8("Left side of ?? must be an Optional but isn't"sv)),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,(ByteString::must_from_utf8("Left side of ?? must be an Optional but isn't"sv)),lhs_span))));
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("None coalescing (??) with incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return (Tuple{checked_operator, lhs_type_id});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18 /* LogicalAnd */: {
{
if ((!(((lhs_type_id).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("left side of logical binary operation is not a boolean"sv)),lhs_span))));
}
if ((!(((rhs_type_id).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("right side of logical binary operation is not a boolean"sv)),rhs_span))));
}
(type_id = types::builtin(types::BuiltinType::Bool()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19 /* LogicalOr */: {
{
if ((!(((lhs_type_id).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("left side of logical binary operation is not a boolean"sv)),lhs_span))));
}
if ((!(((rhs_type_id).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("right side of logical binary operation is not a boolean"sv)),rhs_span))));
}
(type_id = types::builtin(types::BuiltinType::Bool()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* Assign */: {
{
if ((!(((checked_lhs)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),((checked_lhs)->span())))));
return (Tuple{checked_operator, lhs_type_id});
}
if (((checked_rhs)->__jakt_init_index() == 25 /* OptionalNone */)){
utility::Span const span = (checked_rhs)->as.OptionalNone.span;
ids::TypeId const type_id = (checked_rhs)->as.OptionalNone.type_id;
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(lhs_type_id)))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type(lhs_type_id)))->as.GenericInstance.args;
if (((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))))))){
return (Tuple{checked_operator, lhs_type_id});
}
if ((!(((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv))))))))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}

}
NonnullRefPtr<typename types::Type> const lhs_type = TRY((((*this).unwrap_type_from_optional_if_needed(((*this).get_type(lhs_type_id))))));
if (((lhs_type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (lhs_type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (lhs_type)->as.GenericInstance.args;
if ((((((((((*this).program))->get_struct(id))).name)) == ((ByteString::must_from_utf8("WeakPtr"sv)))) && (!(((lhs_type_id).equals(rhs_type_id)))))){
JaktInternal::Optional<ids::TypeId> const unified_type = TRY((((*this).unify(((args)[static_cast<i64>(0LL)]),lhs_span,((checked_rhs)->type()),rhs_span))));
if (((unified_type).has_value())){
return (Tuple{checked_operator, (unified_type.value())});
}
}
}
ids::TypeId const effective_lhs_type_id = TRY((((*this).find_or_add_type_id(lhs_type))));
JaktInternal::Optional<ids::TypeId> const result = TRY((((*this).unify(rhs_type_id,rhs_span,effective_lhs_type_id,lhs_span))));
if ((!(((result).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Assignment between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
}
return (Tuple{checked_operator, ((result).value_or(lhs_type_id))});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27 /* AddAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28 /* SubtractAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29 /* MultiplyAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 31 /* DivideAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30 /* ModuloAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22 /* BitwiseAndAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23 /* BitwiseOrAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24 /* BitwiseXorAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Add */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Subtract */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* Multiply */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3 /* Divide */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4 /* Modulo */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5 /* LessThan */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6 /* LessThanOrEqual */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7 /* GreaterThan */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9 /* Equal */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10 /* NotEqual */: {
{
JaktInternal::DynamicArray<ByteString> const empty_array = (TRY((DynamicArray<ByteString>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool> const trait_names_is_assignment_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<ByteString>,bool>, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Add"sv)), (ByteString::must_from_utf8("ThrowingAdd"sv))})))), false}));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Subtract"sv)), (ByteString::must_from_utf8("ThrowingSubtract"sv))})))), false}));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Multiply"sv)), (ByteString::must_from_utf8("ThrowingMultiply"sv))})))), false}));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Divide"sv)), (ByteString::must_from_utf8("ThrowingDivide"sv))})))), false}));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Modulo"sv)), (ByteString::must_from_utf8("ThrowingModulo"sv))})))), false}));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Compare"sv)), (ByteString::must_from_utf8("ThrowingCompare"sv))})))), false}));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Equal"sv)), (ByteString::must_from_utf8("ThrowingEqual"sv))})))), false}));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("AddAssign"sv)), (ByteString::must_from_utf8("ThrowingAddAssign"sv))})))), true}));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("SubtractAssign"sv)), (ByteString::must_from_utf8("ThrowingSubtractAssign"sv))})))), true}));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("MultiplyAssign"sv)), (ByteString::must_from_utf8("ThrowingMultiplyAssign"sv))})))), true}));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("DivideAssign"sv)), (ByteString::must_from_utf8("ThrowingDivideAssign"sv))})))), true}));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("ModuloAssign"sv)), (ByteString::must_from_utf8("ThrowingModuloAssign"sv))})))), true}));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseAndAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseAndAssign"sv))})))), true}));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseOrAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseOrAssign"sv))})))), true}));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseXorAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseXorAssign"sv))})))), true}));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseLeftShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseLeftShiftAssign"sv))})))), true}));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((Tuple{(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("BitwiseRightShiftAssign"sv)), (ByteString::must_from_utf8("ThrowingBitwiseRightShiftAssign"sv))})))), true}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{empty_array, false}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<ByteString> const trait_names = ((trait_names_is_assignment_).template get<0>());
bool const is_assignment = ((trait_names_is_assignment_).template get<1>());

ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString, ErrorOr<JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Add */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add"sv)));
};/*case end*/
case 1 /* Subtract */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract"sv)));
};/*case end*/
case 2 /* Multiply */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply"sv)));
};/*case end*/
case 3 /* Divide */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide"sv)));
};/*case end*/
case 4 /* Modulo */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo"sv)));
};/*case end*/
case 5 /* LessThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than"sv)));
};/*case end*/
case 6 /* LessThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("less_than_or_equal"sv)));
};/*case end*/
case 7 /* GreaterThan */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than"sv)));
};/*case end*/
case 8 /* GreaterThanOrEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("greater_than_or_equal"sv)));
};/*case end*/
case 9 /* Equal */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("equals"sv)));
};/*case end*/
case 10 /* NotEqual */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("not_equals"sv)));
};/*case end*/
case 27 /* AddAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("add_assign"sv)));
};/*case end*/
case 28 /* SubtractAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("subtract_assign"sv)));
};/*case end*/
case 29 /* MultiplyAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("multiply_assign"sv)));
};/*case end*/
case 31 /* DivideAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("divide_assign"sv)));
};/*case end*/
case 30 /* ModuloAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("modulo_assign"sv)));
};/*case end*/
case 22 /* BitwiseAndAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_and_assign"sv)));
};/*case end*/
case 23 /* BitwiseOrAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_or_assign"sv)));
};/*case end*/
case 24 /* BitwiseXorAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_xor_assign"sv)));
};/*case end*/
case 25 /* BitwiseLeftShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_left_shift_assign"sv)));
};/*case end*/
case 26 /* BitwiseRightShiftAssign */: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("bitwise_right_shift_assign"sv)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8(""sv)));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const add_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(lhs_type_id,trait_names,scope_id,lhs_span,(TRY((DynamicArray<ids::TypeId>::create_with({rhs_type_id}))))))));
if (((add_trait_implementation).has_value())){
typechecker::TraitImplementationDescriptor const implementation = (add_trait_implementation.value());
if ((((((implementation).trait_name)).starts_with((ByteString::must_from_utf8("Throwing"sv)))) && (!(((scope)->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id___ = TRY((((*this).struct_like_id_from_type_id(lhs_type_id,scope_id,span,false,true))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id___).template get<0>());
bool const _ = ((parent_id___).template get<1>());

JaktInternal::Optional<ids::FunctionId> const implementation_function_id = TRY((((*this).find_function_matching_trait_implementation_in_scope(lhs_type_id,TRY((((parent_id).map([&](auto& _value) { return _value.scope_id(((((*this).program)))); })))).value_or_lazy_evaluated([&] { return scope_id; }),function_name,((implementation))))));
if (((implementation_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const implementation_function = ((*this).get_function((implementation_function_id.value())));
if ((TRY((((implementation_function)->is_mutating()))) && (!(((checked_lhs)->is_mutable(((*this).program))))))){
if (is_assignment){
TRY((((*this).error((ByteString::must_from_utf8("Assignment to immutable variable"sv)),span))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot call mutating function on an immutable object instance"sv)),span))));
}

}
(type_id = ((implementation_function)->return_type_id));
types::CheckedCall call_expression = types::CheckedCall((TRY((DynamicArray<types::ResolvedNamespace>::create_with({})))),function_name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({(Tuple{(ByteString::must_from_utf8(""sv)), checked_rhs})})))),(TRY((DynamicArray<ids::TypeId>::create_with({})))),implementation_function_id,type_id,((implementation_function)->can_throw),((implementation_function)->external_name),((implementation_function)->force_inline));
(((checked_operator).trait_implementation) = types::OperatorTraitImplementation(((implementation).trait_id),((implementation).implemented_type_args),call_expression));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Failed to find an implementation of '{}' (trait {}) in type {} ({})"sv)),function_name,((implementation).trait_name),TRY((((*this).type_name(lhs_type_id,false)))),((TRY((((*this).get_scope(TRY(((((parent_id.value())).scope_id(((((*this).program))))))))))))->debug_name)))),lhs_span))));
(type_id = types::unknown_type_id());
}

}
else if (((!(is_assignment)) && ((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */))){
ids::TypeId const lhs_deref_type_id = (((*this).get_type(lhs_type_id)))->as.RawPtr.value;
if (((((*this).get_type(rhs_type_id)))->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_deref_type_id = (((*this).get_type(rhs_type_id)))->as.RawPtr.value;
if (((lhs_deref_type_id).equals(rhs_deref_type_id))){
(type_id = types::builtin(types::BuiltinType::Bool()));
}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
else {
if (((((*this).get_type(lhs_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
JaktInternal::DynamicArray<ids::TypeId> const trait_implementations = (((*this).get_type(lhs_type_id)))->as.TypeVariable.trait_implementations;
if (((trait_implementations).is_empty())){
}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"sv)),((trait_names)[static_cast<i64>(0LL)]),TRY((((*this).type_name(rhs_type_id,false)))),TRY((((*this).type_name(lhs_type_id,false))))))),lhs_span))));
}

}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return (Tuple{checked_operator, type_id});
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl_initial(parser::ParsedRecord const parsed_record,size_t const enum_index,size_t const module_enum_len,ids::ScopeId const scope_id) {
{
ids::ModuleId const module_id = ((*this).current_module_id);
ids::EnumId const enum_id = ids::EnumId(((*this).current_module_id),JaktInternal::checked_add(enum_index,module_enum_len));
NonnullRefPtr<types::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((types::Type::Enum(parser::CheckedQualifiers(false),enum_id)))))));
ids::TypeId const enum_type_id = ids::TypeId(module_id,JaktInternal::checked_sub(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL)));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),enum_type_id,((parsed_record).name_span)))));
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(enum_type_id))));
ScopeGuard __jakt_var_462([&] {
(((*this).self_type_id) = old_self_type_id);
});
bool const is_boxed = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 3 /* SumEnum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.SumEnum;bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
TRY((((((module)->enums)).push(types::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((DynamicArray<types::CheckedGenericParameter>::create_with({})))),(TRY((DynamicArray<types::CheckedEnumVariant>::create_with({})))),(TRY((DynamicArray<types::CheckedField>::create_with({})))),((*this).prelude_scope_id()),((parsed_record).definition_linkage),(TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>::create_with_entries({})))),((parsed_record).record_type),enum_type_id,enum_type_id,is_boxed)))));
}
return {};
}

ErrorOr<ids::TypeId> typechecker::Typechecker::typecheck_generic_resolved_type(ByteString const name,JaktInternal::DynamicArray<ids::TypeId> const checked_inner_types,ids::ScopeId const scope_id,utility::Span const span) {
{
JaktInternal::Optional<ids::TypeId> const explicitly_specialized_type = TRY((((*this).find_explicitly_specialized_type_in_scope(scope_id,name,checked_inner_types,span))));
if (((explicitly_specialized_type).has_value())){
return TRY(((((TRY((types::StructLikeId::from_type_id((explicitly_specialized_type.value()),((((*this).program)))))).value())).specialized_by(checked_inner_types,((((*this).program))),((((*this).current_module()))->id),parser::CheckedQualifiers(false)))));
}
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,name,JaktInternal::OptionalNone()))));
if (((struct_id).has_value())){
types::CheckedStruct const struct_ = ((*this).get_struct((struct_id.value())));
JaktInternal::DynamicArray<ids::TypeId> effective_inner_types = TRY((((((checked_inner_types)[(JaktInternal::Range<i64>{static_cast<i64>(0LL),static_cast<i64>(9223372036854775807LL)})])).to_array())));
if (((((struct_).generic_parameter_defaults)).has_value())){
JaktInternal::DynamicArray<JaktInternal::Optional<ids::TypeId>> const defaults = (((struct_).generic_parameter_defaults).value());
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(((effective_inner_types).size())),static_cast<size_t>(((defaults).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (((((defaults)[i])).has_value())){
ids::TypeId const default_ = (((defaults)[i]).value());
TRY((((effective_inner_types).push(default_))));
}
else {
break;
}

}

}
}

}
return TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),(struct_id.value()),effective_inner_types)))))));
}
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
if (((enum_id).has_value())){
return TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericEnumInstance(parser::CheckedQualifiers(false),(enum_id.value()),checked_inner_types)))))));
}
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((((*this).program))->find_trait_in_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
if (((trait_id).has_value())){
return TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericTraitInstance(parser::CheckedQualifiers(false),(trait_id.value()),checked_inner_types)))))));
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("could not find {}"sv)),name))),span))));
return types::unknown_type_id();
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_comptime_index(NonnullRefPtr<typename parser::ParsedExpression> const expr,NonnullRefPtr<typename parser::ParsedExpression> const index,ids::ScopeId const scope_id,bool const is_optional,types::SafetyMode const safety_mode,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_index = TRY((((*this).typecheck_expression(index,scope_id,safety_mode,JaktInternal::OptionalNone()))));
NonnullRefPtr<interpreter::Interpreter> interpreter = TRY((((*this).interpreter())));
NonnullRefPtr<interpreter::InterpreterScope> scope = TRY((interpreter::InterpreterScope::from_runtime_scope(scope_id,((*this).program),JaktInternal::OptionalNone())));
interpreter::StatementResult const index_result = ({ Optional<interpreter::StatementResult> __jakt_var_463;
auto __jakt_var_464 = [&]() -> ErrorOr<interpreter::StatementResult> { return TRY((((interpreter)->execute_expression(checked_index,scope)))); }();
if (__jakt_var_464.is_error()) {auto error = __jakt_var_464.release_error();
{
warnln((StringView::from_string_literal("Error while evaluating comptime index: {}"sv)),error);
return TRY((types::CheckedExpression::ComptimeIndex(JaktInternal::OptionalNone(),TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span)))),checked_index,is_optional,span)));
}
} else {__jakt_var_463 = __jakt_var_464.release_value();
}
__jakt_var_463.release_value(); });
typechecker::NumericOrStringValue const index_constant = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::NumericOrStringValue, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = index_result;
switch(__jakt_match_variant.__jakt_init_index()) {
case 5 /* JustValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JustValue;types::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::NumericOrStringValue, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.__jakt_init_index()) {
case 13 /* JaktString */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktString;ByteString const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::StringValue(val));
};/*case end*/
case 2 /* U8 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U8;u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::UnsignedNumericValue((infallible_integer_cast<u64>((val)))));
};/*case end*/
case 3 /* U16 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U16;u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::UnsignedNumericValue((infallible_integer_cast<u64>((val)))));
};/*case end*/
case 4 /* U32 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U32;u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::UnsignedNumericValue((infallible_integer_cast<u64>((val)))));
};/*case end*/
case 5 /* U64 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U64;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::UnsignedNumericValue((infallible_integer_cast<u64>((val)))));
};/*case end*/
case 12 /* USize */: {
auto&& __jakt_match_value = __jakt_match_variant.as.USize;size_t const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::UnsignedNumericValue((infallible_integer_cast<u64>((val)))));
};/*case end*/
case 6 /* I8 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I8;i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::SignedNumericValue((infallible_integer_cast<i64>((val)))));
};/*case end*/
case 7 /* I16 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I16;i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::SignedNumericValue((infallible_integer_cast<i64>((val)))));
};/*case end*/
case 8 /* I32 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I32;i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::SignedNumericValue((infallible_integer_cast<i64>((val)))));
};/*case end*/
case 9 /* I64 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I64;i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::NumericOrStringValue::SignedNumericValue((infallible_integer_cast<i64>((val)))));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Index expression evaluation failed: expected numeric or string type, found {}"sv)),((value).impl)))),span))));
return TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void()))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Index expression evaluation returned an invalid object {}"sv)),index_result))),span))));
return TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void()))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = index_constant;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* StringValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.StringValue;ByteString const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_struct(expr,val,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 2 /* UnsignedNumericValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnsignedNumericValue;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_tuple(expr,(infallible_integer_cast<size_t>((val))),scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 1 /* SignedNumericValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.SignedNumericValue;i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_tuple(expr,(infallible_integer_cast<size_t>((val))),scope_id,is_optional,safety_mode,span)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<ids::ScopeId> typechecker::Typechecker::cache_or_process_cpp_import(jakt__path::Path const import_path,ids::ScopeId const scope_id,bool const is_c,JaktInternal::Dictionary<ByteString,ByteString> const defines) {
{
if ((!(((((*this).cpp_import_processor)).has_value())))){
(((*this).cpp_import_processor) = cpp_import__none::CppImportProcessor::create());
}
NonnullRefPtr<types::Module> module = ((((*this).program))->get_module(((scope_id).module_id)));
ids::ScopeId const result_scope_id = TRY(((((((*this).cpp_import_processor).value())).process_cpp_import(((((*this).program))),import_path,scope_id,is_c,defines))));
return result_scope_id;
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_fields(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_fields(child_namespace,child_namespace_scope_id))));
}

}
}

if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_465([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_fields(((chunk).parsed_namespace),((((chunk).generated_scopes))[i])))));
}

}
}

}

}
}

}
AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const record = ((record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((record_scope_id_).template get<1>());

types::StructLikeId const id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::StructLikeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_466; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added struct"sv))))));
}
TRY((((*this).typecheck_struct_fields(record,(struct_id.value())))));
__jakt_var_466 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_421;

}
__jakt_label_421:; __jakt_var_466.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_467; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added struct"sv))))));
}
TRY((((*this).typecheck_struct_fields(record,(struct_id.value())))));
__jakt_var_467 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_422;

}
__jakt_label_422:; __jakt_var_467.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_468; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added enum"sv))))));
}
__jakt_var_468 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_423;

}
__jakt_label_423:; __jakt_var_468.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_469; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added enum"sv))))));
}
__jakt_var_469 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_424;

}
__jakt_label_424:; __jakt_var_469.release_value(); }));
};/*case end*/
default: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord nested_record = (_magic_value.value());
{
TRY((((*this).warn_about_unimplemented_nested_record(nested_record))));
((records_to_process).enqueue((Tuple{nested_record, TRY((((id).scope_id(((((*this).program)))))))})));
}

}
}

}
}
return {};
}

typechecker::Typechecker::Typechecker(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<types::CheckedProgram> a_program, ids::ModuleId a_current_module_id, JaktInternal::Optional<ids::TypeId> a_current_struct_type_id, JaktInternal::Optional<ids::FunctionId> a_current_function_id, bool a_inside_defer, size_t a_checkidx, bool a_ignore_errors, bool a_dump_type_hints, bool a_dump_try_hints, u64 a_lambda_count, types::GenericInferences a_generic_inferences, JaktInternal::Optional<ids::TypeId> a_self_type_id, ByteString a_root_module_name, bool a_in_comptime_function_call, bool a_had_an_error, JaktInternal::Dictionary<ByteString,ids::ScopeId> a_cpp_import_cache, JaktInternal::Optional<cpp_import__none::CppImportProcessor> a_cpp_import_processor): compiler(move(a_compiler)), program(move(a_program)), current_module_id(move(a_current_module_id)), current_struct_type_id(move(a_current_struct_type_id)), current_function_id(move(a_current_function_id)), inside_defer(move(a_inside_defer)), checkidx(move(a_checkidx)), ignore_errors(move(a_ignore_errors)), dump_type_hints(move(a_dump_type_hints)), dump_try_hints(move(a_dump_try_hints)), lambda_count(move(a_lambda_count)), generic_inferences(move(a_generic_inferences)), self_type_id(move(a_self_type_id)), root_module_name(move(a_root_module_name)), in_comptime_function_call(move(a_in_comptime_function_call)), had_an_error(move(a_had_an_error)), cpp_import_cache(move(a_cpp_import_cache)), cpp_import_processor(move(a_cpp_import_processor)){}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::cast_to_underlying(NonnullRefPtr<typename parser::ParsedExpression> const expr,ids::ScopeId const scope_id,NonnullRefPtr<typename parser::ParsedType> const parsed_type) {
{
NonnullRefPtr<typename parser::ParsedExpression> const cast_expression = TRY((parser::ParsedExpression::UnaryOp(expr,parser::UnaryOperator::TypeCast(parser::TypeCast::Infallible(parsed_type)),((expr)->span()))));
return TRY((((*this).typecheck_expression(cast_expression,scope_id,types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::substitute_typevars_in_type(ids::TypeId const type_id,types::GenericInferences const generic_inferences) {
{
return TRY((((((*this).program))->substitute_typevars_in_type(type_id,generic_inferences,((*this).current_module_id)))));
}
}

ErrorOr<ByteString> typechecker::Typechecker::get_argument_name(JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> const arg) const {
{
if ((!(((((arg).template get<0>())).is_empty())))){
return ((arg).template get<0>());
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<ByteString>>{
auto&& __jakt_match_variant = *((arg).template get<2>());
switch(__jakt_match_variant.__jakt_init_index()) {
case 9 /* Var */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Var;ByteString const& name = __jakt_match_value.name;
{
return name;
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11 /* UnaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnaryOp;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
if (((((op).__jakt_init_index() == 7 /* Reference */) || ((op).__jakt_init_index() == 8 /* MutableReference */)) || ((op).__jakt_init_index() == 5 /* Dereference */))){
if (((expr)->__jakt_init_index() == 9 /* Var */)){
ByteString const name = (expr)->as.Var.name;
return name;
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return (ByteString::must_from_utf8(""sv));
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::with_qualifiers(parser::CheckedQualifiers const qualifiers,ids::TypeId const type_id) {
{
return TRY((((((*this).program))->apply_qualifiers_to_type(qualifiers,type_id))));
}
}

ErrorOr<ids::FunctionId> typechecker::Typechecker::typecheck_and_specialize_generic_function(ids::FunctionId const function_id,JaktInternal::DynamicArray<ids::TypeId> const generic_arguments,ids::ScopeId const parent_scope_id,JaktInternal::Optional<ids::TypeId> const this_type_id,types::GenericInferences const generic_substitutions,JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedType>> const type_args,utility::Span const call_span,JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>> const args) {
{
NonnullRefPtr<types::CheckedFunction> checked_function = ((*this).get_function(function_id));
if ((!(((((checked_function)->parsed_function)).has_value())))){
return function_id;
}
size_t const specialization_index = ((((((checked_function)->generics))->specializations)).size());
TRY((((((((checked_function)->generics))->specializations)).push(generic_arguments))));
ids::ModuleId const old_module_id = ((*this).current_module_id);
ScopeGuard __jakt_var_470([&] {
(((*this).current_module_id) = old_module_id);
});
(((*this).current_module_id) = ((((checked_function)->function_scope_id)).module_id));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::FunctionId const new_function_id = ((module)->next_function_id());
parser::ParsedFunction parsed_function = TRY((((checked_function)->to_parsed_function())));
ByteString arg_names = (ByteString::must_from_utf8(""sv));
{
JaktInternal::ArrayIterator<ids::TypeId> _magic = ((generic_arguments).iterator());
for (;;){
JaktInternal::Optional<ids::TypeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::TypeId arg = (_magic_value.value());
{
if ((!(((arg_names).is_empty())))){
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(arg_names,(ByteString::must_from_utf8(", "sv)))));
}
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(arg_names,TRY((((*this).type_name(arg,false)))))));
}

}
}

ids::ScopeId const scope_id = TRY((((*this).create_scope(((((checked_function)->generics))->base_scope_id),((parsed_function).can_throw),TRY((__jakt_format((StringView::from_string_literal("function-specialization({}<{}>)"sv)),((parsed_function).name),arg_names))),true))));
if (((((((parsed_function).generic_parameters)).size())) != (((generic_arguments).size())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Generic function {} expects {} generic arguments, but {} were given"sv)),((parsed_function).name),((((parsed_function).generic_parameters)).size()),((generic_arguments).size())))),((parsed_function).name_span)))));
}
if (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((((parsed_function).generic_parameters)).size()),((generic_arguments).size())) && [](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((((parsed_function).generic_parameters)).size()),((((((checked_function)->generics))->params)).size())))){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_function).generic_parameters)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
utility::Span arg_span = call_span;
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((type_args).size()),i)){
(arg_span = ((((type_args)[i]))->span()));
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((generic_arguments).size()),i)){
TRY((((*this).check_type_argument_requirements(((generic_arguments)[i]),((((((((((checked_function)->generics))->params))[i])).checked_parameter)).constraints),arg_span))));
}
}

}
}

utility::Span const span = ((parsed_function).name_span);
if (((this_type_id).has_value())){
JaktInternal::DynamicArray<types::CheckedGenericParameter> const p = (TRY((DynamicArray<types::CheckedGenericParameter>::create_with({}))));
JaktInternal::DynamicArray<ids::TypeId> const a = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
JaktInternal::Tuple<JaktInternal::DynamicArray<types::CheckedGenericParameter>,JaktInternal::DynamicArray<ids::TypeId>> const params_args_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::DynamicArray<types::CheckedGenericParameter>,JaktInternal::DynamicArray<ids::TypeId>>, ErrorOr<ids::FunctionId>>{
auto&& __jakt_match_variant = *((*this).get_type((this_type_id.value())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_struct(id))).generic_parameters), args}));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue((Tuple{((((*this).get_enum(id))).generic_parameters), args}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{p, a}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<types::CheckedGenericParameter> const params = ((params_args_).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const args = ((params_args_).template get<1>());

{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((params).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
types::CheckedGenericParameter const param = ((params)[i]);
ids::TypeId const arg = ((generic_substitutions).map(((args)[i])));
if (((((*this).get_type(((param).type_id))))->__jakt_init_index() == 18 /* TypeVariable */)){
ByteString const type_name = (((*this).get_type(((param).type_id))))->as.TypeVariable.name;
JaktInternal::Optional<ids::ScopeId> const dependent_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::ScopeId>, ErrorOr<ids::FunctionId>>{
auto&& __jakt_match_variant = *((*this).get_type(((param).type_id)));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_struct(struct_id))).scope_id));
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(struct_id))).scope_id));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_enum(enum_id))).scope_id));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(enum_id))).scope_id));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& trait_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_trait(trait_id)))->scope_id));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& trait_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_trait(trait_id)))->scope_id));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((*this).add_type_to_scope(scope_id,type_name,arg,span))));
if (((dependent_scope_id).has_value())){
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((((scope)->aliases)).set(type_name,(dependent_scope_id.value())))));
}
}
else {
continue;
}

}

}
}

}
{
JaktInternal::ArrayIterator<types::FunctionGenericParameter> _magic = ((((((checked_function)->generics))->params)).iterator());
for (;;){
JaktInternal::Optional<types::FunctionGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::FunctionGenericParameter generic_parameter = (_magic_value.value());
{
ids::TypeId const parameter_type_id = ((((generic_parameter).checked_parameter)).type_id);
JaktInternal::Optional<ids::TypeId> const mapped = ((generic_substitutions).get(parameter_type_id));
if (((mapped).has_value())){
ids::TypeId const type_id = (mapped.value());
if (((((*this).get_type(parameter_type_id)))->__jakt_init_index() == 18 /* TypeVariable */)){
ByteString const type_name = (((*this).get_type(parameter_type_id)))->as.TypeVariable.name;
bool const is_value = (((*this).get_type(parameter_type_id)))->as.TypeVariable.is_value;
JaktInternal::Optional<ids::ScopeId> const dependent_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::ScopeId>, ErrorOr<ids::FunctionId>>{
auto&& __jakt_match_variant = *((*this).get_type(parameter_type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_struct(struct_id))).scope_id));
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(struct_id))).scope_id));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_enum(enum_id))).scope_id));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(enum_id))).scope_id));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& trait_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((*this).get_trait(trait_id)))->scope_id));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& trait_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_trait(trait_id)))->scope_id));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((*this).add_type_to_scope(scope_id,type_name,type_id,span))));
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
if ((is_value && ((((*this).get_type(type_id)))->__jakt_init_index() == 32 /* Const */))){
types::Value const value = (((*this).get_type(type_id)))->as.Const.value;
TRY(((scope)->comptime_bindings).set(type_name, value));
NonnullRefPtr<types::CheckedVariable> const checked_var = TRY((types::CheckedVariable::__jakt_create(type_name,TRY((((((value).impl))->type_id(((((*this).program))))))),false,((value).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
TRY(((scope)->vars).set(type_name, TRY((((module)->add_variable(checked_var))))));
}
if (((dependent_scope_id).has_value())){
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((((scope)->aliases)).set(type_name,(dependent_scope_id.value())))));
}
}
else {
continue;
}

}
else {
continue;
}

}

}
}

(((parsed_function).must_instantiate) = true);
(((checked_function)->is_instantiated) = true);
JaktInternal::Optional<ids::FunctionId> const previous_function_id = ((*this).current_function_id);
(((*this).current_function_id) = static_cast<JaktInternal::Optional<ids::FunctionId>>(new_function_id));
TRY((((*this).typecheck_function_predecl(parsed_function,scope_id,this_type_id,((checked_function)->generics),JaktInternal::OptionalNone()))));
TRY((((*this).typecheck_function(parsed_function,scope_id))));
(((*this).current_function_id) = previous_function_id);
NonnullRefPtr<types::Scope> base_scope = TRY((((*this).get_scope((((TRY((((*this).get_scope(((((checked_function)->generics))->base_scope_id))))))->parent).value())))));
TRY(((((((((base_scope)->functions)).get(((checked_function)->name))).value())).push(new_function_id))));
NonnullRefPtr<types::CheckedFunction> function = ((*this).get_function(new_function_id));
(((function)->specialization_index) = specialization_index);
return new_function_id;
}
else {
return function_id;
}

}
}

ErrorOr<JaktInternal::Optional<JaktInternal::Tuple<ids::TypeId,ids::ScopeId>>> typechecker::Typechecker::find_type_scope(ids::ScopeId const scope_id,ByteString const name) const {
{
return TRY((((((*this).program))->find_type_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
}
}

NonnullRefPtr<types::CheckedFunction> typechecker::Typechecker::get_function(ids::FunctionId const id) const {
{
return ((((*this).program))->get_function(id));
}
}

ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> typechecker::Typechecker::required_scope_id_in_hierarchy_for(NonnullRefPtr<typename types::CheckedExpression> const expr,ids::ScopeId const current_scope_id) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Boolean */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 1 /* NumericConstant */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 2 /* QuotedString */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 3 /* ByteConstant */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 4 /* CharacterConstant */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 5 /* CCharacterConstant */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 33 /* Reflect */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())), expr}));
};/*case end*/
case 7 /* BinaryOp */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 6 /* UnaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnaryOp;types::CheckedUnaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* PreIncrement */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 2 /* PreDecrement */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 5 /* Dereference */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 7 /* Reference */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 8 /* MutableReference */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 11 /* TypeCast */: {
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 10 /* JaktArray */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktArray;JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_471; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename types::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename types::CheckedExpression> val = (_magic_value.value());
{
(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,((TRY((((*this).required_scope_id_in_hierarchy_for(val,current_scope_id))))).template get<0>()))))));
}

}
}

__jakt_var_471 = (Tuple{final_scope_id, expr}); goto __jakt_label_425;

}
__jakt_label_425:; __jakt_var_471.release_value(); }));
};/*case end*/
case 8 /* JaktTuple */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktTuple;JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_472; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename types::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename types::CheckedExpression> val = (_magic_value.value());
{
(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,((TRY((((*this).required_scope_id_in_hierarchy_for(val,current_scope_id))))).template get<0>()))))));
}

}
}

__jakt_var_472 = (Tuple{final_scope_id, expr}); goto __jakt_label_426;

}
__jakt_label_426:; __jakt_var_472.release_value(); }));
};/*case end*/
case 11 /* JaktSet */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktSet;JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_473; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename types::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename types::CheckedExpression> val = (_magic_value.value());
{
(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,((TRY((((*this).required_scope_id_in_hierarchy_for(val,current_scope_id))))).template get<0>()))))));
}

}
}

__jakt_var_473 = (Tuple{final_scope_id, expr}); goto __jakt_label_427;

}
__jakt_label_427:; __jakt_var_473.release_value(); }));
};/*case end*/
case 12 /* JaktDictionary */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktDictionary;JaktInternal::DynamicArray<JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_474; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>>> _magic = ((vals).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>> key__val__ = (_magic_value.value());
{
JaktInternal::Tuple<NonnullRefPtr<typename types::CheckedExpression>,NonnullRefPtr<typename types::CheckedExpression>> const jakt__key__val__ = key__val__;
NonnullRefPtr<typename types::CheckedExpression> const key = ((jakt__key__val__).template get<0>());
NonnullRefPtr<typename types::CheckedExpression> const val = ((jakt__key__val__).template get<1>());

(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,TRY((((*this).scope_lifetime_union(((TRY((((*this).required_scope_id_in_hierarchy_for(key,current_scope_id))))).template get<0>()),((TRY((((*this).required_scope_id_in_hierarchy_for(val,current_scope_id))))).template get<0>()))))))))));
}

}
}

__jakt_var_474 = (Tuple{final_scope_id, expr}); goto __jakt_label_428;

}
__jakt_label_428:; __jakt_var_474.release_value(); }));
};/*case end*/
case 9 /* Range */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 13 /* IndexedExpression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedExpression;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 14 /* IndexedDictionary */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedDictionary;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 15 /* IndexedTuple */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedTuple;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 16 /* IndexedStruct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedStruct;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 17 /* IndexedCommonEnumMember */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedCommonEnumMember;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 18 /* ComptimeIndex */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ComptimeIndex;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 19 /* Match */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 20 /* EnumVariantArg */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 21 /* Call */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 22 /* MethodCall */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MethodCall;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 24 /* Var */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Var;NonnullRefPtr<types::CheckedVariable> const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((var)->owner_scope).value_or_lazy_evaluated([&] { return current_scope_id; })), expr}));
};/*case end*/
case 23 /* NamespacedVar */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NamespacedVar;NonnullRefPtr<types::CheckedVariable> const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(((var)->owner_scope).value_or_lazy_evaluated([&] { return current_scope_id; })), expr}));
};/*case end*/
case 25 /* OptionalNone */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 26 /* OptionalSome */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 27 /* ForcedUnwrap */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ForcedUnwrap;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).required_scope_id_in_hierarchy_for(expr,current_scope_id)))));
};/*case end*/
case 28 /* Block */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 29 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;JaktInternal::DynamicArray<types::CheckedCapture> const& captures = __jakt_match_value.captures;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_475; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<types::CheckedCapture> _magic = ((captures).iterator());
for (;;){
JaktInternal::Optional<types::CheckedCapture> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedCapture capture = (_magic_value.value());
{
JaktInternal::Optional<ids::ScopeId> scope_id = JaktInternal::OptionalNone();
if ((((capture).__jakt_init_index() == 2 /* ByMutableReference */) || ((capture).__jakt_init_index() == 1 /* ByReference */))){
JaktInternal::Optional<JaktInternal::Optional<ids::ScopeId>> const scope_id = ((TRY((((*this).find_var_in_scope(current_scope_id,((capture).common.init_common.name),JaktInternal::OptionalNone()))))).map([](auto& _value) { return _value->owner_scope; }));
}
(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,scope_id)))));
}

}
}

__jakt_var_475 = (Tuple{final_scope_id, expr}); goto __jakt_label_429;

}
__jakt_label_429:; __jakt_var_475.release_value(); }));
};/*case end*/
case 30 /* DependentFunction */: {
auto&& __jakt_match_value = __jakt_match_variant.as.DependentFunction;JaktInternal::DynamicArray<types::CheckedCapture> const& captures = __jakt_match_value.captures;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>>> __jakt_var_476; {
JaktInternal::Optional<ids::ScopeId> final_scope_id = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<types::CheckedCapture> _magic = ((captures).iterator());
for (;;){
JaktInternal::Optional<types::CheckedCapture> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedCapture capture = (_magic_value.value());
{
JaktInternal::Optional<ids::ScopeId> scope_id = JaktInternal::OptionalNone();
if ((((capture).__jakt_init_index() == 2 /* ByMutableReference */) || ((capture).__jakt_init_index() == 1 /* ByReference */))){
JaktInternal::Optional<JaktInternal::Optional<ids::ScopeId>> const scope_id = ((TRY((((*this).find_var_in_scope(current_scope_id,((capture).common.init_common.name),JaktInternal::OptionalNone()))))).map([](auto& _value) { return _value->owner_scope; }));
}
(final_scope_id = TRY((((*this).scope_lifetime_union(final_scope_id,scope_id)))));
}

}
}

__jakt_var_476 = (Tuple{final_scope_id, expr}); goto __jakt_label_430;

}
__jakt_label_430:; __jakt_var_476.release_value(); }));
};/*case end*/
case 31 /* Try */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 32 /* TryBlock */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
case 34 /* Garbage */: {
return JaktInternal::ExplicitValue((Tuple{static_cast<JaktInternal::Optional<ids::ScopeId>>(JaktInternal::OptionalNone()), expr}));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<typechecker::TraitImplementationDescriptor>> typechecker::Typechecker::find_any_singular_trait_implementation(ids::TypeId const type_id,JaktInternal::DynamicArray<ByteString> const trait_names,ids::ScopeId const scope_id,utility::Span const span,JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const filter_for_generics) {
{
{
JaktInternal::ArrayIterator<ByteString> _magic = ((trait_names).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString trait_name = (_magic_value.value());
{
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const maybe_impl = TRY((((*this).find_singular_trait_implementation(type_id,trait_name,scope_id,span,filter_for_generics))));
if (((maybe_impl).has_value())){
return maybe_impl;
}
}

}
}

return JaktInternal::OptionalNone();
}
}

ErrorOr<void> typechecker::Typechecker::specialize_trait(ids::TraitId const trait_id,JaktInternal::DynamicArray<ids::TypeId> const generic_parameters) {
{
NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(trait_id));
if (((((trait_)->generic_parameters)).is_empty())){
return {};
}
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericTraitInstance(parser::CheckedQualifiers(false),trait_id,generic_parameters)))))))))));
ScopeGuard __jakt_var_477([&] {
(((*this).self_type_id) = old_self_type_id);
});
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((trait_)->generic_parameters)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
types::CheckedGenericParameter const parameter = ((((trait_)->generic_parameters))[i]);
ids::TypeId const type = ((generic_parameters)[i]);
TRY((((*this).check_types_for_compat(((parameter).type_id),type,((((*this).generic_inferences))),((parameter).span)))));
}

}
}

}
return {};
}

ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>>> typechecker::Typechecker::typecheck_match_variant(parser::ParsedMatchCase const case_,ids::TypeId const subject_type_id,size_t const variant_index,JaktInternal::Optional<ids::TypeId> const final_result_type,types::CheckedEnumVariant const variant,JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const variant_arguments,JaktInternal::Dictionary<ByteString,parser::ParsedPatternDefault> const default_bindings,utility::Span const arguments_span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode) {
{
JaktInternal::Optional<ByteString> covered_name = JaktInternal::OptionalNone();
ids::ScopeId const new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((__jakt_format((StringView::from_string_literal("catch-enum-variant({})"sv)),((variant).name())))),true))));
NonnullRefPtr<types::Module> module = ((*this).current_module());
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<ByteString>,types::CheckedMatchCase,JaktInternal::Optional<ids::TypeId>>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Untyped */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Untyped;ByteString const& name = __jakt_match_value.name;
{
(covered_name = name);
if ((!(((variant_arguments).is_empty())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case '{}' cannot have arguments"sv)),name))),arguments_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Typed */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Typed;ByteString const& name = __jakt_match_value.name;
ids::TypeId const& type_id = __jakt_match_value.type_id;
utility::Span const& span = __jakt_match_value.span;
{
(covered_name = name);
if ((!(((variant_arguments).is_empty())))){
if (((((variant_arguments).size())) != (static_cast<size_t>(1ULL)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case ‘{}’ must have exactly one argument"sv)),name))),span))));
}
else {
parser::EnumVariantPatternArgument const variant_argument = ((variant_arguments)[static_cast<i64>(0LL)]);
ids::TypeId const variable_type_id = TRY((((*this).substitute_typevars_in_type(type_id,((*this).generic_inferences)))));
ids::VarId const var_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create(((variant_argument).binding),variable_type_id,((variant_argument).is_mutable),span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))))));
TRY((((*this).add_var_to_scope(new_scope_id,((variant_argument).binding),var_id,span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3 /* StructLike */: {
auto&& __jakt_match_value = __jakt_match_variant.as.StructLike;ByteString const& name = __jakt_match_value.name;
JaktInternal::DynamicArray<ids::VarId> const& fields = __jakt_match_value.fields;
{
(covered_name = name);
JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedVariable>> field_variables = (TRY((DynamicArray<NonnullRefPtr<types::CheckedVariable>>::create_with({}))));
{
JaktInternal::ArrayIterator<ids::VarId> _magic = ((fields).iterator());
for (;;){
JaktInternal::Optional<ids::VarId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::VarId var_id = (_magic_value.value());
{
TRY((((field_variables).push(((((*this).program))->get_variable(var_id))))));
}

}
}

JaktInternal::Set<ByteString> seen_names = (TRY((Set<ByteString>::create_with_values({}))));
{
JaktInternal::ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((variant_arguments).iterator());
for (;;){
JaktInternal::Optional<parser::EnumVariantPatternArgument> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
if ((!(((((arg).name)).has_value())))){
bool found_field_name = false;
JaktInternal::DynamicArray<ByteString> field_names = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<types::CheckedVariable>> _magic = ((field_variables).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<types::CheckedVariable> var = (_magic_value.value());
{
TRY((((field_names).push(((var)->name)))));
if (((((var)->name)) == (((arg).binding)))){
(found_field_name = true);
}
}

}
}

if ((!(found_field_name))){
JaktInternal::DynamicArray<ByteString> unused_field_names = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<ByteString> _magic = ((field_names).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString field_name = (_magic_value.value());
{
if (((seen_names).contains(field_name))){
continue;
}
TRY((((unused_field_names).push(field_name))));
}

}
}

TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Match case argument '{}' for struct-like enum variant '{}' cannot be anon"sv)),((arg).binding),name))),((arg).span),TRY((__jakt_format((StringView::from_string_literal("Available arguments for '{}' are: {}\n"sv)),name,TRY((utility::join(unused_field_names,(ByteString::must_from_utf8(", "sv)))))))),((arg).span)))));
continue;
}
}
ByteString const arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); });
if (((seen_names).contains(arg_name))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case argument '{}' is already defined"sv)),arg_name))),((arg).span)))));
continue;
}
TRY((((seen_names).add(arg_name))));
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> matched_field_variable = JaktInternal::OptionalNone();
{
JaktInternal::ArrayIterator<NonnullRefPtr<types::CheckedVariable>> _magic = ((field_variables).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<types::CheckedVariable> var = (_magic_value.value());
{
if (((((var)->name)) == (arg_name))){
(matched_field_variable = var);
}
}

}
}

if (((matched_field_variable).has_value())){
ids::TypeId const substituted_type_id = TRY((((*this).substitute_typevars_in_type((((matched_field_variable.value()))->type_id),((*this).generic_inferences)))));
utility::Span const matched_span = (((matched_field_variable.value()))->definition_span);
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint((((matched_field_variable.value()))->type_id),((arg).span)))));
}
ids::VarId const var_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create(((arg).binding),substituted_type_id,((arg).is_mutable),matched_span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))))));
TRY((((*this).add_var_to_scope(new_scope_id,((arg).binding),var_id,matched_span))));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Match case argument '{}' does not exist in struct-like enum variant '{}'"sv)),arg_name,name))),((arg).span)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* WithValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.WithValue;ByteString const& name = __jakt_match_value.name;
{
(covered_name = name);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> defaults = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,parser::ParsedPatternDefault> _magic = ((default_bindings).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> ___default___ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,parser::ParsedPatternDefault> const jakt_____default___ = ___default___;
ByteString const _ = ((jakt_____default___).template get<0>());
parser::ParsedPatternDefault const default_ = ((jakt_____default___).template get<1>());

NonnullRefPtr<typename types::CheckedStatement> const checked_var_decl = TRY((((*this).typecheck_var_decl(((default_).variable),((default_).value),new_scope_id,safety_mode,((((default_).variable)).span)))));
TRY((((defaults).push(checked_var_decl))));
}

}
}

JaktInternal::Tuple<types::CheckedMatchBody,JaktInternal::Optional<ids::TypeId>> const checked_body_result_type_ = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((((*this).generic_inferences))),final_result_type,((case_).marker_span)))));
types::CheckedMatchBody const checked_body = ((checked_body_result_type_).template get<0>());
JaktInternal::Optional<ids::TypeId> const result_type = ((checked_body_result_type_).template get<1>());

types::CheckedMatchCase const checked_match_case = types::CheckedMatchCase::EnumVariant(defaults,((variant).name()),variant_arguments,subject_type_id,variant_index,new_scope_id,checked_body,((case_).marker_span));
return (Tuple{covered_name, checked_match_case, result_type});
}
}

ErrorOr<void> typechecker::Typechecker::include_prelude() {
{
ByteString const module_name = (ByteString::must_from_utf8("__prelude__"sv));
jakt__path::Path const file_name = TRY((jakt__path::Path::from_string(module_name)));
JaktInternal::DynamicArray<u8> const file_contents = (TRY((DynamicArray<u8>::create_with({static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(83), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(83), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(38), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(38), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(68), static_cast<u8>(121), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(107), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(100), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(95), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(38), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(97), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(100), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(83), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(97), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(100), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(68), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(67), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(80), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(80), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(107), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(111), static_cast<u8>(102), static_cast<u8>(102), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(66), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(80), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(95), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(102), static_cast<u8>(56), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(98), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(98), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(119), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(119), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(66), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(66), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(66), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(119), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(106), static_cast<u8>(115), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(66), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(80), static_cast<u8>(73), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(87), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(80), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(117), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(40), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(75), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(34), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(91), static_cast<u8>(93), static_cast<u8>(34), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(69), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(95), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(119), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(69), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(61), static_cast<u8>(34), static_cast<u8>(95), static_cast<u8>(95), static_cast<u8>(106), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(95), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(34), static_cast<u8>(93), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(95), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(119), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(69), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(117), static_cast<u8>(102), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(119), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(100), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(108), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(95), static_cast<u8>(95), static_cast<u8>(95), static_cast<u8>(106), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(100), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(98), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(80), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(80), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(119), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(68), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(68), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(98), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(98), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(32), static_cast<u8>(46), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(46), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(91), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(93), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(38), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(73), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(77), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(70), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(98), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(86), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(98), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(80), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(111), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(66), static_cast<u8>(108), static_cast<u8>(111), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(76), static_cast<u8>(105), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(40), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(108), static_cast<u8>(121), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(40), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(120), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(83), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(77), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(40), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(120), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(100), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(56), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(56), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(74), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(116), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(67), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(73), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(110), static_cast<u8>(107), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(110), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(78), static_cast<u8>(101), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(79), static_cast<u8>(114), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(40), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(80), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(77), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(58), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(100), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(118), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(100), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(56), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(56), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(105), static_cast<u8>(56), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(105), static_cast<u8>(49), static_cast<u8>(54), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(73), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(105), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(102), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(102), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(74), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(116), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(67), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(73), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(110), static_cast<u8>(107), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(107), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(110), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(78), static_cast<u8>(101), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(79), static_cast<u8>(114), static_cast<u8>(69), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(40), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(34), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(34), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(100), static_cast<u8>(46), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(86), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(34), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(34), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(80), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(34), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(34), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(46), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(34), static_cast<u8>(38), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(34), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(46), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(77), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(34), static_cast<u8>(38), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(34), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(46), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(109), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(61), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(34), static_cast<u8>(102), static_cast<u8>(110), static_cast<u8>(34), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10)}))));
JaktInternal::Optional<utility::FileId> const old_file_id = ((((*this).compiler))->current_file);
JaktInternal::DynamicArray<u8> const old_file_contents = ((((*this).compiler))->current_file_contents);
ScopeGuard __jakt_var_478([&] {
{
(((((*this).compiler))->current_file) = old_file_id);
(((((*this).compiler))->current_file_contents) = old_file_contents);
}

});
utility::FileId const file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
(((((*this).compiler))->current_file) = file_id);
(((((*this).compiler))->current_file_contents) = file_contents);
ids::ModuleId const prelude_module_id = TRY((((*this).create_module(module_name,false,JaktInternal::OptionalNone()))));
(((*this).current_module_id) = prelude_module_id);
TRY((((((*this).program))->set_loaded_module(module_name,types::LoadedModule(prelude_module_id,file_id)))));
ids::ScopeId const prelude_scope_id = TRY((((*this).create_scope(JaktInternal::OptionalNone(),false,(ByteString::must_from_utf8("prelude"sv)),false))));
JaktInternal::DynamicArray<lexer::Token> const tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
JaktInternal::ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
JaktInternal::Optional<lexer::Token> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln((StringView::from_string_literal("token: {}"sv)),token);
}

}
}

}
parser::ParsedNamespace const parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln((StringView::from_string_literal("{:#}"sv)),parsed_namespace);
}
TRY((((((*this).compiler))->dbg_println(TRY((__jakt_format((StringView::from_string_literal("before typechecking parsed prelude, modules ‘{}’"sv)),((((*this).program))->modules))))))));
TRY((((*this).typecheck_module(parsed_namespace,prelude_scope_id))));
}
return {};
}

ErrorOr<ids::ModuleId> typechecker::Typechecker::create_module(ByteString const name,bool const is_root,JaktInternal::Optional<ByteString> const path) {
{
size_t const new_id = ((((((*this).program))->modules)).size());
ids::ModuleId const module_id = ids::ModuleId(new_id);
NonnullRefPtr<types::Module> const module = TRY((types::Module::__jakt_create(module_id,name,(TRY((DynamicArray<NonnullRefPtr<types::CheckedFunction>>::create_with({})))),(TRY((DynamicArray<types::CheckedStruct>::create_with({})))),(TRY((DynamicArray<types::CheckedEnum>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<types::Scope>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<typename types::Type>>::create_with({TRY((types::Type::Void(parser::CheckedQualifiers(false)))), TRY((types::Type::Bool(parser::CheckedQualifiers(false)))), TRY((types::Type::U8(parser::CheckedQualifiers(false)))), TRY((types::Type::U16(parser::CheckedQualifiers(false)))), TRY((types::Type::U32(parser::CheckedQualifiers(false)))), TRY((types::Type::U64(parser::CheckedQualifiers(false)))), TRY((types::Type::I8(parser::CheckedQualifiers(false)))), TRY((types::Type::I16(parser::CheckedQualifiers(false)))), TRY((types::Type::I32(parser::CheckedQualifiers(false)))), TRY((types::Type::I64(parser::CheckedQualifiers(false)))), TRY((types::Type::F32(parser::CheckedQualifiers(false)))), TRY((types::Type::F64(parser::CheckedQualifiers(false)))), TRY((types::Type::Usize(parser::CheckedQualifiers(false)))), TRY((types::Type::JaktString(parser::CheckedQualifiers(false)))), TRY((types::Type::CChar(parser::CheckedQualifiers(false)))), TRY((types::Type::CInt(parser::CheckedQualifiers(false)))), TRY((types::Type::Unknown(parser::CheckedQualifiers(false)))), TRY((types::Type::Never(parser::CheckedQualifiers(false))))})))),(TRY((DynamicArray<NonnullRefPtr<types::CheckedTrait>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<types::CheckedVariable>>::create_with({})))),(TRY((DynamicArray<ids::ModuleId>::create_with({})))),path.value_or_lazy_evaluated([&] { return (((((((*this).compiler))->current_file_path()).value())).to_string()); }),(TRY((Dictionary<size_t, ids::StructId>::create_with_entries({})))),is_root)));
TRY((((((((*this).program))->modules)).push(module))));
return module_id;
}
}

ids::ScopeId typechecker::Typechecker::prelude_scope_id() const {
{
return ((((*this).program))->prelude_scope_id());
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_namespaced_var_or_simple_enum_constructor_call(ByteString const name,JaktInternal::DynamicArray<ByteString> const namespace_,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint,utility::Span const span) {
{
JaktInternal::DynamicArray<ids::ScopeId> scopes = (TRY((DynamicArray<ids::ScopeId>::create_with({scope_id}))));
{
JaktInternal::ArrayIterator<ByteString> _magic = ((namespace_).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString ns = (_magic_value.value());
{
ids::ScopeId const scope = ((scopes)[JaktInternal::checked_sub(((scopes).size()),static_cast<size_t>(1ULL))]);
JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>> const ns_in_scope = TRY((((*this).find_namespace_in_scope(scope,ns,false,JaktInternal::OptionalNone()))));
JaktInternal::Optional<ids::EnumId> const enum_in_scope = TRY((((((*this).program))->find_enum_in_scope(scope,ns,false,JaktInternal::OptionalNone()))));
ids::ScopeId next_scope = scope;
if (((ns_in_scope).has_value())){
(next_scope = (((ns_in_scope.value())).template get<0>()));
}
else if (((enum_in_scope).has_value())){
(next_scope = ((((*this).get_enum((enum_in_scope.value())))).scope_id));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Namespace ‘{}’ not found"sv)),ns))),span))));
}

TRY((((scopes).push(next_scope))));
}

}
}

ids::ScopeId const scope = (((scopes).last()).value());
size_t i = static_cast<size_t>(0ULL);
size_t const min_length = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((scopes).size()),((namespace_).size())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((scopes).size()));
}
else {
return JaktInternal::ExplicitValue(((namespace_).size()));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<types::CheckedNamespace> checked_namespaces = (TRY((DynamicArray<types::CheckedNamespace>::create_with({}))));
while ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(i,min_length)){
TRY((((checked_namespaces).push(types::CheckedNamespace(((namespace_)[i]),scope)))));
((i++));
}
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const var = TRY((((*this).find_var_in_scope(scope,name,JaktInternal::OptionalNone()))));
if (((var).has_value())){
return TRY((types::CheckedExpression::NamespacedVar(JaktInternal::OptionalNone(),checked_namespaces,(var.value()),span)));
}
parser::ParsedCall const implicit_constructor_call = parser::ParsedCall(namespace_,name,(TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedType>>::create_with({})))));
NonnullRefPtr<typename types::CheckedExpression> const call_expression = TRY((((*this).typecheck_call(implicit_constructor_call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,true))));
ids::TypeId const type_id = ((call_expression)->type());
types::CheckedCall const call = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedCall, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *call_expression;
switch(__jakt_match_variant.__jakt_init_index()) {
case 21 /* Call */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Call;types::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(call);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("typecheck_call returned something other than a CheckedCall"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if (((((call).function_id)).has_value())){
return TRY((types::CheckedExpression::Call(JaktInternal::OptionalNone(),call,span,type_id)));
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Variable '{}' not found"sv)),name))),span))));
return TRY((types::CheckedExpression::NamespacedVar(JaktInternal::OptionalNone(),checked_namespaces,TRY((types::CheckedVariable::__jakt_create(name,types::unknown_type_id(),false,span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))),span)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl(parser::ParsedRecord const parsed_record,ids::StructId const struct_id,ids::ScopeId const scope_id) {
{
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(true))));
ScopeGuard __jakt_var_479([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(struct_type_id))));
ScopeGuard __jakt_var_480([&] {
(((*this).self_type_id) = old_self_type_id);
});
ids::ScopeId const struct_scope_id = ((((((((*this).current_module()))->structures))[((struct_id).id)])).scope_id);
TRY((((*this).add_struct_to_scope(scope_id,((parsed_record).name),struct_id,((parsed_record).name_span)))));
JaktInternal::Optional<ids::StructId> super_struct_id = JaktInternal::OptionalNone();
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Class */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Class;JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const& super_parsed_type = __jakt_match_value.super_type;
return (({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<void>>{
auto __jakt_enum_value = (((super_parsed_type).has_value()));
if (__jakt_enum_value == true) {
{
ids::TypeId const super_type_id = TRY((((*this).typecheck_typename((super_parsed_type.value()),scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<typename types::Type> const super_type = ((*this).get_type(super_type_id));
if (((super_type)->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const struct_id = (super_type)->as.Struct.value;
(super_struct_id = struct_id);
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Class can only inherit from another class"sv)),(((super_parsed_type.value()))->span())))));
}

}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == false) {
{
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
})), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const& super_parsed_type = __jakt_match_value.super_type;
return (({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<void>>{
auto __jakt_enum_value = (((super_parsed_type).has_value()));
if (__jakt_enum_value == true) {
{
ids::TypeId const super_type_id = TRY((((*this).typecheck_typename((super_parsed_type.value()),scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<typename types::Type> const super_type = ((*this).get_type(super_type_id));
if (((super_type)->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const struct_id = (super_type)->as.Struct.value;
(super_struct_id = struct_id);
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Struct can only inherit from another struct"sv)),(((super_parsed_type.value()))->span())))));
}

}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == false) {
{
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
})), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic((ByteString::must_from_utf8("Expected Struct or Class in typecheck_struct_predecl"sv)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
NonnullRefPtr<types::Module> module = ((*this).current_module());
(((((module)->structures))[((struct_id).id)]) = types::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((DynamicArray<types::CheckedGenericParameter>::create_with({})))),JaktInternal::OptionalNone(),(TRY((DynamicArray<types::CheckedField>::create_with({})))),struct_scope_id,((parsed_record).definition_linkage),(TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>::create_with_entries({})))),((parsed_record).record_type),struct_type_id,super_struct_id,((parsed_record).external_name),JaktInternal::OptionalNone()));
JaktInternal::DynamicArray<types::CheckedGenericParameter> generic_parameters = ((((((module)->structures))[((struct_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
ids::TypeId const parameter_type_id = ids::TypeId(((*this).current_module_id),((((((*this).current_module()))->types)).size()));
types::CheckedGenericParameter parameter = TRY((types::CheckedGenericParameter::make(parameter_type_id,((gen_parameter).span))));
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
TRY((((((module)->types)).push(TRY((types::Type::TypeVariable(parser::CheckedQualifiers(false),((gen_parameter).name),trait_implementations,((gen_parameter).is_value))))))));
if (((((gen_parameter).requires_list)).has_value())){
TRY((((*this).fill_trait_requirements((((gen_parameter).requires_list).value()),((((parameter).constraints))),((trait_implementations)),scope_id))));
}
TRY((((generic_parameters).push(parameter))));
TRY((((*this).add_type_to_scope(struct_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

bool const is_extern = ((((parsed_record).definition_linkage)).__jakt_init_index() == 1 /* External */);
(((((((module)->structures))[((struct_id).id)])).generic_parameters) = generic_parameters);
(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_unary_operation(NonnullRefPtr<typename types::CheckedExpression> const checked_expr,types::CheckedUnaryOperator const checked_op,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode) {
{
ids::TypeId const expr_type_id = ((checked_expr)->type());
NonnullRefPtr<typename types::Type> const expr_type = ((*this).get_type(expr_type_id));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = checked_op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* PreIncrement */: {
{
if (((*this).is_integer(expr_type_id))){
if ((!(((checked_expr)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of immutable variable"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of non-numeric value"sv)),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* PostIncrement */: {
{
if (((*this).is_integer(expr_type_id))){
if ((!(((checked_expr)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of immutable variable"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of non-numeric value"sv)),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* PreDecrement */: {
{
if (((*this).is_integer(expr_type_id))){
if ((!(((checked_expr)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of immutable variable"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of non-numeric value"sv)),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3 /* PostDecrement */: {
{
if (((*this).is_integer(expr_type_id))){
if ((!(((checked_expr)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of immutable variable"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Increment/decrement of non-numeric value"sv)),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9 /* LogicalNot */: {
{
if ((!(TRY((((*this).check_types_for_compat(types::builtin(types::BuiltinType::Bool()),((checked_expr)->type()),((((*this).generic_inferences))),span))))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot use a logical Not on a value of non-boolean type"sv)),span))));
}
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,expr_type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10 /* BitwiseNot */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,expr_type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11 /* TypeCast */: {
auto&& __jakt_match_value = __jakt_match_variant.as.TypeCast;types::CheckedTypeCast const& cast = __jakt_match_value.value;
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,((cast).type_id()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4 /* Negate */: {
{
return TRY((((*this).typecheck_unary_negate(checked_expr,span,expr_type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12 /* Is */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,types::builtin(types::BuiltinType::Bool()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13 /* IsEnumVariant */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,types::builtin(types::BuiltinType::Bool()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14 /* IsSome */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,types::builtin(types::BuiltinType::Bool()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 15 /* IsNone */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,types::builtin(types::BuiltinType::Bool()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 16 /* Sizeof */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,types::builtin(types::BuiltinType::Usize()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6 /* RawAddress */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((types::Type::RawPtr(parser::CheckedQualifiers(false),expr_type_id))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7 /* Reference */: {
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((types::Type::Reference(parser::CheckedQualifiers(false),expr_type_id))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8 /* MutableReference */: {
{
if ((!(((checked_expr)->is_mutable(((*this).program)))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot make mutable reference to immutable value"sv)),span))));
}
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((types::Type::MutableReference(parser::CheckedQualifiers(false),expr_type_id))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5 /* Dereference */: {
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 26 /* RawPtr */: {
auto&& __jakt_match_value = __jakt_match_variant.as.RawPtr;ids::TypeId const& type_id = __jakt_match_value.value;
{
if (((safety_mode).__jakt_init_index() == 0 /* Safe */)){
TRY((((*this).error((ByteString::must_from_utf8("Dereference of raw pointer outside of unsafe block"sv)),span))));
}
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28 /* Reference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reference;ids::TypeId const& type_id = __jakt_match_value.value;
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29 /* MutableReference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MutableReference;ids::TypeId const& type_id = __jakt_match_value.value;
{
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Dereference of a non-pointer type ‘{}’"sv)),TRY((((*this).type_name(expr_type_id,false))))))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return TRY((types::CheckedExpression::UnaryOp(JaktInternal::OptionalNone(),checked_expr,checked_op,span,expr_type_id)));
}
}

ErrorOr<void> typechecker::Typechecker::warn_about_unimplemented_nested_record(parser::ParsedRecord const record) {
{
if (((((record).definition_linkage)).__jakt_init_index() == 0 /* Internal */)){
TRY((((*this).error((ByteString::must_from_utf8("Only external nested types are currently supported"sv)),((record).name_span)))));
}
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::infer_unsigned_int(u64 const val,utility::Span const span,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
NonnullRefPtr<typename types::CheckedExpression> expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U64(val),span,types::builtin(types::BuiltinType::U64()))));
if (((type_hint).has_value())){
ids::TypeId const hint = (type_hint.value());
if (((hint).equals(types::builtin(types::BuiltinType::I8())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I8());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I8((infallible_integer_cast<i8>((val)))),span,types::builtin(types::BuiltinType::I8())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::I16())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I16());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I16((infallible_integer_cast<i16>((val)))),span,types::builtin(types::BuiltinType::I16())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::I32())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I32());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I32((infallible_integer_cast<i32>((val)))),span,types::builtin(types::BuiltinType::I32())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U8())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U8());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U8((infallible_integer_cast<u8>((val)))),span,types::builtin(types::BuiltinType::U8())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U16())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U16());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U16((infallible_integer_cast<u16>((val)))),span,types::builtin(types::BuiltinType::U16())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U32())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U32());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((type_)->max()),val)){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U32((infallible_integer_cast<u32>((val)))),span,types::builtin(types::BuiltinType::U32())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U64())))){
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U64((infallible_integer_cast<u64>((val)))),span,types::builtin(types::BuiltinType::U64())))));
}
else if (((hint).equals(types::builtin(types::BuiltinType::Usize())))){
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::USize((infallible_integer_cast<u64>((val)))),span,types::builtin(types::BuiltinType::Usize())))));
}
else if (((hint).equals(types::builtin(types::BuiltinType::CInt())))){
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::USize((infallible_integer_cast<u64>((val)))),span,types::builtin(types::BuiltinType::CInt())))));
}
else if (((hint).equals(types::builtin(types::BuiltinType::CChar())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::CChar());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](u64 const& self, u64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](u64 const& self, u64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,static_cast<u64>(255ULL))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U8((infallible_integer_cast<u8>((val)))),span,types::builtin(types::BuiltinType::CChar())))));
}

}
}
return expr;
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::strip_optional_from_type(ids::TypeId const type_id) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<ids::TypeId>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_481; {
if (((id).equals(TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))))))){
return ((args)[static_cast<i64>(0LL)]);
}
__jakt_var_481 = type_id; goto __jakt_label_431;

}
__jakt_label_431:; __jakt_var_481.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<types::FieldRecord>> typechecker::Typechecker::lookup_struct_field(ids::StructId const struct_id,ByteString const name) const {
{
JaktInternal::DynamicArray<ids::StructId> chain = (TRY((DynamicArray<ids::StructId>::create_with({}))));
JaktInternal::Optional<ids::StructId> current = static_cast<JaktInternal::Optional<ids::StructId>>(struct_id);
TRY((((chain).push((current.value())))));
while (((current).has_value())){
JaktInternal::Optional<ids::StructId> const parent = ((((*this).get_struct((current.value())))).super_struct_id);
if (((parent).has_value())){
TRY((((chain).push((parent.value())))));
}
(current = parent);
}
{
JaktInternal::ArrayIterator<ids::StructId> _magic = ((chain).iterator());
for (;;){
JaktInternal::Optional<ids::StructId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::StructId current_struct_id = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((((*this).get_struct(current_struct_id))).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const variable = ((*this).get_variable(((field).variable_id)));
if (((((variable)->name)) == (name))){
return types::FieldRecord(current_struct_id,((field).variable_id));
}
}

}
}

}

}
}

return JaktInternal::OptionalNone();
}
}

ErrorOr<types::CheckedParameter> typechecker::Typechecker::typecheck_parameter(parser::ParsedParameter const parameter,ids::ScopeId const scope_id,bool const first,JaktInternal::Optional<ids::TypeId> const this_arg_type_id,JaktInternal::Optional<ids::ScopeId> const check_scope) {
{
ids::TypeId type_id = TRY((((*this).typecheck_typename(((((parameter).variable)).parsed_type),scope_id,((((parameter).variable)).name)))));
if ((first && ((((((parameter).variable)).name)) == ((ByteString::must_from_utf8("this"sv)))))){
if (((this_arg_type_id).has_value())){
(type_id = (this_arg_type_id.value()));
}
}
if (((((((*this).get_type(type_id)))->common.init_common.qualifiers)).is_immutable)){
(type_id = TRY((((*this).with_qualifiers(parser::CheckedQualifiers(false),type_id)))));
if (((((parameter).variable)).is_mutable)){
TRY((((*this).error((ByteString::must_from_utf8("Cannot have a mutable binding to an immutable parameter"sv)),((((parameter).variable)).span)))));
}
}
NonnullRefPtr<types::CheckedVariable> const variable = TRY((types::CheckedVariable::__jakt_create(((((parameter).variable)).name),type_id,((((parameter).variable)).is_mutable),((((parameter).variable)).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
types::CheckedParameter const checked_parameter = types::CheckedParameter(((parameter).requires_label),variable,({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>,ErrorOr<types::CheckedParameter>>{
auto __jakt_enum_value = (((((parameter).default_argument)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((Tuple{(((parameter).default_argument).value()), scope_id}));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
if (((check_scope).has_value())){
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((parameter).variable)).name),var_id,((((parameter).variable)).span)))));
}
return checked_parameter;
}
}

ErrorOr<types::BlockControlFlow> typechecker::Typechecker::maybe_statement_control_flow(JaktInternal::Optional<NonnullRefPtr<typename types::CheckedStatement>> const statement,types::BlockControlFlow const other_branch) const {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (((statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((((*this).statement_control_flow((statement.value()))))));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(((other_branch).partial()));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<ids::TypeId>> typechecker::Typechecker::unify(ids::TypeId const lhs,utility::Span const lhs_span,ids::TypeId const rhs,utility::Span const rhs_span) {
{
if ((!(TRY((((*this).check_types_for_compat(lhs,rhs,((((*this).generic_inferences))),lhs_span))))))){
return JaktInternal::OptionalNone();
}
return TRY((((*this).substitute_typevars_in_type(lhs,((*this).generic_inferences)))));
}
}

bool typechecker::Typechecker::is_floating(ids::TypeId const type_id) const {
{
return ((((*this).program))->is_floating(type_id));
}
}

ErrorOr<JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>>> typechecker::Typechecker::find_var_in_scope(ids::ScopeId const scope_id,ByteString const var,JaktInternal::Optional<ids::ScopeId> const root_scope_id) const {
{
return TRY((((((*this).program))->find_var_in_scope(scope_id,var,false,JaktInternal::OptionalNone()))));
}
}

ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>> typechecker::Typechecker::struct_like_id_from_type_id(ids::TypeId const type_id,ids::ScopeId const scope_id,utility::Span const span,bool const for_optional_chain,bool const treat_string_as_builtin) {
{
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(type_id));
bool found_optional = false;
JaktInternal::Optional<types::StructLikeId> const parent_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Struct(JaktInternal::OptionalNone(),id)));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Enum(JaktInternal::OptionalNone(),id)));
};/*case end*/
case 13 /* JaktString */: {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>,ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto __jakt_enum_value = (treat_string_as_builtin);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(types::StructLikeId::Struct(JaktInternal::OptionalNone(),TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))))));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Struct(JaktInternal::OptionalNone(),TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("String"sv)))))))));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<types::StructLikeId>> __jakt_var_482; {
__jakt_var_482 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>,ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto __jakt_enum_value = (for_optional_chain);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<types::StructLikeId>> __jakt_var_483; {
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
JaktInternal::Optional<types::StructLikeId> struct_id = JaktInternal::OptionalNone();
if ((!(((id).equals(optional_struct_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Can't use ‘{}’ as an optional type in optional chained call"sv)),((((*this).get_struct(id))).name)))),span))));
}
else {
(found_optional = true);
(struct_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto&& __jakt_match_variant = *((*this).get_type(((args)[static_cast<i64>(0LL)])));
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(types::StructLikeId::Struct(JaktInternal::OptionalNone(),struct_id));
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(types::StructLikeId::Struct(JaktInternal::OptionalNone(),struct_id));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(types::StructLikeId::Enum(JaktInternal::OptionalNone(),id));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(types::StructLikeId::Enum(JaktInternal::OptionalNone(),id));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_484; {
TRY((((*this).error((ByteString::must_from_utf8("Can't use non-struct type as an optional type in optional chained call"sv)),span))));
(found_optional = false);
__jakt_var_484 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),optional_struct_id); goto __jakt_label_434;

}
__jakt_label_434:; __jakt_var_484.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}

__jakt_var_483 = static_cast<JaktInternal::Optional<types::StructLikeId>>(struct_id.value_or_lazy_evaluated([&] { return types::StructLikeId::Struct(JaktInternal::OptionalNone(),optional_struct_id); })); goto __jakt_label_433;

}
__jakt_label_433:; __jakt_var_483.release_value(); }));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Struct(args,id)));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_432;

}
__jakt_label_432:; __jakt_var_482.release_value(); }));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Enum(args,id)));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Trait(JaktInternal::OptionalNone(),id)));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Trait(args,id)));
};/*case end*/
case 18 /* TypeVariable */: {
auto&& __jakt_match_value = __jakt_match_variant.as.TypeVariable;JaktInternal::DynamicArray<ids::TypeId> const& trait_implementations = __jakt_match_value.trait_implementations;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>,ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto __jakt_enum_value = (((trait_implementations).size()));
if (__jakt_enum_value == static_cast<size_t>(0ULL)) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
else {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>, ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto&& __jakt_match_variant = *((*this).get_type(((trait_implementations)[static_cast<i64>(0LL)])));
switch(__jakt_match_variant.__jakt_init_index()) {
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Trait(JaktInternal::OptionalNone(),id)));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<types::StructLikeId>>(types::StructLikeId::Trait(args,id)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<types::StructLikeId>,ErrorOr<JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool>>>{
auto __jakt_enum_value = (((type)->is_builtin()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(types::StructLikeId::Struct(JaktInternal::OptionalNone(),TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))))));
}
else {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_485; {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("no methods available on value (type: {} {})"sv)),TRY((((((*this).get_type(type_id)))->constructor_name()))),TRY((((*this).type_name(type_id,false))))))),span))));
__jakt_var_485 = JaktInternal::OptionalNone(); goto __jakt_label_435;

}
__jakt_label_435:; __jakt_var_485; }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return (Tuple{parent_id, found_optional});
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::find_type_in_prelude(ByteString const name) const {
{
ids::ScopeId const scope_id = ((*this).prelude_scope_id());
JaktInternal::Optional<ids::TypeId> const type_id = TRY((((*this).find_type_in_scope(scope_id,name))));
if (((type_id).has_value())){
return ((type_id).value());
}
TRY((((((*this).compiler))->panic(TRY((__jakt_format((StringView::from_string_literal("internal error: {} builtin definition not found"sv)),name)))))));
}
}

ErrorOr<bool> typechecker::Typechecker::add_type_to_scope(ids::ScopeId const scope_id,ByteString const type_name,ids::TypeId const type_id,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<ids::TypeId> const found_type_id = ((((scope)->types)).get(type_name));
if ((((found_type_id).has_value()) && (!((((found_type_id.value())).equals(type_id)))))){
if (((TRY((((*this).get_scope(scope_id)))))->is_from_generated_code)){
return false;
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Redefinition of type ‘{}’ (duplicate: {} in {})"sv)),type_name,TRY((((*this).type_name((found_type_id.value()),true)))),TRY((((*this).debug_description_of(scope_id))))))),span))));
TRY((((((*this).generic_inferences)).debug_description(((((*this).program)))))));
return false;
}
TRY((((((scope)->types)).set(type_name,type_id))));
return true;
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::infer_signed_int(i64 const val,utility::Span const span,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
NonnullRefPtr<typename types::CheckedExpression> expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I64(val),span,types::builtin(types::BuiltinType::I64()))));
if (((type_hint).has_value())){
ids::TypeId const hint = (type_hint.value());
if (((hint).equals(types::builtin(types::BuiltinType::I8())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I8());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I8((infallible_integer_cast<i8>((val)))),span,types::builtin(types::BuiltinType::I8())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::I16())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I16());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I16((infallible_integer_cast<i16>((val)))),span,types::builtin(types::BuiltinType::I16())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::I32())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::I32());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I32((infallible_integer_cast<i32>((val)))),span,types::builtin(types::BuiltinType::I32())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U8())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U8());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U8((infallible_integer_cast<u8>((val)))),span,types::builtin(types::BuiltinType::U8())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U16())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U16());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U16((infallible_integer_cast<u16>((val)))),span,types::builtin(types::BuiltinType::U16())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U32())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::U32());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,((type_)->min())) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,(infallible_integer_cast<i64>((((type_)->max()))))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U32((infallible_integer_cast<u32>((val)))),span,types::builtin(types::BuiltinType::U32())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::U64())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::Usize());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,static_cast<i64>(0LL))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U64((infallible_integer_cast<u64>((val)))),span,types::builtin(types::BuiltinType::U64())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::Usize())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::Usize());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,static_cast<i64>(0LL))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::USize((infallible_integer_cast<u64>((val)))),span,types::builtin(types::BuiltinType::Usize())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::CInt())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::CInt());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if ([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,static_cast<i64>(0LL))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I32((infallible_integer_cast<i32>((val)))),span,types::builtin(types::BuiltinType::CInt())))));
}

}
else if (((hint).equals(types::builtin(types::BuiltinType::CChar())))){
ids::TypeId const builtin_typeid = types::builtin(types::BuiltinType::CChar());
NonnullRefPtr<typename types::Type> const type_ = ((*this).get_type(builtin_typeid));
if (([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(val,static_cast<i64>(0LL)) || [](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(val,static_cast<i64>(255LL)))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Integer promotion failed"sv)),span,TRY((__jakt_format((StringView::from_string_literal("Cannot fit value into range [{}, {}] of type {}."sv)),((type_)->min()),((type_)->max()),TRY((((*this).type_name(builtin_typeid,false))))))),span))));
}
else {
(expr = TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U8((infallible_integer_cast<u8>((val)))),span,types::builtin(types::BuiltinType::CChar())))));
}

}
}
return expr;
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_aliases(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id,typechecker::ImportRestrictions const allow) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_aliases(child_namespace,child_namespace_scope_id,allow))));
}

}
}

if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_486([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_aliases(((chunk).parsed_namespace),((((chunk).generated_scopes))[i]),allow))));
}

}
}

}

}
}

}
{
JaktInternal::ArrayIterator<parser::ParsedAlias> _magic = ((((parsed_namespace).aliases)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedAlias> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedAlias alias = (_magic_value.value());
{
TRY((((*this).typecheck_alias(alias,scope_id,allow))));
}

}
}

}
return {};
}

ErrorOr<bool> typechecker::Typechecker::add_struct_to_scope(ids::ScopeId const scope_id,ByteString const name,ids::StructId const struct_id,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<ids::StructId> const maybe_scope_id = ((((scope)->structs)).get(name));
if (((maybe_scope_id).has_value())){
if (((TRY((((*this).get_scope(scope_id)))))->is_from_generated_code)){
return false;
}
ids::StructId const existing_struct_id = (maybe_scope_id.value());
utility::Span const definition_span = ((((*this).get_struct(existing_struct_id))).name_span);
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("redefinition of struct/class {}"sv)),name))),span,TRY((__jakt_format((StringView::from_string_literal("struct/class {} was first defined here"sv)),name))),definition_span))));
return false;
}
TRY((((((scope)->structs)).set(name,struct_id))));
return true;
}
}

ErrorOr<void> typechecker::Typechecker::error(ByteString const message,utility::Span const span) {
{
(((*this).had_an_error) = true);
if ((!(((*this).ignore_errors)))){
TRY((((((((*this).compiler))->errors)).push(error::JaktError::Message(message,span)))));
}
else {
(((*this).had_an_error) = true);
}

}
return {};
}

ErrorOr<bool> typechecker::Typechecker::check_restricted_access(ids::ScopeId const accessor,ByteString const accessee_kind,ids::ScopeId const accessee,ByteString const name,JaktInternal::DynamicArray<NonnullRefPtr<typename types::MaybeResolvedScope>> const whitelist,utility::Span const span) {
{
ids::ScopeId const most_specific_active_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId,ErrorOr<bool>>{
auto __jakt_enum_value = (((((*this).current_function_id)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((((*this).get_function((((*this).current_function_id).value()))))->function_scope_id));
}
else {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_487; {
if ((!(((((*this).current_struct_type_id)).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Can't access {0} ‘{1}’ from this global scope, because ‘{1}’ restricts access to it"sv)),accessee_kind,name))),span))));
return false;
}
__jakt_var_487 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId, ErrorOr<bool>>{
auto&& __jakt_match_variant = *((*this).get_type((((*this).current_struct_type_id).value())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(id))).scope_id));
};/*case end*/
default: {
{
utility::panic(TRY((__jakt_format((StringView::from_string_literal("Internal error: current_struct_type_id is not a struct"sv)),span))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_436;

}
__jakt_label_436:; __jakt_var_487.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename types::MaybeResolvedScope>> _magic = ((whitelist).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename types::MaybeResolvedScope>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename types::MaybeResolvedScope> scope = (_magic_value.value());
{
NonnullRefPtr<typename types::MaybeResolvedScope> const resolved_scope = TRY((((scope)->try_resolve(((*this).program)))));
if (((resolved_scope)->__jakt_init_index() == 0 /* Resolved */)){
ids::ScopeId const scope_id = (resolved_scope)->as.Resolved.value;
if (TRY((((*this).scope_can_access(most_specific_active_scope_id,scope_id))))){
return true;
}
}
else {
continue;
}

}

}
}

NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(most_specific_active_scope_id))));
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Cannot access {} ‘{}’ from this scope"sv)),accessee_kind,name))),span))));
return false;
}
}

ErrorOr<bool> typechecker::Typechecker::check_types_for_compat(ids::TypeId const lhs_type_id,ids::TypeId const rhs_type_id,types::GenericInferences& generic_inferences,utility::Span const span) {
{
if (((((lhs_type_id).equals(rhs_type_id)) || ((lhs_type_id).equals(types::unknown_type_id()))) || ((rhs_type_id).equals(types::unknown_type_id())))){
return true;
}
NonnullRefPtr<typename types::Type> const lhs_type = ((*this).get_type(lhs_type_id));
NonnullRefPtr<typename types::Type> const rhs_type = ((*this).get_type(rhs_type_id));
if ((((((lhs_type)->common.init_common.qualifiers)).is_immutable) && (!(((((rhs_type)->common.init_common.qualifiers)).is_immutable))))){
return TRY((((*this).check_types_for_compat(lhs_type_id,TRY((((*this).with_qualifiers(((lhs_type)->common.init_common.qualifiers),rhs_type_id)))),generic_inferences,span))));
}
if ((((lhs_type)->is_builtin()) && (((rhs_type)->is_builtin()) && ((((((lhs_type)->as_builtin_type())).id())) == (((((rhs_type)->as_builtin_type())).id())))))){
return true;
}
if (((lhs_type)->__jakt_init_index() == 31 /* Self */)){
if ((!(((((*this).self_type_id)).has_value())))){
TRY((((*this).error((ByteString::must_from_utf8("Invalid use of the 'Self' type"sv)),span))));
}
else {
return TRY((((*this).check_types_for_compat((((*this).self_type_id).value()),rhs_type_id,generic_inferences,span))));
}

}
if (((rhs_type)->__jakt_init_index() == 31 /* Self */)){
if ((!(((((*this).self_type_id)).has_value())))){
TRY((((*this).error((ByteString::must_from_utf8("Invalid use of the 'Self' type"sv)),span))));
}
else {
return TRY((((*this).check_types_for_compat(lhs_type_id,(((*this).self_type_id).value()),generic_inferences,span))));
}

}
if ((((rhs_type)->__jakt_init_index() == 18 /* TypeVariable */) && (!(((lhs_type)->__jakt_init_index() == 18 /* TypeVariable */))))){
return TRY((((*this).check_types_for_compat(rhs_type_id,lhs_type_id,generic_inferences,span))));
}
if (((rhs_type)->__jakt_init_index() == 32 /* Const */)){
types::Value const rhs = (rhs_type)->as.Const.value;
if (((lhs_type)->__jakt_init_index() == 32 /* Const */)){
types::Value const lhs = (lhs_type)->as.Const.value;
if (((((rhs).impl))->equals(((lhs).impl)))){
return true;
}
NonnullRefPtr<interpreter::Interpreter> const interpreter = TRY((((*this).interpreter())));
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Literal type value mismatch: expected '{}', found '{}'"sv)),TRY((types::comptime_format_impl((ByteString::must_from_utf8("{}"sv)),(((TRY((DynamicArray<types::Value>::create_with({lhs})))))[(JaktInternal::Range<i64>{static_cast<i64>(0LL),static_cast<i64>(9223372036854775807LL)})]),((((*this).program)))))),TRY((types::comptime_format_impl((ByteString::must_from_utf8("{}"sv)),(((TRY((DynamicArray<types::Value>::create_with({rhs})))))[(JaktInternal::Range<i64>{static_cast<i64>(0LL),static_cast<i64>(9223372036854775807LL)})]),((((*this).program))))))))),span))));
return false;
}
}
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
ids::StructId const weakptr_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv))))));
ids::StructId const array_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Array"sv))))));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *lhs_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 18 /* TypeVariable */: {
{
JaktInternal::Optional<ids::TypeId> const maybe_resolved_inference = ((((generic_inferences))).get(lhs_type_id));
if (((maybe_resolved_inference).has_value())){
ids::TypeId const resolved_inference = (maybe_resolved_inference.value());
return TRY((((*this).check_types_for_compat(resolved_inference,rhs_type_id,generic_inferences,span))));
}
else {
TRY((((((generic_inferences))).set(lhs_type_id,rhs_type_id))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19 /* Dependent */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Dependent;ids::TypeId const& namespace_type = __jakt_match_value.namespace_type;
ByteString const& name = __jakt_match_value.name;
{
if (((rhs_type)->__jakt_init_index() == 19 /* Dependent */)){
ids::TypeId const rhs_namespace_type = (rhs_type)->as.Dependent.namespace_type;
ByteString const rhs_name = (rhs_type)->as.Dependent.name;
TRY((((*this).check_types_for_compat(namespace_type,rhs_namespace_type,generic_inferences,span))));
if ([](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(name,rhs_name)){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: mismatched names for dependent types: ‘{}’ and ‘{}’"sv)),name,rhs_name))),span))));
return false;
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& lhs_enum_id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& lhs_args = __jakt_match_value.args;
{
if (((rhs_type)->__jakt_init_index() == 21 /* GenericEnumInstance */)){
ids::EnumId const rhs_enum_id = (rhs_type)->as.GenericEnumInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const rhs_args = (rhs_type)->as.GenericEnumInstance.args;
if (((lhs_enum_id).equals(rhs_enum_id))){
types::CheckedEnum const lhs_enum = ((*this).get_enum(lhs_enum_id));
if (((((lhs_args).size())) == (((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((lhs_args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span))))))){
return false;
}
(++(idx));
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("mismatched number of generic parameters for {}"sv)),((lhs_enum).name)))),span))));
return false;
}

}
}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;JaktInternal::DynamicArray<ids::TypeId> const& lhs_params = __jakt_match_value.params;
bool const& lhs_can_throw = __jakt_match_value.can_throw;
ids::TypeId const& lhs_return_type_id = __jakt_match_value.return_type_id;
{
if (((rhs_type)->__jakt_init_index() == 30 /* Function */)){
JaktInternal::DynamicArray<ids::TypeId> const rhs_params = (rhs_type)->as.Function.params;
bool const rhs_can_throw = (rhs_type)->as.Function.can_throw;
ids::TypeId const rhs_return_type_id = (rhs_type)->as.Function.return_type_id;
if ((!(((lhs_can_throw) == (rhs_can_throw))))){
ByteString const lhs_throw = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString,ErrorOr<bool>>{
auto __jakt_enum_value = (lhs_can_throw);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("Yes"sv)));
}
else {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("No"sv)));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
ByteString const rhs_throw = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString,ErrorOr<bool>>{
auto __jakt_enum_value = (rhs_can_throw);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("Yes"sv)));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue((ByteString::must_from_utf8("No"sv)));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Function can throw mismatch: expected ‘{}’, but got ‘{}’"sv)),lhs_throw,rhs_throw))),span))));
}
if ((!(((((lhs_params).size())) == (((rhs_params).size())))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Function parameter count mismatch: expected ‘{}’, but got ‘{}’"sv)),((lhs_params).size()),((rhs_params).size())))),span))));
return false;
}
if ((!(TRY((((*this).check_types_for_compat(lhs_return_type_id,rhs_return_type_id,generic_inferences,span))))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Function type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("The return types differ: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_return_type_id,false)))),TRY((((*this).type_name(rhs_return_type_id,false))))))),span))));
return false;
}
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(0LL),static_cast<size_t>(((lhs_params).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(TRY((((*this).check_types_for_compat(((lhs_params)[i]),((rhs_params)[i]),generic_inferences,span))))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Function type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span,TRY((__jakt_format((StringView::from_string_literal("The parameter types differ at argument {}: expected ‘{}’, but got ‘{}’"sv)),JaktInternal::checked_add(i,static_cast<size_t>(1ULL)),TRY((((*this).type_name(((lhs_params)[i]),false)))),TRY((((*this).type_name(((rhs_params)[i]),false))))))),span))));
return false;
}
}

}
}

}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
ids::StructId const lhs_struct_id = id;
JaktInternal::DynamicArray<ids::TypeId> lhs_args = args;
if ((((lhs_struct_id).equals(optional_struct_id)) || ((lhs_struct_id).equals(weakptr_struct_id)))){
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((lhs_args).size()),static_cast<size_t>(0ULL))){
if (((((lhs_args)[static_cast<i64>(0LL)])).equals(rhs_type_id))){
return true;
}
}
}
if (((rhs_type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (rhs_type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (rhs_type)->as.GenericInstance.args;
ids::StructId const rhs_struct_id = id;
if (((lhs_struct_id).equals(rhs_struct_id))){
JaktInternal::DynamicArray<ids::TypeId> rhs_args = args;
types::CheckedStruct const lhs_struct = ((*this).get_struct(lhs_struct_id));
if (((((lhs_struct).generic_parameter_defaults)).has_value())){
JaktInternal::DynamicArray<JaktInternal::Optional<ids::TypeId>> const defaults = (((lhs_struct).generic_parameter_defaults).value());
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((lhs_args).size()),((defaults).size()))){
JaktInternal::DynamicArray<ids::TypeId> new_args = TRY((((((lhs_args)[(JaktInternal::Range<i64>{static_cast<i64>(0LL),static_cast<i64>(9223372036854775807LL)})])).to_array())));
size_t idx = ((lhs_args).size());
while (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((defaults).size())) && ((((defaults)[idx])).has_value()))){
TRY((((new_args).push((((defaults)[idx]).value())))));
(++(idx));
}
(lhs_args = new_args);
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(((rhs_args).size()),((defaults).size()))){
JaktInternal::DynamicArray<ids::TypeId> new_args = TRY((((((rhs_args)[(JaktInternal::Range<i64>{static_cast<i64>(0LL),static_cast<i64>(9223372036854775807LL)})])).to_array())));
size_t idx = ((rhs_args).size());
while (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((defaults).size())) && ((((defaults)[idx])).has_value()))){
TRY((((new_args).push((((defaults)[idx]).value())))));
(++(idx));
}
(rhs_args = new_args);
}
}
if (((((lhs_args).size())) == (((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span))))))){
return false;
}
(++(idx));
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("mismatched number of generic parameters for {}"sv)),((lhs_struct).name)))),span))));
return false;
}

}
else if (((lhs_struct_id).equals(array_struct_id))){
ids::TypeId const array_value_type_id = ((args)[static_cast<i64>(0LL)]);
if (((array_value_type_id).equals(types::unknown_type_id()))){
return true;
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}

}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
if (((lhs_type_id).equals(rhs_type_id))){
return true;
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
if (((enum_id).equals(id))){
types::CheckedEnum const lhs_enum = ((*this).get_enum(enum_id));
if (((((args).size())) != (((((lhs_enum).generic_parameters)).size())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("mismatched number of generic parameters for {}"sv)),((lhs_enum).name)))),span))));
return false;
}
size_t idx = static_cast<size_t>(0ULL);
while ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((((((lhs_enum).generic_parameters))[idx])).type_id),((args)[idx]),generic_inferences,span))))))){
return false;
}
(++(idx));
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18 /* TypeVariable */: {
{
JaktInternal::Optional<ids::TypeId> const maybe_seen_type_id = ((((generic_inferences))).get(rhs_type_id));
if (((maybe_seen_type_id).has_value())){
if ([](ids::TypeId const& self, ids::TypeId rhs) -> bool {
{
return (!(((self).equals(rhs))));
}
}
((maybe_seen_type_id.value()),lhs_type_id)){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(((maybe_seen_type_id).value()),false))))))),span))));
return false;
}
}
else {
TRY((((((generic_inferences))).set(lhs_type_id,rhs_type_id))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& lhs_struct_id = __jakt_match_value.value;
{
if ((((lhs_type_id).equals(rhs_type_id)) || ((*this).is_subclass_of(rhs_type_id,lhs_type_id)))){
return true;
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
if ((!(((lhs_struct_id).equals(id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
types::CheckedStruct const lhs_struct = ((*this).get_struct(lhs_struct_id));
if (((((args).size())) != (((((lhs_struct).generic_parameters)).size())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("mismatched number of generic parameters for {}"sv)),((lhs_struct).name)))),span))));
return false;
}
size_t idx = static_cast<size_t>(0ULL);
while ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(0)));
}
}
(idx,((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((((((lhs_struct).generic_parameters))[idx])).type_id),((args)[idx]),generic_inferences,span))))))){
return false;
}
(++(idx));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18 /* TypeVariable */: {
{
JaktInternal::Optional<ids::TypeId> const seen_type_id = ((((generic_inferences))).get(rhs_type_id));
if (((seen_type_id).has_value())){
if ([](ids::TypeId const& self, ids::TypeId rhs) -> bool {
{
return (!(((self).equals(rhs))));
}
}
(((seen_type_id).value()),lhs_type_id)){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(((seen_type_id).value()),false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}
else {
TRY((((((generic_inferences))).set(lhs_type_id,rhs_type_id))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if (((*this).is_subclass_of(lhs_type_id,rhs_type_id))){
return true;
}
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26 /* RawPtr */: {
auto&& __jakt_match_value = __jakt_match_variant.as.RawPtr;ids::TypeId const& lhs_rawptr_type_id = __jakt_match_value.value;
{
if (((lhs_rawptr_type_id).equals(rhs_type_id))){
return true;
}
if (((rhs_type)->__jakt_init_index() == 26 /* RawPtr */)){
ids::TypeId const rhs_rawptr_type_id = (rhs_type)->as.RawPtr.value;
if ((!(TRY((((*this).check_types_for_compat(lhs_rawptr_type_id,rhs_rawptr_type_id,generic_inferences,span))))))){
return false;
}
}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28 /* Reference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reference;ids::TypeId const& lhs_inner_type_id = __jakt_match_value.value;
{
if (((rhs_type)->__jakt_init_index() == 28 /* Reference */)){
ids::TypeId const rhs_inner_type_id = (rhs_type)->as.Reference.value;
if ((!(TRY((((*this).check_types_for_compat(lhs_inner_type_id,rhs_inner_type_id,generic_inferences,span))))))){
return false;
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29 /* MutableReference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MutableReference;ids::TypeId const& lhs_inner_type_id = __jakt_match_value.value;
{
if (((rhs_type)->__jakt_init_index() == 29 /* MutableReference */)){
ids::TypeId const rhs_inner_type_id = (rhs_type)->as.MutableReference.value;
if ((!(TRY((((*this).check_types_for_compat(lhs_inner_type_id,rhs_inner_type_id,generic_inferences,span))))))){
return false;
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ([](ids::TypeId const& self, ids::TypeId rhs) -> bool {
{
return (!(((self).equals(rhs))));
}
}
(((((generic_inferences))).map(rhs_type_id)),((((generic_inferences))).map(lhs_type_id)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),span))));
return false;
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return true;
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl(parser::ParsedRecord const parsed_record,ids::EnumId const enum_id,ids::ScopeId const scope_id) {
{
ids::TypeId const enum_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Enum(parser::CheckedQualifiers(false),enum_id)))))));
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(enum_type_id))));
ScopeGuard __jakt_var_488([&] {
(((*this).self_type_id) = old_self_type_id);
});
ids::ScopeId const enum_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((__jakt_format((StringView::from_string_literal("enum({})"sv)),((parsed_record).name)))),false))));
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(enum_scope_id))));
(((scope)->namespace_name) = ((parsed_record).name));
(((scope)->relevant_type_id) = enum_type_id);
TRY((((*this).add_enum_to_scope(scope_id,((parsed_record).name),enum_id,((parsed_record).name_span)))));
ids::TypeId const underlying_type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 2 /* ValueEnum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ValueEnum;NonnullRefPtr<typename parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_typename(underlying_type,scope_id,JaktInternal::OptionalNone())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::Void()));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
bool const is_boxed = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 3 /* SumEnum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.SumEnum;bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<types::CheckedField> checked_fields = (TRY((DynamicArray<types::CheckedField>::create_with({}))));
JaktInternal::Set<ByteString> seen_fields = (TRY((Set<ByteString>::create_with_values({}))));
if (((((parsed_record).record_type)).__jakt_init_index() == 3 /* SumEnum */)){
JaktInternal::DynamicArray<parser::ParsedField> const fields = (((parsed_record).record_type)).as.SumEnum.fields;
{
JaktInternal::ArrayIterator<parser::ParsedField> _magic = ((fields).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedField field = (_magic_value.value());
{
parser::ParsedVarDecl const var_decl = ((field).var_decl);
if (((seen_fields).contains(((var_decl).name)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Field '{}' is defined more than once"sv)),((var_decl).name)))),((var_decl).span)))));
continue;
}
TRY((((seen_fields).add(((var_decl).name)))));
ids::TypeId const type_id = TRY((((*this).typecheck_typename(((var_decl).parsed_type),enum_scope_id,((var_decl).name)))));
NonnullRefPtr<types::CheckedVariable> const checked_var = TRY((types::CheckedVariable::__jakt_create(((var_decl).name),type_id,((var_decl).is_mutable),((var_decl).span),((((var_decl).parsed_type))->span()),TRY((((*this).typecheck_visibility(((field).visibility),enum_scope_id)))),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),((var_decl).external_name))));
if ((((*this).dump_type_hints) && ((((var_decl).parsed_type))->__jakt_init_index() == 15 /* Empty */))){
TRY((((*this).dump_type_hint(type_id,((var_decl).span)))));
}
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const variable_id = TRY((((module)->add_variable(checked_var))));
JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>> const default_value_expression = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>,ErrorOr<void>>{
auto __jakt_enum_value = (((((field).default_value)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>>((Tuple{(((field).default_value).value()), enum_scope_id})));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((checked_fields).push(types::CheckedField(variable_id,default_value_expression)))));
}

}
}

}
NonnullRefPtr<types::Module> module = ((*this).current_module());
(((((module)->enums))[((enum_id).id)]) = types::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((DynamicArray<types::CheckedGenericParameter>::create_with({})))),(TRY((DynamicArray<types::CheckedEnumVariant>::create_with({})))),checked_fields,enum_scope_id,((parsed_record).definition_linkage),(TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>::create_with_entries({})))),((parsed_record).record_type),underlying_type_id,enum_type_id,is_boxed));
JaktInternal::DynamicArray<types::CheckedGenericParameter> generic_parameters = ((((((module)->enums))[((enum_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
ids::TypeId const parameter_type_id = ids::TypeId(((*this).current_module_id),((((((*this).current_module()))->types)).size()));
types::CheckedGenericParameter checked_param = TRY((types::CheckedGenericParameter::make(parameter_type_id,((gen_parameter).span))));
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
TRY((((((module)->types)).push(TRY((types::Type::TypeVariable(parser::CheckedQualifiers(false),((gen_parameter).name),trait_implementations,((gen_parameter).is_value))))))));
if (((((gen_parameter).requires_list)).has_value())){
TRY((((*this).fill_trait_requirements((((gen_parameter).requires_list).value()),((((checked_param).constraints))),((trait_implementations)),scope_id))));
}
TRY((((generic_parameters).push(checked_param))));
TRY((((*this).add_type_to_scope(enum_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

if (((((parsed_record).implements_list)).has_value())){
TRY((((*this).fill_trait_implementation_list((((parsed_record).implements_list).value()),((((((((module)->enums))[((enum_id).id)])).trait_implementations))),enum_scope_id,JaktInternal::OptionalNone()))));
}
}
return {};
}

ErrorOr<bool> typechecker::Typechecker::signatures_match_impl(ids::TypeId const self_type_id,NonnullRefPtr<types::CheckedFunction> const first,NonnullRefPtr<types::CheckedFunction> const second,Function<ErrorOr<bool>(typechecker::Typechecker&, ids::TypeId, ids::TypeId)> const& types_match) {
{
if (TRY((types_match(((*this)),((first)->return_type_id),((second)->return_type_id))))){
if (((((first)->can_throw)) == (((second)->can_throw)))){
if (((((((first)->params)).size())) == (((((second)->params)).size())))){
size_t arg_start = static_cast<size_t>(0ULL);
if (TRY((((first)->is_static())))){
if (TRY((((second)->is_static())))){
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Function signatures don't match: one is static and the other isn't"sv)),((first)->name_span)))));
return false;
}

}
else {
if ((!(TRY((((second)->is_static())))))){
if (((TRY((((first)->is_mutating())))) == (TRY((((second)->is_mutating())))))){
(arg_start = static_cast<size_t>(1ULL));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Function signatures don't match: one is mutating and the other isn't"sv)),((first)->name_span)))));
return false;
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Function signatures don't match: one is static and the other isn't"sv)),((first)->name_span)))));
return false;
}

}

{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(arg_start),static_cast<size_t>(((((first)->params)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (TRY((types_match(((*this)),((((((((first)->params))[i])).variable))->type_id),((((((((second)->params))[i])).variable))->type_id))))){
}
else {
return false;
}

}

}
}

return true;
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Function signatures don't match: different number of parameters"sv)),((first)->name_span)))));
return false;
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Function signatures don't match: one can throw and the other can't"sv)),((first)->name_span)))));
return false;
}

}
else {
return false;
}

}
}

ErrorOr<void> typechecker::Typechecker::check_member_access(ids::ScopeId const accessor,ids::ScopeId const accessee,NonnullRefPtr<types::CheckedVariable> const member,utility::Span const span) {
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((member)->visibility);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Private */: {
{
if ((!(TRY((((*this).scope_can_access(accessor,accessee))))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Can't access field ‘{}’, because it is marked private"sv)),((member)->name)))),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* Restricted */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Restricted;JaktInternal::DynamicArray<NonnullRefPtr<typename types::MaybeResolvedScope>> const& scopes = __jakt_match_value.scopes;
{
TRY((((*this).check_restricted_access(accessor,(ByteString::must_from_utf8("field"sv)),accessee,((member)->name),scopes,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

bool typechecker::Typechecker::is_integer(ids::TypeId const type_id) const {
{
return ((((*this).program))->is_integer(type_id));
}
}

ErrorOr<JaktInternal::Tuple<bool,JaktInternal::DynamicArray<error::JaktError>>> typechecker::Typechecker::signatures_match(ids::TypeId const self_type_id,NonnullRefPtr<types::CheckedFunction> const first,NonnullRefPtr<types::CheckedFunction> const second) {
{
size_t const starting_error_count = ((((((*this).compiler))->errors)).size());
Function<ErrorOr<bool>(typechecker::Typechecker&, ids::TypeId, ids::TypeId)> const types_match = [self_type_id](typechecker::Typechecker& typechecker, ids::TypeId a, ids::TypeId b) -> ErrorOr<bool> {
{
ids::TypeId const mapped_a = ((((((typechecker))).generic_inferences)).map(a));
ids::TypeId const mapped_b = ((((((typechecker))).generic_inferences)).map(b));
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<bool>>{
auto&& __jakt_match_variant = *((((typechecker))).get_type(mapped_a));
switch(__jakt_match_variant.__jakt_init_index()) {
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((((typechecker))).implements_trait(mapped_b,id,JaktInternal::OptionalNone())))));
};/*case end*/
case 31 /* Self */: {
return JaktInternal::ExplicitValue(TRY((((((typechecker))).check_types_for_compat(self_type_id,mapped_b,((((((typechecker))).generic_inferences))),utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)))))));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((((typechecker))).implements_trait(mapped_b,id,args)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((((typechecker))).check_types_for_compat(mapped_a,mapped_b,((((((typechecker))).generic_inferences))),utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)))))));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}
;
bool const result = TRY((((*this).signatures_match_impl(self_type_id,first,second,((types_match))))));
JaktInternal::DynamicArray<error::JaktError> const errors = TRY((((((((((*this).compiler))->errors))[(JaktInternal::Range<size_t>{static_cast<size_t>(starting_error_count),static_cast<size_t>(9223372036854775807LL)})])).to_array())));
(((((*this).compiler))->errors) = TRY((((((((((*this).compiler))->errors))[(JaktInternal::Range<size_t>{static_cast<size_t>(0LL),static_cast<size_t>(starting_error_count)})])).to_array()))));
return (Tuple{result, errors});
}
}

ErrorOr<NonnullRefPtr<typename types::Type>> typechecker::Typechecker::unwrap_type_from_optional_if_needed(NonnullRefPtr<typename types::Type> const type) const {
{
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
if (((type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (type)->as.GenericInstance.args;
if (((id).equals(optional_struct_id))){
return ((*this).get_type(((args)[static_cast<i64>(0LL)])));
}
}
return type;
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_guard(NonnullRefPtr<typename parser::ParsedExpression> const expr,parser::ParsedBlock const else_block,parser::ParsedBlock const remaining_code,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
bool seen_scope_exit = false;
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedStatement>> _magic = ((((else_block).stmts)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedStatement> statement = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.__jakt_init_index()) {
case 10 /* Break */: {
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11 /* Continue */: {
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12 /* Return */: {
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13 /* Throw */: {
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

types::CheckedBlock const checked_else_block = TRY((((*this).typecheck_block(else_block,scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((!(seen_scope_exit)) && ((((checked_else_block).control_flow)).may_return()))){
TRY((((*this).error((ByteString::must_from_utf8("Else block of guard must either `return`, `break`, `continue`, or `throw`"sv)),span))));
}
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>> const new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(expr,JaktInternal::OptionalNone(),remaining_code,TRY((parser::ParsedStatement::Block(else_block,span))),scope_id,span))));
NonnullRefPtr<typename parser::ParsedExpression> const new_condition = ((new_condition_new_then_block_new_else_statement_).template get<0>());
JaktInternal::Optional<parser::ParsedBlock> const new_then_block = ((new_condition_new_then_block_new_else_statement_).template get<1>());
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const new_else_statement = ((new_condition_new_then_block_new_else_statement_).template get<2>());

NonnullRefPtr<typename types::CheckedExpression> const checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((((checked_condition)->type())).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("Condition must be a boolean expression"sv)),((new_condition)->span())))));
}
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block((new_then_block.value()),scope_id,safety_mode,JaktInternal::OptionalNone()))));
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode,JaktInternal::OptionalNone())))));
}
if (((((checked_block).yielded_type)).has_value())){
return TRY((types::CheckedStatement::Yield(TRY((types::CheckedExpression::Match(JaktInternal::OptionalNone(),checked_condition,(TRY((DynamicArray<types::CheckedMatchCase>::create_with({types::CheckedMatchCase::Expression((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),TRY((types::CheckedExpression::Boolean(JaktInternal::OptionalNone(),true,span))),types::CheckedMatchBody::Expression(TRY((types::CheckedExpression::Block(JaktInternal::OptionalNone(),checked_block,span,(((checked_block).yielded_type).value()))))),span), types::CheckedMatchCase::CatchAll((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),false,types::CheckedMatchBody::Block(checked_else_block),span)})))),span,(((checked_block).yielded_type).value()),false))),span)));
}
return TRY((types::CheckedStatement::If(checked_condition,checked_block,checked_else,span)));
}
}

NonnullRefPtr<typename types::Type> typechecker::Typechecker::get_type(ids::TypeId const id) const {
{
return ((((*this).program))->get_type(id));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_trait_implementations_predecl(ids::ScopeId const scope_id) {
{
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
{
JaktInternal::ArrayIterator<ids::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
JaktInternal::Optional<ids::ScopeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::ScopeId child = (_magic_value.value());
{
TRY((((*this).typecheck_namespace_trait_implementations_predecl(child))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::StructId> ___struct_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::StructId> const jakt_____struct_id__ = ___struct_id__;
ByteString const _ = ((jakt_____struct_id__).template get<0>());
ids::StructId const struct_id = ((jakt_____struct_id__).template get<1>());

types::CheckedStruct const struct_ = ((*this).get_struct(struct_id));
TRY((((*this).typecheck_entity_trait_implementations_predecl(((struct_).scope_id),((struct_).type_id),((struct_).trait_implementations),((struct_).name),((struct_).name_span)))));
}

}
}

}
return {};
}

ErrorOr<bool> typechecker::Typechecker::add_trait_to_scope(ids::ScopeId const scope_id,ByteString const trait_name,ids::TraitId const trait_id,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<ids::TraitId> const found_trait_id = ((((scope)->traits)).get(trait_name));
if ((((found_trait_id).has_value()) && (!((((found_trait_id.value())).equals(trait_id)))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Redefinition of trait ‘{}’"sv)),trait_name))),span))));
return false;
}
TRY((((((scope)->traits)).set(trait_name,trait_id))));
return true;
}
}

ErrorOr<JaktInternal::Optional<ids::ScopeId>> typechecker::Typechecker::scope_lifetime_union(JaktInternal::Optional<ids::ScopeId> const first,JaktInternal::Optional<ids::ScopeId> const second) const {
{
if (((!(((first).has_value()))) || (!(((second).has_value()))))){
return JaktInternal::OptionalNone();
}
ids::ScopeId const first_id = (first.value());
ids::ScopeId const second_id = (second.value());
if (((first_id).equals(((*this).root_scope_id())))){
return second_id;
}
if (((second_id).equals(((*this).root_scope_id())))){
return first_id;
}
{
JaktInternal::Optional<ids::ScopeId> scope_id = static_cast<JaktInternal::Optional<ids::ScopeId>>(first_id);
while (((scope_id).has_value())){
if ((((scope_id.value())).equals(second_id))){
return first_id;
}
(scope_id = ((TRY((((*this).get_scope((scope_id.value()))))))->parent));
}
}

{
JaktInternal::Optional<ids::ScopeId> scope_id = static_cast<JaktInternal::Optional<ids::ScopeId>>(second_id);
while (((scope_id).has_value())){
if ((((scope_id.value())).equals(first_id))){
return second_id;
}
(scope_id = ((TRY((((*this).get_scope((scope_id.value()))))))->parent));
}
}

return JaktInternal::OptionalNone();
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_destructuring_assignment(JaktInternal::DynamicArray<parser::ParsedVarDecl> const vars,NonnullRefPtr<typename parser::ParsedStatement> const var_decl,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedStatement>> var_decls = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({}))));
NonnullRefPtr<typename types::CheckedStatement> const checked_tuple_var_decl = TRY((((*this).typecheck_statement(var_decl,scope_id,safety_mode,JaktInternal::OptionalNone()))));
ids::TypeId expr_type_id = types::unknown_type_id();
ids::VarId tuple_var_id = ids::VarId(ids::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL));
if (((checked_tuple_var_decl)->__jakt_init_index() == 3 /* VarDecl */)){
ids::VarId const var_id = (checked_tuple_var_decl)->as.VarDecl.var_id;
NonnullRefPtr<typename types::CheckedExpression> const init = (checked_tuple_var_decl)->as.VarDecl.init;
(expr_type_id = ((init)->type()));
(tuple_var_id = var_id);
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Destructuting assignment should be a variable declaration"sv)),span))));
}

JaktInternal::DynamicArray<ids::TypeId> inner_types = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
NonnullRefPtr<typename types::Type> const tuple_type = ((*this).get_type(expr_type_id));
if (((tuple_type)->__jakt_init_index() == 20 /* GenericInstance */)){
JaktInternal::DynamicArray<ids::TypeId> const args = (tuple_type)->as.GenericInstance.args;
(inner_types = args);
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Tuple Type should be Generic Instance"sv)),span))));
}

NonnullRefPtr<types::CheckedVariable> const tuple_variable = ((((*this).program))->get_variable(tuple_var_id));
if (((((vars).size())) == (((inner_types).size())))){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vars).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedVarDecl new_var = ((vars)[i]);
(((new_var).parsed_type) = TRY((parser::ParsedType::Name(JaktInternal::OptionalNone(),TRY((((*this).type_name(((inner_types)[i]),false)))),span))));
NonnullRefPtr<typename parser::ParsedExpression> const init = TRY((parser::ParsedExpression::IndexedTuple(TRY((parser::ParsedExpression::Var(((tuple_variable)->name),span))),i,false,span)));
TRY((((var_decls).push(TRY((((*this).typecheck_var_decl(((vars)[i]),init,scope_id,safety_mode,span))))))));
}

}
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Tuple inner types sould have same size as tuple members"sv)),span))));
}

return TRY((types::CheckedStatement::DestructuringAssignment(var_decls,checked_tuple_var_decl,span)));
}
}

ErrorOr<bool> typechecker::Typechecker::is_scope_directly_accessible_from(ids::ScopeId const scope_id,ids::ScopeId const from_scope_id) const {
{
return TRY((((((*this).program))->is_scope_directly_accessible_from(scope_id,from_scope_id,false))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_constructors(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_constructors(child_namespace,child_namespace_scope_id))));
}

}
}

if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_489([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_constructors(((chunk).parsed_namespace),((((chunk).generated_scopes))[i])))));
}

}
}

}

}
}

}
AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const record = ((record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((record_scope_id_).template get<1>());

types::StructLikeId const id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::StructLikeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_490; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added struct"sv))))));
}
TRY((((*this).typecheck_struct_constructor(record,(struct_id.value()),scope_id))));
__jakt_var_490 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_437;

}
__jakt_label_437:; __jakt_var_490.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_491; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added struct"sv))))));
}
TRY((((*this).typecheck_struct_constructor(record,(struct_id.value()),scope_id))));
__jakt_var_491 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),(struct_id.value())); goto __jakt_label_438;

}
__jakt_label_438:; __jakt_var_491.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_492; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added enum"sv))))));
}
TRY((((*this).typecheck_enum_constructor(record,(enum_id.value()),scope_id))));
__jakt_var_492 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_439;

}
__jakt_label_439:; __jakt_var_492.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_493; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find previously added enum"sv))))));
}
TRY((((*this).typecheck_enum_constructor(record,(enum_id.value()),scope_id))));
__jakt_var_493 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),(enum_id.value())); goto __jakt_label_440;

}
__jakt_label_440:; __jakt_var_493.release_value(); }));
};/*case end*/
default: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord nested_record = (_magic_value.value());
{
TRY((((*this).warn_about_unimplemented_nested_record(nested_record))));
((records_to_process).enqueue((Tuple{nested_record, TRY((((id).scope_id(((((*this).program)))))))})));
}

}
}

}
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_block_statement(parser::ParsedBlock const parsed_block,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("A block used as a statement cannot yield values, as the value cannot be observed in any way"sv)),(((parsed_block).find_yield_span()).value())))));
}
return TRY((types::CheckedStatement::Block(checked_block,span)));
}
}

ErrorOr<ids::FunctionId> typechecker::Typechecker::typecheck_function_predecl(parser::ParsedFunction const parsed_function,ids::ScopeId const parent_scope_id,JaktInternal::Optional<ids::TypeId> const this_arg_type_id,JaktInternal::Optional<NonnullRefPtr<types::FunctionGenerics>> generics,JaktInternal::Optional<ids::ScopeId> scope_mixin) {
{
ids::ScopeId const function_scope_id = TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),TRY((__jakt_format((StringView::from_string_literal("fn({})"sv)),((parsed_function).name)))),true))));
if (((scope_mixin).has_value())){
NonnullRefPtr<types::Scope> function_scope = TRY((((*this).get_scope(function_scope_id))));
TRY((((((function_scope)->resolution_mixins)).push((scope_mixin.value())))));
}
ByteString const scope_debug_name = TRY((__jakt_format((StringView::from_string_literal("function-block({})"sv)),((parsed_function).name))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(function_scope_id,((parsed_function).can_throw),scope_debug_name,true))));
size_t const module_id = ((((*this).current_module_id)).id);
bool base_definition = false;
if ((!(((generics).has_value())))){
(generics = TRY((types::FunctionGenerics::__jakt_create(function_scope_id,(TRY((DynamicArray<types::CheckedParameter>::create_with({})))),(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))));
(base_definition = true);
}
bool const is_generic_function = (!(((((parsed_function).generic_parameters)).is_empty())));
bool const is_generic = (is_generic_function || (((this_arg_type_id).has_value()) && ((((*this).get_type((this_arg_type_id.value()))))->__jakt_init_index() == 20 /* GenericInstance */)));
bool has_varargs = ((parsed_function).has_varargs);
if ((has_varargs && ((((parsed_function).linkage)).__jakt_init_index() == 0 /* Internal */))){
TRY((((*this).error((ByteString::must_from_utf8("Only external functions are allowed to be declared using varargs"sv)),((parsed_function).name_span)))));
(has_varargs = false);
}
NonnullRefPtr<types::CheckedFunction> checked_function = TRY((types::CheckedFunction::__jakt_create(((parsed_function).name),((parsed_function).name_span),TRY((((*this).typecheck_visibility(((parsed_function).visibility),parent_scope_id)))),types::unknown_type_id(),((parsed_function).return_type_span),(TRY((DynamicArray<types::CheckedParameter>::create_with({})))),(generics.value()),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::MayReturn(),ids::TypeId::none(),false),((parsed_function).can_throw),((parsed_function).type),((parsed_function).linkage),function_scope_id,JaktInternal::OptionalNone(),((!(is_generic)) || (!(base_definition))),parsed_function,((parsed_function).is_comptime),false,false,((parsed_function).is_unsafe),has_varargs,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,((parsed_function).external_name),((parsed_function).deprecated_message),JaktInternal::OptionalNone(),((parsed_function).force_inline))));
NonnullRefPtr<types::Module> current_module = ((*this).current_module());
ids::FunctionId const function_id = TRY((((current_module)->add_function(checked_function))));
ids::ScopeId const checked_function_scope_id = ((checked_function)->function_scope_id);
bool const external_linkage = ((((parsed_function).linkage)).__jakt_init_index() == 1 /* External */);
JaktInternal::Optional<ids::ScopeId> const check_scope = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::ScopeId>,ErrorOr<ids::FunctionId>>{
auto __jakt_enum_value = ((is_generic || ((((parsed_function).return_type))->__jakt_init_index() == 15 /* Empty */)));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<ids::ScopeId>>(TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),scope_debug_name,true))))));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
i64 i = static_cast<i64>(0LL);
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_function).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
ids::TypeId type_var_type_id = ids::TypeId(((current_module)->id),((((current_module)->types)).size()));
if (base_definition){
types::FunctionGenericParameter parameter = TRY((types::FunctionGenericParameter::parameter(type_var_type_id,((generic_parameter).span))));
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
TRY((((((current_module)->types)).push(TRY((types::Type::TypeVariable(parser::CheckedQualifiers(false),((generic_parameter).name),trait_implementations,((generic_parameter).is_value))))))));
if (((((generic_parameter).requires_list)).has_value())){
TRY((((*this).fill_trait_requirements((((generic_parameter).requires_list).value()),((((((parameter).checked_parameter)).constraints))),((trait_implementations)),parent_scope_id))));
}
TRY((((((((checked_function)->generics))->params)).push(parameter))));
}
else if (((((((((((checked_function)->generics))->params))[i])).kind)).__jakt_init_index() == 1 /* Parameter */)){
(type_var_type_id = ((((((((checked_function)->generics))->params))[i])).type_id()));
}
if (((!(((parsed_function).must_instantiate))) || external_linkage)){
TRY((((*this).add_type_to_scope(checked_function_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
if (((check_scope).has_value())){
TRY((((*this).add_type_to_scope((check_scope.value()),((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
((i++));
}

}
}

bool first = true;
NonnullRefPtr<types::Module> module = ((*this).current_module());
{
JaktInternal::ArrayIterator<parser::ParsedParameter> _magic = ((((parsed_function).params)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter parameter = (_magic_value.value());
{
types::CheckedParameter const checked_param = TRY((((*this).typecheck_parameter(parameter,checked_function_scope_id,first,this_arg_type_id,check_scope))));
TRY((((((checked_function)->params)).push(checked_param))));
if (base_definition){
TRY((((((((checked_function)->generics))->base_params)).push(checked_param))));
}
(first = false);
}

}
}

if (((((parsed_function).stores_arguments)).has_value())){
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel>> _magic = (((((parsed_function).stores_arguments).value())).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel> index_____ = (_magic_value.value());
{
JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel> const jakt__index_____ = index_____;
size_t const index = ((jakt__index_____).template get<0>());
parser::ArgumentStoreLevel const _ = ((jakt__index_____).template get<1>());

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(index,((((checked_function)->params)).size()))){
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("stores_argument() index out of bounds"sv))))));
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<ids::FunctionId>>{
auto&& __jakt_match_variant = *((*this).get_type(((((((((checked_function)->params))[index])).variable))->type_id)));
switch(__jakt_match_variant.__jakt_init_index()) {
case 28 /* Reference */: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29 /* MutableReference */: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error_with_hint((ByteString::must_from_utf8("This parameter is not a reference"sv)),((((((((checked_function)->params))[index])).variable))->definition_span),(ByteString::must_from_utf8("stores_argument() may only be used to declare reference lifetime requirements"sv)),((((((((checked_function)->params))[index])).variable))->definition_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}
(((checked_function)->stores_arguments) = ((parsed_function).stores_arguments));
ids::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),checked_function_scope_id,JaktInternal::OptionalNone()))));
if (((((parsed_function).return_type))->__jakt_init_index() == 15 /* Empty */)){
if (((parsed_function).is_fat_arrow)){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
(((*this).had_an_error) = false);
types::CheckedBlock const block = TRY((((*this).typecheck_block(((parsed_function).block),(check_scope.value()),types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
if (((*this).had_an_error)){
(function_return_type_id = types::void_type_id());
(((*this).ignore_errors) = false);
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Can't infer the return type of this function"sv)),((parsed_function).return_type_span),(ByteString::must_from_utf8("Try adding an explicit return type to the function here"sv)),((parsed_function).return_type_span)))));
}
else {
(function_return_type_id = ((*this).infer_function_return_type(block)));
}

(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
}
else {
(function_return_type_id = types::void_type_id());
}

}
(((checked_function)->return_type_id) = function_return_type_id);
if ((!(((TRY((((*this).get_scope(parent_scope_id)))))->is_from_generated_code)))){
TRY((((*this).check_that_type_doesnt_contain_reference(function_return_type_id,((parsed_function).return_type_span)))));
}
if (((!(((((parsed_function).generic_parameters)).is_empty()))) && ((function_return_type_id).equals(types::unknown_type_id())))){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
types::CheckedBlock const block = TRY((((*this).typecheck_block(((parsed_function).block),(check_scope.value()),types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
ids::TypeId const return_type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId,ErrorOr<ids::FunctionId>>{
auto __jakt_enum_value = (((function_return_type_id).equals(types::unknown_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).infer_function_return_type(block)));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(TRY((((*this).resolve_type_var(function_return_type_id,parent_scope_id)))));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
TRY((((*this).add_function_to_scope(parent_scope_id,((parsed_function).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((parsed_function).name_span)))));
return function_id;
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::find_or_add_type_id(NonnullRefPtr<typename types::Type> const type) {
{
return TRY((((((*this).program))->find_or_add_type_id(type,((*this).current_module_id),false))));
}
}

ErrorOr<typechecker::Typechecker> typechecker::Typechecker::typecheck(NonnullRefPtr<compiler::Compiler> compiler,parser::ParsedNamespace const parsed_namespace) {
{
JaktInternal::Optional<utility::FileId> const input_file = ((compiler)->current_file);
if ((!(((input_file).has_value())))){
TRY((((compiler)->panic((ByteString::must_from_utf8("trying to typecheck a non-existent file"sv))))));
}
ByteString const true_module_name = TRY((((((((compiler)->files))[(((input_file.value())).id)])).basename(true))));
ids::ModuleId const placeholder_module_id = ids::ModuleId(static_cast<size_t>(0ULL));
ByteString const root_module_name = TRY(((((((compiler)->current_file_path()).value())).basename(true))));
typechecker::Typechecker typechecker = typechecker::Typechecker(compiler,TRY((types::CheckedProgram::__jakt_create(compiler,(TRY((DynamicArray<NonnullRefPtr<types::Module>>::create_with({})))),(TRY((Dictionary<ByteString, types::LoadedModule>::create_with_entries({}))))))),placeholder_module_id,ids::TypeId::none(),JaktInternal::OptionalNone(),false,static_cast<size_t>(0ULL),false,((compiler)->dump_type_hints),((compiler)->dump_try_hints),static_cast<u64>(0ULL),types::GenericInferences((TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({}))))),JaktInternal::OptionalNone(),root_module_name,false,false,(TRY((Dictionary<ByteString, ids::ScopeId>::create_with_entries({})))),JaktInternal::OptionalNone());
TRY((((typechecker).include_prelude())));
ids::ModuleId const root_module_id = TRY((((typechecker).create_module(root_module_name,true,JaktInternal::OptionalNone()))));
(((typechecker).current_module_id) = root_module_id);
TRY((((compiler)->set_current_file((input_file.value())))));
types::LoadedModule const loaded_module = types::LoadedModule(root_module_id,(input_file.value()));
TRY((((((typechecker).program))->set_loaded_module(true_module_name,loaded_module))));
ids::ScopeId const PRELUDE_SCOPE_ID = ((typechecker).prelude_scope_id());
ids::ScopeId const root_scope_id = TRY((((typechecker).create_scope(PRELUDE_SCOPE_ID,false,(ByteString::must_from_utf8("root"sv)),false))));
TRY((((typechecker).typecheck_module_import(parser::ParsedModuleImport(parser::ImportName::Literal((ByteString::must_from_utf8("jakt::prelude::prelude"sv)),utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))),JaktInternal::OptionalNone(),parser::ImportList::All(),false,static_cast<size_t>(0ULL)),root_scope_id))));
{
JaktInternal::DictionaryIterator<size_t,ids::StructId> _magic = ((((((((((typechecker).program))->modules))[static_cast<i64>(0LL)]))->builtin_implementation_structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<size_t,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<size_t,ids::StructId> ___struct_id__ = (_magic_value.value());
{
JaktInternal::Tuple<size_t,ids::StructId> const jakt_____struct_id__ = ___struct_id__;
size_t const _ = ((jakt_____struct_id__).template get<0>());
ids::StructId const struct_id = ((jakt_____struct_id__).template get<1>());

types::CheckedStruct const struct_ = ((typechecker).get_struct(struct_id));
TRY((((typechecker).typecheck_entity_trait_implementations_predecl(((struct_).scope_id),((struct_).type_id),((struct_).trait_implementations),((struct_).name),((struct_).name_span)))));
}

}
}

{
JaktInternal::DictionaryIterator<size_t,ids::StructId> _magic = ((((((((((typechecker).program))->modules))[static_cast<i64>(0LL)]))->builtin_implementation_structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<size_t,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<size_t,ids::StructId> ___struct_id__ = (_magic_value.value());
{
JaktInternal::Tuple<size_t,ids::StructId> const jakt_____struct_id__ = ___struct_id__;
size_t const _ = ((jakt_____struct_id__).template get<0>());
ids::StructId const struct_id = ((jakt_____struct_id__).template get<1>());

types::CheckedStruct const struct_ = ((typechecker).get_struct(struct_id));
TRY((((typechecker).typecheck_entity_trait_implementations(((struct_).scope_id),((struct_).type_id),((struct_).trait_implementations),((struct_).name),((struct_).name_span)))));
}

}
}

TRY((((typechecker).typecheck_module(parsed_namespace,root_scope_id))));
return typechecker;
}
}

ErrorOr<JaktInternal::Optional<JaktInternal::DynamicArray<types::CheckedEnumVariantBinding>>> typechecker::Typechecker::typecheck_enum_variant_bindings(types::CheckedEnumVariant const variant,JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const bindings,utility::Span const span) {
{
if (((variant).__jakt_init_index() == 1 /* Typed */)){
ids::TypeId const type_id = (variant).as.Typed.type_id;
if (((((bindings).size())) != (static_cast<size_t>(1ULL)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant ‘{}’ must have exactly one argument"sv)),((variant).name())))),span))));
return JaktInternal::OptionalNone();
}
return (TRY((DynamicArray<types::CheckedEnumVariantBinding>::create_with({types::CheckedEnumVariantBinding(JaktInternal::OptionalNone(),((((bindings)[static_cast<i64>(0LL)])).binding),type_id,span)}))));
}
if (((variant).__jakt_init_index() == 3 /* StructLike */)){
JaktInternal::DynamicArray<ids::VarId> const fields = (variant).as.StructLike.fields;
JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedVariable>> checked_vars = (TRY((DynamicArray<NonnullRefPtr<types::CheckedVariable>>::create_with({}))));
JaktInternal::DynamicArray<types::CheckedEnumVariantBinding> checked_enum_variant_bindings = (TRY((DynamicArray<types::CheckedEnumVariantBinding>::create_with({}))));
{
JaktInternal::ArrayIterator<ids::VarId> _magic = ((fields).iterator());
for (;;){
JaktInternal::Optional<ids::VarId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::VarId field = (_magic_value.value());
{
TRY((((checked_vars).push(((*this).get_variable(field))))));
}

}
}

{
JaktInternal::ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
JaktInternal::Optional<parser::EnumVariantPatternArgument> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
bool found = false;
{
JaktInternal::ArrayIterator<NonnullRefPtr<types::CheckedVariable>> _magic = ((checked_vars).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<types::CheckedVariable> var = (_magic_value.value());
{
ByteString const binding_name = ((binding).name).value_or_lazy_evaluated([&] { return ((binding).binding); });
ids::TypeId const type_id = ((var)->type_id);
if (((binding_name) == (((var)->name)))){
TRY((((checked_enum_variant_bindings).push(types::CheckedEnumVariantBinding(((binding).name),((binding).binding),type_id,span)))));
(found = true);
break;
}
}

}
}

if ((!(found))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant ‘{}’ doesn't have field with name ‘{}’"sv)),((variant).name()),((binding).name_in_enum())))),((binding).name_in_enum_span())))));
}
}

}
}

if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((checked_enum_variant_bindings).size()),static_cast<size_t>(0ULL))){
return checked_enum_variant_bindings;
}
return JaktInternal::OptionalNone();
}
else {
return JaktInternal::OptionalNone();
}

}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct(parser::ParsedRecord const record,ids::StructId const struct_id,ids::ScopeId const parent_scope_id) {
{
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(struct_type_id))));
ScopeGuard __jakt_var_494([&] {
(((*this).self_type_id) = old_self_type_id);
});
JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedFunction>>> all_virtuals = (TRY((Dictionary<ByteString, JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedFunction>>>::create_with_entries({}))));
JaktInternal::Optional<ids::StructId> super_struct_id = ((((*this).get_struct(struct_id))).super_struct_id);
while (((super_struct_id).has_value())){
types::CheckedStruct const super_struct = ((*this).get_struct((super_struct_id.value())));
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(((super_struct).scope_id)))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> _magic = ((((scope)->functions)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> ___overload_set__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> const jakt_____overload_set__ = ___overload_set__;
ByteString const _ = ((jakt_____overload_set__).template get<0>());
JaktInternal::DynamicArray<ids::FunctionId> const overload_set = ((jakt_____overload_set__).template get<1>());

{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((overload_set).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId function_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const function = ((*this).get_function(function_id));
if (((function)->is_virtual)){
if ((!(((all_virtuals).contains(((function)->name)))))){
TRY(all_virtuals.set(((function)->name), (TRY((DynamicArray<NonnullRefPtr<types::CheckedFunction>>::create_with({function}))))));
}
else {
TRY((((((all_virtuals)[((function)->name)])).push(function))));
}

}
}

}
}

}

}
}

(super_struct_id = ((super_struct).super_struct_id));
}
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_override(method,((((*this).get_struct(struct_id))).scope_id),all_virtuals))));
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Struct(JaktInternal::OptionalNone(),struct_id)))));
}

}
}

(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_lambda(JaktInternal::DynamicArray<parser::ParsedCapture> const captures,JaktInternal::DynamicArray<parser::ParsedParameter> const params,bool const can_throw,bool const is_fat_arrow,NonnullRefPtr<typename parser::ParsedType> const return_type,parser::ParsedBlock const block,utility::Span const span,ids::ScopeId const scope_id,types::SafetyMode const safety_mode) {
{
NonnullRefPtr<typename parser::ParsedType> const synthetic_type = TRY((parser::ParsedType::Function(JaktInternal::OptionalNone(),params,can_throw,return_type,span)));
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_495([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
ids::TypeId type_id = TRY((((*this).typecheck_typename(synthetic_type,scope_id,JaktInternal::OptionalNone()))));
JaktInternal::Tuple<ids::TypeId,ids::FunctionId> return_type_id_pseudo_function_id_ = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Tuple<ids::TypeId,ids::FunctionId>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 30 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;ids::TypeId const& return_type_id = __jakt_match_value.return_type_id;
ids::FunctionId const& pseudo_function_id = __jakt_match_value.pseudo_function_id;
return JaktInternal::ExplicitValue((Tuple{return_type_id, pseudo_function_id}));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("Expected the just-checked function to be of a function type"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
ids::TypeId return_type_id = ((return_type_id_pseudo_function_id_).template get<0>());
ids::FunctionId pseudo_function_id = ((return_type_id_pseudo_function_id_).template get<1>());

NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::ScopeId effective_namespace_parent_scope_id = scope_id;
NonnullRefPtr<types::Scope> effective_namespace_parent_scope = TRY((((*this).get_scope(scope_id))));
while (((effective_namespace_parent_scope)->is_block_scope)){
(effective_namespace_parent_scope_id = (((effective_namespace_parent_scope)->parent).value()));
(effective_namespace_parent_scope = TRY((((*this).get_scope(effective_namespace_parent_scope_id)))));
}
ids::ScopeId lambda_scope_id = TRY((((*this).create_scope(effective_namespace_parent_scope_id,can_throw,(ByteString::must_from_utf8("lambda"sv)),true))));
bool is_capturing_everything = false;
JaktInternal::DynamicArray<types::CheckedCapture> checked_captures = (TRY((DynamicArray<types::CheckedCapture>::create_with({}))));
bool has_dependent_capture = false;
{
JaktInternal::ArrayIterator<parser::ParsedCapture> _magic = ((captures).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedCapture> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedCapture capture = (_magic_value.value());
{
if (((capture).__jakt_init_index() == 4 /* AllByReference */)){
TRY((((checked_captures).push(types::CheckedCapture::AllByReference((ByteString::must_from_utf8(""sv)),((capture).common.init_common.span))))));
if ((!(is_capturing_everything))){
(is_capturing_everything = true);
(lambda_scope_id = TRY((((*this).create_scope(scope_id,can_throw,(ByteString::must_from_utf8("lambda"sv)),true)))));
}
}
else if (((TRY((((*this).find_var_in_scope(scope_id,((capture).common.init_common.name),JaktInternal::OptionalNone()))))).has_value())){
ByteString const name = ((capture).common.init_common.name);
utility::Span const span = ((capture).common.init_common.span);
TRY((((checked_captures).push(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedCapture, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = capture;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* ByValue */: {
return JaktInternal::ExplicitValue(types::CheckedCapture::ByValue(name,span));
};/*case end*/
case 1 /* ByReference */: {
return JaktInternal::ExplicitValue(types::CheckedCapture::ByReference(name,span));
};/*case end*/
case 2 /* ByMutableReference */: {
return JaktInternal::ExplicitValue(types::CheckedCapture::ByMutableReference(name,span));
};/*case end*/
case 3 /* ByComptimeDependency */: {
return JaktInternal::ExplicitValue(({ Optional<types::CheckedCapture> __jakt_var_496; {
(has_dependent_capture = true);
if ((!(((*this).in_comptime_function_call)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Comptime dependency capture ‘{}’ is only allowed in comptime function calls"sv)),name))),span))));
}
__jakt_var_496 = types::CheckedCapture::ByComptimeDependency(name,span); goto __jakt_label_441;

}
__jakt_label_441:; __jakt_var_496.release_value(); }));
};/*case end*/
case 4 /* AllByReference */: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("AllByReference capture should not be looked up by name"sv))))));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
})))));
if ((!(is_capturing_everything))){
NonnullRefPtr<types::CheckedVariable> const var = (TRY((((*this).find_var_in_scope(scope_id,((capture).common.init_common.name),JaktInternal::OptionalNone())))).value());
bool const is_this = ((((var)->name)) == ((ByteString::must_from_utf8("this"sv))));
ids::VarId const var_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create(name,((var)->type_id),(((var)->is_mutable) && ((is_this || ((capture).__jakt_init_index() == 1 /* ByReference */)) || ((capture).__jakt_init_index() == 2 /* ByMutableReference */))),((var)->definition_span),((var)->type_span),((var)->visibility),((var)->owner_scope),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))))));
TRY((((*this).add_var_to_scope(lambda_scope_id,name,var_id,span))));
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Variable '{}' not found"sv)),((capture).common.init_common.name)))),span))));
}

}

}
}

if ((!(is_capturing_everything))){
ids::ScopeId current_scope_id = scope_id;
NonnullRefPtr<types::Scope> lambda_scope = TRY((((*this).get_scope(lambda_scope_id))));
while ((!(((current_scope_id).equals(effective_namespace_parent_scope_id))))){
NonnullRefPtr<types::Scope> const current_scope = TRY((((*this).get_scope(current_scope_id))));
TRY((((((lambda_scope)->resolution_mixins)).push(current_scope_id))));
(current_scope_id = (((current_scope)->parent).value()));
}
}
JaktInternal::DynamicArray<types::CheckedParameter> checked_params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
bool first = true;
{
JaktInternal::ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
types::CheckedParameter const checked_param = TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
TRY((((checked_params).push(checked_param))));
ids::VarId const var_id = TRY((((module)->add_variable(((checked_param).variable)))));
TRY((((*this).add_var_to_scope(lambda_scope_id,((((checked_param).variable))->name),var_id,((((checked_param).variable))->definition_span)))));
(first = false);
}

}
}

JaktInternal::Optional<ids::FunctionId> const previous_function_id = ((*this).current_function_id);
(((*this).current_function_id) = pseudo_function_id);
ScopeGuard __jakt_var_497([&] {
{
(((*this).current_function_id) = previous_function_id);
}

});
if (has_dependent_capture){
return TRY((types::CheckedExpression::DependentFunction(JaktInternal::OptionalNone(),checked_captures,checked_params,can_throw,return_type_id,block,span,type_id,pseudo_function_id,lambda_scope_id)));
}
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block(block,lambda_scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((return_type_id).equals(types::unknown_type_id()))){
bool return_type_updated = false;
if (((!(is_fat_arrow)) && ((return_type)->__jakt_init_index() == 15 /* Empty */))){
(return_type_id = types::void_type_id());
(return_type_updated = true);
}
else if ((is_fat_arrow && ((!(((((checked_block).statements)).is_empty()))) && (((((((checked_block).statements)).last()).value()))->__jakt_init_index() == 8 /* Return */)))){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const val = ((((((checked_block).statements)).last()).value()))->as.Return.val;
if (((val).has_value())){
(return_type_id = TRY((((*this).resolve_type_var((((val.value()))->type()),lambda_scope_id)))));
(return_type_updated = true);
}
}
if (return_type_updated){
(type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 30 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;JaktInternal::DynamicArray<ids::TypeId> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
ids::FunctionId const& pseudo_function_id = __jakt_match_value.pseudo_function_id;
return JaktInternal::ExplicitValue(TRY((((*this).find_or_add_type_id(TRY((types::Type::Function(parser::CheckedQualifiers(false),params,can_throw,return_type_id,pseudo_function_id))))))));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("Expected the just-checked function to be of a function type"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
}
return TRY((types::CheckedExpression::Function(JaktInternal::OptionalNone(),checked_captures,checked_params,can_throw,return_type_id,checked_block,span,type_id,pseudo_function_id,lambda_scope_id)));
}
}

NonnullRefPtr<types::CheckedVariable> typechecker::Typechecker::get_variable(ids::VarId const id) const {
{
return ((((*this).program))->get_variable(id));
}
}

ErrorOr<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>>> typechecker::Typechecker::resolve_default_params(JaktInternal::DynamicArray<types::CheckedParameter> const params,bool const has_varargs,JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const args,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,size_t const arg_offset,utility::Span const span) {
{
size_t params_with_default_value = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((params).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
if (((((param).default_value_expression)).has_value())){
((params_with_default_value++));
}
}

}
}

size_t const max_number_of_valid_arguments = JaktInternal::checked_sub(((params).size()),arg_offset);
size_t const min_number_of_valid_arguments = JaktInternal::checked_sub(max_number_of_valid_arguments,params_with_default_value);
if (([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(((args).size()),min_number_of_valid_arguments) && ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((args).size()),max_number_of_valid_arguments) || has_varargs))){
size_t consumed_arg = static_cast<size_t>(0ULL);
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>> resolved_args = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({}))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(arg_offset),static_cast<size_t>(((params).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
types::CheckedParameter const param = ((params)[i]);
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> maybe_checked_expr = JaktInternal::OptionalNone();
if ((!(((param).requires_label)))){
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((args).size()),consumed_arg)){
if ((!(((((param).default_value_expression)).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Missing argument for function parameter {}"sv)),((((param).variable))->name)))),span))));
continue;
}
if (((((param).default_value_expression)).has_value())){
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId> const default_value = (((param).default_value_expression).value());
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId> const expression_default_scope_id_ = default_value;
NonnullRefPtr<typename parser::ParsedExpression> const expression = ((expression_default_scope_id_).template get<0>());
ids::ScopeId const default_scope_id = ((expression_default_scope_id_).template get<1>());

TRY((((((scope)->resolution_mixins)).push(default_scope_id))));
ScopeGuard __jakt_var_498([&] {
((((scope)->resolution_mixins)).pop());
});
(maybe_checked_expr = TRY((((*this).typecheck_expression(expression,scope_id,safety_mode,((((param).variable))->type_id))))));
}
}
else {
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> const name_span_expr_ = ((args)[consumed_arg]);
ByteString const name = ((name_span_expr_).template get<0>());
utility::Span const span = ((name_span_expr_).template get<1>());
NonnullRefPtr<typename parser::ParsedExpression> const expr = ((name_span_expr_).template get<2>());

if (((!(((name).is_empty()))) && [](ByteString const& self, ByteString rhs) -> bool {
{
return (!(((self) == (rhs))));
}
}
(name,((((param).variable))->name)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Wrong parameter name in argument label (got '{}', expected '{}')"sv)),name,((((param).variable))->name)))),span))));
}
(maybe_checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,((((param).variable))->type_id))))));
((consumed_arg++));
}

}
else {
if (((((param).default_value_expression)).has_value())){
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId> const default_value = (((param).default_value_expression).value());
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId> const expression_default_scope_id_ = default_value;
NonnullRefPtr<typename parser::ParsedExpression> const expression = ((expression_default_scope_id_).template get<0>());
ids::ScopeId const default_scope_id = ((expression_default_scope_id_).template get<1>());

TRY((((((scope)->resolution_mixins)).push(default_scope_id))));
ScopeGuard __jakt_var_499([&] {
((((scope)->resolution_mixins)).pop());
});
(maybe_checked_expr = TRY((((*this).typecheck_expression(expression,scope_id,safety_mode,((((param).variable))->type_id))))));
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((args).size()),consumed_arg)){
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> const name_span_expr_ = ((args)[consumed_arg]);
ByteString const name = ((name_span_expr_).template get<0>());
utility::Span const span = ((name_span_expr_).template get<1>());
NonnullRefPtr<typename parser::ParsedExpression> const expr = ((name_span_expr_).template get<2>());

if (TRY((((*this).validate_argument_label(param,name,span,expr,maybe_checked_expr))))){
(maybe_checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,((((param).variable))->type_id))))));
((consumed_arg++));
}
}
}

if (((maybe_checked_expr).has_value())){
NonnullRefPtr<typename types::CheckedExpression> checked_arg = (maybe_checked_expr.value());
TRY((((resolved_args).push((Tuple{((((param).variable))->name), span, checked_arg})))));
}
}

}
}

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((((args)[(JaktInternal::Range<size_t>{static_cast<size_t>(consumed_arg),static_cast<size_t>(9223372036854775807LL)})])).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> name__span__expr__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> const jakt__name__span__expr__ = name__span__expr__;
ByteString const name = ((jakt__name__span__expr__).template get<0>());
utility::Span const span = ((jakt__name__span__expr__).template get<1>());
NonnullRefPtr<typename parser::ParsedExpression> const expr = ((jakt__name__span__expr__).template get<2>());

TRY((((resolved_args).push((Tuple{name, span, TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))))})))));
}

}
}

return resolved_args;
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Wrong number of arguments"sv)),span))));
return (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({}))));
}

}
}

ErrorOr<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> typechecker::Typechecker::find_all_implementations_of_trait(ids::TypeId const type_id,ids::TraitId const trait_id,JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const filter_for_generics) {
{
Function<ErrorOr<bool>(JaktInternal::DynamicArray<ids::TypeId>)> const generics_match = [this, &filter_for_generics, &trait_id](JaktInternal::DynamicArray<ids::TypeId> generics) -> ErrorOr<bool> {
{
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_500([&] {
((((*this).generic_inferences)).restore(old_generic_inferences));
});
if (((filter_for_generics).has_value())){
JaktInternal::DynamicArray<ids::TypeId> const generics_to_match = (filter_for_generics.value());
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(0)));
}
}
(((generics).size()),((generics_to_match).size()))){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
ScopeGuard __jakt_var_501([&] {
{
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
}

});
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((generics_to_match).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
ids::TypeId const generic = ((generics)[i]);
ids::TypeId const generic_to_match = ((generics_to_match)[i]);
if ((!(TRY((((*this).check_types_for_compat(generic,generic_to_match,((((*this).generic_inferences))),utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))))))))){
return false;
}
}

}
}

return true;
}
else {
return false;
}

}
else {
return true;
}

}
}
;
NonnullRefPtr<typename types::Type> type = ((*this).get_type(type_id));
if (((type)->is_builtin())){
(type = ((*this).get_type(((((*this).get_struct(TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))))))).type_id))));
}
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>, ErrorOr<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
JaktInternal::DynamicArray<ids::TypeId> const args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_502; {
types::CheckedStruct const struct_ = ((*this).get_struct(struct_id));
TRY((((((*this).generic_inferences)).set_all(((struct_).generic_parameters),args))));
JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> implementations = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((((struct_).trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> ___trait_descriptors__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt_____trait_descriptors__ = ___trait_descriptors__;
ByteString const _ = ((jakt_____trait_descriptors__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_descriptors = ((jakt_____trait_descriptors__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_descriptors).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_descriptor = (_magic_value.value());
{
if ((((((trait_descriptor).template get<0>())).equals(trait_id)) && TRY((generics_match(((trait_descriptor).template get<1>())))))){
TRY((((implementations).push(((trait_descriptor).template get<1>())))));
}
}

}
}

}

}
}

__jakt_var_502 = implementations; goto __jakt_label_442;

}
__jakt_label_442:; __jakt_var_502.release_value(); }));
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_503; {
types::CheckedStruct const struct_ = ((*this).get_struct(struct_id));
TRY((((((*this).generic_inferences)).set_all(((struct_).generic_parameters),args))));
JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> implementations = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((((struct_).trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> ___trait_descriptors__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt_____trait_descriptors__ = ___trait_descriptors__;
ByteString const _ = ((jakt_____trait_descriptors__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_descriptors = ((jakt_____trait_descriptors__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_descriptors).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_descriptor = (_magic_value.value());
{
if ((((((trait_descriptor).template get<0>())).equals(trait_id)) && TRY((generics_match(((trait_descriptor).template get<1>())))))){
TRY((((implementations).push(((trait_descriptor).template get<1>())))));
}
}

}
}

}

}
}

__jakt_var_503 = implementations; goto __jakt_label_443;

}
__jakt_label_443:; __jakt_var_503.release_value(); }));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_504; {
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> implementations = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((((enum_).trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> ___trait_descriptors__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt_____trait_descriptors__ = ___trait_descriptors__;
ByteString const _ = ((jakt_____trait_descriptors__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_descriptors = ((jakt_____trait_descriptors__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_descriptors).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_descriptor = (_magic_value.value());
{
if ((((((trait_descriptor).template get<0>())).equals(trait_id)) && TRY((generics_match(((trait_descriptor).template get<1>())))))){
TRY((((implementations).push(((trait_descriptor).template get<1>())))));
}
}

}
}

}

}
}

__jakt_var_504 = implementations; goto __jakt_label_444;

}
__jakt_label_444:; __jakt_var_504.release_value(); }));
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_505; {
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> implementations = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((((enum_).trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> ___trait_descriptors__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt_____trait_descriptors__ = ___trait_descriptors__;
ByteString const _ = ((jakt_____trait_descriptors__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_descriptors = ((jakt_____trait_descriptors__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_descriptors).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_descriptor = (_magic_value.value());
{
if ((((((trait_descriptor).template get<0>())).equals(trait_id)) && TRY((generics_match(((trait_descriptor).template get<1>())))))){
TRY((((implementations).push(((trait_descriptor).template get<1>())))));
}
}

}
}

}

}
}

__jakt_var_505 = implementations; goto __jakt_label_445;

}
__jakt_label_445:; __jakt_var_505.release_value(); }));
};/*case end*/
case 27 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_506; {
if ((((id).equals(trait_id)) && TRY((generics_match((TRY((DynamicArray<ids::TypeId>::create_with({}))))))))){
return (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({(TRY((DynamicArray<ids::TypeId>::create_with({}))))}))));
}
__jakt_var_506 = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({})))); goto __jakt_label_446;

}
__jakt_label_446:; __jakt_var_506.release_value(); }));
};/*case end*/
case 22 /* GenericTraitInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericTraitInstance;ids::TraitId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>> __jakt_var_507; {
if (((!(((id).equals(trait_id)))) || (!(TRY((generics_match(args))))))){
return (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))));
}
__jakt_var_507 = (TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({args})))); goto __jakt_label_447;

}
__jakt_label_447:; __jakt_var_507.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>>> typechecker::Typechecker::find_namespace_in_scope(ids::ScopeId const scope_id,ByteString const name,bool const treat_aliases_as_imports,JaktInternal::Optional<ids::ScopeId> const root_scope) const {
{
return TRY((((((*this).program))->find_namespace_in_scope(scope_id,name,treat_aliases_as_imports,false,root_scope))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_fields(parser::ParsedRecord const record,ids::StructId const struct_id) {
{
types::CheckedStruct structure = ((*this).get_struct(struct_id));
ids::ScopeId const checked_struct_scope_id = ((((*this).get_struct(struct_id))).scope_id);
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(struct_type_id))));
ScopeGuard __jakt_var_508([&] {
(((*this).self_type_id) = old_self_type_id);
});
JaktInternal::DynamicArray<parser::ParsedField> const parsed_fields = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::DynamicArray<parser::ParsedField>, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;JaktInternal::DynamicArray<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
case 1 /* Class */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Class;JaktInternal::DynamicArray<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("typecheck_struct_fields cannot handle non-structs"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
bool const in_generated_code = ((TRY((((*this).get_scope(((structure).scope_id))))))->is_from_generated_code);
{
JaktInternal::ArrayIterator<parser::ParsedField> _magic = ((parsed_fields).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedField unchecked_member = (_magic_value.value());
{
parser::ParsedVarDecl const parsed_var_decl = ((unchecked_member).var_decl);
ids::TypeId const checked_member_type = TRY((((*this).typecheck_typename(((parsed_var_decl).parsed_type),checked_struct_scope_id,((parsed_var_decl).name)))));
if ((!(in_generated_code))){
TRY((((*this).check_that_type_doesnt_contain_reference(checked_member_type,((((parsed_var_decl).parsed_type))->span())))));
}
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const variable_id = TRY((((module)->add_variable(TRY((types::CheckedVariable::__jakt_create(((parsed_var_decl).name),checked_member_type,((parsed_var_decl).is_mutable),((parsed_var_decl).span),JaktInternal::OptionalNone(),TRY((((*this).typecheck_visibility(((unchecked_member).visibility),checked_struct_scope_id)))),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),((parsed_var_decl).external_name))))))));
JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>> const default_value_expression = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>,ErrorOr<void>>{
auto __jakt_enum_value = (((((unchecked_member).default_value)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>>((Tuple{(((unchecked_member).default_value).value()), checked_struct_scope_id})));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((((structure).fields)).push(types::CheckedField(variable_id,default_value_expression)))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_call(parser::ParsedCall const call,ids::ScopeId const caller_scope_id,utility::Span const span,JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const this_expr,JaktInternal::Optional<types::StructLikeId> const parent_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> type_hint,bool const must_be_enum_constructor) {
{
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>> args = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({}))));
ids::TypeId return_type = types::builtin(types::BuiltinType::Void());
JaktInternal::DynamicArray<ids::TypeId> generic_arguments = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
bool callee_throws = false;
JaktInternal::DynamicArray<types::ResolvedNamespace> resolved_namespaces = (TRY((DynamicArray<types::ResolvedNamespace>::create_with({}))));
JaktInternal::DynamicArray<ids::FunctionId> resolved_function_id_candidates = (TRY((DynamicArray<ids::FunctionId>::create_with({}))));
JaktInternal::Optional<ids::FunctionId> resolved_function_id = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::TypeId> maybe_this_type_id = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::FunctionId> generic_checked_function_to_instantiate = JaktInternal::OptionalNone();
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_509([&] {
((((*this).generic_inferences)).restore(old_generic_inferences));
});
bool const is_print_like = (((((call).namespace_)).is_empty()) && ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == (ByteString::must_from_utf8("print"sv))) {
return JaktInternal::ExplicitValue(true);
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("println"sv))) {
return JaktInternal::ExplicitValue(true);
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("eprintln"sv))) {
return JaktInternal::ExplicitValue(true);
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("eprint"sv))) {
return JaktInternal::ExplicitValue(true);
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("format"sv))) {
return JaktInternal::ExplicitValue(true);
}
else {
return JaktInternal::ExplicitValue(false);
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
{
JaktInternal::ArrayIterator<ByteString> _magic = ((((call).namespace_)).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString name = (_magic_value.value());
{
TRY((((resolved_namespaces).push(types::ResolvedNamespace(name,JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))));
}

}
}

ids::ScopeId callee_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((parent_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = (parent_id.value());
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_510; {
types::CheckedStruct struct_ = ((*this).get_struct(id));
ids::ScopeId scope_id = ((struct_).scope_id);
while (((resolved_function_id_candidates).is_empty())){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
(resolved_function_id_candidates = TRY((((*this).resolve_call(call,resolved_namespaces,span,scope_id,must_be_enum_constructor)))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
if ((!(((resolved_function_id_candidates).is_empty())))){
break;
}
if (((((struct_).super_struct_id)).has_value())){
ids::StructId const parent_struct_id = (((struct_).super_struct_id).value());
(struct_ = ((*this).get_struct(parent_struct_id)));
(scope_id = ((struct_).scope_id));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Could not find ‘{}’"sv)),((call).name)))),span))));
break;
}

}
__jakt_var_510 = scope_id; goto __jakt_label_448;

}
__jakt_label_448:; __jakt_var_510.release_value(); }));
};/*case end*/
case 1 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_511; {
ids::ScopeId const scope_id = ((((*this).get_enum(id))).scope_id);
(resolved_function_id_candidates = TRY((((*this).resolve_call(call,resolved_namespaces,span,scope_id,must_be_enum_constructor)))));
__jakt_var_511 = scope_id; goto __jakt_label_449;

}
__jakt_label_449:; __jakt_var_511.release_value(); }));
};/*case end*/
case 2 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_512; {
ids::ScopeId const scope_id = ((((*this).get_trait(id)))->scope_id);
(resolved_function_id_candidates = TRY((((*this).resolve_call(call,resolved_namespaces,span,scope_id,must_be_enum_constructor)))));
__jakt_var_512 = scope_id; goto __jakt_label_450;

}
__jakt_label_450:; __jakt_var_512.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
else {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_513; {
if ((!(is_print_like))){
(resolved_function_id_candidates = TRY((((*this).resolve_call(call,resolved_namespaces,span,caller_scope_id,must_be_enum_constructor)))));
}
__jakt_var_513 = caller_scope_id; goto __jakt_label_451;

}
__jakt_label_451:; __jakt_var_513.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> generic_inferences_from_parent = (TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({}))));
if ((((parent_id).has_value()) && (((((parent_id.value())).common.init_common.generic_arguments)).has_value()))){
JaktInternal::DynamicArray<ids::TypeId> const arguments = ((((parent_id.value())).common.init_common.generic_arguments).value());
JaktInternal::DynamicArray<ids::TypeId> const parameters = TRY(((((parent_id.value())).generic_parameters(((((*this).program)))))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((arguments).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((generic_inferences_from_parent).set(((parameters)[i]),((arguments)[i])))));
TRY((((((*this).generic_inferences)).set(((parameters)[i]),((arguments)[i])))));
}

}
}

}
if (is_print_like){
bool first = true;
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> arg = (_magic_value.value());
{
JaktInternal::Optional<ids::TypeId> const type_hint = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::TypeId>,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (first);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<ids::TypeId>> __jakt_var_514; {
(first = false);
__jakt_var_514 = static_cast<JaktInternal::Optional<ids::TypeId>>(TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("StringView"sv))))))); goto __jakt_label_452;

}
__jakt_label_452:; __jakt_var_514.release_value(); }));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
NonnullRefPtr<typename types::CheckedExpression> const checked_arg = TRY((((*this).typecheck_expression(((arg).template get<2>()),caller_scope_id,safety_mode,type_hint))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if (((((call).name)) == ((ByteString::must_from_utf8("format"sv))))){
(return_type = TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("String"sv)))))));
(callee_throws = true);
}
}
else {
i64 max_found_specificity = (-(static_cast<i64>(1LL)));
JaktInternal::DynamicArray<error::JaktError> errors_while_trying_to_find_matching_function = (TRY((DynamicArray<error::JaktError>::create_with({}))));
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> generic_inferences_for_best_match = (TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({}))));
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((resolved_function_id_candidates).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId candidate = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = TRY((((*this).match_function_and_resolve_args(call,caller_scope_id,candidate,safety_mode,span,this_expr))));
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* MatchSuccess */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MatchSuccess;JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> const& resolved_args = __jakt_match_value.args;
JaktInternal::Optional<ids::TypeId> const& resolved_this_type_id = __jakt_match_value.maybe_this_type_id;
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const& used_generic_inferences = __jakt_match_value.used_generic_inferences;
i64 const& specificity = __jakt_match_value.specificity;
{
if ([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(specificity,max_found_specificity)){
(resolved_function_id = candidate);
(maybe_this_type_id = resolved_this_type_id);
(max_found_specificity = specificity);
(generic_inferences_for_best_match = used_generic_inferences);
(args = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>>::create_with({})))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename types::CheckedExpression>> _magic = ((resolved_args).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename types::CheckedExpression> resolved_arg = (_magic_value.value());
{
TRY((((args).push((Tuple{((call).name), resolved_arg})))));
}

}
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* MatchError */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MatchError;JaktInternal::DynamicArray<error::JaktError> const& errors = __jakt_match_value.errors;
{
{
JaktInternal::ArrayIterator<error::JaktError> _magic = ((errors).iterator());
for (;;){
JaktInternal::Optional<error::JaktError> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
error::JaktError error = (_magic_value.value());
{
TRY((((errors_while_trying_to_find_matching_function).push(error))));
}

}
}

return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

if ((!(((resolved_function_id).has_value())))){
if ((!(((resolved_function_id_candidates).is_empty())))){
TRY((((*this).error((ByteString::must_from_utf8("No function with matching signature found."sv)),span))));
{
JaktInternal::ArrayIterator<error::JaktError> _magic = ((errors_while_trying_to_find_matching_function).iterator());
for (;;){
JaktInternal::Optional<error::JaktError> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
error::JaktError match_error = (_magic_value.value());
{
TRY((((((((*this).compiler))->errors)).push(match_error))));
if (((*this).ignore_errors)){
(((*this).had_an_error) = true);
}
}

}
}

{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((resolved_function_id_candidates).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId candidate = (_magic_value.value());
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Candidate: {}"sv)),TRY((((*this).stringify_function_prototype(candidate))))))),span))));
}

}
}

}
JaktInternal::DynamicArray<ids::TypeId> checked_type_args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,caller_scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> arg = (_magic_value.value());
{
NonnullRefPtr<typename types::CheckedExpression> const checked_arg = TRY((((*this).typecheck_expression(((arg).template get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

return TRY((types::CheckedExpression::Call(TRY((((((*this).generic_inferences)).perform_checkpoint(false)))),types::CheckedCall(resolved_namespaces,((call).name),args,checked_type_args,JaktInternal::OptionalNone(),types::builtin(types::BuiltinType::Unknown()),callee_throws,JaktInternal::OptionalNone(),parser::InlineState::Default()),span,types::builtin(types::BuiltinType::Unknown()))));
}
((((*this).generic_inferences)).restore(generic_inferences_for_best_match));
TRY((((((*this).generic_inferences)).set_from(generic_inferences_from_parent))));
NonnullRefPtr<types::CheckedFunction> const callee = ((*this).get_function((resolved_function_id.value())));
(callee_throws = ((callee)->can_throw));
(return_type = ((callee)->return_type_id));
if ((((callee)->is_unsafe) && ((safety_mode).__jakt_init_index() == 0 /* Safe */))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot call unsafe function in safe context"sv)),span))));
}
if ((((type_hint).has_value()) && (!(((((type_hint).value())).equals(types::unknown_type_id())))))){
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
TRY((((*this).check_types_for_compat(return_type,(type_hint.value()),((((*this).generic_inferences))),span))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
}
(return_type = TRY((((*this).substitute_typevars_in_type(return_type,((*this).generic_inferences))))));
if ((((type_hint).has_value()) && (!(((((type_hint).value())).equals(types::unknown_type_id())))))){
bool const old_ignore_errors = ((*this).ignore_errors);
if (((callee)->is_instantiated)){
(((*this).ignore_errors) = true);
}
TRY((((*this).check_types_for_compat((type_hint.value()),return_type,((((*this).generic_inferences))),span))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
}
{
JaktInternal::ArrayIterator<types::FunctionGenericParameter> _magic = ((((((callee)->generics))->params)).iterator());
for (;;){
JaktInternal::Optional<types::FunctionGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::FunctionGenericParameter generic_typevar = (_magic_value.value());
{
if (((((generic_typevar).kind)).__jakt_init_index() == 1 /* Parameter */)){
JaktInternal::Optional<ids::TypeId> const substitution = ((((*this).generic_inferences)).get(((generic_typevar).type_id())));
if (((substitution).has_value())){
TRY((((generic_arguments).push((substitution.value())))));
}
else if ((!(((*this).in_comptime_function_call)))){
TRY((((*this).error((ByteString::must_from_utf8("Not all generic parameters have known types"sv)),span))));
}
else {
TRY((((generic_arguments).push(((generic_typevar).type_id())))));
}

}
}

}
}

if (((!(((callee)->is_instantiated))) || ((!(((((callee)->linkage)).__jakt_init_index() == 1 /* External */))) && (!(((((callee)->generics))->is_specialized_for_types(generic_arguments))))))){
(generic_checked_function_to_instantiate = static_cast<JaktInternal::Optional<ids::FunctionId>>((resolved_function_id.value())));
}
else if (((callee)->is_instantiated)){
if ((((type_hint).has_value()) && (!(((((type_hint).value())).equals(types::unknown_type_id())))))){
TRY((((*this).check_types_for_compat((type_hint.value()),return_type,((((*this).generic_inferences))),span))));
}
}
}

(return_type = TRY((((*this).substitute_typevars_in_type(return_type,((*this).generic_inferences))))));
if ((callee_throws && (!(((TRY((((*this).get_scope(caller_scope_id)))))->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Call to function that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
if (((generic_checked_function_to_instantiate).has_value())){
if (((maybe_this_type_id).has_value())){
(maybe_this_type_id = TRY((((*this).substitute_typevars_in_type((maybe_this_type_id.value()),((*this).generic_inferences))))));
}
(resolved_function_id = TRY((((*this).typecheck_and_specialize_generic_function((generic_checked_function_to_instantiate.value()),generic_arguments,callee_scope_id,maybe_this_type_id,((*this).generic_inferences),((call).type_args),span,args)))));
}
if ((((*this).dump_try_hints) && callee_throws)){
TRY((((*this).dump_try_hint(span))));
}
JaktInternal::Optional<parser::ExternalName> const external_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<parser::ExternalName>,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((resolved_function_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<parser::ExternalName>> __jakt_var_515; {
NonnullRefPtr<types::CheckedFunction> const function = ((*this).get_function((resolved_function_id.value())));
if (((((function)->deprecated_message)).has_value())){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Call to deprecated function: {}"sv)),(((function)->deprecated_message).value())))),span))));
}
__jakt_var_515 = ((function)->external_name); goto __jakt_label_453;

}
__jakt_label_453:; __jakt_var_515.release_value(); }));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if (((resolved_function_id).has_value())){
NonnullRefPtr<types::CheckedFunction> const function = ((*this).get_function((resolved_function_id.value())));
if (((((function)->stores_arguments)).has_value())){
JaktInternal::DynamicArray<JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel>> const argument_behaviour = (((function)->stores_arguments).value());
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel>> _magic = ((argument_behaviour).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel> index__level__ = (_magic_value.value());
{
JaktInternal::Tuple<size_t,parser::ArgumentStoreLevel> const jakt__index__level__ = index__level__;
size_t const index = ((jakt__index__level__).template get<0>());
parser::ArgumentStoreLevel const level = ((jakt__index__level__).template get<1>());

Function<ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>(size_t)> const resolve_arg = [&args, &this_expr, &function](size_t index) -> ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> {
{
if (TRY((((function)->is_static())))){
return ((((args)[index])).template get<1>());
}
if (((index) == (static_cast<size_t>(0ULL)))){
return (this_expr.value());
}
return ((((args)[JaktInternal::checked_sub(index,static_cast<size_t>(1ULL))])).template get<1>());
}
}
;
JaktInternal::Optional<ids::ScopeId> const arg_scope_id = ((TRY((((*this).required_scope_id_in_hierarchy_for(TRY((resolve_arg(index))),caller_scope_id))))).template get<0>());
JaktInternal::Optional<ids::ScopeId> const stored_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::ScopeId>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = level;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* InStaticStorage */: {
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<ids::ScopeId>>(((*this).root_scope_id())));
};/*case end*/
case 0 /* InObject */: {
auto&& __jakt_match_value = __jakt_match_variant.as.InObject;size_t const& argument_index = __jakt_match_value.argument_index;
return JaktInternal::ExplicitValue(((TRY((((*this).required_scope_id_in_hierarchy_for(TRY((resolve_arg(argument_index))),caller_scope_id))))).template get<0>()));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
if (TRY((((*this).scope_lifetime_subsumes(stored_scope_id,arg_scope_id))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot pass this argument by reference, it is not guaranteed to outlive the object it will be stored in"sv)),((TRY((resolve_arg(index))))->span())))));
}
}

}
}

}
}
parser::InlineState const force_inline = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::InlineState,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((resolved_function_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((((*this).get_function((resolved_function_id.value()))))->force_inline));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(parser::InlineState::Default());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
types::CheckedCall const function_call = types::CheckedCall(resolved_namespaces,((call).name),args,generic_arguments,resolved_function_id,return_type,callee_throws,external_name,force_inline);
NonnullRefPtr<typename types::CheckedExpression> const checked_call = TRY((types::CheckedExpression::Call(TRY((((((*this).generic_inferences)).perform_checkpoint(false)))),function_call,span,return_type)));
bool const in_comptime_function = (((((*this).current_function_id)).has_value()) && ((((*this).get_function(((((*this).current_function_id)).value()))))->is_comptime));
if (((!(in_comptime_function)) && (((resolved_function_id).has_value()) && ((((*this).get_function((resolved_function_id.value()))))->is_comptime)))){
NonnullRefPtr<types::CheckedFunction> const resolved_function = ((*this).get_function((resolved_function_id.value())));
NonnullRefPtr<interpreter::Interpreter> interpreter = TRY((((*this).interpreter())));
NonnullRefPtr<types::CheckedFunction> const function = ((((*this).program))->get_function(generic_checked_function_to_instantiate.value_or_lazy_evaluated([&] { return (resolved_function_id.value()); })));
JaktInternal::DynamicArray<types::Value> call_args = (TRY((DynamicArray<types::Value>::create_with({}))));
JaktInternal::Optional<types::Value> this_argument = JaktInternal::OptionalNone();
NonnullRefPtr<interpreter::InterpreterScope> eval_scope = TRY((interpreter::InterpreterScope::from_runtime_scope(caller_scope_id,((*this).program),JaktInternal::OptionalNone())));
{
JaktInternal::DictionaryIterator<ids::TypeId,ids::TypeId> _magic = ((((((*this).generic_inferences)).iterator())).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TypeId,ids::TypeId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TypeId,ids::TypeId> entry = (_magic_value.value());
{
JaktInternal::Tuple<ids::TypeId,ids::TypeId> const key_value_ = entry;
ids::TypeId const key = ((key_value_).template get<0>());
ids::TypeId const value = ((key_value_).template get<1>());

TRY((((((eval_scope)->type_bindings)).set(key,value))));
}

}
}

if (((this_expr).has_value())){
auto __jakt_var_516 = [&]() -> ErrorOr<void> {{
interpreter::StatementResult const evaluated_this = TRY((((interpreter)->execute_expression((this_expr.value()),eval_scope))));
if (((evaluated_this).__jakt_init_index() == 5 /* JustValue */)){
types::Value const value = (evaluated_this).as.JustValue.value;
(this_argument = value);
}
else if (((evaluated_this).__jakt_init_index() == 1 /* Throw */)){
types::Value const value = (evaluated_this).as.Throw.value;
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Error executing this expression (evaluation threw {})"sv)),value))),(((this_expr.value()))->span())))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Invalid this expression"sv)),(((this_expr.value()))->span())))));
}

}

;return {};}();
if (__jakt_var_516.is_error()) {{
TRY((((*this).error((ByteString::must_from_utf8("Error executing this expression"sv)),(((this_expr.value()))->span())))));
}
};
}
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>> _magic = ((args).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,NonnullRefPtr<typename types::CheckedExpression>> argument = (_magic_value.value());
{
interpreter::StatementResult const value = ({ Optional<interpreter::StatementResult> __jakt_var_517;
auto __jakt_var_518 = [&]() -> ErrorOr<interpreter::StatementResult> { return TRY((((interpreter)->execute_expression(((argument).template get<1>()),eval_scope)))); }();
if (__jakt_var_518.is_error()) {{
TRY((((*this).error((ByteString::must_from_utf8("Error in argument"sv)),span))));
continue;
}
} else {__jakt_var_517 = __jakt_var_518.release_value();
}
__jakt_var_517.release_value(); });
if (((value).__jakt_init_index() == 1 /* Throw */)){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Compiletime call failed: {}"sv)),value))),((((argument).template get<1>()))->span())))));
break;
}
types::Value const evaluated_value = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::Value, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = value;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Return */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Return;types::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
case 5 /* JustValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JustValue;types::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
return Error::from_errno(static_cast<i32>(69));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
TRY((((call_args).push(evaluated_value))));
}

}
}

JaktInternal::Dictionary<ids::TypeId,ids::TypeId> type_bindings = (TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({}))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((((resolved_function)->generics))->params)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
types::FunctionGenericParameter const param = ((((((resolved_function)->generics))->params))[i]);
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((((function_call).type_args)).size()),i)){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Missing type argument for generic parameter {}"sv)),i))),span))));
break;
}
TRY((((type_bindings).set(((param).type_id()),((((function_call).type_args))[i])))));
}

}
}

JaktInternal::Optional<interpreter::ExecutionResult> result = JaktInternal::OptionalNone();
NonnullRefPtr<interpreter::InterpreterScope> invocation_scope = TRY((interpreter::InterpreterScope::create((TRY((Dictionary<ByteString, types::Value>::create_with_entries({})))),JaktInternal::OptionalNone(),(TRY((Dictionary<ids::TypeId, ids::TypeId>::create_with_entries({})))))));
auto __jakt_var_519 = [&]() -> ErrorOr<void> {{
(result = TRY((((interpreter)->execute((resolved_function_id.value()),resolved_namespaces,this_argument,call_args,span,invocation_scope)))));
}

;return {};}();
if (__jakt_var_519.is_error()) {auto error = __jakt_var_519.release_error();{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Compiletime call failed: {}"sv)),error))),span))));
return checked_call;
}
};
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Return */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Return;types::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((interpreter::value_to_checked_expression(x,interpreter))));
};/*case end*/
case 1 /* Throw */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Throw;types::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_520; {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Compiletime call failed: {}"sv)),x))),((x).span)))));
__jakt_var_520 = checked_call; goto __jakt_label_454;

}
__jakt_label_454:; __jakt_var_520.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return checked_call;
}
}

ErrorOr<JaktInternal::DynamicArray<ids::FunctionId>> typechecker::Typechecker::resolve_call(parser::ParsedCall const call,JaktInternal::DynamicArray<types::ResolvedNamespace> namespaces,utility::Span const span,ids::ScopeId const scope_id,bool const must_be_enum_constructor) {
{
ids::ScopeId current_scope_id = scope_id;
JaktInternal::DynamicArray<bool> is_base_ns_alias_or_import = (TRY((DynamicArray<bool>::filled(((namespaces).size()), false))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).namespace_)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t namespace_index = (_magic_value.value());
{
ByteString const scope_name = ((((call).namespace_))[namespace_index]);
JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>> const maybe_ns_scope = TRY((((*this).find_namespace_in_scope(current_scope_id,scope_name,false,JaktInternal::OptionalNone()))));
if (((maybe_ns_scope).has_value())){
JaktInternal::Tuple<ids::ScopeId,bool> const scope_id_is_import_ = (maybe_ns_scope.value());
ids::ScopeId const scope_id = ((scope_id_is_import_).template get<0>());
bool const is_import = ((scope_id_is_import_).template get<1>());

if (is_import){
(((((namespaces)[namespace_index])).name) = ((((((((*this).program))->modules))[((((scope_id).module_id)).id)]))->name));
}
(((((namespaces)[namespace_index])).external_name) = ((TRY((((*this).get_scope(scope_id)))))->external_name));
(((is_base_ns_alias_or_import)[namespace_index]) = (((TRY((((*this).find_namespace_in_scope(current_scope_id,scope_name,true,JaktInternal::OptionalNone())))).value())).template get<1>()));
(current_scope_id = scope_id);
continue;
}
JaktInternal::Optional<ids::StructId> const maybe_struct_scope = TRY((((*this).find_struct_in_scope(current_scope_id,scope_name,JaktInternal::OptionalNone()))));
if (((maybe_struct_scope).has_value())){
types::CheckedStruct const structure = ((*this).get_struct((maybe_struct_scope.value())));
(((((namespaces)[namespace_index])).external_name) = ((structure).external_name));
(current_scope_id = ((structure).scope_id));
continue;
}
JaktInternal::Optional<ids::EnumId> const maybe_enum_scope = TRY((((((*this).program))->find_enum_in_scope(current_scope_id,scope_name,false,JaktInternal::OptionalNone()))));
if (((maybe_enum_scope).has_value())){
types::CheckedEnum const enum_ = ((*this).get_enum((maybe_enum_scope.value())));
(current_scope_id = ((enum_).scope_id));
continue;
}
if (((TRY((((((*this).generic_inferences)).find_and_map(scope_name,((((*this).program)))))))).has_value())){
ids::TypeId const type_id = (TRY((((((*this).generic_inferences)).find_and_map(scope_name,((((*this).program))))))).value());
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<JaktInternal::DynamicArray<ids::FunctionId>>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.__jakt_init_index()) {
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
(current_scope_id = ((((*this).get_enum(enum_id))).scope_id));
return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
{
(current_scope_id = ((((*this).get_enum(enum_id))).scope_id));
return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
(current_scope_id = ((((*this).get_struct(struct_id))).scope_id));
return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
{
(current_scope_id = ((((*this).get_struct(struct_id))).scope_id));
return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Not a namespace, enum, class, or struct: ‘{}’"sv)),TRY((utility::join(((call).namespace_),(ByteString::must_from_utf8("::"sv)))))))),span))));
}

}
}

ids::ScopeId initial_scope_id = current_scope_id;
JaktInternal::Optional<ids::ScopeId> owning_scope = JaktInternal::OptionalNone();
ScopeGuard __jakt_var_521([&] {
{
JaktInternal::DynamicArray<types::ResolvedNamespace> resolved_namespaces = (MUST((DynamicArray<types::ResolvedNamespace>::create_with({}))));
{
i64 ns_index = static_cast<i64>(0LL);
{
JaktInternal::ArrayIterator<types::ResolvedNamespace> _magic = ((namespaces).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedNamespace> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedNamespace ns = (_magic_value.value());
{
ScopeGuard __jakt_var_522([&] {
((ns_index) += (static_cast<i64>(1LL)));
});
if ((!(((is_base_ns_alias_or_import)[ns_index])))){
MUST((((resolved_namespaces).push(ns))));
}
}

}
}

}

if ((!(((owning_scope).has_value())))){
JaktInternal::DynamicArray<types::ResolvedNamespace> aliased_namespaces = (MUST((DynamicArray<types::ResolvedNamespace>::create_with({}))));
for (;;){
NonnullRefPtr<types::Scope> const scope = MUST((((*this).get_scope(current_scope_id))));
if (((((scope)->alias_path)).has_value())){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>((((((scope)->alias_path).value())).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
MUST((((aliased_namespaces).push((((((scope)->alias_path).value()))[JaktInternal::checked_sub(i,static_cast<size_t>(1ULL))])))));
}

}
}

}
else if (((((scope)->namespace_name)).has_value())){
MUST((((aliased_namespaces).push(types::ResolvedNamespace((((scope)->namespace_name).value()),((scope)->external_name),JaktInternal::OptionalNone())))));
}
if (MUST((((*this).is_scope_directly_accessible_from(current_scope_id,initial_scope_id))))){
break;
}
JaktInternal::Optional<ids::ScopeId> const parent = ((scope)->parent);
if ((!(((parent).has_value())))){
break;
}
(current_scope_id = (parent.value()));
}
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(((aliased_namespaces).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
MUST((((resolved_namespaces).push(((aliased_namespaces)[JaktInternal::checked_sub(i,static_cast<size_t>(1ULL))])))));
}

}
}

}
((namespaces).shrink(static_cast<size_t>(0ULL)));
MUST((((namespaces).push_values(((resolved_namespaces))))));
}

});
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const maybe_var = TRY((((*this).find_var_in_scope(current_scope_id,((call).name),JaktInternal::OptionalNone()))));
if (((maybe_var).has_value())){
ids::TypeId const inner_type = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<JaktInternal::DynamicArray<ids::FunctionId>>>{
auto&& __jakt_match_variant = *((*this).get_type((((maybe_var.value()))->type_id)));
switch(__jakt_match_variant.__jakt_init_index()) {
case 28 /* Reference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reference;ids::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 29 /* MutableReference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MutableReference;ids::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
default: {
return JaktInternal::ExplicitValue((((maybe_var.value()))->type_id));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if (((((*this).get_type(inner_type)))->__jakt_init_index() == 30 /* Function */)){
ids::FunctionId const pseudo_function_id = (((*this).get_type(inner_type)))->as.Function.pseudo_function_id;
return (TRY((DynamicArray<ids::FunctionId>::create_with({pseudo_function_id}))));
}
}
JaktInternal::Optional<JaktInternal::Tuple<JaktInternal::DynamicArray<ids::FunctionId>,ids::ScopeId>> const maybe_overload_set = TRY((((*this).find_scoped_functions_with_name_in_scope(current_scope_id,((call).name),current_scope_id))));
if (((maybe_overload_set).has_value())){
NonnullRefPtr<types::CheckedFunction> const function = ((*this).get_function((((((maybe_overload_set.value())).template get<0>()))[static_cast<i64>(0LL)])));
if (((!(must_be_enum_constructor)) || ((((function)->type)).__jakt_init_index() == 3 /* ImplicitEnumConstructor */))){
(owning_scope = ((function)->owner_scope));
(current_scope_id = (((maybe_overload_set.value())).template get<1>()));
return (((maybe_overload_set.value())).template get<0>());
}
}
if (must_be_enum_constructor){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("No such enum constructor ‘{}’"sv)),((call).name)))),span))));
return (TRY((DynamicArray<ids::FunctionId>::create_with({}))));
}
JaktInternal::Optional<ids::StructId> const maybe_struct_id = TRY((((*this).find_struct_in_scope(current_scope_id,((call).name),JaktInternal::OptionalNone()))));
if (((maybe_struct_id).has_value())){
ids::StructId const struct_id = (maybe_struct_id.value());
types::CheckedStruct const structure = ((*this).get_struct(struct_id));
JaktInternal::Optional<JaktInternal::Tuple<JaktInternal::DynamicArray<ids::FunctionId>,ids::ScopeId>> const maybe_function_id = TRY((((*this).find_scoped_functions_with_name_in_scope(((structure).scope_id),((structure).name),((structure).scope_id)))));
if (((maybe_function_id).has_value())){
(owning_scope = ((((*this).get_function((((((maybe_function_id.value())).template get<0>()))[static_cast<i64>(0LL)]))))->owner_scope));
(current_scope_id = (((maybe_function_id.value())).template get<1>()));
return (((maybe_function_id.value())).template get<0>());
}
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Call to unknown function: ‘{}’"sv)),((call).name)))),span))));
return (TRY((DynamicArray<ids::FunctionId>::create_with({}))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_auto_extern_imports(JaktInternal::DynamicArray<parser::ParsedExternImport> const imports,auto const child_scope_id) {
{
if (((imports).is_empty())){
return {};
}
ByteStringBuilder builder = ByteStringBuilder::create();
ByteStringBuilder path_name_builder = ByteStringBuilder::create();
TRY((((builder).append((StringView::from_string_literal("#pragma once\n"sv))))));
{
JaktInternal::ArrayIterator<parser::ParsedExternImport> _magic = ((imports).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport import_ = (_magic_value.value());
{
TRY((((path_name_builder).append((StringView::from_string_literal("_"sv))))));
TRY((((path_name_builder).append(TRY((((TRY((jakt__path::Path::from_string(((import_).get_path()))))).basename(true))))))));
{
JaktInternal::ArrayIterator<parser::IncludeAction> _magic = ((((import_).before_include)).iterator());
for (;;){
JaktInternal::Optional<parser::IncludeAction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::IncludeAction action = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = action;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Define */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Define;ByteString const& name = __jakt_match_value.name;
ByteString const& value = __jakt_match_value.value;
return (TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal("#define {} {}\n"sv)),name,value)))))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Undefine */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Undefine;ByteString const& name = __jakt_match_value.name;
return (TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal("#undef {}\n"sv)),name)))))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

if (((import_).is_c)){
TRY((((builder).append((StringView::from_string_literal("extern \"C\" {\n"sv))))));
}
TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal("#include <{}>\n"sv)),((import_).get_path()))))))));
if (((import_).is_c)){
TRY((((builder).append((StringView::from_string_literal("}\n"sv))))));
}
{
JaktInternal::ArrayIterator<parser::IncludeAction> _magic = ((((import_).after_include)).iterator());
for (;;){
JaktInternal::Optional<parser::IncludeAction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::IncludeAction action = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = action;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Define */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Define;ByteString const& name = __jakt_match_value.name;
ByteString const& value = __jakt_match_value.value;
return (TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal("#define {} {}\n"sv)),name,value)))))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Undefine */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Undefine;ByteString const& name = __jakt_match_value.name;
return (TRY((((builder).append(TRY((__jakt_format((StringView::from_string_literal("#undef {}\n"sv)),name)))))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}

}
}

ByteString const contents = TRY((((builder).to_string())));
ByteString const filename = TRY((__jakt_format((StringView::from_string_literal("jakt_autogen_{}.h"sv)),((TRY((((path_name_builder).to_string())))).hash()))));
jakt__path::Path const output = TRY((((TRY((((((((*this).compiler))->binary_dir)).absolute())))).join(filename))));
TRY((utility::write_to_file(contents,((output).to_string()))));
ids::ScopeId const import_scope_id = ({ Optional<ids::ScopeId> __jakt_var_523;
auto __jakt_var_524 = [&]() -> ErrorOr<ids::ScopeId> { return TRY((((*this).cache_or_process_cpp_import(output,child_scope_id,false,(TRY((Dictionary<ByteString, ByteString>::create_with_entries({})))))))); }();
if (__jakt_var_524.is_error()) {auto e = __jakt_var_524.release_error();
{
if (((ByteString::must_from_utf8(((e).string_literal()))) == (ByteString::must_from_utf8(cpp_import__common::CppImportErrors::path_not_found())))){
{
JaktInternal::ArrayIterator<parser::ParsedExternImport> _magic = ((imports).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport import_ = (_magic_value.value());
{
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Could not find imported extern file '{}'"sv)),((import_).get_path())))),(((((import_).assigned_namespace)).name_span).value()),(ByteString::must_from_utf8("make sure the file exists and is in the include path"sv)),(((((import_).assigned_namespace)).name_span).value())))));
}

}
}

return {};
}
else {
return e;
}

}
} else {__jakt_var_523 = __jakt_var_524.release_value();
}
__jakt_var_523.release_value(); });
{
JaktInternal::ArrayIterator<parser::ParsedExternImport> _magic = ((imports).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport import_ = (_magic_value.value());
{
TRY((((((*this).cpp_import_cache)).set(((import_).get_path()),import_scope_id))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_if(NonnullRefPtr<typename parser::ParsedExpression> const condition,parser::ParsedBlock const then_block,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const else_statement,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>> const new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(condition,JaktInternal::OptionalNone(),then_block,else_statement,scope_id,span))));
NonnullRefPtr<typename parser::ParsedExpression> const new_condition = ((new_condition_new_then_block_new_else_statement_).template get<0>());
JaktInternal::Optional<parser::ParsedBlock> const new_then_block = ((new_condition_new_then_block_new_else_statement_).template get<1>());
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const new_else_statement = ((new_condition_new_then_block_new_else_statement_).template get<2>());

NonnullRefPtr<typename types::CheckedExpression> const checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((((checked_condition)->type())).equals(types::builtin(types::BuiltinType::Bool())))))){
TRY((((*this).error((ByteString::must_from_utf8("Condition must be a boolean expression"sv)),((new_condition)->span())))));
}
types::CheckedBlock const checked_block = TRY((((*this).typecheck_block((new_then_block.value()),scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("An 'if' block is not allowed to yield values"sv)),((((new_then_block.value())).find_yield_span()).value())))));
}
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode,JaktInternal::OptionalNone())))));
}
return TRY((types::CheckedStatement::If(checked_condition,checked_block,checked_else,span)));
}
}

ErrorOr<void> typechecker::Typechecker::check_implicit_constructor_argument_access(ids::ScopeId const caller_scope_id,parser::ParsedCall const call,types::CheckedStruct const struct_) {
{
if ((!(TRY((((*this).scope_can_access(caller_scope_id,((struct_).scope_id)))))))){
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>> arg = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((struct_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const variable = ((*this).get_variable(((field).variable_id)));
ByteString const name = TRY((((*this).get_argument_name(arg))));
if ((((((variable)->name)) == (name)) && ((((variable)->visibility)).__jakt_init_index() == 1 /* Private */))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Can't access field '{}' when calling implicit constructor of '{}' because it is marked private"sv)),((variable)->name),((struct_).name)))),((arg).template get<1>())))));
return {};
}
}

}
}

}

}
}

}
}
return {};
}

ErrorOr<JaktInternal::Optional<ids::TypeId>> typechecker::Typechecker::find_explicitly_specialized_type_in_scope(ids::ScopeId const scope_id,ByteString const name,JaktInternal::DynamicArray<ids::TypeId> const arguments,utility::Span const span) {
{
JaktInternal::DynamicArray<types::SpecializedType> matching_types = (TRY((DynamicArray<types::SpecializedType>::create_with({}))));
TRY((((((*this).program))->template for_each_scope_accessible_unqualified_from_scope<bool>(scope_id,(([&matching_types, &name, &arguments, &span, this](ids::ScopeId scope_id, JaktInternal::Optional<ByteString> name_override, bool is_alias) -> ErrorOr<typename utility::IterationDecision<bool>> {
{
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
if ((!(((((scope)->explicitly_specialized_types)).contains(name))))){
return utility::IterationDecision<bool>::Continue();
}
types::SpecializedType const specialized_type = ((((scope)->explicitly_specialized_types))[name]);
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const checkpoint = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_525([&] {
((((*this).generic_inferences)).restore(checkpoint));
});
bool is_okay = true;
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((specialized_type).arguments)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) != (static_cast<u8>(2)));
}
}
(((arguments).size()),i)){
break;
}
ids::TypeId const given_arg = ((arguments)[i]);
ids::TypeId const specialized_arg = ((((specialized_type).arguments))[i]);
bool const old_ignore_errors = ((*this).ignore_errors);
ScopeGuard __jakt_var_526([&] {
(((*this).ignore_errors) = old_ignore_errors);
});
(((*this).ignore_errors) = true);
if ((!(TRY((((*this).check_types_for_compat(specialized_arg,given_arg,((((*this).generic_inferences))),span))))))){
(is_okay = false);
break;
}
}

}
}

if (is_okay){
TRY((((matching_types).push(specialized_type))));
}
return utility::IterationDecision<bool>::Continue();
}
}
)),false,JaktInternal::OptionalNone()))));
JaktInternal::Optional<ids::TypeId> result = JaktInternal::OptionalNone();
JaktInternal::Optional<types::SpecializedType> chosen_specialization = JaktInternal::OptionalNone();
i64 max_seen_specificity = static_cast<i64>(0LL);
{
JaktInternal::ArrayIterator<types::SpecializedType> _magic = ((matching_types).iterator());
for (;;){
JaktInternal::Optional<types::SpecializedType> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::SpecializedType specialization = (_magic_value.value());
{
i64 total_specificity = static_cast<i64>(0LL);
{
JaktInternal::ArrayIterator<ids::TypeId> _magic = ((((specialization).arguments)).iterator());
for (;;){
JaktInternal::Optional<ids::TypeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::TypeId arg = (_magic_value.value());
{
((total_specificity) += (((((*this).get_type(arg)))->specificity(((*this).program),(static_cast<i64>(1LL) << static_cast<i64>(31LL))))));
}

}
}

if ([](i64 const& self, i64 rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](i64 const& self, i64 rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(total_specificity,max_seen_specificity)){
(max_seen_specificity = total_specificity);
(result = ((specialization).type_id));
(chosen_specialization = specialization);
}
}

}
}

if (((chosen_specialization).has_value())){
if (((TRY((types::StructLikeId::from_type_id((result.value()),((((*this).program))))))).has_value())){
types::StructLikeId const struct_like_id = (TRY((types::StructLikeId::from_type_id((result.value()),((((*this).program)))))).value());
TRY((((((*this).generic_inferences)).set_all(TRY((((struct_like_id).generic_parameters_as_checked(((((*this).program))))))),(((chosen_specialization.value())).arguments)))));
}
}
return result;
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum(parser::ParsedRecord const record,ids::EnumId const enum_id,ids::ScopeId const parent_scope_id) {
{
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(((((*this).get_enum(enum_id))).type_id)))));
ScopeGuard __jakt_var_527([&] {
(((*this).self_type_id) = old_self_type_id);
});
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_method(((method).parsed_function),types::StructLikeId::Enum(JaktInternal::OptionalNone(),enum_id)))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_expression_and_dereference_if_needed(NonnullRefPtr<typename parser::ParsedExpression> const expr,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,type_hint))));
return TRY((((*this).dereference_if_needed(checked_expr,span))));
}
}

ErrorOr<JaktInternal::Optional<ids::TypeId>> typechecker::Typechecker::find_type_in_scope(ids::ScopeId const scope_id,ByteString const name) const {
{
return TRY((((((*this).program))->find_type_in_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
}
}

ErrorOr<void> typechecker::Typechecker::set_self_type_id(ids::TypeId const type_id) {
{
if (((((*this).get_type(type_id)))->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const struct_id = (((*this).get_type(type_id)))->as.Struct.value;
if (((((((*this).get_struct(struct_id))).implements_type)).has_value())){
ids::TypeId const replacement_type_id = (((((*this).get_struct(struct_id))).implements_type).value());
(((*this).self_type_id) = replacement_type_id);
}
else {
(((*this).self_type_id) = type_id);
}

}
else {
(((*this).self_type_id) = type_id);
}

}
return {};
}

ErrorOr<JaktInternal::Optional<types::CheckedEnumVariant>> typechecker::Typechecker::get_enum_variant(types::CheckedEnum const enum_,ByteString const variant_name) {
{
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
if (((((variant).name())) == (variant_name))){
return variant;
}
}

}
}

return JaktInternal::OptionalNone();
}
}

ErrorOr<bool> typechecker::Typechecker::scope_can_access(ids::ScopeId const accessor,ids::ScopeId const accessee) const {
{
if (((accessor).equals(accessee))){
return true;
}
NonnullRefPtr<types::Scope> accessor_scope = TRY((((*this).get_scope(accessor))));
while (((((accessor_scope)->parent)).has_value())){
ids::ScopeId const parent = (((accessor_scope)->parent).value());
if (((parent).equals(accessee))){
return true;
}
(accessor_scope = TRY((((*this).get_scope(parent)))));
}
return false;
}
}

ErrorOr<JaktInternal::DynamicArray<ids::StructId>> typechecker::Typechecker::struct_inheritance_chain(ids::StructId const struct_id) const {
{
JaktInternal::DynamicArray<ids::StructId> chain = (TRY((DynamicArray<ids::StructId>::create_with({}))));
JaktInternal::Optional<ids::StructId> current = static_cast<JaktInternal::Optional<ids::StructId>>(struct_id);
TRY((((chain).push((current.value())))));
while (((current).has_value())){
JaktInternal::Optional<ids::StructId> const parent = ((((*this).get_struct((current.value())))).super_struct_id);
if (((parent).has_value())){
TRY((((chain).push((parent.value())))));
}
(current = parent);
}
JaktInternal::DynamicArray<ids::StructId> reverse_chain = (TRY((DynamicArray<ids::StructId>::create_with({}))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((chain).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((reverse_chain).push(((chain)[JaktInternal::checked_sub(JaktInternal::checked_sub(((chain).size()),static_cast<size_t>(1ULL)),i)])))));
}

}
}

return reverse_chain;
}
}

ErrorOr<bool> typechecker::Typechecker::type_contains_reference(ids::TypeId const type_id) {
{
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(type_id));
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<bool>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 28 /* Reference */: {
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 29 /* MutableReference */: {
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_for(ByteString const iterator_name,utility::Span const name_span,bool const is_destructuring,NonnullRefPtr<typename parser::ParsedExpression> const range,parser::ParsedBlock const block,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
JaktInternal::Optional<utility::Span> const maybe_span = ((block).find_yield_span());
if (((maybe_span).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("a 'for' loop block is not allowed to yield values"sv)),(maybe_span.value())))));
}
NonnullRefPtr<typename types::CheckedExpression> iterable_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(range,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId resolved_iterable_result_type = types::unknown_type_id();
NonnullRefPtr<typename parser::ParsedExpression> expression_to_iterate = range;
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const iterable_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(((iterable_expr)->type()),(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("Iterable"sv)), (ByteString::must_from_utf8("ThrowingIterable"sv))})))),scope_id,((iterable_expr)->span()),JaktInternal::OptionalNone()))));
if ((!(((iterable_trait_implementation).has_value())))){
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const into_iterator_trait_implementation = TRY((((*this).find_any_singular_trait_implementation(((iterable_expr)->type()),(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("IntoIterator"sv)), (ByteString::must_from_utf8("IntoThrowingIterator"sv))})))),scope_id,((iterable_expr)->span()),JaktInternal::OptionalNone()))));
if ((!(((into_iterator_trait_implementation).has_value())))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Iterable expression is not iterable"sv)),((range)->span()),TRY((__jakt_format((StringView::from_string_literal("Consider implementing (Throwing)Iterable<T> or Into(Throwing)Iterator<T> for the type of this expression (‘{}’)"sv)),TRY((((*this).type_name(((iterable_expr)->type()),false))))))),((range)->span())))));
}
else {
(resolved_iterable_result_type = (((((into_iterator_trait_implementation.value())).implemented_type_args))[static_cast<i64>(0LL)]));
(expression_to_iterate = TRY((parser::ParsedExpression::MethodCall(range,parser::ParsedCall((TRY((DynamicArray<ByteString>::create_with({})))),(ByteString::must_from_utf8("iterator"sv)),(TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedType>>::create_with({}))))),false,name_span))));
}

}
else {
(resolved_iterable_result_type = (((((iterable_trait_implementation.value())).implemented_type_args))[static_cast<i64>(0LL)]));
}

NonnullRefPtr<typename parser::ParsedStatement> const rewritten_statement = TRY((parser::ParsedStatement::Block(parser::ParsedBlock((TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::VarDecl(parser::ParsedVarDecl((ByteString::must_from_utf8("_magic"sv)),TRY((parser::ParsedType::Empty(JaktInternal::OptionalNone()))),true,JaktInternal::OptionalNone(),name_span,JaktInternal::OptionalNone()),expression_to_iterate,span))), TRY((parser::ParsedStatement::Loop(parser::ParsedBlock((TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::VarDecl(parser::ParsedVarDecl((ByteString::must_from_utf8("_magic_value"sv)),TRY((parser::ParsedType::Empty(JaktInternal::OptionalNone()))),false,JaktInternal::OptionalNone(),name_span,JaktInternal::OptionalNone()),TRY((parser::ParsedExpression::MethodCall(TRY((parser::ParsedExpression::Var((ByteString::must_from_utf8("_magic"sv)),name_span))),parser::ParsedCall((TRY((DynamicArray<ByteString>::create_with({})))),(ByteString::must_from_utf8("next"sv)),(TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedType>>::create_with({}))))),false,name_span))),span))), TRY((parser::ParsedStatement::If(TRY((parser::ParsedExpression::UnaryOp(TRY((parser::ParsedExpression::MethodCall(TRY((parser::ParsedExpression::Var((ByteString::must_from_utf8("_magic_value"sv)),name_span))),parser::ParsedCall((TRY((DynamicArray<ByteString>::create_with({})))),(ByteString::must_from_utf8("has_value"sv)),(TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span,NonnullRefPtr<typename parser::ParsedExpression>>>::create_with({})))),(TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedType>>::create_with({}))))),false,name_span))),parser::UnaryOperator::LogicalNot(),name_span))),parser::ParsedBlock((TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::Break(span)))}))))),JaktInternal::OptionalNone(),span))), TRY((parser::ParsedStatement::VarDecl(parser::ParsedVarDecl(iterator_name,TRY((parser::ParsedType::Empty(JaktInternal::OptionalNone()))),true,({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<utility::Span>,ErrorOr<NonnullRefPtr<typename types::CheckedStatement>>>{
auto __jakt_enum_value = (is_destructuring);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(name_span);
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}),name_span,JaktInternal::OptionalNone()),TRY((parser::ParsedExpression::ForcedUnwrap(TRY((parser::ParsedExpression::Var((ByteString::must_from_utf8("_magic_value"sv)),name_span))),name_span))),span))), TRY((parser::ParsedStatement::Block(block,span)))}))))),span)))}))))),span)));
return TRY((((*this).typecheck_statement(rewritten_statement,scope_id,safety_mode,JaktInternal::OptionalNone()))));
}
}

ErrorOr<JaktInternal::Optional<ids::FunctionId>> typechecker::Typechecker::find_function_matching_signature_in_scope(ids::ScopeId const parent_scope_id,parser::ParsedFunction const prototype) const {
{
ByteString const function_name = ((prototype).name);
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const candidate_ids = TRY((((((*this).program))->find_functions_with_name_in_scope(parent_scope_id,function_name,false,JaktInternal::OptionalNone()))));
if (((candidate_ids).has_value())){
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = (((candidate_ids.value())).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId candidate_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const candidate = ((*this).get_function(candidate_id));
if ((((((candidate)->parsed_function)).has_value()) && (((((candidate)->parsed_function).value())).equals(prototype,false)))){
return candidate_id;
}
}

}
}

}
return JaktInternal::OptionalNone();
}
}

ErrorOr<void> typechecker::Typechecker::resolve_external_trait_implementations(parser::ParsedExternalTraitImplementation const implementation,ids::ScopeId const entity_scope_id,JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>& trait_implementations,ids::TypeId const for_type,ids::ScopeId const scope_id,bool const default_pass) {
{
if (default_pass){
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const impls = TRY((((*this).fill_trait_implementation_list(((implementation).traits),((((trait_implementations)))),entity_scope_id,scope_id))));
size_t index = static_cast<size_t>(0ULL);
{
JaktInternal::ArrayIterator<parser::ParsedNameWithGenericParameters> _magic = ((((implementation).traits)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedNameWithGenericParameters> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNameWithGenericParameters trait_name = (_magic_value.value());
{
ScopeGuard __jakt_var_528([&] {
((index) += (static_cast<size_t>(1ULL)));
});
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((*this).find_trait_in_scope(scope_id,((trait_name).name)))));
if (((trait_id).has_value())){
NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait((trait_id.value())));
if (((((trait_)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = (((trait_)->requirements)).as.Methods.value;
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_529([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
TRY((((((*this).generic_inferences)).set_all(((trait_)->generic_parameters),((((impls)[index])).template get<1>())))));
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> name__function_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__name__function_id__ = name__function_id__;
ByteString const name = ((jakt__name__function_id__).template get<0>());
ids::FunctionId const function_id = ((jakt__name__function_id__).template get<1>());

NonnullRefPtr<types::CheckedFunction>& function = ((((((((((((*this).program))->modules))[((((function_id).module)).id)]))->functions))[((function_id).id)])));
if (((((((((function)))->block)).statements)).is_empty())){
continue;
}
types::GenericInferences const inferences = ((*this).generic_inferences);
TRY((((((function)))->map_types((([inferences](ids::TypeId type_id) -> ErrorOr<ids::TypeId> {
{
return ((inferences).map(type_id));
}
}
))))));
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> ids = TRY((((*this).find_functions_with_name_in_scope(entity_scope_id,name,JaktInternal::OptionalNone()))));
if ((!(((ids).has_value())))){
TRY((((*this).add_function_to_scope(entity_scope_id,name,(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((trait_name).name_span)))));
}
}

}
}

}
else {
continue;
}

}
else {
continue;
}

}

}
}

}
else {
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((implementation).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
JaktInternal::Optional<ids::TypeId> this_arg_type_id = JaktInternal::OptionalNone();
if (((TRY((((((((((((method).parsed_function)).params)).first())).map([](auto& _value) { return _value.variable; }))).map([](auto& _value) { return _value.name; })).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); })))) == ((ByteString::must_from_utf8("this"sv))))){
(this_arg_type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::TypeId>, ErrorOr<void>>{
auto&& __jakt_match_variant = *((*this).get_type(for_type));
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_530; {
types::CheckedStruct const struct_ = ((*this).get_struct(id));
ids::TypeId type = for_type;
if ((!(((((struct_).generic_parameters)).is_empty())))){
JaktInternal::DynamicArray<ids::TypeId> type_arguments = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedGenericParameter> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedGenericParameter param = (_magic_value.value());
{
TRY((((type_arguments).push(((param).type_id)))));
}

}
}

(type = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),id,type_arguments))))))));
}
__jakt_var_530 = type; goto __jakt_label_455;

}
__jakt_label_455:; __jakt_var_530.release_value(); }));
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_531; {
types::CheckedEnum const enum_ = ((*this).get_enum(id));
ids::TypeId type = for_type;
if ((!(((((enum_).generic_parameters)).is_empty())))){
JaktInternal::DynamicArray<ids::TypeId> type_arguments = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedGenericParameter> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedGenericParameter param = (_magic_value.value());
{
TRY((((type_arguments).push(((param).type_id)))));
}

}
}

(type = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericEnumInstance(parser::CheckedQualifiers(false),id,type_arguments))))))));
}
__jakt_var_531 = type; goto __jakt_label_456;

}
__jakt_label_456:; __jakt_var_531.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(for_type);
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
}));
}
TRY((((*this).typecheck_function_predecl(((method).parsed_function),entity_scope_id,this_arg_type_id,JaktInternal::OptionalNone(),scope_id))));
}

}
}

}

}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_array(ids::ScopeId const scope_id,JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedExpression>> const values,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const fill_size,utility::Span const span,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
if ((!(((TRY((((*this).get_scope(scope_id)))))->can_throw)))){
ByteString const message = (ByteString::must_from_utf8("Array initialization inside non-throwing scope"sv));
if (((((*this).current_function_id)).has_value())){
NonnullRefPtr<types::CheckedFunction> const current_function = ((*this).get_function((((*this).current_function_id).value())));
TRY((((*this).error_with_hint(message,span,TRY((__jakt_format((StringView::from_string_literal("Add `throws` keyword to function {}"sv)),((current_function)->name)))),((current_function)->name_span)))));
}
else {
TRY((((*this).error(message,span))));
}

}
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> repeat = JaktInternal::OptionalNone();
if (((fill_size).has_value())){
NonnullRefPtr<typename parser::ParsedExpression> const fill_size_value = ((fill_size).value());
NonnullRefPtr<typename types::CheckedExpression> const fill_size_checked = TRY((((*this).typecheck_expression_and_dereference_if_needed(fill_size_value,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId const fill_size_type = ((fill_size_checked)->type());
if ((!(((*this).is_integer(fill_size_type))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions."sv)),TRY((((*this).type_name(fill_size_type,false))))))),((fill_size_value)->span())))));
}
(repeat = fill_size_checked);
}
ids::StructId const array_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Array"sv))))));
ids::TypeId inner_type_id = types::unknown_type_id();
JaktInternal::Optional<utility::Span> inferred_type_span = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::TypeId> inner_hint = JaktInternal::OptionalNone();
JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const type_hint_ids = TRY((((*this).get_type_ids_from_type_hint_if_struct_ids_match(type_hint,array_struct_id))));
if (((type_hint_ids).has_value())){
(inner_hint = (((type_hint_ids.value()))[static_cast<i64>(0LL)]));
}
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> vals = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedExpression>>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedExpression> value = (_magic_value.value());
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
ids::TypeId const current_value_type_id = ((checked_expr)->type());
if (((current_value_type_id).equals(types::void_type_id()))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot create an array with values of type void\n"sv)),span))));
}
if (((inner_type_id).equals(types::unknown_type_id()))){
(inner_type_id = current_value_type_id);
(inferred_type_span = ((value)->span()));
}
else if ((!(((inner_type_id).equals(current_value_type_id))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type '{}' does not match type '{}' of previous values in array"sv)),TRY((((*this).type_name(current_value_type_id,false)))),TRY((((*this).type_name(inner_type_id,false))))))),((value)->span()),TRY((__jakt_format((StringView::from_string_literal("Array was inferred to store type '{}' here"sv)),TRY((((*this).type_name(inner_type_id,false))))))),(inferred_type_span.value())))));
}
TRY((((vals).push(checked_expr))));
}

}
}

if (((inner_type_id).equals(types::unknown_type_id()))){
if (((inner_hint).has_value())){
(inner_type_id = (inner_hint.value()));
}
else if ((((type_hint).has_value()) && (((type_hint.value())).equals(types::unknown_type_id())))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot infer generic type for Array<T>"sv)),span))));
}
}
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),array_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id})))))))))));
if (((type_hint).has_value())){
TRY((((*this).check_types_for_compat((type_hint.value()),type_id,((((*this).generic_inferences))),span))));
}
return TRY((types::CheckedExpression::JaktArray(JaktInternal::OptionalNone(),vals,repeat,span,type_id,inner_type_id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_entity_trait_implementations_predecl(ids::ScopeId const scope_id,ids::TypeId const type_id,JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const trait_implementations,ByteString const name,utility::Span const name_span) {
{
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> _magic = ((trait_implementations).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> trait_name__trait_ids_and_generic_params__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>> const jakt__trait_name__trait_ids_and_generic_params__ = trait_name__trait_ids_and_generic_params__;
ByteString const trait_name = ((jakt__trait_name__trait_ids_and_generic_params__).template get<0>());
JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const trait_ids_and_generic_params = ((jakt__trait_name__trait_ids_and_generic_params__).template get<1>());

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> _magic = ((trait_ids_and_generic_params).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> trait_id_and_generic_params = (_magic_value.value());
{
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_532([&] {
((((*this).generic_inferences)).restore(old_generic_inferences));
});
JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>> const trait_id_generic_params_ = trait_id_and_generic_params;
ids::TraitId const trait_id = ((trait_id_generic_params_).template get<0>());
JaktInternal::DynamicArray<ids::TypeId> const generic_params = ((trait_id_generic_params_).template get<1>());

NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(trait_id));
if (((((((trait_)->generic_parameters)).size())) != (((generic_params).size())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Trait ‘{}’ expects {} generic parameters, but {} were given"sv)),trait_name,((((trait_)->generic_parameters)).size()),((generic_params).size())))),((trait_)->name_span)))));
continue;
}
TRY((((*this).specialize_trait(trait_id,generic_params))));
if (((((trait_)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const methods = (((trait_)->requirements)).as.Methods.value;
TRY((((((*this).generic_inferences)).set_all(((trait_)->generic_parameters),generic_params))));
{
JaktInternal::DictionaryIterator<ByteString,ids::FunctionId> _magic = ((methods).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::FunctionId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::FunctionId> method_name__method_function_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::FunctionId> const jakt__method_name__method_function_id__ = method_name__method_function_id__;
ByteString const method_name = ((jakt__method_name__method_function_id__).template get<0>());
ids::FunctionId const method_function_id = ((jakt__method_name__method_function_id__).template get<1>());

NonnullRefPtr<types::CheckedFunction> const method = ((*this).get_function(method_function_id));
if (((!(((((method)->parsed_function)).has_value()))) || (((((((((method)->parsed_function).value())).block)).stmts)).is_empty()))){
continue;
}
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const f = TRY((((*this).find_functions_with_name_in_scope(scope_id,method_name,JaktInternal::OptionalNone()))));
if (((f).has_value())){
continue;
}
JaktInternal::Optional<ids::ScopeId> mixin_scope_id = JaktInternal::OptionalNone();
if ((!(((((trait_)->generic_parameters)).is_empty())))){
ids::ScopeId const id = TRY((((((*this).program))->create_scope(JaktInternal::OptionalNone(),false,TRY((__jakt_format((StringView::from_string_literal("trait({}).generic-mixin"sv)),((trait_)->name)))),((scope_id).module_id),false))));
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((trait_)->generic_parameters)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
types::CheckedGenericParameter const generic_param = ((((trait_)->generic_parameters))[i]);
ids::TypeId const generic_param_type = ((generic_params)[i]);
if (((((*this).get_type(((generic_param).type_id))))->__jakt_init_index() == 18 /* TypeVariable */)){
ByteString const name = (((*this).get_type(((generic_param).type_id))))->as.TypeVariable.name;
bool const is_value = (((*this).get_type(((generic_param).type_id))))->as.TypeVariable.is_value;
TRY((((*this).add_type_to_scope(id,name,generic_param_type,((generic_param).span)))));
if ((is_value && ((((*this).get_type(generic_param_type)))->__jakt_init_index() == 32 /* Const */))){
types::Value const value = (((*this).get_type(generic_param_type)))->as.Const.value;
TRY((((*this).add_comptime_binding_to_scope(id,name,value,((generic_param).span)))));
}
(mixin_scope_id = id);
}
else {
continue;
}

}

}
}

}
TRY((((*this).typecheck_function_predecl((((method)->parsed_function).value()),scope_id,type_id,JaktInternal::OptionalNone(),mixin_scope_id))));
}

}
}

}
else {
continue;
}

}

}
}

}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_trait_predecl(parser::ParsedTrait const parsed_trait,ids::ScopeId const scope_id) {
{
ids::ScopeId const trait_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((__jakt_format((StringView::from_string_literal("trait({})"sv)),((parsed_trait).name)))),false))));
TRY((((*this).add_type_to_scope(trait_scope_id,(ByteString::must_from_utf8("Self"sv)),TRY((((*this).find_or_add_type_id(TRY((types::Type::Self(parser::CheckedQualifiers(false)))))))),((parsed_trait).name_span)))));
NonnullRefPtr<types::CheckedTrait> checked_trait = TRY((types::CheckedTrait::__jakt_create(((parsed_trait).name),((parsed_trait).name_span),({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedTraitRequirements, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_trait).requirements);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Methods */: {
return JaktInternal::ExplicitValue(types::CheckedTraitRequirements::Methods((TRY((Dictionary<ByteString, ids::FunctionId>::create_with_entries({}))))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::CheckedTraitRequirements::Nothing());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}),(TRY((DynamicArray<types::CheckedGenericParameter>::create_with({})))),trait_scope_id)));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::TraitId const trait_id = ids::TraitId(((*this).current_module_id),((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->traits)).size()));
ids::TypeId const trait_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Trait(parser::CheckedQualifiers(false),trait_id)))))));
TRY((((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->traits)).push(checked_trait))));
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(trait_type_id))));
ScopeGuard __jakt_var_533([&] {
(((*this).self_type_id) = old_self_type_id);
});
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((*this).add_type_to_scope(scope_id,((parsed_trait).name),trait_type_id,((parsed_trait).name_span)))));
TRY((((*this).add_trait_to_scope(scope_id,((parsed_trait).name),trait_id,((parsed_trait).name_span)))));
NonnullRefPtr<types::Scope> trait_scope = TRY((((*this).get_scope(trait_scope_id))));
(((trait_scope)->relevant_type_id) = trait_type_id);
JaktInternal::DynamicArray<types::CheckedGenericParameter> generic_parameters = ((((((module)->traits))[((trait_id).id)]))->generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_trait).generic_parameters)).size())))));
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_trait).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
ids::TypeId const parameter_type_id = ids::TypeId(((*this).current_module_id),((((((*this).current_module()))->types)).size()));
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
types::CheckedGenericParameter parameter = TRY((types::CheckedGenericParameter::make(parameter_type_id,((gen_parameter).span))));
TRY((((((module)->types)).push(TRY((types::Type::TypeVariable(parser::CheckedQualifiers(false),((gen_parameter).name),trait_implementations,false)))))));
if (((((gen_parameter).requires_list)).has_value())){
TRY((((*this).fill_trait_requirements((((gen_parameter).requires_list).value()),((((parameter).constraints))),((trait_implementations)),scope_id))));
}
TRY((((generic_parameters).push(parameter))));
TRY((((*this).add_type_to_scope(trait_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

ids::StructId const synthetic_struct_id = ids::StructId(((*this).current_module_id),((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->structures)).size()));
TRY((((((module)->structures)).push(types::CheckedStruct(((parsed_trait).name),((parsed_trait).name_span),generic_parameters,JaktInternal::OptionalNone(),(TRY((DynamicArray<types::CheckedField>::create_with({})))),trait_scope_id,parser::DefinitionLinkage::External(),(TRY((Dictionary<ByteString, JaktInternal::DynamicArray<JaktInternal::Tuple<ids::TraitId,JaktInternal::DynamicArray<ids::TypeId>>>>::create_with_entries({})))),parser::RecordType::Struct((TRY((DynamicArray<parser::ParsedField>::create_with({})))),JaktInternal::OptionalNone()),trait_type_id,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())))));
ids::TypeId const struct_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Struct(parser::CheckedQualifiers(false),synthetic_struct_id)))))));
if (((((parsed_trait).requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::DynamicArray<parser::ParsedFunction> const methods = (((parsed_trait).requirements)).as.Methods.value;
if (((((checked_trait)->requirements)).__jakt_init_index() == 1 /* Methods */)){
JaktInternal::Dictionary<ByteString,ids::FunctionId> const checked_methods = (((checked_trait)->requirements)).as.Methods.value;
JaktInternal::Dictionary<ByteString,ids::FunctionId> mutable_checked_methods = checked_methods;
{
JaktInternal::ArrayIterator<parser::ParsedFunction> _magic = ((methods).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedFunction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction parsed_function = (_magic_value.value());
{
ids::ScopeId const method_scope_id = TRY((((*this).create_scope(trait_scope_id,((parsed_function).can_throw),TRY((__jakt_format((StringView::from_string_literal("trait-method({}::{})"sv)),((parsed_trait).name),((parsed_function).name)))),true))));
ids::FunctionId const function_id = ((((((*this).program))->get_module(((*this).current_module_id))))->next_function_id());
JaktInternal::Optional<ids::TypeId> this_arg_type_id = JaktInternal::OptionalNone();
if (((!(((((parsed_function).params)).is_empty()))) && (((((((((((parsed_function).params)).first()).value())).variable)).name)) == ((ByteString::must_from_utf8("this"sv)))))){
(this_arg_type_id = struct_type_id);
}
TRY((((*this).typecheck_function_predecl(parsed_function,trait_scope_id,this_arg_type_id,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
TRY((((mutable_checked_methods).set(((parsed_function).name),function_id))));
}

}
}

}
else {
abort();
}

}
else {
return {};
}

}
return {};
}

ErrorOr<bool> typechecker::Typechecker::implements_trait(ids::TypeId const type_id,ids::TraitId const trait_id,JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const generic_arguments) {
{
Function<ErrorOr<bool>(JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>, ids::TraitId, JaktInternal::DynamicArray<ids::TypeId>, typechecker::Typechecker&)> const has_matching_trait = [type_id](JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> trait_implementations, ids::TraitId trait_id, JaktInternal::DynamicArray<ids::TypeId> passed_generic_arguments, typechecker::Typechecker& typechecker) -> ErrorOr<bool> {
{
bool const old_ignore_errors = ((((typechecker))).ignore_errors);
(((((typechecker))).ignore_errors) = true);
ScopeGuard __jakt_var_534([&] {
{
(((((typechecker))).ignore_errors) = old_ignore_errors);
(((((typechecker))).had_an_error) = false);
}

});
bool found = false;
{
JaktInternal::ArrayIterator<JaktInternal::DynamicArray<ids::TypeId>> _magic = ((trait_implementations).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::DynamicArray<ids::TypeId> implemented_generic_arguments = (_magic_value.value());
{
if (((((implemented_generic_arguments).size())) != (((passed_generic_arguments).size())))){
continue;
}
bool ok = false;
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((implemented_generic_arguments).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
(ok = TRY((((((typechecker))).check_types_for_compat(((implemented_generic_arguments)[i]),((passed_generic_arguments)[i]),((((((typechecker))).generic_inferences))),utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)))))));
if ((!(ok))){
break;
}
}

}
}

if ((!(ok))){
continue;
}
(found = true);
break;
}

}
}

return found;
}
}
;
JaktInternal::DynamicArray<ids::TypeId> const empty = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
return TRY((has_matching_trait(TRY((((*this).find_all_implementations_of_trait(type_id,trait_id,JaktInternal::OptionalNone())))),trait_id,generic_arguments.value_or_lazy_evaluated([&] { return empty; }),((*this)))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_module_import(parser::ParsedModuleImport const import_,ids::ScopeId const scope_id) {
{
JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> const module_names_and_spans = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>, ErrorOr<void>>{
auto&& __jakt_match_variant = ((import_).module_name);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Literal */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Literal;ByteString const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>>((TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>::create_with({(Tuple{name, span})}))))));
};/*case end*/
case 1 /* Comptime */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Comptime;NonnullRefPtr<typename parser::ParsedExpression> const& expression = __jakt_match_value.expression;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>> __jakt_var_535; {
NonnullRefPtr<interpreter::Interpreter> interpreter = TRY((((*this).interpreter())));
NonnullRefPtr<interpreter::InterpreterScope> eval_scope = TRY((interpreter::InterpreterScope::from_runtime_scope(scope_id,((*this).program),JaktInternal::OptionalNone())));
ids::ScopeId const exec_scope = TRY((((*this).create_scope(scope_id,true,(ByteString::must_from_utf8("comptime-import"sv)),true))));
interpreter::StatementResult const result = TRY((((interpreter)->execute_expression(TRY((((*this).typecheck_expression(expression,exec_scope,types::SafetyMode::Safe(),JaktInternal::OptionalNone())))),eval_scope))));
__jakt_var_535 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>, ErrorOr<void>>{
auto&& __jakt_match_variant = result;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Return */: {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_536; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to an invalid value"sv)),((expression)->span())))));
__jakt_var_536 = JaktInternal::OptionalNone(); goto __jakt_label_458;

}
__jakt_label_458:; __jakt_var_536; }));
};/*case end*/
case 2 /* Yield */: {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_537; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to an invalid value"sv)),((expression)->span())))));
__jakt_var_537 = JaktInternal::OptionalNone(); goto __jakt_label_459;

}
__jakt_label_459:; __jakt_var_537; }));
};/*case end*/
case 3 /* Continue */: {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_538; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to an invalid value"sv)),((expression)->span())))));
__jakt_var_538 = JaktInternal::OptionalNone(); goto __jakt_label_460;

}
__jakt_label_460:; __jakt_var_538; }));
};/*case end*/
case 4 /* Break */: {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_539; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to an invalid value"sv)),((expression)->span())))));
__jakt_var_539 = JaktInternal::OptionalNone(); goto __jakt_label_461;

}
__jakt_label_461:; __jakt_var_539; }));
};/*case end*/
case 1 /* Throw */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Throw;types::Value const& error = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_540; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),TRY((__jakt_format((StringView::from_string_literal("this expression threw an error: {}"sv)),error))),((expression)->span())))));
__jakt_var_540 = JaktInternal::OptionalNone(); goto __jakt_label_462;

}
__jakt_label_462:; __jakt_var_540; }));
};/*case end*/
case 5 /* JustValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JustValue;types::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>, ErrorOr<void>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.__jakt_init_index()) {
case 13 /* JaktString */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktString;ByteString const& string = __jakt_match_value.value;
return JaktInternal::ExplicitValue(static_cast<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>>((TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>::create_with({(Tuple{string, ((value).span)})}))))));
};/*case end*/
case 20 /* JaktArray */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktArray;JaktInternal::DynamicArray<types::Value> const& values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>> __jakt_var_541; {
if (((values).is_empty())){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to an empty array"sv)),((expression)->span())))));
}
JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>> result = (TRY((DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>::create_with({}))));
{
JaktInternal::ArrayIterator<types::Value> _magic = ((values).iterator());
for (;;){
JaktInternal::Optional<types::Value> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::Value value = (_magic_value.value());
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.__jakt_init_index()) {
case 13 /* JaktString */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktString;ByteString const& string = __jakt_match_value.value;
return (TRY((((result).push((Tuple{string, ((value).span)})))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal or an array of strings"sv)),((value).span),(ByteString::must_from_utf8("this expression evaluates to an invalid value"sv)),((value).span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

__jakt_var_541 = static_cast<JaktInternal::Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>>>(result); goto __jakt_label_463;

}
__jakt_label_463:; __jakt_var_541.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<JaktInternal::DynamicArray<JaktInternal::Tuple<ByteString,utility::Span>>> __jakt_var_542; {
TRY((((*this).error_with_hint((ByteString::must_from_utf8("module name must evaluate to a string literal"sv)),((expression)->span()),(ByteString::must_from_utf8("this expression evaluates to a non-string value"sv)),((expression)->span())))));
__jakt_var_542 = JaktInternal::OptionalNone(); goto __jakt_label_464;

}
__jakt_label_464:; __jakt_var_542; }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_457;

}
__jakt_label_457:; __jakt_var_535.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if ((!(((module_names_and_spans).has_value())))){
return {};
}
size_t const parent_path_count = ((import_).parent_path_count);
bool const import_is_relative = ((import_).relative_path);
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> module_name_and_span = JaktInternal::OptionalNone();
JaktInternal::DynamicArray<ByteString> names = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<JaktInternal::Tuple<ByteString,utility::Span>> _magic = (((module_names_and_spans.value())).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,utility::Span>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,utility::Span> name_and_span = (_magic_value.value());
{
TRY((((names).push(((name_and_span).template get<0>())))));
JaktInternal::Optional<types::LoadedModule> maybe_loaded_module = ((((*this).program))->get_loaded_module(((name_and_span).template get<0>())));
if ((!(((maybe_loaded_module).has_value())))){
JaktInternal::Optional<jakt__path::Path> const maybe_file_name = TRY((((((*this).compiler))->search_for_path(((name_and_span).template get<0>()),import_is_relative,parent_path_count))));
jakt__path::Path const file_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<jakt__path::Path,ErrorOr<void>>{
auto __jakt_enum_value = (((maybe_file_name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((maybe_file_name.value()));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(TRY((((TRY((((TRY((((TRY((((*this).get_root_path())))).parent())))).join(((name_and_span).template get<0>())))))).replace_extension((ByteString::must_from_utf8("jakt"sv)))))));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
if (File::exists(((file_name).to_string()))){
(module_name_and_span = name_and_span);
break;
}
}
else {
(module_name_and_span = name_and_span);
break;
}

}

}
}

if ((!(((module_name_and_span).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("No module in module set {{{}}} was found"sv)),TRY((utility::join(names,(ByteString::must_from_utf8(", "sv)))))))),((((import_).module_name)).span())))));
return {};
}
JaktInternal::Tuple<ByteString,utility::Span> const module_name_module_span_ = (module_name_and_span.value());
ByteString const module_name = ((module_name_module_span_).template get<0>());
utility::Span const module_span = ((module_name_module_span_).template get<1>());

ByteString const sanitized_module_name = ((module_name).replace((ByteString::must_from_utf8(":"sv)),(ByteString::must_from_utf8("_"sv))));
ids::ModuleId imported_module_id = ids::ModuleId(static_cast<size_t>(0ULL));
JaktInternal::Optional<types::LoadedModule> maybe_loaded_module = ((((*this).program))->get_loaded_module(sanitized_module_name));
if ((!(((maybe_loaded_module).has_value())))){
JaktInternal::Optional<jakt__path::Path> const maybe_file_name = TRY((((((*this).compiler))->search_for_path(module_name,import_is_relative,parent_path_count))));
jakt__path::Path const file_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<jakt__path::Path,ErrorOr<void>>{
auto __jakt_enum_value = (((maybe_file_name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((maybe_file_name.value()));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(TRY((((TRY((((TRY((((TRY((((*this).get_root_path())))).parent())))).join(module_name))))).replace_extension((ByteString::must_from_utf8("jakt"sv)))))));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
utility::FileId const file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
JaktInternal::Optional<parser::ParsedNamespace> const parsed_namespace = TRY((((*this).lex_and_parse_file_contents(file_id))));
if ((!(((parsed_namespace).has_value())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Module '{}' not found"sv)),module_name))),module_span))));
return {};
}
ids::ModuleId const original_current_module_id = ((*this).current_module_id);
(imported_module_id = TRY((((*this).create_module(sanitized_module_name,false,((file_name).to_string()))))));
TRY((((((*this).program))->set_loaded_module(sanitized_module_name,types::LoadedModule(imported_module_id,file_id)))));
(((*this).current_module_id) = imported_module_id);
ids::ScopeId const imported_scope_id = TRY((((*this).create_scope(((*this).root_scope_id()),false,TRY((__jakt_format((StringView::from_string_literal("module({})"sv)),sanitized_module_name))),false))));
NonnullRefPtr<types::Scope> imported_scope = TRY((((*this).get_scope(imported_scope_id))));
(((imported_scope)->namespace_name) = sanitized_module_name);
(((imported_scope)->is_from_generated_code) = (((parsed_namespace.value())).is_generated_code));
TRY((((*this).typecheck_module((parsed_namespace.value()),imported_scope_id))));
(((*this).current_module_id) = original_current_module_id);
}
else {
(imported_module_id = (((maybe_loaded_module.value())).module_id));
}

JaktInternal::DynamicArray<ids::ModuleId> current_module_imports = ((((*this).current_module()))->imports);
TRY((((current_module_imports).push(imported_module_id))));
if (((((import_).import_list)).is_empty())){
JaktInternal::Dictionary<ByteString,ids::ModuleId> scope_imports = ((TRY((((*this).get_scope(scope_id)))))->imports);
ByteString import_name = module_name;
if (((((import_).alias_name)).has_value())){
(import_name = TRY(((((((import_).alias_name).value())).literal_name()))));
}
TRY((((scope_imports).set(import_name,imported_module_id))));
}
else if (((((import_).import_list)).__jakt_init_index() == 1 /* All */)){
NonnullRefPtr<types::Scope> const import_scope = TRY((((*this).get_scope(ids::ScopeId(imported_module_id,static_cast<size_t>(0ULL))))));
{
JaktInternal::DictionaryIterator<ByteString,ids::VarId> _magic = ((((import_scope)->vars)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::VarId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::VarId> name__var_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::VarId> const jakt__name__var_id__ = name__var_id__;
ByteString const name = ((jakt__name__var_id__).template get<0>());
ids::VarId const var_id = ((jakt__name__var_id__).template get<1>());

TRY((((*this).add_var_to_scope(scope_id,name,var_id,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,types::Value> _magic = ((((import_scope)->comptime_bindings)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,types::Value>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,types::Value> name__value__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,types::Value> const jakt__name__value__ = name__value__;
ByteString const name = ((jakt__name__value__).template get<0>());
types::Value const value = ((jakt__name__value__).template get<1>());

TRY((((*this).add_comptime_binding_to_scope(scope_id,name,value,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::StructId> _magic = ((((import_scope)->structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::StructId> name__struct_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::StructId> const jakt__name__struct_id__ = name__struct_id__;
ByteString const name = ((jakt__name__struct_id__).template get<0>());
ids::StructId const struct_id = ((jakt__name__struct_id__).template get<1>());

TRY((((*this).add_struct_to_scope(scope_id,name,struct_id,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> _magic = ((((import_scope)->functions)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> name__overload_set__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::DynamicArray<ids::FunctionId>> const jakt__name__overload_set__ = name__overload_set__;
ByteString const name = ((jakt__name__overload_set__).template get<0>());
JaktInternal::DynamicArray<ids::FunctionId> const overload_set = ((jakt__name__overload_set__).template get<1>());

TRY((((*this).add_function_to_scope(scope_id,name,overload_set,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::EnumId> _magic = ((((import_scope)->enums)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::EnumId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::EnumId> name__enum_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::EnumId> const jakt__name__enum_id__ = name__enum_id__;
ByteString const name = ((jakt__name__enum_id__).template get<0>());
ids::EnumId const enum_id = ((jakt__name__enum_id__).template get<1>());

TRY((((*this).add_enum_to_scope(scope_id,name,enum_id,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::TypeId> _magic = ((((import_scope)->types)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::TypeId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::TypeId> name__type_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::TypeId> const jakt__name__type_id__ = name__type_id__;
ByteString const name = ((jakt__name__type_id__).template get<0>());
ids::TypeId const type_id = ((jakt__name__type_id__).template get<1>());

TRY((((*this).add_type_to_scope(scope_id,name,type_id,((((import_).module_name)).span())))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::TraitId> _magic = ((((import_scope)->traits)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::TraitId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::TraitId> name__trait_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::TraitId> const jakt__name__trait_id__ = name__trait_id__;
ByteString const name = ((jakt__name__trait_id__).template get<0>());
ids::TraitId const trait_id = ((jakt__name__trait_id__).template get<1>());

TRY((((*this).add_trait_to_scope(scope_id,name,trait_id,((((import_).module_name)).span())))));
}

}
}

}
else if (((((import_).import_list)).__jakt_init_index() == 0 /* List */)){
JaktInternal::DynamicArray<parser::ImportName> const names = (((import_).import_list)).as.List.value;
ids::ScopeId const import_scope_id = ids::ScopeId(imported_module_id,static_cast<size_t>(0ULL));
{
JaktInternal::ArrayIterator<parser::ImportName> _magic = ((names).iterator());
for (;;){
JaktInternal::Optional<parser::ImportName> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ImportName imported_name = (_magic_value.value());
{
bool const found = TRY((((*this).find_and_import_name_from_scope(TRY((((imported_name).literal_name()))),((imported_name).span()),TRY((((imported_name).literal_name()))),((imported_name).span()),import_scope_id,scope_id,typechecker::ImportRestrictions::all()))));
if ((!(found))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Imported name '{}' not found in module '{}'"sv)),TRY((((imported_name).literal_name()))),module_name))),((imported_name).span())))));
}
}

}
}

}
}
return {};
}

ErrorOr<JaktInternal::Optional<ids::FunctionId>> typechecker::Typechecker::typecheck_method(parser::ParsedFunction const func,types::StructLikeId const parent_id) {
{
JaktInternal::DynamicArray<types::CheckedGenericParameter> parent_generic_parameters = (TRY((DynamicArray<types::CheckedGenericParameter>::create_with({}))));
ids::ScopeId parent_scope_id = ((*this).prelude_scope_id());
parser::DefinitionLinkage parent_definition_linkage = parser::DefinitionLinkage::Internal();
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<JaktInternal::Optional<ids::FunctionId>>>{
auto&& __jakt_match_variant = parent_id;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
types::CheckedStruct structure = ((*this).get_struct(struct_id));
(parent_scope_id = ((structure).scope_id));
(parent_definition_linkage = ((structure).definition_linkage));
(parent_generic_parameters = ((structure).generic_parameters));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
(parent_scope_id = ((enum_).scope_id));
(parent_definition_linkage = ((enum_).definition_linkage));
(parent_generic_parameters = ((enum_).generic_parameters));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* Trait */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Trait;ids::TraitId const& trait_id = __jakt_match_value.value;
{
NonnullRefPtr<types::CheckedTrait> const trait_ = ((*this).get_trait(trait_id));
(parent_scope_id = ((trait_)->scope_id));
(parent_definition_linkage = parser::DefinitionLinkage::Internal());
(parent_generic_parameters = ((trait_)->generic_parameters));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
if (((!(((((func).generic_parameters)).is_empty()))) && (!(((func).must_instantiate))))){
return JaktInternal::OptionalNone();
}
JaktInternal::Optional<ids::FunctionId> const method_id = TRY((((*this).find_function_matching_signature_in_scope(parent_scope_id,func))));
if (((method_id).has_value())){
TRY((((*this).typecheck_function(func,parent_scope_id))));
return (method_id.value());
}
else {
TRY((((((*this).compiler))->panic(TRY((__jakt_format((StringView::from_string_literal("Previously defined function {} not found in scope {}"sv)),((func).name),parent_scope_id)))))));
}

}
}

ErrorOr<void> typechecker::Typechecker::typecheck_extern_import(parser::ParsedExternImport const import_,ids::ScopeId const scope_id) {
{
{
JaktInternal::ArrayIterator<parser::ParsedFunction> _magic = ((((((import_).assigned_namespace)).functions)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedFunction> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction f = (_magic_value.value());
{
if ((!(((((f).linkage)).__jakt_init_index() == 1 /* External */)))){
TRY((((*this).error((ByteString::must_from_utf8("Expected all functions in an `import extern` to be be external"sv)),((f).name_span)))));
}
if ((((import_).is_c) && (!(((((f).generic_parameters)).is_empty()))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("imported function '{}' is declared to have C linkage, but is generic"sv)),((f).name)))),((f).name_span),(ByteString::must_from_utf8("this function may not be generic"sv)),((f).name_span)))));
}
if ((!(((((((f).block)).stmts)).is_empty())))){
TRY((((*this).error((ByteString::must_from_utf8("imported extern function is not allowed to have a body"sv)),((f).name_span)))));
}
}

}
}

{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((((import_).assigned_namespace)).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
if ((!(((((record).definition_linkage)).__jakt_init_index() == 1 /* External */)))){
TRY((((*this).error((ByteString::must_from_utf8("Expected all records in an `import extern` to be external"sv)),((record).name_span)))));
}
if ((((import_).is_c) && (!(((((record).generic_parameters)).is_empty()))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("imported {} '{}' is declared to have C linkage, but is generic"sv)),TRY((((((record).record_type)).record_type_name()))),((record).name)))),((record).name_span),TRY((__jakt_format((StringView::from_string_literal("this {} may not be generic"sv)),TRY((((((record).record_type)).record_type_name())))))),((record).name_span)))));
}
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_override(parser::ParsedMethod const method,ids::ScopeId const parent_scope_id,JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedFunction>>> const all_virtuals) {
{
if (((method).is_override)){
JaktInternal::Optional<JaktInternal::DynamicArray<NonnullRefPtr<types::CheckedFunction>>> overrides = ((all_virtuals).get(((((method).parsed_function)).name)));
if (((overrides).has_value())){
JaktInternal::Optional<NonnullRefPtr<types::CheckedFunction>> const override_target = (((overrides.value())).pop());
if (((override_target).has_value())){
JaktInternal::Optional<ids::FunctionId> const method_id = TRY((((*this).find_function_matching_signature_in_scope(parent_scope_id,((method).parsed_function)))));
NonnullRefPtr<types::CheckedFunction> const method_function = ((*this).get_function((method_id.value())));
if ((!(((((method_function)->return_type_id)).equals((((override_target.value()))->return_type_id)))))){
TRY((((*this).error((ByteString::must_from_utf8("Override function return type does not match virtual function"sv)),((method_function)->return_type_span).value_or_lazy_evaluated([&] { return ((method_function)->name_span); })))));
}
if (((((method_function)->can_throw)) != ((((override_target.value()))->can_throw)))){
TRY((((*this).error((ByteString::must_from_utf8("Override function throwability does not match virtual function"sv)),((method_function)->name_span)))));
}
if (((((((method_function)->params)).size())) != ((((((override_target.value()))->params)).size())))){
TRY((((*this).error((ByteString::must_from_utf8("Override function parameters do not match virtual function"sv)),((method_function)->name_span)))));
return {};
}
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((method_function)->params)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t param_index = (_magic_value.value());
{
types::CheckedParameter const method_param = ((((method_function)->params))[param_index]);
types::CheckedParameter const virtual_param = (((((override_target.value()))->params))[param_index]);
if (((((((virtual_param).variable))->is_mutable)) != (((((method_param).variable))->is_mutable)))){
TRY((((*this).error((ByteString::must_from_utf8("Override function parameter mutability does not match virtual function"sv)),((((method_param).variable))->definition_span)))));
}
if ((((param_index) == (static_cast<size_t>(0ULL))) && ((((((method_param).variable))->name)) == ((ByteString::must_from_utf8("this"sv)))))){
continue;
}
if ((!(((((((method_param).variable))->type_id)).equals(((((virtual_param).variable))->type_id)))))){
TRY((((*this).error((ByteString::must_from_utf8("Override function parameter type does not match virtual function"sv)),((((method_param).variable))->type_span).value_or_lazy_evaluated([&] { return ((((method_param).variable))->definition_span); })))));
}
}

}
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Missing virtual for override"sv)),((((method).parsed_function)).name_span)))));
return {};
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Missing virtual for override"sv)),((((method).parsed_function)).name_span)))));
return {};
}

}
else {
if (((all_virtuals).contains(((((method).parsed_function)).name)))){
TRY((((*this).error((ByteString::must_from_utf8("Missing override keyword on function that is virtual"sv)),((((method).parsed_function)).name_span)))));
}
return {};
}

}
return {};
}

ErrorOr<types::BlockControlFlow> typechecker::Typechecker::statement_control_flow(NonnullRefPtr<typename types::CheckedStatement> const statement) const {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.__jakt_init_index()) {
case 8 /* Return */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 11 /* Throw */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 9 /* Break */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysTransfersControl(true));
};/*case end*/
case 10 /* Continue */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysTransfersControl(false));
};/*case end*/
case 12 /* Yield */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Yield;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((TRY((((expr)->control_flow())))).updated(types::BlockControlFlow::AlwaysTransfersControl(false))));
};/*case end*/
case 4 /* If */: {
auto&& __jakt_match_value = __jakt_match_variant.as.If;NonnullRefPtr<typename types::CheckedExpression> const& condition = __jakt_match_value.condition;
types::CheckedBlock const& then_block = __jakt_match_value.then_block;
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Boolean */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Boolean;bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((then_block).control_flow));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((((*this).statement_control_flow((else_statement.value()))))));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(((((then_block).control_flow)).branch_unify_with(TRY((((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))))))));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 5 /* Block */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Block;types::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 7 /* While */: {
auto&& __jakt_match_value = __jakt_match_variant.as.While;NonnullRefPtr<typename types::CheckedExpression> const& condition = __jakt_match_value.condition;
types::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Boolean */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Boolean;bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* AlwaysReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 2 /* NeverReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::NeverReturns());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
else {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 6 /* Loop */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Loop;types::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* AlwaysTransfersControl */: {
auto&& __jakt_match_value = __jakt_match_variant.as.AlwaysTransfersControl;bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (might_break);
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysTransfersControl(might_break));
}
else if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 2 /* NeverReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::NeverReturns());
};/*case end*/
case 0 /* AlwaysReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 3 /* MayReturn */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow,ErrorOr<types::BlockControlFlow>>{
auto __jakt_enum_value = (((((block).control_flow)).may_break()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::BlockControlFlow, ErrorOr<types::BlockControlFlow>>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.__jakt_init_index()) {
case 4 /* PartialAlwaysReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 6 /* PartialNeverReturns */: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::NeverReturns());
};/*case end*/
case 5 /* PartialAlwaysTransfersControl */: {
auto&& __jakt_match_value = __jakt_match_variant.as.PartialAlwaysTransfersControl;bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(types::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 0 /* Expression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Expression;NonnullRefPtr<typename types::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((expr)->control_flow()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(types::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<JaktInternal::Optional<ids::StructId>> typechecker::Typechecker::find_struct_in_scope(ids::ScopeId const scope_id,ByteString const name,JaktInternal::Optional<ids::ScopeId> const root_scope) const {
{
return TRY((((((*this).program))->find_struct_in_scope(scope_id,name,false,root_scope))));
}
}

ErrorOr<void> typechecker::Typechecker::check_that_type_doesnt_contain_reference(ids::TypeId const type_id,utility::Span const span) {
{
if (TRY((((*this).type_contains_reference(type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Reference type ‘{}’ not usable in this context"sv)),TRY((((*this).type_name(type_id,false))))))),span))));
}
}
return {};
}

ErrorOr<JaktInternal::Optional<parser::ParsedNamespace>> typechecker::Typechecker::lex_and_parse_file_contents(utility::FileId const file_id) {
{
JaktInternal::Tuple<JaktInternal::Optional<utility::FileId>,JaktInternal::DynamicArray<u8>> const old_file_state = ((((*this).compiler))->current_file_state());
if ((!(TRY((((((*this).compiler))->set_current_file(file_id))))))){
return JaktInternal::OptionalNone();
}
ScopeGuard __jakt_var_543([&] {
((((*this).compiler))->restore_file_state(old_file_state));
});
JaktInternal::DynamicArray<lexer::Token> const tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
JaktInternal::ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
JaktInternal::Optional<lexer::Token> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln((StringView::from_string_literal("token: {}"sv)),token);
}

}
}

}
parser::ParsedNamespace const parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln((StringView::from_string_literal("{:#}"sv)),parsed_namespace);
}
return parsed_namespace;
}
}

ErrorOr<bool> typechecker::Typechecker::find_and_import_name_from_scope(ByteString const from_name,utility::Span const from_span,ByteString const to_name,utility::Span const to_span,ids::ScopeId const from_scope_id,ids::ScopeId const into_scope_id,typechecker::ImportRestrictions const allow) {
{
bool found = false;
if (((allow).functions)){
JaktInternal::Optional<JaktInternal::DynamicArray<ids::FunctionId>> const maybe_overload_set = TRY((((*this).find_functions_with_name_in_scope(from_scope_id,from_name,JaktInternal::OptionalNone()))));
if (((maybe_overload_set).has_value())){
(found = true);
TRY((((*this).add_function_to_scope(into_scope_id,to_name,(maybe_overload_set.value()),to_span))));
}
}
if (((allow).enums)){
JaktInternal::Optional<ids::EnumId> const maybe_enum_id = TRY((((((*this).program))->find_enum_in_scope(from_scope_id,from_name,false,JaktInternal::OptionalNone()))));
if (((maybe_enum_id).has_value())){
(found = true);
TRY((((*this).add_enum_to_scope(into_scope_id,to_name,(maybe_enum_id.value()),to_span))));
}
}
if (((allow).types)){
JaktInternal::Optional<ids::TypeId> const maybe_type_id = TRY((((*this).find_type_in_scope(from_scope_id,from_name))));
if (((maybe_type_id).has_value())){
(found = true);
TRY((((*this).add_type_to_scope(into_scope_id,to_name,(maybe_type_id.value()),to_span))));
}
}
if (((allow).structs)){
JaktInternal::Optional<ids::StructId> const maybe_struct_id = TRY((((*this).find_struct_in_scope(from_scope_id,from_name,JaktInternal::OptionalNone()))));
if (((maybe_struct_id).has_value())){
(found = true);
TRY((((*this).add_struct_to_scope(into_scope_id,to_name,(maybe_struct_id.value()),to_span))));
}
}
if (((allow).traits)){
JaktInternal::Optional<ids::TraitId> const maybe_trait_id = TRY((((*this).find_trait_in_scope(from_scope_id,from_name))));
if (((maybe_trait_id).has_value())){
(found = true);
TRY((((*this).add_trait_to_scope(into_scope_id,to_name,(maybe_trait_id.value()),to_span))));
}
}
if (((allow).namespaces)){
JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>> const maybe_scope_id = TRY((((*this).find_namespace_in_scope(from_scope_id,from_name,false,JaktInternal::OptionalNone()))));
if (((maybe_scope_id).has_value())){
(found = true);
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(into_scope_id))));
TRY((((((scope)->aliases)).set(to_name,(((maybe_scope_id.value())).template get<0>())))));
}
}
return found;
}
}

parser::CheckedQualifiers typechecker::Typechecker::typecheck_type_qualifiers(JaktInternal::Optional<parser::ParsedTypeQualifiers> const qualifiers) const {
{
if (((qualifiers).has_value())){
parser::ParsedTypeQualifiers const q = (qualifiers.value());
return parser::CheckedQualifiers(((q).is_immutable));
}
else {
return parser::CheckedQualifiers(false);
}

}
}

ErrorOr<bool> typechecker::Typechecker::validate_argument_label(types::CheckedParameter const param,ByteString const label,utility::Span const span,NonnullRefPtr<typename parser::ParsedExpression> const expr,JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const default_value) {
{
ByteString const name = TRY((((*this).get_argument_name((Tuple{label, span, expr})))));
if (((name) == (((((param).variable))->name)))){
return true;
}
if ((!(((default_value).has_value())))){
if (((label).is_empty())){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Missing argument label (expected '{}:')"sv)),((((param).variable))->name)))),((expr)->span())))));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Wrong parameter name in argument label (got '{}', expected '{}')"sv)),label,((((param).variable))->name)))),span))));
}

}
return false;
}
}

ErrorOr<bool> typechecker::Typechecker::add_enum_to_scope(ids::ScopeId const scope_id,ByteString const name,ids::EnumId const enum_id,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
JaktInternal::Optional<ids::EnumId> const maybe_enum_id = ((((scope)->enums)).get(name));
if (((maybe_enum_id).has_value())){
if (((TRY((((*this).get_scope(scope_id)))))->is_from_generated_code)){
return false;
}
ids::EnumId const existing_enum_id = (maybe_enum_id.value());
utility::Span const definition_span = ((((*this).get_enum(existing_enum_id))).name_span);
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("redefinition of enum {}"sv)),name))),span,TRY((__jakt_format((StringView::from_string_literal("enum {} was first defined here"sv)),name))),definition_span))));
return false;
}
TRY((((((scope)->enums)).set(name,enum_id))));
return true;
}
}

ErrorOr<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>>> typechecker::Typechecker::expand_context_for_bindings(NonnullRefPtr<typename parser::ParsedExpression> const condition,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const acc,JaktInternal::Optional<parser::ParsedBlock> const then_block,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const else_statement,ids::ScopeId const scope_id,utility::Span const span) {
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>>>>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.__jakt_init_index()) {
case 12 /* BinaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.BinaryOp;NonnullRefPtr<typename parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typename parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
{
if (((op).__jakt_init_index() == 18 /* LogicalAnd */)){
JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,JaktInternal::Optional<parser::ParsedBlock>,JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>>> const rhs_condition_rhs_then_block_rhs_else_statement_ = TRY((((*this).expand_context_for_bindings(rhs,acc,then_block,else_statement,scope_id,span))));
NonnullRefPtr<typename parser::ParsedExpression> const rhs_condition = ((rhs_condition_rhs_then_block_rhs_else_statement_).template get<0>());
JaktInternal::Optional<parser::ParsedBlock> const rhs_then_block = ((rhs_condition_rhs_then_block_rhs_else_statement_).template get<1>());
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const rhs_else_statement = ((rhs_condition_rhs_then_block_rhs_else_statement_).template get<2>());

NonnullRefPtr<typename parser::ParsedExpression> accumulated_condition = rhs_condition;
return TRY((((*this).expand_context_for_bindings(lhs,accumulated_condition,rhs_then_block,rhs_else_statement,scope_id,span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11 /* UnaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnaryOp;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
if (((op).__jakt_init_index() == 13 /* IsEnumVariant */)){
NonnullRefPtr<typename parser::ParsedType> const inner = (op).as.IsEnumVariant.inner;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const bindings = (op).as.IsEnumVariant.bindings;
NonnullRefPtr<typename parser::ParsedExpression> const unary_op_single_condition = TRY((parser::ParsedExpression::UnaryOp(expr,parser::UnaryOperator::Is(inner),span)));
JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedStatement>> outer_if_stmts = (TRY((DynamicArray<NonnullRefPtr<typename parser::ParsedStatement>>::create_with({}))));
bool const ignore_errors_state = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
NonnullRefPtr<typename types::CheckedExpression> const pre_checked_unary_op = TRY((((*this).typecheck_expression(unary_op_single_condition,scope_id,types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = ignore_errors_state);
{
JaktInternal::ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
JaktInternal::Optional<parser::EnumVariantPatternArgument> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
parser::ParsedVarDecl const var = parser::ParsedVarDecl(((binding).binding),TRY((parser::ParsedType::Empty(JaktInternal::OptionalNone()))),false,JaktInternal::OptionalNone(),((binding).span),JaktInternal::OptionalNone());
if (((pre_checked_unary_op)->__jakt_init_index() == 6 /* UnaryOp */)){
types::CheckedUnaryOperator const op = (pre_checked_unary_op)->as.UnaryOp.op;
if (((op).__jakt_init_index() == 14 /* IsSome */)){
NonnullRefPtr<typename parser::ParsedExpression> const init = TRY((parser::ParsedExpression::ForcedUnwrap(expr,span)));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::VarDecl(var,init,span)))))));
}
else {
NonnullRefPtr<typename parser::ParsedExpression> const enum_variant_arg = TRY((parser::ParsedExpression::EnumVariantArg(expr,binding,inner,span)));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::VarDecl(var,enum_variant_arg,span)))))));
}

}
else {
NonnullRefPtr<typename parser::ParsedExpression> const enum_variant_arg = TRY((parser::ParsedExpression::EnumVariantArg(expr,binding,inner,span)));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::VarDecl(var,enum_variant_arg,span)))))));
}

}

}
}

NonnullRefPtr<typename parser::ParsedExpression> inner_condition = condition;
if (((then_block).has_value())){
if (((acc).has_value())){
(inner_condition = (acc.value()));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::If(inner_condition,(then_block.value()),else_statement,span)))))));
}
else {
TRY((((outer_if_stmts).push_values((((((then_block.value())).stmts)))))));
}

}
parser::ParsedBlock const new_then_block = parser::ParsedBlock(outer_if_stmts);
return TRY((((*this).expand_context_for_bindings(unary_op_single_condition,JaktInternal::OptionalNone(),new_then_block,else_statement,scope_id,span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
NonnullRefPtr<typename parser::ParsedExpression> base_condition = condition;
if (((acc).has_value())){
(base_condition = TRY((parser::ParsedExpression::BinaryOp(condition,parser::BinaryOperator::LogicalAnd(),(acc.value()),span))));
}
return (Tuple{base_condition, then_block, else_statement});
}
}

ErrorOr<JaktInternal::Optional<ids::TraitId>> typechecker::Typechecker::find_trait_in_scope(ids::ScopeId const scope_id,ByteString const name) const {
{
return TRY((((((*this).program))->find_trait_in_scope(scope_id,name,false,JaktInternal::OptionalNone()))));
}
}

NonnullRefPtr<types::Module> typechecker::Typechecker::current_module() const {
{
return ((((*this).program))->get_module(((*this).current_module_id)));
}
}

ids::ScopeId typechecker::Typechecker::root_scope_id() const {
{
return ids::ScopeId(ids::ModuleId(static_cast<size_t>(1ULL)),static_cast<size_t>(0ULL));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_defer(NonnullRefPtr<typename parser::ParsedStatement> const statement,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
bool const was_inside_defer = ((*this).inside_defer);
(((*this).inside_defer) = true);
ScopeGuard __jakt_var_544([&] {
(((*this).inside_defer) = was_inside_defer);
});
NonnullRefPtr<typename types::CheckedStatement> const checked_statement = TRY((((*this).typecheck_statement(statement,scope_id,safety_mode,JaktInternal::OptionalNone()))));
if (((checked_statement)->__jakt_init_index() == 5 /* Block */)){
types::CheckedBlock const block = (checked_statement)->as.Block.block;
if (((((block).yielded_type)).has_value())){
TRY((((*this).error((ByteString::must_from_utf8("‘yield’ inside ‘defer’ is meaningless"sv)),span))));
}
}
return TRY((types::CheckedStatement::Defer(checked_statement,span)));
}
}

ErrorOr<bool> typechecker::Typechecker::add_function_to_scope(ids::ScopeId const parent_scope_id,ByteString const name,JaktInternal::DynamicArray<ids::FunctionId> const overload_set,utility::Span const span) {
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(parent_scope_id))));
if (((((scope)->functions)).contains(name))){
JaktInternal::DynamicArray<ids::FunctionId> const existing_function_binding = ((((scope)->functions))[name]);
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((overload_set).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId function_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const function_to_add = ((*this).get_function(function_id));
{
JaktInternal::ArrayIterator<ids::FunctionId> _magic = ((existing_function_binding).iterator());
for (;;){
JaktInternal::Optional<ids::FunctionId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::FunctionId existing_function_id = (_magic_value.value());
{
NonnullRefPtr<types::CheckedFunction> const existing_function = ((*this).get_function(existing_function_id));
if (TRY((((function_to_add)->signature_matches(existing_function,false))))){
if (((TRY((((*this).get_scope(parent_scope_id)))))->is_from_generated_code)){
continue;
}
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Redefinition of function ‘{}’."sv)),((function_to_add)->name)))),(((((function_to_add)->parsed_function).value())).name_span),(ByteString::must_from_utf8("Previous definition is here"sv)),(((((existing_function)->parsed_function).value())).name_span)))));
}
}

}
}

TRY((((((((scope)->functions))[name])).push(function_id))));
}

}
}

}
else {
TRY((((((scope)->functions)).set(name,overload_set))));
}

TRY((((((*this).program))->set_owner_scope_if_needed(parent_scope_id,overload_set,span))));
return true;
}
}

ErrorOr<void> typechecker::Typechecker::check_method_access(ids::ScopeId const accessor,ids::ScopeId const accessee,NonnullRefPtr<types::CheckedFunction> const method,utility::Span const span) {
{
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((method)->visibility);
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Private */: {
{
if ((!(TRY((((*this).scope_can_access(accessor,accessee))))))){
if ((!(((((method)->type)).__jakt_init_index() == 0 /* Normal */)))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Can't access constructor ‘{}’, because it is marked private"sv)),((method)->name)))),span,(ByteString::must_from_utf8("Private constructors are created if any fields are private"sv)),span))));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Can't access method ‘{}’, because it is marked private"sv)),((method)->name)))),span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2 /* Restricted */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Restricted;JaktInternal::DynamicArray<NonnullRefPtr<typename types::MaybeResolvedScope>> const& scopes = __jakt_match_value.scopes;
{
TRY((((*this).check_restricted_access(accessor,(ByteString::must_from_utf8("function"sv)),accessee,((method)->name),scopes,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return {};
}

ErrorOr<ids::TypeId> typechecker::Typechecker::final_type_resolution_form(ids::TypeId const type_id,ids::ScopeId const scope_id) const {
{
ids::TypeId const mapped_type_id = TRY((((*this).resolve_type_var(type_id,scope_id))));
if ((((((*this).get_type(mapped_type_id)))->__jakt_init_index() == 31 /* Self */) && ((((*this).self_type_id)).has_value()))){
return (((*this).self_type_id).value());
}
return mapped_type_id;
}
}

ErrorOr<JaktInternal::Optional<JaktInternal::Tuple<JaktInternal::DynamicArray<ids::FunctionId>,ids::ScopeId>>> typechecker::Typechecker::find_scoped_functions_with_name_in_scope(ids::ScopeId const parent_scope_id,ByteString const function_name,JaktInternal::Optional<ids::ScopeId> const root_scope_id) const {
{
return TRY((((((*this).program))->find_scoped_functions_with_name_in_scope(parent_scope_id,function_name,false,JaktInternal::OptionalNone()))));
}
}

ErrorOr<NonnullRefPtr<interpreter::Interpreter>> typechecker::Typechecker::interpreter() {
{
return TRY((interpreter::Interpreter::create(((*this).compiler),((*this).program),TRY((types::TypecheckFunctions::__jakt_create([this](parser::ParsedBlock parsed_block, ids::ScopeId parent_scope_id, types::SafetyMode safety_mode, JaktInternal::Optional<ids::TypeId> yield_type_hint, JaktInternal::Optional<ids::FunctionId> containing_function_id) -> ErrorOr<types::CheckedBlock> {
{
JaktInternal::Optional<ids::FunctionId> const previous_function_id = ((*this).current_function_id);
(((*this).current_function_id) = containing_function_id);
ScopeGuard __jakt_var_545([&] {
{
(((*this).current_function_id) = previous_function_id);
}

});
return TRY((((*this).typecheck_block(parsed_block,parent_scope_id,safety_mode,yield_type_hint))));
}
}
,[this](NonnullRefPtr<types::CheckedFunction> function) -> ErrorOr<ids::FunctionId> {
{
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::FunctionId const id = ((module)->next_function_id());
TRY((((((module)->functions)).push(function))));
return id;
}
}
))),(TRY((DynamicArray<utility::Span>::create_with({})))))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_methods_predecl(parser::ParsedRecord const parsed_record,ids::EnumId const enum_id,ids::ScopeId const scope_id,bool const comptime_pass,bool const generic_pass) {
{
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::TypeId const enum_type_id = ((((*this).get_enum(enum_id))).type_id);
bool const is_extern = ((((parsed_record).definition_linkage)).__jakt_init_index() == 1 /* External */);
{
JaktInternal::ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedMethod> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
parser::ParsedFunction const func = ((method).parsed_function);
if (((((func).is_comptime)) != (comptime_pass))){
continue;
}
if (((generic_pass) != ((!(((((func).generic_parameters)).is_empty())))))){
continue;
}
ids::ScopeId const method_scope_id = TRY((((*this).create_scope(scope_id,((func).can_throw),TRY((__jakt_format((StringView::from_string_literal("method({}::{})"sv)),((parsed_record).name),((func).name)))),true))));
ids::ScopeId const block_scope_id = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((__jakt_format((StringView::from_string_literal("method-block({}::{})"sv)),((parsed_record).name),((func).name)))),true))));
bool const is_generic = ((!(((((parsed_record).generic_parameters)).is_empty()))) || (!(((((func).generic_parameters)).is_empty()))));
bool has_varargs = ((((method).parsed_function)).has_varargs);
if ((has_varargs && ((((((method).parsed_function)).linkage)).__jakt_init_index() == 0 /* Internal */))){
TRY((((*this).error((ByteString::must_from_utf8("Only external functions are allowed to be declared using varargs"sv)),((((method).parsed_function)).name_span)))));
(has_varargs = false);
}
NonnullRefPtr<types::CheckedFunction> checked_function = TRY((types::CheckedFunction::__jakt_create(((func).name),((func).name_span),TRY((((*this).typecheck_visibility(((method).visibility),scope_id)))),types::unknown_type_id(),JaktInternal::OptionalNone(),(TRY((DynamicArray<types::CheckedParameter>::create_with({})))),TRY((types::FunctionGenerics::__jakt_create(method_scope_id,(TRY((DynamicArray<types::CheckedParameter>::create_with({})))),(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),block_scope_id,types::BlockControlFlow::MayReturn(),ids::TypeId::none(),false),((func).can_throw),((func).type),((func).linkage),method_scope_id,JaktInternal::OptionalNone(),((!(is_generic)) || is_extern),func,((func).is_comptime),false,false,((func).is_unsafe),has_varargs,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
ids::FunctionId const function_id = TRY((((module)->add_function(checked_function))));
JaktInternal::DynamicArray<types::FunctionGenericParameter> generic_parameters = (TRY((DynamicArray<types::FunctionGenericParameter>::create_with({}))));
{
JaktInternal::ArrayIterator<parser::ParsedGenericParameter> _magic = ((((func).generic_parameters)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedGenericParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
ids::TypeId const type_var_type_id = ids::TypeId(((*this).current_module_id),((((((*this).current_module()))->types)).size()));
types::FunctionGenericParameter parameter = TRY((types::FunctionGenericParameter::parameter(type_var_type_id,((generic_parameter).span))));
JaktInternal::DynamicArray<ids::TypeId> trait_implementations = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
TRY((((((module)->types)).push(TRY((types::Type::TypeVariable(parser::CheckedQualifiers(false),((generic_parameter).name),trait_implementations,((generic_parameter).is_value))))))));
if (((((generic_parameter).requires_list)).has_value())){
TRY((((*this).fill_trait_requirements((((generic_parameter).requires_list).value()),((((((parameter).checked_parameter)).constraints))),((trait_implementations)),scope_id))));
}
TRY((((generic_parameters).push(parameter))));
if ((!(((func).must_instantiate)))){
TRY((((*this).add_type_to_scope(method_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
}

}
}

(((((checked_function)->generics))->params) = generic_parameters);
{
JaktInternal::ArrayIterator<parser::ParsedParameter> _magic = ((((func).params)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
if (((((((param).variable)).name)) == ((ByteString::must_from_utf8("this"sv))))){
NonnullRefPtr<types::CheckedVariable> const checked_variable = TRY((types::CheckedVariable::__jakt_create(((((param).variable)).name),enum_type_id,((((param).variable)).is_mutable),((((param).variable)).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
TRY((((checked_function)->add_param(types::CheckedParameter(((param).requires_label),checked_variable,JaktInternal::OptionalNone())))));
}
else {
ids::TypeId const param_type = TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),method_scope_id,((((param).variable)).name)))));
NonnullRefPtr<types::CheckedVariable> const checked_variable = TRY((types::CheckedVariable::__jakt_create(((((param).variable)).name),param_type,((((param).variable)).is_mutable),((((param).variable)).span),((((((param).variable)).parsed_type))->span()),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
TRY((((checked_function)->add_param(types::CheckedParameter(((param).requires_label),checked_variable,({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,ids::ScopeId>>,ErrorOr<void>>{
auto __jakt_enum_value = (((((param).default_argument)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((Tuple{(((param).default_argument).value()), method_scope_id}));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
}))))));
}

}

}
}

TRY((((*this).add_function_to_scope(scope_id,((func).name),(TRY((DynamicArray<ids::FunctionId>::create_with({function_id})))),((parsed_record).name_span)))));
ids::TypeId const function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),method_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::dump_try_hint(utility::Span const span) const {
{
outln((StringView::from_string_literal("{{\"type\":\"try\",\"file_id\":{},\"position\":{}}}"sv)),((((span).file_id)).id),((span).start));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_methods_predecl(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id,bool const comptime_pass,bool const generic_pass) {
{
JaktInternal::DynamicArray<ids::ScopeId> const children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedNamespace const child_namespace = ((((parsed_namespace).namespaces))[i]);
ids::ScopeId const child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_methods_predecl(child_namespace,child_namespace_scope_id,comptime_pass,generic_pass))));
}

}
}

AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const parsed_record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const parsed_record = ((parsed_record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((parsed_record_scope_id_).template get<1>());

ids::ScopeId const record_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_546; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((parsed_record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
return JaktInternal::LoopContinue{};
}
ids::ScopeId const struct_scope_id = ((((*this).get_struct((struct_id.value())))).scope_id);
TRY((((*this).typecheck_struct_methods_predecl(parsed_record,(struct_id.value()),struct_scope_id,comptime_pass,generic_pass))));
__jakt_var_546 = struct_scope_id; goto __jakt_label_465;

}
__jakt_label_465:; __jakt_var_546.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_547; {
JaktInternal::Optional<ids::StructId> const struct_id = TRY((((*this).find_struct_in_scope(scope_id,((parsed_record).name),JaktInternal::OptionalNone()))));
if ((!(((struct_id).has_value())))){
return JaktInternal::LoopContinue{};
}
ids::ScopeId const struct_scope_id = ((((*this).get_struct((struct_id.value())))).scope_id);
TRY((((*this).typecheck_struct_methods_predecl(parsed_record,(struct_id.value()),struct_scope_id,comptime_pass,generic_pass))));
__jakt_var_547 = struct_scope_id; goto __jakt_label_466;

}
__jakt_label_466:; __jakt_var_547.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_548; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((parsed_record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
return JaktInternal::LoopContinue{};
}
ids::ScopeId const enum_scope_id = ((((*this).get_enum((enum_id.value())))).scope_id);
TRY((((*this).typecheck_enum_methods_predecl(parsed_record,(enum_id.value()),enum_scope_id,comptime_pass,generic_pass))));
__jakt_var_548 = enum_scope_id; goto __jakt_label_467;

}
__jakt_label_467:; __jakt_var_548.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_549; {
JaktInternal::Optional<ids::EnumId> const enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((parsed_record).name),false,JaktInternal::OptionalNone()))));
if ((!(((enum_id).has_value())))){
return JaktInternal::LoopContinue{};
}
ids::ScopeId const enum_scope_id = ((((*this).get_enum((enum_id.value())))).scope_id);
TRY((((*this).typecheck_enum_methods_predecl(parsed_record,(enum_id.value()),enum_scope_id,comptime_pass,generic_pass))));
__jakt_var_549 = enum_scope_id; goto __jakt_label_468;

}
__jakt_label_468:; __jakt_var_549.release_value(); }));
};/*case end*/
case 4 /* Garbage */: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{record, record_scope_id})));
}

}
}

}
if (((((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks)).has_value())){
JaktInternal::DynamicArray<types::ResolvedForallChunk> const chunks = (((TRY((((*this).get_scope(scope_id)))))->resolved_forall_chunks).value());
{
JaktInternal::ArrayIterator<types::ResolvedForallChunk> _magic = ((chunks).iterator());
for (;;){
JaktInternal::Optional<types::ResolvedForallChunk> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::ResolvedForallChunk chunk = (_magic_value.value());
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(((chunk).parameters))));
size_t i = static_cast<size_t>(0ULL);
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> stuff = (_magic_value.value());
{
ScopeGuard __jakt_var_550([&] {
((i) += (static_cast<size_t>(1ULL)));
});
TRY((((*this).typecheck_namespace_methods_predecl(((chunk).parsed_namespace),((((chunk).generated_scopes))[i]),comptime_pass,generic_pass))));
}

}
}

}

}
}

}
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_module(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id) {
{
TRY((((*this).typecheck_namespace_imports(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_predecl(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_methods_predecl(parsed_namespace,scope_id,true,false))));
TRY((((*this).typecheck_namespace_methods_predecl(parsed_namespace,scope_id,false,false))));
TRY((((*this).typecheck_namespace_methods_predecl(parsed_namespace,scope_id,true,true))));
TRY((((*this).typecheck_namespace_methods_predecl(parsed_namespace,scope_id,false,true))));
TRY((((*this).typecheck_namespace_aliases(parsed_namespace,scope_id,typechecker::ImportRestrictions(false,true,true,true,true,true)))));
TRY((((*this).typecheck_namespace_fields(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_constructors(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_function_predecl(parsed_namespace,scope_id,true,false))));
TRY((((*this).typecheck_namespace_function_predecl(parsed_namespace,scope_id,false,false))));
TRY((((*this).typecheck_namespace_function_predecl(parsed_namespace,scope_id,true,true))));
TRY((((*this).typecheck_namespace_function_predecl(parsed_namespace,scope_id,false,true))));
TRY((((*this).typecheck_namespace_aliases(parsed_namespace,scope_id,typechecker::ImportRestrictions(true,false,false,false,false,false)))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id,true,false))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id,true,true))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id,false,false))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id,false,true))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::error_with_hint(ByteString const message,utility::Span const span,ByteString const hint,utility::Span const hint_span) {
{
if ((!(((*this).ignore_errors)))){
TRY((((((((*this).compiler))->errors)).push(error::JaktError::MessageWithHint(message,span,hint,hint_span)))));
}
else {
(((*this).had_an_error) = true);
}

}
return {};
}

bool typechecker::Typechecker::is_subclass_of(ids::TypeId const ancestor_type_id,ids::TypeId const child_type_id) const {
{
NonnullRefPtr<typename types::Type> const ancestor_type = ((*this).get_type(ancestor_type_id));
NonnullRefPtr<typename types::Type> const child_type = ((*this).get_type(child_type_id));
if (((ancestor_type)->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const ancestor_struct_id = (ancestor_type)->as.Struct.value;
if (((child_type)->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const child_struct_id = (child_type)->as.Struct.value;
types::CheckedStruct ancestor_struct = ((*this).get_struct(ancestor_struct_id));
ids::StructId current_struct_id = child_struct_id;
for (;;){
types::CheckedStruct const current_struct = ((*this).get_struct(current_struct_id));
if (((((current_struct).super_struct_id)).has_value())){
if (((ancestor_struct_id).equals((((current_struct).super_struct_id).value())))){
return true;
}
(current_struct_id = (((current_struct).super_struct_id).value()));
}
else {
return false;
}

}
return false;
}
else {
return false;
}

}
else {
return false;
}

}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_predecl(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id) {
{
size_t const module_struct_len = ((((((*this).current_module()))->structures)).size());
size_t const module_enum_len = ((((((*this).current_module()))->enums)).size());
size_t struct_index = static_cast<size_t>(0ULL);
size_t enum_index = static_cast<size_t>(0ULL);
AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>> records_to_process = AK::Queue<JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId>>();
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const parsed_record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const parsed_record = ((parsed_record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((parsed_record_scope_id_).template get<1>());

types::StructLikeId const id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::StructLikeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_551; {
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,((struct_index++)),module_struct_len,scope_id))));
__jakt_var_551 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),ids::StructId(((scope_id).module_id),JaktInternal::checked_sub(struct_index,static_cast<size_t>(1ULL)))); goto __jakt_label_469;

}
__jakt_label_469:; __jakt_var_551.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_552; {
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,((struct_index++)),module_struct_len,scope_id))));
__jakt_var_552 = types::StructLikeId::Struct(JaktInternal::OptionalNone(),ids::StructId(((scope_id).module_id),JaktInternal::checked_sub(struct_index,static_cast<size_t>(1ULL)))); goto __jakt_label_470;

}
__jakt_label_470:; __jakt_var_552.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_553; {
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,((enum_index++)),module_enum_len,scope_id))));
__jakt_var_553 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),ids::EnumId(((scope_id).module_id),JaktInternal::checked_sub(enum_index,static_cast<size_t>(1ULL)))); goto __jakt_label_471;

}
__jakt_label_471:; __jakt_var_553.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<types::StructLikeId> __jakt_var_554; {
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,((enum_index++)),module_enum_len,scope_id))));
__jakt_var_554 = types::StructLikeId::Enum(JaktInternal::OptionalNone(),ids::EnumId(((scope_id).module_id),JaktInternal::checked_sub(enum_index,static_cast<size_t>(1ULL)))); goto __jakt_label_472;

}
__jakt_label_472:; __jakt_var_554.release_value(); }));
};/*case end*/
case 4 /* Garbage */: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{record, TRY((((id).scope_id(((((*this).program)))))))})));
}

}
}

}
{
JaktInternal::ArrayIterator<parser::ParsedNamespace> _magic = ((((parsed_namespace).namespaces)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedNamespace> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNamespace namespace_ = (_magic_value.value());
{
ByteString debug_name = (ByteString::must_from_utf8("namespace("sv));
if (((((namespace_).name)).has_value())){
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(((namespace_).name).value()))));
}
else {
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(ByteString::must_from_utf8("unnamed-namespace"sv)))));
}

TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(ByteString::must_from_utf8(")"sv)))));
JaktInternal::Optional<ids::ScopeId> existing_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<JaktInternal::Optional<ids::ScopeId>,ErrorOr<void>>{
auto __jakt_enum_value = (((((namespace_).name)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((TRY((((*this).find_namespace_in_scope(scope_id,(((namespace_).name).value()),false,JaktInternal::OptionalNone()))))).map([](auto& _value) { return _value.template get<0>(); })));
}
else if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
VERIFY_NOT_REACHED();
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
JaktInternal::Optional<ids::ScopeId> namespace_scope_id = existing_scope_id;
if ((!(((existing_scope_id).has_value())))){
if (((((namespace_).import_path_if_extern)).has_value())){
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(ByteString::must_from_utf8(" (extern "sv)))));
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(((namespace_).import_path_if_extern).value()))));
TRY(([](ByteString& self, ByteString rhs) -> ErrorOr<void> {
{
(self = TRY((((self) + (rhs)))));
}
return {};
}
(debug_name,(ByteString::must_from_utf8(")"sv)))));
}
ids::ScopeId const parent_scope_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId,ErrorOr<void>>{
auto __jakt_enum_value = (((((namespace_).import_path_if_extern)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(ids::ScopeId(ids::ModuleId(static_cast<size_t>(1ULL)),static_cast<size_t>(0ULL)));
}
else {
return JaktInternal::ExplicitValue(scope_id);
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
ids::ScopeId const child_scope_id = TRY((((*this).create_scope(parent_scope_id,false,debug_name,false))));
NonnullRefPtr<types::Scope> child_scope = TRY((((*this).get_scope(child_scope_id))));
(((child_scope)->namespace_name) = ((namespace_).name));
(((child_scope)->import_path_if_extern) = ((namespace_).import_path_if_extern));
(((child_scope)->before_extern_include) = ((namespace_).generating_import_extern_before_include));
(((child_scope)->after_extern_include) = ((namespace_).generating_import_extern_after_include));
(((child_scope)->is_from_generated_code) = (((child_scope)->is_from_generated_code) || ((namespace_).is_generated_code)));
if (((((namespace_).import_path_if_extern)).has_value())){
TRY((((((child_scope)->resolution_mixins)).push(scope_id))));
}
(namespace_scope_id = child_scope_id);
}
NonnullRefPtr<types::Scope> parent_scope = TRY((((*this).get_scope(scope_id))));
TRY((((((parent_scope)->children)).push((namespace_scope_id.value())))));
TRY((((*this).typecheck_namespace_predecl(namespace_,(namespace_scope_id.value())))));
}

}
}

{
JaktInternal::ArrayIterator<parser::ParsedTrait> _magic = ((((parsed_namespace).traits)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedTrait> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedTrait parsed_trait = (_magic_value.value());
{
TRY((((*this).typecheck_trait_predecl(parsed_trait,scope_id))));
}

}
}

(struct_index = static_cast<size_t>(0ULL));
(enum_index = static_cast<size_t>(0ULL));
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{parsed_record, scope_id})));
}

}
}

while ((!(((records_to_process).is_empty())))){
JaktInternal::Tuple<parser::ParsedRecord,ids::ScopeId> const parsed_record_scope_id_ = ((records_to_process).dequeue());
parser::ParsedRecord const parsed_record = ((parsed_record_scope_id_).template get<0>());
ids::ScopeId const scope_id = ((parsed_record_scope_id_).template get<1>());

ids::ScopeId const id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::ScopeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Struct */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_555; {
ids::StructId const struct_id = ids::StructId(((*this).current_module_id),JaktInternal::checked_add(struct_index,module_struct_len));
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
((struct_index++));
__jakt_var_555 = ((((*this).get_struct(struct_id))).scope_id); goto __jakt_label_473;

}
__jakt_label_473:; __jakt_var_555.release_value(); }));
};/*case end*/
case 1 /* Class */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_556; {
ids::StructId const struct_id = ids::StructId(((*this).current_module_id),JaktInternal::checked_add(struct_index,module_struct_len));
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
((struct_index++));
__jakt_var_556 = ((((*this).get_struct(struct_id))).scope_id); goto __jakt_label_474;

}
__jakt_label_474:; __jakt_var_556.release_value(); }));
};/*case end*/
case 3 /* SumEnum */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_557; {
ids::EnumId const enum_id = ids::EnumId(((*this).current_module_id),JaktInternal::checked_add(enum_index,module_enum_len));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
((enum_index++));
__jakt_var_557 = ((((*this).get_enum(enum_id))).scope_id); goto __jakt_label_475;

}
__jakt_label_475:; __jakt_var_557.release_value(); }));
};/*case end*/
case 2 /* ValueEnum */: {
return JaktInternal::ExplicitValue(({ Optional<ids::ScopeId> __jakt_var_558; {
ids::EnumId const enum_id = ids::EnumId(((*this).current_module_id),JaktInternal::checked_add(enum_index,module_enum_len));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
((enum_index++));
__jakt_var_558 = ((((*this).get_enum(enum_id))).scope_id); goto __jakt_label_476;

}
__jakt_label_476:; __jakt_var_558.release_value(); }));
};/*case end*/
case 4 /* Garbage */: {
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
{
JaktInternal::ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_record).nested_records)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedRecord> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
((records_to_process).enqueue((Tuple{record, id})));
}

}
}

}
{
JaktInternal::ArrayIterator<bool> _magic = (((TRY((DynamicArray<bool>::create_with({false, true}))))).iterator());
for (;;){
JaktInternal::Optional<bool> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
bool default_pass = (_magic_value.value());
{
{
JaktInternal::ArrayIterator<parser::ParsedExternalTraitImplementation> _magic = ((((parsed_namespace).external_trait_implementations)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternalTraitImplementation> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternalTraitImplementation implementation = (_magic_value.value());
{
ids::TypeId const for_type = TRY((((*this).typecheck_typename(((implementation).for_type),scope_id,JaktInternal::OptionalNone()))));
JaktInternal::Optional<ids::TypeId> const old_self_type_id = ((*this).self_type_id);
TRY((((*this).set_self_type_id(for_type))));
ScopeGuard __jakt_var_559([&] {
(((*this).self_type_id) = old_self_type_id);
});
NonnullRefPtr<typename types::Type> type = ((*this).get_type(for_type));
if (((type)->is_builtin())){
(type = ((*this).get_type(((((*this).get_struct(TRY((((((*this).program))->builtin_implementation_struct(((type)->as_builtin_type()),((((*this).program))->prelude_module_id())))))))).type_id))));
}
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
types::CheckedStruct struct_ = ((*this).get_struct(struct_id));
TRY((((*this).resolve_external_trait_implementations(implementation,((struct_).scope_id),((((struct_).trait_implementations))),for_type,scope_id,default_pass))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
{
types::CheckedStruct struct_ = ((*this).get_struct(struct_id));
TRY((((*this).resolve_external_trait_implementations(implementation,((struct_).scope_id),((((struct_).trait_implementations))),for_type,scope_id,default_pass))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum enum_ = ((*this).get_enum(enum_id));
TRY((((*this).resolve_external_trait_implementations(implementation,((enum_).scope_id),((((enum_).trait_implementations))),for_type,scope_id,default_pass))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
{
types::CheckedEnum enum_ = ((*this).get_enum(enum_id));
TRY((((*this).resolve_external_trait_implementations(implementation,((enum_).scope_id),((((enum_).trait_implementations))),for_type,scope_id,default_pass))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(default_pass))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Cannot implement traits for type '{}'"sv)),TRY((((*this).type_name(for_type,false))))))),((((implementation).for_type))->span())))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
});
}

}
}

}

}
}

{
JaktInternal::ArrayIterator<parser::ParsedTrait> _magic = ((((parsed_namespace).traits)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedTrait> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedTrait parsed_trait = (_magic_value.value());
{
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((*this).find_trait_in_scope(scope_id,((parsed_trait).name)))));
if (((trait_id).has_value())){
TRY((((*this).typecheck_trait(parsed_trait,(trait_id.value()),scope_id,true))));
}
else {
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("can't find trait that has been previous added"sv))))));
}

}

}
}

{
JaktInternal::ArrayIterator<JaktInternal::Tuple<JaktInternal::DynamicArray<parser::ParsedGenericParameter>,parser::ParsedNamespace>> _magic = ((((parsed_namespace).forall_chunks)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<JaktInternal::DynamicArray<parser::ParsedGenericParameter>,parser::ParsedNamespace>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<JaktInternal::DynamicArray<parser::ParsedGenericParameter>,parser::ParsedNamespace> chunk_parameters__chunk_namespace__ = (_magic_value.value());
{
JaktInternal::Tuple<JaktInternal::DynamicArray<parser::ParsedGenericParameter>,parser::ParsedNamespace> const jakt__chunk_parameters__chunk_namespace__ = chunk_parameters__chunk_namespace__;
JaktInternal::DynamicArray<parser::ParsedGenericParameter> const chunk_parameters = ((jakt__chunk_parameters__chunk_namespace__).template get<0>());
parser::ParsedNamespace const chunk_namespace = ((jakt__chunk_parameters__chunk_namespace__).template get<1>());

JaktInternal::Dictionary<ByteString,JaktInternal::DynamicArray<JaktInternal::Tuple<utility::Span,ids::TypeId>>> const resolved_parameters = TRY((((*this).typecheck_forall_chunk_parameters(chunk_parameters,scope_id))));
types::ResolvedForallChunk resolved_chunk = types::ResolvedForallChunk(resolved_parameters,chunk_namespace,(TRY((DynamicArray<ids::ScopeId>::create_with({})))));
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> all_types = TRY((typechecker::create_internal_dictionary_product<ByteString, JaktInternal::Tuple<utility::Span,ids::TypeId>>(resolved_parameters)));
{
typechecker::InternalDictionaryProduct<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = all_types;
for (;;){
JaktInternal::Optional<JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Dictionary<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> parameters = (_magic_value.value());
{
ByteStringBuilder debug_name_builder = ByteStringBuilder::create();
TRY((((debug_name_builder).append((StringView::from_string_literal("forall<"sv))))));
bool first = true;
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = ((parameters).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> name__value__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> const jakt__name__value__ = name__value__;
ByteString const name = ((jakt__name__value__).template get<0>());
JaktInternal::Tuple<utility::Span,ids::TypeId> const value = ((jakt__name__value__).template get<1>());

if (first){
(first = false);
}
else {
TRY((((debug_name_builder).append((StringView::from_string_literal(", "sv))))));
}

TRY((((debug_name_builder).append(name))));
TRY((((debug_name_builder).append((StringView::from_string_literal("="sv))))));
TRY((((debug_name_builder).append(TRY((((*this).type_name(((value).template get<1>()),false))))))));
}

}
}

TRY((((debug_name_builder).append((StringView::from_string_literal("> namespace"sv))))));
ids::ScopeId const namespace_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((((debug_name_builder).to_string()))),false))));
{
JaktInternal::DictionaryIterator<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> _magic = ((parameters).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> name__value__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,JaktInternal::Tuple<utility::Span,ids::TypeId>> const jakt__name__value__ = name__value__;
ByteString const name = ((jakt__name__value__).template get<0>());
JaktInternal::Tuple<utility::Span,ids::TypeId> const value = ((jakt__name__value__).template get<1>());

TRY((((*this).add_type_to_scope(namespace_scope_id,name,((value).template get<1>()),((value).template get<0>())))));
}

}
}

NonnullRefPtr<types::Scope> parent_scope = TRY((((*this).get_scope(scope_id))));
TRY((((((parent_scope)->children)).push(namespace_scope_id))));
TRY((((((parent_scope)->resolution_mixins)).push(namespace_scope_id))));
TRY((((*this).typecheck_namespace_predecl(chunk_namespace,namespace_scope_id))));
TRY((((((resolved_chunk).generated_scopes)).push(namespace_scope_id))));
}

}
}

NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
if ((!(((scope)->resolved_forall_chunks)).has_value())){
(((scope)->resolved_forall_chunks) = (TRY((DynamicArray<types::ResolvedForallChunk>::create_with({})))));
}
TRY(((((((scope)->resolved_forall_chunks).value())).push(resolved_chunk))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_var_decl(parser::ParsedVarDecl const var,NonnullRefPtr<typename parser::ParsedExpression> const init,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span) {
{
ids::TypeId lhs_type_id = TRY((((*this).typecheck_typename(((var).parsed_type),scope_id,((var).name)))));
NonnullRefPtr<typename types::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(init,scope_id,safety_mode,lhs_type_id))));
ids::TypeId const rhs_type_id = ((checked_expr)->type());
if (((rhs_type_id).equals(types::void_type_id()))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign `void` to a variable"sv)),((checked_expr)->span())))));
}
if (((((((*this).get_type(lhs_type_id)))->common.init_common.qualifiers)).is_immutable)){
(lhs_type_id = TRY((((*this).with_qualifiers(parser::CheckedQualifiers(false),lhs_type_id)))));
if (((var).is_mutable)){
TRY((((*this).error((ByteString::must_from_utf8("Cannot have a mutable binding to an immutable object"sv)),((var).span)))));
}
}
if ((((lhs_type_id).equals(types::unknown_type_id())) && (!(((rhs_type_id).equals(types::unknown_type_id())))))){
(lhs_type_id = rhs_type_id);
}
ids::StructId const weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv))))));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
if (TRY((((*this).type_contains_reference(lhs_type_id))))){
JaktInternal::Tuple<JaktInternal::Optional<ids::ScopeId>,NonnullRefPtr<typename types::CheckedExpression>> const init_scope_id_cause_expr_ = TRY((((*this).required_scope_id_in_hierarchy_for(checked_expr,scope_id))));
JaktInternal::Optional<ids::ScopeId> const init_scope_id = ((init_scope_id_cause_expr_).template get<0>());
NonnullRefPtr<typename types::CheckedExpression> const cause_expr = ((init_scope_id_cause_expr_).template get<1>());

if (TRY((((*this).scope_lifetime_subsumes(scope_id,init_scope_id))))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Cannot assign a reference to a variable that outlives the reference"sv)),((checked_expr)->span()),(ByteString::must_from_utf8("Limited by this expression's lifetime"sv)),((cause_expr)->span())))));
}
}
NonnullRefPtr<typename types::Type> const lhs_type = ((*this).get_type(lhs_type_id));
if (((checked_expr)->__jakt_init_index() == 25 /* OptionalNone */)){
utility::Span const span = (checked_expr)->as.OptionalNone.span;
ids::TypeId const type_id = (checked_expr)->as.OptionalNone.type_id;
if (((lhs_type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (lhs_type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (lhs_type)->as.GenericInstance.args;
if ((!((((id).equals(optional_struct_id)) || ((id).equals(weak_ptr_struct_id)))))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Cannot assign None to a non-optional type"sv)),span))));
}

}
if (((lhs_type)->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (lhs_type)->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (lhs_type)->as.GenericInstance.args;
if (((id).equals(weak_ptr_struct_id))){
if (((!(((lhs_type_id).equals(rhs_type_id)))) && ((!(((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id)))) && ((!(((rhs_type_id).equals(types::unknown_type_id())))) && (!(((*this).is_subclass_of(((args)[static_cast<i64>(0LL)]),rhs_type_id)))))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),((checked_expr)->span())))));
}
}
else if (((id).equals(optional_struct_id))){
if (((!(((lhs_type_id).equals(rhs_type_id)))) && ((!(((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id)))) && ((!(((rhs_type_id).equals(types::unknown_type_id())))) && (!(((*this).is_subclass_of(((args)[static_cast<i64>(0LL)]),rhs_type_id)))))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),((checked_expr)->span())))));
}
}
else {
if (((!(((lhs_type_id).equals(rhs_type_id)))) && (!(((rhs_type_id).equals(types::unknown_type_id())))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),((checked_expr)->span())))));
}
}

}
else if (((lhs_type)->is_builtin())){
JaktInternal::Optional<types::NumberConstant> const number_constant = ((checked_expr)->to_number_constant(((*this).program)));
bool is_rhs_zero = false;
if (((number_constant).has_value())){
(is_rhs_zero = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typename types::CheckedStatement>>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Signed */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Signed;i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((value) == (static_cast<i64>(0LL))));
};/*case end*/
case 1 /* Unsigned */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Unsigned;u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((value) == (static_cast<u64>(0ULL))));
};/*case end*/
case 2 /* Floating */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Floating;f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((value) == (static_cast<f64>(0))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
if (((!((((*this).is_numeric(lhs_type_id)) && is_rhs_zero))) && (((*this).is_integer(lhs_type_id)) ^ ((*this).is_integer(rhs_type_id))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),((checked_expr)->span())))));
return TRY((types::CheckedStatement::Garbage(span)));
}
}
else {
if (((!(((lhs_type_id).equals(rhs_type_id)))) && ((!(((rhs_type_id).equals(types::unknown_type_id())))) && (!(((*this).is_subclass_of(lhs_type_id,rhs_type_id))))))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Type mismatch: expected ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(lhs_type_id,false)))),TRY((((*this).type_name(rhs_type_id,false))))))),((checked_expr)->span())))));
}
}

NonnullRefPtr<types::CheckedVariable> const checked_var = TRY((types::CheckedVariable::__jakt_create(((var).name),lhs_type_id,((var).is_mutable),((var).span),JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
if ((((*this).dump_type_hints) && ((((var).inlay_span)).has_value()))){
TRY((((*this).dump_type_hint(lhs_type_id,(((var).inlay_span).value())))));
}
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const var_id = TRY((((module)->add_variable(checked_var))));
TRY((((*this).add_var_to_scope(scope_id,((var).name),var_id,((checked_var)->definition_span)))));
return TRY((types::CheckedStatement::VarDecl(var_id,checked_expr,span)));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedStatement>> typechecker::Typechecker::typecheck_inline_cpp(parser::ParsedBlock const block,utility::Span const span,types::SafetyMode const safety_mode) {
{
if (((safety_mode).__jakt_init_index() == 0 /* Safe */)){
TRY((((*this).error((ByteString::must_from_utf8("Use of inline cpp block outside of unsafe block"sv)),span))));
}
JaktInternal::DynamicArray<ByteString> strings = (TRY((DynamicArray<ByteString>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedStatement>> _magic = ((((block).stmts)).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedStatement>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedStatement> statement = (_magic_value.value());
{
if (((statement)->__jakt_init_index() == 0 /* Expression */)){
NonnullRefPtr<typename parser::ParsedExpression> const expr = (statement)->as.Expression.expr;
if (((expr)->__jakt_init_index() == 2 /* QuotedString */)){
ByteString const val = (expr)->as.QuotedString.val;
utility::Span const span = (expr)->as.QuotedString.span;
TRY((((strings).push(val))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Expected block of strings"sv)),span))));
}

}
else {
TRY((((*this).error((ByteString::must_from_utf8("Expected block of strings"sv)),span))));
}

}

}
}

return TRY((types::CheckedStatement::InlineCpp(strings,span)));
}
}

bool typechecker::Typechecker::is_struct(ids::TypeId const type_id) const {
{
if (((((*this).get_type(type_id)))->__jakt_init_index() == 24 /* Struct */)){
ids::StructId const struct_id = (((*this).get_type(type_id)))->as.Struct.value;
return ((((((*this).get_struct(struct_id))).record_type)).__jakt_init_index() == 0 /* Struct */);
}
else {
return false;
}

}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_expression(NonnullRefPtr<typename parser::ParsedExpression> const expr,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.__jakt_init_index()) {
case 7 /* IndexedStruct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedStruct;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
ByteString const& field_name = __jakt_match_value.field_name;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_struct(expr,field_name,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 8 /* ComptimeIndex */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ComptimeIndex;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typename parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_comptime_index(expr,index,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 0 /* Boolean */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Boolean;bool const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_560; {
TRY((((*this).unify_with_type(types::builtin(types::BuiltinType::Bool()),type_hint,span))));
__jakt_var_560 = TRY((types::CheckedExpression::Boolean(JaktInternal::OptionalNone(),val,span))); goto __jakt_label_477;

}
__jakt_label_477:; __jakt_var_560.release_value(); }));
};/*case end*/
case 1 /* NumericConstant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NumericConstant;parser::NumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_561; {
JaktInternal::Optional<ids::TypeId> type_hint_unwrapped = type_hint;
if ((((type_hint).has_value()) && ((((*this).get_type((type_hint.value()))))->__jakt_init_index() == 20 /* GenericInstance */))){
ids::StructId const id = (((*this).get_type((type_hint.value()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type((type_hint.value()))))->as.GenericInstance.args;
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
if (((id).equals(optional_struct_id))){
(type_hint_unwrapped = ((args)[static_cast<i64>(0LL)]));
}
}
__jakt_var_561 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* I8 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I8;i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I8(val),span,types::builtin(types::BuiltinType::I8())))));
};/*case end*/
case 1 /* I16 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I16;i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I16(val),span,types::builtin(types::BuiltinType::I16())))));
};/*case end*/
case 2 /* I32 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I32;i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I32(val),span,types::builtin(types::BuiltinType::I32())))));
};/*case end*/
case 3 /* I64 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.I64;i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::I64(val),span,types::builtin(types::BuiltinType::I64())))));
};/*case end*/
case 4 /* U8 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U8;u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U8(val),span,types::builtin(types::BuiltinType::U8())))));
};/*case end*/
case 5 /* U16 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U16;u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U16(val),span,types::builtin(types::BuiltinType::U16())))));
};/*case end*/
case 6 /* U32 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U32;u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U32(val),span,types::builtin(types::BuiltinType::U32())))));
};/*case end*/
case 7 /* U64 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.U64;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::U64(val),span,types::builtin(types::BuiltinType::U64())))));
};/*case end*/
case 8 /* USize */: {
auto&& __jakt_match_value = __jakt_match_variant.as.USize;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::USize(val),span,types::builtin(types::BuiltinType::Usize())))));
};/*case end*/
case 9 /* F32 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.F32;f32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::F32(val),span,types::builtin(types::BuiltinType::F32())))));
};/*case end*/
case 10 /* F64 */: {
auto&& __jakt_match_value = __jakt_match_variant.as.F64;f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::NumericConstant(JaktInternal::OptionalNone(),types::CheckedNumericConstant::F64(val),span,types::builtin(types::BuiltinType::F64())))));
};/*case end*/
case 11 /* UnknownSigned */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnknownSigned;i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).infer_signed_int(val,span,type_hint_unwrapped)))));
};/*case end*/
case 12 /* UnknownUnsigned */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnknownUnsigned;u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).infer_unsigned_int(val,span,type_hint_unwrapped)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_478;

}
__jakt_label_478:; __jakt_var_561.release_value(); }));
};/*case end*/
case 3 /* SingleQuotedString */: {
auto&& __jakt_match_value = __jakt_match_variant.as.SingleQuotedString;ByteString const& val = __jakt_match_value.val;
JaktInternal::Optional<ByteString> const& prefix = __jakt_match_value.prefix;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (TRY((prefix.try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); }))));
if (__jakt_enum_value == (ByteString::must_from_utf8(""sv))) {
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::CharacterConstant(JaktInternal::OptionalNone(),val,span))));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("b"sv))) {
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::ByteConstant(JaktInternal::OptionalNone(),val,span))));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("c"sv))) {
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::CCharacterConstant(JaktInternal::OptionalNone(),val,span))));
}
else {
{
TRY((((((*this).compiler))->panic(TRY((__jakt_format((StringView::from_string_literal("Unknown string prefix {}"sv)),prefix)))))));
}
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
};/*case end*/
case 2 /* QuotedString */: {
auto&& __jakt_match_value = __jakt_match_variant.as.QuotedString;ByteString const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_562; {
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
__jakt_var_562 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = ((((type_hint).has_value()) && (!((((type_hint.value())).equals(types::unknown_type_id()))))));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_563; {
ids::TypeId type_id = TRY((((*this).strip_optional_from_type(((((*this).generic_inferences)).map((type_hint.value())))))));
ids::TypeId const prelude_string_type_id = TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("String"sv))))));
ids::TypeId const prelude_string_view_type_id = TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("StringView"sv))))));
bool may_throw = false;
if (((!(((type_id).equals(prelude_string_type_id)))) && (!(((type_id).equals(prelude_string_view_type_id)))))){
if (((((*this).get_type(type_id)))->is_concrete())){
JaktInternal::Optional<typechecker::TraitImplementationDescriptor> const trait_implementation = TRY((((*this).find_any_singular_trait_implementation(type_id,(TRY((DynamicArray<ByteString>::create_with({(ByteString::must_from_utf8("FromStringLiteral"sv)), (ByteString::must_from_utf8("ThrowingFromStringLiteral"sv))})))),scope_id,span,JaktInternal::OptionalNone()))));
if ((!(((trait_implementation).has_value())))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Type {} cannot be used as an overloaded string literal type"sv)),TRY((((*this).type_name(type_id,true))))))),span,TRY((__jakt_format((StringView::from_string_literal("Consider implementing the FromStringLiteral trait for {}"sv)),TRY((((*this).type_name(type_id,false))))))),span))));
(type_id = prelude_string_type_id);
}
else {
(may_throw = (((((trait_implementation.value())).trait_name)) == ((ByteString::must_from_utf8("ThrowingFromStringLiteral"sv)))));
}

}
else if ((!(((((*this).get_type(type_id)))->is_concrete())))){
(type_id = TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("String"sv)))))));
}
}
TRY((((*this).unify((type_hint.value()),span,type_id,span))));
if ((may_throw && (!(((TRY((((*this).get_scope(scope_id)))))->can_throw))))){
TRY((((*this).error((ByteString::must_from_utf8("Operation that may throw needs to be in a try statement or a function marked as throws"sv)),span))));
}
__jakt_var_563 = TRY((types::CheckedExpression::QuotedString(JaktInternal::OptionalNone(),types::CheckedStringLiteral(types::StringLiteral::Static(val),type_id,may_throw),span))); goto __jakt_label_480;

}
__jakt_label_480:; __jakt_var_563.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_564; {
__jakt_var_564 = TRY((types::CheckedExpression::QuotedString(JaktInternal::OptionalNone(),types::CheckedStringLiteral(types::StringLiteral::Static(val),TRY((((*this).prelude_struct_type_named((ByteString::must_from_utf8("String"sv)))))),false),span))); goto __jakt_label_481;

}
__jakt_label_481:; __jakt_var_564.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_479;

}
__jakt_label_479:; __jakt_var_562.release_value(); }));
};/*case end*/
case 4 /* Call */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Call;parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_565; {
__jakt_var_565 = TRY((((*this).typecheck_call(call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,false)))); goto __jakt_label_482;

}
__jakt_label_482:; __jakt_var_565.release_value(); }));
};/*case end*/
case 5 /* MethodCall */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MethodCall;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_566; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId const checked_expr_type_id = ((checked_expr)->type());
ids::TypeId const final_type_id = TRY((((*this).final_type_resolution_form(checked_expr_type_id,scope_id))));
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(final_type_id));
JaktInternal::Tuple<JaktInternal::Optional<types::StructLikeId>,bool> const parent_id_found_optional_ = TRY((((*this).struct_like_id_from_type_id(final_type_id,scope_id,span,is_optional,false))));
JaktInternal::Optional<types::StructLikeId> const parent_id = ((parent_id_found_optional_).template get<0>());
bool const found_optional = ((parent_id_found_optional_).template get<1>());

if ((is_optional && (!(found_optional)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Optional chain mismatch: expected optional chain, found {}"sv)),TRY((((*this).type_name(checked_expr_type_id,false))))))),((checked_expr)->span())))));
}
NonnullRefPtr<typename types::CheckedExpression> const checked_call_expr = TRY((((*this).typecheck_call(call,scope_id,span,checked_expr,parent_id,safety_mode,type_hint,false))));
ids::TypeId const type_id = ((checked_call_expr)->type());
__jakt_var_566 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_call_expr;
switch(__jakt_match_variant.__jakt_init_index()) {
case 21 /* Call */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Call;types::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_567; {
ids::TypeId result_type = ((call).return_type);
if (is_optional){
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
(result_type = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({result_type}))))))))))));
}
__jakt_var_567 = TRY((types::CheckedExpression::MethodCall(JaktInternal::OptionalNone(),checked_expr,call,span,is_optional,result_type))); goto __jakt_label_484;

}
__jakt_label_484:; __jakt_var_567.release_value(); }));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("typecheck_call should return `CheckedExpression::Call()`"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_483;

}
__jakt_label_483:; __jakt_var_566.release_value(); }));
};/*case end*/
case 20 /* Range */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Range;JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const& from = __jakt_match_value.from;
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_568; {
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> checked_from = JaktInternal::OptionalNone();
JaktInternal::Optional<ids::TypeId> from_type = JaktInternal::OptionalNone();
utility::Span from_span = span;
if ((((from).has_value()) && ((!((((from.value()))->__jakt_init_index() == 1 /* NumericConstant */))) && (!((((from.value()))->__jakt_init_index() == 1 /* NumericConstant */)))))){
(checked_from = TRY((((*this).typecheck_expression((from.value()),scope_id,safety_mode,JaktInternal::OptionalNone())))));
(from_type = (((checked_from.value()))->type()));
(from_span = (((checked_from.value()))->span()));
}
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> checked_to = JaktInternal::OptionalNone();
ids::TypeId to_type = types::unknown_type_id();
utility::Span to_span = span;
if (((to).has_value())){
(checked_to = TRY((((*this).typecheck_expression((to.value()),scope_id,safety_mode,from_type)))));
(to_type = (((checked_to.value()))->type()));
(to_span = (((checked_to.value()))->span()));
}
if ((((from).has_value()) && ((((from.value()))->__jakt_init_index() == 1 /* NumericConstant */) || (((from.value()))->__jakt_init_index() == 1 /* NumericConstant */)))){
(checked_from = TRY((((*this).typecheck_expression((from.value()),scope_id,safety_mode,to_type)))));
(from_type = (((checked_from.value()))->type()));
(from_span = (((checked_from.value()))->span()));
}
JaktInternal::Optional<ids::TypeId> values_type_id = JaktInternal::OptionalNone();
if ((((from).has_value()) && ((to).has_value()))){
(values_type_id = TRY((((*this).unify((from_type.value()),from_span,to_type,from_span)))));
if ((!(((values_type_id).has_value())))){
TRY((((*this).error((ByteString::must_from_utf8("Range values differ in types"sv)),span))));
}
}
else if (((from).has_value())){
(values_type_id = from_type);
}
else if (((to).has_value())){
(values_type_id = to_type);
}
ids::StructId const range_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Range"sv))))));
NonnullRefPtr<typename types::Type> const range_type = TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),range_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({((values_type_id).value_or(types::builtin(types::BuiltinType::I64())))})))))));
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(range_type))));
__jakt_var_568 = TRY((types::CheckedExpression::Range(JaktInternal::OptionalNone(),checked_from,checked_to,span,type_id))); goto __jakt_label_485;

}
__jakt_label_485:; __jakt_var_568.release_value(); }));
};/*case end*/
case 28 /* Reflect */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reflect;NonnullRefPtr<typename parser::ParsedType> const& type = __jakt_match_value.type;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_569; {
ids::EnumId const reflected_type_enum_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::EnumId, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = TRY((((((*this).program))->find_reflected_primitive((ByteString::must_from_utf8("Type"sv))))));
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("unreachable"sv))))));
}
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
ids::TypeId const reflected_type = TRY((((*this).typecheck_typename(type,scope_id,JaktInternal::OptionalNone()))));
__jakt_var_569 = TRY((types::CheckedExpression::Reflect(JaktInternal::OptionalNone(),reflected_type,span,TRY((((*this).find_or_add_type_id(TRY((types::Type::Enum(parser::CheckedQualifiers(false),reflected_type_enum_id)))))))))); goto __jakt_label_486;

}
__jakt_label_486:; __jakt_var_569.release_value(); }));
};/*case end*/
case 11 /* UnaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.UnaryOp;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_570; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 5 /* Dereference */: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone())))));
};/*case end*/
case 4 /* Negate */: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,type_hint,span)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span)))));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
types::CheckedUnaryOperator const checked_op = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedUnaryOperator, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* PreIncrement */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::PreIncrement());
};/*case end*/
case 1 /* PostIncrement */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::PostIncrement());
};/*case end*/
case 2 /* PreDecrement */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::PreDecrement());
};/*case end*/
case 3 /* PostDecrement */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::PostDecrement());
};/*case end*/
case 4 /* Negate */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::Negate());
};/*case end*/
case 5 /* Dereference */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::Dereference());
};/*case end*/
case 6 /* RawAddress */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::RawAddress());
};/*case end*/
case 7 /* Reference */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::Reference());
};/*case end*/
case 8 /* MutableReference */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::MutableReference());
};/*case end*/
case 9 /* LogicalNot */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::LogicalNot());
};/*case end*/
case 10 /* BitwiseNot */: {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::BitwiseNot());
};/*case end*/
case 11 /* TypeCast */: {
auto&& __jakt_match_value = __jakt_match_variant.as.TypeCast;parser::TypeCast const& cast = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedUnaryOperator> __jakt_var_571; {
ids::TypeId const type_id = TRY((((*this).typecheck_typename(((cast).parsed_type()),scope_id,JaktInternal::OptionalNone()))));
types::CheckedTypeCast const checked_cast = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedTypeCast, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = cast;
switch(__jakt_match_variant.__jakt_init_index()) {
case 0 /* Fallible */: {
return JaktInternal::ExplicitValue(({ Optional<types::CheckedTypeCast> __jakt_var_572; {
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
NonnullRefPtr<typename types::Type> const optional_type = TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({type_id})))))));
ids::TypeId const optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_572 = types::CheckedTypeCast::Fallible(optional_type_id); goto __jakt_label_489;

}
__jakt_label_489:; __jakt_var_572.release_value(); }));
};/*case end*/
case 1 /* Infallible */: {
return JaktInternal::ExplicitValue(types::CheckedTypeCast::Infallible(type_id));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
__jakt_var_571 = types::CheckedUnaryOperator::TypeCast(checked_cast); goto __jakt_label_488;

}
__jakt_label_488:; __jakt_var_571.release_value(); }));
};/*case end*/
case 14 /* Sizeof */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Sizeof;NonnullRefPtr<typename parser::ParsedType> const& unchecked_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedUnaryOperator> __jakt_var_573; {
ids::TypeId const type_id = TRY((((*this).typecheck_typename(unchecked_type,scope_id,JaktInternal::OptionalNone()))));
__jakt_var_573 = types::CheckedUnaryOperator::Sizeof(type_id); goto __jakt_label_490;

}
__jakt_label_490:; __jakt_var_573.release_value(); }));
};/*case end*/
case 12 /* Is */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Is;NonnullRefPtr<typename parser::ParsedType> const& unchecked_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<types::CheckedUnaryOperator> __jakt_var_574; {
bool const old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
ids::TypeId const type_id = TRY((((*this).typecheck_typename(unchecked_type,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
(((*this).had_an_error) = false);
types::CheckedUnaryOperator operator_is = types::CheckedUnaryOperator::Is(type_id);
if (((unchecked_type)->__jakt_init_index() == 0 /* Name */)){
ByteString const name = (unchecked_type)->as.Name.name;
ids::TypeId const expr_type_id = ((checked_expr)->type());
if (((((*this).get_type(expr_type_id)))->__jakt_init_index() == 25 /* Enum */)){
ids::EnumId const enum_id = (((*this).get_type(expr_type_id)))->as.Enum.value;
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
bool exists = false;
{
JaktInternal::ArrayIterator<types::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedEnumVariant> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedEnumVariant variant = (_magic_value.value());
{
(exists = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.__jakt_init_index()) {
case 3 /* StructLike */: {
auto&& __jakt_match_value = __jakt_match_variant.as.StructLike;ByteString const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(((var_name) == (name)));
};/*case end*/
case 1 /* Typed */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Typed;ByteString const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(((var_name) == (name)));
};/*case end*/
case 0 /* Untyped */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Untyped;ByteString const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(((var_name) == (name)));
};/*case end*/
case 2 /* WithValue */: {
auto&& __jakt_match_value = __jakt_match_variant.as.WithValue;ByteString const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(((var_name) == (name)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    if (_jakt_value.is_loop_break())
        break;
    if (_jakt_value.is_loop_continue())
        continue;
    _jakt_value.release_value();
}));
if (exists){
(operator_is = types::CheckedUnaryOperator::IsEnumVariant(variant,(TRY((DynamicArray<types::CheckedEnumVariantBinding>::create_with({})))),expr_type_id));
break;
}
}

}
}

if (((!(exists)) && ((type_id).equals(types::unknown_type_id())))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant {} does not exist on {}"sv)),name,TRY((((*this).type_name(expr_type_id,false))))))),span))));
}
}
else if ((((name) == ((ByteString::must_from_utf8("Some"sv)))) || ((name) == ((ByteString::must_from_utf8("None"sv)))))){
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
NonnullRefPtr<typename types::Type> const checked_expr_type = ((*this).get_type(((checked_expr)->type())));
if ((!(((checked_expr_type)->__jakt_init_index() == 20 /* GenericInstance */)))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("The left-hand side of an `is {}` statement must have a {} variant"sv)),name,name))),((checked_expr)->span())))));
}
(operator_is = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<types::CheckedUnaryOperator,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == (ByteString::must_from_utf8("Some"sv))) {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::IsSome());
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("None"sv))) {
return JaktInternal::ExplicitValue(types::CheckedUnaryOperator::IsNone());
}
else {
{
utility::panic((ByteString::must_from_utf8("unreachable"sv)));
}
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}));
}
else if (((type_id).equals(types::unknown_type_id()))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type or invalid type name: {}"sv)),name))),span))));
}
}
else {
TRY((((*this).error((ByteString::must_from_utf8("The right-hand side of an `is` operator must be a type name or enum variant"sv)),span))));
}

__jakt_var_574 = operator_is; goto __jakt_label_491;

}
__jakt_label_491:; __jakt_var_574.release_value(); }));
};/*case end*/
case 13 /* IsEnumVariant */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IsEnumVariant;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
JaktInternal::DynamicArray<parser::EnumVariantPatternArgument> const& bindings = __jakt_match_value.bindings;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_is_enum_variant(checked_expr,inner,bindings,scope_id)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
__jakt_var_570 = TRY((((*this).typecheck_unary_operation(checked_expr,checked_op,span,scope_id,safety_mode)))); goto __jakt_label_487;

}
__jakt_label_487:; __jakt_var_570.release_value(); }));
};/*case end*/
case 12 /* BinaryOp */: {
auto&& __jakt_match_value = __jakt_match_variant.as.BinaryOp;NonnullRefPtr<typename parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typename parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_575; {
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> original_checked_lhs = JaktInternal::OptionalNone();
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> original_checked_rhs = JaktInternal::OptionalNone();
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> checked_lhs = JaktInternal::OptionalNone();
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> checked_rhs = JaktInternal::OptionalNone();
if (((lhs)->__jakt_init_index() == 1 /* NumericConstant */)){
parser::NumericConstant const val = (lhs)->as.NumericConstant.val;
if ((((val).__jakt_init_index() == 11 /* UnknownSigned */) || ((val).__jakt_init_index() == 12 /* UnknownUnsigned */))){
(original_checked_rhs = TRY((((*this).typecheck_expression(rhs,scope_id,safety_mode,JaktInternal::OptionalNone())))));
(checked_rhs = TRY((((*this).dereference_if_needed((original_checked_rhs.value()),span)))));
ids::TypeId const hint = (((checked_rhs.value()))->type());
(original_checked_lhs = TRY((((*this).typecheck_expression(lhs,scope_id,safety_mode,hint)))));
(checked_lhs = TRY((((*this).dereference_if_needed((original_checked_lhs.value()),span)))));
}
else {
(original_checked_lhs = TRY((((*this).typecheck_expression(lhs,scope_id,safety_mode,JaktInternal::OptionalNone())))));
(checked_lhs = TRY((((*this).dereference_if_needed((original_checked_lhs.value()),span)))));
ids::TypeId const hint = (((checked_lhs.value()))->type());
(original_checked_rhs = TRY((((*this).typecheck_expression(rhs,scope_id,safety_mode,hint)))));
(checked_rhs = TRY((((*this).dereference_if_needed((original_checked_rhs.value()),span)))));
}

}
else {
(original_checked_lhs = TRY((((*this).typecheck_expression(lhs,scope_id,safety_mode,JaktInternal::OptionalNone())))));
(checked_lhs = TRY((((*this).dereference_if_needed((original_checked_lhs.value()),span)))));
ids::TypeId const hint = (((checked_lhs.value()))->type());
(original_checked_rhs = TRY((((*this).typecheck_expression(rhs,scope_id,safety_mode,hint)))));
(checked_rhs = TRY((((*this).dereference_if_needed((original_checked_rhs.value()),span)))));
}

if ((TRY((((*this).type_contains_reference((((original_checked_lhs.value()))->type()))))) && ((rhs)->__jakt_init_index() == 11 /* UnaryOp */))){
parser::UnaryOperator const op = (rhs)->as.UnaryOp.op;
if ((((op).__jakt_init_index() == 7 /* Reference */) || ((op).__jakt_init_index() == 8 /* MutableReference */))){
TRY((((*this).error_with_hint((ByteString::must_from_utf8("Attempt to rebind a reference will result in write-through"sv)),span,(ByteString::must_from_utf8("This reference will be immediately dereferenced and then assigned"sv)),((rhs)->span())))));
}
}
JaktInternal::Tuple<types::CheckedBinaryOperator,ids::TypeId> const checked_operator_output_type_ = TRY((((*this).typecheck_binary_operation((checked_lhs.value()),op,(checked_rhs.value()),scope_id,span))));
types::CheckedBinaryOperator const checked_operator = ((checked_operator_output_type_).template get<0>());
ids::TypeId const output_type = ((checked_operator_output_type_).template get<1>());

__jakt_var_575 = TRY((types::CheckedExpression::BinaryOp(JaktInternal::OptionalNone(),(checked_lhs.value()),checked_operator,(checked_rhs.value()),span,output_type))); goto __jakt_label_492;

}
__jakt_label_492:; __jakt_var_575.release_value(); }));
};/*case end*/
case 15 /* OptionalNone */: {
auto&& __jakt_match_value = __jakt_match_variant.as.OptionalNone;utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_576; {
JaktInternal::Optional<ids::TypeId> type_hint_unwrapped = type_hint;
if ((((type_hint).has_value()) && ((((*this).get_type((type_hint.value()))))->__jakt_init_index() == 20 /* GenericInstance */))){
ids::StructId const id = (((*this).get_type((type_hint.value()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type((type_hint.value()))))->as.GenericInstance.args;
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
if (((id).equals(optional_struct_id))){
(type_hint_unwrapped = ((args)[static_cast<i64>(0LL)]));
}
}
__jakt_var_576 = TRY((types::CheckedExpression::OptionalNone(JaktInternal::OptionalNone(),span,type_hint_unwrapped.value_or_lazy_evaluated([&] { return types::unknown_type_id(); })))); goto __jakt_label_493;

}
__jakt_label_493:; __jakt_var_576.release_value(); }));
};/*case end*/
case 14 /* OptionalSome */: {
auto&& __jakt_match_value = __jakt_match_variant.as.OptionalSome;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_577; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
ids::TypeId const type_id = ((checked_expr)->type());
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
NonnullRefPtr<typename types::Type> const optional_type = TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({type_id})))))));
ids::TypeId const optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_577 = TRY((types::CheckedExpression::OptionalSome(JaktInternal::OptionalNone(),checked_expr,span,optional_type_id))); goto __jakt_label_494;

}
__jakt_label_494:; __jakt_var_577.release_value(); }));
};/*case end*/
case 9 /* Var */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Var;ByteString const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
JaktInternal::Optional<NonnullRefPtr<types::CheckedVariable>> const var = TRY((((*this).find_var_in_scope(scope_id,name,JaktInternal::OptionalNone()))));
return ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>,ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto __jakt_enum_value = (((var).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::Var(JaktInternal::OptionalNone(),(var.value()),span))));
}
else {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_578; {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Variable '{}' not found"sv)),name))),span))));
__jakt_var_578 = TRY((types::CheckedExpression::Var(JaktInternal::OptionalNone(),TRY((types::CheckedVariable::__jakt_create(name,((type_hint).value_or(types::unknown_type_id())),false,span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))),span))); goto __jakt_label_495;

}
__jakt_label_495:; __jakt_var_578.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
};/*case end*/
case 21 /* ForcedUnwrap */: {
auto&& __jakt_match_value = __jakt_match_variant.as.ForcedUnwrap;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_579; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(((checked_expr)->type())));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
ids::StructId const weakptr_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv))))));
ids::TypeId const type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_580; {
ids::TypeId inner_type_id = types::unknown_type_id();
if ((((id).equals(optional_struct_id)) || ((id).equals(weakptr_struct_id)))){
(inner_type_id = ((args)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Forced unwrap only works on Optional"sv)),span))));
}

__jakt_var_580 = inner_type_id; goto __jakt_label_497;

}
__jakt_label_497:; __jakt_var_580.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_581; {
TRY((((*this).error((ByteString::must_from_utf8("Forced unwrap only works on Optional"sv)),span))));
__jakt_var_581 = types::unknown_type_id(); goto __jakt_label_498;

}
__jakt_label_498:; __jakt_var_581.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
__jakt_var_579 = TRY((types::CheckedExpression::ForcedUnwrap(JaktInternal::OptionalNone(),checked_expr,span,type_id))); goto __jakt_label_496;

}
__jakt_label_496:; __jakt_var_579.release_value(); }));
};/*case end*/
case 16 /* JaktArray */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktArray;JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedExpression>> const& values = __jakt_match_value.values;
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const& fill_size = __jakt_match_value.fill_size;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_array(scope_id,values,fill_size,span,safety_mode,type_hint)))));
};/*case end*/
case 19 /* JaktTuple */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktTuple;JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_582; {
ids::TypeId const VOID_TYPE_ID = types::builtin(types::BuiltinType::Void());
JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> checked_values = (TRY((DynamicArray<NonnullRefPtr<typename types::CheckedExpression>>::create_with({}))));
JaktInternal::DynamicArray<ids::TypeId> checked_types = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedExpression>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedExpression> value = (_magic_value.value());
{
NonnullRefPtr<typename types::CheckedExpression> const checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,JaktInternal::OptionalNone()))));
ids::TypeId const type_id = ((checked_value)->type());
if (((type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error((ByteString::must_from_utf8("Cannot create a tuple that contains a value of type void"sv)),((value)->span())))));
}
TRY((((checked_types).push(type_id))));
TRY((((checked_values).push(checked_value))));
}

}
}

if ((((type_hint).has_value()) && ((((*this).get_type((type_hint.value()))))->__jakt_init_index() == 20 /* GenericInstance */))){
ids::StructId const id = (((*this).get_type((type_hint.value()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type((type_hint.value()))))->as.GenericInstance.args;
if (((((checked_types).size())) == (((args).size())))){
{
JaktInternal::Range<size_t> _magic = (JaktInternal::Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((args).size()))});
for (;;){
JaktInternal::Optional<size_t> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
ids::TypeId value_type = ((checked_types)[i]);
JaktInternal::Optional<ids::TypeId> const unified = TRY((((*this).unify(((args)[i]),span,value_type,span))));
if (((unified).has_value())){
bool type_optional = false;
if (((((*this).get_type((unified.value()))))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type((unified.value()))))->as.GenericInstance.id;
if (((id).equals(optional_struct_id))){
(type_optional = true);
}
}
bool value_optional = false;
if (((((*this).get_type(value_type)))->__jakt_init_index() == 20 /* GenericInstance */)){
ids::StructId const id = (((*this).get_type(value_type)))->as.GenericInstance.id;
if (((id).equals(optional_struct_id))){
(value_optional = true);
}
}
(((checked_types)[i]) = (unified.value()));
if ((type_optional && ((!(value_optional)) && (!(((((checked_values)[i]))->__jakt_init_index() == 26 /* OptionalSome */)))))){
if ((((((checked_values)[i]))->__jakt_init_index() == 25 /* OptionalNone */) && ((((*this).get_type((unified.value()))))->__jakt_init_index() == 20 /* GenericInstance */))){
ids::StructId const id = (((*this).get_type((unified.value()))))->as.GenericInstance.id;
JaktInternal::DynamicArray<ids::TypeId> const args = (((*this).get_type((unified.value()))))->as.GenericInstance.args;
(value_type = ((args)[static_cast<i64>(0LL)]));
}
NonnullRefPtr<typename types::Type> const optional_type = TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({value_type})))))));
ids::TypeId const optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
(((checked_values)[i]) = TRY((types::CheckedExpression::OptionalSome(JaktInternal::OptionalNone(),((checked_values)[i]),span,optional_type_id))));
}
}
}

}
}

}
}
ids::StructId const tuple_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Tuple"sv))))));
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),tuple_struct_id,checked_types)))))));
if (((type_hint).has_value())){
TRY((((*this).check_types_for_compat((type_hint.value()),type_id,((((*this).generic_inferences))),span))));
}
__jakt_var_582 = TRY((types::CheckedExpression::JaktTuple(JaktInternal::OptionalNone(),checked_values,span,type_id))); goto __jakt_label_499;

}
__jakt_label_499:; __jakt_var_582.release_value(); }));
};/*case end*/
case 10 /* IndexedExpression */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedExpression;NonnullRefPtr<typename parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<typename parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_583; {
NonnullRefPtr<typename types::CheckedExpression> const checked_base = TRY((((*this).typecheck_expression_and_dereference_if_needed(base,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
NonnullRefPtr<typename types::CheckedExpression> const checked_index = TRY((((*this).typecheck_expression_and_dereference_if_needed(index,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
__jakt_var_583 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typename types::CheckedExpression>, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((checked_base)->type())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_584; {
ids::StructId const array_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Array"sv))))));
ids::StructId const array_slice_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("ArraySlice"sv))))));
ids::StructId const dictionary_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Dictionary"sv))))));
NonnullRefPtr<typename types::CheckedExpression> result = TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void()))));
if ((((id).equals(array_struct_id)) || ((id).equals(array_slice_struct_id)))){
if ((((*this).is_integer(((checked_index)->type()))) || ((checked_index)->__jakt_init_index() == 9 /* Range */))){
ids::TypeId const type_id = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_index;
switch(__jakt_match_variant.__jakt_init_index()) {
case 9 /* Range */: {
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_585; {
ids::StructId const array_slice_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("ArraySlice"sv))))));
__jakt_var_585 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),array_slice_struct_id,args))))))); goto __jakt_label_502;

}
__jakt_label_502:; __jakt_var_585.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
(result = TRY((types::CheckedExpression::IndexedExpression(JaktInternal::OptionalNone(),checked_base,checked_index,span,type_id))));
}
else {
TRY((((*this).error((ByteString::must_from_utf8("Index must be an integer or a range"sv)),span))));
}

}
else if (((id).equals(dictionary_struct_id))){
(result = TRY((types::CheckedExpression::IndexedDictionary(JaktInternal::OptionalNone(),checked_base,checked_index,span,((args)[static_cast<i64>(1LL)])))));
}
__jakt_var_584 = result; goto __jakt_label_501;

}
__jakt_label_501:; __jakt_var_584.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_586; {
TRY((((*this).error((ByteString::must_from_utf8("Index used on value that cannot be indexed"sv)),span))));
__jakt_var_586 = TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void())))); goto __jakt_label_503;

}
__jakt_label_503:; __jakt_var_586.release_value(); }));
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_500;

}
__jakt_label_500:; __jakt_var_583.release_value(); }));
};/*case end*/
case 6 /* IndexedTuple */: {
auto&& __jakt_match_value = __jakt_match_variant.as.IndexedTuple;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_tuple(expr,index,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 29 /* Garbage */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Garbage;utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void())))));
};/*case end*/
case 24 /* NamespacedVar */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NamespacedVar;ByteString const& name = __jakt_match_value.name;
JaktInternal::DynamicArray<ByteString> const& namespace_ = __jakt_match_value.namespace_;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_namespaced_var_or_simple_enum_constructor_call(name,namespace_,scope_id,safety_mode,type_hint,span)))));
};/*case end*/
case 22 /* Match */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Match;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
JaktInternal::DynamicArray<parser::ParsedMatchCase> const& cases = __jakt_match_value.cases;
utility::Span const& marker_span = __jakt_match_value.marker_span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_match(expr,cases,marker_span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 23 /* EnumVariantArg */: {
auto&& __jakt_match_value = __jakt_match_variant.as.EnumVariantArg;NonnullRefPtr<typename parser::ParsedExpression> const& inner_expr = __jakt_match_value.expr;
parser::EnumVariantPatternArgument const& arg = __jakt_match_value.arg;
NonnullRefPtr<typename parser::ParsedType> const& enum_variant = __jakt_match_value.enum_variant;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typename types::CheckedExpression>> __jakt_var_587; {
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(inner_expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
types::CheckedEnumVariantBinding checked_binding = types::CheckedEnumVariantBinding((ByteString::must_from_utf8(""sv)),(ByteString::must_from_utf8(""sv)),types::unknown_type_id(),span);
JaktInternal::Optional<types::CheckedEnumVariant> checked_enum_variant = JaktInternal::OptionalNone();
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *enum_variant;
switch(__jakt_match_variant.__jakt_init_index()) {
case 1 /* NamespacedName */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NamespacedName;ByteString const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((checked_expr)->type())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::Optional<types::CheckedEnumVariant> const variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
JaktInternal::Optional<JaktInternal::DynamicArray<types::CheckedEnumVariantBinding>> const checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((DynamicArray<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
if (((checked_bindings).has_value())){
JaktInternal::DynamicArray<types::CheckedEnumVariantBinding> const bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant {} does not exist"sv)),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type or invalid type name: {}"sv)),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
})), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0 /* Name */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Name;ByteString const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((checked_expr)->type())));
switch(__jakt_match_variant.__jakt_init_index()) {
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
JaktInternal::Optional<types::CheckedEnumVariant> const variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
JaktInternal::Optional<JaktInternal::DynamicArray<types::CheckedEnumVariantBinding>> const checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((DynamicArray<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
if (((checked_bindings).has_value())){
JaktInternal::DynamicArray<types::CheckedEnumVariantBinding> const bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Enum variant {} does not exist"sv)),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type or invalid type name: {}"sv)),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
})), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
NonnullRefPtr<typename types::CheckedExpression> output = TRY((types::CheckedExpression::Garbage(JaktInternal::OptionalNone(),span,types::builtin(types::BuiltinType::Void()))));
if (((checked_enum_variant).has_value())){
(output = TRY((types::CheckedExpression::EnumVariantArg(JaktInternal::OptionalNone(),checked_expr,checked_binding,(checked_enum_variant.value()),span))));
}
__jakt_var_587 = output; goto __jakt_label_504;

}
__jakt_label_504:; __jakt_var_587.release_value(); }));
};/*case end*/
case 17 /* JaktDictionary */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktDictionary;JaktInternal::DynamicArray<JaktInternal::Tuple<NonnullRefPtr<typename parser::ParsedExpression>,NonnullRefPtr<typename parser::ParsedExpression>>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_dictionary(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 18 /* Set */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Set;JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_set(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 25 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;JaktInternal::DynamicArray<parser::ParsedCapture> const& captures = __jakt_match_value.captures;
JaktInternal::DynamicArray<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
bool const& is_fat_arrow = __jakt_match_value.is_fat_arrow;
NonnullRefPtr<typename parser::ParsedType> const& return_type = __jakt_match_value.return_type;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_lambda(captures,params,can_throw,is_fat_arrow,return_type,block,span,scope_id,safety_mode)))));
};/*case end*/
case 26 /* Try */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Try;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
JaktInternal::Optional<parser::ParsedBlock> const& catch_block = __jakt_match_value.catch_block;
JaktInternal::Optional<utility::Span> const& catch_span = __jakt_match_value.catch_span;
JaktInternal::Optional<ByteString> const& catch_name = __jakt_match_value.catch_name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_try(expr,catch_block,catch_span,catch_name,scope_id,safety_mode,span,type_hint)))));
};/*case end*/
case 27 /* TryBlock */: {
auto&& __jakt_match_value = __jakt_match_variant.as.TryBlock;NonnullRefPtr<typename parser::ParsedStatement> const& stmt = __jakt_match_value.stmt;
parser::ParsedBlock const& catch_block = __jakt_match_value.catch_block;
ByteString const& error_name = __jakt_match_value.error_name;
utility::Span const& error_span = __jakt_match_value.error_span;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_try_block(stmt,error_name,error_span,catch_block,scope_id,safety_mode,span)))));
};/*case end*/
case 30 /* Unsafe */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Unsafe;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression(expr,scope_id,types::SafetyMode::Unsafe(),type_hint)))));
};/*case end*/
case 13 /* Operator */: {
{
TRY((((((*this).compiler))->panic((ByteString::must_from_utf8("idk how to handle this thing"sv))))));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_indexed_struct(NonnullRefPtr<typename parser::ParsedExpression> const expr,ByteString const field_name,ids::ScopeId const scope_id,bool const is_optional,types::SafetyMode const safety_mode,utility::Span const span) {
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
ids::TypeId const checked_expr_type_id = ((checked_expr)->type());
NonnullRefPtr<typename types::Type> const checked_expr_type = ((*this).get_type(checked_expr_type_id));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_expr_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
ids::TypeId type_id = checked_expr_type_id;
if (is_optional){
if ((!(((id).equals(optional_struct_id))))){
TRY((((*this).error((ByteString::must_from_utf8("Optional chaining is only allowed on optional types"sv)),span))));
return TRY((types::CheckedExpression::IndexedStruct(JaktInternal::OptionalNone(),checked_expr,field_name,JaktInternal::OptionalNone(),span,is_optional,types::unknown_type_id())));
}
(type_id = ((args)[static_cast<i64>(0LL)]));
}
NonnullRefPtr<typename types::Type> const type = ((*this).get_type(type_id));
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const checkpoint = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_588([&] {
((((*this).generic_inferences)).restore(checkpoint));
});
TRY((((*this).map_generic_arguments(type_id,args))));
({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typename types::CheckedExpression>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 20 /* GenericInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericInstance;ids::StructId const& struct_id = __jakt_match_value.id;
{
types::CheckedStruct const structure = ((*this).get_struct(struct_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((structure).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedStruct(JaktInternal::OptionalNone(),checked_expr,field_name,((field).variable_id),span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown member of struct: {}.{}"sv)),((structure).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
types::CheckedStruct const structure = ((*this).get_struct(struct_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((structure).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedStruct(JaktInternal::OptionalNone(),checked_expr,field_name,((field).variable_id),span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown member of struct: {}.{}"sv)),((structure).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((enum_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((enum_).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedCommonEnumMember(JaktInternal::OptionalNone(),checked_expr,field_name,span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown common member of enum: {}.{}"sv)),((enum_).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
{
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((enum_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((enum_).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedCommonEnumMember(JaktInternal::OptionalNone(),checked_expr,field_name,span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown common member of enum: {}.{}"sv)),((enum_).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Member field access on value of non-struct type ‘{}’"sv)),TRY((((*this).type_name(checked_expr_type_id,false))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24 /* Struct */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Struct;ids::StructId const& struct_id = __jakt_match_value.value;
{
if (is_optional){
TRY((((*this).error((ByteString::must_from_utf8("Optional chaining is not allowed on non-optional types"sv)),span))));
}
types::CheckedStruct const structure = ((*this).get_struct(struct_id));
JaktInternal::Optional<types::FieldRecord> const field_record = TRY((((*this).lookup_struct_field(struct_id,field_name))));
if (((field_record).has_value())){
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable((((field_record.value())).field_id)));
ids::TypeId const resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
TRY((((*this).check_member_access(scope_id,((((*this).get_struct((((field_record.value())).struct_id)))).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedStruct(JaktInternal::OptionalNone(),checked_expr,field_name,(((field_record.value())).field_id),span,is_optional,resolved_type_id)));
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown member of struct: {}.{}"sv)),((structure).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21 /* GenericEnumInstance */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericEnumInstance;ids::EnumId const& enum_id = __jakt_match_value.id;
JaktInternal::DynamicArray<ids::TypeId> const& args = __jakt_match_value.args;
{
if (is_optional){
TRY((((*this).error((ByteString::must_from_utf8("Optional chaining is not allowed on non-optional types"sv)),span))));
}
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const checkpoint = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_589([&] {
((((*this).generic_inferences)).restore(checkpoint));
});
TRY((((*this).map_generic_arguments(checked_expr_type_id,args))));
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((enum_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((enum_).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedCommonEnumMember(JaktInternal::OptionalNone(),checked_expr,field_name,span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown common member of enum: {}.{}"sv)),((enum_).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25 /* Enum */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Enum;ids::EnumId const& enum_id = __jakt_match_value.value;
JaktInternal::DynamicArray<ids::TypeId> const args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
if (is_optional){
TRY((((*this).error((ByteString::must_from_utf8("Optional chaining is not allowed on non-optional types"sv)),span))));
}
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const checkpoint = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_590([&] {
((((*this).generic_inferences)).restore(checkpoint));
});
TRY((((*this).map_generic_arguments(checked_expr_type_id,args))));
types::CheckedEnum const enum_ = ((*this).get_enum(enum_id));
{
JaktInternal::ArrayIterator<types::CheckedField> _magic = ((((enum_).fields)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedField> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedField field = (_magic_value.value());
{
NonnullRefPtr<types::CheckedVariable> const member = ((*this).get_variable(((field).variable_id)));
if (((((member)->name)) == (field_name))){
ids::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member)->type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((enum_).scope_id),member,span))));
return TRY((types::CheckedExpression::IndexedCommonEnumMember(JaktInternal::OptionalNone(),checked_expr,field_name,span,is_optional,resolved_type_id)));
}
}

}
}

TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("unknown common member of enum: {}.{}"sv)),((enum_).name),field_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Member field access on value of non-struct type ‘{}’"sv)),TRY((((*this).type_name(checked_expr_type_id,false))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
return TRY((types::CheckedExpression::IndexedStruct(JaktInternal::OptionalNone(),checked_expr,field_name,JaktInternal::OptionalNone(),span,is_optional,types::unknown_type_id())));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_imports(parser::ParsedNamespace const parsed_namespace,ids::ScopeId const scope_id) {
{
{
JaktInternal::ArrayIterator<parser::ParsedModuleImport> _magic = ((((parsed_namespace).module_imports)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedModuleImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedModuleImport module_import = (_magic_value.value());
{
TRY((((*this).typecheck_module_import(module_import,scope_id))));
}

}
}

JaktInternal::DynamicArray<parser::ParsedExternImport> coalesced_imports = (TRY((DynamicArray<parser::ParsedExternImport>::create_with({}))));
{
JaktInternal::ArrayIterator<parser::ParsedExternImport> _magic = ((((parsed_namespace).extern_imports)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
if ((!(((extern_import).should_auto_import)))){
continue;
}
ByteString const path = ((extern_import).get_path());
JaktInternal::Optional<ids::ScopeId> const existing_scope = ((((*this).cpp_import_cache)).get(path));
if (((existing_scope).has_value())){
ids::ScopeId const import_scope_id = (existing_scope.value());
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((((scope)->resolution_mixins)).push(import_scope_id))));
if (((((((extern_import).assigned_namespace)).name)).has_value())){
(((TRY((((*this).get_scope(import_scope_id)))))->namespace_name) = (((((extern_import).assigned_namespace)).name).value()));
(((TRY((((*this).get_scope(import_scope_id)))))->external_name) = parser::ExternalName::Plain((ByteString::must_from_utf8(""sv))));
}
continue;
}
TRY((((coalesced_imports).push(extern_import))));
}

}
}

if ((!(((coalesced_imports).is_empty())))){
ids::ScopeId const child_scope_id = TRY((((*this).create_scope(((*this).root_scope_id()),false,(ByteString::must_from_utf8("coalesced-extern-imports"sv)),false))));
{
NonnullRefPtr<types::Scope> scope = TRY((((*this).get_scope(scope_id))));
TRY((((((scope)->resolution_mixins)).push(child_scope_id))));
}

TRY((((*this).typecheck_auto_extern_imports(coalesced_imports,child_scope_id))));
}
{
JaktInternal::ArrayIterator<parser::ParsedExternImport> _magic = ((((parsed_namespace).extern_imports)).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedExternImport> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
if ((!(((extern_import).should_auto_import)))){
TRY((((*this).typecheck_extern_import(extern_import,scope_id))));
}
}

}
}

}
return {};
}

ErrorOr<jakt__path::Path> typechecker::Typechecker::get_root_path() const {
{
JaktInternal::Optional<types::LoadedModule> const root_module = ((((*this).program))->get_loaded_module(((*this).root_module_name)));
if (((root_module).has_value())){
utility::FileId const file_id = (((root_module.value())).file_id);
return (TRY((((((*this).compiler))->get_file_path(file_id)))).value());
}
return TRY((jakt__path::Path::from_string((ByteString::must_from_utf8("."sv)))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_trait_implementations(ids::ScopeId const scope_id) {
{
NonnullRefPtr<types::Scope> const scope = TRY((((*this).get_scope(scope_id))));
{
JaktInternal::ArrayIterator<ids::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
JaktInternal::Optional<ids::ScopeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::ScopeId child = (_magic_value.value());
{
TRY((((*this).typecheck_namespace_trait_implementations(child))));
}

}
}

{
JaktInternal::DictionaryIterator<ByteString,ids::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
JaktInternal::Optional<JaktInternal::Tuple<ByteString,ids::StructId>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
JaktInternal::Tuple<ByteString,ids::StructId> ___struct_id__ = (_magic_value.value());
{
JaktInternal::Tuple<ByteString,ids::StructId> const jakt_____struct_id__ = ___struct_id__;
ByteString const _ = ((jakt_____struct_id__).template get<0>());
ids::StructId const struct_id = ((jakt_____struct_id__).template get<1>());

types::CheckedStruct const struct_ = ((*this).get_struct(struct_id));
if (((((struct_).trait_implementations)).is_empty())){
continue;
}
TRY((((*this).typecheck_entity_trait_implementations(((struct_).scope_id),((struct_).type_id),((struct_).trait_implementations),((struct_).name),((struct_).name_span)))));
}

}
}

}
return {};
}

ErrorOr<JaktInternal::Optional<typechecker::TraitImplementationDescriptor>> typechecker::Typechecker::find_singular_trait_implementation(ids::TypeId const type_id,ByteString const trait_name,ids::ScopeId const scope_id,utility::Span const span,JaktInternal::Optional<JaktInternal::DynamicArray<ids::TypeId>> const filter_for_generics) {
{
JaktInternal::Optional<ids::TraitId> const trait_id = TRY((((*this).find_trait_in_scope(scope_id,trait_name))));
if ((!(((trait_id).has_value())))){
return JaktInternal::OptionalNone();
}
JaktInternal::DynamicArray<JaktInternal::DynamicArray<ids::TypeId>> const trait_impls = TRY((((*this).find_all_implementations_of_trait(type_id,(trait_id.value()),filter_for_generics))));
if (((trait_impls).is_empty())){
return JaktInternal::OptionalNone();
}
if ([](size_t const& self, size_t rhs) -> bool {
{
return (((infallible_integer_cast<u8>(([](size_t const& self, size_t rhs) -> jakt__prelude__operators::Ordering {
{
return (infallible_enum_cast<jakt__prelude__operators::Ordering>((JaktInternal::compare(self,rhs))));
}
}
(self,rhs))))) == (static_cast<u8>(2)));
}
}
(((trait_impls).size()),static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("type ‘{}’ implements trait ‘{}’ more than once, but a singular implementation is allowed"sv)),TRY((((*this).type_name(type_id,false)))),trait_name))),span))));
}
return typechecker::TraitImplementationDescriptor((trait_id.value()),trait_name,((trait_impls)[static_cast<i64>(0LL)]));
}
}

ErrorOr<ids::TypeId> typechecker::Typechecker::typecheck_typename(NonnullRefPtr<typename parser::ParsedType> const parsed_type,ids::ScopeId const scope_id,JaktInternal::Optional<ByteString> const name) {
{
ids::TypeId const output = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId, ErrorOr<ids::TypeId>>{
auto&& __jakt_match_variant = *parsed_type;
switch(__jakt_match_variant.__jakt_init_index()) {
case 14 /* DependentType */: {
auto&& __jakt_match_value = __jakt_match_variant.as.DependentType;NonnullRefPtr<typename parser::ParsedType> const& base = __jakt_match_value.base;
ByteString const& dependent_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_591; {
ids::TypeId const base_type = TRY((((*this).typecheck_typename(base,scope_id,name))));
ids::TypeId const type_id = TRY((((*this).find_or_add_type_id(TRY((types::Type::Dependent(parser::CheckedQualifiers(false),base_type,dependent_name)))))));
__jakt_var_591 = TRY((((*this).substitute_typevars_in_type(type_id,((*this).generic_inferences))))); goto __jakt_label_505;

}
__jakt_label_505:; __jakt_var_591.release_value(); }));
};/*case end*/
case 13 /* Const */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Const;NonnullRefPtr<typename parser::ParsedExpression> const& expr = __jakt_match_value.expr;
{
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,types::SafetyMode::Safe(),JaktInternal::OptionalNone()))));
NonnullRefPtr<interpreter::Interpreter> interpreter = TRY((((*this).interpreter())));
NonnullRefPtr<interpreter::InterpreterScope> scope = TRY((interpreter::InterpreterScope::from_runtime_scope(scope_id,((*this).program),JaktInternal::OptionalNone())));
JaktInternal::Optional<interpreter::StatementResult> const value = ({ Optional<interpreter::StatementResult> __jakt_var_592;
auto __jakt_var_593 = [&]() -> ErrorOr<interpreter::StatementResult> { return TRY((((interpreter)->execute_expression(checked_expr,scope)))); }();
if (!__jakt_var_593.is_error()) __jakt_var_592 = __jakt_var_593.release_value();
__jakt_var_592; });
if ((((value).has_value()) && (((value.value())).__jakt_init_index() == 5 /* JustValue */))){
types::Value const resolved_value = ((value.value())).as.JustValue.value;
return TRY((((*this).find_or_add_type_id(TRY((types::Type::Const(parser::CheckedQualifiers(false),resolved_value)))))));
}
TRY((((*this).error((ByteString::must_from_utf8("Could not evaluate const expression"sv)),((expr)->span())))));
return TRY((((*this).find_or_add_type_id(TRY((types::Type::Unknown(parser::CheckedQualifiers(false))))))));
}
};/*case end*/
case 8 /* Reference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Reference;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_594; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
__jakt_var_594 = TRY((((*this).find_or_add_type_id(TRY((types::Type::Reference(parser::CheckedQualifiers(false),inner_type_id))))))); goto __jakt_label_506;

}
__jakt_label_506:; __jakt_var_594.release_value(); }));
};/*case end*/
case 9 /* MutableReference */: {
auto&& __jakt_match_value = __jakt_match_variant.as.MutableReference;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_595; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
__jakt_var_595 = TRY((((*this).find_or_add_type_id(TRY((types::Type::MutableReference(parser::CheckedQualifiers(false),inner_type_id))))))); goto __jakt_label_507;

}
__jakt_label_507:; __jakt_var_595.release_value(); }));
};/*case end*/
case 1 /* NamespacedName */: {
auto&& __jakt_match_value = __jakt_match_variant.as.NamespacedName;ByteString const& name = __jakt_match_value.name;
JaktInternal::DynamicArray<ByteString> const& namespaces = __jakt_match_value.namespaces;
JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedType>> const& params = __jakt_match_value.params;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_596; {
ids::ScopeId current_namespace_scope_id = scope_id;
{
JaktInternal::ArrayIterator<ByteString> _magic = ((namespaces).iterator());
for (;;){
JaktInternal::Optional<ByteString> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ByteString ns = (_magic_value.value());
{
JaktInternal::Optional<JaktInternal::Tuple<ids::ScopeId,bool>> const result = TRY((((*this).find_namespace_in_scope(current_namespace_scope_id,ns,false,JaktInternal::OptionalNone()))));
if (((result).has_value())){
(current_namespace_scope_id = (((result.value())).template get<0>()));
}
else {
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown namespace: '{}'"sv)),ns))),span))));
return types::unknown_type_id();
}

}

}
}

JaktInternal::DynamicArray<ids::TypeId> generic_args = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((params).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> param = (_magic_value.value());
{
ids::TypeId const checked_arg = TRY((((*this).typecheck_typename(param,scope_id,name))));
TRY((((generic_args).push(checked_arg))));
}

}
}

JaktInternal::Optional<ids::TypeId> type_id = JaktInternal::OptionalNone();
if (((generic_args).is_empty())){
NonnullRefPtr<typename parser::ParsedType> const synthetic_typename = TRY((parser::ParsedType::Name(((parsed_type)->common.init_common.qualifiers),name,span)));
(type_id = TRY((((*this).typecheck_typename(synthetic_typename,current_namespace_scope_id,name)))));
}
else {
(type_id = TRY((((*this).typecheck_generic_resolved_type(name,generic_args,current_namespace_scope_id,span)))));
}

__jakt_var_596 = (type_id.value()); goto __jakt_label_508;

}
__jakt_label_508:; __jakt_var_596.release_value(); }));
};/*case end*/
case 0 /* Name */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Name;ByteString const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_597; {
JaktInternal::Optional<JaktInternal::Tuple<ids::TypeId,ids::ScopeId>> const maybe_type_and_scope = TRY((((*this).find_type_scope(scope_id,name))));
if (((maybe_type_and_scope).has_value())){
if ((!((((((maybe_type_and_scope.value())).template get<1>())).equals(((*this).prelude_scope_id())))))){
return TRY((((*this).with_qualifiers(((*this).typecheck_type_qualifiers(((parsed_type)->common.init_common.qualifiers))),(((maybe_type_and_scope.value())).template get<0>())))));
}
}
__jakt_var_597 = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ids::TypeId,ErrorOr<ids::TypeId>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == (ByteString::must_from_utf8("i8"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::I8()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("i16"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::I16()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("i32"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::I32()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("i64"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::I64()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("u8"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::U8()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("u16"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::U16()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("u32"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::U32()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("u64"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::U64()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("f32"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::F32()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("f64"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::F64()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("c_char"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::CChar()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("c_int"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::CInt()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("usize"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::Usize()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("bool"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::Bool()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("void"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::Void()));
}
else if (__jakt_enum_value == (ByteString::must_from_utf8("never"sv))) {
return JaktInternal::ExplicitValue(types::builtin(types::BuiltinType::Never()));
}
else {
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_598; {
if (((maybe_type_and_scope).has_value())){
return (((maybe_type_and_scope.value())).template get<0>());
}
if ((((TRY((((*this).get_scope(scope_id)))))->is_from_generated_code) && ((name) == ((ByteString::must_from_utf8("unknown"sv)))))){
return types::builtin(types::BuiltinType::Unknown());
}
TRY((((*this).error(TRY((__jakt_format((StringView::from_string_literal("Unknown type ‘{}’ in scope {}"sv)),name,TRY((((*this).debug_description_of(scope_id))))))),span))));
__jakt_var_598 = types::unknown_type_id(); goto __jakt_label_510;

}
__jakt_label_510:; __jakt_var_598.release_value(); }));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
}); goto __jakt_label_509;

}
__jakt_label_509:; __jakt_var_597.release_value(); }));
};/*case end*/
case 15 /* Empty */: {
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_599; {
__jakt_var_599 = types::unknown_type_id(); goto __jakt_label_511;

}
__jakt_label_511:; __jakt_var_599.release_value(); }));
};/*case end*/
case 5 /* JaktTuple */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktTuple;JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedType>> const& types = __jakt_match_value.types;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_600; {
JaktInternal::DynamicArray<ids::TypeId> checked_types = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((types).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> parsed_type = (_magic_value.value());
{
TRY((((checked_types).push(TRY((((*this).typecheck_typename(parsed_type,scope_id,name))))))));
}

}
}

ids::StructId const tuple_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Tuple"sv))))));
__jakt_var_600 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),tuple_struct_id,checked_types))))))); goto __jakt_label_512;

}
__jakt_label_512:; __jakt_var_600.release_value(); }));
};/*case end*/
case 3 /* JaktArray */: {
auto&& __jakt_match_value = __jakt_match_variant.as.JaktArray;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_601; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
ids::StructId const array_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Array"sv))))));
__jakt_var_601 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),array_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id}))))))))))); goto __jakt_label_513;

}
__jakt_label_513:; __jakt_var_601.release_value(); }));
};/*case end*/
case 4 /* Dictionary */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Dictionary;NonnullRefPtr<typename parser::ParsedType> const& key = __jakt_match_value.key;
NonnullRefPtr<typename parser::ParsedType> const& value = __jakt_match_value.value;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_602; {
ids::TypeId const key_type_id = TRY((((*this).typecheck_typename(key,scope_id,name))));
ids::TypeId const value_type_id = TRY((((*this).typecheck_typename(value,scope_id,name))));
ids::StructId const dict_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Dictionary"sv))))));
TRY((((*this).ensure_type_implements_trait(key_type_id,(ByteString::must_from_utf8("Hashable"sv)),JaktInternal::OptionalNone(),scope_id,span))));
TRY((((*this).ensure_type_implements_trait(key_type_id,(ByteString::must_from_utf8("Equal"sv)),(TRY((DynamicArray<ids::TypeId>::create_with({key_type_id})))),scope_id,span))));
__jakt_var_602 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),dict_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({key_type_id, value_type_id}))))))))))); goto __jakt_label_514;

}
__jakt_label_514:; __jakt_var_602.release_value(); }));
};/*case end*/
case 6 /* Set */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Set;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_603; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
ids::StructId const set_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Set"sv))))));
TRY((((*this).ensure_type_implements_trait(inner_type_id,(ByteString::must_from_utf8("Hashable"sv)),JaktInternal::OptionalNone(),scope_id,span))));
TRY((((*this).ensure_type_implements_trait(inner_type_id,(ByteString::must_from_utf8("Equal"sv)),(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id})))),scope_id,span))));
__jakt_var_603 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),set_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id}))))))))))); goto __jakt_label_515;

}
__jakt_label_515:; __jakt_var_603.release_value(); }));
};/*case end*/
case 7 /* Optional */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Optional;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_604; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
__jakt_var_604 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id}))))))))))); goto __jakt_label_516;

}
__jakt_label_516:; __jakt_var_604.release_value(); }));
};/*case end*/
case 11 /* WeakPtr */: {
auto&& __jakt_match_value = __jakt_match_variant.as.WeakPtr;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_605; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
ids::StructId const weakptr_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("WeakPtr"sv))))));
__jakt_var_605 = TRY((((*this).find_or_add_type_id(TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),weakptr_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({inner_type_id}))))))))))); goto __jakt_label_517;

}
__jakt_label_517:; __jakt_var_605.release_value(); }));
};/*case end*/
case 10 /* RawPtr */: {
auto&& __jakt_match_value = __jakt_match_variant.as.RawPtr;NonnullRefPtr<typename parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_606; {
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
__jakt_var_606 = TRY((((*this).find_or_add_type_id(TRY((types::Type::RawPtr(parser::CheckedQualifiers(false),inner_type_id))))))); goto __jakt_label_518;

}
__jakt_label_518:; __jakt_var_606.release_value(); }));
};/*case end*/
case 2 /* GenericType */: {
auto&& __jakt_match_value = __jakt_match_variant.as.GenericType;ByteString const& name = __jakt_match_value.name;
JaktInternal::DynamicArray<NonnullRefPtr<typename parser::ParsedType>> const& generic_parameters = __jakt_match_value.generic_parameters;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_607; {
JaktInternal::DynamicArray<ids::TypeId> checked_inner_types = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<NonnullRefPtr<typename parser::ParsedType>> _magic = ((generic_parameters).iterator());
for (;;){
JaktInternal::Optional<NonnullRefPtr<typename parser::ParsedType>> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typename parser::ParsedType> inner_type = (_magic_value.value());
{
ids::TypeId const inner_type_id = TRY((((*this).typecheck_typename(inner_type,scope_id,name))));
TRY((((checked_inner_types).push(inner_type_id))));
}

}
}

__jakt_var_607 = TRY((((*this).typecheck_generic_resolved_type(name,checked_inner_types,scope_id,span)))); goto __jakt_label_519;

}
__jakt_label_519:; __jakt_var_607.release_value(); }));
};/*case end*/
case 12 /* Function */: {
auto&& __jakt_match_value = __jakt_match_variant.as.Function;JaktInternal::DynamicArray<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
NonnullRefPtr<typename parser::ParsedType> const& return_type = __jakt_match_value.return_type;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<ids::TypeId> __jakt_var_608; {
ByteString const function_name = ({
    auto&& _jakt_value = ([&]() -> JaktInternal::ExplicitValueOrControlFlow<ByteString,ErrorOr<ids::TypeId>>{
auto __jakt_enum_value = (((name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((name.value()));
}
else {
return JaktInternal::ExplicitValue(TRY((({ Optional<ByteString> __jakt_var_609;
auto __jakt_var_610 = [&]() -> ErrorOr<ByteString> { return TRY((__jakt_format((StringView::from_string_literal("lambda{}"sv)),((((*this).lambda_count)++))))); }();
if (!__jakt_var_610.is_error()) __jakt_var_609 = __jakt_var_610.release_value();
__jakt_var_609; }).try_value_or_lazy_evaluated([&]() -> ErrorOr<ByteString> { return (ByteString::must_from_utf8(""sv)); }))));
}
}());
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
JaktInternal::DynamicArray<types::CheckedParameter> checked_params = (TRY((DynamicArray<types::CheckedParameter>::create_with({}))));
bool first = true;
JaktInternal::Dictionary<ids::TypeId,ids::TypeId> const old_generic_inferences = TRY((((((*this).generic_inferences)).perform_checkpoint(false))));
ScopeGuard __jakt_var_611([&] {
{
((((*this).generic_inferences)).restore(old_generic_inferences));
}

});
{
JaktInternal::ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
JaktInternal::Optional<parser::ParsedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((checked_params).push(TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))))))));
(first = false);
}

}
}

NonnullRefPtr<types::CheckedFunction> const checked_function = TRY((types::CheckedFunction::__jakt_create(function_name,span,types::CheckedVisibility::Public(),TRY((((*this).typecheck_typename(return_type,scope_id,JaktInternal::OptionalNone())))),((return_type)->span()),checked_params,TRY((types::FunctionGenerics::__jakt_create(scope_id,checked_params,(TRY((DynamicArray<types::FunctionGenericParameter>::create_with({})))),(TRY((DynamicArray<JaktInternal::DynamicArray<ids::TypeId>>::create_with({}))))))),types::CheckedBlock((TRY((DynamicArray<NonnullRefPtr<typename types::CheckedStatement>>::create_with({})))),scope_id,types::BlockControlFlow::MayReturn(),JaktInternal::OptionalNone(),false),can_throw,parser::FunctionType::Expression(),parser::FunctionLinkage::Internal(),scope_id,JaktInternal::OptionalNone(),true,JaktInternal::OptionalNone(),false,false,false,false,false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),false,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),parser::InlineState::Default())));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::FunctionId const function_id = TRY((((module)->add_function(checked_function))));
JaktInternal::DynamicArray<ids::TypeId> param_type_ids = (TRY((DynamicArray<ids::TypeId>::create_with({}))));
{
JaktInternal::ArrayIterator<types::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
JaktInternal::Optional<types::CheckedParameter> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
types::CheckedParameter param = (_magic_value.value());
{
TRY((((param_type_ids).push(((((param).variable))->type_id)))));
}

}
}

__jakt_var_608 = TRY((((*this).find_or_add_type_id(TRY((types::Type::Function(parser::CheckedQualifiers(false),param_type_ids,can_throw,((checked_function)->return_type_id),function_id))))))); goto __jakt_label_520;

}
__jakt_label_520:; __jakt_var_608.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
);
    if (_jakt_value.is_return())
        return _jakt_value.release_return();
    _jakt_value.release_value();
});
parser::CheckedQualifiers const qualifiers = ((*this).typecheck_type_qualifiers(((parsed_type)->common.init_common.qualifiers)));
return TRY((((*this).with_qualifiers(qualifiers,output))));
}
}

ErrorOr<NonnullRefPtr<typename types::CheckedExpression>> typechecker::Typechecker::typecheck_try(NonnullRefPtr<typename parser::ParsedExpression> const expr,JaktInternal::Optional<parser::ParsedBlock> const catch_block,JaktInternal::Optional<utility::Span> const catch_span,JaktInternal::Optional<ByteString> const catch_name,ids::ScopeId const scope_id,types::SafetyMode const safety_mode,utility::Span const span,JaktInternal::Optional<ids::TypeId> const type_hint) {
{
ids::ScopeId const try_scope_id = TRY((((*this).create_scope(scope_id,true,(ByteString::must_from_utf8("try"sv)),true))));
NonnullRefPtr<typename types::CheckedExpression> const checked_expr = TRY((((*this).typecheck_expression(expr,try_scope_id,safety_mode,type_hint))));
ids::StructId const error_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Error"sv))))));
NonnullRefPtr<types::Module> module = ((*this).current_module());
JaktInternal::Optional<types::CheckedBlock> checked_catch_block = JaktInternal::OptionalNone();
ids::TypeId const expression_type_id = ((checked_expr)->type());
ids::StructId const optional_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Optional"sv))))));
NonnullRefPtr<typename types::Type> const optional_type = TRY((types::Type::GenericInstance(parser::CheckedQualifiers(false),optional_struct_id,(TRY((DynamicArray<ids::TypeId>::create_with({expression_type_id})))))));
ids::TypeId const optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
ids::TypeId type_id = optional_type_id;
if (((catch_block).has_value())){
NonnullRefPtr<types::Scope> const parent_scope = TRY((((*this).get_scope(scope_id))));
ids::ScopeId const catch_scope_id = TRY((((*this).create_scope(scope_id,((parent_scope)->can_throw),(ByteString::must_from_utf8("catch"sv)),true))));
if (((catch_name).has_value())){
ids::StructId const error_struct_id = TRY((((*this).find_struct_in_prelude((ByteString::must_from_utf8("Error"sv))))));
NonnullRefPtr<types::CheckedVariable> const error_decl = TRY((types::CheckedVariable::__jakt_create((catch_name.value()),((((*this).get_struct(error_struct_id))).type_id),false,span,JaktInternal::OptionalNone(),types::CheckedVisibility::Public(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),JaktInternal::OptionalNone())));
NonnullRefPtr<types::Module> module = ((*this).current_module());
ids::VarId const error_id = TRY((((module)->add_variable(error_decl))));
TRY((((*this).add_var_to_scope(catch_scope_id,(catch_name.value()),error_id,span))));
}
types::CheckedBlock const block = TRY((((*this).typecheck_block((catch_block.value()),catch_scope_id,safety_mode,JaktInternal::OptionalNone()))));
if ((((((block).control_flow)).always_transfers_control()) || ((((block).yielded_type)).has_value()))){
if ((!(((((block).yielded_type).value_or_lazy_evaluated([&] { return expression_type_id; })).equals(expression_type_id))))){
TRY((((*this).error_with_hint(TRY((__jakt_format((StringView::from_string_literal("Expected a value of type ‘{}’, but got ‘{}’"sv)),TRY((((*this).type_name(expression_type_id,false)))),TRY((((*this).type_name((((block).yielded_type).value()),false))))))),span,TRY((__jakt_format((StringView::from_string_literal("Expression 'catch' block must either yield the same type as the expression it is catching, or yield nothing"sv))))),span))));
}
else {
(type_id = ((block).yielded_type).value_or_lazy_evaluated([&] { return expression_type_id; }));
}

}
else {
if ((!(((expression_type_id).equals(types::builtin(types::BuiltinType::Void())))))){
TRY((((*this).error((ByteString::must_from_utf8("In a try expression that returns a value, 'catch' block must either yield a value or transfer control flow"sv)),catch_span.value_or_lazy_evaluated([&] { return span; })))));
}
}

(checked_catch_block = block);
}
return TRY((types::CheckedExpression::Try(JaktInternal::OptionalNone(),checked_expr,checked_catch_block,catch_span,catch_name,span,type_id,expression_type_id)));
}
}

ids::TypeId typechecker::Typechecker::infer_function_return_type(types::CheckedBlock const block) const {
{
if (((((block).statements)).is_empty())){
return types::void_type_id();
}
if ((((((((block).statements)).last()).value()))->__jakt_init_index() == 8 /* Return */)){
JaktInternal::Optional<NonnullRefPtr<typename types::CheckedExpression>> const val = ((((((block).statements)).last()).value()))->as.Return.val;
if (((val).has_value())){
return (((val.value()))->type());
}
}
return types::void_type_id();
}
}

ErrorOr<bool> typechecker::Typechecker::scope_lifetime_subsumes(JaktInternal::Optional<ids::ScopeId> const larger,JaktInternal::Optional<ids::ScopeId> const smaller) const {
{
if ((!(((larger).has_value())))){
return false;
}
if ((!(((smaller).has_value())))){
return true;
}
ids::ScopeId const larger_id = (larger.value());
ids::ScopeId const smaller_id = (smaller.value());
if (((larger_id).equals(smaller_id))){
return false;
}
JaktInternal::Optional<ids::ScopeId> scope_id = ((TRY((((((*this).program))->get_scope(smaller_id)))))->parent);
while (((scope_id).has_value())){
if ((((scope_id.value())).equals(larger_id))){
return true;
}
NonnullRefPtr<types::Scope> const scope = TRY((((((*this).program))->get_scope((scope_id.value())))));
{
JaktInternal::ArrayIterator<ids::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
JaktInternal::Optional<ids::ScopeId> const _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
ids::ScopeId child_scope_id = (_magic_value.value());
{
if (((child_scope_id).equals(larger_id))){
return true;
}
}

}
}

(scope_id = ((scope)->parent));
}
return false;
}
}

ErrorOr<ByteString> typechecker::NumericOrStringValue::debug_description() const {
auto builder = ByteStringBuilder::create();
switch (this->__jakt_init_index()) {case 0 /* StringValue */: {
TRY(builder.append("NumericOrStringValue::StringValue"sv));
[[maybe_unused]] auto const& that = this->as.StringValue;
TRY(builder.appendff("(\"{}\")", that.value));
break;}
case 1 /* SignedNumericValue */: {
TRY(builder.append("NumericOrStringValue::SignedNumericValue"sv));
[[maybe_unused]] auto const& that = this->as.SignedNumericValue;
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* UnsignedNumericValue */: {
TRY(builder.append("NumericOrStringValue::UnsignedNumericValue"sv));
[[maybe_unused]] auto const& that = this->as.UnsignedNumericValue;
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}
[[nodiscard]] NumericOrStringValue NumericOrStringValue::StringValue(ByteString value){
NumericOrStringValue __jakt_uninit_enum;
__jakt_uninit_enum.__jakt_variant_index = 1;
new (&__jakt_uninit_enum.as.StringValue.value) (decltype(value))(move(value));
return __jakt_uninit_enum;
}
[[nodiscard]] NumericOrStringValue NumericOrStringValue::SignedNumericValue(i64 value){
NumericOrStringValue __jakt_uninit_enum;
__jakt_uninit_enum.__jakt_variant_index = 2;
new (&__jakt_uninit_enum.as.SignedNumericValue.value) (decltype(value))(move(value));
return __jakt_uninit_enum;
}
[[nodiscard]] NumericOrStringValue NumericOrStringValue::UnsignedNumericValue(u64 value){
NumericOrStringValue __jakt_uninit_enum;
__jakt_uninit_enum.__jakt_variant_index = 3;
new (&__jakt_uninit_enum.as.UnsignedNumericValue.value) (decltype(value))(move(value));
return __jakt_uninit_enum;
}
NumericOrStringValue& NumericOrStringValue::operator=(NumericOrStringValue const &rhs){
{VERIFY(this->__jakt_variant_index != 0 && rhs.__jakt_variant_index != 0);
if (this->__jakt_variant_index != rhs.__jakt_variant_index) {
this->__jakt_destroy_variant();
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
new (&this->as.StringValue.value) (decltype(this->as.StringValue.value))(rhs.as.StringValue.value);
break;
case 1 /* SignedNumericValue */:
new (&this->as.SignedNumericValue.value) (decltype(this->as.SignedNumericValue.value))(rhs.as.SignedNumericValue.value);
break;
case 2 /* UnsignedNumericValue */:
new (&this->as.UnsignedNumericValue.value) (decltype(this->as.UnsignedNumericValue.value))(rhs.as.UnsignedNumericValue.value);
break;
}
} else {
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
this->as.StringValue.value = rhs.as.StringValue.value;
break;
case 1 /* SignedNumericValue */:
this->as.SignedNumericValue.value = rhs.as.SignedNumericValue.value;
break;
case 2 /* UnsignedNumericValue */:
this->as.UnsignedNumericValue.value = rhs.as.UnsignedNumericValue.value;
break;
}
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
return *this;
}
NumericOrStringValue::NumericOrStringValue(NumericOrStringValue const &rhs){VERIFY(rhs.__jakt_variant_index != 0);
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
new (&this->as.StringValue.value) (decltype(this->as.StringValue.value))(rhs.as.StringValue.value);
break;
case 1 /* SignedNumericValue */:
new (&this->as.SignedNumericValue.value) (decltype(this->as.SignedNumericValue.value))(rhs.as.SignedNumericValue.value);
break;
case 2 /* UnsignedNumericValue */:
new (&this->as.UnsignedNumericValue.value) (decltype(this->as.UnsignedNumericValue.value))(rhs.as.UnsignedNumericValue.value);
break;
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
NumericOrStringValue& NumericOrStringValue::operator=(NumericOrStringValue &&rhs){
{VERIFY(this->__jakt_variant_index != 0 && rhs.__jakt_variant_index != 0);
if (this->__jakt_variant_index != rhs.__jakt_variant_index) {
this->__jakt_destroy_variant();
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
new (&this->as.StringValue.value) (decltype(this->as.StringValue.value))(move(rhs.as.StringValue.value));
break;
case 1 /* SignedNumericValue */:
new (&this->as.SignedNumericValue.value) (decltype(this->as.SignedNumericValue.value))(move(rhs.as.SignedNumericValue.value));
break;
case 2 /* UnsignedNumericValue */:
new (&this->as.UnsignedNumericValue.value) (decltype(this->as.UnsignedNumericValue.value))(move(rhs.as.UnsignedNumericValue.value));
break;
}
} else {
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
this->as.StringValue.value = move(rhs.as.StringValue.value);
break;
case 1 /* SignedNumericValue */:
this->as.SignedNumericValue.value = move(rhs.as.SignedNumericValue.value);
break;
case 2 /* UnsignedNumericValue */:
this->as.UnsignedNumericValue.value = move(rhs.as.UnsignedNumericValue.value);
break;
}
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
return *this;
}
NumericOrStringValue::NumericOrStringValue(NumericOrStringValue &&rhs){
{VERIFY(rhs.__jakt_variant_index != 0);
switch (rhs.__jakt_init_index()) {
case 0 /* StringValue */:
new (&this->as.StringValue.value) (decltype(this->as.StringValue.value))(move(rhs.as.StringValue.value));
break;
case 1 /* SignedNumericValue */:
new (&this->as.SignedNumericValue.value) (decltype(this->as.SignedNumericValue.value))(move(rhs.as.SignedNumericValue.value));
break;
case 2 /* UnsignedNumericValue */:
new (&this->as.UnsignedNumericValue.value) (decltype(this->as.UnsignedNumericValue.value))(move(rhs.as.UnsignedNumericValue.value));
break;
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
}
NumericOrStringValue::~NumericOrStringValue(){
if (this->__jakt_variant_index == 0) return;
this->__jakt_destroy_variant();
}
void NumericOrStringValue::__jakt_destroy_variant() {
switch (this->__jakt_init_index()) {
case 0 /* StringValue */:this->as.StringValue.value.~ByteString();
break;
case 1 /* SignedNumericValue */:break;
case 2 /* UnsignedNumericValue */:break;
}
}
ErrorOr<ByteString> typechecker::FunctionMatchResult::debug_description() const {
auto builder = ByteStringBuilder::create();
switch (this->__jakt_init_index()) {case 0 /* MatchSuccess */: {
TRY(builder.append("FunctionMatchResult::MatchSuccess"sv));
[[maybe_unused]] auto const& that = this->as.MatchSuccess;
TRY(builder.append("("sv));
{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));
TRY(builder.appendff("args: {}, ", that.args));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));
TRY(builder.appendff("maybe_this_type_id: {}, ", that.maybe_this_type_id));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));
TRY(builder.appendff("used_generic_inferences: {}, ", that.used_generic_inferences));
TRY(JaktInternal::PrettyPrint::output_indentation(builder));
TRY(builder.appendff("specificity: {}", that.specificity));
}
TRY(builder.append(")"sv));
break;}
case 1 /* MatchError */: {
TRY(builder.append("FunctionMatchResult::MatchError"sv));
[[maybe_unused]] auto const& that = this->as.MatchError;
TRY(builder.append("("sv));
{
JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};
TRY(JaktInternal::PrettyPrint::output_indentation(builder));
TRY(builder.appendff("errors: {}", that.errors));
}
TRY(builder.append(")"sv));
break;}
}
return builder.to_string();
}
[[nodiscard]] FunctionMatchResult FunctionMatchResult::MatchSuccess(JaktInternal::DynamicArray<NonnullRefPtr<typename types::CheckedExpression>> args, JaktInternal::Optional<ids::TypeId> maybe_this_type_id, JaktInternal::Dictionary<ids::TypeId,ids::TypeId> used_generic_inferences, i64 specificity){
FunctionMatchResult __jakt_uninit_enum;
__jakt_uninit_enum.__jakt_variant_index = 1;
new (&__jakt_uninit_enum.as.MatchSuccess.args) (decltype(args))(move(args));
new (&__jakt_uninit_enum.as.MatchSuccess.maybe_this_type_id) (decltype(maybe_this_type_id))(move(maybe_this_type_id));
new (&__jakt_uninit_enum.as.MatchSuccess.used_generic_inferences) (decltype(used_generic_inferences))(move(used_generic_inferences));
new (&__jakt_uninit_enum.as.MatchSuccess.specificity) (decltype(specificity))(move(specificity));
return __jakt_uninit_enum;
}
[[nodiscard]] FunctionMatchResult FunctionMatchResult::MatchError(JaktInternal::DynamicArray<error::JaktError> errors){
FunctionMatchResult __jakt_uninit_enum;
__jakt_uninit_enum.__jakt_variant_index = 2;
new (&__jakt_uninit_enum.as.MatchError.errors) (decltype(errors))(move(errors));
return __jakt_uninit_enum;
}
FunctionMatchResult& FunctionMatchResult::operator=(FunctionMatchResult const &rhs){
{VERIFY(this->__jakt_variant_index != 0 && rhs.__jakt_variant_index != 0);
if (this->__jakt_variant_index != rhs.__jakt_variant_index) {
this->__jakt_destroy_variant();
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
new (&this->as.MatchSuccess.args) (decltype(this->as.MatchSuccess.args))(rhs.as.MatchSuccess.args);
new (&this->as.MatchSuccess.maybe_this_type_id) (decltype(this->as.MatchSuccess.maybe_this_type_id))(rhs.as.MatchSuccess.maybe_this_type_id);
new (&this->as.MatchSuccess.used_generic_inferences) (decltype(this->as.MatchSuccess.used_generic_inferences))(rhs.as.MatchSuccess.used_generic_inferences);
new (&this->as.MatchSuccess.specificity) (decltype(this->as.MatchSuccess.specificity))(rhs.as.MatchSuccess.specificity);
break;
case 1 /* MatchError */:
new (&this->as.MatchError.errors) (decltype(this->as.MatchError.errors))(rhs.as.MatchError.errors);
break;
}
} else {
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
this->as.MatchSuccess.args = rhs.as.MatchSuccess.args;
this->as.MatchSuccess.maybe_this_type_id = rhs.as.MatchSuccess.maybe_this_type_id;
this->as.MatchSuccess.used_generic_inferences = rhs.as.MatchSuccess.used_generic_inferences;
this->as.MatchSuccess.specificity = rhs.as.MatchSuccess.specificity;
break;
case 1 /* MatchError */:
this->as.MatchError.errors = rhs.as.MatchError.errors;
break;
}
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
return *this;
}
FunctionMatchResult::FunctionMatchResult(FunctionMatchResult const &rhs){VERIFY(rhs.__jakt_variant_index != 0);
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
new (&this->as.MatchSuccess.args) (decltype(this->as.MatchSuccess.args))(rhs.as.MatchSuccess.args);
new (&this->as.MatchSuccess.maybe_this_type_id) (decltype(this->as.MatchSuccess.maybe_this_type_id))(rhs.as.MatchSuccess.maybe_this_type_id);
new (&this->as.MatchSuccess.used_generic_inferences) (decltype(this->as.MatchSuccess.used_generic_inferences))(rhs.as.MatchSuccess.used_generic_inferences);
new (&this->as.MatchSuccess.specificity) (decltype(this->as.MatchSuccess.specificity))(rhs.as.MatchSuccess.specificity);
break;
case 1 /* MatchError */:
new (&this->as.MatchError.errors) (decltype(this->as.MatchError.errors))(rhs.as.MatchError.errors);
break;
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
FunctionMatchResult& FunctionMatchResult::operator=(FunctionMatchResult &&rhs){
{VERIFY(this->__jakt_variant_index != 0 && rhs.__jakt_variant_index != 0);
if (this->__jakt_variant_index != rhs.__jakt_variant_index) {
this->__jakt_destroy_variant();
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
new (&this->as.MatchSuccess.args) (decltype(this->as.MatchSuccess.args))(move(rhs.as.MatchSuccess.args));
new (&this->as.MatchSuccess.maybe_this_type_id) (decltype(this->as.MatchSuccess.maybe_this_type_id))(move(rhs.as.MatchSuccess.maybe_this_type_id));
new (&this->as.MatchSuccess.used_generic_inferences) (decltype(this->as.MatchSuccess.used_generic_inferences))(move(rhs.as.MatchSuccess.used_generic_inferences));
new (&this->as.MatchSuccess.specificity) (decltype(this->as.MatchSuccess.specificity))(move(rhs.as.MatchSuccess.specificity));
break;
case 1 /* MatchError */:
new (&this->as.MatchError.errors) (decltype(this->as.MatchError.errors))(move(rhs.as.MatchError.errors));
break;
}
} else {
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
this->as.MatchSuccess.args = move(rhs.as.MatchSuccess.args);
this->as.MatchSuccess.maybe_this_type_id = move(rhs.as.MatchSuccess.maybe_this_type_id);
this->as.MatchSuccess.used_generic_inferences = move(rhs.as.MatchSuccess.used_generic_inferences);
this->as.MatchSuccess.specificity = move(rhs.as.MatchSuccess.specificity);
break;
case 1 /* MatchError */:
this->as.MatchError.errors = move(rhs.as.MatchError.errors);
break;
}
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
return *this;
}
FunctionMatchResult::FunctionMatchResult(FunctionMatchResult &&rhs){
{VERIFY(rhs.__jakt_variant_index != 0);
switch (rhs.__jakt_init_index()) {
case 0 /* MatchSuccess */:
new (&this->as.MatchSuccess.args) (decltype(this->as.MatchSuccess.args))(move(rhs.as.MatchSuccess.args));
new (&this->as.MatchSuccess.maybe_this_type_id) (decltype(this->as.MatchSuccess.maybe_this_type_id))(move(rhs.as.MatchSuccess.maybe_this_type_id));
new (&this->as.MatchSuccess.used_generic_inferences) (decltype(this->as.MatchSuccess.used_generic_inferences))(move(rhs.as.MatchSuccess.used_generic_inferences));
new (&this->as.MatchSuccess.specificity) (decltype(this->as.MatchSuccess.specificity))(move(rhs.as.MatchSuccess.specificity));
break;
case 1 /* MatchError */:
new (&this->as.MatchError.errors) (decltype(this->as.MatchError.errors))(move(rhs.as.MatchError.errors));
break;
}
this->__jakt_variant_index = rhs.__jakt_variant_index;
}
}
FunctionMatchResult::~FunctionMatchResult(){
if (this->__jakt_variant_index == 0) return;
this->__jakt_destroy_variant();
}
void FunctionMatchResult::__jakt_destroy_variant() {
switch (this->__jakt_init_index()) {
case 0 /* MatchSuccess */:this->as.MatchSuccess.args.~DynamicArray();
this->as.MatchSuccess.maybe_this_type_id.~Optional();
this->as.MatchSuccess.used_generic_inferences.~Dictionary();
break;
case 1 /* MatchError */:this->as.MatchError.errors.~DynamicArray();
break;
}
}
}
} // namespace Jakt
