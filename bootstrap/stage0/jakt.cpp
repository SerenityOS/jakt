#include <lib.h>
namespace Jakt {
namespace utility {
struct Span;
struct FileId;
class FilePath;
struct ArgsParser;
static ErrorOr<Array<String>> append_to_each(const Array<String> strings, const String suffix);

static String join(const Array<String> strings, const String separator);

template <typename T>
static ErrorOr<void> extend_array(Array<T> target, const Array<T> extend_with);

[[noreturn]] static void panic(const String message);

static ErrorOr<Array<String>> prepend_to_each(const Array<String> strings, const String prefix);

static void todo(const String message);

}
namespace error {
namespace JaktError_Details {
struct Message;
struct MessageWithHint;
}
struct JaktError;

namespace MessageSeverity_Details {
struct Hint;
struct Error;
}
struct MessageSeverity;

static ErrorOr<void> print_error_json(const String file_name, const error::JaktError error);

static ErrorOr<Array<Tuple<size_t,size_t>>> gather_line_spans(const Array<u8> file_contents);

static ErrorOr<void> display_message_with_span(const error::MessageSeverity severity, const String file_name, const Optional<Array<u8>> contents, const String message, const utility::Span span);

static ErrorOr<void> print_source_line(const error::MessageSeverity severity, const Array<u8> file_contents, const Tuple<size_t,size_t> file_span, const utility::Span error_span, const size_t line_number, const size_t largest_line_number);

static ErrorOr<void> display_message_with_span_json(const error::MessageSeverity severity, const String file_name, const String message, const utility::Span span);

static ErrorOr<void> print_error(const String file_name, const Optional<Array<u8>> file_contents, const error::JaktError error);

}
namespace prelude {
struct JaktPrelude;
}
namespace compiler {
class Compiler;
}
namespace lexer {
struct Lexer;
namespace LiteralSuffix_Details {
struct None;
struct UZ;
struct U8;
struct U16;
struct U32;
struct U64;
struct I8;
struct I16;
struct I32;
struct I64;
struct F32;
struct F64;
}
struct LiteralSuffix;

namespace NumericConstant_Details {
struct I8;
struct I16;
struct I32;
struct I64;
struct U8;
struct U16;
struct U32;
struct U64;
struct USize;
struct F32;
struct F64;
}
struct NumericConstant;

namespace Token_Details {
struct SingleQuotedString;
struct SingleQuotedByteString;
struct QuotedString;
struct Number;
struct Identifier;
struct Semicolon;
struct Colon;
struct ColonColon;
struct LParen;
struct RParen;
struct LCurly;
struct RCurly;
struct LSquare;
struct RSquare;
struct PercentSign;
struct Plus;
struct Minus;
struct Equal;
struct PlusEqual;
struct PlusPlus;
struct MinusEqual;
struct MinusMinus;
struct AsteriskEqual;
struct ForwardSlashEqual;
struct PercentSignEqual;
struct NotEqual;
struct DoubleEqual;
struct GreaterThan;
struct GreaterThanOrEqual;
struct LessThan;
struct LessThanOrEqual;
struct LeftArithmeticShift;
struct LeftShift;
struct LeftShiftEqual;
struct RightShift;
struct RightArithmeticShift;
struct RightShiftEqual;
struct Asterisk;
struct Ampersand;
struct AmpersandEqual;
struct Pipe;
struct PipeEqual;
struct Caret;
struct CaretEqual;
struct Dollar;
struct Tilde;
struct ForwardSlash;
struct ExclamationPoint;
struct QuestionMark;
struct QuestionMarkQuestionMark;
struct QuestionMarkQuestionMarkEqual;
struct Comma;
struct Dot;
struct DotDot;
struct Eol;
struct Eof;
struct FatArrow;
struct Arrow;
struct And;
struct Anon;
struct As;
struct Boxed;
struct Break;
struct Catch;
struct Class;
struct Continue;
struct Cpp;
struct Defer;
struct Else;
struct Enum;
struct Extern;
struct False;
struct For;
struct Function;
struct If;
struct Import;
struct In;
struct Is;
struct Let;
struct Loop;
struct Match;
struct Mut;
struct Namespace;
struct Not;
struct Or;
struct Private;
struct Public;
struct Raw;
struct Return;
struct Restricted;
struct Struct;
struct This;
struct Throw;
struct Throws;
struct True;
struct Try;
struct Unsafe;
struct Weak;
struct While;
struct Yield;
struct Guard;
struct Garbage;
}
struct Token;

static bool is_ascii_alphanumeric(const u8 c);

static bool is_ascii_alpha(const u8 c);

static f32 f64_to_f32(const f64 number);

static ErrorOr<lexer::Token> make_float_token(const f64 number, const lexer::LiteralSuffix suffix, const utility::Span span);

static bool is_ascii_octdigit(const u8 c);

static bool is_ascii_hexdigit(const u8 c);

template <typename T>
static T u64_to_float(const u64 number);

static bool is_ascii_digit(const u8 c);

}
namespace parser {
struct ParsedGenericParameter;
struct EnumVariantPatternArgument;
struct ParsedBlock;
struct ParsedRecord;
struct ParsedVarDecl;
struct ParsedFunction;
struct ParsedExternImport;
struct ParsedModuleImport;
struct ParsedVariable;
struct SumEnumVariant;
struct ParsedMatchCase;
struct ImportName;
struct Parser;
struct ParsedCall;
struct ParsedNamespace;
struct ParsedMethod;
struct ParsedField;
struct ParsedParameter;
struct ValueEnumVariant;
namespace ParsedMatchBody_Details {
struct Expression;
struct Block;
}
struct ParsedMatchBody;

namespace ParsedType_Details {
struct Name;
struct NamespacedName;
struct GenericType;
struct JaktArray;
struct Dictionary;
struct JaktTuple;
struct Set;
struct Optional;
struct Reference;
struct MutableReference;
struct RawPtr;
struct WeakPtr;
struct Function;
struct Empty;
}
struct ParsedType;

namespace ParsedExpression_Details {
struct Boolean;
struct NumericConstant;
struct QuotedString;
struct SingleQuotedString;
struct SingleQuotedByteString;
struct Call;
struct MethodCall;
struct IndexedTuple;
struct IndexedStruct;
struct Var;
struct IndexedExpression;
struct UnaryOp;
struct BinaryOp;
struct Operator;
struct OptionalSome;
struct OptionalNone;
struct JaktArray;
struct JaktDictionary;
struct Set;
struct JaktTuple;
struct Range;
struct ForcedUnwrap;
struct Match;
struct EnumVariantArg;
struct NamespacedVar;
struct Function;
struct Garbage;
}
struct ParsedExpression;

namespace TypeCast_Details {
struct Fallible;
struct Infallible;
}
struct TypeCast;

namespace DefinitionLinkage_Details {
struct Internal;
struct External;
}
struct DefinitionLinkage;

namespace RecordType_Details {
struct Struct;
struct Class;
struct ValueEnum;
struct SumEnum;
struct Garbage;
}
struct RecordType;

namespace ParsedCapture_Details {
struct ByValue;
struct ByReference;
struct ByMutableReference;
}
struct ParsedCapture;

namespace BinaryOperator_Details {
struct Add;
struct Subtract;
struct Multiply;
struct Divide;
struct Modulo;
struct LessThan;
struct LessThanOrEqual;
struct GreaterThan;
struct GreaterThanOrEqual;
struct Equal;
struct NotEqual;
struct BitwiseAnd;
struct BitwiseXor;
struct BitwiseOr;
struct BitwiseLeftShift;
struct BitwiseRightShift;
struct ArithmeticLeftShift;
struct ArithmeticRightShift;
struct LogicalAnd;
struct LogicalOr;
struct NoneCoalescing;
struct Assign;
struct BitwiseAndAssign;
struct BitwiseOrAssign;
struct BitwiseXorAssign;
struct BitwiseLeftShiftAssign;
struct BitwiseRightShiftAssign;
struct AddAssign;
struct SubtractAssign;
struct MultiplyAssign;
struct ModuloAssign;
struct DivideAssign;
struct NoneCoalescingAssign;
struct Garbage;
}
struct BinaryOperator;

namespace Visibility_Details {
struct Public;
struct Private;
struct Restricted;
}
struct Visibility;

namespace FunctionType_Details {
struct Normal;
struct ImplicitConstructor;
struct ImplicitEnumConstructor;
struct ExternalClassConstructor;
}
struct FunctionType;

namespace ParsedStatement_Details {
struct Expression;
struct Defer;
struct UnsafeBlock;
struct DestructuringAssignment;
struct VarDecl;
struct If;
struct Block;
struct Loop;
struct While;
struct For;
struct Break;
struct Continue;
struct Return;
struct Throw;
struct Yield;
struct InlineCpp;
struct Try;
struct Guard;
struct Garbage;
}
struct ParsedStatement;

namespace ParsedMatchPattern_Details {
struct EnumVariant;
struct Expression;
struct CatchAll;
}
struct ParsedMatchPattern;

namespace FunctionLinkage_Details {
struct Internal;
struct External;
}
struct FunctionLinkage;

namespace UnaryOperator_Details {
struct PreIncrement;
struct PostIncrement;
struct PreDecrement;
struct PostDecrement;
struct Negate;
struct Dereference;
struct RawAddress;
struct Reference;
struct MutableReference;
struct LogicalNot;
struct BitwiseNot;
struct TypeCast;
struct Is;
struct IsEnumVariant;
}
struct UnaryOperator;

static utility::Span merge_spans(const utility::Span start, const utility::Span end);

static bool binary_operator_equals(const parser::BinaryOperator lhs_op, const parser::BinaryOperator rhs_op);

static bool unary_operator_equals(const parser::UnaryOperator lhs_op, const parser::UnaryOperator rhs_op);

static bool parsed_statement_equals(const NonnullRefPtr<parser::ParsedStatement> lhs_statement, const NonnullRefPtr<parser::ParsedStatement> rhs_statement);

static bool parsed_var_decl_equals(const parser::ParsedVarDecl lhs_var_decl, const parser::ParsedVarDecl rhs_var_decl);

static bool parsed_call_equals(const parser::ParsedCall lhs_parsed_call, const parser::ParsedCall rhs_parsed_call);

static bool parsed_expression_equals(const NonnullRefPtr<parser::ParsedExpression> lhs_expression, const NonnullRefPtr<parser::ParsedExpression> rhs_expression);

static bool parsed_block_equals(const parser::ParsedBlock lhs_block, const parser::ParsedBlock rhs_block);

}
namespace typechecker {
struct CheckedStruct;
struct CheckedVariable;
class CheckedProgram;
struct CheckedParameter;
struct CheckedCall;
struct CheckedNamespace;
struct CheckedBlock;
struct FunctionId;
class Module;
struct VarId;
class CheckedFunction;
struct EnumId;
struct StructId;
struct ScopeId;
struct LoadedModule;
struct Typechecker;
struct ResolvedNamespace;
struct CheckedVarDecl;
class Scope;
struct TypeId;
struct CheckedEnum;
struct ModuleId;
struct CheckedEnumVariantBinding;
namespace Type_Details {
struct Void;
struct Bool;
struct U8;
struct U16;
struct U32;
struct U64;
struct I8;
struct I16;
struct I32;
struct I64;
struct F32;
struct F64;
struct Usize;
struct JaktString;
struct CChar;
struct CInt;
struct Unknown;
struct Never;
struct TypeVariable;
struct GenericInstance;
struct GenericEnumInstance;
struct GenericResolvedType;
struct Struct;
struct Enum;
struct RawPtr;
struct Reference;
struct MutableReference;
struct Function;
}
struct Type;

namespace CheckedMatchBody_Details {
struct Expression;
struct Block;
}
struct CheckedMatchBody;

namespace CheckedStatement_Details {
struct Expression;
struct Defer;
struct DestructuringAssignment;
struct VarDecl;
struct If;
struct Block;
struct Loop;
struct While;
struct Return;
struct Break;
struct Continue;
struct Throw;
struct Yield;
struct Try;
struct InlineCpp;
struct Garbage;
}
struct CheckedStatement;

namespace BlockControlFlow_Details {
struct AlwaysReturns;
struct AlwaysTransfersControl;
struct NeverReturns;
struct MayReturn;
struct PartialAlwaysReturns;
struct PartialAlwaysTransfersControl;
struct PartialNeverReturns;
}
struct BlockControlFlow;

namespace StructOrEnumId_Details {
struct Struct;
struct Enum;
}
struct StructOrEnumId;

namespace CheckedEnumVariant_Details {
struct Untyped;
struct Typed;
struct WithValue;
struct StructLike;
}
struct CheckedEnumVariant;

namespace CheckedMatchCase_Details {
struct EnumVariant;
struct Expression;
struct CatchAll;
}
struct CheckedMatchCase;

namespace FunctionGenericParameter_Details {
struct InferenceGuide;
struct Parameter;
}
struct FunctionGenericParameter;

namespace CheckedTypeCast_Details {
struct Fallible;
struct Infallible;
}
struct CheckedTypeCast;

namespace NumberConstant_Details {
struct Signed;
struct Unsigned;
struct Floating;
}
struct NumberConstant;

namespace CheckedUnaryOperator_Details {
struct PreIncrement;
struct PostIncrement;
struct PreDecrement;
struct PostDecrement;
struct Negate;
struct Dereference;
struct RawAddress;
struct Reference;
struct MutableReference;
struct LogicalNot;
struct BitwiseNot;
struct TypeCast;
struct Is;
struct IsEnumVariant;
}
struct CheckedUnaryOperator;

namespace CheckedCapture_Details {
struct ByValue;
struct ByReference;
struct ByMutableReference;
}
struct CheckedCapture;

namespace SafetyMode_Details {
struct Safe;
struct Unsafe;
}
struct SafetyMode;

namespace CheckedExpression_Details {
struct Boolean;
struct NumericConstant;
struct QuotedString;
struct ByteConstant;
struct CharacterConstant;
struct UnaryOp;
struct BinaryOp;
struct JaktTuple;
struct Range;
struct JaktArray;
struct JaktSet;
struct JaktDictionary;
struct IndexedExpression;
struct IndexedDictionary;
struct IndexedTuple;
struct IndexedStruct;
struct Match;
struct EnumVariantArg;
struct Call;
struct MethodCall;
struct NamespacedVar;
struct Var;
struct OptionalNone;
struct OptionalSome;
struct ForcedUnwrap;
struct Block;
struct Function;
struct Garbage;
}
struct CheckedExpression;

namespace CheckedNumericConstant_Details {
struct I8;
struct I16;
struct I32;
struct I64;
struct U8;
struct U16;
struct U32;
struct U64;
struct USize;
struct F32;
struct F64;
}
struct CheckedNumericConstant;

enum class BuiltinType: size_t;
static typechecker::TypeId void_type_id();

static typechecker::TypeId expression_type(const NonnullRefPtr<typechecker::CheckedExpression> expr);

static bool expression_can_throw(const NonnullRefPtr<typechecker::CheckedExpression> expr);

static typechecker::TypeId builtin(const typechecker::BuiltinType builtin);

static typechecker::TypeId unknown_type_id();

static ErrorOr<typechecker::TypeId> flip_signedness(const NonnullRefPtr<typechecker::Type> type);

static typechecker::BlockControlFlow checked_expression_control_flow(const NonnullRefPtr<typechecker::CheckedExpression> check_expression);

static Optional<typechecker::CheckedNumericConstant> promote(const typechecker::NumberConstant num_const, const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedProgram> program);

static typechecker::TypeId never_type_id();

}
namespace codegen {
struct LineSpan;
struct CodegenDebugInfo;
struct CodeGenerator;
struct ControlFlowState;
namespace AllowedControlExits_Details {
struct Nothing;
struct JustReturn;
struct AtLoop;
}
struct AllowedControlExits;

static bool are_loop_exits_allowed(const codegen::AllowedControlExits allowed_control_exits);

static bool is_return_allowed(const codegen::AllowedControlExits allowed_control_exits);

}
namespace ide {
namespace Mutability_Details {
struct DoesNotApply;
struct Immutable;
struct Mutable;
}
struct Mutability;

namespace Usage_Details {
struct Variable;
struct Call;
struct Typename;
struct NameSet;
struct EnumVariant;
}
struct Usage;

namespace VarType_Details {
struct Variable;
struct Field;
}
struct VarType;

namespace VarVisibility_Details {
struct DoesNotApply;
struct Public;
struct Private;
struct Restricted;
}
struct VarVisibility;

static ErrorOr<ide::Usage> get_enum_variant_usage_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const String name);

static ErrorOr<Array<String>> completions_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id);

static ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>> enum_variant_fields(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedEnumVariant checked_enum_variant);

static ErrorOr<String> get_enum_variant_signature_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const String name);

static ErrorOr<String> get_type_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id);

static ErrorOr<Optional<ide::Usage>> find_span_in_scope(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::Scope> scope, const utility::Span span);

static ErrorOr<String> get_constructor_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::FunctionId function_id);

static ErrorOr<Array<String>> find_dot_completions(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<utility::Span> find_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<String> get_var_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const String name, const typechecker::TypeId var_type_id, const ide::Mutability mutability, const ide::VarType var_type, const ide::VarVisibility visibility, const Optional<typechecker::TypeId> struct_type_id);

static ErrorOr<Optional<ide::Usage>> find_span_in_expression(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedExpression> expr, const utility::Span span);

static ErrorOr<utility::Span> find_type_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_block(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedBlock block, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_function(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedFunction> checked_function, const utility::Span span);

static ErrorOr<Optional<String>> find_typename_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<utility::Span> find_type_definition_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const utility::Span span);

static ErrorOr<String> get_enum_variant_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const String name, const typechecker::TypeId type_id, const Array<Tuple<Optional<String>,typechecker::TypeId>> variants, const Optional<typechecker::NumberConstant> number_constant);

static ErrorOr<Optional<ide::Usage>> find_span_in_enum(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedEnum checked_enum, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_statement(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedStatement> statement, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_struct(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedStruct checked_struct, const utility::Span span);

static ErrorOr<String> get_function_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::FunctionId function_id);

}
static ErrorOr<void> write_to_file(const String data, const String output_filename);

static ErrorOr<void> run_compiler(const String cxx_compiler_path, const String cpp_filename, const String output_filename, const String runtime_path, const Array<String> extra_include_paths, const Array<String> extra_lib_paths, const Array<String> extra_link_libs, const bool optimize);

static String usage();

static String help();

namespace utility {
struct FileId {
  public:
size_t id;bool equals(const utility::FileId rhs) const;
FileId(size_t a_id) :id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FileId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ArgsParser {
  public:
Array<String> args;Array<size_t> removed_indices;static ErrorOr<utility::ArgsParser> from_args(const Array<String> args);
ErrorOr<Array<String>> option_multiple(const Array<String> names);
ErrorOr<bool> flag(const Array<String> names);
ArgsParser(Array<String> a_args, Array<size_t> a_removed_indices) :args(a_args), removed_indices(a_removed_indices){}

ErrorOr<Array<String>> remaining_arguments() const;
ErrorOr<Optional<String>> option(const Array<String> names);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ArgsParser("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("removed_indices: "));TRY(builder.appendff("{}", removed_indices));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Span {
  public:
utility::FileId file_id;size_t start;size_t end;bool contains(const utility::Span span) const;
Span(utility::FileId a_file_id, size_t a_start, size_t a_end) :file_id(a_file_id), start(a_start), end(a_end){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Span("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_id: "));TRY(builder.appendff("{}, ", file_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("start: "));TRY(builder.appendff("{}, ", start));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("end: "));TRY(builder.appendff("{}", end));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class FilePath : public RefCounted<FilePath>, public Weakable<FilePath> {
  public:
virtual ~FilePath() = default;
String path;static ErrorOr<NonnullRefPtr<utility::FilePath>> make(const String filepath);
ErrorOr<Tuple<String,String>> split_at_last_slash() const;
ErrorOr<String> dirname() const;
private:
explicit FilePath(String&& a_path): path(move(a_path)){}
public:
static ErrorOr<NonnullRefPtr<FilePath>> create(String path) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) FilePath (move(path)))); return o; }
static Optional<size_t> last_slash(const String path);
ErrorOr<String> basename() const;
ErrorOr<String> ext() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FilePath("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("path: "));TRY(builder.appendff("\"{}\"", path));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static ErrorOr<Array<String>> append_to_each(const Array<String> strings,const String suffix) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String str = (_magic_value.value());
{
TRY((((output).push((str + suffix)))));
}

}
}

return (output);
}
}

static String join(const Array<String> strings,const String separator) {
{
String output = String("");
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String s = (_magic_value.value());
{
(output += s);
if ((i < (JaktInternal::checked_sub<size_t>(((strings).size()),static_cast<size_t>(1ULL))))){
(output += separator);
}
(i++);
}

}
}

return (output);
}
}

template <typename T>
static ErrorOr<void> extend_array(Array<T> target,const Array<T> extend_with) {
{
TRY((((target).add_capacity(((extend_with).size())))));
{
ArrayIterator<T> _magic = ((extend_with).iterator());
for (;;){
Optional<T> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
T v = (_magic_value.value());
{
TRY((((target).push(v))));
}

}
}

}
return {};
}

[[noreturn]] static void panic(const String message) {
{
warnln(String("internal error: {}"),message);
abort();
}
}

static ErrorOr<Array<String>> prepend_to_each(const Array<String> strings,const String prefix) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String str = (_magic_value.value());
{
TRY((((output).push((prefix + str)))));
}

}
}

return (output);
}
}

static void todo(const String message) {
{
warnln(String("TODO: {}"),message);
abort();
}
}

bool utility::Span::contains(const utility::Span span) const {
{
return (((((((*this).file_id)).equals(((span).file_id))) && (((span).start) >= ((*this).start))) && (((span).end) <= ((*this).end))));
}
}

bool utility::FileId::equals(const utility::FileId rhs) const {
{
return ((((*this).id) == ((rhs).id)));
}
}

ErrorOr<NonnullRefPtr<utility::FilePath>> utility::FilePath::make(const String filepath) {
{
return (TRY((utility::FilePath::create(filepath))));
}
}

ErrorOr<Tuple<String,String>> utility::FilePath::split_at_last_slash() const {
{
const size_t len = ((((*this).path)).length());
const Optional<size_t> last_slash = utility::FilePath::last_slash(((*this).path));
if (((last_slash).has_value())){
const String dir = TRY((((((*this).path)).substring(static_cast<size_t>(0ULL),(JaktInternal::checked_add<size_t>((last_slash.value()),static_cast<size_t>(1ULL)))))));
const String base = TRY((((((*this).path)).substring((JaktInternal::checked_add<size_t>((last_slash.value()),static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>((JaktInternal::checked_sub<size_t>(len,(last_slash.value()))),static_cast<size_t>(1ULL)))))));
return ((Tuple{dir, base}));
}
return ((Tuple{String(""), ((*this).path)}));
}
}

ErrorOr<String> utility::FilePath::dirname() const {
{
const Tuple<String,String> parts = TRY((((*this).split_at_last_slash())));
return (((parts).get<0>()));
}
}

Optional<size_t> utility::FilePath::last_slash(const String path) {
{
size_t i = (JaktInternal::checked_sub<size_t>(((path).length()),static_cast<size_t>(1ULL)));
while (((i >= static_cast<size_t>(1ULL)) && (((path).byte_at(i)) != '/'))){
(i--);
}
if (((i == static_cast<size_t>(0ULL)) && (((path).byte_at(i)) != '/'))){
return (JaktInternal::OptionalNone());
}
return (i);
}
}

ErrorOr<String> utility::FilePath::basename() const {
{
const Tuple<String,String> parts = TRY((((*this).split_at_last_slash())));
return (((parts).get<1>()));
}
}

ErrorOr<String> utility::FilePath::ext() const {
{
{
Range<size_t> _magic = (((Range<size_t>{static_cast<size_t>((JaktInternal::checked_sub<size_t>(((((*this).path)).length()),static_cast<size_t>(1ULL)))),static_cast<size_t>(static_cast<size_t>(0ULL))})).inclusive());
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const u8 c = ((((*this).path)).byte_at(i));
if ((c == '/')){
break;
}
if ((c == '.')){
return (TRY((((((*this).path)).substring((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>((JaktInternal::checked_sub<size_t>(((((*this).path)).length()),static_cast<size_t>(1ULL))),i)))))));
}
}

}
}

return (String(""));
}
}

ErrorOr<utility::ArgsParser> utility::ArgsParser::from_args(const Array<String> args) {
{
return (utility::ArgsParser(args,(TRY((Array<size_t>::create_with({}))))));
}
}

ErrorOr<Array<String>> utility::ArgsParser::option_multiple(const Array<String> names) {
{
Array<String> result = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
if ((((((*this).args)).size()) <= (JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))))){
warnln(String("The option '{}' requires a value, but none was supplied"),name);
return Error::from_errno(static_cast<i32>(200));
}
TRY((((((*this).removed_indices)).push(i))));
TRY((((((*this).removed_indices)).push((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))))));
TRY((((result).push(((((*this).args))[(JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))])))));
}
}

}
}

}

}
}

return (result);
}
}

ErrorOr<bool> utility::ArgsParser::flag(const Array<String> names) {
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
TRY((((((*this).removed_indices)).push(i))));
return (true);
}
}

}
}

}

}
}

return (false);
}
}

ErrorOr<Array<String>> utility::ArgsParser::remaining_arguments() const {
{
Array<String> remaining = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!((((*this).removed_indices)).contains(i)))){
TRY((((remaining).push(((((*this).args))[i])))));
}
}

}
}

return (remaining);
}
}

ErrorOr<Optional<String>> utility::ArgsParser::option(const Array<String> names) {
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
if ((((((*this).args)).size()) <= (JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))))){
warnln(String("The option '{}' requires a value, but none was supplied"),name);
return Error::from_errno(static_cast<i32>(200));
}
TRY((((((*this).removed_indices)).push(i))));
TRY((((((*this).removed_indices)).push((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))))));
return (((((*this).args))[(JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))]));
}
}

}
}

}

}
}

return (JaktInternal::OptionalNone());
}
}

}
namespace error {
namespace MessageSeverity_Details {
struct Hint {};
struct Error {};
}
struct MessageSeverity : public Variant<MessageSeverity_Details::Hint, MessageSeverity_Details::Error> {
using Variant<MessageSeverity_Details::Hint, MessageSeverity_Details::Error>::Variant;
    using Hint = MessageSeverity_Details::Hint;
    using Error = MessageSeverity_Details::Error;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Hint const& that) -> ErrorOr<void> {
TRY(builder.append("MessageSeverity::Hint"));return {}; },[&]([[maybe_unused]] Error const& that) -> ErrorOr<void> {
TRY(builder.append("MessageSeverity::Error"));return {}; }));return builder.to_string();}ErrorOr<String> ansi_color_code() const;
ErrorOr<String> name() const;
};
namespace JaktError_Details {
struct Message {
String message;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Message(_MemberT0&& member_0, _MemberT1&& member_1):
message{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MessageWithHint {
String message;
utility::Span span;
String hint;
utility::Span hint_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
MessageWithHint(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
message{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
hint{ forward<_MemberT2>(member_2)},
hint_span{ forward<_MemberT3>(member_3)}
{}
};
}
struct JaktError : public Variant<JaktError_Details::Message, JaktError_Details::MessageWithHint> {
using Variant<JaktError_Details::Message, JaktError_Details::MessageWithHint>::Variant;
    using Message = JaktError_Details::Message;
    using MessageWithHint = JaktError_Details::MessageWithHint;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Message const& that) -> ErrorOr<void> {
TRY(builder.append("JaktError::Message"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("message: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.message));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MessageWithHint const& that) -> ErrorOr<void> {
TRY(builder.append("JaktError::MessageWithHint"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("message: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.message));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("hint: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.hint));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("hint_span: "));TRY(builder.appendff("{}", that.hint_span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}utility::Span span() const;
};
static ErrorOr<void> print_error_json(const String file_name,const error::JaktError error) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = error;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
{
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Error(),file_name,message,span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
String const& hint = __jakt_match_value.hint;
utility::Span const& hint_span = __jakt_match_value.hint_span;
{
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Error(),file_name,message,span)));
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Hint(),file_name,hint,hint_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return {};
}

static ErrorOr<Array<Tuple<size_t,size_t>>> gather_line_spans(const Array<u8> file_contents) {
{
size_t idx = static_cast<size_t>(0ULL);
Array<Tuple<size_t,size_t>> output = (TRY((Array<Tuple<size_t,size_t>>::create_with({}))));
size_t start = idx;
while ((idx < ((file_contents).size()))){
if ((((file_contents)[idx]) == '\n')){
TRY((((output).push((Tuple{start, idx})))));
(start = (JaktInternal::checked_add<size_t>(idx,static_cast<size_t>(1ULL))));
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
if ((start < idx)){
TRY((((output).push((Tuple{start, idx})))));
}
return (output);
}
}

static ErrorOr<void> display_message_with_span(const error::MessageSeverity severity,const String file_name,const Optional<Array<u8>> contents,const String message,const utility::Span span) {
{
warnln(String("{}: {}"),TRY((((severity).name()))),message);
if ((!((contents).has_value()))){
return {};
}
const Array<u8> file_contents = (contents.value());
const Array<Tuple<size_t,size_t>> line_spans = TRY((error::gather_line_spans(file_contents)));
size_t line_index = static_cast<size_t>(1ULL);
const size_t largest_line_number = ((line_spans).size());
const size_t width = ((TRY((String::formatted(String("{}"),largest_line_number)))).length());
while ((line_index < ((line_spans).size()))){
if (((((span).start) >= ((((line_spans)[line_index])).get<0>())) && (((span).start) <= ((((line_spans)[line_index])).get<1>())))){
const size_t column_index = (JaktInternal::checked_sub<size_t>(((span).start),((((line_spans)[line_index])).get<0>())));
warnln(String("----- \u001b[33m{}:{}:{}\u001b[0m"),file_name,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),(JaktInternal::checked_add<size_t>(column_index,static_cast<size_t>(1ULL))));
if ((line_index > static_cast<size_t>(0ULL))){
TRY((error::print_source_line(severity,file_contents,((line_spans)[(JaktInternal::checked_sub<size_t>(line_index,static_cast<size_t>(1ULL)))]),span,line_index,largest_line_number)));
}
TRY((error::print_source_line(severity,file_contents,((line_spans)[line_index]),span,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),largest_line_number)));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>((JaktInternal::checked_add<size_t>((JaktInternal::checked_add<size_t>((JaktInternal::checked_sub<size_t>(((span).start),((((line_spans)[line_index])).get<0>()))),width)),static_cast<size_t>(4ULL))))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t x = (_magic_value.value());
{
warn(String(" "));
}

}
}

warnln(String("\u001b[{}m^- {}\u001b[0m"),TRY((((severity).ansi_color_code()))),message);
while (((line_index < ((line_spans).size())) && (((span).end) > ((((line_spans)[line_index])).get<0>())))){
(++line_index);
if ((line_index >= ((line_spans).size()))){
break;
}
TRY((error::print_source_line(severity,file_contents,((line_spans)[line_index]),span,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),largest_line_number)));
break;
}
}
else {
(++line_index);
}

}
warnln(String("\u001b[0m-----"));
}
return {};
}

static ErrorOr<void> print_source_line(const error::MessageSeverity severity,const Array<u8> file_contents,const Tuple<size_t,size_t> file_span,const utility::Span error_span,const size_t line_number,const size_t largest_line_number) {
{
size_t index = ((file_span).get<0>());
const size_t width = ((TRY((String::formatted(String("{}"),largest_line_number)))).length());
warn(String(" {} | "),line_number);
while ((index <= ((file_span).get<1>()))){
u8 c = ' ';
if ((index < ((file_span).get<1>()))){
(c = ((file_contents)[index]));
}
else if (((((error_span).start) == ((error_span).end)) && (index == ((error_span).start)))){
(c = '_');
}
if ((index == ((error_span).start))){
warn(String("\u001b[{}m"),TRY((((severity).ansi_color_code()))));
}
if ((index == ((error_span).end))){
warn(String("\u001b[0m"));
}
warn(String("{:c}"),c);
(++index);
}
warnln(String(""));
}
return {};
}

static ErrorOr<void> display_message_with_span_json(const error::MessageSeverity severity,const String file_name,const String message,const utility::Span span) {
{
outln(String("{{\"type\":\"diagnostic\",\"message\":\"{}\",\"severity\":\"{}\",\"file_id\":{},\"span\":{{\"start\":{},\"end\":{}}}}}"),message,TRY((((severity).name()))),((((span).file_id)).id),((span).start),((span).end));
}
return {};
}

static ErrorOr<void> print_error(const String file_name,const Optional<Array<u8>> file_contents,const error::JaktError error) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = error;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
{
TRY((error::display_message_with_span(typename error::MessageSeverity::Error(),file_name,file_contents,message,span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
String const& hint = __jakt_match_value.hint;
utility::Span const& hint_span = __jakt_match_value.hint_span;
{
TRY((error::display_message_with_span(typename error::MessageSeverity::Error(),file_name,file_contents,message,span)));
TRY((error::display_message_with_span(typename error::MessageSeverity::Hint(),file_name,file_contents,hint,hint_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return {};
}

utility::Span error::JaktError::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<String> error::MessageSeverity::ansi_color_code() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Hint>();
return JaktInternal::ExplicitValue(String("94"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Error>();
return JaktInternal::ExplicitValue(String("31"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<String> error::MessageSeverity::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Hint>();
return JaktInternal::ExplicitValue(String("Hint"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Error>();
return JaktInternal::ExplicitValue(String("Error"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace prelude {
struct JaktPrelude {
  public:
static String to_string();
JaktPrelude() {}

static ErrorOr<Array<u8>> to_bytes();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("JaktPrelude("));JaktInternal::_pretty_print_level++;
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};String prelude::JaktPrelude::to_string() {
{
return (String("\nextern struct Optional<T> {\n    function has_value(this) -> bool\n    function value(this) -> T\n    function value_or(this, anon x: T) -> T\n    function Optional<S>(anon x: S) -> Optional<S>\n}\n\nextern struct ArrayIterator<T> {\n    function next(mut this) -> T?\n}\n\nextern struct Array<T> {\n    function is_empty(this) -> bool\n    function contains(this, anon value: T) -> bool\n    function size(this) -> usize\n    function capacity(this) -> usize\n    function ensure_capacity(this, anon capacity: usize) throws\n    function add_capacity(this, anon capacity: usize) throws\n    function resize(mut this, anon size: usize) throws\n    function push(mut this, anon value: T) throws\n    function pop(mut this) -> T?\n    function iterator(this) -> ArrayIterator<T>\n    function first(this) -> T?\n    function last(this) -> T?\n}\n\nextern struct String {\n    function number(anon number: i64) throws -> String\n    function split(this, anon c: c_char) throws -> [String]\n    function c_string(this) -> raw c_char\n    function to_int(this) -> i32?\n    function to_uint(this) -> u32?\n    function is_whitespace(this) -> bool\n    function hash(this) -> u32\n    function substring(this, start: usize, length: usize) throws -> String\n    function repeated(character: c_char, count: usize) throws -> String\n    function is_empty(this) -> bool\n    function length(this) -> usize\n    function byte_at(this, anon index: usize) -> u8\n    function contains(this, anon needle: String) -> bool\n    function replace(this, replace: String, with: String) throws -> String\n}\n\nextern struct StringBuilder {\n    function append(mut this, anon b: u8) throws\n    function append_string(mut this, anon s: String) throws\n    function append_c_string(mut this, anon s: raw c_char) throws\n    function append_code_point(mut this, anon code_point: u32) throws\n    function append_escaped_for_json(mut this, anon s: String) throws\n    function to_string(this) throws -> String\n    function is_empty(this) -> bool\n    function length(this) -> usize\n    function clear(mut this)\n    function create() throws -> StringBuilder\n}\n\nextern struct WeakPtr<T> {\n    function has_value(this) -> bool\n    function clear(mut this)\n}\n\nextern struct Tuple {}\n\nextern struct DictionaryIterator<K, V> {\n    function next(mut this) -> (K, V)?\n}\n\nextern struct Dictionary<K, V> {\n    function is_empty(this) -> bool\n    function get(this, anon key: K) -> V?\n    function contains(this, anon key: K) -> bool\n    function set(mut this, anon key: K, anon value: V) throws\n    function remove(mut this, anon key: K) -> bool\n    function ensure_capacity(mut this, anon capacity: usize) throws\n    function clear(mut this)\n    function size(this) -> usize\n    function capacity(this) -> usize\n    function keys(this) throws -> [K]\n    function hash(this) -> u32\n    function Dictionary<A, B>() -> Dictionary<A, B>\n    function iterator(this) -> DictionaryIterator<K, V>\n}\n\nextern struct SetIterator<T> {\n    function next(mut this) -> T?\n}\n\nextern struct Set<V> {\n    function is_empty(this) -> bool\n    function contains(this, anon value: V) -> bool\n    function add(mut this, anon value: V) throws\n    function remove(mut this, anon value: V) -> bool\n    function ensure_capacity(mut this, anon capacity: usize) throws\n    function clear(mut this)\n    function size(this) -> usize\n    function capacity(this) -> usize\n    function hash(this) -> u32\n    function Set<A>() -> Set<A>\n    function iterator(this) -> SetIterator<V>\n}\n\nextern struct Range<T> {\n    function next(mut this) -> T?\n    function inclusive(this) -> Range<T>\n    function exclusive(this) -> Range<T>\n}\n\nextern struct Error {\n    function code(this) -> i32\n    function from_errno(anon errno: i32) -> Error\n}\n\nextern class File {\n    public function open_for_reading(anon path: String) throws -> File\n    public function open_for_writing(anon path: String) throws -> File\n\n    public function read(mut this, anon buffer: [u8]) throws -> usize\n    public function write(mut this, anon data: [u8]) throws -> usize\n\n    public function read_all(mut this) throws -> [u8]\n\n    public function exists(anon path: String) -> bool\n}\n\nextern function abort() -> never\nextern function as_saturated<U, T>(anon input: T) -> U\nextern function as_truncated<U, T>(anon input: T) -> U\nextern function unchecked_add<T>(anon a: T, anon b: T) -> T\nextern function unchecked_mul<T>(anon a: T, anon b: T) -> T\n\n// FIXME: Remove from prelude once extern C functions are working again\nextern struct FILE {}\n\nextern function fopen(anon str: raw c_char, anon mode: raw c_char) -> raw FILE\nextern function fgetc(anon mut file: raw FILE) -> c_int\nextern function fclose(anon mut file: raw FILE) -> c_int\nextern function feof(anon mut file: raw FILE) -> c_int\nextern function putchar(anon ch: c_int) -> c_int\nextern function system(anon command: raw c_char) -> c_int\n"));
}
}

ErrorOr<Array<u8>> prelude::JaktPrelude::to_bytes() {
{
const String string = prelude::JaktPrelude::to_string();
size_t pos = static_cast<size_t>(0ULL);
Array<u8> bytes_ = (TRY((Array<u8>::create_with({}))));
TRY((((bytes_).ensure_capacity(((string).length())))));
while ((pos < ((string).length()))){
TRY((((bytes_).push(((string).byte_at(pos))))));
(++pos);
}
return (bytes_);
}
}

}
namespace compiler {
class Compiler : public RefCounted<Compiler>, public Weakable<Compiler> {
  public:
virtual ~Compiler() = default;
Array<NonnullRefPtr<utility::FilePath>> files;Dictionary<String,utility::FileId> file_ids;Array<error::JaktError> errors;Optional<utility::FileId> current_file;Array<u8> current_file_contents;bool dump_lexer;bool dump_parser;bool ignore_parser_errors;bool debug_print;Array<String> include_paths;bool json_errors;bool dump_type_hints;bool dump_try_hints;ErrorOr<void> load_prelude();
ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> get_file_path(const utility::FileId file_id) const;
bool set_current_file(const utility::FileId file_id);
ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> search_for_path(const String module_name) const;
ErrorOr<utility::FileId> get_file_id_or_register(const NonnullRefPtr<utility::FilePath> file);
Optional<utility::FileId> current_file_id() const;
private:
explicit Compiler(Array<NonnullRefPtr<utility::FilePath>>&& a_files, Dictionary<String,utility::FileId>&& a_file_ids, Array<error::JaktError>&& a_errors, Optional<utility::FileId>&& a_current_file, Array<u8>&& a_current_file_contents, bool&& a_dump_lexer, bool&& a_dump_parser, bool&& a_ignore_parser_errors, bool&& a_debug_print, Array<String>&& a_include_paths, bool&& a_json_errors, bool&& a_dump_type_hints, bool&& a_dump_try_hints): files(move(a_files)), file_ids(move(a_file_ids)), errors(move(a_errors)), current_file(move(a_current_file)), current_file_contents(move(a_current_file_contents)), dump_lexer(move(a_dump_lexer)), dump_parser(move(a_dump_parser)), ignore_parser_errors(move(a_ignore_parser_errors)), debug_print(move(a_debug_print)), include_paths(move(a_include_paths)), json_errors(move(a_json_errors)), dump_type_hints(move(a_dump_type_hints)), dump_try_hints(move(a_dump_try_hints)){}
public:
static ErrorOr<NonnullRefPtr<Compiler>> create(Array<NonnullRefPtr<utility::FilePath>> files, Dictionary<String,utility::FileId> file_ids, Array<error::JaktError> errors, Optional<utility::FileId> current_file, Array<u8> current_file_contents, bool dump_lexer, bool dump_parser, bool ignore_parser_errors, bool debug_print, Array<String> include_paths, bool json_errors, bool dump_type_hints, bool dump_try_hints) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Compiler (move(files), move(file_ids), move(errors), move(current_file), move(current_file_contents), move(dump_lexer), move(dump_parser), move(ignore_parser_errors), move(debug_print), move(include_paths), move(json_errors), move(dump_type_hints), move(dump_try_hints)))); return o; }
Optional<NonnullRefPtr<utility::FilePath>> current_file_path() const;
[[noreturn]] ErrorOr<void> panic(const String message) const;
ErrorOr<void> print_errors() const;
void dbg_println(const String message) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Compiler("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("files: "));TRY(builder.appendff("{}, ", files));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_ids: "));TRY(builder.appendff("{}, ", file_ids));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("errors: "));TRY(builder.appendff("{}, ", errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_file: "));TRY(builder.appendff("{}, ", current_file));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_file_contents: "));TRY(builder.appendff("{}, ", current_file_contents));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_lexer: "));TRY(builder.appendff("{}, ", dump_lexer));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_parser: "));TRY(builder.appendff("{}, ", dump_parser));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("ignore_parser_errors: "));TRY(builder.appendff("{}, ", ignore_parser_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_print: "));TRY(builder.appendff("{}, ", debug_print));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("include_paths: "));TRY(builder.appendff("{}, ", include_paths));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("json_errors: "));TRY(builder.appendff("{}, ", json_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_type_hints: "));TRY(builder.appendff("{}, ", dump_type_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_try_hints: "));TRY(builder.appendff("{}", dump_try_hints));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};ErrorOr<void> compiler::Compiler::load_prelude() {
{
const String module_name = String("__prelude__");
const NonnullRefPtr<utility::FilePath> file_name = TRY((utility::FilePath::make(module_name)));
const Array<u8> file_contents = TRY((prelude::JaktPrelude::to_bytes()));
TRY((((*this).get_file_id_or_register(file_name))));
}
return {};
}

ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> compiler::Compiler::get_file_path(const utility::FileId file_id) const {
{
if ((((file_id).id) >= ((((*this).files)).size()))){
return (JaktInternal::OptionalNone());
}
return (((((*this).files))[((file_id).id)]));
}
}

bool compiler::Compiler::set_current_file(const utility::FileId file_id) {
{
const i32 ErrNOENT = static_cast<i32>(2);
const i32 ErrACCES = static_cast<i32>(13);
const i32 ErrFBIG = static_cast<i32>(27);
const i32 ErrNAMETOOLONG = static_cast<i32>(36);
const Optional<utility::FileId> old_file_id = ((*this).current_file);
(((*this).current_file) = file_id);
{auto _jakt_try_result = [&]() -> ErrorOr<void> {{
NonnullRefPtr<File> file = TRY((File::open_for_reading(((((((*this).files))[((file_id).id)]))->path))));
(((*this).current_file_contents) = TRY((((file)->read_all()))));
}

;return {};}();if (_jakt_try_result.is_error()) {auto error = _jakt_try_result.release_error();{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,bool>{
auto __jakt_enum_value = (((error).code()));
if (__jakt_enum_value == ErrNOENT) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: File not found"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrACCES) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: Permission denied"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrFBIG) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: File too big"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrNAMETOOLONG) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: Name too long"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else {
{
utility::panic(String("Incurred unrecognized error while trying to open file"));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(((*this).current_file) = old_file_id);
return (false);
}
}}
return (true);
}
}

ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> compiler::Compiler::search_for_path(const String module_name) const {
{
{
ArrayIterator<String> _magic = ((((*this).include_paths)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String include_path = (_magic_value.value());
{
const String candidate_path = (((include_path + String("/")) + module_name) + String(".jakt"));
if (File::exists(candidate_path)){
return (TRY((utility::FilePath::make(candidate_path))));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

ErrorOr<utility::FileId> compiler::Compiler::get_file_id_or_register(const NonnullRefPtr<utility::FilePath> file) {
{
Optional<utility::FileId> file_id = ((((*this).file_ids)).get(((file)->path)));
if (((file_id).has_value())){
return ((file_id.value()));
}
TRY((((((*this).files)).push(file))));
(file_id = utility::FileId((JaktInternal::checked_sub<size_t>(((((*this).files)).size()),static_cast<size_t>(1ULL)))));
TRY((((((*this).file_ids)).set(((file)->path),(file_id.value())))));
return ((file_id.value()));
}
}

Optional<utility::FileId> compiler::Compiler::current_file_id() const {
{
return (((*this).current_file));
}
}

Optional<NonnullRefPtr<utility::FilePath>> compiler::Compiler::current_file_path() const {
{
if (((((*this).current_file)).has_value())){
return (((((*this).files))[(((((*this).current_file).value())).id)]));
}
return (JaktInternal::OptionalNone());
}
}

[[noreturn]] ErrorOr<void> compiler::Compiler::panic(const String message) const {
{
MUST((((*this).print_errors())));
utility::panic(message);
}
}

ErrorOr<void> compiler::Compiler::print_errors() const {
{
size_t idx = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<utility::FilePath>> _magic = ((((*this).files)).iterator());
for (;;){
Optional<NonnullRefPtr<utility::FilePath>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<utility::FilePath> file = (_magic_value.value());
{
Optional<Array<u8>> file_contents = JaktInternal::OptionalNone();
const String file_name = ((file)->path);
{
ArrayIterator<error::JaktError> _magic = ((((*this).errors)).iterator());
for (;;){
Optional<error::JaktError> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
error::JaktError error = (_magic_value.value());
{
const utility::Span span = ((error).span());
if ((((((span).file_id)).id) == idx)){
if (((*this).json_errors)){
TRY((error::print_error_json(file_name,error)));
}
else {
if ((!((file_contents).has_value()))){
{auto _jakt_try_result = [&]() -> ErrorOr<void> {{
NonnullRefPtr<File> file = TRY((File::open_for_reading(file_name)));
(file_contents = TRY((((file)->read_all()))));
}

;return {};}();if (_jakt_try_result.is_error()) {auto error = _jakt_try_result.release_error();{
}
}}
}
TRY((error::print_error(file_name,file_contents,error)));
}

}
}

}
}

(idx++);
}

}
}

}
return {};
}

void compiler::Compiler::dbg_println(const String message) const {
{
if (((*this).debug_print)){
outln(String("{}"),message);
}
}
}

}
namespace lexer {
namespace LiteralSuffix_Details {
struct None {};
struct UZ {};
struct U8 {};
struct U16 {};
struct U32 {};
struct U64 {};
struct I8 {};
struct I16 {};
struct I32 {};
struct I64 {};
struct F32 {};
struct F64 {};
}
struct LiteralSuffix : public Variant<LiteralSuffix_Details::None, LiteralSuffix_Details::UZ, LiteralSuffix_Details::U8, LiteralSuffix_Details::U16, LiteralSuffix_Details::U32, LiteralSuffix_Details::U64, LiteralSuffix_Details::I8, LiteralSuffix_Details::I16, LiteralSuffix_Details::I32, LiteralSuffix_Details::I64, LiteralSuffix_Details::F32, LiteralSuffix_Details::F64> {
using Variant<LiteralSuffix_Details::None, LiteralSuffix_Details::UZ, LiteralSuffix_Details::U8, LiteralSuffix_Details::U16, LiteralSuffix_Details::U32, LiteralSuffix_Details::U64, LiteralSuffix_Details::I8, LiteralSuffix_Details::I16, LiteralSuffix_Details::I32, LiteralSuffix_Details::I64, LiteralSuffix_Details::F32, LiteralSuffix_Details::F64>::Variant;
    using None = LiteralSuffix_Details::None;
    using UZ = LiteralSuffix_Details::UZ;
    using U8 = LiteralSuffix_Details::U8;
    using U16 = LiteralSuffix_Details::U16;
    using U32 = LiteralSuffix_Details::U32;
    using U64 = LiteralSuffix_Details::U64;
    using I8 = LiteralSuffix_Details::I8;
    using I16 = LiteralSuffix_Details::I16;
    using I32 = LiteralSuffix_Details::I32;
    using I64 = LiteralSuffix_Details::I64;
    using F32 = LiteralSuffix_Details::F32;
    using F64 = LiteralSuffix_Details::F64;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] None const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::None"));return {}; },[&]([[maybe_unused]] UZ const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::UZ"));return {}; },[&]([[maybe_unused]] U8 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::U8"));return {}; },[&]([[maybe_unused]] U16 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::U16"));return {}; },[&]([[maybe_unused]] U32 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::U32"));return {}; },[&]([[maybe_unused]] U64 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::U64"));return {}; },[&]([[maybe_unused]] I8 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::I8"));return {}; },[&]([[maybe_unused]] I16 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::I16"));return {}; },[&]([[maybe_unused]] I32 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::I32"));return {}; },[&]([[maybe_unused]] I64 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::I64"));return {}; },[&]([[maybe_unused]] F32 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::F32"));return {}; },[&]([[maybe_unused]] F64 const& that) -> ErrorOr<void> {
TRY(builder.append("LiteralSuffix::F64"));return {}; }));return builder.to_string();}};
namespace NumericConstant_Details {
struct I8{
i8 value;
template<typename... Args>
I8(Args&&... args): value { forward<Args>(args)... } {}
};
struct I16{
i16 value;
template<typename... Args>
I16(Args&&... args): value { forward<Args>(args)... } {}
};
struct I32{
i32 value;
template<typename... Args>
I32(Args&&... args): value { forward<Args>(args)... } {}
};
struct I64{
i64 value;
template<typename... Args>
I64(Args&&... args): value { forward<Args>(args)... } {}
};
struct U8{
u8 value;
template<typename... Args>
U8(Args&&... args): value { forward<Args>(args)... } {}
};
struct U16{
u16 value;
template<typename... Args>
U16(Args&&... args): value { forward<Args>(args)... } {}
};
struct U32{
u32 value;
template<typename... Args>
U32(Args&&... args): value { forward<Args>(args)... } {}
};
struct U64{
u64 value;
template<typename... Args>
U64(Args&&... args): value { forward<Args>(args)... } {}
};
struct USize{
u64 value;
template<typename... Args>
USize(Args&&... args): value { forward<Args>(args)... } {}
};
struct F32{
f32 value;
template<typename... Args>
F32(Args&&... args): value { forward<Args>(args)... } {}
};
struct F64{
f64 value;
template<typename... Args>
F64(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct NumericConstant : public Variant<NumericConstant_Details::I8, NumericConstant_Details::I16, NumericConstant_Details::I32, NumericConstant_Details::I64, NumericConstant_Details::U8, NumericConstant_Details::U16, NumericConstant_Details::U32, NumericConstant_Details::U64, NumericConstant_Details::USize, NumericConstant_Details::F32, NumericConstant_Details::F64> {
using Variant<NumericConstant_Details::I8, NumericConstant_Details::I16, NumericConstant_Details::I32, NumericConstant_Details::I64, NumericConstant_Details::U8, NumericConstant_Details::U16, NumericConstant_Details::U32, NumericConstant_Details::U64, NumericConstant_Details::USize, NumericConstant_Details::F32, NumericConstant_Details::F64>::Variant;
    using I8 = NumericConstant_Details::I8;
    using I16 = NumericConstant_Details::I16;
    using I32 = NumericConstant_Details::I32;
    using I64 = NumericConstant_Details::I64;
    using U8 = NumericConstant_Details::U8;
    using U16 = NumericConstant_Details::U16;
    using U32 = NumericConstant_Details::U32;
    using U64 = NumericConstant_Details::U64;
    using USize = NumericConstant_Details::USize;
    using F32 = NumericConstant_Details::F32;
    using F64 = NumericConstant_Details::F64;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] I8 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::I8"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I16 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::I16"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I32 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::I32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I64 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::I64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U8 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::U8"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U16 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::U16"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U32 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::U32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U64 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::U64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] USize const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::USize"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] F32 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::F32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] F64 const& that) -> ErrorOr<void> {
TRY(builder.append("NumericConstant::F64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}size_t to_usize() const;
};
namespace Token_Details {
struct SingleQuotedString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedByteString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedByteString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct QuotedString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Number {
lexer::NumericConstant number;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Number(_MemberT0&& member_0, _MemberT1&& member_1):
number{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Identifier {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Identifier(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Semicolon{
utility::Span value;
template<typename... Args>
Semicolon(Args&&... args): value { forward<Args>(args)... } {}
};
struct Colon{
utility::Span value;
template<typename... Args>
Colon(Args&&... args): value { forward<Args>(args)... } {}
};
struct ColonColon{
utility::Span value;
template<typename... Args>
ColonColon(Args&&... args): value { forward<Args>(args)... } {}
};
struct LParen{
utility::Span value;
template<typename... Args>
LParen(Args&&... args): value { forward<Args>(args)... } {}
};
struct RParen{
utility::Span value;
template<typename... Args>
RParen(Args&&... args): value { forward<Args>(args)... } {}
};
struct LCurly{
utility::Span value;
template<typename... Args>
LCurly(Args&&... args): value { forward<Args>(args)... } {}
};
struct RCurly{
utility::Span value;
template<typename... Args>
RCurly(Args&&... args): value { forward<Args>(args)... } {}
};
struct LSquare{
utility::Span value;
template<typename... Args>
LSquare(Args&&... args): value { forward<Args>(args)... } {}
};
struct RSquare{
utility::Span value;
template<typename... Args>
RSquare(Args&&... args): value { forward<Args>(args)... } {}
};
struct PercentSign{
utility::Span value;
template<typename... Args>
PercentSign(Args&&... args): value { forward<Args>(args)... } {}
};
struct Plus{
utility::Span value;
template<typename... Args>
Plus(Args&&... args): value { forward<Args>(args)... } {}
};
struct Minus{
utility::Span value;
template<typename... Args>
Minus(Args&&... args): value { forward<Args>(args)... } {}
};
struct Equal{
utility::Span value;
template<typename... Args>
Equal(Args&&... args): value { forward<Args>(args)... } {}
};
struct PlusEqual{
utility::Span value;
template<typename... Args>
PlusEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct PlusPlus{
utility::Span value;
template<typename... Args>
PlusPlus(Args&&... args): value { forward<Args>(args)... } {}
};
struct MinusEqual{
utility::Span value;
template<typename... Args>
MinusEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct MinusMinus{
utility::Span value;
template<typename... Args>
MinusMinus(Args&&... args): value { forward<Args>(args)... } {}
};
struct AsteriskEqual{
utility::Span value;
template<typename... Args>
AsteriskEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct ForwardSlashEqual{
utility::Span value;
template<typename... Args>
ForwardSlashEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct PercentSignEqual{
utility::Span value;
template<typename... Args>
PercentSignEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct NotEqual{
utility::Span value;
template<typename... Args>
NotEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct DoubleEqual{
utility::Span value;
template<typename... Args>
DoubleEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct GreaterThan{
utility::Span value;
template<typename... Args>
GreaterThan(Args&&... args): value { forward<Args>(args)... } {}
};
struct GreaterThanOrEqual{
utility::Span value;
template<typename... Args>
GreaterThanOrEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct LessThan{
utility::Span value;
template<typename... Args>
LessThan(Args&&... args): value { forward<Args>(args)... } {}
};
struct LessThanOrEqual{
utility::Span value;
template<typename... Args>
LessThanOrEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftArithmeticShift{
utility::Span value;
template<typename... Args>
LeftArithmeticShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftShift{
utility::Span value;
template<typename... Args>
LeftShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftShiftEqual{
utility::Span value;
template<typename... Args>
LeftShiftEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightShift{
utility::Span value;
template<typename... Args>
RightShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightArithmeticShift{
utility::Span value;
template<typename... Args>
RightArithmeticShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightShiftEqual{
utility::Span value;
template<typename... Args>
RightShiftEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Asterisk{
utility::Span value;
template<typename... Args>
Asterisk(Args&&... args): value { forward<Args>(args)... } {}
};
struct Ampersand{
utility::Span value;
template<typename... Args>
Ampersand(Args&&... args): value { forward<Args>(args)... } {}
};
struct AmpersandEqual{
utility::Span value;
template<typename... Args>
AmpersandEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Pipe{
utility::Span value;
template<typename... Args>
Pipe(Args&&... args): value { forward<Args>(args)... } {}
};
struct PipeEqual{
utility::Span value;
template<typename... Args>
PipeEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Caret{
utility::Span value;
template<typename... Args>
Caret(Args&&... args): value { forward<Args>(args)... } {}
};
struct CaretEqual{
utility::Span value;
template<typename... Args>
CaretEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Dollar{
utility::Span value;
template<typename... Args>
Dollar(Args&&... args): value { forward<Args>(args)... } {}
};
struct Tilde{
utility::Span value;
template<typename... Args>
Tilde(Args&&... args): value { forward<Args>(args)... } {}
};
struct ForwardSlash{
utility::Span value;
template<typename... Args>
ForwardSlash(Args&&... args): value { forward<Args>(args)... } {}
};
struct ExclamationPoint{
utility::Span value;
template<typename... Args>
ExclamationPoint(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMark{
utility::Span value;
template<typename... Args>
QuestionMark(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMarkQuestionMark{
utility::Span value;
template<typename... Args>
QuestionMarkQuestionMark(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMarkQuestionMarkEqual{
utility::Span value;
template<typename... Args>
QuestionMarkQuestionMarkEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Comma{
utility::Span value;
template<typename... Args>
Comma(Args&&... args): value { forward<Args>(args)... } {}
};
struct Dot{
utility::Span value;
template<typename... Args>
Dot(Args&&... args): value { forward<Args>(args)... } {}
};
struct DotDot{
utility::Span value;
template<typename... Args>
DotDot(Args&&... args): value { forward<Args>(args)... } {}
};
struct Eol{
utility::Span value;
template<typename... Args>
Eol(Args&&... args): value { forward<Args>(args)... } {}
};
struct Eof{
utility::Span value;
template<typename... Args>
Eof(Args&&... args): value { forward<Args>(args)... } {}
};
struct FatArrow{
utility::Span value;
template<typename... Args>
FatArrow(Args&&... args): value { forward<Args>(args)... } {}
};
struct Arrow{
utility::Span value;
template<typename... Args>
Arrow(Args&&... args): value { forward<Args>(args)... } {}
};
struct And{
utility::Span value;
template<typename... Args>
And(Args&&... args): value { forward<Args>(args)... } {}
};
struct Anon{
utility::Span value;
template<typename... Args>
Anon(Args&&... args): value { forward<Args>(args)... } {}
};
struct As{
utility::Span value;
template<typename... Args>
As(Args&&... args): value { forward<Args>(args)... } {}
};
struct Boxed{
utility::Span value;
template<typename... Args>
Boxed(Args&&... args): value { forward<Args>(args)... } {}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Catch{
utility::Span value;
template<typename... Args>
Catch(Args&&... args): value { forward<Args>(args)... } {}
};
struct Class{
utility::Span value;
template<typename... Args>
Class(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Cpp{
utility::Span value;
template<typename... Args>
Cpp(Args&&... args): value { forward<Args>(args)... } {}
};
struct Defer{
utility::Span value;
template<typename... Args>
Defer(Args&&... args): value { forward<Args>(args)... } {}
};
struct Else{
utility::Span value;
template<typename... Args>
Else(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
utility::Span value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
struct Extern{
utility::Span value;
template<typename... Args>
Extern(Args&&... args): value { forward<Args>(args)... } {}
};
struct False{
utility::Span value;
template<typename... Args>
False(Args&&... args): value { forward<Args>(args)... } {}
};
struct For{
utility::Span value;
template<typename... Args>
For(Args&&... args): value { forward<Args>(args)... } {}
};
struct Function{
utility::Span value;
template<typename... Args>
Function(Args&&... args): value { forward<Args>(args)... } {}
};
struct If{
utility::Span value;
template<typename... Args>
If(Args&&... args): value { forward<Args>(args)... } {}
};
struct Import{
utility::Span value;
template<typename... Args>
Import(Args&&... args): value { forward<Args>(args)... } {}
};
struct In{
utility::Span value;
template<typename... Args>
In(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
utility::Span value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct Let{
utility::Span value;
template<typename... Args>
Let(Args&&... args): value { forward<Args>(args)... } {}
};
struct Loop{
utility::Span value;
template<typename... Args>
Loop(Args&&... args): value { forward<Args>(args)... } {}
};
struct Match{
utility::Span value;
template<typename... Args>
Match(Args&&... args): value { forward<Args>(args)... } {}
};
struct Mut{
utility::Span value;
template<typename... Args>
Mut(Args&&... args): value { forward<Args>(args)... } {}
};
struct Namespace{
utility::Span value;
template<typename... Args>
Namespace(Args&&... args): value { forward<Args>(args)... } {}
};
struct Not{
utility::Span value;
template<typename... Args>
Not(Args&&... args): value { forward<Args>(args)... } {}
};
struct Or{
utility::Span value;
template<typename... Args>
Or(Args&&... args): value { forward<Args>(args)... } {}
};
struct Private{
utility::Span value;
template<typename... Args>
Private(Args&&... args): value { forward<Args>(args)... } {}
};
struct Public{
utility::Span value;
template<typename... Args>
Public(Args&&... args): value { forward<Args>(args)... } {}
};
struct Raw{
utility::Span value;
template<typename... Args>
Raw(Args&&... args): value { forward<Args>(args)... } {}
};
struct Return{
utility::Span value;
template<typename... Args>
Return(Args&&... args): value { forward<Args>(args)... } {}
};
struct Restricted{
utility::Span value;
template<typename... Args>
Restricted(Args&&... args): value { forward<Args>(args)... } {}
};
struct Struct{
utility::Span value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct This{
utility::Span value;
template<typename... Args>
This(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw{
utility::Span value;
template<typename... Args>
Throw(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throws{
utility::Span value;
template<typename... Args>
Throws(Args&&... args): value { forward<Args>(args)... } {}
};
struct True{
utility::Span value;
template<typename... Args>
True(Args&&... args): value { forward<Args>(args)... } {}
};
struct Try{
utility::Span value;
template<typename... Args>
Try(Args&&... args): value { forward<Args>(args)... } {}
};
struct Unsafe{
utility::Span value;
template<typename... Args>
Unsafe(Args&&... args): value { forward<Args>(args)... } {}
};
struct Weak{
utility::Span value;
template<typename... Args>
Weak(Args&&... args): value { forward<Args>(args)... } {}
};
struct While{
utility::Span value;
template<typename... Args>
While(Args&&... args): value { forward<Args>(args)... } {}
};
struct Yield{
utility::Span value;
template<typename... Args>
Yield(Args&&... args): value { forward<Args>(args)... } {}
};
struct Guard{
utility::Span value;
template<typename... Args>
Guard(Args&&... args): value { forward<Args>(args)... } {}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct Token : public Variant<Token_Details::SingleQuotedString, Token_Details::SingleQuotedByteString, Token_Details::QuotedString, Token_Details::Number, Token_Details::Identifier, Token_Details::Semicolon, Token_Details::Colon, Token_Details::ColonColon, Token_Details::LParen, Token_Details::RParen, Token_Details::LCurly, Token_Details::RCurly, Token_Details::LSquare, Token_Details::RSquare, Token_Details::PercentSign, Token_Details::Plus, Token_Details::Minus, Token_Details::Equal, Token_Details::PlusEqual, Token_Details::PlusPlus, Token_Details::MinusEqual, Token_Details::MinusMinus, Token_Details::AsteriskEqual, Token_Details::ForwardSlashEqual, Token_Details::PercentSignEqual, Token_Details::NotEqual, Token_Details::DoubleEqual, Token_Details::GreaterThan, Token_Details::GreaterThanOrEqual, Token_Details::LessThan, Token_Details::LessThanOrEqual, Token_Details::LeftArithmeticShift, Token_Details::LeftShift, Token_Details::LeftShiftEqual, Token_Details::RightShift, Token_Details::RightArithmeticShift, Token_Details::RightShiftEqual, Token_Details::Asterisk, Token_Details::Ampersand, Token_Details::AmpersandEqual, Token_Details::Pipe, Token_Details::PipeEqual, Token_Details::Caret, Token_Details::CaretEqual, Token_Details::Dollar, Token_Details::Tilde, Token_Details::ForwardSlash, Token_Details::ExclamationPoint, Token_Details::QuestionMark, Token_Details::QuestionMarkQuestionMark, Token_Details::QuestionMarkQuestionMarkEqual, Token_Details::Comma, Token_Details::Dot, Token_Details::DotDot, Token_Details::Eol, Token_Details::Eof, Token_Details::FatArrow, Token_Details::Arrow, Token_Details::And, Token_Details::Anon, Token_Details::As, Token_Details::Boxed, Token_Details::Break, Token_Details::Catch, Token_Details::Class, Token_Details::Continue, Token_Details::Cpp, Token_Details::Defer, Token_Details::Else, Token_Details::Enum, Token_Details::Extern, Token_Details::False, Token_Details::For, Token_Details::Function, Token_Details::If, Token_Details::Import, Token_Details::In, Token_Details::Is, Token_Details::Let, Token_Details::Loop, Token_Details::Match, Token_Details::Mut, Token_Details::Namespace, Token_Details::Not, Token_Details::Or, Token_Details::Private, Token_Details::Public, Token_Details::Raw, Token_Details::Return, Token_Details::Restricted, Token_Details::Struct, Token_Details::This, Token_Details::Throw, Token_Details::Throws, Token_Details::True, Token_Details::Try, Token_Details::Unsafe, Token_Details::Weak, Token_Details::While, Token_Details::Yield, Token_Details::Guard, Token_Details::Garbage> {
using Variant<Token_Details::SingleQuotedString, Token_Details::SingleQuotedByteString, Token_Details::QuotedString, Token_Details::Number, Token_Details::Identifier, Token_Details::Semicolon, Token_Details::Colon, Token_Details::ColonColon, Token_Details::LParen, Token_Details::RParen, Token_Details::LCurly, Token_Details::RCurly, Token_Details::LSquare, Token_Details::RSquare, Token_Details::PercentSign, Token_Details::Plus, Token_Details::Minus, Token_Details::Equal, Token_Details::PlusEqual, Token_Details::PlusPlus, Token_Details::MinusEqual, Token_Details::MinusMinus, Token_Details::AsteriskEqual, Token_Details::ForwardSlashEqual, Token_Details::PercentSignEqual, Token_Details::NotEqual, Token_Details::DoubleEqual, Token_Details::GreaterThan, Token_Details::GreaterThanOrEqual, Token_Details::LessThan, Token_Details::LessThanOrEqual, Token_Details::LeftArithmeticShift, Token_Details::LeftShift, Token_Details::LeftShiftEqual, Token_Details::RightShift, Token_Details::RightArithmeticShift, Token_Details::RightShiftEqual, Token_Details::Asterisk, Token_Details::Ampersand, Token_Details::AmpersandEqual, Token_Details::Pipe, Token_Details::PipeEqual, Token_Details::Caret, Token_Details::CaretEqual, Token_Details::Dollar, Token_Details::Tilde, Token_Details::ForwardSlash, Token_Details::ExclamationPoint, Token_Details::QuestionMark, Token_Details::QuestionMarkQuestionMark, Token_Details::QuestionMarkQuestionMarkEqual, Token_Details::Comma, Token_Details::Dot, Token_Details::DotDot, Token_Details::Eol, Token_Details::Eof, Token_Details::FatArrow, Token_Details::Arrow, Token_Details::And, Token_Details::Anon, Token_Details::As, Token_Details::Boxed, Token_Details::Break, Token_Details::Catch, Token_Details::Class, Token_Details::Continue, Token_Details::Cpp, Token_Details::Defer, Token_Details::Else, Token_Details::Enum, Token_Details::Extern, Token_Details::False, Token_Details::For, Token_Details::Function, Token_Details::If, Token_Details::Import, Token_Details::In, Token_Details::Is, Token_Details::Let, Token_Details::Loop, Token_Details::Match, Token_Details::Mut, Token_Details::Namespace, Token_Details::Not, Token_Details::Or, Token_Details::Private, Token_Details::Public, Token_Details::Raw, Token_Details::Return, Token_Details::Restricted, Token_Details::Struct, Token_Details::This, Token_Details::Throw, Token_Details::Throws, Token_Details::True, Token_Details::Try, Token_Details::Unsafe, Token_Details::Weak, Token_Details::While, Token_Details::Yield, Token_Details::Guard, Token_Details::Garbage>::Variant;
    using SingleQuotedString = Token_Details::SingleQuotedString;
    using SingleQuotedByteString = Token_Details::SingleQuotedByteString;
    using QuotedString = Token_Details::QuotedString;
    using Number = Token_Details::Number;
    using Identifier = Token_Details::Identifier;
    using Semicolon = Token_Details::Semicolon;
    using Colon = Token_Details::Colon;
    using ColonColon = Token_Details::ColonColon;
    using LParen = Token_Details::LParen;
    using RParen = Token_Details::RParen;
    using LCurly = Token_Details::LCurly;
    using RCurly = Token_Details::RCurly;
    using LSquare = Token_Details::LSquare;
    using RSquare = Token_Details::RSquare;
    using PercentSign = Token_Details::PercentSign;
    using Plus = Token_Details::Plus;
    using Minus = Token_Details::Minus;
    using Equal = Token_Details::Equal;
    using PlusEqual = Token_Details::PlusEqual;
    using PlusPlus = Token_Details::PlusPlus;
    using MinusEqual = Token_Details::MinusEqual;
    using MinusMinus = Token_Details::MinusMinus;
    using AsteriskEqual = Token_Details::AsteriskEqual;
    using ForwardSlashEqual = Token_Details::ForwardSlashEqual;
    using PercentSignEqual = Token_Details::PercentSignEqual;
    using NotEqual = Token_Details::NotEqual;
    using DoubleEqual = Token_Details::DoubleEqual;
    using GreaterThan = Token_Details::GreaterThan;
    using GreaterThanOrEqual = Token_Details::GreaterThanOrEqual;
    using LessThan = Token_Details::LessThan;
    using LessThanOrEqual = Token_Details::LessThanOrEqual;
    using LeftArithmeticShift = Token_Details::LeftArithmeticShift;
    using LeftShift = Token_Details::LeftShift;
    using LeftShiftEqual = Token_Details::LeftShiftEqual;
    using RightShift = Token_Details::RightShift;
    using RightArithmeticShift = Token_Details::RightArithmeticShift;
    using RightShiftEqual = Token_Details::RightShiftEqual;
    using Asterisk = Token_Details::Asterisk;
    using Ampersand = Token_Details::Ampersand;
    using AmpersandEqual = Token_Details::AmpersandEqual;
    using Pipe = Token_Details::Pipe;
    using PipeEqual = Token_Details::PipeEqual;
    using Caret = Token_Details::Caret;
    using CaretEqual = Token_Details::CaretEqual;
    using Dollar = Token_Details::Dollar;
    using Tilde = Token_Details::Tilde;
    using ForwardSlash = Token_Details::ForwardSlash;
    using ExclamationPoint = Token_Details::ExclamationPoint;
    using QuestionMark = Token_Details::QuestionMark;
    using QuestionMarkQuestionMark = Token_Details::QuestionMarkQuestionMark;
    using QuestionMarkQuestionMarkEqual = Token_Details::QuestionMarkQuestionMarkEqual;
    using Comma = Token_Details::Comma;
    using Dot = Token_Details::Dot;
    using DotDot = Token_Details::DotDot;
    using Eol = Token_Details::Eol;
    using Eof = Token_Details::Eof;
    using FatArrow = Token_Details::FatArrow;
    using Arrow = Token_Details::Arrow;
    using And = Token_Details::And;
    using Anon = Token_Details::Anon;
    using As = Token_Details::As;
    using Boxed = Token_Details::Boxed;
    using Break = Token_Details::Break;
    using Catch = Token_Details::Catch;
    using Class = Token_Details::Class;
    using Continue = Token_Details::Continue;
    using Cpp = Token_Details::Cpp;
    using Defer = Token_Details::Defer;
    using Else = Token_Details::Else;
    using Enum = Token_Details::Enum;
    using Extern = Token_Details::Extern;
    using False = Token_Details::False;
    using For = Token_Details::For;
    using Function = Token_Details::Function;
    using If = Token_Details::If;
    using Import = Token_Details::Import;
    using In = Token_Details::In;
    using Is = Token_Details::Is;
    using Let = Token_Details::Let;
    using Loop = Token_Details::Loop;
    using Match = Token_Details::Match;
    using Mut = Token_Details::Mut;
    using Namespace = Token_Details::Namespace;
    using Not = Token_Details::Not;
    using Or = Token_Details::Or;
    using Private = Token_Details::Private;
    using Public = Token_Details::Public;
    using Raw = Token_Details::Raw;
    using Return = Token_Details::Return;
    using Restricted = Token_Details::Restricted;
    using Struct = Token_Details::Struct;
    using This = Token_Details::This;
    using Throw = Token_Details::Throw;
    using Throws = Token_Details::Throws;
    using True = Token_Details::True;
    using Try = Token_Details::Try;
    using Unsafe = Token_Details::Unsafe;
    using Weak = Token_Details::Weak;
    using While = Token_Details::While;
    using Yield = Token_Details::Yield;
    using Guard = Token_Details::Guard;
    using Garbage = Token_Details::Garbage;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] SingleQuotedString const& that) -> ErrorOr<void> {
TRY(builder.append("Token::SingleQuotedString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("quote: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.quote));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] SingleQuotedByteString const& that) -> ErrorOr<void> {
TRY(builder.append("Token::SingleQuotedByteString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("quote: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.quote));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuotedString const& that) -> ErrorOr<void> {
TRY(builder.append("Token::QuotedString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("quote: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.quote));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Number const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Number"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("number: "));TRY(builder.appendff("{}", that.number));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Identifier const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Identifier"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Semicolon const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Semicolon"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Colon const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Colon"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ColonColon const& that) -> ErrorOr<void> {
TRY(builder.append("Token::ColonColon"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LParen const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LParen"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RParen const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RParen"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LCurly const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LCurly"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RCurly const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RCurly"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LSquare const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LSquare"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RSquare const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RSquare"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PercentSign const& that) -> ErrorOr<void> {
TRY(builder.append("Token::PercentSign"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Plus const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Plus"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Minus const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Minus"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Equal const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Equal"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PlusEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::PlusEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PlusPlus const& that) -> ErrorOr<void> {
TRY(builder.append("Token::PlusPlus"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MinusEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::MinusEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MinusMinus const& that) -> ErrorOr<void> {
TRY(builder.append("Token::MinusMinus"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] AsteriskEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::AsteriskEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ForwardSlashEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::ForwardSlashEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PercentSignEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::PercentSignEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NotEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::NotEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] DoubleEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::DoubleEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GreaterThan const& that) -> ErrorOr<void> {
TRY(builder.append("Token::GreaterThan"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GreaterThanOrEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::GreaterThanOrEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LessThan const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LessThan"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LessThanOrEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LessThanOrEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LeftArithmeticShift const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LeftArithmeticShift"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LeftShift const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LeftShift"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] LeftShiftEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::LeftShiftEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RightShift const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RightShift"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RightArithmeticShift const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RightArithmeticShift"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RightShiftEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::RightShiftEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Asterisk const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Asterisk"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Ampersand const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Ampersand"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] AmpersandEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::AmpersandEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Pipe const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Pipe"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PipeEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::PipeEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Caret const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Caret"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] CaretEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::CaretEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Dollar const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Dollar"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Tilde const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Tilde"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ForwardSlash const& that) -> ErrorOr<void> {
TRY(builder.append("Token::ForwardSlash"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ExclamationPoint const& that) -> ErrorOr<void> {
TRY(builder.append("Token::ExclamationPoint"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuestionMark const& that) -> ErrorOr<void> {
TRY(builder.append("Token::QuestionMark"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuestionMarkQuestionMark const& that) -> ErrorOr<void> {
TRY(builder.append("Token::QuestionMarkQuestionMark"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuestionMarkQuestionMarkEqual const& that) -> ErrorOr<void> {
TRY(builder.append("Token::QuestionMarkQuestionMarkEqual"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Comma const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Comma"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Dot const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Dot"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] DotDot const& that) -> ErrorOr<void> {
TRY(builder.append("Token::DotDot"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Eol const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Eol"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Eof const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Eof"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] FatArrow const& that) -> ErrorOr<void> {
TRY(builder.append("Token::FatArrow"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Arrow const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Arrow"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] And const& that) -> ErrorOr<void> {
TRY(builder.append("Token::And"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Anon const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Anon"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] As const& that) -> ErrorOr<void> {
TRY(builder.append("Token::As"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Boxed const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Boxed"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Break const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Break"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Catch const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Catch"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Class const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Class"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Continue const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Continue"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Cpp const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Cpp"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Defer const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Defer"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Else const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Else"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Enum const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Enum"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Extern const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Extern"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] False const& that) -> ErrorOr<void> {
TRY(builder.append("Token::False"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] For const& that) -> ErrorOr<void> {
TRY(builder.append("Token::For"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Function const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Function"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] If const& that) -> ErrorOr<void> {
TRY(builder.append("Token::If"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Import const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Import"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] In const& that) -> ErrorOr<void> {
TRY(builder.append("Token::In"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Is const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Is"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Let const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Let"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Loop const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Loop"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Match const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Match"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Mut const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Mut"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Namespace const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Namespace"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Not const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Not"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Or const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Or"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Private const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Private"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Public const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Public"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Raw const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Raw"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Return const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Return"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Restricted const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Restricted"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Struct const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Struct"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] This const& that) -> ErrorOr<void> {
TRY(builder.append("Token::This"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Throw const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Throw"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Throws const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Throws"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] True const& that) -> ErrorOr<void> {
TRY(builder.append("Token::True"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Try const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Try"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Unsafe const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Unsafe"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Weak const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Weak"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] While const& that) -> ErrorOr<void> {
TRY(builder.append("Token::While"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Yield const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Yield"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Guard const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Guard"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("Token::Garbage"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}static lexer::Token from_keyword_or_identifier(const String string, const utility::Span span);
utility::Span span() const;
};
struct Lexer {
  public:
size_t index;Array<u8> input;NonnullRefPtr<compiler::Compiler> compiler;ErrorOr<lexer::Token> lex_quoted_string(const u8 delimiter);
ErrorOr<Optional<lexer::Token>> next();
bool is_whitespace(const u8 ch) const;
ErrorOr<lexer::Token> lex_character_constant_or_name();
lexer::Token lex_dot();
ErrorOr<lexer::Token> make_integer_token(const u64 number, const lexer::LiteralSuffix suffix, const utility::Span span);
ErrorOr<lexer::Token> lex_forward_slash();
lexer::Token lex_question_mark();
u8 peek_behind(const size_t steps) const;
u8 peek_ahead(const size_t steps) const;
lexer::Token lex_asterisk();
u8 peek() const;
lexer::Token lex_percent_sign();
ErrorOr<lexer::Token> lex_number_or_name();
lexer::Token lex_minus();
bool eof() const;
lexer::Token lex_ampersand();
utility::Span span(const size_t start, const size_t end) const;
lexer::Token lex_plus();
lexer::Token lex_exclamation_point();
Optional<lexer::LiteralSuffix> consume_numeric_literal_suffix();
lexer::Token lex_colon();
Lexer(size_t a_index, Array<u8> a_input, NonnullRefPtr<compiler::Compiler> a_compiler) :index(a_index), input(a_input), compiler(a_compiler){}

ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<String> substring(const size_t start, const size_t length) const;
lexer::Token lex_greater_than();
lexer::Token lex_pipe();
lexer::Token lex_caret();
ErrorOr<lexer::Token> lex_number();
lexer::Token lex_less_than();
lexer::Token lex_equals();
static ErrorOr<Array<lexer::Token>> lex(const NonnullRefPtr<compiler::Compiler> compiler);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Lexer("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}, ", index));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("input: "));TRY(builder.appendff("{}, ", input));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}", *compiler));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static bool is_ascii_alphanumeric(const u8 c) {
{
return ((lexer::is_ascii_alpha(c) || lexer::is_ascii_digit(c)));
}
}

static bool is_ascii_alpha(const u8 c) {
{
return ((((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))));
}
}

static f32 f64_to_f32(const f64 number) {
{
f32 f32_value = static_cast<i64>(0LL);
{
f32_value = (f32)number;
}

return (f32_value);
}
}

static ErrorOr<lexer::Token> make_float_token(const f64 number,const lexer::LiteralSuffix suffix,const utility::Span span) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(typename lexer::Token::Number(typename lexer::NumericConstant::F32(lexer::f64_to_f32(number)),span));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(typename lexer::Token::Number(typename lexer::NumericConstant::F64(number),span));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename lexer::Token::Garbage(span));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static bool is_ascii_octdigit(const u8 c) {
{
return (((c >= '0') && (c <= '7')));
}
}

static bool is_ascii_hexdigit(const u8 c) {
{
return (((((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'f'))) || ((c >= 'A') && (c <= 'F'))));
}
}

template <typename T>
static T u64_to_float(const u64 number) {
{
i64 float_value = static_cast<i64>(0LL);
{
float_value = number;
}

return (float_value);
}
}

static bool is_ascii_digit(const u8 c) {
{
return (((c >= '0') && (c <= '9')));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_quoted_string(const u8 delimiter) {
{
const size_t start = ((*this).index);
(++((*this).index));
if (((*this).eof())){
TRY((((*this).error(String("unexpected eof"),((*this).span(start,start))))));
return (typename lexer::Token::Garbage(((*this).span(start,start))));
}
bool escaped = false;
while (((!((*this).eof())) && (escaped || (((*this).peek()) != delimiter)))){
if (((((*this).peek()) == '\r') || (((*this).peek()) == '\n'))){
(++((*this).index));
continue;
}
if (((!escaped) && (((*this).peek()) == '\\'))){
(escaped = true);
}
else {
(escaped = false);
}

(++((*this).index));
}
const String str = TRY((((*this).substring((JaktInternal::checked_add<size_t>(start,static_cast<size_t>(1ULL))),((*this).index)))));
(((*this).index)++);
const size_t end = ((*this).index);
if ((delimiter == '\'')){
return (typename lexer::Token::SingleQuotedString(str,((*this).span(start,end))));
}
return (typename lexer::Token::QuotedString(str,((*this).span(start,end))));
}
}

ErrorOr<Optional<lexer::Token>> lexer::Lexer::next() {
{
for (;;){
if ((((*this).index) == ((((*this).input)).size()))){
(++((*this).index));
return (typename lexer::Token::Eof(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)))))));
}
if (((*this).eof())){
return (JaktInternal::OptionalNone());
}
const u8 ch = ((*this).peek());
if (((*this).is_whitespace(ch))){
(((*this).index)++);
}
else {
break;
}

}
const size_t start = ((*this).index);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,ErrorOr<Optional<lexer::Token>>>{
auto __jakt_enum_value = (((((*this).input))[((*this).index)]));
if (__jakt_enum_value == '(') {
return JaktInternal::ExplicitValue(typename lexer::Token::LParen(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == ')') {
return JaktInternal::ExplicitValue(typename lexer::Token::RParen(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '[') {
return JaktInternal::ExplicitValue(typename lexer::Token::LSquare(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == ']') {
return JaktInternal::ExplicitValue(typename lexer::Token::RSquare(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '{') {
return JaktInternal::ExplicitValue(typename lexer::Token::LCurly(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '}') {
return JaktInternal::ExplicitValue(typename lexer::Token::RCurly(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(((*this).lex_less_than()));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(((*this).lex_greater_than()));
}
else if (__jakt_enum_value == '.') {
return JaktInternal::ExplicitValue(((*this).lex_dot()));
}
else if (__jakt_enum_value == ',') {
return JaktInternal::ExplicitValue(typename lexer::Token::Comma(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '~') {
return JaktInternal::ExplicitValue(typename lexer::Token::Tilde(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == ';') {
return JaktInternal::ExplicitValue(typename lexer::Token::Semicolon(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == ':') {
return JaktInternal::ExplicitValue(((*this).lex_colon()));
}
else if (__jakt_enum_value == '?') {
return JaktInternal::ExplicitValue(((*this).lex_question_mark()));
}
else if (__jakt_enum_value == '+') {
return JaktInternal::ExplicitValue(((*this).lex_plus()));
}
else if (__jakt_enum_value == '-') {
return JaktInternal::ExplicitValue(((*this).lex_minus()));
}
else if (__jakt_enum_value == '*') {
return JaktInternal::ExplicitValue(((*this).lex_asterisk()));
}
else if (__jakt_enum_value == '/') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_forward_slash()))));
}
else if (__jakt_enum_value == '^') {
return JaktInternal::ExplicitValue(((*this).lex_caret()));
}
else if (__jakt_enum_value == '|') {
return JaktInternal::ExplicitValue(((*this).lex_pipe()));
}
else if (__jakt_enum_value == '%') {
return JaktInternal::ExplicitValue(((*this).lex_percent_sign()));
}
else if (__jakt_enum_value == '!') {
return JaktInternal::ExplicitValue(((*this).lex_exclamation_point()));
}
else if (__jakt_enum_value == '&') {
return JaktInternal::ExplicitValue(((*this).lex_ampersand()));
}
else if (__jakt_enum_value == '$') {
return JaktInternal::ExplicitValue(typename lexer::Token::Dollar(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(((*this).lex_equals()));
}
else if (__jakt_enum_value == '\n') {
return JaktInternal::ExplicitValue(typename lexer::Token::Eol(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '\'') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_quoted_string('\'')))));
}
else if (__jakt_enum_value == '\"') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_quoted_string('"')))));
}
else if (__jakt_enum_value == 'b') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_character_constant_or_name()))));
}
else if (__jakt_enum_value == 'c') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_character_constant_or_name()))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).lex_number_or_name()))));
}
}()))
);
}
}

bool lexer::Lexer::is_whitespace(const u8 ch) const {
{
return ((((((ch == ' ') || (ch == '\t')) || (ch == '\r')) || (ch == '\f')) || (ch == '\v')));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_character_constant_or_name() {
{
if ((((*this).peek_ahead(static_cast<size_t>(1ULL))) != '\'')){
return (TRY((((*this).lex_number_or_name()))));
}
const bool is_byte = (((*this).peek()) == 'b');
if (is_byte){
(((*this).index)++);
}
const size_t start = ((*this).index);
(((*this).index)++);
bool escaped = false;
while (((!((*this).eof())) && (escaped || (((*this).peek()) != '\'')))){
if ((escaped && ((JaktInternal::checked_sub<size_t>(((*this).index),start)) > static_cast<size_t>(3ULL)))){
break;
}
else if (((JaktInternal::checked_sub<size_t>(((*this).index),start)) > static_cast<size_t>(2ULL))){
break;
}
if (((!escaped) && (((*this).peek()) == '\\'))){
(escaped = true);
}
(((*this).index)++);
}
if ((((*this).eof()) || (((*this).peek()) != '\''))){
TRY((((*this).error(String("Expected single quote"),((*this).span(start,start))))));
}
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append(((((*this).input))[(JaktInternal::checked_add<size_t>(start,static_cast<size_t>(1ULL)))])))));
if (escaped){
TRY((((builder).append(((((*this).input))[(JaktInternal::checked_add<size_t>(start,static_cast<size_t>(2ULL)))])))));
}
const String quote = TRY((((builder).to_string())));
const size_t end = ((*this).index);
if (is_byte){
return (typename lexer::Token::SingleQuotedByteString(quote,((*this).span(start,end))));
}
return (typename lexer::Token::SingleQuotedString(quote,((*this).span(start,end))));
}
}

lexer::Token lexer::Lexer::lex_dot() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '.') {
return JaktInternal::ExplicitValue(typename lexer::Token::DotDot(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Dot(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::make_integer_token(const u64 number,const lexer::LiteralSuffix suffix,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::None>();
{
const Optional<i64> n = (fallible_integer_cast<i64>(number));
if (((n).has_value())){
return (typename lexer::Token::Number(typename lexer::NumericConstant::I64((n.value())),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U8>();
{
const Optional<u8> n = (fallible_integer_cast<u8>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U8((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U16>();
{
const Optional<u16> n = (fallible_integer_cast<u16>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U16((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U32>();
{
const Optional<u32> n = (fallible_integer_cast<u32>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U32((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U64>();
{
const Optional<u64> n = (fallible_integer_cast<u64>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::UZ>();
{
const Optional<size_t> n = (fallible_integer_cast<size_t>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::USize((infallible_integer_cast<u64>((n.value())))),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I8>();
{
const Optional<i8> n = (fallible_integer_cast<i8>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I8((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I16>();
{
const Optional<i16> n = (fallible_integer_cast<i16>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I16((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I32>();
{
const Optional<i32> n = (fallible_integer_cast<i32>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I32((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I64>();
{
const Optional<i64> n = (fallible_integer_cast<i64>(number));
if ((!((n).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I64((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (typename lexer::Token::Garbage(span));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_forward_slash() {
{
const size_t start = (((*this).index)++);
if ((((*this).peek()) == '=')){
return (typename lexer::Token::ForwardSlashEqual(((*this).span(start,(++((*this).index))))));
}
if ((((*this).peek()) != '/')){
return (typename lexer::Token::ForwardSlash(((*this).span(start,((*this).index)))));
}
while ((!((*this).eof()))){
const u8 c = ((*this).peek());
(((*this).index)++);
if ((c == '\n')){
break;
}
}
return (TRY((((*this).next()))).value_or_lazy_evaluated([&] { return typename lexer::Token::Eof(((*this).span(((*this).index),((*this).index)))); }));
}
}

lexer::Token lexer::Lexer::lex_question_mark() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '?') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_0; {
(((*this).index)++);
__jakt_var_0 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMarkQuestionMarkEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMarkQuestionMark(((*this).span(start,((*this).index)))));
}
}()))
; goto __jakt_label_0;

}
__jakt_label_0:; __jakt_var_0.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMark(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

u8 lexer::Lexer::peek_behind(const size_t steps) const {
{
if ((((*this).index) < steps)){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[(JaktInternal::checked_sub<size_t>(((*this).index),steps))]));
}
}

u8 lexer::Lexer::peek_ahead(const size_t steps) const {
{
if (((JaktInternal::checked_add<size_t>(((*this).index),steps)) >= ((((*this).input)).size()))){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[(JaktInternal::checked_add<size_t>(((*this).index),steps))]));
}
}

lexer::Token lexer::Lexer::lex_asterisk() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::AsteriskEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Asterisk(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

u8 lexer::Lexer::peek() const {
{
if (((*this).eof())){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[((*this).index)]));
}
}

lexer::Token lexer::Lexer::lex_percent_sign() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PercentSignEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::PercentSign(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_number_or_name() {
{
const size_t start = ((*this).index);
if (((*this).eof())){
TRY((((*this).error(String("unexpected eof"),((*this).span(start,start))))));
return (typename lexer::Token::Garbage(((*this).span(start,start))));
}
if (lexer::is_ascii_digit(((*this).peek()))){
return (TRY((((*this).lex_number()))));
}
else if ((lexer::is_ascii_alpha(((*this).peek())) || (((*this).peek()) == '_'))){
StringBuilder string_builder = TRY((StringBuilder::create()));
while ((lexer::is_ascii_alphanumeric(((*this).peek())) || (((*this).peek()) == '_'))){
const u8 value = ((((*this).input))[((*this).index)]);
(++((*this).index));
TRY((((string_builder).append(value))));
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
const String string = TRY((((string_builder).to_string())));
return (lexer::Token::from_keyword_or_identifier(string,span));
}
const u8 unknown_char = ((((*this).input))[((*this).index)]);
const size_t end = (++((*this).index));
TRY((((*this).error(TRY((String::formatted(String("unknown character: {:c}"),unknown_char))),((*this).span(start,end))))));
return (typename lexer::Token::Garbage(((*this).span(start,end))));
}
}

lexer::Token lexer::Lexer::lex_minus() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::MinusEqual(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '-') {
return JaktInternal::ExplicitValue(typename lexer::Token::MinusMinus(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::Arrow(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Minus(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

bool lexer::Lexer::eof() const {
{
return ((((*this).index) >= ((((*this).input)).size())));
}
}

lexer::Token lexer::Lexer::lex_ampersand() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::AmpersandEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Ampersand(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

utility::Span lexer::Lexer::span(const size_t start,const size_t end) const {
{
return (utility::Span((((((*this).compiler))->current_file).value()),start,end));
}
}

lexer::Token lexer::Lexer::lex_plus() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PlusEqual(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '+') {
return JaktInternal::ExplicitValue(typename lexer::Token::PlusPlus(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Plus(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_exclamation_point() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::NotEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::ExclamationPoint(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

Optional<lexer::LiteralSuffix> lexer::Lexer::consume_numeric_literal_suffix() {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == 'u') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'i') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'f') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
return (JaktInternal::OptionalNone());
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
if (((((*this).peek()) == 'u') && (((*this).peek_ahead(static_cast<size_t>(1ULL))) == 'z'))){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
return (typename lexer::LiteralSuffix::UZ());
}
size_t local_index = static_cast<size_t>(1ULL);
i64 width = static_cast<i64>(0LL);
while (lexer::is_ascii_digit(((*this).peek_ahead(local_index)))){
if ((local_index > static_cast<size_t>(3ULL))){
return (JaktInternal::OptionalNone());
}
const u8 value = ((((*this).input))[(JaktInternal::checked_add<size_t>(((*this).index),local_index))]);
(++local_index);
const i64 digit = as_saturated<i64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(width = (JaktInternal::checked_add<i64>((JaktInternal::checked_mul<i64>(width,static_cast<i64>(10LL))),digit)));
}
const lexer::LiteralSuffix suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == 'u') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U8());
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U16());
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else if (__jakt_enum_value == 'i') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I8());
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I16());
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else if (__jakt_enum_value == 'f') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
;
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, local_index);});
return (suffix);
}
}

lexer::Token lexer::Lexer::lex_colon() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == ':') {
return JaktInternal::ExplicitValue(typename lexer::Token::ColonColon(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Colon(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<void> lexer::Lexer::error(const String message,const utility::Span span) {
{
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
return {};
}

ErrorOr<String> lexer::Lexer::substring(const size_t start,const size_t length) const {
{
StringBuilder builder = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(start),static_cast<size_t>(length)});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((builder).append(((((*this).input))[i])))));
}

}
}

return (TRY((((builder).to_string()))));
}
}

lexer::Token lexer::Lexer::lex_greater_than() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::GreaterThanOrEqual(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_1; {
(((*this).index)++);
__jakt_var_1 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::RightArithmeticShift(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::RightShiftEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::RightShift(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
; goto __jakt_label_1;

}
__jakt_label_1:; __jakt_var_1.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::GreaterThan(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_pipe() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PipeEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Pipe(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_caret() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::CaretEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Caret(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_number() {
{
const size_t start = ((*this).index);
u64 total = static_cast<u64>(0ULL);
if ((((*this).peek()) == '0')){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<lexer::Token>>{
auto __jakt_enum_value = (((*this).peek_ahead(static_cast<size_t>(1ULL))));
if (__jakt_enum_value == 'x') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (lexer::is_ascii_hexdigit(((*this).peek()))){
u8 offset = static_cast<u8>(0);
if (((((*this).peek()) >= 'a') && (((*this).peek()) <= 'z'))){
(offset = static_cast<u8>(39));
}
else if (((((*this).peek()) >= 'A') && (((*this).peek()) <= 'Z'))){
(offset = static_cast<u8>(7));
}
const u8 value = (JaktInternal::checked_sub<u8>(((((*this).input))[((*this).index)]),offset));
(++((*this).index));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(16ULL))),digit)));
if ((((*this).peek()) == '_')){
(++((*this).index));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Hexadecimal number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
return (TRY((((*this).make_integer_token(total,suffix,((*this).span(start,end)))))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'o') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (lexer::is_ascii_octdigit(((*this).peek()))){
const u8 value = ((((*this).input))[((*this).index)]);
(++((*this).index));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(8ULL))),digit)));
if ((((*this).peek()) == '_')){
(++((*this).index));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Octal number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse octal number"),span))));
return (typename lexer::Token::Garbage(span));
}
return (TRY((((*this).make_integer_token(total,suffix,span)))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'b') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (((((*this).peek()) == '0') || (((*this).peek()) == '1'))){
const u8 value = ((((*this).input))[((*this).index)]);
(++((*this).index));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(2ULL))),digit)));
if ((((*this).peek()) == '_')){
(++((*this).index));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Binary number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse binary number"),span))));
return (typename lexer::Token::Garbage(span));
}
return (TRY((((*this).make_integer_token(total,suffix,span)))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}
bool number_too_large = false;
bool floating = false;
u64 fraction_nominator = static_cast<u64>(0ULL);
u64 fraction_denominator = static_cast<u64>(1ULL);
while ((!((*this).eof()))){
const u8 value = ((((*this).input))[((*this).index)]);
if ((value == '.')){
if (((!lexer::is_ascii_digit(((*this).peek_ahead(static_cast<size_t>(1ULL))))) || floating)){
break;
}
(floating = true);
(((*this).index)++);
continue;
}
else if ((!lexer::is_ascii_digit(value))){
break;
}
(++((*this).index));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
if ((!floating)){
const u64 old_total = total;
(total = unchecked_add<u64>(unchecked_mul<u64>(total,static_cast<u64>(10ULL)),digit));
if ((total < old_total)){
(number_too_large = true);
}
}
else {
(fraction_nominator = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(fraction_nominator,static_cast<u64>(10ULL))),digit)));
({auto& _jakt_ref = fraction_denominator;_jakt_ref = JaktInternal::checked_mul<u64>(_jakt_ref, static_cast<u64>(10ULL));});
}

if ((((*this).peek()) == '_')){
if (lexer::is_ascii_digit(((*this).peek_ahead(static_cast<size_t>(1ULL))))){
(++((*this).index));
}
else {
break;
}

}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if (number_too_large){
TRY((((*this).error(TRY((String::formatted(String("Integer literal too large")))),span))));
return (typename lexer::Token::Garbage(span));
}
if ((((*this).peek()) == '_')){
TRY((((*this).error(String("Number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix default_suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,ErrorOr<lexer::Token>>{
auto __jakt_enum_value = (floating);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F64());
}
else {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::None());
}
}()))
;
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return default_suffix; });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse number"),span))));
return (typename lexer::Token::Garbage(span));
}
const bool is_float_suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
if ((floating && (!is_float_suffix))){
return (typename lexer::Token::Garbage(((*this).span(start,((*this).index)))));
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_2; {
const f64 number = (lexer::u64_to_float<f64>(total) + (lexer::u64_to_float<f64>(fraction_nominator) / lexer::u64_to_float<f64>(fraction_denominator)));
__jakt_var_2 = TRY((lexer::make_float_token(number,suffix,((*this).span(start,end))))); goto __jakt_label_2;

}
__jakt_label_2:; __jakt_var_2.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_3; {
const f64 number = (lexer::u64_to_float<f64>(total) + (lexer::u64_to_float<f64>(fraction_nominator) / lexer::u64_to_float<f64>(fraction_denominator)));
__jakt_var_3 = TRY((lexer::make_float_token(number,suffix,((*this).span(start,end))))); goto __jakt_label_3;

}
__jakt_label_3:; __jakt_var_3.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).make_integer_token(total,suffix,((*this).span(start,end)))))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

lexer::Token lexer::Lexer::lex_less_than() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::LessThanOrEqual(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_4; {
(((*this).index)++);
__jakt_var_4 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftArithmeticShift(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftShiftEqual(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftShift(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
; goto __jakt_label_4;

}
__jakt_label_4:; __jakt_var_4.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::LessThan(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_equals() {
{
const size_t start = (((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::DoubleEqual(((*this).span(start,(++((*this).index))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::FatArrow(((*this).span(start,(++((*this).index))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Equal(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<Array<lexer::Token>> lexer::Lexer::lex(const NonnullRefPtr<compiler::Compiler> compiler) {
{
lexer::Lexer lexer = lexer::Lexer(static_cast<size_t>(0ULL),((compiler)->current_file_contents),compiler);
Array<lexer::Token> tokens = (TRY((Array<lexer::Token>::create_with({}))));
{
lexer::Lexer _magic = lexer;
for (;;){
Optional<lexer::Token> _magic_value = TRY((((_magic).next())));
if ((!((_magic_value).has_value()))){
break;
}
lexer::Token token = (_magic_value.value());
{
TRY((((tokens).push(token))));
}

}
}

return (tokens);
}
}

size_t lexer::NumericConstant::to_usize() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t, size_t>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I8>();
i8 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I16>();
i16 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I32>();
i32 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I64>();
i64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U8>();
u8 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U16>();
u16 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U32>();
u32 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U64>();
u64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::USize>();
u64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(num)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(static_cast<i64>(0LL))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

lexer::Token lexer::Token::from_keyword_or_identifier(const String string,const utility::Span span) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (string);
if (__jakt_enum_value == String("and")) {
return JaktInternal::ExplicitValue(typename lexer::Token::And(span));
}
else if (__jakt_enum_value == String("anon")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Anon(span));
}
else if (__jakt_enum_value == String("as")) {
return JaktInternal::ExplicitValue(typename lexer::Token::As(span));
}
else if (__jakt_enum_value == String("boxed")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Boxed(span));
}
else if (__jakt_enum_value == String("break")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Break(span));
}
else if (__jakt_enum_value == String("catch")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Catch(span));
}
else if (__jakt_enum_value == String("class")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Class(span));
}
else if (__jakt_enum_value == String("continue")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Continue(span));
}
else if (__jakt_enum_value == String("cpp")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Cpp(span));
}
else if (__jakt_enum_value == String("defer")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Defer(span));
}
else if (__jakt_enum_value == String("else")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Else(span));
}
else if (__jakt_enum_value == String("enum")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Enum(span));
}
else if (__jakt_enum_value == String("extern")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Extern(span));
}
else if (__jakt_enum_value == String("false")) {
return JaktInternal::ExplicitValue(typename lexer::Token::False(span));
}
else if (__jakt_enum_value == String("for")) {
return JaktInternal::ExplicitValue(typename lexer::Token::For(span));
}
else if (__jakt_enum_value == String("function")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Function(span));
}
else if (__jakt_enum_value == String("if")) {
return JaktInternal::ExplicitValue(typename lexer::Token::If(span));
}
else if (__jakt_enum_value == String("import")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Import(span));
}
else if (__jakt_enum_value == String("in")) {
return JaktInternal::ExplicitValue(typename lexer::Token::In(span));
}
else if (__jakt_enum_value == String("is")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Is(span));
}
else if (__jakt_enum_value == String("let")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Let(span));
}
else if (__jakt_enum_value == String("loop")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Loop(span));
}
else if (__jakt_enum_value == String("match")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Match(span));
}
else if (__jakt_enum_value == String("mut")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Mut(span));
}
else if (__jakt_enum_value == String("namespace")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Namespace(span));
}
else if (__jakt_enum_value == String("not")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Not(span));
}
else if (__jakt_enum_value == String("or")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Or(span));
}
else if (__jakt_enum_value == String("private")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Private(span));
}
else if (__jakt_enum_value == String("public")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Public(span));
}
else if (__jakt_enum_value == String("raw")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Raw(span));
}
else if (__jakt_enum_value == String("return")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Return(span));
}
else if (__jakt_enum_value == String("restricted")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Restricted(span));
}
else if (__jakt_enum_value == String("struct")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Struct(span));
}
else if (__jakt_enum_value == String("this")) {
return JaktInternal::ExplicitValue(typename lexer::Token::This(span));
}
else if (__jakt_enum_value == String("throw")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Throw(span));
}
else if (__jakt_enum_value == String("throws")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Throws(span));
}
else if (__jakt_enum_value == String("true")) {
return JaktInternal::ExplicitValue(typename lexer::Token::True(span));
}
else if (__jakt_enum_value == String("try")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Try(span));
}
else if (__jakt_enum_value == String("unsafe")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Unsafe(span));
}
else if (__jakt_enum_value == String("weak")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Weak(span));
}
else if (__jakt_enum_value == String("while")) {
return JaktInternal::ExplicitValue(typename lexer::Token::While(span));
}
else if (__jakt_enum_value == String("yield")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Yield(span));
}
else if (__jakt_enum_value == String("guard")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Guard(span));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Identifier(string,span));
}
}()))
);
}
}

utility::Span lexer::Token::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Colon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 66: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Cpp>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSign>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Plus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 57: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Arrow>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AsteriskEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlashEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSignEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::NotEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DoubleEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThanOrEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThan>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThanOrEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftArithmeticShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShiftEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 34: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 35: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightArithmeticShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 36: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShiftEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 39: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AmpersandEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 40: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Pipe>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 41: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PipeEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 42: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Caret>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 43: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::CaretEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 44: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dollar>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 45: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Tilde>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 46: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlash>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 49: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMark>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 50: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMarkEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 53: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DotDot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 55: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eof>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 56: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::FatArrow>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 58: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::And>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 59: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Anon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 60: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::As>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 62: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 63: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Catch>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 65: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 67: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Defer>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 68: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Else>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 70: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Extern>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 72: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::For>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 75: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Import>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 76: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::In>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 77: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Is>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 78: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Let>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 79: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Loop>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 80: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Match>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Namespace>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 83: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Not>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 84: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Or>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Raw>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 89: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Restricted>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 88: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Return>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 92: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throw>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 93: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throws>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 94: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 95: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Try>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 96: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Unsafe>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 97: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Weak>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 98: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::While>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 99: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Yield>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 100: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Guard>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 101: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace parser {
struct ParsedNamespace {
  public:
Optional<String> name;Optional<utility::Span> name_span;Array<parser::ParsedFunction> functions;Array<parser::ParsedRecord> records;Array<parser::ParsedNamespace> namespaces;Array<parser::ParsedModuleImport> module_imports;Array<parser::ParsedExternImport> extern_imports;Optional<String> import_path_if_extern;ErrorOr<void> add_child_namespace(const parser::ParsedNamespace namespace_);
ParsedNamespace(Optional<String> a_name, Optional<utility::Span> a_name_span, Array<parser::ParsedFunction> a_functions, Array<parser::ParsedRecord> a_records, Array<parser::ParsedNamespace> a_namespaces, Array<parser::ParsedModuleImport> a_module_imports, Array<parser::ParsedExternImport> a_extern_imports, Optional<String> a_import_path_if_extern) :name(a_name), name_span(a_name_span), functions(a_functions), records(a_records), namespaces(a_namespaces), module_imports(a_module_imports), extern_imports(a_extern_imports), import_path_if_extern(a_import_path_if_extern){}

bool is_equivalent_to(const parser::ParsedNamespace other) const;
ErrorOr<void> add_extern_import(const parser::ParsedExternImport import_);
ErrorOr<void> merge_with(const parser::ParsedNamespace namespace_);
ErrorOr<void> add_module_import(const parser::ParsedModuleImport import_);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("records: "));TRY(builder.appendff("{}, ", records));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespaces: "));TRY(builder.appendff("{}, ", namespaces));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_imports: "));TRY(builder.appendff("{}, ", module_imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("extern_imports: "));TRY(builder.appendff("{}, ", extern_imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_path_if_extern: "));TRY(builder.appendff("{}", import_path_if_extern));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace DefinitionLinkage_Details {
struct Internal {};
struct External {};
}
struct DefinitionLinkage : public Variant<DefinitionLinkage_Details::Internal, DefinitionLinkage_Details::External> {
using Variant<DefinitionLinkage_Details::Internal, DefinitionLinkage_Details::External>::Variant;
    using Internal = DefinitionLinkage_Details::Internal;
    using External = DefinitionLinkage_Details::External;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Internal const& that) -> ErrorOr<void> {
TRY(builder.append("DefinitionLinkage::Internal"));return {}; },[&]([[maybe_unused]] External const& that) -> ErrorOr<void> {
TRY(builder.append("DefinitionLinkage::External"));return {}; }));return builder.to_string();}};
namespace FunctionType_Details {
struct Normal {};
struct ImplicitConstructor {};
struct ImplicitEnumConstructor {};
struct ExternalClassConstructor {};
}
struct FunctionType : public Variant<FunctionType_Details::Normal, FunctionType_Details::ImplicitConstructor, FunctionType_Details::ImplicitEnumConstructor, FunctionType_Details::ExternalClassConstructor> {
using Variant<FunctionType_Details::Normal, FunctionType_Details::ImplicitConstructor, FunctionType_Details::ImplicitEnumConstructor, FunctionType_Details::ExternalClassConstructor>::Variant;
    using Normal = FunctionType_Details::Normal;
    using ImplicitConstructor = FunctionType_Details::ImplicitConstructor;
    using ImplicitEnumConstructor = FunctionType_Details::ImplicitEnumConstructor;
    using ExternalClassConstructor = FunctionType_Details::ExternalClassConstructor;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Normal const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionType::Normal"));return {}; },[&]([[maybe_unused]] ImplicitConstructor const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionType::ImplicitConstructor"));return {}; },[&]([[maybe_unused]] ImplicitEnumConstructor const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionType::ImplicitEnumConstructor"));return {}; },[&]([[maybe_unused]] ExternalClassConstructor const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionType::ExternalClassConstructor"));return {}; }));return builder.to_string();}};
namespace Visibility_Details {
struct Public {};
struct Private {};
struct Restricted {
Array<NonnullRefPtr<parser::ParsedType>> whitelist;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Restricted(_MemberT0&& member_0, _MemberT1&& member_1):
whitelist{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct Visibility : public Variant<Visibility_Details::Public, Visibility_Details::Private, Visibility_Details::Restricted> {
using Variant<Visibility_Details::Public, Visibility_Details::Private, Visibility_Details::Restricted>::Variant;
    using Public = Visibility_Details::Public;
    using Private = Visibility_Details::Private;
    using Restricted = Visibility_Details::Restricted;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Public const& that) -> ErrorOr<void> {
TRY(builder.append("Visibility::Public"));return {}; },[&]([[maybe_unused]] Private const& that) -> ErrorOr<void> {
TRY(builder.append("Visibility::Private"));return {}; },[&]([[maybe_unused]] Restricted const& that) -> ErrorOr<void> {
TRY(builder.append("Visibility::Restricted"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("whitelist: "));TRY(builder.appendff("{}", that.whitelist));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}};
struct ParsedBlock {
  public:
Array<NonnullRefPtr<parser::ParsedStatement>> stmts;Optional<utility::Span> find_yield_span() const;
ErrorOr<Optional<utility::Span>> span(const parser::Parser parser) const;
ParsedBlock(Array<NonnullRefPtr<parser::ParsedStatement>> a_stmts) :stmts(a_stmts){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedBlock("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("stmts: "));TRY(builder.appendff("{}", stmts));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace FunctionLinkage_Details {
struct Internal {};
struct External {};
}
struct FunctionLinkage : public Variant<FunctionLinkage_Details::Internal, FunctionLinkage_Details::External> {
using Variant<FunctionLinkage_Details::Internal, FunctionLinkage_Details::External>::Variant;
    using Internal = FunctionLinkage_Details::Internal;
    using External = FunctionLinkage_Details::External;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Internal const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionLinkage::Internal"));return {}; },[&]([[maybe_unused]] External const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionLinkage::External"));return {}; }));return builder.to_string();}};
struct ParsedFunction {
  public:
String name;utility::Span name_span;parser::Visibility visibility;Array<parser::ParsedParameter> params;Array<parser::ParsedGenericParameter> generic_parameters;parser::ParsedBlock block;NonnullRefPtr<parser::ParsedType> return_type;utility::Span return_type_span;bool can_throw;parser::FunctionType type;parser::FunctionLinkage linkage;bool must_instantiate;ParsedFunction(String a_name, utility::Span a_name_span, parser::Visibility a_visibility, Array<parser::ParsedParameter> a_params, Array<parser::ParsedGenericParameter> a_generic_parameters, parser::ParsedBlock a_block, NonnullRefPtr<parser::ParsedType> a_return_type, utility::Span a_return_type_span, bool a_can_throw, parser::FunctionType a_type, parser::FunctionLinkage a_linkage, bool a_must_instantiate) :name(a_name), name_span(a_name_span), visibility(a_visibility), params(a_params), generic_parameters(a_generic_parameters), block(a_block), return_type(a_return_type), return_type_span(a_return_type_span), can_throw(a_can_throw), type(a_type), linkage(a_linkage), must_instantiate(a_must_instantiate){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedFunction("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}, ", visibility));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}, ", params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}, ", block));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}, ", return_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_span: "));TRY(builder.appendff("{}, ", return_type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type: "));TRY(builder.appendff("{}, ", type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("linkage: "));TRY(builder.appendff("{}, ", linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("must_instantiate: "));TRY(builder.appendff("{}", must_instantiate));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace TypeCast_Details {
struct Fallible{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Fallible(Args&&... args): value { forward<Args>(args)... } {}
};
struct Infallible{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Infallible(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct TypeCast : public Variant<TypeCast_Details::Fallible, TypeCast_Details::Infallible> {
using Variant<TypeCast_Details::Fallible, TypeCast_Details::Infallible>::Variant;
    using Fallible = TypeCast_Details::Fallible;
    using Infallible = TypeCast_Details::Infallible;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Fallible const& that) -> ErrorOr<void> {
TRY(builder.append("TypeCast::Fallible"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Infallible const& that) -> ErrorOr<void> {
TRY(builder.append("TypeCast::Infallible"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}NonnullRefPtr<parser::ParsedType> parsed_type() const;
};
namespace ParsedType_Details {
struct Name {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Name(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NamespacedName {
String name;
Array<String> namespaces;
Array<NonnullRefPtr<parser::ParsedType>> params;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
NamespacedName(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
name{ forward<_MemberT0>(member_0)},
namespaces{ forward<_MemberT1>(member_1)},
params{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct GenericType {
String name;
Array<NonnullRefPtr<parser::ParsedType>> generic_parameters;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
GenericType(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
name{ forward<_MemberT0>(member_0)},
generic_parameters{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktArray {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Dictionary {
NonnullRefPtr<parser::ParsedType> key;
NonnullRefPtr<parser::ParsedType> value;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Dictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
key{ forward<_MemberT0>(member_0)},
value{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<parser::ParsedType>> types;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1):
types{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Set {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Set(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Optional {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Optional(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Reference {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Reference(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MutableReference {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
MutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct RawPtr {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
RawPtr(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct WeakPtr {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
WeakPtr(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Function {
Array<parser::ParsedParameter> params;
bool can_throw;
NonnullRefPtr<parser::ParsedType> return_type;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
params{ forward<_MemberT0>(member_0)},
can_throw{ forward<_MemberT1>(member_1)},
return_type{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Empty {};
}
struct ParsedType : public Variant<ParsedType_Details::Name, ParsedType_Details::NamespacedName, ParsedType_Details::GenericType, ParsedType_Details::JaktArray, ParsedType_Details::Dictionary, ParsedType_Details::JaktTuple, ParsedType_Details::Set, ParsedType_Details::Optional, ParsedType_Details::Reference, ParsedType_Details::MutableReference, ParsedType_Details::RawPtr, ParsedType_Details::WeakPtr, ParsedType_Details::Function, ParsedType_Details::Empty>, public RefCounted<ParsedType> {
using Variant<ParsedType_Details::Name, ParsedType_Details::NamespacedName, ParsedType_Details::GenericType, ParsedType_Details::JaktArray, ParsedType_Details::Dictionary, ParsedType_Details::JaktTuple, ParsedType_Details::Set, ParsedType_Details::Optional, ParsedType_Details::Reference, ParsedType_Details::MutableReference, ParsedType_Details::RawPtr, ParsedType_Details::WeakPtr, ParsedType_Details::Function, ParsedType_Details::Empty>::Variant;
    using Name = ParsedType_Details::Name;
    using NamespacedName = ParsedType_Details::NamespacedName;
    using GenericType = ParsedType_Details::GenericType;
    using JaktArray = ParsedType_Details::JaktArray;
    using Dictionary = ParsedType_Details::Dictionary;
    using JaktTuple = ParsedType_Details::JaktTuple;
    using Set = ParsedType_Details::Set;
    using Optional = ParsedType_Details::Optional;
    using Reference = ParsedType_Details::Reference;
    using MutableReference = ParsedType_Details::MutableReference;
    using RawPtr = ParsedType_Details::RawPtr;
    using WeakPtr = ParsedType_Details::WeakPtr;
    using Function = ParsedType_Details::Function;
    using Empty = ParsedType_Details::Empty;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedType(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Name const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Name"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NamespacedName const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::NamespacedName"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespaces: "));TRY(builder.appendff("{}", that.namespaces));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", that.params));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GenericType const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::GenericType"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}", that.generic_parameters));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktArray const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::JaktArray"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Dictionary const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Dictionary"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("key: "));TRY(builder.appendff("{}", that.key));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("value: "));TRY(builder.appendff("{}", that.value));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktTuple const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::JaktTuple"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("types: "));TRY(builder.appendff("{}", that.types));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Set const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Set"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Optional const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Optional"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Reference const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Reference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::MutableReference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RawPtr const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::RawPtr"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] WeakPtr const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::WeakPtr"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Function const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Function"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", that.params));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}", that.can_throw));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}", that.return_type));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Empty const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedType::Empty"));return {}; }));return builder.to_string();}utility::Span span() const;
};
namespace RecordType_Details {
struct Struct {
Array<parser::ParsedField> fields;
template<typename _MemberT0>
Struct(_MemberT0&& member_0):
fields{ forward<_MemberT0>(member_0)}
{}
};
struct Class {
Array<parser::ParsedField> fields;
Optional<NonnullRefPtr<parser::ParsedType>> super_class;
template<typename _MemberT0, typename _MemberT1>
Class(_MemberT0&& member_0, _MemberT1&& member_1):
fields{ forward<_MemberT0>(member_0)},
super_class{ forward<_MemberT1>(member_1)}
{}
};
struct ValueEnum {
NonnullRefPtr<parser::ParsedType> underlying_type;
Array<parser::ValueEnumVariant> variants;
template<typename _MemberT0, typename _MemberT1>
ValueEnum(_MemberT0&& member_0, _MemberT1&& member_1):
underlying_type{ forward<_MemberT0>(member_0)},
variants{ forward<_MemberT1>(member_1)}
{}
};
struct SumEnum {
bool is_boxed;
Array<parser::SumEnumVariant> variants;
template<typename _MemberT0, typename _MemberT1>
SumEnum(_MemberT0&& member_0, _MemberT1&& member_1):
is_boxed{ forward<_MemberT0>(member_0)},
variants{ forward<_MemberT1>(member_1)}
{}
};
struct Garbage {};
}
struct RecordType : public Variant<RecordType_Details::Struct, RecordType_Details::Class, RecordType_Details::ValueEnum, RecordType_Details::SumEnum, RecordType_Details::Garbage> {
using Variant<RecordType_Details::Struct, RecordType_Details::Class, RecordType_Details::ValueEnum, RecordType_Details::SumEnum, RecordType_Details::Garbage>::Variant;
    using Struct = RecordType_Details::Struct;
    using Class = RecordType_Details::Class;
    using ValueEnum = RecordType_Details::ValueEnum;
    using SumEnum = RecordType_Details::SumEnum;
    using Garbage = RecordType_Details::Garbage;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Struct const& that) -> ErrorOr<void> {
TRY(builder.append("RecordType::Struct"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fields: "));TRY(builder.appendff("{}", that.fields));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Class const& that) -> ErrorOr<void> {
TRY(builder.append("RecordType::Class"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fields: "));TRY(builder.appendff("{}", that.fields));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("super_class: "));TRY(builder.appendff("{}", that.super_class));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ValueEnum const& that) -> ErrorOr<void> {
TRY(builder.append("RecordType::ValueEnum"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("underlying_type: "));TRY(builder.appendff("{}", that.underlying_type));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variants: "));TRY(builder.appendff("{}", that.variants));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] SumEnum const& that) -> ErrorOr<void> {
TRY(builder.append("RecordType::SumEnum"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_boxed: "));TRY(builder.appendff("{}", that.is_boxed));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variants: "));TRY(builder.appendff("{}", that.variants));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("RecordType::Garbage"));return {}; }));return builder.to_string();}String record_type_name() const;
};
struct ParsedRecord {
  public:
String name;utility::Span name_span;Array<parser::ParsedGenericParameter> generic_parameters;parser::DefinitionLinkage definition_linkage;Array<parser::ParsedMethod> methods;parser::RecordType record_type;ParsedRecord(String a_name, utility::Span a_name_span, Array<parser::ParsedGenericParameter> a_generic_parameters, parser::DefinitionLinkage a_definition_linkage, Array<parser::ParsedMethod> a_methods, parser::RecordType a_record_type) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), definition_linkage(a_definition_linkage), methods(a_methods), record_type(a_record_type){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedRecord("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("methods: "));TRY(builder.appendff("{}, ", methods));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}", record_type));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedCall {
  public:
Array<String> namespace_;String name;Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> args;Array<NonnullRefPtr<parser::ParsedType>> type_args;ParsedCall(Array<String> a_namespace_, String a_name, Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> a_args, Array<NonnullRefPtr<parser::ParsedType>> a_type_args) :namespace_(a_namespace_), name(a_name), args(a_args), type_args(a_type_args){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedCall("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_: "));TRY(builder.appendff("{}, ", namespace_));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_args: "));TRY(builder.appendff("{}", type_args));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace UnaryOperator_Details {
struct PreIncrement {};
struct PostIncrement {};
struct PreDecrement {};
struct PostDecrement {};
struct Negate {};
struct Dereference {};
struct RawAddress {};
struct Reference {};
struct MutableReference {};
struct LogicalNot {};
struct BitwiseNot {};
struct TypeCast{
parser::TypeCast value;
template<typename... Args>
TypeCast(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct IsEnumVariant {
NonnullRefPtr<parser::ParsedType> inner;
Array<parser::EnumVariantPatternArgument> bindings;
template<typename _MemberT0, typename _MemberT1>
IsEnumVariant(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
bindings{ forward<_MemberT1>(member_1)}
{}
};
}
struct UnaryOperator : public Variant<UnaryOperator_Details::PreIncrement, UnaryOperator_Details::PostIncrement, UnaryOperator_Details::PreDecrement, UnaryOperator_Details::PostDecrement, UnaryOperator_Details::Negate, UnaryOperator_Details::Dereference, UnaryOperator_Details::RawAddress, UnaryOperator_Details::Reference, UnaryOperator_Details::MutableReference, UnaryOperator_Details::LogicalNot, UnaryOperator_Details::BitwiseNot, UnaryOperator_Details::TypeCast, UnaryOperator_Details::Is, UnaryOperator_Details::IsEnumVariant> {
using Variant<UnaryOperator_Details::PreIncrement, UnaryOperator_Details::PostIncrement, UnaryOperator_Details::PreDecrement, UnaryOperator_Details::PostDecrement, UnaryOperator_Details::Negate, UnaryOperator_Details::Dereference, UnaryOperator_Details::RawAddress, UnaryOperator_Details::Reference, UnaryOperator_Details::MutableReference, UnaryOperator_Details::LogicalNot, UnaryOperator_Details::BitwiseNot, UnaryOperator_Details::TypeCast, UnaryOperator_Details::Is, UnaryOperator_Details::IsEnumVariant>::Variant;
    using PreIncrement = UnaryOperator_Details::PreIncrement;
    using PostIncrement = UnaryOperator_Details::PostIncrement;
    using PreDecrement = UnaryOperator_Details::PreDecrement;
    using PostDecrement = UnaryOperator_Details::PostDecrement;
    using Negate = UnaryOperator_Details::Negate;
    using Dereference = UnaryOperator_Details::Dereference;
    using RawAddress = UnaryOperator_Details::RawAddress;
    using Reference = UnaryOperator_Details::Reference;
    using MutableReference = UnaryOperator_Details::MutableReference;
    using LogicalNot = UnaryOperator_Details::LogicalNot;
    using BitwiseNot = UnaryOperator_Details::BitwiseNot;
    using TypeCast = UnaryOperator_Details::TypeCast;
    using Is = UnaryOperator_Details::Is;
    using IsEnumVariant = UnaryOperator_Details::IsEnumVariant;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] PreIncrement const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::PreIncrement"));return {}; },[&]([[maybe_unused]] PostIncrement const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::PostIncrement"));return {}; },[&]([[maybe_unused]] PreDecrement const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::PreDecrement"));return {}; },[&]([[maybe_unused]] PostDecrement const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::PostDecrement"));return {}; },[&]([[maybe_unused]] Negate const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::Negate"));return {}; },[&]([[maybe_unused]] Dereference const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::Dereference"));return {}; },[&]([[maybe_unused]] RawAddress const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::RawAddress"));return {}; },[&]([[maybe_unused]] Reference const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::Reference"));return {}; },[&]([[maybe_unused]] MutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::MutableReference"));return {}; },[&]([[maybe_unused]] LogicalNot const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::LogicalNot"));return {}; },[&]([[maybe_unused]] BitwiseNot const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::BitwiseNot"));return {}; },[&]([[maybe_unused]] TypeCast const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::TypeCast"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Is const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::Is"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IsEnumVariant const& that) -> ErrorOr<void> {
TRY(builder.append("UnaryOperator::IsEnumVariant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner: "));TRY(builder.appendff("{}", that.inner));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("bindings: "));TRY(builder.appendff("{}", that.bindings));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}};
namespace BinaryOperator_Details {
struct Add {};
struct Subtract {};
struct Multiply {};
struct Divide {};
struct Modulo {};
struct LessThan {};
struct LessThanOrEqual {};
struct GreaterThan {};
struct GreaterThanOrEqual {};
struct Equal {};
struct NotEqual {};
struct BitwiseAnd {};
struct BitwiseXor {};
struct BitwiseOr {};
struct BitwiseLeftShift {};
struct BitwiseRightShift {};
struct ArithmeticLeftShift {};
struct ArithmeticRightShift {};
struct LogicalAnd {};
struct LogicalOr {};
struct NoneCoalescing {};
struct Assign {};
struct BitwiseAndAssign {};
struct BitwiseOrAssign {};
struct BitwiseXorAssign {};
struct BitwiseLeftShiftAssign {};
struct BitwiseRightShiftAssign {};
struct AddAssign {};
struct SubtractAssign {};
struct MultiplyAssign {};
struct ModuloAssign {};
struct DivideAssign {};
struct NoneCoalescingAssign {};
struct Garbage {};
}
struct BinaryOperator : public Variant<BinaryOperator_Details::Add, BinaryOperator_Details::Subtract, BinaryOperator_Details::Multiply, BinaryOperator_Details::Divide, BinaryOperator_Details::Modulo, BinaryOperator_Details::LessThan, BinaryOperator_Details::LessThanOrEqual, BinaryOperator_Details::GreaterThan, BinaryOperator_Details::GreaterThanOrEqual, BinaryOperator_Details::Equal, BinaryOperator_Details::NotEqual, BinaryOperator_Details::BitwiseAnd, BinaryOperator_Details::BitwiseXor, BinaryOperator_Details::BitwiseOr, BinaryOperator_Details::BitwiseLeftShift, BinaryOperator_Details::BitwiseRightShift, BinaryOperator_Details::ArithmeticLeftShift, BinaryOperator_Details::ArithmeticRightShift, BinaryOperator_Details::LogicalAnd, BinaryOperator_Details::LogicalOr, BinaryOperator_Details::NoneCoalescing, BinaryOperator_Details::Assign, BinaryOperator_Details::BitwiseAndAssign, BinaryOperator_Details::BitwiseOrAssign, BinaryOperator_Details::BitwiseXorAssign, BinaryOperator_Details::BitwiseLeftShiftAssign, BinaryOperator_Details::BitwiseRightShiftAssign, BinaryOperator_Details::AddAssign, BinaryOperator_Details::SubtractAssign, BinaryOperator_Details::MultiplyAssign, BinaryOperator_Details::ModuloAssign, BinaryOperator_Details::DivideAssign, BinaryOperator_Details::NoneCoalescingAssign, BinaryOperator_Details::Garbage> {
using Variant<BinaryOperator_Details::Add, BinaryOperator_Details::Subtract, BinaryOperator_Details::Multiply, BinaryOperator_Details::Divide, BinaryOperator_Details::Modulo, BinaryOperator_Details::LessThan, BinaryOperator_Details::LessThanOrEqual, BinaryOperator_Details::GreaterThan, BinaryOperator_Details::GreaterThanOrEqual, BinaryOperator_Details::Equal, BinaryOperator_Details::NotEqual, BinaryOperator_Details::BitwiseAnd, BinaryOperator_Details::BitwiseXor, BinaryOperator_Details::BitwiseOr, BinaryOperator_Details::BitwiseLeftShift, BinaryOperator_Details::BitwiseRightShift, BinaryOperator_Details::ArithmeticLeftShift, BinaryOperator_Details::ArithmeticRightShift, BinaryOperator_Details::LogicalAnd, BinaryOperator_Details::LogicalOr, BinaryOperator_Details::NoneCoalescing, BinaryOperator_Details::Assign, BinaryOperator_Details::BitwiseAndAssign, BinaryOperator_Details::BitwiseOrAssign, BinaryOperator_Details::BitwiseXorAssign, BinaryOperator_Details::BitwiseLeftShiftAssign, BinaryOperator_Details::BitwiseRightShiftAssign, BinaryOperator_Details::AddAssign, BinaryOperator_Details::SubtractAssign, BinaryOperator_Details::MultiplyAssign, BinaryOperator_Details::ModuloAssign, BinaryOperator_Details::DivideAssign, BinaryOperator_Details::NoneCoalescingAssign, BinaryOperator_Details::Garbage>::Variant;
    using Add = BinaryOperator_Details::Add;
    using Subtract = BinaryOperator_Details::Subtract;
    using Multiply = BinaryOperator_Details::Multiply;
    using Divide = BinaryOperator_Details::Divide;
    using Modulo = BinaryOperator_Details::Modulo;
    using LessThan = BinaryOperator_Details::LessThan;
    using LessThanOrEqual = BinaryOperator_Details::LessThanOrEqual;
    using GreaterThan = BinaryOperator_Details::GreaterThan;
    using GreaterThanOrEqual = BinaryOperator_Details::GreaterThanOrEqual;
    using Equal = BinaryOperator_Details::Equal;
    using NotEqual = BinaryOperator_Details::NotEqual;
    using BitwiseAnd = BinaryOperator_Details::BitwiseAnd;
    using BitwiseXor = BinaryOperator_Details::BitwiseXor;
    using BitwiseOr = BinaryOperator_Details::BitwiseOr;
    using BitwiseLeftShift = BinaryOperator_Details::BitwiseLeftShift;
    using BitwiseRightShift = BinaryOperator_Details::BitwiseRightShift;
    using ArithmeticLeftShift = BinaryOperator_Details::ArithmeticLeftShift;
    using ArithmeticRightShift = BinaryOperator_Details::ArithmeticRightShift;
    using LogicalAnd = BinaryOperator_Details::LogicalAnd;
    using LogicalOr = BinaryOperator_Details::LogicalOr;
    using NoneCoalescing = BinaryOperator_Details::NoneCoalescing;
    using Assign = BinaryOperator_Details::Assign;
    using BitwiseAndAssign = BinaryOperator_Details::BitwiseAndAssign;
    using BitwiseOrAssign = BinaryOperator_Details::BitwiseOrAssign;
    using BitwiseXorAssign = BinaryOperator_Details::BitwiseXorAssign;
    using BitwiseLeftShiftAssign = BinaryOperator_Details::BitwiseLeftShiftAssign;
    using BitwiseRightShiftAssign = BinaryOperator_Details::BitwiseRightShiftAssign;
    using AddAssign = BinaryOperator_Details::AddAssign;
    using SubtractAssign = BinaryOperator_Details::SubtractAssign;
    using MultiplyAssign = BinaryOperator_Details::MultiplyAssign;
    using ModuloAssign = BinaryOperator_Details::ModuloAssign;
    using DivideAssign = BinaryOperator_Details::DivideAssign;
    using NoneCoalescingAssign = BinaryOperator_Details::NoneCoalescingAssign;
    using Garbage = BinaryOperator_Details::Garbage;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Add const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Add"));return {}; },[&]([[maybe_unused]] Subtract const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Subtract"));return {}; },[&]([[maybe_unused]] Multiply const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Multiply"));return {}; },[&]([[maybe_unused]] Divide const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Divide"));return {}; },[&]([[maybe_unused]] Modulo const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Modulo"));return {}; },[&]([[maybe_unused]] LessThan const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::LessThan"));return {}; },[&]([[maybe_unused]] LessThanOrEqual const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::LessThanOrEqual"));return {}; },[&]([[maybe_unused]] GreaterThan const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::GreaterThan"));return {}; },[&]([[maybe_unused]] GreaterThanOrEqual const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::GreaterThanOrEqual"));return {}; },[&]([[maybe_unused]] Equal const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Equal"));return {}; },[&]([[maybe_unused]] NotEqual const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::NotEqual"));return {}; },[&]([[maybe_unused]] BitwiseAnd const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseAnd"));return {}; },[&]([[maybe_unused]] BitwiseXor const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseXor"));return {}; },[&]([[maybe_unused]] BitwiseOr const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseOr"));return {}; },[&]([[maybe_unused]] BitwiseLeftShift const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseLeftShift"));return {}; },[&]([[maybe_unused]] BitwiseRightShift const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseRightShift"));return {}; },[&]([[maybe_unused]] ArithmeticLeftShift const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::ArithmeticLeftShift"));return {}; },[&]([[maybe_unused]] ArithmeticRightShift const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::ArithmeticRightShift"));return {}; },[&]([[maybe_unused]] LogicalAnd const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::LogicalAnd"));return {}; },[&]([[maybe_unused]] LogicalOr const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::LogicalOr"));return {}; },[&]([[maybe_unused]] NoneCoalescing const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::NoneCoalescing"));return {}; },[&]([[maybe_unused]] Assign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Assign"));return {}; },[&]([[maybe_unused]] BitwiseAndAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseAndAssign"));return {}; },[&]([[maybe_unused]] BitwiseOrAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseOrAssign"));return {}; },[&]([[maybe_unused]] BitwiseXorAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseXorAssign"));return {}; },[&]([[maybe_unused]] BitwiseLeftShiftAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseLeftShiftAssign"));return {}; },[&]([[maybe_unused]] BitwiseRightShiftAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::BitwiseRightShiftAssign"));return {}; },[&]([[maybe_unused]] AddAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::AddAssign"));return {}; },[&]([[maybe_unused]] SubtractAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::SubtractAssign"));return {}; },[&]([[maybe_unused]] MultiplyAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::MultiplyAssign"));return {}; },[&]([[maybe_unused]] ModuloAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::ModuloAssign"));return {}; },[&]([[maybe_unused]] DivideAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::DivideAssign"));return {}; },[&]([[maybe_unused]] NoneCoalescingAssign const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::NoneCoalescingAssign"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("BinaryOperator::Garbage"));return {}; }));return builder.to_string();}bool is_assignment() const;
};
struct EnumVariantPatternArgument {
  public:
Optional<String> name;String binding;utility::Span span;EnumVariantPatternArgument(Optional<String> a_name, String a_binding, utility::Span a_span) :name(a_name), binding(a_binding), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("EnumVariantPatternArgument("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("binding: "));TRY(builder.appendff("\"{}\", ", binding));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedExpression_Details {
struct Boolean {
bool val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Boolean(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NumericConstant {
lexer::NumericConstant val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
NumericConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct QuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedByteString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedByteString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Call {
parser::ParsedCall call;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Call(_MemberT0&& member_0, _MemberT1&& member_1):
call{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MethodCall {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::ParsedCall call;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
MethodCall(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
call{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedTuple {
NonnullRefPtr<parser::ParsedExpression> expr;
size_t index;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedStruct {
NonnullRefPtr<parser::ParsedExpression> expr;
String field;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedStruct(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
field{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Var {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Var(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct IndexedExpression {
NonnullRefPtr<parser::ParsedExpression> base;
NonnullRefPtr<parser::ParsedExpression> index;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
IndexedExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
base{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct UnaryOp {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::UnaryOperator op;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
UnaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct BinaryOp {
NonnullRefPtr<parser::ParsedExpression> lhs;
parser::BinaryOperator op;
NonnullRefPtr<parser::ParsedExpression> rhs;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
BinaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
lhs{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
rhs{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Operator {
parser::BinaryOperator op;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Operator(_MemberT0&& member_0, _MemberT1&& member_1):
op{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalSome {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
OptionalSome(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalNone{
utility::Span value;
template<typename... Args>
OptionalNone(Args&&... args): value { forward<Args>(args)... } {}
};
struct JaktArray {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
values{ forward<_MemberT0>(member_0)},
fill_size{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktDictionary {
Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktDictionary(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Set {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Set(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Range {
NonnullRefPtr<parser::ParsedExpression> from;
NonnullRefPtr<parser::ParsedExpression> to;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Range(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
from{ forward<_MemberT0>(member_0)},
to{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct ForcedUnwrap {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ForcedUnwrap(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Match {
NonnullRefPtr<parser::ParsedExpression> expr;
Array<parser::ParsedMatchCase> cases;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Match(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
cases{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct EnumVariantArg {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::EnumVariantPatternArgument arg;
NonnullRefPtr<parser::ParsedType> enum_variant;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
EnumVariantArg(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
arg{ forward<_MemberT1>(member_1)},
enum_variant{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct NamespacedVar {
String name;
Array<String> namespace_;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NamespacedVar(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
name{ forward<_MemberT0>(member_0)},
namespace_{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Function {
Array<parser::ParsedCapture> captures;
Array<parser::ParsedParameter> params;
bool can_throw;
NonnullRefPtr<parser::ParsedType> return_type;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5):
captures{ forward<_MemberT0>(member_0)},
params{ forward<_MemberT1>(member_1)},
can_throw{ forward<_MemberT2>(member_2)},
return_type{ forward<_MemberT3>(member_3)},
block{ forward<_MemberT4>(member_4)},
span{ forward<_MemberT5>(member_5)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedExpression : public Variant<ParsedExpression_Details::Boolean, ParsedExpression_Details::NumericConstant, ParsedExpression_Details::QuotedString, ParsedExpression_Details::SingleQuotedString, ParsedExpression_Details::SingleQuotedByteString, ParsedExpression_Details::Call, ParsedExpression_Details::MethodCall, ParsedExpression_Details::IndexedTuple, ParsedExpression_Details::IndexedStruct, ParsedExpression_Details::Var, ParsedExpression_Details::IndexedExpression, ParsedExpression_Details::UnaryOp, ParsedExpression_Details::BinaryOp, ParsedExpression_Details::Operator, ParsedExpression_Details::OptionalSome, ParsedExpression_Details::OptionalNone, ParsedExpression_Details::JaktArray, ParsedExpression_Details::JaktDictionary, ParsedExpression_Details::Set, ParsedExpression_Details::JaktTuple, ParsedExpression_Details::Range, ParsedExpression_Details::ForcedUnwrap, ParsedExpression_Details::Match, ParsedExpression_Details::EnumVariantArg, ParsedExpression_Details::NamespacedVar, ParsedExpression_Details::Function, ParsedExpression_Details::Garbage>, public RefCounted<ParsedExpression> {
using Variant<ParsedExpression_Details::Boolean, ParsedExpression_Details::NumericConstant, ParsedExpression_Details::QuotedString, ParsedExpression_Details::SingleQuotedString, ParsedExpression_Details::SingleQuotedByteString, ParsedExpression_Details::Call, ParsedExpression_Details::MethodCall, ParsedExpression_Details::IndexedTuple, ParsedExpression_Details::IndexedStruct, ParsedExpression_Details::Var, ParsedExpression_Details::IndexedExpression, ParsedExpression_Details::UnaryOp, ParsedExpression_Details::BinaryOp, ParsedExpression_Details::Operator, ParsedExpression_Details::OptionalSome, ParsedExpression_Details::OptionalNone, ParsedExpression_Details::JaktArray, ParsedExpression_Details::JaktDictionary, ParsedExpression_Details::Set, ParsedExpression_Details::JaktTuple, ParsedExpression_Details::Range, ParsedExpression_Details::ForcedUnwrap, ParsedExpression_Details::Match, ParsedExpression_Details::EnumVariantArg, ParsedExpression_Details::NamespacedVar, ParsedExpression_Details::Function, ParsedExpression_Details::Garbage>::Variant;
    using Boolean = ParsedExpression_Details::Boolean;
    using NumericConstant = ParsedExpression_Details::NumericConstant;
    using QuotedString = ParsedExpression_Details::QuotedString;
    using SingleQuotedString = ParsedExpression_Details::SingleQuotedString;
    using SingleQuotedByteString = ParsedExpression_Details::SingleQuotedByteString;
    using Call = ParsedExpression_Details::Call;
    using MethodCall = ParsedExpression_Details::MethodCall;
    using IndexedTuple = ParsedExpression_Details::IndexedTuple;
    using IndexedStruct = ParsedExpression_Details::IndexedStruct;
    using Var = ParsedExpression_Details::Var;
    using IndexedExpression = ParsedExpression_Details::IndexedExpression;
    using UnaryOp = ParsedExpression_Details::UnaryOp;
    using BinaryOp = ParsedExpression_Details::BinaryOp;
    using Operator = ParsedExpression_Details::Operator;
    using OptionalSome = ParsedExpression_Details::OptionalSome;
    using OptionalNone = ParsedExpression_Details::OptionalNone;
    using JaktArray = ParsedExpression_Details::JaktArray;
    using JaktDictionary = ParsedExpression_Details::JaktDictionary;
    using Set = ParsedExpression_Details::Set;
    using JaktTuple = ParsedExpression_Details::JaktTuple;
    using Range = ParsedExpression_Details::Range;
    using ForcedUnwrap = ParsedExpression_Details::ForcedUnwrap;
    using Match = ParsedExpression_Details::Match;
    using EnumVariantArg = ParsedExpression_Details::EnumVariantArg;
    using NamespacedVar = ParsedExpression_Details::NamespacedVar;
    using Function = ParsedExpression_Details::Function;
    using Garbage = ParsedExpression_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedExpression(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Boolean const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Boolean"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.appendff("{}", that.val));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NumericConstant const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::NumericConstant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.appendff("{}", that.val));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuotedString const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::QuotedString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] SingleQuotedString const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::SingleQuotedString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] SingleQuotedByteString const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::SingleQuotedByteString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Call const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Call"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("call: "));TRY(builder.appendff("{}", that.call));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MethodCall const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::MethodCall"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("call: "));TRY(builder.appendff("{}", that.call));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedTuple const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::IndexedTuple"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedStruct const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::IndexedStruct"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("field: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.field));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Var const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Var"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedExpression const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::IndexedExpression"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("base: "));TRY(builder.appendff("{}", that.base));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] UnaryOp const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::UnaryOp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("op: "));TRY(builder.appendff("{}", that.op));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] BinaryOp const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::BinaryOp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("lhs: "));TRY(builder.appendff("{}", that.lhs));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("op: "));TRY(builder.appendff("{}", that.op));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("rhs: "));TRY(builder.appendff("{}", that.rhs));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Operator const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Operator"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("op: "));TRY(builder.appendff("{}", that.op));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] OptionalSome const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::OptionalSome"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] OptionalNone const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::OptionalNone"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktArray const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::JaktArray"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("values: "));TRY(builder.appendff("{}", that.values));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fill_size: "));TRY(builder.appendff("{}", that.fill_size));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktDictionary const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::JaktDictionary"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("values: "));TRY(builder.appendff("{}", that.values));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Set const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Set"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("values: "));TRY(builder.appendff("{}", that.values));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktTuple const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::JaktTuple"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("values: "));TRY(builder.appendff("{}", that.values));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Range const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Range"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("from: "));TRY(builder.appendff("{}", that.from));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("to: "));TRY(builder.appendff("{}", that.to));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ForcedUnwrap const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::ForcedUnwrap"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Match const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Match"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("cases: "));TRY(builder.appendff("{}", that.cases));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] EnumVariantArg const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::EnumVariantArg"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("arg: "));TRY(builder.appendff("{}", that.arg));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_variant: "));TRY(builder.appendff("{}", that.enum_variant));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NamespacedVar const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::NamespacedVar"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_: "));TRY(builder.appendff("{}", that.namespace_));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Function const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Function"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("captures: "));TRY(builder.appendff("{}", that.captures));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", that.params));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}", that.can_throw));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}", that.return_type));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedExpression::Garbage"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}utility::Span span() const;
i64 precedence() const;
};
struct ParsedVarDecl {
  public:
String name;NonnullRefPtr<parser::ParsedType> parsed_type;bool is_mutable;Optional<utility::Span> inlay_span;utility::Span span;ParsedVarDecl(String a_name, NonnullRefPtr<parser::ParsedType> a_parsed_type, bool a_is_mutable, Optional<utility::Span> a_inlay_span, utility::Span a_span) :name(a_name), parsed_type(a_parsed_type), is_mutable(a_is_mutable), inlay_span(a_inlay_span), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedVarDecl("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_type: "));TRY(builder.appendff("{}, ", parsed_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inlay_span: "));TRY(builder.appendff("{}, ", inlay_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedStatement_Details {
struct Expression {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Expression(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Defer {
NonnullRefPtr<parser::ParsedStatement> statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Defer(_MemberT0&& member_0, _MemberT1&& member_1):
statement{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct UnsafeBlock {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
UnsafeBlock(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct DestructuringAssignment {
Array<parser::ParsedVarDecl> vars;
NonnullRefPtr<parser::ParsedStatement> var_decl;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
DestructuringAssignment(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vars{ forward<_MemberT0>(member_0)},
var_decl{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct VarDecl {
parser::ParsedVarDecl var;
NonnullRefPtr<parser::ParsedExpression> init;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
VarDecl(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
var{ forward<_MemberT0>(member_0)},
init{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct If {
NonnullRefPtr<parser::ParsedExpression> condition;
parser::ParsedBlock then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
If(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
condition{ forward<_MemberT0>(member_0)},
then_block{ forward<_MemberT1>(member_1)},
else_statement{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Block {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Block(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Loop {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Loop(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct While {
NonnullRefPtr<parser::ParsedExpression> condition;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
While(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
condition{ forward<_MemberT0>(member_0)},
block{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct For {
String iterator_name;
utility::Span name_span;
NonnullRefPtr<parser::ParsedExpression> range;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
For(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
iterator_name{ forward<_MemberT0>(member_0)},
name_span{ forward<_MemberT1>(member_1)},
range{ forward<_MemberT2>(member_2)},
block{ forward<_MemberT3>(member_3)},
span{ forward<_MemberT4>(member_4)}
{}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Return {
Optional<NonnullRefPtr<parser::ParsedExpression>> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Return(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Throw {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Throw(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Yield {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Yield(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct InlineCpp {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
InlineCpp(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Try {
NonnullRefPtr<parser::ParsedStatement> stmt;
String error_name;
utility::Span error_span;
parser::ParsedBlock catch_block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
Try(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
stmt{ forward<_MemberT0>(member_0)},
error_name{ forward<_MemberT1>(member_1)},
error_span{ forward<_MemberT2>(member_2)},
catch_block{ forward<_MemberT3>(member_3)},
span{ forward<_MemberT4>(member_4)}
{}
};
struct Guard {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::ParsedBlock else_block;
parser::ParsedBlock remaining_code;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Guard(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
else_block{ forward<_MemberT1>(member_1)},
remaining_code{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedStatement : public Variant<ParsedStatement_Details::Expression, ParsedStatement_Details::Defer, ParsedStatement_Details::UnsafeBlock, ParsedStatement_Details::DestructuringAssignment, ParsedStatement_Details::VarDecl, ParsedStatement_Details::If, ParsedStatement_Details::Block, ParsedStatement_Details::Loop, ParsedStatement_Details::While, ParsedStatement_Details::For, ParsedStatement_Details::Break, ParsedStatement_Details::Continue, ParsedStatement_Details::Return, ParsedStatement_Details::Throw, ParsedStatement_Details::Yield, ParsedStatement_Details::InlineCpp, ParsedStatement_Details::Try, ParsedStatement_Details::Guard, ParsedStatement_Details::Garbage>, public RefCounted<ParsedStatement> {
using Variant<ParsedStatement_Details::Expression, ParsedStatement_Details::Defer, ParsedStatement_Details::UnsafeBlock, ParsedStatement_Details::DestructuringAssignment, ParsedStatement_Details::VarDecl, ParsedStatement_Details::If, ParsedStatement_Details::Block, ParsedStatement_Details::Loop, ParsedStatement_Details::While, ParsedStatement_Details::For, ParsedStatement_Details::Break, ParsedStatement_Details::Continue, ParsedStatement_Details::Return, ParsedStatement_Details::Throw, ParsedStatement_Details::Yield, ParsedStatement_Details::InlineCpp, ParsedStatement_Details::Try, ParsedStatement_Details::Guard, ParsedStatement_Details::Garbage>::Variant;
    using Expression = ParsedStatement_Details::Expression;
    using Defer = ParsedStatement_Details::Defer;
    using UnsafeBlock = ParsedStatement_Details::UnsafeBlock;
    using DestructuringAssignment = ParsedStatement_Details::DestructuringAssignment;
    using VarDecl = ParsedStatement_Details::VarDecl;
    using If = ParsedStatement_Details::If;
    using Block = ParsedStatement_Details::Block;
    using Loop = ParsedStatement_Details::Loop;
    using While = ParsedStatement_Details::While;
    using For = ParsedStatement_Details::For;
    using Break = ParsedStatement_Details::Break;
    using Continue = ParsedStatement_Details::Continue;
    using Return = ParsedStatement_Details::Return;
    using Throw = ParsedStatement_Details::Throw;
    using Yield = ParsedStatement_Details::Yield;
    using InlineCpp = ParsedStatement_Details::InlineCpp;
    using Try = ParsedStatement_Details::Try;
    using Guard = ParsedStatement_Details::Guard;
    using Garbage = ParsedStatement_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedStatement(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Expression"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Defer const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Defer"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statement: "));TRY(builder.appendff("{}", that.statement));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] UnsafeBlock const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::UnsafeBlock"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] DestructuringAssignment const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::DestructuringAssignment"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vars: "));TRY(builder.appendff("{}", that.vars));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_decl: "));TRY(builder.appendff("{}", that.var_decl));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] VarDecl const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::VarDecl"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var: "));TRY(builder.appendff("{}", that.var));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("init: "));TRY(builder.appendff("{}", that.init));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] If const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::If"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("condition: "));TRY(builder.appendff("{}", that.condition));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("then_block: "));TRY(builder.appendff("{}", that.then_block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("else_statement: "));TRY(builder.appendff("{}", that.else_statement));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Block const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Block"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Loop const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Loop"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] While const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::While"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("condition: "));TRY(builder.appendff("{}", that.condition));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] For const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::For"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("iterator_name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.iterator_name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}", that.name_span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("range: "));TRY(builder.appendff("{}", that.range));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Break const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Break"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Continue const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Continue"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Return const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Return"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Throw const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Throw"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Yield const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Yield"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] InlineCpp const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::InlineCpp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Try const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Try"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("stmt: "));TRY(builder.appendff("{}", that.stmt));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("error_name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.error_name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("error_span: "));TRY(builder.appendff("{}", that.error_span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("catch_block: "));TRY(builder.appendff("{}", that.catch_block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Guard const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Guard"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("else_block: "));TRY(builder.appendff("{}", that.else_block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("remaining_code: "));TRY(builder.appendff("{}", that.remaining_code));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedStatement::Garbage"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}utility::Span span() const;
};
namespace ParsedMatchBody_Details {
struct Expression{
NonnullRefPtr<parser::ParsedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct Block{
parser::ParsedBlock value;
template<typename... Args>
Block(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedMatchBody : public Variant<ParsedMatchBody_Details::Expression, ParsedMatchBody_Details::Block> {
using Variant<ParsedMatchBody_Details::Expression, ParsedMatchBody_Details::Block>::Variant;
    using Expression = ParsedMatchBody_Details::Expression;
    using Block = ParsedMatchBody_Details::Block;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedMatchBody::Expression"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Block const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedMatchBody::Block"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}};
namespace ParsedMatchPattern_Details {
struct EnumVariant {
Array<Tuple<String,utility::Span>> variant_name;
Array<parser::EnumVariantPatternArgument> variant_arguments;
utility::Span arguments_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
variant_name{ forward<_MemberT0>(member_0)},
variant_arguments{ forward<_MemberT1>(member_1)},
arguments_span{ forward<_MemberT2>(member_2)}
{}
};
struct Expression{
NonnullRefPtr<parser::ParsedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct CatchAll {};
}
struct ParsedMatchPattern : public Variant<ParsedMatchPattern_Details::EnumVariant, ParsedMatchPattern_Details::Expression, ParsedMatchPattern_Details::CatchAll> {
using Variant<ParsedMatchPattern_Details::EnumVariant, ParsedMatchPattern_Details::Expression, ParsedMatchPattern_Details::CatchAll>::Variant;
    using EnumVariant = ParsedMatchPattern_Details::EnumVariant;
    using Expression = ParsedMatchPattern_Details::Expression;
    using CatchAll = ParsedMatchPattern_Details::CatchAll;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] EnumVariant const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedMatchPattern::EnumVariant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variant_name: "));TRY(builder.appendff("{}", that.variant_name));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variant_arguments: "));TRY(builder.appendff("{}", that.variant_arguments));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("arguments_span: "));TRY(builder.appendff("{}", that.arguments_span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedMatchPattern::Expression"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] CatchAll const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedMatchPattern::CatchAll"));return {}; }));return builder.to_string();}};
struct Parser {
  public:
size_t index;Array<lexer::Token> tokens;NonnullRefPtr<compiler::Compiler> compiler;ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>> parse_value_enum_body(const parser::ParsedRecord partial_enum, const parser::DefinitionLinkage definition_linkage);
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_try_statement();
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_statement(const bool inside_block);
ErrorOr<String> parse_argument_label();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_array_or_dictionary();
ErrorOr<parser::ParsedBlock> parse_fat_arrow();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_typename();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_match_expression();
ErrorOr<void> error_with_hint(const String message, const utility::Span span, const String hint, const utility::Span hint_span);
ErrorOr<parser::ParsedField> parse_field(const parser::Visibility visibility);
ErrorOr<parser::ParsedRecord> parse_class(const parser::DefinitionLinkage definition_linkage);
bool eof() const;
ErrorOr<parser::ParsedRecord> parse_enum(const parser::DefinitionLinkage definition_linkage, const bool is_boxed);
utility::Span span(const size_t start, const size_t end) const;
ErrorOr<Array<parser::ParsedVarDecl>> parse_destructuring_assignment(const bool is_mutable);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand_base();
ErrorOr<parser::ParsedFunction> parse_function(const parser::FunctionLinkage linkage, const parser::Visibility visibility);
static ErrorOr<parser::ParsedNamespace> parse(const NonnullRefPtr<compiler::Compiler> compiler, const Array<lexer::Token> tokens);
ErrorOr<parser::ParsedMethod> parse_method(const parser::FunctionLinkage linkage, const parser::Visibility visibility);
ErrorOr<parser::ParsedModuleImport> parse_module_import();
ErrorOr<parser::ParsedBlock> parse_block();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_longhand();
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_if_statement();
ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operator(const bool allow_assignments);
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_for_statement();
ErrorOr<Array<parser::ParsedParameter>> parse_function_parameters();
ErrorOr<Optional<parser::ParsedCall>> parse_call();
ErrorOr<parser::ParsedRecord> parse_struct(const parser::DefinitionLinkage definition_linkage);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_array_or_dictionary_literal();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand();
void skip_newlines();
bool eol() const;
ErrorOr<parser::ParsedMatchPattern> parse_match_pattern();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_lambda();
ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>> parse_struct_class_body(const parser::DefinitionLinkage definition_linkage, const parser::Visibility default_visibility, const bool is_class);
ErrorOr<parser::ParsedExternImport> parse_extern_import();
ErrorOr<Array<parser::EnumVariantPatternArgument>> parse_variant_arguments();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_set_literal();
ErrorOr<parser::ParsedNamespace> parse_namespace();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_ampersand();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_asterisk();
ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>> parse_sum_enum_body(const parser::ParsedRecord partial_enum, const parser::DefinitionLinkage definition_linkage, const bool is_boxed);
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_tuple();
ErrorOr<Array<parser::ParsedCapture>> parse_captures();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_postfix_colon_colon(const utility::Span start, const NonnullRefPtr<parser::ParsedExpression> expr);
Parser(size_t a_index, Array<lexer::Token> a_tokens, NonnullRefPtr<compiler::Compiler> a_compiler) :index(a_index), tokens(a_tokens), compiler(a_compiler){}

ErrorOr<void> parse_import(parser::ParsedNamespace parent);
ErrorOr<Array<parser::ParsedMatchCase>> parse_match_cases();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_set();
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_guard_statement();
ErrorOr<parser::ParsedVarDecl> parse_variable_declaration(const bool is_mutable);
lexer::Token current() const;
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_expression(const bool allow_assignments, const bool allow_newlines);
ErrorOr<parser::Visibility> parse_restricted_visibility_modifier();
lexer::Token peek(const size_t steps) const;
ErrorOr<parser::ParsedRecord> parse_record(const parser::DefinitionLinkage definition_linkage);
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand();
utility::Span empty_span() const;
ErrorOr<Array<parser::ParsedMatchPattern>> parse_match_patterns();
lexer::Token previous() const;
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand_postfix_operator(const utility::Span start, const NonnullRefPtr<parser::ParsedExpression> expr);
ErrorOr<Array<parser::ParsedGenericParameter>> parse_generic_parameters();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Parser("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}, ", index));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("tokens: "));TRY(builder.appendff("{}, ", tokens));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}", *compiler));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ImportName {
  public:
String name;utility::Span span;ImportName(String a_name, utility::Span a_span) :name(a_name), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ImportName("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedModuleImport {
  public:
parser::ImportName module_name;Optional<parser::ImportName> alias_name;Array<parser::ImportName> import_list;ParsedModuleImport(parser::ImportName a_module_name, Optional<parser::ImportName> a_alias_name, Array<parser::ImportName> a_import_list) :module_name(a_module_name), alias_name(a_alias_name), import_list(a_import_list){}

bool is_equivalent_to(const parser::ParsedModuleImport other) const;
bool has_same_alias_than(const parser::ParsedModuleImport other) const;
bool has_same_import_semantics(const parser::ParsedModuleImport other) const;
ErrorOr<void> merge_import_list(const Array<parser::ImportName> list);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedModuleImport("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_name: "));TRY(builder.appendff("{}, ", module_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("alias_name: "));TRY(builder.appendff("{}, ", alias_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_list: "));TRY(builder.appendff("{}", import_list));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedField {
  public:
parser::ParsedVarDecl var_decl;parser::Visibility visibility;ParsedField(parser::ParsedVarDecl a_var_decl, parser::Visibility a_visibility) :var_decl(a_var_decl), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedField("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_decl: "));TRY(builder.appendff("{}, ", var_decl));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedMethod {
  public:
parser::ParsedFunction parsed_function;parser::Visibility visibility;ParsedMethod(parser::ParsedFunction a_parsed_function, parser::Visibility a_visibility) :parsed_function(a_parsed_function), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedMethod("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_function: "));TRY(builder.appendff("{}, ", parsed_function));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedMatchCase {
  public:
Array<parser::ParsedMatchPattern> patterns;utility::Span marker_span;parser::ParsedMatchBody body;ParsedMatchCase(Array<parser::ParsedMatchPattern> a_patterns, utility::Span a_marker_span, parser::ParsedMatchBody a_body) :patterns(a_patterns), marker_span(a_marker_span), body(a_body){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedMatchCase("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("patterns: "));TRY(builder.appendff("{}, ", patterns));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("marker_span: "));TRY(builder.appendff("{}, ", marker_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("body: "));TRY(builder.appendff("{}", body));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedVariable {
  public:
String name;NonnullRefPtr<parser::ParsedType> parsed_type;bool is_mutable;utility::Span span;ParsedVariable(String a_name, NonnullRefPtr<parser::ParsedType> a_parsed_type, bool a_is_mutable, utility::Span a_span) :name(a_name), parsed_type(a_parsed_type), is_mutable(a_is_mutable), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedVariable("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_type: "));TRY(builder.appendff("{}, ", parsed_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedParameter {
  public:
bool requires_label;parser::ParsedVariable variable;utility::Span span;ParsedParameter(bool a_requires_label, parser::ParsedVariable a_variable, utility::Span a_span) :requires_label(a_requires_label), variable(a_variable), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("requires_label: "));TRY(builder.appendff("{}, ", requires_label));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variable: "));TRY(builder.appendff("{}, ", variable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedGenericParameter {
  public:
String name;utility::Span span;ParsedGenericParameter(String a_name, utility::Span a_span) :name(a_name), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedGenericParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedExternImport {
  public:
bool is_c;parser::ParsedNamespace assigned_namespace;ErrorOr<bool> is_equivalent_to(const parser::ParsedExternImport other) const;
ParsedExternImport(bool a_is_c, parser::ParsedNamespace a_assigned_namespace) :is_c(a_is_c), assigned_namespace(a_assigned_namespace){}

String get_name() const;
String get_path() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedExternImport("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_c: "));TRY(builder.appendff("{}, ", is_c));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("assigned_namespace: "));TRY(builder.appendff("{}", assigned_namespace));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedCapture_Details {
struct ByValue {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByValue(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByMutableReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByMutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct ParsedCapture : public Variant<ParsedCapture_Details::ByValue, ParsedCapture_Details::ByReference, ParsedCapture_Details::ByMutableReference> {
using Variant<ParsedCapture_Details::ByValue, ParsedCapture_Details::ByReference, ParsedCapture_Details::ByMutableReference>::Variant;
    using ByValue = ParsedCapture_Details::ByValue;
    using ByReference = ParsedCapture_Details::ByReference;
    using ByMutableReference = ParsedCapture_Details::ByMutableReference;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] ByValue const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedCapture::ByValue"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ByReference const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedCapture::ByReference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ByMutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("ParsedCapture::ByMutableReference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}String name() const;
utility::Span span() const;
};
struct ValueEnumVariant {
  public:
String name;utility::Span span;Optional<NonnullRefPtr<parser::ParsedExpression>> value;ValueEnumVariant(String a_name, utility::Span a_span, Optional<NonnullRefPtr<parser::ParsedExpression>> a_value) :name(a_name), span(a_span), value(a_value){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ValueEnumVariant("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("value: "));TRY(builder.appendff("{}", value));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct SumEnumVariant {
  public:
String name;utility::Span span;Optional<Array<parser::ParsedVarDecl>> params;SumEnumVariant(String a_name, utility::Span a_span, Optional<Array<parser::ParsedVarDecl>> a_params) :name(a_name), span(a_span), params(a_params){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("SumEnumVariant("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", params));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static utility::Span merge_spans(const utility::Span start,const utility::Span end) {
{
if ((((((start).file_id)).id) != ((((end).file_id)).id))){
utility::panic(String("cannot merge spans from two different files!"));
}
return (utility::Span(((start).file_id),((start).start),((end).end)));
}
}

static bool binary_operator_equals(const parser::BinaryOperator lhs_op,const parser::BinaryOperator rhs_op) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = lhs_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Add>());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Subtract>());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Multiply>());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Divide>());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Modulo>());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::LessThan>());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::LessThanOrEqual>());
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::GreaterThan>());
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::GreaterThanOrEqual>());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Equal>());
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::NotEqual>());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseAnd>());
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseXor>());
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseOr>());
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseLeftShift>());
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseRightShift>());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::ArithmeticLeftShift>());
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticRightShift>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::ArithmeticRightShift>());
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::LogicalOr>());
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::LogicalAnd>());
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::NoneCoalescing>());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Assign>());
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseAndAssign>());
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseOrAssign>());
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseXorAssign>());
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseLeftShiftAssign>());
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::BitwiseRightShiftAssign>());
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::AddAssign>());
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::SubtractAssign>());
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::MultiplyAssign>());
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::ModuloAssign>());
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::DivideAssign>());
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::NoneCoalescingAssign>());
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Garbage>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::BinaryOperator::Garbage>());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool unary_operator_equals(const parser::UnaryOperator lhs_op,const parser::UnaryOperator rhs_op) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = lhs_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::PreIncrement>());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::PostIncrement>());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::PreDecrement>());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::PostDecrement>());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Negate>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::Negate>());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::Dereference>());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::RawAddress>());
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Reference>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::Reference>());
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::MutableReference>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::MutableReference>());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::LogicalNot>());
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue((rhs_op).has<parser::UnaryOperator::BitwiseNot>());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_statement_equals(const NonnullRefPtr<parser::ParsedStatement> lhs_statement,const NonnullRefPtr<parser::ParsedStatement> rhs_statement) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *lhs_statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& lhs_statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& rhs_statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(parser::parsed_statement_equals(lhs_statement,rhs_statement));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& lhs_var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& lhs_init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& rhs_var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& rhs_init = __jakt_match_value.init;
return JaktInternal::ExplicitValue((parser::parsed_var_decl_equals(lhs_var,rhs_var) && parser::parsed_expression_equals(lhs_init,rhs_init)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& lhs_vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& lhs_var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& rhs_vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& rhs_var_decl = __jakt_match_value.var_decl;
{
if ((((lhs_vars).size()) != ((rhs_vars).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_vars).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!parser::parsed_var_decl_equals(((lhs_vars)[i]),((rhs_vars)[i])))){
return (false);
}
}

}
}

if ((!parser::parsed_statement_equals(lhs_var_decl,rhs_var_decl))){
return (false);
}
return (true);
}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& lhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& lhs_then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& lhs_else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& rhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& rhs_then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& rhs_else_statement = __jakt_match_value.else_statement;
{
if ((!(parser::parsed_expression_equals(lhs_condition,rhs_condition) && parser::parsed_block_equals(lhs_then_block,rhs_then_block)))){
return (false);
}
if ((!((lhs_else_statement).has_value()))){
return ((!((rhs_else_statement).has_value())));
}
else {
if ((!((rhs_else_statement).has_value()))){
return (false);
}
if (parser::parsed_statement_equals((lhs_else_statement.value()),(rhs_else_statement.value()))){
return (true);
}
return (false);
}

}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& lhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& rhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_condition,rhs_condition) && parser::parsed_block_equals(lhs_block,rhs_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& lhs_iterator_name = __jakt_match_value.iterator_name;
NonnullRefPtr<parser::ParsedExpression> const& lhs_range = __jakt_match_value.range;
parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& rhs_iterator_name = __jakt_match_value.iterator_name;
NonnullRefPtr<parser::ParsedExpression> const& rhs_range = __jakt_match_value.range;
parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_5; {
__jakt_var_5 = (((lhs_iterator_name == rhs_iterator_name) && parser::parsed_expression_equals(lhs_range,rhs_range)) && parser::parsed_block_equals(lhs_block,rhs_block)); goto __jakt_label_5;

}
__jakt_label_5:; __jakt_var_5.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
return JaktInternal::ExplicitValue((rhs_statement)->has<parser::ParsedStatement::Break>());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
return JaktInternal::ExplicitValue((rhs_statement)->has<parser::ParsedStatement::Continue>());
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& rhs_expr = __jakt_match_value.expr;
{
if ((!((lhs_expr).has_value()))){
return ((!((rhs_expr).has_value())));
}
else {
if ((!((rhs_expr).has_value()))){
return (false);
}
if (parser::parsed_expression_equals((lhs_expr.value()),(rhs_expr.value()))){
return (true);
}
return (false);
}

}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Try>();NonnullRefPtr<parser::ParsedStatement> const& lhs_stmt = __jakt_match_value.stmt;
String const& lhs_error_name = __jakt_match_value.error_name;
parser::ParsedBlock const& lhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Try>();NonnullRefPtr<parser::ParsedStatement> const& rhs_stmt = __jakt_match_value.stmt;
String const& rhs_error_name = __jakt_match_value.error_name;
parser::ParsedBlock const& rhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_6; {
__jakt_var_6 = (((lhs_error_name == rhs_error_name) && parser::parsed_statement_equals(lhs_stmt,rhs_stmt)) && parser::parsed_block_equals(lhs_catch_block,rhs_catch_block)); goto __jakt_label_6;

}
__jakt_label_6:; __jakt_var_6.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedBlock const& else_block = __jakt_match_value.else_block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::ParsedBlock const& rhs_else_block = __jakt_match_value.else_block;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(expr,rhs_expr) && parser::parsed_block_equals(else_block,rhs_else_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
return JaktInternal::ExplicitValue((rhs_statement)->has<parser::ParsedStatement::Garbage>());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_var_decl_equals(const parser::ParsedVarDecl lhs_var_decl,const parser::ParsedVarDecl rhs_var_decl) {
{
return (((((lhs_var_decl).name) == ((rhs_var_decl).name)) && (((lhs_var_decl).is_mutable) == ((rhs_var_decl).is_mutable))));
}
}

static bool parsed_call_equals(const parser::ParsedCall lhs_parsed_call,const parser::ParsedCall rhs_parsed_call) {
{
if ((((lhs_parsed_call).name) != ((rhs_parsed_call).name))){
return (false);
}
if ((((((lhs_parsed_call).args)).size()) != ((((rhs_parsed_call).args)).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((lhs_parsed_call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const String lhs_str = ((((((lhs_parsed_call).args))[i])).get<0>());
const String rhs_str = ((((((rhs_parsed_call).args))[i])).get<0>());
const NonnullRefPtr<parser::ParsedExpression> lhs_expr = ((((((lhs_parsed_call).args))[i])).get<2>());
const NonnullRefPtr<parser::ParsedExpression> rhs_expr = ((((((rhs_parsed_call).args))[i])).get<2>());
if (((lhs_str != rhs_str) || (!parser::parsed_expression_equals(lhs_expr,rhs_expr)))){
return (false);
}
}

}
}

return (true);
}
}

static bool parsed_expression_equals(const NonnullRefPtr<parser::ParsedExpression> lhs_expression,const NonnullRefPtr<parser::ParsedExpression> rhs_expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *lhs_expression;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((((lhs_val).to_usize()) == ((rhs_val).to_usize())));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& lhs_call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& rhs_call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(parser::parsed_call_equals(lhs_call,rhs_call));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
parser::ParsedCall const& lhs_call = __jakt_match_value.call;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::ParsedCall const& rhs_call = __jakt_match_value.call;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && parser::parsed_call_equals(lhs_call,rhs_call)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
size_t const& lhs_index = __jakt_match_value.index;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
size_t const& rhs_index = __jakt_match_value.index;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && (lhs_index == rhs_index)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
String const& lhs_field = __jakt_match_value.field;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
String const& rhs_field = __jakt_match_value.field;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && (lhs_field == rhs_field)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& lhs_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& rhs_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((lhs_name == rhs_name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& lhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& lhs_index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& rhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& rhs_index = __jakt_match_value.index;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_base,rhs_base) && parser::parsed_expression_equals(lhs_index,rhs_index)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
parser::UnaryOperator const& lhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::UnaryOperator const& rhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_expr,rhs_expr) && parser::unary_operator_equals(lhs_op,rhs_op)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs_lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& lhs_op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& lhs_rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& rhs_lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& rhs_op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs_rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(((parser::parsed_expression_equals(lhs_lhs,rhs_lhs) && parser::binary_operator_equals(lhs_op,rhs_op)) && parser::parsed_expression_equals(lhs_rhs,rhs_rhs)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& lhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& rhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(parser::binary_operator_equals(lhs_op,rhs_op));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
return JaktInternal::ExplicitValue((rhs_expression)->has<parser::ParsedExpression::OptionalNone>());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& lhs_fill_size = __jakt_match_value.fill_size;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& rhs_fill_size = __jakt_match_value.fill_size;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_7; {
if ((!((lhs_fill_size).has_value()))){
if (((rhs_fill_size).has_value())){
return (false);
}
}
else {
if ((!((rhs_fill_size).has_value()))){
return (false);
}
if ((!parser::parsed_expression_equals((lhs_fill_size.value()),(rhs_fill_size.value())))){
return (false);
}
}

if (((!((lhs_values).size())) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i])))){
return (false);
}
}

}
}

__jakt_var_7 = true; goto __jakt_label_7;

}
__jakt_label_7:; __jakt_var_7.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_8; {
if (((!((lhs_values).size())) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(parser::parsed_expression_equals(((((lhs_values)[i])).get<0>()),((((rhs_values)[i])).get<0>())) && parser::parsed_expression_equals(((((lhs_values)[i])).get<1>()),((((rhs_values)[i])).get<1>()))))){
return (false);
}
}

}
}

__jakt_var_8 = true; goto __jakt_label_8;

}
__jakt_label_8:; __jakt_var_8.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_9; {
if (((!((lhs_values).size())) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i])))){
return (false);
}
}

}
}

__jakt_var_9 = true; goto __jakt_label_9;

}
__jakt_label_9:; __jakt_var_9.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_10; {
if (((!((lhs_values).size())) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i])))){
return (false);
}
}

}
}

__jakt_var_10 = true; goto __jakt_label_10;

}
__jakt_label_10:; __jakt_var_10.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& lhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& lhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& rhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& rhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_from,rhs_from) && parser::parsed_expression_equals(lhs_to,rhs_to)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& lhs_name = __jakt_match_value.name;
Array<String> const& lhs_namespace = __jakt_match_value.namespace_;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& rhs_name = __jakt_match_value.name;
Array<String> const& rhs_namespace = __jakt_match_value.namespace_;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_11; {
if ((((lhs_namespace).size()) != ((rhs_namespace).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_namespace).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((((lhs_namespace)[i]) != ((rhs_namespace)[i]))){
return (false);
}
}

}
}

__jakt_var_11 = (lhs_name == rhs_name); goto __jakt_label_11;

}
__jakt_label_11:; __jakt_var_11.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();return JaktInternal::ExplicitValue(false);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
return JaktInternal::ExplicitValue((rhs_expression)->has<parser::ParsedExpression::Garbage>());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_block_equals(const parser::ParsedBlock lhs_block,const parser::ParsedBlock rhs_block) {
{
if ((((((lhs_block).stmts)).size()) != ((((rhs_block).stmts)).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((lhs_block).stmts)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t x = (_magic_value.value());
{
const NonnullRefPtr<parser::ParsedStatement> lhs_statement = ((((lhs_block).stmts))[x]);
const NonnullRefPtr<parser::ParsedStatement> rhs_statement = ((((rhs_block).stmts))[x]);
const bool are_statements_equal = parser::parsed_statement_equals(((((lhs_block).stmts))[x]),((((rhs_block).stmts))[x]));
if ((!are_statements_equal)){
return (false);
}
}

}
}

return (true);
}
}

Optional<utility::Span> parser::ParsedBlock::find_yield_span() const {
{
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((*this).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
if ((stmt)->has<parser::ParsedStatement::Yield>()){
const NonnullRefPtr<parser::ParsedExpression> expr = (stmt->get<parser::ParsedStatement::Yield>()).expr;
return (((expr)->span()));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

ErrorOr<Optional<utility::Span>> parser::ParsedBlock::span(const parser::Parser parser) const {
{
Optional<size_t> start = JaktInternal::OptionalNone();
size_t end = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((*this).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
const utility::Span stmt_span = ((stmt)->span());
if ((!((start).has_value()))){
(start = ((stmt_span).start));
}
(end = ((stmt_span).end));
}

}
}

if (((start).has_value())){
return (((parser).span((start.value()),end)));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<bool> parser::ParsedExternImport::is_equivalent_to(const parser::ParsedExternImport other) const {
{
return ((((((*this).is_c) && ((other).is_c)) && (((*this).get_path()) == ((other).get_path()))) && (((*this).get_name()) == ((other).get_name()))));
}
}

String parser::ParsedExternImport::get_name() const {
{
return ((((((*this).assigned_namespace)).name).value()));
}
}

String parser::ParsedExternImport::get_path() const {
{
return ((((((*this).assigned_namespace)).import_path_if_extern).value()));
}
}

bool parser::ParsedModuleImport::is_equivalent_to(const parser::ParsedModuleImport other) const {
{
return ((((((((*this).module_name)).name) == ((((other).module_name)).name)) && ((*this).has_same_alias_than(other))) && ((*this).has_same_import_semantics(other))));
}
}

bool parser::ParsedModuleImport::has_same_alias_than(const parser::ParsedModuleImport other) const {
{
if (((((*this).alias_name)).has_value())){
return ((((((other).alias_name)).has_value()) && ((((((other).alias_name).value())).name) == (((((*this).alias_name).value())).name))));
}
else {
return ((!((((other).alias_name)).has_value())));
}

}
}

bool parser::ParsedModuleImport::has_same_import_semantics(const parser::ParsedModuleImport other) const {
{
return ((((((*this).import_list)).is_empty()) == ((((other).import_list)).is_empty())));
}
}

ErrorOr<void> parser::ParsedModuleImport::merge_import_list(const Array<parser::ImportName> list) {
{
TRY((((((*this).import_list)).add_capacity(((list).size())))));
Set<String> name_set = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ImportName> _magic = ((((*this).import_list)).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ImportName import_ = (_magic_value.value());
{
TRY((((name_set).add(((import_).name)))));
}

}
}

{
ArrayIterator<parser::ImportName> _magic = ((list).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ImportName import_ = (_magic_value.value());
{
if ((!((name_set).contains(((import_).name))))){
TRY((((name_set).add(((import_).name)))));
TRY((((((*this).import_list)).push(import_))));
}
}

}
}

}
return {};
}

ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>> parser::Parser::parse_value_enum_body(const parser::ParsedRecord partial_enum,const parser::DefinitionLinkage definition_linkage) {
{
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Array<parser::ValueEnumVariant> variants = (TRY((Array<parser::ValueEnumVariant>::create_with({}))));
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `{` to start the enum body"),((((*this).current())).span())))));
}

((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected variant name"),((((*this).previous())).span())))));
return ((Tuple{variants, methods}));
}
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::Equal>()){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
TRY((((variants).push(parser::ValueEnumVariant(name,span,expr)))));
}
else {
(((*this).index)++);
TRY((((variants).push(parser::ValueEnumVariant(name,span,JaktInternal::OptionalNone())))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected identifier or the end of enum block"),((((*this).current())).span())))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (((*this).eof())){
TRY((((*this).error(String("Invalid enum definition, expected `}`"),((((*this).current())).span())))));
return ((Tuple{variants, methods}));
}
if (((variants).is_empty())){
TRY((((*this).error(String("Empty enums are not allowed"),((partial_enum).name_span)))));
}
return ((Tuple{variants, methods}));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_try_statement() {
{
const utility::Span start_span = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedStatement> stmt = TRY((((*this).parse_statement(false))));
String error_name = String("");
utility::Span error_span = ((((*this).current())).span());
if ((((*this).current())).has<lexer::Token::Catch>()){
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(error_span = ((((*this).current())).span()));
(error_name = name);
(((*this).index)++);
}
}
else {
TRY((((*this).error(String("Expected catch"),((((*this).current())).span())))));
}

const parser::ParsedBlock catch_block = TRY((((*this).parse_block())));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Try>(stmt,error_name,error_span,catch_block,parser::merge_spans(start_span,((((*this).previous())).span()))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_statement(const bool inside_block) {
{
const utility::Span start = ((((*this).current())).span());
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedStatement>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 66: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Cpp>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_12; {
(((*this).index)++);
__jakt_var_12 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::InlineCpp>(TRY((((*this).parse_block()))),parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_12;

}
__jakt_label_12:; __jakt_var_12.release_value(); }));
};/*case end*/
case 67: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Defer>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_13; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedStatement> statement = TRY((((*this).parse_statement(false))));
__jakt_var_13 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Defer>(statement,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_13;

}
__jakt_label_13:; __jakt_var_13.release_value(); }));
};/*case end*/
case 96: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Unsafe>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_14; {
(((*this).index)++);
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_14 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::UnsafeBlock>(block,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_14;

}
__jakt_label_14:; __jakt_var_14.release_value(); }));
};/*case end*/
case 62: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Break>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_15; {
(((*this).index)++);
__jakt_var_15 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Break>(start))); goto __jakt_label_15;

}
__jakt_label_15:; __jakt_var_15.release_value(); }));
};/*case end*/
case 65: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Continue>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_16; {
(((*this).index)++);
__jakt_var_16 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Continue>(start))); goto __jakt_label_16;

}
__jakt_label_16:; __jakt_var_16.release_value(); }));
};/*case end*/
case 79: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Loop>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_17; {
(((*this).index)++);
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_17 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Loop>(block,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_17;

}
__jakt_label_17:; __jakt_var_17.release_value(); }));
};/*case end*/
case 92: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throw>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_18; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
__jakt_var_18 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Throw>(expr,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_18;

}
__jakt_label_18:; __jakt_var_18.release_value(); }));
};/*case end*/
case 98: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::While>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_19; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> condition = TRY((((*this).parse_expression(false,true))));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_19 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::While>(condition,block,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_19;

}
__jakt_label_19:; __jakt_var_19.release_value(); }));
};/*case end*/
case 99: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Yield>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_20; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if ((!inside_block)){
TRY((((*this).error(String("yield can only be used inside a block"),parser::merge_spans(start,((expr)->span()))))));
}
__jakt_var_20 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Yield>(expr,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_20;

}
__jakt_label_20:; __jakt_var_20.release_value(); }));
};/*case end*/
case 88: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Return>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_21; {
(((*this).index)++);
__jakt_var_21 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedStatement>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
case 55: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eof>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(TRY((((*this).parse_expression(false,false)))),parser::merge_spans(start,((((*this).previous())).span()))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_21;

}
__jakt_label_21:; __jakt_var_21.release_value(); }));
};/*case end*/
case 78: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Let>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_22; {
const bool is_mutable = (((*this).current())).has<lexer::Token::Mut>();
(((*this).index)++);
Array<parser::ParsedVarDecl> vars = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
bool is_destructuring_assingment = false;
String tuple_var_name = String("");
parser::ParsedVarDecl tuple_var_decl = parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,JaktInternal::OptionalNone(),((((*this).current())).span()));
if ((((*this).current())).has<lexer::Token::LParen>()){
(vars = TRY((((*this).parse_destructuring_assignment(is_mutable)))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = ((vars).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedVarDecl var = (_magic_value.value());
{
(tuple_var_name += ((var).name));
(tuple_var_name += String("_"));
}

}
}

(((tuple_var_decl).name) = tuple_var_name);
(is_destructuring_assingment = true);
}
else {
(tuple_var_decl = TRY((((*this).parse_variable_declaration(is_mutable)))));
}

const NonnullRefPtr<parser::ParsedExpression> init = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_23; {
(((*this).index)++);
__jakt_var_23 = TRY((((*this).parse_expression(false,false)))); goto __jakt_label_23;

}
__jakt_label_23:; __jakt_var_23.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_24; {
TRY((((*this).error(String("Expected initializer"),((((*this).current())).span())))));
__jakt_var_24 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))); goto __jakt_label_24;

}
__jakt_label_24:; __jakt_var_24.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(tuple_var_decl,init,parser::merge_spans(start,((((*this).previous())).span())))));
if (is_destructuring_assingment){
const NonnullRefPtr<parser::ParsedStatement> old_return_statement = return_statement;
(return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::DestructuringAssignment>(vars,old_return_statement,parser::merge_spans(start,((((*this).previous())).span()))))));
}
__jakt_var_22 = return_statement; goto __jakt_label_22;

}
__jakt_label_22:; __jakt_var_22.release_value(); }));
};/*case end*/
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_25; {
const bool is_mutable = (((*this).current())).has<lexer::Token::Mut>();
(((*this).index)++);
Array<parser::ParsedVarDecl> vars = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
bool is_destructuring_assingment = false;
String tuple_var_name = String("");
parser::ParsedVarDecl tuple_var_decl = parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,JaktInternal::OptionalNone(),((((*this).current())).span()));
if ((((*this).current())).has<lexer::Token::LParen>()){
(vars = TRY((((*this).parse_destructuring_assignment(is_mutable)))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = ((vars).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedVarDecl var = (_magic_value.value());
{
(tuple_var_name += ((var).name));
(tuple_var_name += String("_"));
}

}
}

(((tuple_var_decl).name) = tuple_var_name);
(is_destructuring_assingment = true);
}
else {
(tuple_var_decl = TRY((((*this).parse_variable_declaration(is_mutable)))));
}

const NonnullRefPtr<parser::ParsedExpression> init = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_26; {
(((*this).index)++);
__jakt_var_26 = TRY((((*this).parse_expression(false,false)))); goto __jakt_label_26;

}
__jakt_label_26:; __jakt_var_26.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_27; {
TRY((((*this).error(String("Expected initializer"),((((*this).current())).span())))));
__jakt_var_27 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))); goto __jakt_label_27;

}
__jakt_label_27:; __jakt_var_27.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(tuple_var_decl,init,parser::merge_spans(start,((((*this).previous())).span())))));
if (is_destructuring_assingment){
const NonnullRefPtr<parser::ParsedStatement> old_return_statement = return_statement;
(return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::DestructuringAssignment>(vars,old_return_statement,parser::merge_spans(start,((((*this).previous())).span()))))));
}
__jakt_var_25 = return_statement; goto __jakt_label_25;

}
__jakt_label_25:; __jakt_var_25.release_value(); }));
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_if_statement()))));
};/*case end*/
case 72: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::For>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_for_statement()))));
};/*case end*/
case 95: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Try>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_try_statement()))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_28; {
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_28 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_28;

}
__jakt_label_28:; __jakt_var_28.release_value(); }));
};/*case end*/
case 100: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Guard>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_guard_statement()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_29; {
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(true,false))));
__jakt_var_29 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Expression>(expr,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_29;

}
__jakt_label_29:; __jakt_var_29.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<String> parser::Parser::parse_argument_label() {
{
if (((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::Colon>() && (((*this).current())).has<lexer::Token::Identifier>())){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
return (name);
}
return (String(""));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_array_or_dictionary() {
{
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
if ((((*this).current())).has<lexer::Token::RSquare>()){
(((*this).index)++);
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::JaktArray>(inner,parser::merge_spans(start,((((*this).previous())).span()))))));
}
if ((((*this).current())).has<lexer::Token::Colon>()){
(((*this).index)++);
const NonnullRefPtr<parser::ParsedType> value = TRY((((*this).parse_typename())));
if ((((*this).current())).has<lexer::Token::RSquare>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected ']'"),((((*this).current())).span())))));
}

return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Dictionary>(inner,value,parser::merge_spans(start,((((*this).current())).span()))))));
}
TRY((((*this).error(String("Expected shorthand type"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<parser::ParsedBlock> parser::Parser::parse_fat_arrow() {
{
(((*this).index)++);
const utility::Span start = ((((*this).current())).span());
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
const NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(expr,parser::merge_spans(start,((((*this).current())).span())))));
return (parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({return_statement}))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_typename() {
{
const utility::Span start = ((((*this).current())).span());
bool is_reference = false;
bool is_mutable_reference = false;
if ((((*this).current())).has<lexer::Token::Ampersand>()){
(is_reference = true);
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Mut>()){
(is_mutable_reference = true);
(((*this).index)++);
}
}
NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_type_shorthand())));
if ((parsed_type)->has<parser::ParsedType::Empty>()){
(parsed_type = TRY((((*this).parse_type_longhand()))));
}
if ((((*this).current())).has<lexer::Token::QuestionMark>()){
(((*this).index)++);
const utility::Span span = parser::merge_spans(start,((((*this).current())).span()));
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Optional>(parsed_type,span))));
}
if (is_reference){
const utility::Span span = parser::merge_spans(start,((((*this).current())).span()));
if (is_mutable_reference){
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::MutableReference>(parsed_type,span))));
}
else {
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Reference>(parsed_type,span))));
}

}
return (parsed_type);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_match_expression() {
{
utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,true))));
const Array<parser::ParsedMatchCase> cases = TRY((((*this).parse_match_cases())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Match>(expr,cases,parser::merge_spans(start,((((*this).previous())).span()))))));
}
}

ErrorOr<void> parser::Parser::error_with_hint(const String message,const utility::Span span,const String hint,const utility::Span hint_span) {
{
if ((!((((*this).compiler))->ignore_parser_errors))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::MessageWithHint(message,span,hint,hint_span)))));
}
}
return {};
}

ErrorOr<parser::ParsedField> parser::Parser::parse_field(const parser::Visibility visibility) {
{
const parser::ParsedVarDecl parsed_variable_declaration = TRY((((*this).parse_variable_declaration(true))));
if ((((parsed_variable_declaration).parsed_type))->has<parser::ParsedType::Empty>()){
TRY((((*this).error(String("Field missing type"),((parsed_variable_declaration).span)))));
}
return (parser::ParsedField(parsed_variable_declaration,visibility));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_class(const parser::DefinitionLinkage definition_linkage) {
{
parser::ParsedRecord parsed_class = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
Optional<NonnullRefPtr<parser::ParsedType>> super_class = JaktInternal::OptionalNone();
if ((((*this).current())).has<lexer::Token::Class>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `class` keyword"),((((*this).current())).span())))));
return (parsed_class);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected name"),((((*this).current())).span())))));
return (parsed_class);
}
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((*this).index)++);
(((parsed_class).name) = name);
(((parsed_class).name_span) = span);
}
else {
TRY((((*this).error(String("Incomplete class definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected generic parameters or super class or body"),((((*this).current())).span())))));
return (parsed_class);
}
(((parsed_class).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected super class or body"),((((*this).current())).span())))));
return (parsed_class);
}
if ((((*this).current())).has<lexer::Token::Colon>()){
(((*this).index)++);
(super_class = TRY((((*this).parse_typename()))));
}
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected body"),((((*this).current())).span())))));
return (parsed_class);
}
const Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>> fields_methods = TRY((((*this).parse_struct_class_body(definition_linkage,typename parser::Visibility::Private(),true))));
(((parsed_class).methods) = ((fields_methods).get<1>()));
(((parsed_class).record_type) = typename parser::RecordType::Class(((fields_methods).get<0>()),super_class));
return (parsed_class);
}
}

bool parser::Parser::eof() const {
{
return ((((*this).index) >= (JaktInternal::checked_sub<size_t>(((((*this).tokens)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_enum(const parser::DefinitionLinkage definition_linkage,const bool is_boxed) {
{
parser::ParsedRecord parsed_enum = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
Optional<NonnullRefPtr<parser::ParsedType>> underlying_type = JaktInternal::OptionalNone();
if ((((*this).current())).has<lexer::Token::Enum>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected enum keyword"),((((*this).current())).span())))));
return (parsed_enum);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected name"),((((*this).current())).span())))));
return (parsed_enum);
}
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((parsed_enum).name) = name);
(((parsed_enum).name_span) = span);
(((*this).index)++);
}
else {
TRY((((*this).error(String("Incomplete enum definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected generic parameters or underlying type or body"),((((*this).current())).span())))));
return (parsed_enum);
}
if ((((*this).current())).has<lexer::Token::LessThan>()){
(((parsed_enum).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
}
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected underlying type or body"),((((*this).current())).span())))));
return (parsed_enum);
}
if ((((*this).current())).has<lexer::Token::Colon>()){
if (is_boxed){
TRY((((*this).error(String("Invalid enum definition: Value enums must not have an underlying type"),((((*this).current())).span())))));
}
(((*this).index)++);
(underlying_type = TRY((((*this).parse_typename()))));
}
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected body"),((((*this).current())).span())))));
return (parsed_enum);
}
if (((underlying_type).has_value())){
const Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>> variants_methods = TRY((((*this).parse_value_enum_body(parsed_enum,definition_linkage))));
(((parsed_enum).methods) = ((variants_methods).get<1>()));
(((parsed_enum).record_type) = typename parser::RecordType::ValueEnum((underlying_type.value()),((variants_methods).get<0>())));
}
else {
const Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>> variants_methods = TRY((((*this).parse_sum_enum_body(parsed_enum,definition_linkage,is_boxed))));
(((parsed_enum).methods) = ((variants_methods).get<1>()));
(((parsed_enum).record_type) = typename parser::RecordType::SumEnum(is_boxed,((variants_methods).get<0>())));
}

return (parsed_enum);
}
}

utility::Span parser::Parser::span(const size_t start,const size_t end) const {
{
return (utility::Span((((((*this).compiler))->current_file).value()),start,end));
}
}

ErrorOr<Array<parser::ParsedVarDecl>> parser::Parser::parse_destructuring_assignment(const bool is_mutable) {
{
(((*this).index)++);
Array<parser::ParsedVarDecl> var_declarations = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
for (;;){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedVarDecl>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
TRY((((var_declarations).push(TRY((((*this).parse_variable_declaration(is_mutable))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return (var_declarations);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected close of destructuring assignment block"),((((*this).current())).span())))));
return ((TRY((Array<parser::ParsedVarDecl>::create_with({})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return ((TRY((Array<parser::ParsedVarDecl>::create_with({parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),((((*this).current())).span()))})))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand_base() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_30; {
__jakt_var_30 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("this"),span))); goto __jakt_label_30;

}
__jakt_label_30:; __jakt_var_30.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_31; {
(((*this).index)++);
__jakt_var_31 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::QuotedString>(quote,span))); goto __jakt_label_31;

}
__jakt_label_31:; __jakt_var_31.release_value(); }));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_32; {
(((*this).index)++);
__jakt_var_32 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::SingleQuotedString>(quote,span))); goto __jakt_label_32;

}
__jakt_label_32:; __jakt_var_32.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_33; {
(((*this).index)++);
__jakt_var_33 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::SingleQuotedByteString>(quote,span))); goto __jakt_label_33;

}
__jakt_label_33:; __jakt_var_33.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_34; {
(((*this).index)++);
__jakt_var_34 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NumericConstant>(number,span))); goto __jakt_label_34;

}
__jakt_label_34:; __jakt_var_34.release_value(); }));
};/*case end*/
case 94: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_35; {
(((*this).index)++);
__jakt_var_35 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Boolean>(true,span))); goto __jakt_label_35;

}
__jakt_label_35:; __jakt_var_35.release_value(); }));
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_36; {
(((*this).index)++);
__jakt_var_36 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Boolean>(false,span))); goto __jakt_label_36;

}
__jakt_label_36:; __jakt_var_36.release_value(); }));
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_37; {
(((*this).index)++);
__jakt_var_37 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("this"),span))); goto __jakt_label_37;

}
__jakt_label_37:; __jakt_var_37.release_value(); }));
};/*case end*/
case 83: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Not>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_38; {
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = parser::merge_spans(start,((expr)->span()));
__jakt_var_38 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::LogicalNot(),span))); goto __jakt_label_38;

}
__jakt_label_38:; __jakt_var_38.release_value(); }));
};/*case end*/
case 45: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Tilde>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_39; {
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = parser::merge_spans(start,((expr)->span()));
__jakt_var_39 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::BitwiseNot(),span))); goto __jakt_label_39;

}
__jakt_label_39:; __jakt_var_39.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_40; {
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::LParen>()){
if ((name == String("Some"))){
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalSome>(expr,span))));
}
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),span))));
}
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::LessThan>()){
(((((*this).compiler))->ignore_parser_errors) = true);
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
(((((*this).compiler))->ignore_parser_errors) = false);
if ((!((call).has_value()))){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>,ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == String("None")) {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalNone>(span))));
}
else {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(name,span))));
}
}()))
);
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),span))));
}
(((*this).index)++);
if ((name == String("None"))){
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalNone>(span))));
}
__jakt_var_40 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(name,span))); goto __jakt_label_40;

}
__jakt_label_40:; __jakt_var_40.release_value(); }));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_41; {
const utility::Span start_span = ((((*this).current())).span());
(((*this).index)++);
NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
((*this).skip_newlines());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
Array<NonnullRefPtr<parser::ParsedExpression>> tuple_exprs = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({expr}))));
utility::Span end_span = start_span;
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
(end_span = ((expr)->span()));
TRY((((tuple_exprs).push(expr))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (((*this).eof())){
TRY((((*this).error(String("Expected ')'"),((((*this).current())).span())))));
}
(expr = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktTuple>(tuple_exprs,parser::merge_spans(start_span,end_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected ')'"),((((*this).current())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_41 = expr; goto __jakt_label_41;

}
__jakt_label_41:; __jakt_var_41.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_42; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = parser::merge_spans(start,((expr)->span()));
__jakt_var_42 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_42;

}
__jakt_label_42:; __jakt_var_42.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_43; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = parser::merge_spans(start,((expr)->span()));
__jakt_var_43 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_43;

}
__jakt_label_43:; __jakt_var_43.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_44; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = parser::merge_spans(start,((expr)->span()));
__jakt_var_44 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_44;

}
__jakt_label_44:; __jakt_var_44.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_45; {
__jakt_var_45 = TRY((((*this).parse_array_or_dictionary_literal()))); goto __jakt_label_45;

}
__jakt_label_45:; __jakt_var_45.release_value(); }));
};/*case end*/
case 80: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Match>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_46; {
__jakt_var_46 = TRY((((*this).parse_match_expression()))); goto __jakt_label_46;

}
__jakt_label_46:; __jakt_var_46.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_47; {
__jakt_var_47 = TRY((((*this).parse_set_literal()))); goto __jakt_label_47;

}
__jakt_label_47:; __jakt_var_47.release_value(); }));
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_ampersand()))));
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_asterisk()))));
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_lambda()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_48; {
const utility::Span span = ((((*this).current())).span());
(((*this).index)++);
TRY((((*this).error(String("Unsupported expression"),span))));
__jakt_var_48 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(span))); goto __jakt_label_48;

}
__jakt_label_48:; __jakt_var_48.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<parser::ParsedFunction> parser::Parser::parse_function(const parser::FunctionLinkage linkage,const parser::Visibility visibility) {
{
parser::ParsedFunction parsed_function = parser::ParsedFunction(String(""),((*this).empty_span()),visibility,(TRY((Array<parser::ParsedParameter>::create_with({})))),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({}))))),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))),false,typename parser::FunctionType::Normal(),linkage,false);
(((*this).index)++);
if (((*this).eof())){
TRY((((*this).error(String("Incomplete function definition"),((((*this).current())).span())))));
return (parsed_function);
}
const String function_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<parser::ParsedFunction>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: {
{
return (parsed_function);
}
};/*case end*/
}/*switch end*/
}()
));
(((parsed_function).name) = function_name);
(((parsed_function).name_span) = ((((*this).current())).span()));
(((*this).index)++);
(((parsed_function).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete function"),((((*this).current())).span())))));
}
(((parsed_function).params) = TRY((((*this).parse_function_parameters()))));
bool can_throw = (function_name == String("main"));
if ((((*this).current())).has<lexer::Token::Throws>()){
(can_throw = true);
(((*this).index)++);
}
(((parsed_function).can_throw) = can_throw);
if ((((*this).current())).has<lexer::Token::Arrow>()){
(((*this).index)++);
const utility::Span start = ((((*this).current())).span());
(((parsed_function).return_type) = TRY((((*this).parse_typename()))));
(((parsed_function).return_type_span) = parser::merge_spans(start,((((*this).previous())).span())));
}
if ((linkage).has<parser::FunctionLinkage::External>()){
return (parsed_function);
}
if ((((*this).current())).has<lexer::Token::FatArrow>()){
(((parsed_function).block) = TRY((((*this).parse_fat_arrow()))));
}
else {
(((parsed_function).block) = TRY((((*this).parse_block()))));
}

return (parsed_function);
}
}

ErrorOr<parser::ParsedNamespace> parser::Parser::parse(const NonnullRefPtr<compiler::Compiler> compiler,const Array<lexer::Token> tokens) {
{
parser::Parser parser = parser::Parser(static_cast<size_t>(0ULL),tokens,compiler);
return (TRY((((parser).parse_namespace()))));
}
}

ErrorOr<parser::ParsedMethod> parser::Parser::parse_method(const parser::FunctionLinkage linkage,const parser::Visibility visibility) {
{
parser::ParsedFunction parsed_function = TRY((((*this).parse_function(linkage,visibility))));
if ((linkage).has<parser::FunctionLinkage::External>()){
(((parsed_function).must_instantiate) = true);
}
return (parser::ParsedMethod(parsed_function,visibility));
}
}

ErrorOr<parser::ParsedModuleImport> parser::Parser::parse_module_import() {
{
parser::ParsedModuleImport parsed_import = parser::ParsedModuleImport(parser::ImportName(String(""),((*this).empty_span())),JaktInternal::OptionalNone(),(TRY((Array<parser::ImportName>::create_with({})))));
(((parsed_import).module_name) = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ImportName, ErrorOr<parser::ParsedModuleImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(parser::ImportName(name,span));
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected module name"),((((*this).current())).span())))));
return (parsed_import);
}
};/*case end*/
}/*switch end*/
}()
)));
(((*this).index)++);
if (((*this).eol())){
return (parsed_import);
}
if ((((*this).current())).has<lexer::Token::As>()){
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((*this).index)++);
(((parsed_import).alias_name) = parser::ImportName(name,span));
}
else {
TRY((((*this).error(String("Expected name"),((((*this).current())).span())))));
(((*this).index)++);
}

}
if (((*this).eol())){
return (parsed_import);
}
if ((!(((*this).current())).has<lexer::Token::LCurly>())){
TRY((((*this).error(String("Expected '{'"),((((*this).current())).span())))));
}
(((*this).index)++);
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedModuleImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((((parsed_import).import_list)).push(parser::ImportName(name,span)))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected import symbol"),((((*this).current())).span())))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (parsed_import);
}
}

ErrorOr<parser::ParsedBlock> parser::Parser::parse_block() {
{
const utility::Span start = ((((*this).current())).span());
parser::ParsedBlock block = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({})))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete block"),start))));
return (block);
}
((*this).skip_newlines());
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected '{'"),start))));
}

while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedBlock>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
(((*this).index)++);
return (block);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((block).stmts)).push(TRY((((*this).parse_statement(true))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((*this).error(String("Expected complete block"),parser::merge_spans(start,((((*this).current())).span()))))));
return (block);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_longhand() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Raw>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_49; {
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
const utility::Span span = parser::merge_spans(start,((((*this).current())).span()));
__jakt_var_49 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Optional>(TRY((parser::ParsedType::template create<typename parser::ParsedType::RawPtr>(inner,span))),span))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::RawPtr>(inner,span))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_49;

}
__jakt_label_49:; __jakt_var_49.release_value(); }));
};/*case end*/
case 97: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Weak>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_50; {
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
const utility::Span span = parser::merge_spans(start,((((*this).current())).span()));
__jakt_var_50 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::WeakPtr>(inner,span))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_51; {
TRY((((*this).error(String("missing `?` after weak pointer type name"),span))));
__jakt_var_51 = TRY((parser::ParsedType::template create<typename parser::ParsedType::WeakPtr>(inner,span))); goto __jakt_label_51;

}
__jakt_label_51:; __jakt_var_51.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_50;

}
__jakt_label_50:; __jakt_var_50.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_52; {
const utility::Span span = ((((*this).current())).span());
(((*this).index)++);
NonnullRefPtr<parser::ParsedType> parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(name,span)));
if ((((*this).current())).has<lexer::Token::LessThan>()){
Array<NonnullRefPtr<parser::ParsedType>> params = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
if ((((*this).current())).has<lexer::Token::LessThan>()){
(((*this).index)++);
while (((!(((*this).current())).has<lexer::Token::GreaterThan>()) && (!((*this).eof())))){
TRY((((params).push(TRY((((*this).parse_typename())))))));
if ((((*this).current())).has<lexer::Token::Comma>()){
(((*this).index)++);
}
}
if ((((*this).current())).has<lexer::Token::GreaterThan>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `>` after type parameters"),((((*this).current())).span())))));
}

}
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::GenericType>(name,params,span))));
}
if ((((*this).current())).has<lexer::Token::ColonColon>()){
(((*this).index)++);
Array<String> namespaces = (TRY((Array<String>::create_with({name}))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& namespace_name = __jakt_match_value.name;
{
if ((((*this).previous())).has<lexer::Token::ColonColon>()){
TRY((((namespaces).push(namespace_name))));
(((*this).index)++);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
{
if ((((*this).previous())).has<lexer::Token::Identifier>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected name after"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const String type_name = (((namespaces).pop()).value());
Array<NonnullRefPtr<parser::ParsedType>> params = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
if ((((*this).current())).has<lexer::Token::LessThan>()){
(((*this).index)++);
while (((!(((*this).current())).has<lexer::Token::GreaterThan>()) && (!((*this).eof())))){
TRY((((params).push(TRY((((*this).parse_typename())))))));
if ((((*this).current())).has<lexer::Token::Comma>()){
(((*this).index)++);
}
}
if ((((*this).current())).has<lexer::Token::GreaterThan>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `>` after type parameters"),((((*this).current())).span())))));
}

}
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::NamespacedName>(type_name,namespaces,params,((((*this).previous())).span())))));
}
__jakt_var_52 = parsed_type; goto __jakt_label_52;

}
__jakt_label_52:; __jakt_var_52.release_value(); }));
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_53; {
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const Array<parser::ParsedParameter> params = TRY((((*this).parse_function_parameters())));
const bool can_throw = (((*this).current())).has<lexer::Token::Throws>();
if (can_throw){
(((*this).index)++);
}
NonnullRefPtr<parser::ParsedType> return_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>()));
if ((((*this).current())).has<lexer::Token::Arrow>()){
(((*this).index)++);
(return_type = TRY((((*this).parse_typename()))));
}
else {
TRY((((*this).error(String("Expected '->'"),((((*this).current())).span())))));
}

__jakt_var_53 = TRY((parser::ParsedType::template create<typename parser::ParsedType::Function>(params,can_throw,return_type,parser::merge_spans(start,((return_type)->span()))))); goto __jakt_label_53;

}
__jakt_label_53:; __jakt_var_53.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_54; {
TRY((((*this).error(String("Expected type name"),((((*this).current())).span())))));
__jakt_var_54 = TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())); goto __jakt_label_54;

}
__jakt_label_54:; __jakt_var_54.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_if_statement() {
{
if ((!(((*this).current())).has<lexer::Token::If>())){
TRY((((*this).error(String("Expected if statement"),((((*this).current())).span())))));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(((((*this).current())).span())))));
}
const utility::Span start_span = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> condition = TRY((((*this).parse_expression(false,true))));
const parser::ParsedBlock then_block = TRY((((*this).parse_block())));
Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement = JaktInternal::OptionalNone();
((*this).skip_newlines());
if ((((*this).current())).has<lexer::Token::Else>()){
(((*this).index)++);
((*this).skip_newlines());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
{
(else_statement = TRY((((*this).parse_if_statement()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
{
const parser::ParsedBlock block = TRY((((*this).parse_block())));
if (parser::parsed_block_equals(then_block,block)){
TRY((((*this).error(String("if and else have identical blocks"),((((*this).current())).span())))));
}
(else_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,parser::merge_spans(start_span,((((*this).previous())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("else missing if or block"),((((*this).previous())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(condition,then_block,else_statement,parser::merge_spans(start_span,((((*this).previous())).span()))))));
}
}

ErrorOr<void> parser::Parser::error(const String message,const utility::Span span) {
{
if ((!((((*this).compiler))->ignore_parser_errors))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
}
return {};
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operator(const bool allow_assignments) {
{
const utility::Span span = ((((*this).current())).span());
const parser::BinaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::BinaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 49: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMark>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NoneCoalescing());
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Plus>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Add());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Subtract());
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Multiply());
};/*case end*/
case 46: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlash>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Divide());
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSign>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Modulo());
};/*case end*/
case 58: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::And>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LogicalAnd());
};/*case end*/
case 84: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Or>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LogicalOr());
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DoubleEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Equal());
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::NotEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NotEqual());
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThan>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LessThan());
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThanOrEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LessThanOrEqual());
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::GreaterThan());
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::GreaterThanOrEqual());
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseAnd());
};/*case end*/
case 40: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Pipe>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseOr());
};/*case end*/
case 42: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Caret>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseXor());
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseLeftShift());
};/*case end*/
case 34: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseRightShift());
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftArithmeticShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ArithmeticLeftShift());
};/*case end*/
case 35: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightArithmeticShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ArithmeticRightShift());
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Assign());
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShiftEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseLeftShiftAssign());
};/*case end*/
case 36: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShiftEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseRightShiftAssign());
};/*case end*/
case 39: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AmpersandEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseAndAssign());
};/*case end*/
case 41: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PipeEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseOrAssign());
};/*case end*/
case 43: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::CaretEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseXorAssign());
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::AddAssign());
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::SubtractAssign());
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AsteriskEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::MultiplyAssign());
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlashEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::DivideAssign());
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSignEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ModuloAssign());
};/*case end*/
case 50: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMarkEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NoneCoalescingAssign());
};/*case end*/
default: {
{
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(span))));
}
};/*case end*/
}/*switch end*/
}()
));
(((*this).index)++);
if (((!allow_assignments) && ((op).is_assignment()))){
TRY((((*this).error(String("Assignment is not allowed in this position"),span))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Operator>(op,span))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Operator>(op,span))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_for_statement() {
{
const utility::Span start_span = ((((*this).current())).span());
(((*this).index)++);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedStatement>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_55; {
const String iterator_name = name;
const utility::Span name_span = ((((*this).current())).span());
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::In>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected in"),((((*this).current())).span())))));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(parser::merge_spans(start_span,((((*this).current())).span()))))));
}

const NonnullRefPtr<parser::ParsedExpression> range = TRY((((*this).parse_expression(false,false))));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_55 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::For>(iterator_name,name_span,range,block,parser::merge_spans(start_span,((((*this).previous())).span()))))); goto __jakt_label_55;

}
__jakt_label_55:; __jakt_var_55.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_56; {
TRY((((*this).error(String("Expected iterator name"),((((*this).current())).span())))));
__jakt_var_56 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(parser::merge_spans(start_span,((((*this).current())).span()))))); goto __jakt_label_56;

}
__jakt_label_56:; __jakt_var_56.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<Array<parser::ParsedParameter>> parser::Parser::parse_function_parameters() {
{
if ((((*this).current())).has<lexer::Token::LParen>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected '('"),((((*this).current())).span())))));
}

((*this).skip_newlines());
Array<parser::ParsedParameter> params = (TRY((Array<parser::ParsedParameter>::create_with({}))));
bool current_param_requires_label = true;
bool current_param_is_mutable = false;
bool error = false;
bool parameter_complete = false;
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedParameter>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
if (((!parameter_complete) && (!error))){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
(((*this).index)++);
(current_param_requires_label = true);
(current_param_is_mutable = false);
(parameter_complete = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
if (((!parameter_complete) && (!error))){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
(((*this).index)++);
(current_param_requires_label = true);
(current_param_is_mutable = false);
(parameter_complete = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 59: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Anon>();
{
if ((parameter_complete && (!error))){
TRY((((*this).error(String("anon must appear at start of parameter declaration, not the end"),((((*this).current())).span())))));
(error = true);
}
if ((current_param_is_mutable && (!error))){
TRY((((*this).error(String("anon must appear before mut"),((((*this).current())).span())))));
(error = true);
}
if (((!current_param_requires_label) && (!error))){
TRY((((*this).error(String("anon cannot appear multiple times in one parameter declaration"),((((*this).current())).span())))));
(error = true);
}
(((*this).index)++);
(current_param_requires_label = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
{
if ((parameter_complete && (!error))){
TRY((((*this).error(String("mut must appear at start of parameter declaration, not the end"),((((*this).current())).span())))));
(error = true);
}
if ((current_param_is_mutable && (!error))){
TRY((((*this).error(String("mut cannot appear multiple times in one parameter declaration"),((((*this).current())).span())))));
(error = true);
}
(((*this).index)++);
(current_param_is_mutable = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
{
TRY((((params).push(parser::ParsedParameter(false,parser::ParsedVariable(String("this"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),current_param_is_mutable,((((*this).current())).span())),((((*this).current())).span()))))));
(((*this).index)++);
(parameter_complete = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const parser::ParsedVarDecl var_decl = TRY((((*this).parse_variable_declaration(current_param_is_mutable))));
TRY((((params).push(parser::ParsedParameter(current_param_requires_label,parser::ParsedVariable(((var_decl).name),((var_decl).parsed_type),((var_decl).is_mutable),((((*this).previous())).span())),((((*this).previous())).span()))))));
(parameter_complete = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!error)){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (params);
}
}

ErrorOr<Optional<parser::ParsedCall>> parser::Parser::parse_call() {
{
parser::ParsedCall call = parser::ParsedCall((TRY((Array<String>::create_with({})))),String(""),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({})))));
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(((call).name) = name);
(((*this).index)++);
const size_t index_reset = ((*this).index);
if ((((*this).current())).has<lexer::Token::LessThan>()){
(((*this).index)++);
Array<NonnullRefPtr<parser::ParsedType>> inner_types = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<parser::ParsedCall>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const size_t index_before = ((*this).index);
const NonnullRefPtr<parser::ParsedType> inner_type = TRY((((*this).parse_typename())));
if ((index_before == ((*this).index))){
(((*this).index) = index_reset);
return JaktInternal::LoopBreak{};
}
TRY((((inner_types).push(inner_type))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
(((call).type_args) = inner_types);
}
if ((((*this).current())).has<lexer::Token::LParen>()){
(((*this).index)++);
}
else {
(((*this).index) = index_reset);
TRY((((*this).error(String("Expected '('"),((((*this).current())).span())))));
return (JaktInternal::OptionalNone());
}

while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<parser::ParsedCall>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const utility::Span label_span = ((((*this).current())).span());
const String label = TRY((((*this).parse_argument_label())));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
TRY((((((call).args)).push((Tuple{label, label_span, expr})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (call);
}
else {
TRY((((*this).error(String("Expected function call"),((((*this).current())).span())))));
return (call);
}

}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_struct(const parser::DefinitionLinkage definition_linkage) {
{
parser::ParsedRecord parsed_struct = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
if ((((*this).current())).has<lexer::Token::Struct>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `struct` keyword"),((((*this).current())).span())))));
return (parsed_struct);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected name"),((((*this).current())).span())))));
return (parsed_struct);
}
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((*this).index)++);
(((parsed_struct).name) = name);
(((parsed_struct).name_span) = span);
}
else {
TRY((((*this).error(String("Incomplete struct definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected generic parameters or body"),((((*this).current())).span())))));
return (parsed_struct);
}
(((parsed_struct).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected body"),((((*this).current())).span())))));
return (parsed_struct);
}
const Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>> fields_methods = TRY((((*this).parse_struct_class_body(definition_linkage,typename parser::Visibility::Public(),false))));
(((parsed_struct).methods) = ((fields_methods).get<1>()));
(((parsed_struct).record_type) = typename parser::RecordType::Struct(((fields_methods).get<0>())));
return (parsed_struct);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_array_or_dictionary_literal() {
{
bool is_dictionary = false;
const utility::Span start = ((((*this).current())).span());
if ((!(((*this).current())).has<lexer::Token::LSquare>())){
TRY((((*this).error(String("Expected ["),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
(((*this).index)++);
Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size_expr = JaktInternal::OptionalNone();
Array<NonnullRefPtr<parser::ParsedExpression>> output = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> dict_output = (TRY((Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>>::create_with({}))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
if ((((output).size()) == static_cast<size_t>(1ULL))){
(((*this).index)++);
(fill_size_expr = TRY((((*this).parse_expression(false,false)))));
}
else {
TRY((((*this).error(String("Can't fill an Array with more than one expression"),((((*this).current())).span())))));
(((*this).index)++);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Colon>();
{
(((*this).index)++);
if (((dict_output).is_empty())){
if ((((*this).current())).has<lexer::Token::RSquare>()){
(((*this).index)++);
(is_dictionary = true);
return JaktInternal::LoopBreak{};
}
else {
TRY((((*this).error(String("Expected ]"),((((*this).current())).span())))));
}

}
else {
TRY((((*this).error(String("Missing key in dictionary literal"),((((*this).current())).span())))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if ((expr)->has<parser::ParsedExpression::Garbage>()){
return JaktInternal::LoopBreak{};
}
if ((((*this).current())).has<lexer::Token::Colon>()){
if ((!((output).is_empty()))){
TRY((((*this).error(String("Mixing dictionary and array values"),((((*this).current())).span())))));
}
(is_dictionary = true);
(((*this).index)++);
if (((*this).eof())){
TRY((((*this).error(String("Key missing value in dictionary"),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
const NonnullRefPtr<parser::ParsedExpression> value = TRY((((*this).parse_expression(false,false))));
TRY((((dict_output).push((Tuple{expr, value})))));
}
else if ((!is_dictionary)){
TRY((((output).push(expr))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const size_t end = (JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)));
if (((end >= ((((*this).tokens)).size())) || (!(((((*this).tokens))[end])).has<lexer::Token::RSquare>()))){
TRY((((*this).error(String("Expected ] to close the array"),((((((*this).tokens))[end])).span())))));
}
if (is_dictionary){
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktDictionary>(dict_output,parser::merge_spans(start,((((((*this).tokens))[end])).span()))))));
}
else {
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktArray>(output,fill_size_expr,parser::merge_spans(start,((((((*this).tokens))[end])).span()))))));
}

}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand() {
{
((*this).skip_newlines());
const utility::Span start = ((((*this).current())).span());
((*this).skip_newlines());
NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand_base())));
return (TRY((((*this).parse_operand_postfix_operator(start,expr)))));
}
}

void parser::Parser::skip_newlines() {
{
while ((((*this).current())).has<lexer::Token::Eol>()){
(((*this).index)++);
}
}
}

bool parser::Parser::eol() const {
{
return ((((*this).eof()) || (((((*this).tokens))[((*this).index)])).has<lexer::Token::Eol>()));
}
}

ErrorOr<parser::ParsedMatchPattern> parser::Parser::parse_match_pattern() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedMatchPattern, ErrorOr<parser::ParsedMatchPattern>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 94: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 68: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Else>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_57; {
(((*this).index)++);
__jakt_var_57 = typename parser::ParsedMatchPattern::CatchAll(); goto __jakt_label_57;

}
__jakt_label_57:; __jakt_var_57.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_58; {
const size_t pattern_start_index = ((*this).index);
Array<Tuple<String,utility::Span>> variant_name = (TRY((Array<Tuple<String,utility::Span>>::create_with({}))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedMatchPattern>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
(((*this).index)++);
TRY((((variant_name).push((Tuple{name, ((((*this).current())).span())})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
Array<parser::EnumVariantPatternArgument> variant_arguments = TRY((((*this).parse_variant_arguments())));
const utility::Span arguments_start = ((((*this).current())).span());
const utility::Span arguments_end = ((((*this).previous())).span());
const utility::Span arguments_span = parser::merge_spans(arguments_start,arguments_end);
__jakt_var_58 = typename parser::ParsedMatchPattern::EnumVariant(variant_name,variant_arguments,arguments_span); goto __jakt_label_58;

}
__jakt_label_58:; __jakt_var_58.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_59; {
TRY((((*this).error(String("Expected pattern or else"),((((*this).current())).span())))));
__jakt_var_59 = typename parser::ParsedMatchPattern::CatchAll(); goto __jakt_label_59;

}
__jakt_label_59:; __jakt_var_59.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_lambda() {
{
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const Array<parser::ParsedCapture> captures = TRY((((*this).parse_captures())));
const Array<parser::ParsedParameter> params = TRY((((*this).parse_function_parameters())));
const bool can_throw = (((*this).current())).has<lexer::Token::Throws>();
if (can_throw){
(((*this).index)++);
}
NonnullRefPtr<parser::ParsedType> return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 57: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Arrow>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_60; {
(((*this).index)++);
__jakt_var_60 = TRY((((*this).parse_typename()))); goto __jakt_label_60;

}
__jakt_label_60:; __jakt_var_60.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
};/*case end*/
}/*switch end*/
}()
));
const parser::ParsedBlock block = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedBlock, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 56: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::FatArrow>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedBlock> __jakt_var_61; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(true,false))));
const utility::Span span = ((expr)->span());
__jakt_var_61 = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(expr,span)))}))))); goto __jakt_label_61;

}
__jakt_label_61:; __jakt_var_61.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).parse_block()))));
};/*case end*/
}/*switch end*/
}()
));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Function>(captures,params,can_throw,return_type,block,parser::merge_spans(start,((((*this).current())).span()))))));
}
}

ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>> parser::Parser::parse_struct_class_body(const parser::DefinitionLinkage definition_linkage,const parser::Visibility default_visibility,const bool is_class) {
{
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
}

Array<parser::ParsedField> fields = (TRY((Array<parser::ParsedField>::create_with({}))));
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
bool error = false;
while ((!((*this).eof()))){
const lexer::Token token = ((*this).current());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = token;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
if (((last_visibility).has_value())){
TRY((((*this).error(String("Expected function or parameter after visibility modifier"),((token).span())))));
}
(((*this).index)++);
return ((Tuple{fields, methods}));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 89: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Restricted>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = TRY((((*this).parse_restricted_visibility_modifier()))));
(last_visibility_span = span);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return default_visibility; });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedField field = TRY((((*this).parse_field(visibility))));
TRY((((fields).push(field))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return default_visibility; });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!error)){
TRY((((*this).error(TRY((String::formatted(String("Invalid member, did not expect a {} here"),token))),((token).span())))));
(error = true);
}
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (is_class){
TRY((((*this).error(String("Incomplete class body, expected }"),((((*this).current())).span())))));
}
else {
TRY((((*this).error(String("Incomplete struct body, expected }"),((((*this).current())).span())))));
}

return ((Tuple{fields, methods}));
}
}

ErrorOr<parser::ParsedExternImport> parser::Parser::parse_extern_import() {
{
parser::ParsedExternImport parsed_import = parser::ParsedExternImport(false,parser::ParsedNamespace(JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),(TRY((Array<parser::ParsedFunction>::create_with({})))),(TRY((Array<parser::ParsedRecord>::create_with({})))),(TRY((Array<parser::ParsedNamespace>::create_with({})))),(TRY((Array<parser::ParsedModuleImport>::create_with({})))),(TRY((Array<parser::ParsedExternImport>::create_with({})))),JaktInternal::OptionalNone()));
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((*this).index)++);
if (((name == String("c")) || (name == String("C")))){
(((parsed_import).is_c) = true);
}
else {
TRY((((*this).error(String("Expected 'c' or path after `import extern`"),((((*this).current())).span())))));
}

}
const String import_path = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<parser::ParsedExternImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_62; {
(((*this).index)++);
__jakt_var_62 = quote; goto __jakt_label_62;

}
__jakt_label_62:; __jakt_var_62.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_63; {
TRY((((*this).error(String("Expected path after `import extern`"),((((*this).current())).span())))));
__jakt_var_63 = String(""); goto __jakt_label_63;

}
__jakt_label_63:; __jakt_var_63.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
if ((((*this).current())).has<lexer::Token::As>()){
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((*this).index)++);
(((((parsed_import).assigned_namespace)).name) = name);
(((((parsed_import).assigned_namespace)).name_span) = span);
}
else {
TRY((((*this).error(String("Expected name after 'as' keyword to name the extern import"),((((*this).current())).span())))));
}

}
if ((!(((*this).current())).has<lexer::Token::LCurly>())){
TRY((((*this).error(String("Expected '{' to start namespace for the extern import"),((((*this).current())).span())))));
}
(((*this).index)++);
(((parsed_import).assigned_namespace) = TRY((((*this).parse_namespace()))));
(((((parsed_import).assigned_namespace)).import_path_if_extern) = (import_path));
if ((((*this).current())).has<lexer::Token::RCurly>()){
(((*this).index)++);
}
return (parsed_import);
}
}

ErrorOr<Array<parser::EnumVariantPatternArgument>> parser::Parser::parse_variant_arguments() {
{
Array<parser::EnumVariantPatternArgument> variant_arguments = (TRY((Array<parser::EnumVariantPatternArgument>::create_with({}))));
bool has_parens = false;
if ((((*this).current())).has<lexer::Token::LParen>()){
(has_parens = true);
(((*this).index)++);
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::EnumVariantPatternArgument>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& arg_name = __jakt_match_value.name;
{
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::Colon>()){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String arg_binding = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = ((((*this).current())).span());
(((*this).index)++);
TRY((((variant_arguments).push(parser::EnumVariantPatternArgument((arg_name),arg_binding,span)))));
}
else {
TRY((((*this).error(String("Expected binding after :"),((((*this).current())).span())))));
}

}
else {
TRY((((variant_arguments).push(parser::EnumVariantPatternArgument(JaktInternal::OptionalNone(),arg_name,((((*this).current())).span()))))));
(((*this).index)++);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected pattern argument name"),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
}
return (variant_arguments);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_set_literal() {
{
const utility::Span start = ((((*this).current())).span());
if ((!(((*this).current())).has<lexer::Token::LCurly>())){
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
(((*this).index)++);
Array<NonnullRefPtr<parser::ParsedExpression>> output = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if ((expr)->has<parser::ParsedExpression::Garbage>()){
return JaktInternal::LoopBreak{};
}
TRY((((output).push(expr))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const size_t end = (JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)));
if (((end >= ((((*this).tokens)).size())) || (!(((((*this).tokens))[end])).has<lexer::Token::RCurly>()))){
TRY((((*this).error(String("Expected } to close the set"),((((((*this).tokens))[end])).span())))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Set>(output,parser::merge_spans(start,((((((*this).tokens))[end])).span()))))));
}
}

ErrorOr<parser::ParsedNamespace> parser::Parser::parse_namespace() {
{
parser::ParsedNamespace parsed_namespace = parser::ParsedNamespace(JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),(TRY((Array<parser::ParsedFunction>::create_with({})))),(TRY((Array<parser::ParsedRecord>::create_with({})))),(TRY((Array<parser::ParsedNamespace>::create_with({})))),(TRY((Array<parser::ParsedModuleImport>::create_with({})))),(TRY((Array<parser::ParsedExternImport>::create_with({})))),JaktInternal::OptionalNone());
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 75: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Import>();
{
(((*this).index)++);
TRY((((*this).parse_import(parsed_namespace))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::ParsedFunction parsed_function = TRY((((*this).parse_function(typename parser::FunctionLinkage::Internal(),typename parser::Visibility::Public()))));
TRY((((((parsed_namespace).functions)).push(parsed_function))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Namespace>();
{
(((*this).index)++);
const Optional<Tuple<String,utility::Span>> name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<Tuple<String,utility::Span>>, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<Tuple<String,utility::Span>>> __jakt_var_64; {
(((*this).index)++);
__jakt_var_64 = ((Tuple{name, span})); goto __jakt_label_64;

}
__jakt_label_64:; __jakt_var_64.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Optional<Tuple<String,utility::Span>>> __jakt_var_65; {
const Optional<Tuple<String,utility::Span>> tuple_none = JaktInternal::OptionalNone();
__jakt_var_65 = tuple_none; goto __jakt_label_65;

}
__jakt_label_65:; __jakt_var_65.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
}

parser::ParsedNamespace namespace_ = TRY((((*this).parse_namespace())));
if ((((*this).current())).has<lexer::Token::RCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Incomplete namespace"),((((*this).previous())).span())))));
}

if (((name).has_value())){
(((namespace_).name) = (((name.value())).get<0>()));
(((namespace_).name_span) = (((name.value())).get<1>()));
}
TRY((((parsed_namespace).add_child_namespace(namespace_))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 70: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Extern>();
{
(((*this).index)++);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::ParsedFunction parsed_function = TRY((((*this).parse_function(typename parser::FunctionLinkage::External(),typename parser::Visibility::Public()))));
TRY((((((parsed_namespace).functions)).push(parsed_function))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
{
const parser::ParsedRecord parsed_struct = TRY((((*this).parse_struct(typename parser::DefinitionLinkage::External()))));
TRY((((((parsed_namespace).records)).push(parsed_struct))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
{
const parser::ParsedRecord parsed_class = TRY((((*this).parse_class(typename parser::DefinitionLinkage::External()))));
TRY((((((parsed_namespace).records)).push(parsed_class))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Unexpected keyword"),((((*this).current())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Unexpected token (expected keyword)"),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (parsed_namespace);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_ampersand() {
{
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Raw>()){
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::RawAddress(),parser::merge_spans(start,((expr)->span()))))));
}
if ((((*this).current())).has<lexer::Token::Mut>()){
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::MutableReference(),parser::merge_spans(start,((expr)->span()))))));
}
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Reference(),parser::merge_spans(start,((expr)->span()))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_asterisk() {
{
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Dereference(),parser::merge_spans(start,((((*this).current())).span()))))));
}
}

ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>> parser::Parser::parse_sum_enum_body(const parser::ParsedRecord partial_enum,const parser::DefinitionLinkage definition_linkage,const bool is_boxed) {
{
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Array<parser::SumEnumVariant> variants = (TRY((Array<parser::SumEnumVariant>::create_with({}))));
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `{` to start the enum body"),((((*this).current())).span())))));
}

((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected variant name"),((((*this).previous())).span())))));
return ((Tuple{variants, methods}));
}
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::LParen>()){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
Array<parser::ParsedVarDecl> var_decls = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
while ((!((*this).eof()))){
if ((((*this).peek(static_cast<size_t>(1ULL)))).has<lexer::Token::Colon>()){
parser::ParsedVarDecl var_decl = TRY((((*this).parse_variable_declaration(false))));
if ((((var_decl).parsed_type))->has<parser::ParsedType::Name>()){
const String name = (((var_decl).parsed_type)->get<parser::ParsedType::Name>()).name;
const utility::Span span = (((var_decl).parsed_type)->get<parser::ParsedType::Name>()).span;
(((var_decl).inlay_span) = span);
if (((name == ((partial_enum).name)) && (!is_boxed))){
TRY((((*this).error(String("use 'boxed enum' to make the enum recursive"),((var_decl).span)))));
}
}
TRY((((var_decls).push(var_decl))));
continue;
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Incomplete enum variant defintion, expected `,` or `)`; got `{}`"),((*this).current())))),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((variants).push(parser::SumEnumVariant(name,span,var_decls)))));
}
else {
(((*this).index)++);
TRY((((variants).push(parser::SumEnumVariant(name,span,JaktInternal::OptionalNone())))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected identifier or the end of enum block"),((((*this).current())).span())))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if ((!(((*this).current())).has<lexer::Token::RCurly>())){
TRY((((*this).error(String("Invalid enum definition, expected `}`"),((((*this).current())).span())))));
return ((Tuple{variants, methods}));
}
(((*this).index)++);
if (((variants).is_empty())){
TRY((((*this).error(String("Empty enums are not allowed"),((partial_enum).name_span)))));
}
return ((Tuple{variants, methods}));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_tuple() {
{
const utility::Span start = ((((*this).current())).span());
(((*this).index)++);
Array<NonnullRefPtr<parser::ParsedType>> types = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
while ((!((*this).eof()))){
if ((((*this).current())).has<lexer::Token::RParen>()){
(((*this).index)++);
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::JaktTuple>(types,parser::merge_spans(start,((((*this).previous())).span()))))));
}
if ((((*this).current())).has<lexer::Token::Comma>()){
(((*this).index)++);
}
const size_t index_before = ((*this).index);
const NonnullRefPtr<parser::ParsedType> type = TRY((((*this).parse_typename())));
const size_t index_after = ((*this).index);
if ((index_before == index_after)){
break;
}
TRY((((types).push(type))));
}
TRY((((*this).error(String("Expected )"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<Array<parser::ParsedCapture>> parser::Parser::parse_captures() {
{
Array<parser::ParsedCapture> captures = (TRY((Array<parser::ParsedCapture>::create_with({}))));
if ((((*this).current())).has<lexer::Token::LSquare>()){
(((*this).index)++);
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedCapture>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
{
(((*this).index)++);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
{
(((*this).index)++);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedCapture>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
{
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
TRY((((captures).push(typename parser::ParsedCapture::ByMutableReference(name,((((*this).current())).span()))))));
(((*this).index)++);
}
else {
TRY((((*this).error(TRY((String::formatted(String("Expected identifier, got '{}'"),((*this).current())))),((((*this).current())).span())))));
(((*this).index)++);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
TRY((((captures).push(typename parser::ParsedCapture::ByReference(name,((((*this).current())).span()))))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Expected identifier or mut, got '{}'"),((*this).current())))),((((*this).current())).span())))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
TRY((((captures).push(typename parser::ParsedCapture::ByValue(name,((((*this).current())).span()))))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unexpected token '{}' in captures list"),((*this).current())))),((((*this).current())).span())))));
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (captures);
}
else {
return ((TRY((Array<parser::ParsedCapture>::create_with({})))));
}

}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_postfix_colon_colon(const utility::Span start,const NonnullRefPtr<parser::ParsedExpression> expr) {
{
(((*this).index)++);
Array<String> namespace_ = (TRY((Array<String>::create_with({}))));
if ((expr)->has<parser::ParsedExpression::Var>()){
const String name = (expr->get<parser::ParsedExpression::Var>()).name;
TRY((((namespace_).push(name))));
}
else {
TRY((((*this).error(String("Expected namespace"),((expr)->span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete static method call"),((((*this).current())).span())))));
}
while ((!((*this).eof()))){
const String current_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: {
{
TRY((((*this).error(String("Unsupported static method call"),((((*this).current())).span())))));
return (expr);
}
};/*case end*/
}/*switch end*/
}()
));
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::LParen>()){
(((*this).index)--);
Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
((((call.value())).namespace_) = namespace_);
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),parser::merge_spans(((expr)->span()),((((*this).current())).span()))))));
}
if ((((*this).current())).has<lexer::Token::ColonColon>()){
if ((((*this).previous())).has<lexer::Token::Identifier>()){
const String name = (((*this).previous()).get<lexer::Token::Identifier>()).name;
TRY((((namespace_).push(name))));
}
else {
TRY((((*this).error(String("Expected namespace"),((expr)->span())))));
}

(((*this).index)++);
continue;
}
if ((((*this).current())).has<lexer::Token::LessThan>()){
(((*this).index)--);
const Optional<parser::ParsedCall> maybe_call = TRY((((*this).parse_call())));
if (((maybe_call).has_value())){
parser::ParsedCall call = (maybe_call.value());
(((call).namespace_) = namespace_);
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>(call,parser::merge_spans(((expr)->span()),((((*this).current())).span()))))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NamespacedVar>(current_name,namespace_,parser::merge_spans(start,((((*this).current())).span()))))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
}

ErrorOr<void> parser::Parser::parse_import(parser::ParsedNamespace parent) {
{
if ((((*this).current())).has<lexer::Token::Extern>()){
(((*this).index)++);
TRY((((parent).add_extern_import(TRY((((*this).parse_extern_import())))))));
}
else {
TRY((((parent).add_module_import(TRY((((*this).parse_module_import())))))));
}

}
return {};
}

ErrorOr<Array<parser::ParsedMatchCase>> parser::Parser::parse_match_cases() {
{
Array<parser::ParsedMatchCase> cases = (TRY((Array<parser::ParsedMatchCase>::create_with({}))));
((*this).skip_newlines());
if ((!(((*this).current())).has<lexer::Token::LCurly>())){
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
return (cases);
}
(((*this).index)++);
((*this).skip_newlines());
while (((!((*this).eof())) && (!(((*this).current())).has<lexer::Token::RCurly>()))){
const size_t pattern_start_index = ((*this).index);
const Array<parser::ParsedMatchPattern> patterns = TRY((((*this).parse_match_patterns())));
((*this).skip_newlines());
const utility::Span marker_span = ((((*this).current())).span());
if ((((*this).current())).has<lexer::Token::FatArrow>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected =>"),((((*this).current())).span())))));
}

((*this).skip_newlines());
const parser::ParsedMatchBody body = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedMatchBody, ErrorOr<Array<parser::ParsedMatchCase>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchBody::Block(TRY((((*this).parse_block())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename parser::ParsedMatchBody::Expression(TRY((((*this).parse_expression(false,false))))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((patterns).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
TRY((((cases).push(parser::ParsedMatchCase((TRY((Array<parser::ParsedMatchPattern>::create_with({pattern})))),marker_span,body)))));
}

}
}

if ((((*this).index) == pattern_start_index)){
break;
}
if (((((*this).current())).has<lexer::Token::Eol>() || (((*this).current())).has<lexer::Token::Comma>())){
(((*this).index)++);
}
((*this).skip_newlines());
}
((*this).skip_newlines());
if ((!(((*this).current())).has<lexer::Token::RCurly>())){
TRY((((*this).error(String("Expected }"),((((*this).current())).span())))));
}
(((*this).index)++);
return (cases);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_set() {
{
const utility::Span start = ((((*this).current())).span());
if ((((*this).current())).has<lexer::Token::LCurly>()){
(((*this).index)++);
}
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
if ((((*this).current())).has<lexer::Token::RCurly>()){
(((*this).index)++);
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Set>(inner,parser::merge_spans(start,((((*this).current())).span()))))));
}
TRY((((*this).error(String("Expected '}'"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_guard_statement() {
{
const utility::Span span = ((((*this).current())).span());
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,true))));
if ((((*this).current())).has<lexer::Token::Else>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `else` keyword"),((((*this).current())).span())))));
}

const parser::ParsedBlock else_block = TRY((((*this).parse_block())));
parser::ParsedBlock remaining_code = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({})))));
while ((!((*this).eof()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Guard>(expr,else_block,remaining_code,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((remaining_code).stmts)).push(TRY((((*this).parse_statement(true))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Guard>(expr,else_block,remaining_code,span))));
}
}

ErrorOr<parser::ParsedVarDecl> parser::Parser::parse_variable_declaration(const bool is_mutable) {
{
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = ((((*this).current())).span());
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::Colon>()){
(((*this).index)++);
}
else {
return (parser::ParsedVarDecl(name,TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,span,span));
}

const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
if ((is_mutable && ((parsed_type)->has<parser::ParsedType::Reference>() || (parsed_type)->has<parser::ParsedType::MutableReference>()))){
TRY((((*this).error(String("Reference parameter can not be mutable"),span))));
}
return (parser::ParsedVarDecl(name,parsed_type,is_mutable,JaktInternal::OptionalNone(),span));
}
return (parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),((((*this).current())).span())));
}
}

lexer::Token parser::Parser::current() const {
{
return (((*this).peek(static_cast<size_t>(0ULL))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_expression(const bool allow_assignments,const bool allow_newlines) {
{
Array<NonnullRefPtr<parser::ParsedExpression>> expr_stack = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
i64 last_precedence = static_cast<i64>(1000000LL);
const NonnullRefPtr<parser::ParsedExpression> lhs = TRY((((*this).parse_operand())));
TRY((((expr_stack).push(lhs))));
for (;;){
if (allow_newlines){
if ((((*this).eof()) || (((*this).current())).has<lexer::Token::LCurly>())){
break;
}
((*this).skip_newlines());
}
else {
if (((*this).eol())){
break;
}
}

const NonnullRefPtr<parser::ParsedExpression> parsed_operator = TRY((((*this).parse_operator(allow_assignments))));
if ((parsed_operator)->has<parser::ParsedExpression::Garbage>()){
break;
}
const i64 precedence = ((parsed_operator)->precedence());
((*this).skip_newlines());
const NonnullRefPtr<parser::ParsedExpression> rhs = TRY((((*this).parse_operand())));
while (((precedence <= last_precedence) && (((expr_stack).size()) > static_cast<size_t>(1ULL)))){
const NonnullRefPtr<parser::ParsedExpression> rhs = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> op = (((expr_stack).pop()).value());
(last_precedence = ((op)->precedence()));
if ((last_precedence < precedence)){
TRY((((expr_stack).push(op))));
TRY((((expr_stack).push(rhs))));
break;
}
const NonnullRefPtr<parser::ParsedExpression> lhs = (((expr_stack).pop()).value());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = *op;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
{
const utility::Span new_span = parser::merge_spans(((lhs)->span()),((rhs)->span()));
TRY((((expr_stack).push(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(lhs,op,rhs,new_span)))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("operator is not an operator")))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((expr_stack).push(parsed_operator))));
TRY((((expr_stack).push(rhs))));
(last_precedence = precedence);
}
while ((((expr_stack).size()) > static_cast<size_t>(1ULL))){
const NonnullRefPtr<parser::ParsedExpression> rhs = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> parsed_operator = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> lhs = (((expr_stack).pop()).value());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = *parsed_operator;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
{
const utility::Span new_span = parser::merge_spans(((lhs)->span()),((rhs)->span()));
TRY((((expr_stack).push(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(lhs,op,rhs,new_span)))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("operator is not an operator")))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (((expr_stack)[static_cast<i64>(0LL)]));
}
}

ErrorOr<parser::Visibility> parser::Parser::parse_restricted_visibility_modifier() {
{
utility::Span restricted_span = ((((*this).current())).span());
(((*this).index)++);
if ((((*this).current())).has<lexer::Token::LParen>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected ("),((((*this).current())).span())))));
}

Array<NonnullRefPtr<parser::ParsedType>> whitelist = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
bool expect_comma = false;
while ((((*this).index) < ((((*this).tokens)).size()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::Visibility>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
utility::Span const& span = __jakt_match_value.value;
{
if (expect_comma){
(expect_comma = false);
}
else {
TRY((((*this).error(String("Unexpected comma"),span))));
}

(((*this).index)++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if (expect_comma){
TRY((((*this).error(String("Expected comma"),((((*this).current())).span())))));
}
((*this).skip_newlines());
const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
TRY((((whitelist).push(parsed_type))));
(expect_comma = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
(((restricted_span).end) = ((((((*this).current())).span())).end));
if (((whitelist).is_empty())){
TRY((((*this).error(String("Type list cannot be empty"),restricted_span))));
}
if ((((*this).current())).has<lexer::Token::RParen>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected )"),((((*this).current())).span())))));
}

return (typename parser::Visibility::Restricted(whitelist,restricted_span));
}
}

lexer::Token parser::Parser::peek(const size_t steps) const {
{
if ((((*this).eof()) || ((JaktInternal::checked_add<size_t>(steps,((*this).index))) >= ((((*this).tokens)).size())))){
return ((((((*this).tokens)).last()).value()));
}
return (((((*this).tokens))[(JaktInternal::checked_add<size_t>(((*this).index),steps))]));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_record(const parser::DefinitionLinkage definition_linkage) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedRecord, ErrorOr<parser::ParsedRecord>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_struct(definition_linkage)))));
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_class(definition_linkage)))));
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_enum(definition_linkage,false)))));
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedRecord> __jakt_var_66; {
(((*this).index)++);
__jakt_var_66 = TRY((((*this).parse_enum(definition_linkage,true)))); goto __jakt_label_66;

}
__jakt_label_66:; __jakt_var_66.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedRecord> __jakt_var_67; {
TRY((((*this).error(String("Expected `struct`, `class`, `enum`, or `boxed`"),((((*this).current())).span())))));
__jakt_var_67 = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage()); goto __jakt_label_67;

}
__jakt_label_67:; __jakt_var_67.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_array_or_dictionary()))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_set()))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_tuple()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
};/*case end*/
}/*switch end*/
}()
)));
}
}

utility::Span parser::Parser::empty_span() const {
{
return (((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))));
}
}

ErrorOr<Array<parser::ParsedMatchPattern>> parser::Parser::parse_match_patterns() {
{
Array<parser::ParsedMatchPattern> patterns = (TRY((Array<parser::ParsedMatchPattern>::create_with({}))));
((*this).skip_newlines());
while ((!((*this).eof()))){
const parser::ParsedMatchPattern pattern = TRY((((*this).parse_match_pattern())));
TRY((((patterns).push(pattern))));
((*this).skip_newlines());
if ((((*this).current())).has<lexer::Token::Pipe>()){
(((*this).index)++);
continue;
}
break;
}
return (patterns);
}
}

lexer::Token parser::Parser::previous() const {
{
if (((((*this).index) == static_cast<size_t>(0ULL)) || (((*this).index) > ((((*this).tokens)).size())))){
return (typename lexer::Token::Eof(((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)))));
}
return (((((*this).tokens))[(JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)))]));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand_postfix_operator(const utility::Span start,const NonnullRefPtr<parser::ParsedExpression> expr) {
{
NonnullRefPtr<parser::ParsedExpression> result = expr;
for (;;){
(result = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 53: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DotDot>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_68; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> to = TRY((((*this).parse_expression(false,false))));
__jakt_var_68 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Range>(result,to,parser::merge_spans(start,((to)->span()))))); goto __jakt_label_68;

}
__jakt_label_68:; __jakt_var_68.release_value(); }));
};/*case end*/
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_69; {
(((*this).index)++);
__jakt_var_69 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::ForcedUnwrap>(result,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_69;

}
__jakt_label_69:; __jakt_var_69.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_70; {
(((*this).index)++);
__jakt_var_70 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::PostIncrement(),parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_70;

}
__jakt_label_70:; __jakt_var_70.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_71; {
(((*this).index)++);
__jakt_var_71 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::PostDecrement(),parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_71;

}
__jakt_label_71:; __jakt_var_71.release_value(); }));
};/*case end*/
case 60: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::As>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_72; {
(((*this).index)++);
const utility::Span cast_span = parser::merge_spans(((((*this).previous())).span()),((((*this).current())).span()));
const parser::TypeCast cast = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::TypeCast, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_73; {
(((*this).index)++);
__jakt_var_73 = typename parser::TypeCast::Infallible(TRY((((*this).parse_typename())))); goto __jakt_label_73;

}
__jakt_label_73:; __jakt_var_73.release_value(); }));
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_74; {
(((*this).index)++);
__jakt_var_74 = typename parser::TypeCast::Fallible(TRY((((*this).parse_typename())))); goto __jakt_label_74;

}
__jakt_label_74:; __jakt_var_74.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_75; {
TRY((((*this).error(String("Invalid cast syntax"),cast_span))));
__jakt_var_75 = typename parser::TypeCast::Fallible(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>()))); goto __jakt_label_75;

}
__jakt_label_75:; __jakt_var_75.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
const utility::Span span = parser::merge_spans(start,parser::merge_spans(cast_span,((((*this).current())).span())));
__jakt_var_72 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::TypeCast(cast),span))); goto __jakt_label_72;

}
__jakt_label_72:; __jakt_var_72.release_value(); }));
};/*case end*/
case 77: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Is>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_76; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
const utility::Span span = parser::merge_spans(start,((((*this).current())).span()));
Array<parser::EnumVariantPatternArgument> bindings = (TRY((Array<parser::EnumVariantPatternArgument>::create_with({}))));
Optional<NonnullRefPtr<parser::ParsedExpression>> unary_operator_is = JaktInternal::OptionalNone();
if (((((*this).current())).has<lexer::Token::LParen>() && ((parsed_type)->has<parser::ParsedType::NamespacedName>() || (parsed_type)->has<parser::ParsedType::Name>()))){
(bindings = TRY((((*this).parse_variant_arguments()))));
(unary_operator_is = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::IsEnumVariant(parsed_type,bindings),span))));
}
else {
(unary_operator_is = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::Is(parsed_type),span))));
}

__jakt_var_76 = (unary_operator_is.value()); goto __jakt_label_76;

}
__jakt_label_76:; __jakt_var_76.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_postfix_colon_colon(start,result)))));
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_77; {
const bool is_optional = (((*this).current())).has<lexer::Token::QuestionMark>();
if (is_optional){
(((*this).index)++);
if ((!(((*this).current())).has<lexer::Token::Dot>())){
TRY((((*this).error(String("Expected . after ? for optional chaining access"),((((*this).current())).span())))));
}
}
(((*this).index)++);
__jakt_var_77 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_78; {
(((*this).index)++);
const size_t num = ((number).to_usize());
__jakt_var_78 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(result,num,is_optional,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_78;

}
__jakt_label_78:; __jakt_var_78.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_79; {
(((*this).index)++);
__jakt_var_79 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_80; {
(((*this).index)--);
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
__jakt_var_80 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(result,(call.value()),is_optional,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_80;

}
__jakt_label_80:; __jakt_var_80.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedStruct>(result,name,is_optional,parser::merge_spans(start,((((*this).current())).span()))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_79;

}
__jakt_label_79:; __jakt_var_79.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_81; {
TRY((((*this).error(String("Unsupported dot operation"),((((*this).current())).span())))));
(((*this).index)++);
__jakt_var_81 = result; goto __jakt_label_81;

}
__jakt_label_81:; __jakt_var_81.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_77;

}
__jakt_label_77:; __jakt_var_77.release_value(); }));
};/*case end*/
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_82; {
const bool is_optional = (((*this).current())).has<lexer::Token::QuestionMark>();
if (is_optional){
(((*this).index)++);
if ((!(((*this).current())).has<lexer::Token::Dot>())){
TRY((((*this).error(String("Expected . after ? for optional chaining access"),((((*this).current())).span())))));
}
}
(((*this).index)++);
__jakt_var_82 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_83; {
(((*this).index)++);
const size_t num = ((number).to_usize());
__jakt_var_83 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(result,num,is_optional,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_83;

}
__jakt_label_83:; __jakt_var_83.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_84; {
(((*this).index)++);
__jakt_var_84 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_85; {
(((*this).index)--);
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
__jakt_var_85 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(result,(call.value()),is_optional,parser::merge_spans(start,((((*this).previous())).span()))))); goto __jakt_label_85;

}
__jakt_label_85:; __jakt_var_85.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedStruct>(result,name,is_optional,parser::merge_spans(start,((((*this).current())).span()))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_84;

}
__jakt_label_84:; __jakt_var_84.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_86; {
TRY((((*this).error(String("Unsupported dot operation"),((((*this).current())).span())))));
(((*this).index)++);
__jakt_var_86 = result; goto __jakt_label_86;

}
__jakt_label_86:; __jakt_var_86.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_82;

}
__jakt_label_82:; __jakt_var_82.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_87; {
(((*this).index)++);
const NonnullRefPtr<parser::ParsedExpression> index_expr = TRY((((*this).parse_expression(false,false))));
if ((((*this).current())).has<lexer::Token::RSquare>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected ']'"),((((*this).current())).span())))));
}

__jakt_var_87 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedExpression>(result,index_expr,parser::merge_spans(start,((((*this).current())).span()))))); goto __jakt_label_87;

}
__jakt_label_87:; __jakt_var_87.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_88; {
return JaktInternal::LoopBreak{};
__jakt_var_88 = result; goto __jakt_label_88;

}
__jakt_label_88:; __jakt_var_88.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
return (result);
}
}

ErrorOr<Array<parser::ParsedGenericParameter>> parser::Parser::parse_generic_parameters() {
{
if ((!(((*this).current())).has<lexer::Token::LessThan>())){
return ((TRY((Array<parser::ParsedGenericParameter>::create_with({})))));
}
(((*this).index)++);
Array<parser::ParsedGenericParameter> generic_parameters = (TRY((Array<parser::ParsedGenericParameter>::create_with({}))));
((*this).skip_newlines());
while (((!(((*this).current())).has<lexer::Token::GreaterThan>()) && (!(((*this).current())).has<lexer::Token::Garbage>()))){
if ((((*this).current())).has<lexer::Token::Identifier>()){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
TRY((((generic_parameters).push(parser::ParsedGenericParameter(name,span)))));
(((*this).index)++);
if (((((*this).current())).has<lexer::Token::Comma>() || (((*this).current())).has<lexer::Token::Eol>())){
(((*this).index)++);
}
}
else {
TRY((((*this).error(String("Expected generic parameter name"),((((*this).current())).span())))));
return (generic_parameters);
}

}
if ((((*this).current())).has<lexer::Token::GreaterThan>()){
(((*this).index)++);
}
else {
TRY((((*this).error(String("Expected `>` to end the generic parameters"),((((*this).current())).span())))));
return (generic_parameters);
}

return (generic_parameters);
}
}

ErrorOr<void> parser::ParsedNamespace::add_child_namespace(const parser::ParsedNamespace namespace_) {
{
{
ArrayIterator<parser::ParsedNamespace> _magic = ((((*this).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedNamespace child_namespace = (_magic_value.value());
{
if (((child_namespace).is_equivalent_to(namespace_))){
TRY((((child_namespace).merge_with(namespace_))));
return {};
}
}

}
}

TRY((((((*this).namespaces)).push(namespace_))));
}
return {};
}

bool parser::ParsedNamespace::is_equivalent_to(const parser::ParsedNamespace other) const {
{
return (((((*this).name) == ((other).name)) && (((*this).import_path_if_extern) == ((other).import_path_if_extern))));
}
}

ErrorOr<void> parser::ParsedNamespace::add_extern_import(const parser::ParsedExternImport import_) {
{
{
ArrayIterator<parser::ParsedExternImport> _magic = ((((*this).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
if (TRY((((extern_import).is_equivalent_to(import_))))){
TRY((((((extern_import).assigned_namespace)).merge_with(((import_).assigned_namespace)))));
return {};
}
}

}
}

TRY((((((*this).extern_imports)).push(import_))));
}
return {};
}

ErrorOr<void> parser::ParsedNamespace::merge_with(const parser::ParsedNamespace namespace_) {
{
TRY((utility::extend_array<parser::ParsedFunction>(((*this).functions),((namespace_).functions))));
TRY((utility::extend_array<parser::ParsedRecord>(((*this).records),((namespace_).records))));
TRY((((((*this).module_imports)).add_capacity(((((namespace_).module_imports)).size())))));
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((namespace_).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedModuleImport import_ = (_magic_value.value());
{
TRY((((*this).add_module_import(import_))));
}

}
}

TRY((((((*this).extern_imports)).add_capacity(((((namespace_).extern_imports)).size())))));
{
ArrayIterator<parser::ParsedExternImport> _magic = ((((namespace_).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedExternImport import_ = (_magic_value.value());
{
TRY((((*this).add_extern_import(import_))));
}

}
}

{
ArrayIterator<parser::ParsedNamespace> _magic = ((((namespace_).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedNamespace child_namespace = (_magic_value.value());
{
TRY((((*this).add_child_namespace(child_namespace))));
}

}
}

}
return {};
}

ErrorOr<void> parser::ParsedNamespace::add_module_import(const parser::ParsedModuleImport import_) {
{
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((*this).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedModuleImport module_import = (_magic_value.value());
{
if (((module_import).is_equivalent_to(import_))){
TRY((((module_import).merge_import_list(((import_).import_list)))));
return {};
}
}

}
}

TRY((((((*this).module_imports)).push(import_))));
}
return {};
}

utility::Span parser::ParsedType::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& name = __jakt_match_value.name;
Array<String> const& namespaces = __jakt_match_value.namespaces;
Array<NonnullRefPtr<parser::ParsedType>> const& params = __jakt_match_value.params;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::GenericType>();String const& name = __jakt_match_value.name;
Array<NonnullRefPtr<parser::ParsedType>> const& generic_parameters = __jakt_match_value.generic_parameters;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktArray>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Dictionary>();NonnullRefPtr<parser::ParsedType> const& key = __jakt_match_value.key;
NonnullRefPtr<parser::ParsedType> const& value = __jakt_match_value.value;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktTuple>();Array<NonnullRefPtr<parser::ParsedType>> const& types = __jakt_match_value.types;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Set>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Reference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::MutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::RawPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::WeakPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
return JaktInternal::ExplicitValue(utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedExpression::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& fill_size = __jakt_match_value.fill_size;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
Array<parser::ParsedMatchCase> const& cases = __jakt_match_value.cases;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
String const& field = __jakt_match_value.field;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& name = __jakt_match_value.name;
Array<String> const& namespace_ = __jakt_match_value.namespace_;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

i64 parser::ParsedExpression::precedence() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(static_cast<i64>(90LL));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(static_cast<i64>(90LL));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticRightShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue(static_cast<i64>(73LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue(static_cast<i64>(72LL));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue(static_cast<i64>(71LL));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(static_cast<i64>(70LL));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(static_cast<i64>(69LL));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
return JaktInternal::ExplicitValue(static_cast<i64>(69LL));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

NonnullRefPtr<parser::ParsedType> parser::TypeCast::parsed_type() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, NonnullRefPtr<parser::ParsedType>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Fallible>();
NonnullRefPtr<parser::ParsedType> const& parsed_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(parsed_type);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Infallible>();
NonnullRefPtr<parser::ParsedType> const& parsed_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(parsed_type);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String parser::RecordType::record_type_name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();return JaktInternal::ExplicitValue(String("value enum"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();return JaktInternal::ExplicitValue(String("sum enum"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
return JaktInternal::ExplicitValue(String("<garbage record type>"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String parser::ParsedCapture::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedCapture::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool parser::BinaryOperator::is_assignment() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedStatement::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Try>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace typechecker {
struct ModuleId {
  public:
size_t id;ModuleId(size_t a_id) :id(a_id){}

bool equals(const typechecker::ModuleId rhs) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ModuleId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class Module : public RefCounted<Module>, public Weakable<Module> {
  public:
virtual ~Module() = default;
typechecker::ModuleId id;String name;Array<NonnullRefPtr<typechecker::CheckedFunction>> functions;Array<typechecker::CheckedStruct> structures;Array<typechecker::CheckedEnum> enums;Array<NonnullRefPtr<typechecker::Scope>> scopes;Array<NonnullRefPtr<typechecker::Type>> types;Array<typechecker::CheckedVariable> variables;Array<typechecker::ModuleId> imports;bool is_root;private:
explicit Module(typechecker::ModuleId&& a_id, String&& a_name, Array<NonnullRefPtr<typechecker::CheckedFunction>>&& a_functions, Array<typechecker::CheckedStruct>&& a_structures, Array<typechecker::CheckedEnum>&& a_enums, Array<NonnullRefPtr<typechecker::Scope>>&& a_scopes, Array<NonnullRefPtr<typechecker::Type>>&& a_types, Array<typechecker::CheckedVariable>&& a_variables, Array<typechecker::ModuleId>&& a_imports, bool&& a_is_root): id(move(a_id)), name(move(a_name)), functions(move(a_functions)), structures(move(a_structures)), enums(move(a_enums)), scopes(move(a_scopes)), types(move(a_types)), variables(move(a_variables)), imports(move(a_imports)), is_root(move(a_is_root)){}
public:
static ErrorOr<NonnullRefPtr<Module>> create(typechecker::ModuleId id, String name, Array<NonnullRefPtr<typechecker::CheckedFunction>> functions, Array<typechecker::CheckedStruct> structures, Array<typechecker::CheckedEnum> enums, Array<NonnullRefPtr<typechecker::Scope>> scopes, Array<NonnullRefPtr<typechecker::Type>> types, Array<typechecker::CheckedVariable> variables, Array<typechecker::ModuleId> imports, bool is_root) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Module (move(id), move(name), move(functions), move(structures), move(enums), move(scopes), move(types), move(variables), move(imports), move(is_root)))); return o; }
ErrorOr<typechecker::TypeId> new_type_variable();
ErrorOr<typechecker::FunctionId> add_function(const NonnullRefPtr<typechecker::CheckedFunction> checked_function);
ErrorOr<typechecker::VarId> add_variable(const typechecker::CheckedVariable checked_variable);
typechecker::FunctionId next_function_id() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Module("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}, ", id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("structures: "));TRY(builder.appendff("{}, ", structures));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enums: "));TRY(builder.appendff("{}, ", enums));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scopes: "));TRY(builder.appendff("{}, ", scopes));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("types: "));TRY(builder.appendff("{}, ", types));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variables: "));TRY(builder.appendff("{}, ", variables));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("imports: "));TRY(builder.appendff("{}, ", imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_root: "));TRY(builder.appendff("{}", is_root));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace NumberConstant_Details {
struct Signed{
i64 value;
template<typename... Args>
Signed(Args&&... args): value { forward<Args>(args)... } {}
};
struct Unsigned{
u64 value;
template<typename... Args>
Unsigned(Args&&... args): value { forward<Args>(args)... } {}
};
struct Floating{
f64 value;
template<typename... Args>
Floating(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct NumberConstant : public Variant<NumberConstant_Details::Signed, NumberConstant_Details::Unsigned, NumberConstant_Details::Floating> {
using Variant<NumberConstant_Details::Signed, NumberConstant_Details::Unsigned, NumberConstant_Details::Floating>::Variant;
    using Signed = NumberConstant_Details::Signed;
    using Unsigned = NumberConstant_Details::Unsigned;
    using Floating = NumberConstant_Details::Floating;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Signed const& that) -> ErrorOr<void> {
TRY(builder.append("NumberConstant::Signed"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Unsigned const& that) -> ErrorOr<void> {
TRY(builder.append("NumberConstant::Unsigned"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Floating const& that) -> ErrorOr<void> {
TRY(builder.append("NumberConstant::Floating"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}size_t to_usize() const;
bool can_fit_number(const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedProgram> program) const;
};
struct EnumId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::EnumId rhs) const;
EnumId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("EnumId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct TypeId {
  public:
typechecker::ModuleId module;size_t id;ErrorOr<String> to_string() const;
static Optional<typechecker::TypeId> none();
bool equals(const typechecker::TypeId rhs) const;
TypeId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

static ErrorOr<typechecker::TypeId> from_string(const String type_id_string);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("TypeId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedEnumVariant_Details {
struct Untyped {
typechecker::EnumId enum_id;
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Untyped(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Typed {
typechecker::EnumId enum_id;
String name;
typechecker::TypeId type_id;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Typed(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct WithValue {
typechecker::EnumId enum_id;
String name;
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
WithValue(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
expr{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct StructLike {
typechecker::EnumId enum_id;
String name;
Array<typechecker::VarId> fields;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
StructLike(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
fields{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
}
struct CheckedEnumVariant : public Variant<CheckedEnumVariant_Details::Untyped, CheckedEnumVariant_Details::Typed, CheckedEnumVariant_Details::WithValue, CheckedEnumVariant_Details::StructLike> {
using Variant<CheckedEnumVariant_Details::Untyped, CheckedEnumVariant_Details::Typed, CheckedEnumVariant_Details::WithValue, CheckedEnumVariant_Details::StructLike>::Variant;
    using Untyped = CheckedEnumVariant_Details::Untyped;
    using Typed = CheckedEnumVariant_Details::Typed;
    using WithValue = CheckedEnumVariant_Details::WithValue;
    using StructLike = CheckedEnumVariant_Details::StructLike;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Untyped const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedEnumVariant::Untyped"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_id: "));TRY(builder.appendff("{}", that.enum_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Typed const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedEnumVariant::Typed"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_id: "));TRY(builder.appendff("{}", that.enum_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] WithValue const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedEnumVariant::WithValue"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_id: "));TRY(builder.appendff("{}", that.enum_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] StructLike const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedEnumVariant::StructLike"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_id: "));TRY(builder.appendff("{}", that.enum_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fields: "));TRY(builder.appendff("{}", that.fields));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}typechecker::EnumId enum_id() const;
String name() const;
bool equals(const typechecker::CheckedEnumVariant other) const;
utility::Span span() const;
};
struct ScopeId {
  public:
typechecker::ModuleId module_id;size_t id;bool equals(const typechecker::ScopeId other) const;
ScopeId(typechecker::ModuleId a_module_id, size_t a_id) :module_id(a_module_id), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ScopeId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_id: "));TRY(builder.appendff("{}, ", module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedNamespace {
  public:
String name;typechecker::ScopeId scope;CheckedNamespace(String a_name, typechecker::ScopeId a_scope) :name(a_name), scope(a_scope){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope: "));TRY(builder.appendff("{}", scope));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace SafetyMode_Details {
struct Safe {};
struct Unsafe {};
}
struct SafetyMode : public Variant<SafetyMode_Details::Safe, SafetyMode_Details::Unsafe> {
using Variant<SafetyMode_Details::Safe, SafetyMode_Details::Unsafe>::Variant;
    using Safe = SafetyMode_Details::Safe;
    using Unsafe = SafetyMode_Details::Unsafe;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Safe const& that) -> ErrorOr<void> {
TRY(builder.append("SafetyMode::Safe"));return {}; },[&]([[maybe_unused]] Unsafe const& that) -> ErrorOr<void> {
TRY(builder.append("SafetyMode::Unsafe"));return {}; }));return builder.to_string();}};
struct StructId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::StructId rhs) const;
StructId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("StructId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace BlockControlFlow_Details {
struct AlwaysReturns {};
struct AlwaysTransfersControl {
bool might_break;
template<typename _MemberT0>
AlwaysTransfersControl(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct NeverReturns {};
struct MayReturn {};
struct PartialAlwaysReturns {
bool might_break;
template<typename _MemberT0>
PartialAlwaysReturns(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct PartialAlwaysTransfersControl {
bool might_break;
template<typename _MemberT0>
PartialAlwaysTransfersControl(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct PartialNeverReturns {
bool might_break;
template<typename _MemberT0>
PartialNeverReturns(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
}
struct BlockControlFlow : public Variant<BlockControlFlow_Details::AlwaysReturns, BlockControlFlow_Details::AlwaysTransfersControl, BlockControlFlow_Details::NeverReturns, BlockControlFlow_Details::MayReturn, BlockControlFlow_Details::PartialAlwaysReturns, BlockControlFlow_Details::PartialAlwaysTransfersControl, BlockControlFlow_Details::PartialNeverReturns> {
using Variant<BlockControlFlow_Details::AlwaysReturns, BlockControlFlow_Details::AlwaysTransfersControl, BlockControlFlow_Details::NeverReturns, BlockControlFlow_Details::MayReturn, BlockControlFlow_Details::PartialAlwaysReturns, BlockControlFlow_Details::PartialAlwaysTransfersControl, BlockControlFlow_Details::PartialNeverReturns>::Variant;
    using AlwaysReturns = BlockControlFlow_Details::AlwaysReturns;
    using AlwaysTransfersControl = BlockControlFlow_Details::AlwaysTransfersControl;
    using NeverReturns = BlockControlFlow_Details::NeverReturns;
    using MayReturn = BlockControlFlow_Details::MayReturn;
    using PartialAlwaysReturns = BlockControlFlow_Details::PartialAlwaysReturns;
    using PartialAlwaysTransfersControl = BlockControlFlow_Details::PartialAlwaysTransfersControl;
    using PartialNeverReturns = BlockControlFlow_Details::PartialNeverReturns;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] AlwaysReturns const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::AlwaysReturns"));return {}; },[&]([[maybe_unused]] AlwaysTransfersControl const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::AlwaysTransfersControl"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("might_break: "));TRY(builder.appendff("{}", that.might_break));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NeverReturns const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::NeverReturns"));return {}; },[&]([[maybe_unused]] MayReturn const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::MayReturn"));return {}; },[&]([[maybe_unused]] PartialAlwaysReturns const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::PartialAlwaysReturns"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("might_break: "));TRY(builder.appendff("{}", that.might_break));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PartialAlwaysTransfersControl const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::PartialAlwaysTransfersControl"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("might_break: "));TRY(builder.appendff("{}", that.might_break));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] PartialNeverReturns const& that) -> ErrorOr<void> {
TRY(builder.append("BlockControlFlow::PartialNeverReturns"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("might_break: "));TRY(builder.appendff("{}", that.might_break));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}bool always_transfers_control() const;
typechecker::BlockControlFlow partial() const;
bool always_returns() const;
typechecker::BlockControlFlow updated(const typechecker::BlockControlFlow second) const;
bool may_break() const;
bool is_reachable() const;
bool never_returns() const;
bool may_return() const;
typechecker::BlockControlFlow unify_with(const typechecker::BlockControlFlow second) const;
};
struct CheckedBlock {
  public:
Array<NonnullRefPtr<typechecker::CheckedStatement>> statements;typechecker::ScopeId scope_id;typechecker::BlockControlFlow control_flow;Optional<typechecker::TypeId> yielded_type;CheckedBlock(Array<NonnullRefPtr<typechecker::CheckedStatement>> a_statements, typechecker::ScopeId a_scope_id, typechecker::BlockControlFlow a_control_flow, Optional<typechecker::TypeId> a_yielded_type) :statements(a_statements), scope_id(a_scope_id), control_flow(a_control_flow), yielded_type(a_yielded_type){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedBlock("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statements: "));TRY(builder.appendff("{}, ", statements));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("control_flow: "));TRY(builder.appendff("{}, ", control_flow));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("yielded_type: "));TRY(builder.appendff("{}", yielded_type));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedMatchBody_Details {
struct Expression{
NonnullRefPtr<typechecker::CheckedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct Block{
typechecker::CheckedBlock value;
template<typename... Args>
Block(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedMatchBody : public Variant<CheckedMatchBody_Details::Expression, CheckedMatchBody_Details::Block> {
using Variant<CheckedMatchBody_Details::Expression, CheckedMatchBody_Details::Block>::Variant;
    using Expression = CheckedMatchBody_Details::Expression;
    using Block = CheckedMatchBody_Details::Block;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedMatchBody::Expression"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Block const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedMatchBody::Block"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}};
struct CheckedStruct {
  public:
String name;utility::Span name_span;Array<typechecker::TypeId> generic_parameters;Array<typechecker::VarId> fields;typechecker::ScopeId scope_id;parser::DefinitionLinkage definition_linkage;parser::RecordType record_type;typechecker::TypeId type_id;CheckedStruct(String a_name, utility::Span a_name_span, Array<typechecker::TypeId> a_generic_parameters, Array<typechecker::VarId> a_fields, typechecker::ScopeId a_scope_id, parser::DefinitionLinkage a_definition_linkage, parser::RecordType a_record_type, typechecker::TypeId a_type_id) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), fields(a_fields), scope_id(a_scope_id), definition_linkage(a_definition_linkage), record_type(a_record_type), type_id(a_type_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedStruct("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fields: "));TRY(builder.appendff("{}, ", fields));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}, ", record_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedVariable {
  public:
String name;typechecker::TypeId type_id;bool is_mutable;utility::Span definition_span;Optional<utility::Span> type_span;parser::Visibility visibility;CheckedVariable(String a_name, typechecker::TypeId a_type_id, bool a_is_mutable, utility::Span a_definition_span, Optional<utility::Span> a_type_span, parser::Visibility a_visibility) :name(a_name), type_id(a_type_id), is_mutable(a_is_mutable), definition_span(a_definition_span), type_span(a_type_span), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedVariable("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_span: "));TRY(builder.appendff("{}, ", definition_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_span: "));TRY(builder.appendff("{}, ", type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedTypeCast_Details {
struct Fallible{
typechecker::TypeId value;
template<typename... Args>
Fallible(Args&&... args): value { forward<Args>(args)... } {}
};
struct Infallible{
typechecker::TypeId value;
template<typename... Args>
Infallible(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedTypeCast : public Variant<CheckedTypeCast_Details::Fallible, CheckedTypeCast_Details::Infallible> {
using Variant<CheckedTypeCast_Details::Fallible, CheckedTypeCast_Details::Infallible>::Variant;
    using Fallible = CheckedTypeCast_Details::Fallible;
    using Infallible = CheckedTypeCast_Details::Infallible;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Fallible const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedTypeCast::Fallible"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Infallible const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedTypeCast::Infallible"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}typechecker::TypeId type_id() const;
};
namespace CheckedUnaryOperator_Details {
struct PreIncrement {};
struct PostIncrement {};
struct PreDecrement {};
struct PostDecrement {};
struct Negate {};
struct Dereference {};
struct RawAddress {};
struct Reference {};
struct MutableReference {};
struct LogicalNot {};
struct BitwiseNot {};
struct TypeCast{
typechecker::CheckedTypeCast value;
template<typename... Args>
TypeCast(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
typechecker::TypeId value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct IsEnumVariant {
typechecker::CheckedEnumVariant enum_variant;
Array<typechecker::CheckedEnumVariantBinding> bindings;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
IsEnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
enum_variant{ forward<_MemberT0>(member_0)},
bindings{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
}
struct CheckedUnaryOperator : public Variant<CheckedUnaryOperator_Details::PreIncrement, CheckedUnaryOperator_Details::PostIncrement, CheckedUnaryOperator_Details::PreDecrement, CheckedUnaryOperator_Details::PostDecrement, CheckedUnaryOperator_Details::Negate, CheckedUnaryOperator_Details::Dereference, CheckedUnaryOperator_Details::RawAddress, CheckedUnaryOperator_Details::Reference, CheckedUnaryOperator_Details::MutableReference, CheckedUnaryOperator_Details::LogicalNot, CheckedUnaryOperator_Details::BitwiseNot, CheckedUnaryOperator_Details::TypeCast, CheckedUnaryOperator_Details::Is, CheckedUnaryOperator_Details::IsEnumVariant> {
using Variant<CheckedUnaryOperator_Details::PreIncrement, CheckedUnaryOperator_Details::PostIncrement, CheckedUnaryOperator_Details::PreDecrement, CheckedUnaryOperator_Details::PostDecrement, CheckedUnaryOperator_Details::Negate, CheckedUnaryOperator_Details::Dereference, CheckedUnaryOperator_Details::RawAddress, CheckedUnaryOperator_Details::Reference, CheckedUnaryOperator_Details::MutableReference, CheckedUnaryOperator_Details::LogicalNot, CheckedUnaryOperator_Details::BitwiseNot, CheckedUnaryOperator_Details::TypeCast, CheckedUnaryOperator_Details::Is, CheckedUnaryOperator_Details::IsEnumVariant>::Variant;
    using PreIncrement = CheckedUnaryOperator_Details::PreIncrement;
    using PostIncrement = CheckedUnaryOperator_Details::PostIncrement;
    using PreDecrement = CheckedUnaryOperator_Details::PreDecrement;
    using PostDecrement = CheckedUnaryOperator_Details::PostDecrement;
    using Negate = CheckedUnaryOperator_Details::Negate;
    using Dereference = CheckedUnaryOperator_Details::Dereference;
    using RawAddress = CheckedUnaryOperator_Details::RawAddress;
    using Reference = CheckedUnaryOperator_Details::Reference;
    using MutableReference = CheckedUnaryOperator_Details::MutableReference;
    using LogicalNot = CheckedUnaryOperator_Details::LogicalNot;
    using BitwiseNot = CheckedUnaryOperator_Details::BitwiseNot;
    using TypeCast = CheckedUnaryOperator_Details::TypeCast;
    using Is = CheckedUnaryOperator_Details::Is;
    using IsEnumVariant = CheckedUnaryOperator_Details::IsEnumVariant;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] PreIncrement const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::PreIncrement"));return {}; },[&]([[maybe_unused]] PostIncrement const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::PostIncrement"));return {}; },[&]([[maybe_unused]] PreDecrement const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::PreDecrement"));return {}; },[&]([[maybe_unused]] PostDecrement const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::PostDecrement"));return {}; },[&]([[maybe_unused]] Negate const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::Negate"));return {}; },[&]([[maybe_unused]] Dereference const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::Dereference"));return {}; },[&]([[maybe_unused]] RawAddress const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::RawAddress"));return {}; },[&]([[maybe_unused]] Reference const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::Reference"));return {}; },[&]([[maybe_unused]] MutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::MutableReference"));return {}; },[&]([[maybe_unused]] LogicalNot const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::LogicalNot"));return {}; },[&]([[maybe_unused]] BitwiseNot const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::BitwiseNot"));return {}; },[&]([[maybe_unused]] TypeCast const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::TypeCast"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Is const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::Is"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IsEnumVariant const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedUnaryOperator::IsEnumVariant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_variant: "));TRY(builder.appendff("{}", that.enum_variant));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("bindings: "));TRY(builder.appendff("{}", that.bindings));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}};
struct FunctionId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::FunctionId rhs) const;
FunctionId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FunctionId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedCall {
  public:
Array<typechecker::ResolvedNamespace> namespace_;String name;Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args;Array<typechecker::TypeId> type_args;Optional<typechecker::FunctionId> function_id;typechecker::TypeId return_type;bool callee_throws;CheckedCall(Array<typechecker::ResolvedNamespace> a_namespace_, String a_name, Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> a_args, Array<typechecker::TypeId> a_type_args, Optional<typechecker::FunctionId> a_function_id, typechecker::TypeId a_return_type, bool a_callee_throws) :namespace_(a_namespace_), name(a_name), args(a_args), type_args(a_type_args), function_id(a_function_id), return_type(a_return_type), callee_throws(a_callee_throws){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedCall("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_: "));TRY(builder.appendff("{}, ", namespace_));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_args: "));TRY(builder.appendff("{}, ", type_args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("function_id: "));TRY(builder.appendff("{}, ", function_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}, ", return_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("callee_throws: "));TRY(builder.appendff("{}", callee_throws));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct LoadedModule {
  public:
typechecker::ModuleId module_id;utility::FileId file_id;LoadedModule(typechecker::ModuleId a_module_id, utility::FileId a_file_id) :module_id(a_module_id), file_id(a_file_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("LoadedModule("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_id: "));TRY(builder.appendff("{}, ", module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_id: "));TRY(builder.appendff("{}", file_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedMatchCase_Details {
struct EnumVariant {
String name;
Array<parser::EnumVariantPatternArgument> args;
typechecker::TypeId subject_type_id;
size_t index;
typechecker::ScopeId scope_id;
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
name{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)},
subject_type_id{ forward<_MemberT2>(member_2)},
index{ forward<_MemberT3>(member_3)},
scope_id{ forward<_MemberT4>(member_4)},
body{ forward<_MemberT5>(member_5)},
marker_span{ forward<_MemberT6>(member_6)}
{}
};
struct Expression {
NonnullRefPtr<typechecker::CheckedExpression> expression;
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Expression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expression{ forward<_MemberT0>(member_0)},
body{ forward<_MemberT1>(member_1)},
marker_span{ forward<_MemberT2>(member_2)}
{}
};
struct CatchAll {
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1>
CatchAll(_MemberT0&& member_0, _MemberT1&& member_1):
body{ forward<_MemberT0>(member_0)},
marker_span{ forward<_MemberT1>(member_1)}
{}
};
}
struct CheckedMatchCase : public Variant<CheckedMatchCase_Details::EnumVariant, CheckedMatchCase_Details::Expression, CheckedMatchCase_Details::CatchAll> {
using Variant<CheckedMatchCase_Details::EnumVariant, CheckedMatchCase_Details::Expression, CheckedMatchCase_Details::CatchAll>::Variant;
    using EnumVariant = CheckedMatchCase_Details::EnumVariant;
    using Expression = CheckedMatchCase_Details::Expression;
    using CatchAll = CheckedMatchCase_Details::CatchAll;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] EnumVariant const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedMatchCase::EnumVariant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}", that.args));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("subject_type_id: "));TRY(builder.appendff("{}", that.subject_type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}", that.scope_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("body: "));TRY(builder.appendff("{}", that.body));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("marker_span: "));TRY(builder.appendff("{}", that.marker_span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedMatchCase::Expression"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expression: "));TRY(builder.appendff("{}", that.expression));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("body: "));TRY(builder.appendff("{}", that.body));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("marker_span: "));TRY(builder.appendff("{}", that.marker_span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] CatchAll const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedMatchCase::CatchAll"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("body: "));TRY(builder.appendff("{}", that.body));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("marker_span: "));TRY(builder.appendff("{}", that.marker_span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}};
namespace StructOrEnumId_Details {
struct Struct{
typechecker::StructId value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
typechecker::EnumId value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct StructOrEnumId : public Variant<StructOrEnumId_Details::Struct, StructOrEnumId_Details::Enum> {
using Variant<StructOrEnumId_Details::Struct, StructOrEnumId_Details::Enum>::Variant;
    using Struct = StructOrEnumId_Details::Struct;
    using Enum = StructOrEnumId_Details::Enum;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Struct const& that) -> ErrorOr<void> {
TRY(builder.append("StructOrEnumId::Struct"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Enum const& that) -> ErrorOr<void> {
TRY(builder.append("StructOrEnumId::Enum"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}};
class CheckedProgram : public RefCounted<CheckedProgram>, public Weakable<CheckedProgram> {
  public:
virtual ~CheckedProgram() = default;
NonnullRefPtr<compiler::Compiler> compiler;Array<NonnullRefPtr<typechecker::Module>> modules;Dictionary<String,typechecker::LoadedModule> loaded_modules;bool is_floating(const typechecker::TypeId type_id) const;
typechecker::ScopeId prelude_scope_id() const;
ErrorOr<Optional<typechecker::StructId>> find_struct_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> set_loaded_module(const String module_name, const typechecker::LoadedModule loaded_module);
bool is_integer(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Module> get_module(const typechecker::ModuleId id) const;
bool is_numeric(const typechecker::TypeId type_id) const;
bool is_string(const typechecker::TypeId type_id) const;
typechecker::CheckedVariable get_variable(const typechecker::VarId id) const;
private:
explicit CheckedProgram(NonnullRefPtr<compiler::Compiler>&& a_compiler, Array<NonnullRefPtr<typechecker::Module>>&& a_modules, Dictionary<String,typechecker::LoadedModule>&& a_loaded_modules): compiler(move(a_compiler)), modules(move(a_modules)), loaded_modules(move(a_loaded_modules)){}
public:
static ErrorOr<NonnullRefPtr<CheckedProgram>> create(NonnullRefPtr<compiler::Compiler> compiler, Array<NonnullRefPtr<typechecker::Module>> modules, Dictionary<String,typechecker::LoadedModule> loaded_modules) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) CheckedProgram (move(compiler), move(modules), move(loaded_modules)))); return o; }
NonnullRefPtr<typechecker::CheckedFunction> get_function(const typechecker::FunctionId id) const;
i64 get_bits(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Type> get_type(const typechecker::TypeId id) const;
ErrorOr<typechecker::StructId> find_struct_in_prelude(const String name) const;
typechecker::CheckedEnum get_enum(const typechecker::EnumId id) const;
ErrorOr<String> type_name(const typechecker::TypeId type_id) const;
ErrorOr<Optional<typechecker::CheckedVariable>> find_var_in_scope(const typechecker::ScopeId scope_id, const String var) const;
typechecker::CheckedStruct get_struct(const typechecker::StructId id) const;
ErrorOr<Optional<typechecker::StructId>> check_and_extract_weak_ptr(const typechecker::StructId struct_id, const Array<typechecker::TypeId> args) const;
ErrorOr<Optional<typechecker::EnumId>> find_enum_in_scope(const typechecker::ScopeId scope_id, const String name) const;
Optional<typechecker::LoadedModule> get_loaded_module(const String module_name) const;
bool is_signed(const typechecker::TypeId type_id) const;
ErrorOr<NonnullRefPtr<typechecker::Scope>> get_scope(const typechecker::ScopeId id) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedProgram("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("modules: "));TRY(builder.appendff("{}, ", modules));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("loaded_modules: "));TRY(builder.appendff("{}", loaded_modules));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Typechecker {
  public:
NonnullRefPtr<compiler::Compiler> compiler;NonnullRefPtr<typechecker::CheckedProgram> program;typechecker::ModuleId current_module_id;Optional<typechecker::TypeId> current_struct_type_id;Optional<typechecker::FunctionId> current_function_id;bool inside_defer;size_t checkidx;bool ignore_errors;bool dump_type_hints;bool dump_try_hints;u64 lambda_count;bool is_floating(const typechecker::TypeId type_id) const;
ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>> typecheck_match_body(const parser::ParsedMatchBody body, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Dictionary<String,String> generic_inferences, const Optional<typechecker::TypeId> final_result_type, const utility::Span span);
ErrorOr<void> typecheck_namespace_predecl(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_set(const Array<NonnullRefPtr<parser::ParsedExpression>> values, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
bool is_integer(const typechecker::TypeId type_id) const;
ErrorOr<void> dump_try_hint(const utility::Span span) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_call(const parser::ParsedCall call, const typechecker::ScopeId caller_scope_id, const utility::Span span, const Optional<NonnullRefPtr<typechecker::CheckedExpression>> this_expr, const Optional<typechecker::StructOrEnumId> parent_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const bool must_be_enum_constructor);
ErrorOr<bool> add_type_to_scope(const typechecker::ScopeId scope_id, const String type_name, const typechecker::TypeId type_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_namespaced_var_or_simple_enum_constructor_call(const String name, const Array<String> namespace_, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const utility::Span span);
ErrorOr<String> type_name(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Module> current_module() const;
ErrorOr<void> error_with_hint(const String message, const utility::Span span, const String hint, const utility::Span hint_span);
ErrorOr<Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>>> find_type_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<typechecker::TypeId> find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type);
ErrorOr<Optional<Tuple<typechecker::ScopeId,bool>>> find_namespace_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_match(const NonnullRefPtr<parser::ParsedExpression> expr, const Array<parser::ParsedMatchCase> cases, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<void> typecheck_enum_predecl(const parser::ParsedRecord parsed_record, const typechecker::EnumId enum_id, const typechecker::ScopeId scope_id);
ErrorOr<Optional<typechecker::CheckedEnumVariant>> get_enum_variant(const typechecker::CheckedEnum enum_, const String variant_name);
typechecker::ScopeId root_scope_id() const;
ErrorOr<Optional<typechecker::FunctionId>> find_function_in_scope(const typechecker::ScopeId parent_scope_id, const String function_name) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_loop(const parser::ParsedBlock parsed_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_defer(const NonnullRefPtr<parser::ParsedStatement> statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_unary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr, const typechecker::CheckedUnaryOperator checked_op, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_generic_arguments_method_call(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr, const parser::ParsedCall call, const typechecker::ScopeId scope_id, const utility::Span span, const bool is_optional, const typechecker::SafetyMode safety_mode);
ErrorOr<void> typecheck_module(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_namespace_declarations(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<typechecker::TypeId> substitute_typevars_in_type(const typechecker::TypeId type_id, const Dictionary<String,String> generic_inferences);
ErrorOr<typechecker::StructId> find_struct_in_prelude(const String name) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> cast_to_underlying(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const NonnullRefPtr<parser::ParsedType> parsed_type);
ErrorOr<void> typecheck_module_import(const parser::ParsedModuleImport import_, const typechecker::ScopeId scope_id);
ErrorOr<typechecker::TypeId> typecheck_binary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs, const parser::BinaryOperator op, const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs, const typechecker::ScopeId scope_id, const utility::Span span);
ErrorOr<Optional<typechecker::StructId>> find_struct_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> check_method_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee, const NonnullRefPtr<typechecker::CheckedFunction> method, const utility::Span span);
ErrorOr<typechecker::CheckedBlock> typecheck_block(const parser::ParsedBlock parsed_block, const typechecker::ScopeId parent_scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<Optional<typechecker::TypeId>> find_type_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> typecheck_function(const parser::ParsedFunction parsed_function, const typechecker::ScopeId parent_scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_inline_cpp(const parser::ParsedBlock block, const utility::Span span, const typechecker::SafetyMode safety_mode);
utility::Span expression_span(const NonnullRefPtr<typechecker::CheckedExpression> expr) const;
ErrorOr<void> check_restricted_access(const typechecker::ScopeId accessor, const String accessee_kind, const typechecker::ScopeId accessee, const String name, const Array<NonnullRefPtr<parser::ParsedType>> whitelist, const utility::Span span);
ErrorOr<void> include_prelude();
ErrorOr<bool> add_function_to_scope(const typechecker::ScopeId parent_scope_id, const String name, const typechecker::FunctionId function_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_while(const NonnullRefPtr<parser::ParsedExpression> condition, const parser::ParsedBlock block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_expression_and_dereference_if_needed(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const utility::Span span);
ErrorOr<NonnullRefPtr<utility::FilePath>> get_root_path() const;
ErrorOr<bool> scope_can_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee) const;
ErrorOr<void> typecheck_struct_fields(const parser::ParsedRecord record, const typechecker::StructId struct_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_expression(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<void> dump_type_hint(const typechecker::TypeId type_id, const utility::Span span) const;
ErrorOr<void> typecheck_namespace_imports(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_block_statement(const parser::ParsedBlock parsed_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<typechecker::TypeId> typecheck_typename(const NonnullRefPtr<parser::ParsedType> parsed_type, const typechecker::ScopeId scope_id, const Optional<String> name);
ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>> expand_context_for_bindings(const NonnullRefPtr<parser::ParsedExpression> condition, const Optional<NonnullRefPtr<parser::ParsedExpression>> acc, const parser::ParsedBlock then_block, const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement, const utility::Span span);
ErrorOr<Optional<typechecker::TypeId>> unify(const typechecker::TypeId lhs, const utility::Span lhs_span, const typechecker::TypeId rhs, const utility::Span rhs_span);
ErrorOr<typechecker::TypeId> find_type_in_prelude(const String name) const;
bool is_numeric(const typechecker::TypeId type_id) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_array(const typechecker::ScopeId scope_id, const Array<NonnullRefPtr<parser::ParsedExpression>> values, const Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size, const utility::Span span, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<bool> add_var_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::VarId var_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::Scope>> get_scope(const typechecker::ScopeId id) const;
ErrorOr<bool> check_types_for_compat(const typechecker::TypeId lhs_type_id, const typechecker::TypeId rhs_type_id, Dictionary<String,String> generic_inferences, const utility::Span span);
ErrorOr<Optional<typechecker::CheckedVariable>> find_var_in_scope(const typechecker::ScopeId scope_id, const String var) const;
typechecker::CheckedStruct get_struct(const typechecker::StructId id) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_lambda(const Array<parser::ParsedCapture> captures, const Array<parser::ParsedParameter> params, const bool can_throw, const NonnullRefPtr<parser::ParsedType> return_type, const parser::ParsedBlock block, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_try(const NonnullRefPtr<parser::ParsedStatement> stmt, const String error_name, const utility::Span error_span, const parser::ParsedBlock catch_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_return(const Optional<NonnullRefPtr<parser::ParsedExpression>> expr, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<void> check_that_type_doesnt_contain_reference(const typechecker::TypeId type_id, const utility::Span span);
ErrorOr<void> typecheck_namespace_fields(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_and_specialize_generic_function(const typechecker::FunctionId function_id, const Array<typechecker::TypeId> generic_arguments, const typechecker::ScopeId parent_scope_id, const Optional<typechecker::TypeId> this_type_id, const Dictionary<String,String> generic_substitutions);
ErrorOr<Optional<parser::ParsedNamespace>> lex_and_parse_file_contents(const utility::FileId file_id);
ErrorOr<Optional<NonnullRefPtr<typechecker::CheckedExpression>>> try_to_promote_constant_expr_to_type(const typechecker::TypeId lhs_type, const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs, const utility::Span span);
ErrorOr<typechecker::TypeId> resolve_type_var(const typechecker::TypeId type_var_type_id, const typechecker::ScopeId scope_id) const;
NonnullRefPtr<typechecker::CheckedFunction> get_function(const typechecker::FunctionId id) const;
ErrorOr<void> typecheck_struct_predecl(const parser::ParsedRecord parsed_record, const typechecker::StructId struct_id, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_enum_predecl_initial(const parser::ParsedRecord parsed_record, const size_t enum_index, const size_t module_enum_len, const typechecker::ScopeId scope_id);
NonnullRefPtr<typechecker::Type> get_type(const typechecker::TypeId id) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_guard(const NonnullRefPtr<parser::ParsedExpression> expr, const parser::ParsedBlock else_block, const parser::ParsedBlock remaining_code, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> typecheck_extern_import(const parser::ParsedExternImport import_, const typechecker::ScopeId scope_id, parser::ParsedNamespace parent);
ErrorOr<void> check_member_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee, const typechecker::CheckedVariable member, const utility::Span span);
ErrorOr<void> typecheck_method(const parser::ParsedFunction func, const typechecker::StructOrEnumId parent_id);
bool expression_is_mutable(const NonnullRefPtr<typechecker::CheckedExpression> expr) const;
ErrorOr<bool> add_struct_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::StructId struct_id, const utility::Span span);
Typechecker(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<typechecker::CheckedProgram> a_program, typechecker::ModuleId a_current_module_id, Optional<typechecker::TypeId> a_current_struct_type_id, Optional<typechecker::FunctionId> a_current_function_id, bool a_inside_defer, size_t a_checkidx, bool a_ignore_errors, bool a_dump_type_hints, bool a_dump_try_hints, u64 a_lambda_count) :compiler(a_compiler), program(a_program), current_module_id(a_current_module_id), current_struct_type_id(a_current_struct_type_id), current_function_id(a_current_function_id), inside_defer(a_inside_defer), checkidx(a_checkidx), ignore_errors(a_ignore_errors), dump_type_hints(a_dump_type_hints), dump_try_hints(a_dump_try_hints), lambda_count(a_lambda_count){}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_unary_negate(const NonnullRefPtr<typechecker::CheckedExpression> expr, const utility::Span span, const typechecker::TypeId type_id);
ErrorOr<Optional<typechecker::FunctionId>> resolve_call(const parser::ParsedCall call, Array<typechecker::ResolvedNamespace> namespaces, const utility::Span span, const typechecker::ScopeId scope_id, const bool must_be_enum_constructor);
static ErrorOr<NonnullRefPtr<typechecker::CheckedProgram>> typecheck(NonnullRefPtr<compiler::Compiler> compiler, const parser::ParsedNamespace parsed_namespace);
ErrorOr<bool> add_enum_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::EnumId enum_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_dictionary(const Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_if(const NonnullRefPtr<parser::ParsedExpression> condition, const parser::ParsedBlock then_block, const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<typechecker::TypeId> unify_with_type(const typechecker::TypeId found_type, const Optional<typechecker::TypeId> expected_type, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_throw(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_destructuring_assignment(const Array<parser::ParsedVarDecl> vars, const NonnullRefPtr<parser::ParsedStatement> var_decl, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
typechecker::ScopeId prelude_scope_id() const;
typechecker::BlockControlFlow statement_control_flow(const NonnullRefPtr<typechecker::CheckedStatement> statement) const;
ErrorOr<typechecker::ScopeId> create_scope(const Optional<typechecker::ScopeId> parent_scope_id, const bool can_throw, const String debug_name);
ErrorOr<bool> validate_argument_label(const typechecker::CheckedParameter param, const String label, const utility::Span span, const NonnullRefPtr<parser::ParsedExpression> expr);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_indexed_struct(const NonnullRefPtr<parser::ParsedExpression> expr, const String field, const typechecker::ScopeId scope_id, const bool is_optional, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> typecheck_function_predecl(const parser::ParsedFunction parsed_function, const typechecker::ScopeId parent_scope_id, const Optional<typechecker::TypeId> this_arg_type_id);
typechecker::CheckedVariable get_variable(const typechecker::VarId id) const;
ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<typechecker::ModuleId> create_module(const String name, const bool is_root);
typechecker::TypeId infer_function_return_type(const typechecker::CheckedBlock block) const;
ErrorOr<typechecker::TypeId> substitute_typevars_in_type_helper(const typechecker::TypeId type_id, const Dictionary<String,String> generic_inferences);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_statement(const NonnullRefPtr<parser::ParsedStatement> statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
bool statement_never_returns(const NonnullRefPtr<typechecker::CheckedStatement> statement) const;
typechecker::CheckedEnum get_enum(const typechecker::EnumId id) const;
ErrorOr<void> typecheck_enum(const parser::ParsedRecord record, const typechecker::EnumId enum_id, const typechecker::ScopeId parent_scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_var_decl(const parser::ParsedVarDecl var, const NonnullRefPtr<parser::ParsedExpression> init, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<Optional<Array<typechecker::CheckedEnumVariantBinding>>> typecheck_enum_variant_bindings(const typechecker::CheckedEnumVariant variant, const Array<parser::EnumVariantPatternArgument> bindings, const utility::Span span);
ErrorOr<typechecker::CheckedParameter> typecheck_parameter(const parser::ParsedParameter parameter, const typechecker::ScopeId scope_id, const bool first, const Optional<typechecker::TypeId> this_arg_type_id, const Optional<typechecker::ScopeId> check_scope);
ErrorOr<void> typecheck_struct(const parser::ParsedRecord record, const typechecker::StructId struct_id, const typechecker::ScopeId parent_scope_id);
ErrorOr<void> typecheck_struct_predecl_initial(const parser::ParsedRecord parsed_record, const size_t struct_index, const size_t module_struct_len, const typechecker::ScopeId scope_id);
ErrorOr<typechecker::TypeId> typecheck_generic_resolved_type(const String name, const Array<typechecker::TypeId> checked_inner_types, const typechecker::ScopeId scope_id, const utility::Span span);
typechecker::BlockControlFlow maybe_statement_control_flow(const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement, const typechecker::BlockControlFlow other_branch) const;
ErrorOr<void> typecheck_jakt_main(const parser::ParsedFunction parsed_function);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_for(const String iterator_name, const utility::Span name_span, const NonnullRefPtr<parser::ParsedExpression> range, const parser::ParsedBlock block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Typechecker("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("program: "));TRY(builder.appendff("{}, ", *program));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_module_id: "));TRY(builder.appendff("{}, ", current_module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_struct_type_id: "));TRY(builder.appendff("{}, ", current_struct_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_function_id: "));TRY(builder.appendff("{}, ", current_function_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inside_defer: "));TRY(builder.appendff("{}, ", inside_defer));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("checkidx: "));TRY(builder.appendff("{}, ", checkidx));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("ignore_errors: "));TRY(builder.appendff("{}, ", ignore_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_type_hints: "));TRY(builder.appendff("{}, ", dump_type_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_try_hints: "));TRY(builder.appendff("{}, ", dump_try_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("lambda_count: "));TRY(builder.appendff("{}", lambda_count));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};enum class BuiltinType: size_t {
Void = (infallible_integer_cast<size_t>(static_cast<i64>(0LL))),
Bool = (infallible_integer_cast<size_t>(static_cast<i64>(1LL))),
U8 = (infallible_integer_cast<size_t>(static_cast<i64>(2LL))),
U16 = (infallible_integer_cast<size_t>(static_cast<i64>(3LL))),
U32 = (infallible_integer_cast<size_t>(static_cast<i64>(4LL))),
U64 = (infallible_integer_cast<size_t>(static_cast<i64>(5LL))),
I8 = (infallible_integer_cast<size_t>(static_cast<i64>(6LL))),
I16 = (infallible_integer_cast<size_t>(static_cast<i64>(7LL))),
I32 = (infallible_integer_cast<size_t>(static_cast<i64>(8LL))),
I64 = (infallible_integer_cast<size_t>(static_cast<i64>(9LL))),
F32 = (infallible_integer_cast<size_t>(static_cast<i64>(10LL))),
F64 = (infallible_integer_cast<size_t>(static_cast<i64>(11LL))),
Usize = (infallible_integer_cast<size_t>(static_cast<i64>(12LL))),
String = (infallible_integer_cast<size_t>(static_cast<i64>(13LL))),
CChar = (infallible_integer_cast<size_t>(static_cast<i64>(14LL))),
CInt = (infallible_integer_cast<size_t>(static_cast<i64>(15LL))),
Unknown = (infallible_integer_cast<size_t>(static_cast<i64>(16LL))),
Never = (infallible_integer_cast<size_t>(static_cast<i64>(17LL))),
};
struct CheckedEnum {
  public:
String name;utility::Span name_span;Array<typechecker::TypeId> generic_parameters;Array<typechecker::CheckedEnumVariant> variants;typechecker::ScopeId scope_id;parser::DefinitionLinkage definition_linkage;parser::RecordType record_type;typechecker::TypeId underlying_type_id;typechecker::TypeId type_id;bool is_boxed;CheckedEnum(String a_name, utility::Span a_name_span, Array<typechecker::TypeId> a_generic_parameters, Array<typechecker::CheckedEnumVariant> a_variants, typechecker::ScopeId a_scope_id, parser::DefinitionLinkage a_definition_linkage, parser::RecordType a_record_type, typechecker::TypeId a_underlying_type_id, typechecker::TypeId a_type_id, bool a_is_boxed) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), variants(a_variants), scope_id(a_scope_id), definition_linkage(a_definition_linkage), record_type(a_record_type), underlying_type_id(a_underlying_type_id), type_id(a_type_id), is_boxed(a_is_boxed){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedEnum("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variants: "));TRY(builder.appendff("{}, ", variants));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}, ", record_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("underlying_type_id: "));TRY(builder.appendff("{}, ", underlying_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_boxed: "));TRY(builder.appendff("{}", is_boxed));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedVarDecl {
  public:
String name;bool is_mutable;utility::Span span;typechecker::TypeId type_id;CheckedVarDecl(String a_name, bool a_is_mutable, utility::Span a_span, typechecker::TypeId a_type_id) :name(a_name), is_mutable(a_is_mutable), span(a_span), type_id(a_type_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedVarDecl("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedCapture_Details {
struct ByValue {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByValue(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByMutableReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByMutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct CheckedCapture : public Variant<CheckedCapture_Details::ByValue, CheckedCapture_Details::ByReference, CheckedCapture_Details::ByMutableReference> {
using Variant<CheckedCapture_Details::ByValue, CheckedCapture_Details::ByReference, CheckedCapture_Details::ByMutableReference>::Variant;
    using ByValue = CheckedCapture_Details::ByValue;
    using ByReference = CheckedCapture_Details::ByReference;
    using ByMutableReference = CheckedCapture_Details::ByMutableReference;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] ByValue const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedCapture::ByValue"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ByReference const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedCapture::ByReference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ByMutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedCapture::ByMutableReference"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}String name() const;
utility::Span span() const;
};
struct VarId {
  public:
typechecker::ModuleId module;size_t id;VarId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("VarId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedStatement_Details {
struct Expression {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Expression(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Defer {
NonnullRefPtr<typechecker::CheckedStatement> statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Defer(_MemberT0&& member_0, _MemberT1&& member_1):
statement{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct DestructuringAssignment {
Array<NonnullRefPtr<typechecker::CheckedStatement>> vars;
NonnullRefPtr<typechecker::CheckedStatement> var_decl;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
DestructuringAssignment(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vars{ forward<_MemberT0>(member_0)},
var_decl{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct VarDecl {
typechecker::VarId var_id;
NonnullRefPtr<typechecker::CheckedExpression> init;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
VarDecl(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
var_id{ forward<_MemberT0>(member_0)},
init{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct If {
NonnullRefPtr<typechecker::CheckedExpression> condition;
typechecker::CheckedBlock then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> else_statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
If(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
condition{ forward<_MemberT0>(member_0)},
then_block{ forward<_MemberT1>(member_1)},
else_statement{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Block {
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Block(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Loop {
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Loop(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct While {
NonnullRefPtr<typechecker::CheckedExpression> condition;
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
While(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
condition{ forward<_MemberT0>(member_0)},
block{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Return {
Optional<NonnullRefPtr<typechecker::CheckedExpression>> val;
Optional<utility::Span> span;
template<typename _MemberT0, typename _MemberT1>
Return(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Throw(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Yield {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Yield(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Try {
NonnullRefPtr<typechecker::CheckedStatement> stmt;
String error_name;
typechecker::CheckedBlock catch_block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Try(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
stmt{ forward<_MemberT0>(member_0)},
error_name{ forward<_MemberT1>(member_1)},
catch_block{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct InlineCpp {
Array<String> lines;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
InlineCpp(_MemberT0&& member_0, _MemberT1&& member_1):
lines{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedStatement : public Variant<CheckedStatement_Details::Expression, CheckedStatement_Details::Defer, CheckedStatement_Details::DestructuringAssignment, CheckedStatement_Details::VarDecl, CheckedStatement_Details::If, CheckedStatement_Details::Block, CheckedStatement_Details::Loop, CheckedStatement_Details::While, CheckedStatement_Details::Return, CheckedStatement_Details::Break, CheckedStatement_Details::Continue, CheckedStatement_Details::Throw, CheckedStatement_Details::Yield, CheckedStatement_Details::Try, CheckedStatement_Details::InlineCpp, CheckedStatement_Details::Garbage>, public RefCounted<CheckedStatement> {
using Variant<CheckedStatement_Details::Expression, CheckedStatement_Details::Defer, CheckedStatement_Details::DestructuringAssignment, CheckedStatement_Details::VarDecl, CheckedStatement_Details::If, CheckedStatement_Details::Block, CheckedStatement_Details::Loop, CheckedStatement_Details::While, CheckedStatement_Details::Return, CheckedStatement_Details::Break, CheckedStatement_Details::Continue, CheckedStatement_Details::Throw, CheckedStatement_Details::Yield, CheckedStatement_Details::Try, CheckedStatement_Details::InlineCpp, CheckedStatement_Details::Garbage>::Variant;
    using Expression = CheckedStatement_Details::Expression;
    using Defer = CheckedStatement_Details::Defer;
    using DestructuringAssignment = CheckedStatement_Details::DestructuringAssignment;
    using VarDecl = CheckedStatement_Details::VarDecl;
    using If = CheckedStatement_Details::If;
    using Block = CheckedStatement_Details::Block;
    using Loop = CheckedStatement_Details::Loop;
    using While = CheckedStatement_Details::While;
    using Return = CheckedStatement_Details::Return;
    using Break = CheckedStatement_Details::Break;
    using Continue = CheckedStatement_Details::Continue;
    using Throw = CheckedStatement_Details::Throw;
    using Yield = CheckedStatement_Details::Yield;
    using Try = CheckedStatement_Details::Try;
    using InlineCpp = CheckedStatement_Details::InlineCpp;
    using Garbage = CheckedStatement_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) CheckedStatement(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Expression const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Expression"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Defer const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Defer"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statement: "));TRY(builder.appendff("{}", that.statement));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] DestructuringAssignment const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::DestructuringAssignment"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vars: "));TRY(builder.appendff("{}", that.vars));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_decl: "));TRY(builder.appendff("{}", that.var_decl));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] VarDecl const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::VarDecl"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_id: "));TRY(builder.appendff("{}", that.var_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("init: "));TRY(builder.appendff("{}", that.init));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] If const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::If"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("condition: "));TRY(builder.appendff("{}", that.condition));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("then_block: "));TRY(builder.appendff("{}", that.then_block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("else_statement: "));TRY(builder.appendff("{}", that.else_statement));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Block const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Block"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Loop const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Loop"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] While const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::While"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("condition: "));TRY(builder.appendff("{}", that.condition));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Return const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Return"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.appendff("{}", that.val));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Break const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Break"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Continue const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Continue"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Throw const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Throw"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Yield const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Yield"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Try const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Try"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("stmt: "));TRY(builder.appendff("{}", that.stmt));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("error_name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.error_name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("catch_block: "));TRY(builder.appendff("{}", that.catch_block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] InlineCpp const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::InlineCpp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("lines: "));TRY(builder.appendff("{}", that.lines));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedStatement::Garbage"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}static Optional<NonnullRefPtr<typechecker::CheckedStatement>> none();
Optional<utility::Span> span() const;
};
struct CheckedParameter {
  public:
bool requires_label;typechecker::CheckedVariable variable;CheckedParameter(bool a_requires_label, typechecker::CheckedVariable a_variable) :requires_label(a_requires_label), variable(a_variable){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("requires_label: "));TRY(builder.appendff("{}, ", requires_label));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variable: "));TRY(builder.appendff("{}", variable));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedNumericConstant_Details {
struct I8{
i8 value;
template<typename... Args>
I8(Args&&... args): value { forward<Args>(args)... } {}
};
struct I16{
i16 value;
template<typename... Args>
I16(Args&&... args): value { forward<Args>(args)... } {}
};
struct I32{
i32 value;
template<typename... Args>
I32(Args&&... args): value { forward<Args>(args)... } {}
};
struct I64{
i64 value;
template<typename... Args>
I64(Args&&... args): value { forward<Args>(args)... } {}
};
struct U8{
u8 value;
template<typename... Args>
U8(Args&&... args): value { forward<Args>(args)... } {}
};
struct U16{
u16 value;
template<typename... Args>
U16(Args&&... args): value { forward<Args>(args)... } {}
};
struct U32{
u32 value;
template<typename... Args>
U32(Args&&... args): value { forward<Args>(args)... } {}
};
struct U64{
u64 value;
template<typename... Args>
U64(Args&&... args): value { forward<Args>(args)... } {}
};
struct USize{
u64 value;
template<typename... Args>
USize(Args&&... args): value { forward<Args>(args)... } {}
};
struct F32{
f32 value;
template<typename... Args>
F32(Args&&... args): value { forward<Args>(args)... } {}
};
struct F64{
f64 value;
template<typename... Args>
F64(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedNumericConstant : public Variant<CheckedNumericConstant_Details::I8, CheckedNumericConstant_Details::I16, CheckedNumericConstant_Details::I32, CheckedNumericConstant_Details::I64, CheckedNumericConstant_Details::U8, CheckedNumericConstant_Details::U16, CheckedNumericConstant_Details::U32, CheckedNumericConstant_Details::U64, CheckedNumericConstant_Details::USize, CheckedNumericConstant_Details::F32, CheckedNumericConstant_Details::F64> {
using Variant<CheckedNumericConstant_Details::I8, CheckedNumericConstant_Details::I16, CheckedNumericConstant_Details::I32, CheckedNumericConstant_Details::I64, CheckedNumericConstant_Details::U8, CheckedNumericConstant_Details::U16, CheckedNumericConstant_Details::U32, CheckedNumericConstant_Details::U64, CheckedNumericConstant_Details::USize, CheckedNumericConstant_Details::F32, CheckedNumericConstant_Details::F64>::Variant;
    using I8 = CheckedNumericConstant_Details::I8;
    using I16 = CheckedNumericConstant_Details::I16;
    using I32 = CheckedNumericConstant_Details::I32;
    using I64 = CheckedNumericConstant_Details::I64;
    using U8 = CheckedNumericConstant_Details::U8;
    using U16 = CheckedNumericConstant_Details::U16;
    using U32 = CheckedNumericConstant_Details::U32;
    using U64 = CheckedNumericConstant_Details::U64;
    using USize = CheckedNumericConstant_Details::USize;
    using F32 = CheckedNumericConstant_Details::F32;
    using F64 = CheckedNumericConstant_Details::F64;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] I8 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::I8"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I16 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::I16"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I32 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::I32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] I64 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::I64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U8 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::U8"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U16 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::U16"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U32 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::U32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] U64 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::U64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] USize const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::USize"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] F32 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::F32"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] F64 const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedNumericConstant::F64"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}Optional<typechecker::NumberConstant> number_constant() const;
};
struct CheckedEnumVariantBinding {
  public:
Optional<String> name;String binding;typechecker::TypeId type_id;utility::Span span;CheckedEnumVariantBinding(Optional<String> a_name, String a_binding, typechecker::TypeId a_type_id, utility::Span a_span) :name(a_name), binding(a_binding), type_id(a_type_id), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedEnumVariantBinding("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("binding: "));TRY(builder.appendff("\"{}\", ", binding));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedExpression_Details {
struct Boolean {
bool val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Boolean(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NumericConstant {
typechecker::CheckedNumericConstant val;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NumericConstant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct QuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByteConstant {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByteConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct CharacterConstant {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
CharacterConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct UnaryOp {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedUnaryOperator op;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
UnaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct BinaryOp {
NonnullRefPtr<typechecker::CheckedExpression> lhs;
parser::BinaryOperator op;
NonnullRefPtr<typechecker::CheckedExpression> rhs;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
BinaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
lhs{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
rhs{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Range {
NonnullRefPtr<typechecker::CheckedExpression> from;
NonnullRefPtr<typechecker::CheckedExpression> to;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Range(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
from{ forward<_MemberT0>(member_0)},
to{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct JaktArray {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> repeat;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId inner_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
vals{ forward<_MemberT0>(member_0)},
repeat{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)},
inner_type_id{ forward<_MemberT4>(member_4)}
{}
};
struct JaktSet {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId inner_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
JaktSet(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
inner_type_id{ forward<_MemberT3>(member_3)}
{}
};
struct JaktDictionary {
Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> vals;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId key_type_id;
typechecker::TypeId value_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
JaktDictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
key_type_id{ forward<_MemberT3>(member_3)},
value_type_id{ forward<_MemberT4>(member_4)}
{}
};
struct IndexedExpression {
NonnullRefPtr<typechecker::CheckedExpression> expr;
NonnullRefPtr<typechecker::CheckedExpression> index;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedDictionary {
NonnullRefPtr<typechecker::CheckedExpression> expr;
NonnullRefPtr<typechecker::CheckedExpression> index;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedDictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedTuple {
NonnullRefPtr<typechecker::CheckedExpression> expr;
size_t index;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
IndexedTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct IndexedStruct {
NonnullRefPtr<typechecker::CheckedExpression> expr;
String index;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
IndexedStruct(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct Match {
NonnullRefPtr<typechecker::CheckedExpression> expr;
Array<typechecker::CheckedMatchCase> match_cases;
utility::Span span;
typechecker::TypeId type_id;
bool all_variants_constant;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
Match(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
match_cases{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)},
all_variants_constant{ forward<_MemberT4>(member_4)}
{}
};
struct EnumVariantArg {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedEnumVariantBinding arg;
typechecker::CheckedEnumVariant enum_variant;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
EnumVariantArg(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
arg{ forward<_MemberT1>(member_1)},
enum_variant{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Call {
typechecker::CheckedCall call;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Call(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
call{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct MethodCall {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedCall call;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
MethodCall(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
call{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct NamespacedVar {
Array<typechecker::CheckedNamespace> namespaces;
typechecker::CheckedVariable var;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NamespacedVar(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
namespaces{ forward<_MemberT0>(member_0)},
var{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Var {
typechecker::CheckedVariable var;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Var(_MemberT0&& member_0, _MemberT1&& member_1):
var{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalNone {
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1>
OptionalNone(_MemberT0&& member_0, _MemberT1&& member_1):
span{ forward<_MemberT0>(member_0)},
type_id{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalSome {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
OptionalSome(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct ForcedUnwrap {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
ForcedUnwrap(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Block {
typechecker::CheckedBlock block;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Block(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Function {
Array<typechecker::CheckedCapture> captures;
Array<typechecker::CheckedParameter> params;
bool can_throw;
typechecker::TypeId return_type_id;
typechecker::CheckedBlock block;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
captures{ forward<_MemberT0>(member_0)},
params{ forward<_MemberT1>(member_1)},
can_throw{ forward<_MemberT2>(member_2)},
return_type_id{ forward<_MemberT3>(member_3)},
block{ forward<_MemberT4>(member_4)},
span{ forward<_MemberT5>(member_5)},
type_id{ forward<_MemberT6>(member_6)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedExpression : public Variant<CheckedExpression_Details::Boolean, CheckedExpression_Details::NumericConstant, CheckedExpression_Details::QuotedString, CheckedExpression_Details::ByteConstant, CheckedExpression_Details::CharacterConstant, CheckedExpression_Details::UnaryOp, CheckedExpression_Details::BinaryOp, CheckedExpression_Details::JaktTuple, CheckedExpression_Details::Range, CheckedExpression_Details::JaktArray, CheckedExpression_Details::JaktSet, CheckedExpression_Details::JaktDictionary, CheckedExpression_Details::IndexedExpression, CheckedExpression_Details::IndexedDictionary, CheckedExpression_Details::IndexedTuple, CheckedExpression_Details::IndexedStruct, CheckedExpression_Details::Match, CheckedExpression_Details::EnumVariantArg, CheckedExpression_Details::Call, CheckedExpression_Details::MethodCall, CheckedExpression_Details::NamespacedVar, CheckedExpression_Details::Var, CheckedExpression_Details::OptionalNone, CheckedExpression_Details::OptionalSome, CheckedExpression_Details::ForcedUnwrap, CheckedExpression_Details::Block, CheckedExpression_Details::Function, CheckedExpression_Details::Garbage>, public RefCounted<CheckedExpression> {
using Variant<CheckedExpression_Details::Boolean, CheckedExpression_Details::NumericConstant, CheckedExpression_Details::QuotedString, CheckedExpression_Details::ByteConstant, CheckedExpression_Details::CharacterConstant, CheckedExpression_Details::UnaryOp, CheckedExpression_Details::BinaryOp, CheckedExpression_Details::JaktTuple, CheckedExpression_Details::Range, CheckedExpression_Details::JaktArray, CheckedExpression_Details::JaktSet, CheckedExpression_Details::JaktDictionary, CheckedExpression_Details::IndexedExpression, CheckedExpression_Details::IndexedDictionary, CheckedExpression_Details::IndexedTuple, CheckedExpression_Details::IndexedStruct, CheckedExpression_Details::Match, CheckedExpression_Details::EnumVariantArg, CheckedExpression_Details::Call, CheckedExpression_Details::MethodCall, CheckedExpression_Details::NamespacedVar, CheckedExpression_Details::Var, CheckedExpression_Details::OptionalNone, CheckedExpression_Details::OptionalSome, CheckedExpression_Details::ForcedUnwrap, CheckedExpression_Details::Block, CheckedExpression_Details::Function, CheckedExpression_Details::Garbage>::Variant;
    using Boolean = CheckedExpression_Details::Boolean;
    using NumericConstant = CheckedExpression_Details::NumericConstant;
    using QuotedString = CheckedExpression_Details::QuotedString;
    using ByteConstant = CheckedExpression_Details::ByteConstant;
    using CharacterConstant = CheckedExpression_Details::CharacterConstant;
    using UnaryOp = CheckedExpression_Details::UnaryOp;
    using BinaryOp = CheckedExpression_Details::BinaryOp;
    using JaktTuple = CheckedExpression_Details::JaktTuple;
    using Range = CheckedExpression_Details::Range;
    using JaktArray = CheckedExpression_Details::JaktArray;
    using JaktSet = CheckedExpression_Details::JaktSet;
    using JaktDictionary = CheckedExpression_Details::JaktDictionary;
    using IndexedExpression = CheckedExpression_Details::IndexedExpression;
    using IndexedDictionary = CheckedExpression_Details::IndexedDictionary;
    using IndexedTuple = CheckedExpression_Details::IndexedTuple;
    using IndexedStruct = CheckedExpression_Details::IndexedStruct;
    using Match = CheckedExpression_Details::Match;
    using EnumVariantArg = CheckedExpression_Details::EnumVariantArg;
    using Call = CheckedExpression_Details::Call;
    using MethodCall = CheckedExpression_Details::MethodCall;
    using NamespacedVar = CheckedExpression_Details::NamespacedVar;
    using Var = CheckedExpression_Details::Var;
    using OptionalNone = CheckedExpression_Details::OptionalNone;
    using OptionalSome = CheckedExpression_Details::OptionalSome;
    using ForcedUnwrap = CheckedExpression_Details::ForcedUnwrap;
    using Block = CheckedExpression_Details::Block;
    using Function = CheckedExpression_Details::Function;
    using Garbage = CheckedExpression_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) CheckedExpression(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Boolean const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Boolean"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.appendff("{}", that.val));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NumericConstant const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::NumericConstant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.appendff("{}", that.val));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] QuotedString const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::QuotedString"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ByteConstant const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::ByteConstant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] CharacterConstant const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::CharacterConstant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("val: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.val));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] UnaryOp const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::UnaryOp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("op: "));TRY(builder.appendff("{}", that.op));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] BinaryOp const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::BinaryOp"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("lhs: "));TRY(builder.appendff("{}", that.lhs));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("op: "));TRY(builder.appendff("{}", that.op));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("rhs: "));TRY(builder.appendff("{}", that.rhs));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktTuple const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::JaktTuple"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vals: "));TRY(builder.appendff("{}", that.vals));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Range const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Range"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("from: "));TRY(builder.appendff("{}", that.from));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("to: "));TRY(builder.appendff("{}", that.to));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktArray const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::JaktArray"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vals: "));TRY(builder.appendff("{}", that.vals));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("repeat: "));TRY(builder.appendff("{}", that.repeat));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner_type_id: "));TRY(builder.appendff("{}", that.inner_type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktSet const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::JaktSet"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vals: "));TRY(builder.appendff("{}", that.vals));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inner_type_id: "));TRY(builder.appendff("{}", that.inner_type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] JaktDictionary const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::JaktDictionary"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vals: "));TRY(builder.appendff("{}", that.vals));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("key_type_id: "));TRY(builder.appendff("{}", that.key_type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("value_type_id: "));TRY(builder.appendff("{}", that.value_type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedExpression const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::IndexedExpression"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedDictionary const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::IndexedDictionary"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedTuple const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::IndexedTuple"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}", that.index));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] IndexedStruct const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::IndexedStruct"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.index));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Match const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Match"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("match_cases: "));TRY(builder.appendff("{}", that.match_cases));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("all_variants_constant: "));TRY(builder.appendff("{}", that.all_variants_constant));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] EnumVariantArg const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::EnumVariantArg"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("arg: "));TRY(builder.appendff("{}", that.arg));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enum_variant: "));TRY(builder.appendff("{}", that.enum_variant));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Call const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Call"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("call: "));TRY(builder.appendff("{}", that.call));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MethodCall const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::MethodCall"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("call: "));TRY(builder.appendff("{}", that.call));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_optional: "));TRY(builder.appendff("{}", that.is_optional));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NamespacedVar const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::NamespacedVar"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespaces: "));TRY(builder.appendff("{}", that.namespaces));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var: "));TRY(builder.appendff("{}", that.var));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Var const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Var"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var: "));TRY(builder.appendff("{}", that.var));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] OptionalNone const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::OptionalNone"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] OptionalSome const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::OptionalSome"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] ForcedUnwrap const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::ForcedUnwrap"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("expr: "));TRY(builder.appendff("{}", that.expr));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Block const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Block"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Function const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Function"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("captures: "));TRY(builder.appendff("{}", that.captures));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", that.params));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}", that.can_throw));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_id: "));TRY(builder.appendff("{}", that.return_type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}", that.block));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Garbage const& that) -> ErrorOr<void> {
TRY(builder.append("CheckedExpression::Garbage"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}Optional<typechecker::NumberConstant> to_number_constant(const NonnullRefPtr<typechecker::CheckedProgram> program) const;
};
namespace Type_Details {
struct Void {};
struct Bool {};
struct U8 {};
struct U16 {};
struct U32 {};
struct U64 {};
struct I8 {};
struct I16 {};
struct I32 {};
struct I64 {};
struct F32 {};
struct F64 {};
struct Usize {};
struct JaktString {};
struct CChar {};
struct CInt {};
struct Unknown {};
struct Never {};
struct TypeVariable{
String value;
template<typename... Args>
TypeVariable(Args&&... args): value { forward<Args>(args)... } {}
};
struct GenericInstance {
typechecker::StructId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericInstance(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct GenericEnumInstance {
typechecker::EnumId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericEnumInstance(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct GenericResolvedType {
typechecker::StructId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericResolvedType(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct Struct{
typechecker::StructId value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
typechecker::EnumId value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
struct RawPtr{
typechecker::TypeId value;
template<typename... Args>
RawPtr(Args&&... args): value { forward<Args>(args)... } {}
};
struct Reference{
typechecker::TypeId value;
template<typename... Args>
Reference(Args&&... args): value { forward<Args>(args)... } {}
};
struct MutableReference{
typechecker::TypeId value;
template<typename... Args>
MutableReference(Args&&... args): value { forward<Args>(args)... } {}
};
struct Function {
Array<typechecker::TypeId> params;
bool can_throw;
typechecker::TypeId return_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
params{ forward<_MemberT0>(member_0)},
can_throw{ forward<_MemberT1>(member_1)},
return_type_id{ forward<_MemberT2>(member_2)}
{}
};
}
struct Type : public Variant<Type_Details::Void, Type_Details::Bool, Type_Details::U8, Type_Details::U16, Type_Details::U32, Type_Details::U64, Type_Details::I8, Type_Details::I16, Type_Details::I32, Type_Details::I64, Type_Details::F32, Type_Details::F64, Type_Details::Usize, Type_Details::JaktString, Type_Details::CChar, Type_Details::CInt, Type_Details::Unknown, Type_Details::Never, Type_Details::TypeVariable, Type_Details::GenericInstance, Type_Details::GenericEnumInstance, Type_Details::GenericResolvedType, Type_Details::Struct, Type_Details::Enum, Type_Details::RawPtr, Type_Details::Reference, Type_Details::MutableReference, Type_Details::Function>, public RefCounted<Type> {
using Variant<Type_Details::Void, Type_Details::Bool, Type_Details::U8, Type_Details::U16, Type_Details::U32, Type_Details::U64, Type_Details::I8, Type_Details::I16, Type_Details::I32, Type_Details::I64, Type_Details::F32, Type_Details::F64, Type_Details::Usize, Type_Details::JaktString, Type_Details::CChar, Type_Details::CInt, Type_Details::Unknown, Type_Details::Never, Type_Details::TypeVariable, Type_Details::GenericInstance, Type_Details::GenericEnumInstance, Type_Details::GenericResolvedType, Type_Details::Struct, Type_Details::Enum, Type_Details::RawPtr, Type_Details::Reference, Type_Details::MutableReference, Type_Details::Function>::Variant;
    using Void = Type_Details::Void;
    using Bool = Type_Details::Bool;
    using U8 = Type_Details::U8;
    using U16 = Type_Details::U16;
    using U32 = Type_Details::U32;
    using U64 = Type_Details::U64;
    using I8 = Type_Details::I8;
    using I16 = Type_Details::I16;
    using I32 = Type_Details::I32;
    using I64 = Type_Details::I64;
    using F32 = Type_Details::F32;
    using F64 = Type_Details::F64;
    using Usize = Type_Details::Usize;
    using JaktString = Type_Details::JaktString;
    using CChar = Type_Details::CChar;
    using CInt = Type_Details::CInt;
    using Unknown = Type_Details::Unknown;
    using Never = Type_Details::Never;
    using TypeVariable = Type_Details::TypeVariable;
    using GenericInstance = Type_Details::GenericInstance;
    using GenericEnumInstance = Type_Details::GenericEnumInstance;
    using GenericResolvedType = Type_Details::GenericResolvedType;
    using Struct = Type_Details::Struct;
    using Enum = Type_Details::Enum;
    using RawPtr = Type_Details::RawPtr;
    using Reference = Type_Details::Reference;
    using MutableReference = Type_Details::MutableReference;
    using Function = Type_Details::Function;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) Type(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Void const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Void"));return {}; },[&]([[maybe_unused]] Bool const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Bool"));return {}; },[&]([[maybe_unused]] U8 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::U8"));return {}; },[&]([[maybe_unused]] U16 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::U16"));return {}; },[&]([[maybe_unused]] U32 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::U32"));return {}; },[&]([[maybe_unused]] U64 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::U64"));return {}; },[&]([[maybe_unused]] I8 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::I8"));return {}; },[&]([[maybe_unused]] I16 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::I16"));return {}; },[&]([[maybe_unused]] I32 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::I32"));return {}; },[&]([[maybe_unused]] I64 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::I64"));return {}; },[&]([[maybe_unused]] F32 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::F32"));return {}; },[&]([[maybe_unused]] F64 const& that) -> ErrorOr<void> {
TRY(builder.append("Type::F64"));return {}; },[&]([[maybe_unused]] Usize const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Usize"));return {}; },[&]([[maybe_unused]] JaktString const& that) -> ErrorOr<void> {
TRY(builder.append("Type::JaktString"));return {}; },[&]([[maybe_unused]] CChar const& that) -> ErrorOr<void> {
TRY(builder.append("Type::CChar"));return {}; },[&]([[maybe_unused]] CInt const& that) -> ErrorOr<void> {
TRY(builder.append("Type::CInt"));return {}; },[&]([[maybe_unused]] Unknown const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Unknown"));return {}; },[&]([[maybe_unused]] Never const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Never"));return {}; },[&]([[maybe_unused]] TypeVariable const& that) -> ErrorOr<void> {
TRY(builder.append("Type::TypeVariable"));TRY(builder.append("("));TRY(builder.append("\""));TRY(builder.appendff("{}", that.value));TRY(builder.append("\""));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GenericInstance const& that) -> ErrorOr<void> {
TRY(builder.append("Type::GenericInstance"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", that.id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}", that.args));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GenericEnumInstance const& that) -> ErrorOr<void> {
TRY(builder.append("Type::GenericEnumInstance"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", that.id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}", that.args));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] GenericResolvedType const& that) -> ErrorOr<void> {
TRY(builder.append("Type::GenericResolvedType"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", that.id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}", that.args));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Struct const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Struct"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Enum const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Enum"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] RawPtr const& that) -> ErrorOr<void> {
TRY(builder.append("Type::RawPtr"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Reference const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Reference"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] MutableReference const& that) -> ErrorOr<void> {
TRY(builder.append("Type::MutableReference"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Function const& that) -> ErrorOr<void> {
TRY(builder.append("Type::Function"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", that.params));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}", that.can_throw));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_id: "));TRY(builder.appendff("{}", that.return_type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}u64 max() const;
bool equals(const NonnullRefPtr<typechecker::Type> rhs) const;
i64 get_bits() const;
bool is_builtin() const;
i64 min() const;
bool is_signed() const;
};
class Scope : public RefCounted<Scope>, public Weakable<Scope> {
  public:
virtual ~Scope() = default;
Optional<String> namespace_name;Dictionary<String,typechecker::VarId> vars;Dictionary<String,typechecker::StructId> structs;Dictionary<String,typechecker::FunctionId> functions;Dictionary<String,typechecker::EnumId> enums;Dictionary<String,typechecker::TypeId> types;Dictionary<String,typechecker::ModuleId> imports;Optional<typechecker::ScopeId> parent;Array<typechecker::ScopeId> children;bool can_throw;Optional<String> import_path_if_extern;String debug_name;private:
explicit Scope(Optional<String>&& a_namespace_name, Dictionary<String,typechecker::VarId>&& a_vars, Dictionary<String,typechecker::StructId>&& a_structs, Dictionary<String,typechecker::FunctionId>&& a_functions, Dictionary<String,typechecker::EnumId>&& a_enums, Dictionary<String,typechecker::TypeId>&& a_types, Dictionary<String,typechecker::ModuleId>&& a_imports, Optional<typechecker::ScopeId>&& a_parent, Array<typechecker::ScopeId>&& a_children, bool&& a_can_throw, Optional<String>&& a_import_path_if_extern, String&& a_debug_name): namespace_name(move(a_namespace_name)), vars(move(a_vars)), structs(move(a_structs)), functions(move(a_functions)), enums(move(a_enums)), types(move(a_types)), imports(move(a_imports)), parent(move(a_parent)), children(move(a_children)), can_throw(move(a_can_throw)), import_path_if_extern(move(a_import_path_if_extern)), debug_name(move(a_debug_name)){}
public:
static ErrorOr<NonnullRefPtr<Scope>> create(Optional<String> namespace_name, Dictionary<String,typechecker::VarId> vars, Dictionary<String,typechecker::StructId> structs, Dictionary<String,typechecker::FunctionId> functions, Dictionary<String,typechecker::EnumId> enums, Dictionary<String,typechecker::TypeId> types, Dictionary<String,typechecker::ModuleId> imports, Optional<typechecker::ScopeId> parent, Array<typechecker::ScopeId> children, bool can_throw, Optional<String> import_path_if_extern, String debug_name) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Scope (move(namespace_name), move(vars), move(structs), move(functions), move(enums), move(types), move(imports), move(parent), move(children), move(can_throw), move(import_path_if_extern), move(debug_name)))); return o; }
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Scope("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_name: "));TRY(builder.appendff("{}, ", namespace_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vars: "));TRY(builder.appendff("{}, ", vars));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("structs: "));TRY(builder.appendff("{}, ", structs));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enums: "));TRY(builder.appendff("{}, ", enums));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("types: "));TRY(builder.appendff("{}, ", types));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("imports: "));TRY(builder.appendff("{}, ", imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parent: "));TRY(builder.appendff("{}, ", parent));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("children: "));TRY(builder.appendff("{}, ", children));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_path_if_extern: "));TRY(builder.appendff("{}, ", import_path_if_extern));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_name: "));TRY(builder.appendff("\"{}\"", debug_name));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class CheckedFunction : public RefCounted<CheckedFunction>, public Weakable<CheckedFunction> {
  public:
virtual ~CheckedFunction() = default;
String name;utility::Span name_span;parser::Visibility visibility;typechecker::TypeId return_type_id;Optional<utility::Span> return_type_span;Array<typechecker::CheckedParameter> params;Array<typechecker::FunctionGenericParameter> generic_params;typechecker::CheckedBlock block;bool can_throw;parser::FunctionType type;parser::FunctionLinkage linkage;typechecker::ScopeId function_scope_id;bool is_instantiated;Optional<parser::ParsedFunction> parsed_function;bool is_static() const;
bool is_mutating() const;
parser::ParsedFunction to_parsed_function() const;
private:
explicit CheckedFunction(String&& a_name, utility::Span&& a_name_span, parser::Visibility&& a_visibility, typechecker::TypeId&& a_return_type_id, Optional<utility::Span>&& a_return_type_span, Array<typechecker::CheckedParameter>&& a_params, Array<typechecker::FunctionGenericParameter>&& a_generic_params, typechecker::CheckedBlock&& a_block, bool&& a_can_throw, parser::FunctionType&& a_type, parser::FunctionLinkage&& a_linkage, typechecker::ScopeId&& a_function_scope_id, bool&& a_is_instantiated, Optional<parser::ParsedFunction>&& a_parsed_function): name(move(a_name)), name_span(move(a_name_span)), visibility(move(a_visibility)), return_type_id(move(a_return_type_id)), return_type_span(move(a_return_type_span)), params(move(a_params)), generic_params(move(a_generic_params)), block(move(a_block)), can_throw(move(a_can_throw)), type(move(a_type)), linkage(move(a_linkage)), function_scope_id(move(a_function_scope_id)), is_instantiated(move(a_is_instantiated)), parsed_function(move(a_parsed_function)){}
public:
static ErrorOr<NonnullRefPtr<CheckedFunction>> create(String name, utility::Span name_span, parser::Visibility visibility, typechecker::TypeId return_type_id, Optional<utility::Span> return_type_span, Array<typechecker::CheckedParameter> params, Array<typechecker::FunctionGenericParameter> generic_params, typechecker::CheckedBlock block, bool can_throw, parser::FunctionType type, parser::FunctionLinkage linkage, typechecker::ScopeId function_scope_id, bool is_instantiated, Optional<parser::ParsedFunction> parsed_function) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) CheckedFunction (move(name), move(name_span), move(visibility), move(return_type_id), move(return_type_span), move(params), move(generic_params), move(block), move(can_throw), move(type), move(linkage), move(function_scope_id), move(is_instantiated), move(parsed_function)))); return o; }
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedFunction("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}, ", visibility));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_id: "));TRY(builder.appendff("{}, ", return_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_span: "));TRY(builder.appendff("{}, ", return_type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}, ", params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_params: "));TRY(builder.appendff("{}, ", generic_params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}, ", block));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type: "));TRY(builder.appendff("{}, ", type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("linkage: "));TRY(builder.appendff("{}, ", linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("function_scope_id: "));TRY(builder.appendff("{}, ", function_scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_instantiated: "));TRY(builder.appendff("{}, ", is_instantiated));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_function: "));TRY(builder.appendff("{}", parsed_function));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ResolvedNamespace {
  public:
String name;Optional<Array<typechecker::TypeId>> generic_parameters;ResolvedNamespace(String a_name, Optional<Array<typechecker::TypeId>> a_generic_parameters) :name(a_name), generic_parameters(a_generic_parameters){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ResolvedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}", generic_parameters));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace FunctionGenericParameter_Details {
struct InferenceGuide{
typechecker::TypeId value;
template<typename... Args>
InferenceGuide(Args&&... args): value { forward<Args>(args)... } {}
};
struct Parameter{
typechecker::TypeId value;
template<typename... Args>
Parameter(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct FunctionGenericParameter : public Variant<FunctionGenericParameter_Details::InferenceGuide, FunctionGenericParameter_Details::Parameter> {
using Variant<FunctionGenericParameter_Details::InferenceGuide, FunctionGenericParameter_Details::Parameter>::Variant;
    using InferenceGuide = FunctionGenericParameter_Details::InferenceGuide;
    using Parameter = FunctionGenericParameter_Details::Parameter;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] InferenceGuide const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionGenericParameter::InferenceGuide"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Parameter const& that) -> ErrorOr<void> {
TRY(builder.append("FunctionGenericParameter::Parameter"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; }));return builder.to_string();}typechecker::TypeId type_id() const;
};
static typechecker::TypeId void_type_id() {
{
return (typechecker::builtin(BuiltinType::Void));
}
}

static typechecker::TypeId expression_type(const NonnullRefPtr<typechecker::CheckedExpression> expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Bool));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::String));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CChar));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).type_id));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).type_id));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();typechecker::CheckedEnumVariantBinding const& arg = __jakt_match_value.arg;
return JaktInternal::ExplicitValue(((arg).type_id));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedExpression::Garbage>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool expression_can_throw(const NonnullRefPtr<typechecker::CheckedExpression> expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(((call).callee_throws));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(((call).callee_throws));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

static typechecker::TypeId builtin(const typechecker::BuiltinType builtin) {
{
return (typechecker::TypeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),(infallible_integer_cast<size_t>(builtin))));
}
}

static typechecker::TypeId unknown_type_id() {
{
return (typechecker::builtin(BuiltinType::Unknown));
}
}

static ErrorOr<typechecker::TypeId> flip_signedness(const NonnullRefPtr<typechecker::Type> type) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U16));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U32));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U64));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I8));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I16));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I32));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I64));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Unknown));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static typechecker::BlockControlFlow checked_expression_control_flow(const NonnullRefPtr<typechecker::CheckedExpression> check_expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *check_expression;
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
bool const& all_variants_constant = __jakt_match_value.all_variants_constant;
return JaktInternal::ExplicitValue(({ Optional<typechecker::BlockControlFlow> __jakt_var_89; {
Optional<typechecker::BlockControlFlow> control_flow = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
const typechecker::BlockControlFlow case_control_flow = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = case_;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if (((control_flow).has_value())){
(control_flow = (((control_flow.value())).unify_with(case_control_flow)));
}
else {
(control_flow = case_control_flow);
}

}

}
}

__jakt_var_89 = control_flow.value_or_lazy_evaluated([&] { return typename typechecker::BlockControlFlow::MayReturn(); }); goto __jakt_label_89;

}
__jakt_label_89:; __jakt_var_89.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((type_id).equals(typechecker::never_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((type_id).equals(typechecker::never_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}

static Optional<typechecker::CheckedNumericConstant> promote(const typechecker::NumberConstant num_const,const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedProgram> program) {
{
if ((!((num_const).can_fit_number(type_id,program)))){
return (JaktInternal::OptionalNone());
}
const i64 bits = ((program)->get_bits(type_id));
const bool is_signed = ((program)->is_signed(type_id));
const typechecker::CheckedNumericConstant new_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, Optional<typechecker::CheckedNumericConstant>>{
auto&& __jakt_match_variant = num_const;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U8((infallible_integer_cast<u8>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U16((infallible_integer_cast<u16>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U32((infallible_integer_cast<u32>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U64((infallible_integer_cast<u64>(value))));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64(value));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
}()))
);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U8((infallible_integer_cast<u8>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U16((infallible_integer_cast<u16>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U32((infallible_integer_cast<u32>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U64(value));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>(value))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64((infallible_integer_cast<i64>(value))));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
}()))
);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedNumericConstant> __jakt_var_90; {
utility::todo(String("Add conversion from f64 to f32"));
__jakt_var_90 = typename typechecker::CheckedNumericConstant::I64(static_cast<i64>(0LL)); goto __jakt_label_90;

}
__jakt_label_90:; __jakt_var_90.release_value(); }));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::F64(value));
}
else {
{
utility::panic(String("Floating numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
{
utility::panic(String("Floating numeric constant cannot be unsigned"));
}
}
}()))
);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (new_constant);
}
}

static typechecker::TypeId never_type_id() {
{
return (typechecker::builtin(BuiltinType::Never));
}
}

bool typechecker::CheckedProgram::is_floating(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::ScopeId typechecker::CheckedProgram::prelude_scope_id() const {
{
return (typechecker::ScopeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL)));
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::CheckedProgram::find_struct_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
Optional<typechecker::ScopeId> current_scope_id = (scope_id);
while (((current_scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope((current_scope_id.value())))));
const Optional<typechecker::StructId> maybe_scope = ((((scope)->structs)).get(name));
if (((maybe_scope).has_value())){
return (maybe_scope);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!((((child_scope)->namespace_name)).has_value()))){
const Optional<typechecker::StructId> maybe_scope = ((((child_scope)->structs)).get(name));
if (((maybe_scope).has_value())){
return (maybe_scope);
}
}
}

}
}

(current_scope_id = ((scope)->parent));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<void> typechecker::CheckedProgram::set_loaded_module(const String module_name,const typechecker::LoadedModule loaded_module) {
{
TRY((((((*this).loaded_modules)).set(module_name,loaded_module))));
}
return {};
}

bool typechecker::CheckedProgram::is_integer(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

NonnullRefPtr<typechecker::Module> typechecker::CheckedProgram::get_module(const typechecker::ModuleId id) const {
{
return (((((*this).modules))[((id).id)]));
}
}

bool typechecker::CheckedProgram::is_numeric(const typechecker::TypeId type_id) const {
{
return ((((*this).is_integer(type_id)) || ((*this).is_floating(type_id))));
}
}

bool typechecker::CheckedProgram::is_string(const typechecker::TypeId type_id) const {
{
return ((((*this).get_type(type_id)))->has<typechecker::Type::JaktString>());
}
}

typechecker::CheckedVariable typechecker::CheckedProgram::get_variable(const typechecker::VarId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->variables))[((id).id)]));
}
}

NonnullRefPtr<typechecker::CheckedFunction> typechecker::CheckedProgram::get_function(const typechecker::FunctionId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->functions))[((id).id)]));
}
}

i64 typechecker::CheckedProgram::get_bits(const typechecker::TypeId type_id) const {
{
return (((((*this).get_type(type_id)))->get_bits()));
}
}

NonnullRefPtr<typechecker::Type> typechecker::CheckedProgram::get_type(const typechecker::TypeId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->types))[((id).id)]));
}
}

ErrorOr<typechecker::StructId> typechecker::CheckedProgram::find_struct_in_prelude(const String name) const {
{
const typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,name))));
if (((struct_id).has_value())){
return (((struct_id).value()));
}
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("internal error: {} builtin definition not found"),name)))))));
}
}

typechecker::CheckedEnum typechecker::CheckedProgram::get_enum(const typechecker::EnumId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->enums))[((id).id)]));
}
}

ErrorOr<String> typechecker::CheckedProgram::type_name(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("never"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("usize"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("c_char"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("c_int"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(String("unknown"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_91; {
Array<String> param_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((params).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId x = (_magic_value.value());
{
TRY((((param_names).push(TRY((((*this).type_name(x))))))));
}

}
}

const String return_type = TRY((((*this).type_name(return_type_id))));
__jakt_var_91 = TRY((String::formatted(String("function({}) -> {}"),utility::join(param_names,String(", ")),return_type))); goto __jakt_label_91;

}
__jakt_label_91:; __jakt_var_91.release_value(); }));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(id))).name));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(id))).name));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_92; {
String output = TRY((String::formatted(String("enum {}"),((((*this).get_enum(id))).name))));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(">"));
__jakt_var_92 = output; goto __jakt_label_92;

}
__jakt_label_92:; __jakt_var_92.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_93; {
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((*this).find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
String output = String("");
if (((id).equals(array_struct_id))){
(output = TRY((String::formatted(String("[{}]"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(dictionary_struct_id))){
(output = TRY((String::formatted(String("[{}:{}]"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)]))))),TRY((((*this).type_name(((args)[static_cast<i64>(1LL)])))))))));
}
else if (((id).equals(optional_struct_id))){
(output = TRY((String::formatted(String("{}?"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(range_struct_id))){
(output = TRY((String::formatted(String("{}..{}"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)]))))),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(set_struct_id))){
(output = TRY((String::formatted(String("{{{}}}"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(tuple_struct_id))){
(output = String("("));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(")"));
}
else if (((id).equals(weak_ptr_struct_id))){
(output = TRY((String::formatted(String("weak {}?"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else {
const typechecker::CheckedStruct structure = ((*this).get_struct(id));
(output = ((structure).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(">"));
}

__jakt_var_93 = output; goto __jakt_label_93;

}
__jakt_label_93:; __jakt_var_93.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_94; {
String output = ((((*this).get_struct(id))).name);
bool first = true;
(output += String("<"));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(type_id)))));
}

}
}

(output += String(">"));
__jakt_var_94 = output; goto __jakt_label_94;

}
__jakt_label_94:; __jakt_var_94.release_value(); }));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("raw {}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&mut {}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<Optional<typechecker::CheckedVariable>> typechecker::CheckedProgram::find_var_in_scope(const typechecker::ScopeId scope_id,const String var) const {
{
typechecker::ScopeId current_scope_id = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current_scope_id))));
const Optional<typechecker::VarId> maybe_var = ((((scope)->vars)).get(var));
if (((maybe_var).has_value())){
return (((*this).get_variable((maybe_var.value()))));
}
if ((!((((scope)->parent)).has_value()))){
break;
}
(current_scope_id = (((scope)->parent).value()));
}
return (JaktInternal::OptionalNone());
}
}

typechecker::CheckedStruct typechecker::CheckedProgram::get_struct(const typechecker::StructId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->structures))[((id).id)]));
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::CheckedProgram::check_and_extract_weak_ptr(const typechecker::StructId struct_id,const Array<typechecker::TypeId> args) const {
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((struct_id).equals(weak_ptr_struct_id))){
if ((((args).size()) != static_cast<size_t>(1ULL))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("Internal error: Generic type is WeakPtr but there are not exactly 1 type parameter. There are {} parameters."),((args).size()))))))));
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
const NonnullRefPtr<typechecker::Type> inner_type = ((*this).get_type(inner_type_id));
if ((inner_type)->has<typechecker::Type::Struct>()){
const typechecker::StructId inner_struct_id = (inner_type->get<typechecker::Type::Struct>()).value;
return (inner_struct_id);
}
utility::panic(TRY((String::formatted(String("Internal error: Inner type of WeakPtr is not a struct. It is {}."),inner_type))));
}
else {
return (JaktInternal::OptionalNone());
}

}
}

ErrorOr<Optional<typechecker::EnumId>> typechecker::CheckedProgram::find_enum_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::EnumId> maybe_enum = ((((scope)->enums)).get(name));
if (((maybe_enum).has_value())){
return (maybe_enum);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!((((child_scope)->namespace_name)).has_value()))){
const Optional<typechecker::EnumId> maybe_enum = ((((child_scope)->enums)).get(name));
if (((maybe_enum).has_value())){
return (maybe_enum);
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

Optional<typechecker::LoadedModule> typechecker::CheckedProgram::get_loaded_module(const String module_name) const {
{
return (((((*this).loaded_modules)).get(module_name)));
}
}

bool typechecker::CheckedProgram::is_signed(const typechecker::TypeId type_id) const {
{
return (((((*this).get_type(type_id)))->is_signed()));
}
}

ErrorOr<NonnullRefPtr<typechecker::Scope>> typechecker::CheckedProgram::get_scope(const typechecker::ScopeId id) const {
{
const size_t max_scope = (JaktInternal::checked_sub<size_t>(((((((((*this).modules))[((((id).module_id)).id)]))->scopes)).size()),static_cast<size_t>(1ULL)));
if ((((id).id) > max_scope)){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("scope_id {} does not exist in module"),id)))))));
}
return (((((((((*this).modules))[((((id).module_id)).id)]))->scopes))[((id).id)]));
}
}

bool typechecker::FunctionId::equals(const typechecker::FunctionId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Module::new_type_variable() {
{
const size_t new_id = ((((*this).types)).size());
TRY((((((*this).types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(TRY((String::formatted(String("T{}"),new_id))))))))));
return (typechecker::TypeId(((*this).id),new_id));
}
}

ErrorOr<typechecker::FunctionId> typechecker::Module::add_function(const NonnullRefPtr<typechecker::CheckedFunction> checked_function) {
{
const typechecker::FunctionId new_id = ((*this).next_function_id());
TRY((((((*this).functions)).push(checked_function))));
return (new_id);
}
}

ErrorOr<typechecker::VarId> typechecker::Module::add_variable(const typechecker::CheckedVariable checked_variable) {
{
const size_t new_id = ((((*this).variables)).size());
TRY((((((*this).variables)).push(checked_variable))));
return (typechecker::VarId(((*this).id),new_id));
}
}

typechecker::FunctionId typechecker::Module::next_function_id() const {
{
return (typechecker::FunctionId(((*this).id),((((*this).functions)).size())));
}
}

bool typechecker::CheckedFunction::is_static() const {
{
if ((((((*this).params)).size()) < static_cast<size_t>(1ULL))){
return (true);
}
return ((((((((((*this).params))[static_cast<i64>(0LL)])).variable)).name) != String("this")));
}
}

bool typechecker::CheckedFunction::is_mutating() const {
{
if ((((((*this).params)).size()) < static_cast<size_t>(1ULL))){
return (false);
}
const typechecker::CheckedVariable first_param_variable = ((((((*this).params))[static_cast<i64>(0LL)])).variable);
return (((((first_param_variable).name) == String("this")) && ((first_param_variable).is_mutable)));
}
}

parser::ParsedFunction typechecker::CheckedFunction::to_parsed_function() const {
{
if ((!((((*this).parsed_function)).has_value()))){
utility::panic(String("to_parsed_function() called on a synthetic function"));
}
return ((((*this).parsed_function).value()));
}
}

bool typechecker::EnumId::equals(const typechecker::EnumId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

bool typechecker::StructId::equals(const typechecker::StructId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

bool typechecker::ScopeId::equals(const typechecker::ScopeId other) const {
{
return (((((((*this).module_id)).id) == ((((other).module_id)).id)) && (((*this).id) == ((other).id))));
}
}

bool typechecker::Typechecker::is_floating(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_floating(type_id)));
}
}

ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>> typechecker::Typechecker::typecheck_match_body(const parser::ParsedMatchBody body,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Dictionary<String,String> generic_inferences,const Optional<typechecker::TypeId> final_result_type,const utility::Span span) {
{
Optional<typechecker::TypeId> result_type = final_result_type;
const typechecker::CheckedMatchBody checked_match_body = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedMatchBody, ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchBody::Block>();
parser::ParsedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedMatchBody> __jakt_var_95; {
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode))));
if ((((((checked_block).control_flow)).may_return()) || ((((checked_block).yielded_type)).has_value()))){
const typechecker::TypeId block_type_id = ((checked_block).yielded_type).value_or_lazy_evaluated([&] { return typechecker::void_type_id(); });
const utility::Span yield_span = ((block).find_yield_span()).value_or_lazy_evaluated([&] { return span; });
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),block_type_id,generic_inferences,yield_span))));
}
else {
(result_type = block_type_id);
}

}
Optional<typechecker::CheckedMatchBody> final_body = JaktInternal::OptionalNone();
if ((((((checked_block).yielded_type)).has_value()) && (!((((checked_block).control_flow)).never_returns())))){
(final_body = typename typechecker::CheckedMatchBody::Expression(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Block>(checked_block,span,(((checked_block).yielded_type).value()))))));
}
else {
(final_body = typename typechecker::CheckedMatchBody::Block(checked_block));
}

__jakt_var_95 = (final_body.value()); goto __jakt_label_95;

}
__jakt_label_95:; __jakt_var_95.release_value(); }));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchBody::Expression>();
NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedMatchBody> __jakt_var_96; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expression = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,result_type))));
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),typechecker::expression_type(checked_expression),generic_inferences,span))));
}
else {
(result_type = typechecker::expression_type(checked_expression));
}

__jakt_var_96 = typename typechecker::CheckedMatchBody::Expression(checked_expression); goto __jakt_label_96;

}
__jakt_label_96:; __jakt_var_96.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return ((Tuple{checked_match_body, result_type}));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_predecl(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const size_t module_struct_len = ((((((*this).current_module()))->structures)).size());
const size_t module_enum_len = ((((((*this).current_module()))->enums)).size());
size_t struct_index = static_cast<size_t>(0ULL);
size_t enum_index = static_cast<size_t>(0ULL);
{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,(struct_index++),module_struct_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,(struct_index++),module_struct_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,(enum_index++),module_enum_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,(enum_index++),module_enum_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedNamespace> _magic = ((((parsed_namespace).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedNamespace namespce = (_magic_value.value());
{
String debug_name = String("namespace(");
if (((((namespce).name)).has_value())){
(debug_name += (((namespce).name).value()));
}
else {
(debug_name += String("unnamed-namespace"));
}

(debug_name += String(")"));
const typechecker::ScopeId namespace_scope_id = TRY((((*this).create_scope(scope_id,false,debug_name))));
NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(namespace_scope_id))));
(((child_scope)->namespace_name) = ((namespce).name));
(((child_scope)->import_path_if_extern) = ((namespce).import_path_if_extern));
NonnullRefPtr<typechecker::Scope> parent_scope = TRY((((*this).get_scope(scope_id))));
TRY((((((parent_scope)->children)).push(namespace_scope_id))));
TRY((((*this).typecheck_namespace_predecl(namespce,namespace_scope_id))));
}

}
}

(struct_index = static_cast<size_t>(0ULL));
(enum_index = static_cast<size_t>(0ULL));
{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
const typechecker::StructId struct_id = typechecker::StructId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(struct_index,module_struct_len)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
(struct_index++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
(struct_index++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
(enum_index++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
(enum_index++);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!((enum_id).has_value()))){
TRY((((((*this).compiler))->panic(String("can't find enum that has been previous added")))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!((enum_id).has_value()))){
TRY((((((*this).compiler))->panic(String("can't find enum that has been previous added")))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
TRY((((*this).typecheck_function_predecl(fun,scope_id,JaktInternal::OptionalNone()))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_set(const Array<NonnullRefPtr<parser::ParsedExpression>> values,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
Optional<utility::Span> inner_type_span = JaktInternal::OptionalNone();
Array<NonnullRefPtr<typechecker::CheckedExpression>> output = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
Optional<typechecker::TypeId> inner_hint = JaktInternal::OptionalNone();
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_value);
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
if ((((current_value_type_id).equals(typechecker::void_type_id())) || ((current_value_type_id).equals(typechecker::unknown_type_id())))){
TRY((((*this).error(String("Cannot create a set with values of type void"),((value)->span())))));
}
(inner_type_id = current_value_type_id);
(inner_type_span = ((value)->span()));
}
else if ((!((inner_type_id).equals(current_value_type_id)))){
const String set_type_name = TRY((((*this).type_name(inner_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in set"),TRY((((*this).type_name(current_value_type_id)))),set_type_name))),((value)->span()),TRY((String::formatted(String("Set was inferred to store type '{}' here"),set_type_name))),(inner_type_span.value())))));
}
TRY((((output).push(checked_value))));
}

}
}

if ((((inner_type_id).equals(typechecker::unknown_type_id())) && (((type_hint).has_value()) && (!(((type_hint.value())).equals(typechecker::unknown_type_id())))))){
if ((((*this).get_type((type_hint.value()))))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(set_struct_id))){
(inner_type_id = ((args)[static_cast<i64>(0LL)]));
}
else {
utility::panic(String("expected Set struct"));
}

}
else {
utility::panic(String("expected Set struct"));
}

}
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
TRY((((*this).error(String("Cannot infer generic type for Set<T>"),span))));
}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(set_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktSet>(output,span,type_id,inner_type_id))));
}
}

bool typechecker::Typechecker::is_integer(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_integer(type_id)));
}
}

ErrorOr<void> typechecker::Typechecker::dump_try_hint(const utility::Span span) const {
{
outln(String("{{\"type\":\"try\",\"file_id\":{},\"position\":{}}}"),((((span).file_id)).id),((span).start));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_call(const parser::ParsedCall call,const typechecker::ScopeId caller_scope_id,const utility::Span span,const Optional<NonnullRefPtr<typechecker::CheckedExpression>> this_expr,const Optional<typechecker::StructOrEnumId> parent_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const bool must_be_enum_constructor) {
{
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
typechecker::TypeId return_type = typechecker::builtin(BuiltinType::Void);
Array<typechecker::TypeId> generic_arguments = (TRY((Array<typechecker::TypeId>::create_with({}))));
bool callee_throws = false;
Array<typechecker::ResolvedNamespace> resolved_namespaces = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
Optional<typechecker::FunctionId> resolved_function_id = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> maybe_this_type_id = JaktInternal::OptionalNone();
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
Optional<typechecker::FunctionId> generic_checked_function_to_instantiate = JaktInternal::OptionalNone();
{
ArrayIterator<String> _magic = ((((call).namespace_)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
TRY((((resolved_namespaces).push(typechecker::ResolvedNamespace(name,JaktInternal::OptionalNone())))));
}

}
}

const typechecker::ScopeId callee_scope_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ScopeId,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((parent_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ScopeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (parent_id.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(id))).scope_id));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(id))).scope_id));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(caller_scope_id);
}
}()))
;
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("println")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprint")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("format")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
(resolved_function_id = TRY((((*this).resolve_call(call,resolved_namespaces,span,callee_scope_id,must_be_enum_constructor)))));
if ((!((resolved_function_id).has_value()))){
Array<typechecker::TypeId> checked_type_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,caller_scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(typechecker::CheckedCall(resolved_namespaces,((call).name),args,checked_type_args,resolved_function_id,return_type,callee_throws),span,return_type))));
}
const typechecker::FunctionId function_id = (resolved_function_id.value());
const NonnullRefPtr<typechecker::CheckedFunction> callee = ((*this).get_function(function_id));
(callee_throws = ((callee)->can_throw));
(return_type = ((callee)->return_type_id));
const typechecker::ScopeId scope_containing_callee = (((TRY((((*this).get_scope(((callee)->function_scope_id))))))->parent).value());
TRY((((*this).check_method_access(caller_scope_id,scope_containing_callee,callee,span))));
size_t type_arg_index = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> parsed_type = (_magic_value.value());
{
const typechecker::TypeId checked_type = TRY((((*this).typecheck_typename(parsed_type,caller_scope_id,JaktInternal::OptionalNone()))));
if ((((((callee)->generic_params)).size()) <= type_arg_index)){
TRY((((*this).error(String("Trying to access generic parameter out of bounds"),((parsed_type)->span())))));
continue;
}
const typechecker::TypeId typevar_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = ((((callee)->generic_params))[type_arg_index]);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
TRY((((generic_inferences).set(TRY((((typevar_type_id).to_string()))),TRY((((checked_type).to_string())))))));
({auto& _jakt_ref = type_arg_index;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}

}
}

if (((this_expr).has_value())){
const typechecker::TypeId type_id = typechecker::expression_type((this_expr.value()));
(maybe_this_type_id = type_id);
const NonnullRefPtr<typechecker::Type> param_type = ((*this).get_type(type_id));
if ((param_type)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (param_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (param_type->get<typechecker::Type::GenericInstance>()).args;
const typechecker::CheckedStruct structure = ((*this).get_struct(id));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((structure).generic_parameters)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((generic_inferences).set(TRY((((((((structure).generic_parameters))[i])).to_string()))),TRY((((((args)[i])).to_string())))))));
}

}
}

}
if (((callee)->is_static())){
TRY((((*this).error(String("Cannot call static method on an instance of an object"),span))));
}
if ((((callee)->is_mutating()) && (!((*this).expression_is_mutable((this_expr.value())))))){
TRY((((*this).error(String("Cannot call mutating method on an immutable object instance"),span))));
}
}
const size_t arg_offset = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((this_expr).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(static_cast<size_t>(1ULL));
}
else {
return JaktInternal::ExplicitValue(static_cast<size_t>(0ULL));
}
}()))
;
if ((!((callee)->is_instantiated))){
(generic_checked_function_to_instantiate = (function_id));
}
if ((((((callee)->params)).size()) != (JaktInternal::checked_add<size_t>(((((call).args)).size()),arg_offset)))){
TRY((((*this).error(String("Wrong number of arguments"),span))));
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((i == ((((callee)->params)).size()))){
break;
}
const Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> parsed_label_and_arg = ((((call).args))[i]);
const typechecker::CheckedParameter param = ((((callee)->params))[(JaktInternal::checked_add<size_t>(i,arg_offset))]);
if (((param).requires_label)){
TRY((((*this).validate_argument_label(param,((parsed_label_and_arg).get<0>()),((parsed_label_and_arg).get<1>()),((parsed_label_and_arg).get<2>())))));
}
NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((parsed_label_and_arg).get<2>()),caller_scope_id,safety_mode,((((param).variable)).type_id)))));
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_arg = TRY((((*this).try_to_promote_constant_expr_to_type(((((param).variable)).type_id),checked_arg,span))));
(checked_arg = promoted_arg.value_or_lazy_evaluated([&] { return checked_arg; }));
TRY((((*this).check_types_for_compat(((((param).variable)).type_id),typechecker::expression_type(checked_arg),generic_inferences,((*this).expression_span(checked_arg))))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((type_hint).has_value()) && (!((((type_hint).value())).equals(typechecker::unknown_type_id()))))){
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
TRY((((*this).check_types_for_compat(return_type,(type_hint.value()),generic_inferences,span))));
(((*this).ignore_errors) = old_ignore_errors);
}
(return_type = TRY((((*this).substitute_typevars_in_type(return_type,generic_inferences)))));
if ((((type_hint).has_value()) && (!((((type_hint).value())).equals(typechecker::unknown_type_id()))))){
TRY((((*this).check_types_for_compat((type_hint.value()),return_type,generic_inferences,span))));
}
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((callee)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::FunctionGenericParameter generic_typevar = (_magic_value.value());
{
if ((generic_typevar).has<typechecker::FunctionGenericParameter::Parameter>()){
const typechecker::TypeId id = (generic_typevar.get<typechecker::FunctionGenericParameter::Parameter>()).value;
const Optional<String> substitution = ((generic_inferences).get(TRY((((id).to_string())))));
if (((substitution).has_value())){
TRY((((generic_arguments).push(TRY((typechecker::TypeId::from_string((substitution.value()))))))));
}
else {
TRY((((*this).error(String("Not all generic parameters have known types"),span))));
}

}
}

}
}

}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(return_type = TRY((((*this).substitute_typevars_in_type(return_type,generic_inferences)))));
if ((callee_throws && (!((TRY((((*this).get_scope(caller_scope_id)))))->can_throw)))){
TRY((((*this).error(String("Call to function that may throw needs to be in a try statement or a function marked as throws"),span))));
}
if (((generic_checked_function_to_instantiate).has_value())){
if (((maybe_this_type_id).has_value())){
(maybe_this_type_id = TRY((((*this).substitute_typevars_in_type((maybe_this_type_id.value()),generic_inferences)))));
}
TRY((((*this).typecheck_and_specialize_generic_function((generic_checked_function_to_instantiate.value()),generic_arguments,callee_scope_id,maybe_this_type_id,generic_inferences))));
}
if ((((*this).dump_try_hints) && callee_throws)){
TRY((((*this).dump_try_hint(span))));
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(typechecker::CheckedCall(resolved_namespaces,((call).name),args,generic_arguments,resolved_function_id,return_type,callee_throws),span,return_type))));
}
}

ErrorOr<bool> typechecker::Typechecker::add_type_to_scope(const typechecker::ScopeId scope_id,const String type_name,const typechecker::TypeId type_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::TypeId> found_type_id = ((((scope)->types)).get(type_name));
if ((((found_type_id).has_value()) && (!(((found_type_id.value())).equals(type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Redefinition of type {}"),type_name))),span))));
return (false);
}
TRY((((((scope)->types)).set(type_name,type_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_namespaced_var_or_simple_enum_constructor_call(const String name,const Array<String> namespace_,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const utility::Span span) {
{
Array<typechecker::ScopeId> scopes = (TRY((Array<typechecker::ScopeId>::create_with({scope_id}))));
{
ArrayIterator<String> _magic = ((namespace_).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String ns = (_magic_value.value());
{
const typechecker::ScopeId scope = ((scopes)[(JaktInternal::checked_sub<size_t>(((scopes).size()),static_cast<size_t>(1ULL)))]);
const Optional<Tuple<typechecker::ScopeId,bool>> ns_in_scope = TRY((((*this).find_namespace_in_scope(scope,ns))));
const Optional<typechecker::EnumId> enum_in_scope = TRY((((((*this).program))->find_enum_in_scope(scope,ns))));
typechecker::ScopeId next_scope = scope;
if (((ns_in_scope).has_value())){
(next_scope = (((ns_in_scope.value())).get<0>()));
}
else if (((enum_in_scope).has_value())){
(next_scope = ((((*this).get_enum((enum_in_scope.value())))).scope_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Namespace {} not found"),ns))),span))));
}

TRY((((scopes).push(next_scope))));
}

}
}

const typechecker::ScopeId scope = (((scopes).last()).value());
size_t i = static_cast<size_t>(0ULL);
const size_t min_length = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = ((((scopes).size()) <= ((namespace_).size())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((scopes).size()));
}
else {
return JaktInternal::ExplicitValue(((namespace_).size()));
}
}()))
;
Array<typechecker::CheckedNamespace> checked_namespaces = (TRY((Array<typechecker::CheckedNamespace>::create_with({}))));
while ((i < min_length)){
TRY((((checked_namespaces).push(typechecker::CheckedNamespace(((namespace_)[i]),scope)))));
(i++);
}
const Optional<typechecker::CheckedVariable> var = TRY((((*this).find_var_in_scope(scope,name))));
if (((var).has_value())){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NamespacedVar>(checked_namespaces,(var.value()),span))));
}
const parser::ParsedCall implicit_constructor_call = parser::ParsedCall(namespace_,name,(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({})))));
const NonnullRefPtr<typechecker::CheckedExpression> call_expression = TRY((((*this).typecheck_call(implicit_constructor_call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,true))));
const typechecker::TypeId type_id = typechecker::expression_type(call_expression);
const typechecker::CheckedCall call = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedCall, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *call_expression;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(call);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_call returned something other than a CheckedCall")))));
}
};/*case end*/
}/*switch end*/
}()
));
if (((((call).function_id)).has_value())){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(call,span,type_id))));
}
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),name))),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NamespacedVar>(checked_namespaces,typechecker::CheckedVariable(name,typechecker::unknown_type_id(),false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public()),span))));
}
}

ErrorOr<String> typechecker::Typechecker::type_name(const typechecker::TypeId type_id) const {
{
return (TRY((((((*this).program))->type_name(type_id)))));
}
}

NonnullRefPtr<typechecker::Module> typechecker::Typechecker::current_module() const {
{
return (((((*this).program))->get_module(((*this).current_module_id))));
}
}

ErrorOr<void> typechecker::Typechecker::error_with_hint(const String message,const utility::Span span,const String hint,const utility::Span hint_span) {
{
if ((!((*this).ignore_errors))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::MessageWithHint(message,span,hint,hint_span)))));
}
}
return {};
}

ErrorOr<Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>>> typechecker::Typechecker::find_type_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::TypeId> maybe_type = ((((scope)->types)).get(name));
if (((maybe_type).has_value())){
return ((Tuple{(maybe_type.value()), current}));
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!((((child_scope)->namespace_name)).has_value()))){
const Optional<typechecker::TypeId> maybe_type = ((((child_scope)->types)).get(name));
if (((maybe_type).has_value())){
return ((Tuple{(maybe_type.value()), child_id}));
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((module)->types)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t id = (_magic_value.value());
{
if (((((((module)->types))[id]))->equals(type))){
return (typechecker::TypeId(((module)->id),id));
}
}

}
}

}

}
}

TRY((((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->types)).push(type))));
return (typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<Optional<Tuple<typechecker::ScopeId,bool>>> typechecker::Typechecker::find_namespace_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child))));
if (((((child_scope)->namespace_name)).has_value())){
if ((name == ((((child_scope)->namespace_name)).value()))){
return ((Tuple{child, false}));
}
}
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!((((child_scope)->namespace_name)).has_value()))){
{
ArrayIterator<typechecker::ScopeId> _magic = ((((TRY((((*this).get_scope(child_id)))))->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId scope = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> descendant_scope = TRY((((*this).get_scope(scope))));
if (((((descendant_scope)->namespace_name)).has_value())){
if ((name == ((((descendant_scope)->namespace_name)).value()))){
return ((Tuple{scope, false}));
}
}
}

}
}

}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
const typechecker::ModuleId module_id = ((scope_id).module_id);
const typechecker::ScopeId search_scope_id = typechecker::ScopeId(module_id,static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> search_scope = TRY((((*this).get_scope(search_scope_id))));
const Dictionary<String,typechecker::ModuleId> search_imports = ((search_scope)->imports);
const Optional<typechecker::ModuleId> maybe_import = ((search_imports).get(name));
if (((maybe_import).has_value())){
const typechecker::ModuleId import_module_id = (maybe_import.value());
const typechecker::ScopeId import_scope_id = typechecker::ScopeId(import_module_id,static_cast<size_t>(0ULL));
return ((Tuple{import_scope_id, true}));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_match(const NonnullRefPtr<parser::ParsedExpression> expr,const Array<parser::ParsedMatchCase> cases,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId subject_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> type_to_match_on = ((*this).get_type(subject_type_id));
Array<typechecker::CheckedMatchCase> checked_cases = (TRY((Array<typechecker::CheckedMatchCase>::create_with({}))));
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
Optional<typechecker::TypeId> final_result_type = JaktInternal::OptionalNone();
if ((type_to_match_on)->has<typechecker::Type::GenericEnumInstance>()){
const typechecker::EnumId id = (type_to_match_on->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> args = (type_to_match_on->get<typechecker::Type::GenericEnumInstance>()).args;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(id));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((enum_).generic_parameters)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const String generic = TRY((((((((enum_).generic_parameters))[i])).to_string())));
const String argument_type = TRY((((((args)[i])).to_string())));
TRY((((generic_inferences).set(generic,argument_type))));
}

}
}

}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *type_to_match_on;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
Set<String> covered_variants = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if ((((variant_names).size()) == static_cast<size_t>(1ULL))){
const Tuple<String,utility::Span> temp = ((variant_names)[static_cast<i64>(0LL)]);
(variant_names = (TRY((Array<Tuple<String,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names)[static_cast<i64>(0LL)])).get<1>())}), temp})))));
}
if (((variant_names).is_empty())){
return JaktInternal::LoopContinue{};
}
if ((((((variant_names)[static_cast<i64>(0LL)])).get<0>()) != ((enum_).name))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' does not match enum '{}'"),((((variant_names)[static_cast<i64>(0LL)])).get<0>()),((enum_).name)))),((((variant_names)[static_cast<i64>(0LL)])).get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
Optional<typechecker::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant v = (_magic_value.value());
{
if ((((v).name()) == ((((variant_names)[static_cast<i64>(1LL)])).get<0>()))){
(matched_variant = v);
(variant_index = i);
}
(i++);
}

}
}

if ((!((matched_variant).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Enum '{}' does not contain a variant named '{}'"),((enum_).name),((((variant_names)[static_cast<i64>(1LL)])).get<0>())))),((case_).marker_span)))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,(TRY((Array<typechecker::CheckedMatchCase>::create_with({})))),span,typechecker::unknown_type_id(),false))));
}
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (matched_variant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
TRY((((covered_variants).add(name))));
if ((!((variant_arguments).is_empty()))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' cannot have arguments"),name))),arguments_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((covered_variants).add(name))));
if ((!((variant_arguments).is_empty()))){
if ((((variant_arguments).size()) != static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((String::formatted(String("Match case {} must have exactly one argument"),name))),span))));
}
else {
const parser::EnumVariantPatternArgument variant_argument = ((variant_arguments)[static_cast<i64>(0LL)]);
const typechecker::TypeId variable_type_id = TRY((((*this).substitute_typevars_in_type(type_id,generic_inferences))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant_argument).binding),variable_type_id,false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((variant_argument).binding),var_id,span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
TRY((((covered_variants).add(name))));
Array<typechecker::CheckedVariable> field_variables = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId var_id = (_magic_value.value());
{
TRY((((field_variables).push(((((*this).program))->get_variable(var_id))))));
}

}
}

Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((variant_arguments).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
if ((!((((arg).name)).has_value()))){
bool found_field_name = false;
Array<String> field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
TRY((((field_names).push(((var).name)))));
if ((((var).name) == ((arg).binding))){
(found_field_name = true);
}
}

}
}

if ((!found_field_name)){
Array<String> unused_field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((field_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String field_name = (_magic_value.value());
{
if (((seen_names).contains(field_name))){
continue;
}
TRY((((unused_field_names).push(field_name))));
}

}
}

TRY((((*this).error_with_hint(TRY((String::formatted(String("Match case argument '{}' for struct-like enum variant cannot be anon"),((arg).binding)))),((arg).span),TRY((String::formatted(String("Available arguments are: {}\n"),utility::join(unused_field_names,String(", "))))),((arg).span)))));
continue;
}
}
const String arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); });
if (((seen_names).contains(arg_name))){
TRY((((*this).error(TRY((String::formatted(String("match case argument '{}' is already defined"),arg_name))),((arg).span)))));
continue;
}
TRY((((seen_names).add(arg_name))));
Optional<typechecker::CheckedVariable> matched_field_variable = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
if ((((var).name) == arg_name)){
(matched_field_variable = var);
}
}

}
}

JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((matched_field_variable).has_value()));
if (__jakt_enum_value == true) {
{
const typechecker::TypeId substituted_type_id = TRY((((*this).substitute_typevars_in_type((((matched_field_variable.value())).type_id),(TRY((Dictionary<String, String>::create_with_entries({}))))))));
const utility::Span matched_span = (((matched_field_variable.value())).definition_span);
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint((((matched_field_variable.value())).type_id),((arg).span)))));
}
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((arg).binding),substituted_type_id,false,matched_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((arg).binding),var_id,span))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Match case argument '{}' does not exist in struct-like enum variant '{}'"),arg_name,name))),((arg).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("implement {} match case for matched variant"),matched_variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant(((((variant_names)[static_cast<i64>(1LL)])).get<0>()),variant_arguments,subject_type_id,(variant_index.value()),new_scope_id,checked_body,(((matched_variant.value())).span()));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Multiple catch-all cases in match are not allowed"),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_span = ((case_).marker_span));
}

const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

}

}
}

Array<String> enum_variant_names = (TRY((Array<String>::create_with({}))));
Array<String> missing_variants = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
ArrayIterator<String> _magic = ((enum_variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String variant = (_magic_value.value());
{
if ((!((covered_variants).contains(variant)))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ((((missing_variants).size()) > static_cast<size_t>(0ULL))){
if ((!seen_catch_all)){
StringBuilder str_missing_values = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((missing_variants).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((str_missing_values).append_c_string(((((missing_variants)[i])).c_string())))));
if ((i < (JaktInternal::checked_sub<size_t>(((missing_variants).size()),static_cast<size_t>(1ULL))))){
TRY((((str_missing_values).append_c_string(((String(", ")).c_string())))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("match expression is not exhaustive, missing variants are: {}"),TRY((((str_missing_values).to_string())))))),span))));
}
}
else {
if (seen_catch_all){
TRY((((*this).error(String("all variants are covered, but an irrefutable pattern is also present"),span))));
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& enum_id = __jakt_match_value.id;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
Set<String> covered_variants = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if ((((variant_names).size()) == static_cast<size_t>(1ULL))){
const Tuple<String,utility::Span> temp = ((variant_names)[static_cast<i64>(0LL)]);
(variant_names = (TRY((Array<Tuple<String,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names)[static_cast<i64>(0LL)])).get<1>())}), temp})))));
}
if (((variant_names).is_empty())){
return JaktInternal::LoopContinue{};
}
if ((((((variant_names)[static_cast<i64>(0LL)])).get<0>()) != ((enum_).name))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' does not match enum '{}'"),((((variant_names)[static_cast<i64>(0LL)])).get<0>()),((enum_).name)))),((((variant_names)[static_cast<i64>(0LL)])).get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
Optional<typechecker::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant v = (_magic_value.value());
{
if ((((v).name()) == ((((variant_names)[static_cast<i64>(1LL)])).get<0>()))){
(matched_variant = v);
(variant_index = i);
}
(i++);
}

}
}

if ((!((matched_variant).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Enum '{}' does not contain a variant named '{}'"),((enum_).name),((((variant_names)[static_cast<i64>(1LL)])).get<0>())))),((case_).marker_span)))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,(TRY((Array<typechecker::CheckedMatchCase>::create_with({})))),span,typechecker::unknown_type_id(),false))));
}
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (matched_variant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
TRY((((covered_variants).add(name))));
if ((!((variant_arguments).is_empty()))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' cannot have arguments"),name))),arguments_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((covered_variants).add(name))));
if ((!((variant_arguments).is_empty()))){
if ((((variant_arguments).size()) != static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((String::formatted(String("Match case {} must have exactly one argument"),name))),span))));
}
else {
const parser::EnumVariantPatternArgument variant_argument = ((variant_arguments)[static_cast<i64>(0LL)]);
const typechecker::TypeId variable_type_id = TRY((((*this).substitute_typevars_in_type(type_id,generic_inferences))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant_argument).binding),variable_type_id,false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((variant_argument).binding),var_id,span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
TRY((((covered_variants).add(name))));
Array<typechecker::CheckedVariable> field_variables = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId var_id = (_magic_value.value());
{
TRY((((field_variables).push(((((*this).program))->get_variable(var_id))))));
}

}
}

Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((variant_arguments).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
if ((!((((arg).name)).has_value()))){
bool found_field_name = false;
Array<String> field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
TRY((((field_names).push(((var).name)))));
if ((((var).name) == ((arg).binding))){
(found_field_name = true);
}
}

}
}

if ((!found_field_name)){
Array<String> unused_field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((field_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String field_name = (_magic_value.value());
{
if (((seen_names).contains(field_name))){
continue;
}
TRY((((unused_field_names).push(field_name))));
}

}
}

TRY((((*this).error_with_hint(TRY((String::formatted(String("Match case argument '{}' for struct-like enum variant cannot be anon"),((arg).binding)))),((arg).span),TRY((String::formatted(String("Available arguments are: {}\n"),utility::join(unused_field_names,String(", "))))),((arg).span)))));
continue;
}
}
const String arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); });
if (((seen_names).contains(arg_name))){
TRY((((*this).error(TRY((String::formatted(String("match case argument '{}' is already defined"),arg_name))),((arg).span)))));
continue;
}
TRY((((seen_names).add(arg_name))));
Optional<typechecker::CheckedVariable> matched_field_variable = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
if ((((var).name) == arg_name)){
(matched_field_variable = var);
}
}

}
}

JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((matched_field_variable).has_value()));
if (__jakt_enum_value == true) {
{
const typechecker::TypeId substituted_type_id = TRY((((*this).substitute_typevars_in_type((((matched_field_variable.value())).type_id),(TRY((Dictionary<String, String>::create_with_entries({}))))))));
const utility::Span matched_span = (((matched_field_variable.value())).definition_span);
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint((((matched_field_variable.value())).type_id),((arg).span)))));
}
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((arg).binding),substituted_type_id,false,matched_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((arg).binding),var_id,span))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Match case argument '{}' does not exist in struct-like enum variant '{}'"),arg_name,name))),((arg).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("implement {} match case for matched variant"),matched_variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant(((((variant_names)[static_cast<i64>(1LL)])).get<0>()),variant_arguments,subject_type_id,(variant_index.value()),new_scope_id,checked_body,(((matched_variant.value())).span()));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Multiple catch-all cases in match are not allowed"),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_span = ((case_).marker_span));
}

const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

}

}
}

Array<String> enum_variant_names = (TRY((Array<String>::create_with({}))));
Array<String> missing_variants = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
ArrayIterator<String> _magic = ((enum_variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String variant = (_magic_value.value());
{
if ((!((covered_variants).contains(variant)))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ((((missing_variants).size()) > static_cast<size_t>(0ULL))){
if ((!seen_catch_all)){
StringBuilder str_missing_values = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((missing_variants).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((str_missing_values).append_c_string(((((missing_variants)[i])).c_string())))));
if ((i < (JaktInternal::checked_sub<size_t>(((missing_variants).size()),static_cast<size_t>(1ULL))))){
TRY((((str_missing_values).append_c_string(((String(", ")).c_string())))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("match expression is not exhaustive, missing variants are: {}"),TRY((((str_missing_values).to_string())))))),span))));
}
}
else {
if (seen_catch_all){
TRY((((*this).error(String("all variants are covered, but an irrefutable pattern is also present"),span))));
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
{
TRY((((*this).error(String("Can't match on 'void' type"),((*this).expression_span(checked_expr))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
bool is_enum_match = false;
bool is_value_match = false;
bool seen_catch_all = false;
bool all_variants_constant = true;
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if (is_value_match){
TRY((((*this).error(String("Cannot have an enum match case in a match expression containing value matches"),((case_).marker_span)))));
}
if ((((variant_names).size()) == static_cast<size_t>(0ULL))){
TRY((((((*this).compiler))->panic(String("typecheck_match - else - EnumVariant - variant_names.size() == 0")))));
}
(is_enum_match = true);
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant((((((variant_names).last()).value())).get<0>()),variant_arguments,subject_type_id,static_cast<size_t>(0ULL),new_scope_id,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Cannot have multiple catch-all match cases"),((case_).marker_span)))));
}
(seen_catch_all = true);
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::Expression>();
NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.value;
{
if (is_enum_match){
TRY((((*this).error(String("Cannot have a value match case in a match expression containing enum matches"),((case_).marker_span)))));
}
(is_value_match = true);
const NonnullRefPtr<typechecker::CheckedExpression> checked_expression = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,(subject_type_id)))));
if ((!((((checked_expression)->to_number_constant(((*this).program)))).has_value()))){
(all_variants_constant = false);
}
TRY((((*this).check_types_for_compat(typechecker::expression_type(checked_expression),subject_type_id,(TRY((Dictionary<String, String>::create_with_entries({})))),((case_).marker_span)))));
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-expression({})"),expr)))))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,generic_inferences,final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::Expression(checked_expression,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

}

}
}

if ((is_value_match && (!seen_catch_all))){
TRY((((*this).error(String("match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,checked_cases,span,final_result_type.value_or_lazy_evaluated([&] { return typechecker::void_type_id(); }),true))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl(const parser::ParsedRecord parsed_record,const typechecker::EnumId enum_id,const typechecker::ScopeId scope_id) {
{
const typechecker::TypeId enum_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id)))))));
const typechecker::ScopeId enum_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((String::formatted(String("enum({})"),((parsed_record).name))))))));
TRY((((*this).add_enum_to_scope(scope_id,((parsed_record).name),enum_id,((parsed_record).name_span)))));
const bool is_extern = (((parsed_record).definition_linkage)).has<parser::DefinitionLinkage::External>();
const typechecker::TypeId underlying_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();NonnullRefPtr<parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_typename(underlying_type,scope_id,JaktInternal::OptionalNone())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
};/*case end*/
}/*switch end*/
}()
));
const bool is_boxed = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
(((((module)->enums))[((enum_id).id)]) = typechecker::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::CheckedEnumVariant>::create_with({})))),enum_scope_id,((parsed_record).definition_linkage),((parsed_record).record_type),underlying_type_id,enum_type_id,is_boxed));
Array<typechecker::TypeId> generic_parameters = ((((((module)->enums))[((enum_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId parameter_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(parameter_type_id))));
TRY((((*this).add_type_to_scope(enum_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
const parser::ParsedFunction func = ((method).parsed_function);
const typechecker::ScopeId method_scope_id = TRY((((*this).create_scope(enum_scope_id,((func).can_throw),TRY((String::formatted(String("method({}::{})"),((parsed_record).name),((func).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-block({}::{})"),((parsed_record).name),((func).name))))))));
const bool is_generic = ((!((((parsed_record).generic_parameters)).is_empty())) || (!((((func).generic_parameters)).is_empty())));
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((func).name),((func).name_span),((method).visibility),typechecker::unknown_type_id(),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((func).can_throw),((func).type),((func).linkage),method_scope_id,((!is_generic) || is_extern),func)));
TRY((((((module)->functions)).push(checked_function))));
const typechecker::FunctionId function_id = typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL))));
Array<typechecker::FunctionGenericParameter> generic_parameters = (TRY((Array<typechecker::FunctionGenericParameter>::create_with({}))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((func).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((generic_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
if ((!((func).must_instantiate))){
TRY((((*this).add_type_to_scope(method_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
}

}
}

(((checked_function)->generic_params) = generic_parameters);
{
ArrayIterator<parser::ParsedParameter> _magic = ((((func).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
if ((((((param).variable)).name) == String("this"))){
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),enum_type_id,((((param).variable)).is_mutable),((((param).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable)))));
}
else {
const typechecker::TypeId param_type = TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),method_scope_id,((((param).variable)).name)))));
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),param_type,((((param).variable)).is_mutable),((((param).variable)).span),((((((param).variable)).parsed_type))->span()),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable)))));
}

}

}
}

TRY((((*this).add_function_to_scope(enum_scope_id,((func).name),function_id,((parsed_record).name_span)))));
}

}
}

}
return {};
}

ErrorOr<Optional<typechecker::CheckedEnumVariant>> typechecker::Typechecker::get_enum_variant(const typechecker::CheckedEnum enum_,const String variant_name) {
{
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == variant_name)){
return (variant);
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

typechecker::ScopeId typechecker::Typechecker::root_scope_id() const {
{
return (typechecker::ScopeId(typechecker::ModuleId(static_cast<size_t>(1ULL)),static_cast<size_t>(0ULL)));
}
}

ErrorOr<Optional<typechecker::FunctionId>> typechecker::Typechecker::find_function_in_scope(const typechecker::ScopeId parent_scope_id,const String function_name) const {
{
Array<typechecker::ScopeId> visited = (TRY((Array<typechecker::ScopeId>::create_with({}))));
Array<typechecker::ScopeId> queue = (TRY((Array<typechecker::ScopeId>::create_with({parent_scope_id}))));
Optional<typechecker::ScopeId> scope_id = (parent_scope_id);
while ((!((queue).is_empty()))){
const typechecker::ScopeId scope_id = (((queue).pop()).value());
{
bool was_visited = false;
{
ArrayIterator<typechecker::ScopeId> _magic = ((visited).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId visited_id = (_magic_value.value());
{
if (((visited_id).equals(scope_id))){
(was_visited = true);
break;
}
}

}
}

if (was_visited){
continue;
}
}

TRY((((visited).push(scope_id))));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::FunctionId> maybe_function = ((((scope)->functions)).get(function_name));
if (((maybe_function).has_value())){
return (maybe_function);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_scope_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(child_scope_id))));
if ((!((((scope)->namespace_name)).has_value()))){
TRY((((queue).push(child_scope_id))));
}
}

}
}

if (((((scope)->parent)).has_value())){
const typechecker::ScopeId parent = (((scope)->parent).value());
if (((parent).equals(scope_id))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("Scope {} is its own parent!"),scope_id)))))));
}
TRY((((queue).push(parent))));
}
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_loop(const parser::ParsedBlock parsed_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A loop block is not allowed to yield values"),(((parsed_block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Loop>(checked_block,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_defer(const NonnullRefPtr<parser::ParsedStatement> statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const bool was_inside_defer = ((*this).inside_defer);
(((*this).inside_defer) = true);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).inside_defer) = was_inside_defer);
});
const NonnullRefPtr<typechecker::CheckedStatement> checked_statement = TRY((((*this).typecheck_statement(statement,scope_id,safety_mode))));
if ((checked_statement)->has<typechecker::CheckedStatement::Block>()){
const typechecker::CheckedBlock block = (checked_statement->get<typechecker::CheckedStatement::Block>()).block;
if (((((block).yielded_type)).has_value())){
TRY((((*this).error(String("yield inside defer is meaningless"),span))));
}
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Defer>(checked_statement,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_unary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr,const typechecker::CheckedUnaryOperator checked_op,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> expr_type = ((*this).get_type(expr_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = checked_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreIncrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!((*this).expression_is_mutable(checked_expr)))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostIncrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!((*this).expression_is_mutable(checked_expr)))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreDecrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!((*this).expression_is_mutable(checked_expr)))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostDecrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!((*this).expression_is_mutable(checked_expr)))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::BitwiseNot>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,((cast).type_id())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Negate>();
{
return (TRY((((*this).typecheck_unary_negate(checked_expr,span,expr_type_id)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,typechecker::builtin(BuiltinType::Bool)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedUnaryOperator::IsEnumVariant>();{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,typechecker::builtin(BuiltinType::Bool)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::RawAddress>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Reference>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Reference>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::MutableReference>();
{
if ((!((*this).expression_is_mutable(checked_expr)))){
TRY((((*this).error(String("Cannot make mutable reference to immutable value"),span))));
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::MutableReference>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr_type;
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
if ((safety_mode).has<typechecker::SafetyMode::Safe>()){
TRY((((*this).error(String("Dereference of raw pointer outside of unsafe block"),span))));
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Dereference of a non-pointer value"),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_generic_arguments_method_call(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr,const parser::ParsedCall call,const typechecker::ScopeId scope_id,const utility::Span span,const bool is_optional,const typechecker::SafetyMode safety_mode) {
{
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> checked_args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
TRY((((checked_args).ensure_capacity(((((call).args)).size())))));
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> call_arg = (_magic_value.value());
{
const String name = ((call_arg).get<0>());
const NonnullRefPtr<parser::ParsedExpression> expr = ((call_arg).get<2>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> checked_arg = (Tuple{name, checked_arg_expr});
TRY((((checked_args).push(checked_arg))));
}

}
}

Array<typechecker::TypeId> checked_type_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,typechecker::CheckedCall((TRY((Array<typechecker::ResolvedNamespace>::create_with({})))),((call).name),checked_args,checked_type_args,JaktInternal::OptionalNone(),typechecker::unknown_type_id(),false),span,is_optional,typechecker::unknown_type_id()))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_module(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
TRY((((*this).typecheck_namespace_imports(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_predecl(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_fields(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_declarations(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_declarations(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!((struct_id).has_value()))){
TRY((((((*this).compiler))->panic(String("can't find struct that has been previous added")))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!((struct_id).has_value()))){
TRY((((((*this).compiler))->panic(String("can't find struct that has been previous added")))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
(((*this).current_function_id) = TRY((((*this).find_function_in_scope(scope_id,((fun).name))))));
TRY((((*this).typecheck_function(fun,scope_id))));
(((*this).current_function_id) = JaktInternal::OptionalNone());
}

}
}

}
return {};
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::substitute_typevars_in_type(const typechecker::TypeId type_id,const Dictionary<String,String> generic_inferences) {
{
typechecker::TypeId result = TRY((((*this).substitute_typevars_in_type_helper(type_id,generic_inferences))));
for (;;){
const typechecker::TypeId fixed_point = TRY((((*this).substitute_typevars_in_type_helper(type_id,generic_inferences))));
if (((fixed_point).equals(result))){
break;
}
else {
(result = fixed_point);
}

}
return (result);
}
}

ErrorOr<typechecker::StructId> typechecker::Typechecker::find_struct_in_prelude(const String name) const {
{
return (TRY((((((*this).program))->find_struct_in_prelude(name)))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::cast_to_underlying(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const NonnullRefPtr<parser::ParsedType> parsed_type) {
{
const NonnullRefPtr<parser::ParsedExpression> cast_expression = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::TypeCast(typename parser::TypeCast::Infallible(parsed_type)),((expr)->span()))));
return (TRY((((*this).typecheck_expression(cast_expression,scope_id,typename typechecker::SafetyMode::Safe(),JaktInternal::OptionalNone())))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_module_import(const parser::ParsedModuleImport import_,const typechecker::ScopeId scope_id) {
{
typechecker::ModuleId imported_module_id = typechecker::ModuleId(static_cast<size_t>(0ULL));
Optional<typechecker::LoadedModule> maybe_loaded_module = ((((*this).program))->get_loaded_module(((((import_).module_name)).name)));
if ((!((maybe_loaded_module).has_value()))){
const Optional<NonnullRefPtr<utility::FilePath>> maybe_file_name = TRY((((((*this).compiler))->search_for_path(((((import_).module_name)).name)))));
const NonnullRefPtr<utility::FilePath> file_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<utility::FilePath>,ErrorOr<void>>{
auto __jakt_enum_value = (((maybe_file_name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((maybe_file_name.value()));
}
else {
return JaktInternal::ExplicitValue(TRY((utility::FilePath::make(TRY((String::formatted(String("{}{}.jakt"),TRY((((TRY((((*this).get_root_path()))))->dirname()))),((((import_).module_name)).name))))))));
}
}()))
;
const utility::FileId file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
const Optional<parser::ParsedNamespace> parsed_namespace = TRY((((*this).lex_and_parse_file_contents(file_id))));
if ((!((parsed_namespace).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Module '{}' not found"),((((import_).module_name)).name)))),((((import_).module_name)).span)))));
return {};
}
const typechecker::ModuleId original_current_module_id = ((*this).current_module_id);
(imported_module_id = TRY((((*this).create_module(((((import_).module_name)).name),false)))));
TRY((((((*this).program))->set_loaded_module(((((import_).module_name)).name),typechecker::LoadedModule(imported_module_id,file_id)))));
(((*this).current_module_id) = imported_module_id);
const typechecker::ScopeId imported_scope_id = TRY((((*this).create_scope(((*this).root_scope_id()),false,TRY((String::formatted(String("module({})"),((((import_).module_name)).name))))))));
TRY((((*this).typecheck_module((parsed_namespace.value()),imported_scope_id))));
(((*this).current_module_id) = original_current_module_id);
}
else {
(imported_module_id = (((maybe_loaded_module.value())).module_id));
}

Array<typechecker::ModuleId> current_module_imports = ((((*this).current_module()))->imports);
TRY((((current_module_imports).push(imported_module_id))));
if (((((import_).import_list)).is_empty())){
Dictionary<String,typechecker::ModuleId> scope_imports = ((TRY((((*this).get_scope(scope_id)))))->imports);
String import_name = ((((import_).module_name)).name);
if (((((import_).alias_name)).has_value())){
(import_name = (((((import_).alias_name).value())).name));
}
TRY((((scope_imports).set(import_name,imported_module_id))));
}
else {
const typechecker::ScopeId import_scope_id = typechecker::ScopeId(imported_module_id,static_cast<size_t>(0ULL));
{
ArrayIterator<parser::ImportName> _magic = ((((import_).import_list)).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ImportName imported_name = (_magic_value.value());
{
const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_function_id).has_value())){
TRY((((*this).add_function_to_scope(scope_id,((imported_name).name),(maybe_function_id.value()),((imported_name).span)))));
}
const Optional<typechecker::EnumId> maybe_enum_id = TRY((((((*this).program))->find_enum_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_enum_id).has_value())){
TRY((((*this).add_enum_to_scope(scope_id,((imported_name).name),(maybe_enum_id.value()),((imported_name).span)))));
}
const Optional<typechecker::TypeId> maybe_type_id = TRY((((*this).find_type_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_type_id).has_value())){
TRY((((*this).add_type_to_scope(scope_id,((imported_name).name),(maybe_type_id.value()),((imported_name).span)))));
}
const Optional<typechecker::StructId> maybe_struct_id = TRY((((*this).find_struct_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_struct_id).has_value())){
TRY((((*this).add_struct_to_scope(scope_id,((imported_name).name),(maybe_struct_id.value()),((imported_name).span)))));
}
}

}
}

}

}
return {};
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_binary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs,const parser::BinaryOperator op,const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs,const typechecker::ScopeId scope_id,const utility::Span span) {
{
const typechecker::TypeId lhs_type_id = typechecker::expression_type(checked_lhs);
const typechecker::TypeId rhs_type_id = typechecker::expression_type(checked_rhs);
const utility::Span lhs_span = ((*this).expression_span(checked_lhs));
const utility::Span rhs_span = ((*this).expression_span(checked_rhs));
typechecker::TypeId type_id = typechecker::expression_type(checked_lhs);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
{
if ((op).has<parser::BinaryOperator::NoneCoalescingAssign>()){
if ((checked_lhs)->has<typechecker::CheckedExpression::Var>()){
const typechecker::CheckedVariable var = (checked_lhs->get<typechecker::CheckedExpression::Var>()).var;
const utility::Span span = (checked_lhs->get<typechecker::CheckedExpression::Var>()).span;
if ((!((var).is_mutable))){
TRY((((*this).error_with_hint(String("left-hand side of ??= must be a mutable variable"),span,String("This variable isn't marked as mutable"),((var).definition_span)))));
return (typechecker::unknown_type_id());
}
}
else {
TRY((((*this).error(String("left-hand side of ??= must be a mutable variable"),span))));
return (typechecker::unknown_type_id());
}

}
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (lhs_type_id);
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (inner_type_id);
}
}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

TRY((((*this).error(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
{
if ((op).has<parser::BinaryOperator::NoneCoalescingAssign>()){
if ((checked_lhs)->has<typechecker::CheckedExpression::Var>()){
const typechecker::CheckedVariable var = (checked_lhs->get<typechecker::CheckedExpression::Var>()).var;
const utility::Span span = (checked_lhs->get<typechecker::CheckedExpression::Var>()).span;
if ((!((var).is_mutable))){
TRY((((*this).error_with_hint(String("left-hand side of ??= must be a mutable variable"),span,String("This variable isn't marked as mutable"),((var).definition_span)))));
return (typechecker::unknown_type_id());
}
}
else {
TRY((((*this).error(String("left-hand side of ??= must be a mutable variable"),span))));
return (typechecker::unknown_type_id());
}

}
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (lhs_type_id);
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (inner_type_id);
}
}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

TRY((((*this).error(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
{
if ((!((lhs_type_id).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("left side of logical binary operation is not a boolean"),lhs_span))));
}
if ((!((rhs_type_id).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("right side of logical binary operation is not a boolean"),rhs_span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
{
if ((!((lhs_type_id).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("left side of logical binary operation is not a boolean"),lhs_span))));
}
if ((!((rhs_type_id).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("right side of logical binary operation is not a boolean"),rhs_span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
{
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
return (lhs_type_id);
}
if ((checked_rhs)->has<typechecker::CheckedExpression::OptionalNone>()){
const utility::Span span = (checked_rhs->get<typechecker::CheckedExpression::OptionalNone>()).span;
const typechecker::TypeId type_id = (checked_rhs->get<typechecker::CheckedExpression::OptionalNone>()).type_id;
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
return (lhs_type_id);
}
}
}
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
if ((lhs_type)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (lhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (lhs_type->get<typechecker::Type::GenericInstance>()).args;
if (((((((((*this).program))->get_struct(id))).name) == String("Optional")) && ((typechecker::expression_type(checked_rhs)).equals(((args)[static_cast<i64>(0LL)]))))){
return (lhs_type_id);
}
if (((((((((*this).program))->get_struct(id))).name) == String("WeakPtr")) && ((typechecker::expression_type(checked_rhs)).equals(((args)[static_cast<i64>(0LL)]))))){
return (lhs_type_id);
}
}
const Optional<typechecker::TypeId> result = TRY((((*this).unify(rhs_type_id,rhs_span,lhs_type_id,lhs_span))));
if ((!((result).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
return (((result).value_or(lhs_type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if ((((*this).get_type(lhs_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && (((*this).get_type(((args)[static_cast<i64>(0LL)]))))->has<typechecker::Type::Struct>())){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!((*this).expression_is_mutable(checked_lhs)))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
{
if ((!((lhs_type_id).equals(rhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (type_id);
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::Typechecker::find_struct_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
return (TRY((((((*this).program))->find_struct_in_scope(scope_id,name)))));
}
}

ErrorOr<void> typechecker::Typechecker::check_method_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee,const NonnullRefPtr<typechecker::CheckedFunction> method,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((method)->visibility);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
{
if ((!TRY((((*this).scope_can_access(accessor,accessee)))))){
TRY((((*this).error(TRY((String::formatted(String("Can't access function {} from scope {}, because it is marked private"),((method)->name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();Array<NonnullRefPtr<parser::ParsedType>> const& whitelist = __jakt_match_value.whitelist;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((*this).check_restricted_access(accessor,String("function"),accessee,((method)->name),whitelist,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<typechecker::CheckedBlock> typechecker::Typechecker::typecheck_block(const parser::ParsedBlock parsed_block,const typechecker::ScopeId parent_scope_id,const typechecker::SafetyMode safety_mode) {
{
const bool parent_throws = ((TRY((((*this).get_scope(parent_scope_id)))))->can_throw);
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(parent_scope_id,parent_throws,String("block")))));
typechecker::CheckedBlock checked_block = typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none());
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((parsed_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> parsed_statement = (_magic_value.value());
{
if (((((checked_block).control_flow)).never_returns())){
TRY((((*this).error(String("Unreachable code"),((parsed_statement)->span())))));
}
const NonnullRefPtr<typechecker::CheckedStatement> checked_statement = TRY((((*this).typecheck_statement(parsed_statement,block_scope_id,safety_mode))));
(((checked_block).control_flow) = ((((checked_block).control_flow)).updated(((*this).statement_control_flow(checked_statement)))));
const Optional<utility::Span> yield_span = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<utility::Span>, ErrorOr<typechecker::CheckedBlock>>{
auto&& __jakt_match_variant = *parsed_statement;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((((expr)->span())));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> checked_yield_expression = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<NonnullRefPtr<typechecker::CheckedExpression>>, ErrorOr<typechecker::CheckedBlock>>{
auto&& __jakt_match_variant = *checked_statement;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
if ((((yield_span).has_value()) && ((checked_yield_expression).has_value()))){
const typechecker::TypeId type_var_type_id = typechecker::expression_type(((checked_yield_expression).value()));
const typechecker::TypeId type_ = TRY((((*this).resolve_type_var(type_var_type_id,block_scope_id))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).check_types_for_compat(((((checked_block).yielded_type)).value()),type_,generic_inferences,((yield_span).value())))));
}
else {
(((checked_block).yielded_type) = (type_));
}

}
TRY((((((checked_block).statements)).push(checked_statement))));
}

}
}

if (((((checked_block).yielded_type)).has_value())){
(((checked_block).yielded_type) = (TRY((((*this).substitute_typevars_in_type(((((checked_block).yielded_type)).value()),generic_inferences))))));
}
return (checked_block);
}
}

ErrorOr<Optional<typechecker::TypeId>> typechecker::Typechecker::find_type_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::TypeId> maybe_type = ((((scope)->types)).get(name));
if (((maybe_type).has_value())){
return (maybe_type);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!((((child_scope)->namespace_name)).has_value()))){
const Optional<typechecker::TypeId> maybe_type = ((((child_scope)->types)).get(name));
if (((maybe_type).has_value())){
return (maybe_type);
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_function(const parser::ParsedFunction parsed_function,const typechecker::ScopeId parent_scope_id) {
{
if (((!((((parsed_function).generic_parameters)).is_empty())) && (!((parsed_function).must_instantiate)))){
return {};
}
const Optional<typechecker::FunctionId> function_id = TRY((((*this).find_function_in_scope(parent_scope_id,((parsed_function).name)))));
if ((!((function_id).has_value()))){
TRY((((((*this).compiler))->panic(String("Internal error: missing previously defined function")))));
}
if ((((parsed_function).name) == String("main"))){
TRY((((*this).typecheck_jakt_main(parsed_function))));
}
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function((function_id.value())));
const typechecker::ScopeId function_scope_id = ((checked_function)->function_scope_id);
const parser::FunctionLinkage function_linkage = ((checked_function)->linkage);
Array<typechecker::CheckedVariable> param_vars = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
TRY((((param_vars).push(variable))));
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope(function_scope_id,((variable).name),var_id,((variable).definition_span)))));
}

}
}

typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),function_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
if (((function_return_type_id).equals(typechecker::never_type_id()))){
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(function_scope_id))));
(((scope)->can_throw) = true);
}
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((parsed_function).block),function_scope_id,typename typechecker::SafetyMode::Safe()))));
(function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),function_scope_id,JaktInternal::OptionalNone())))));
const typechecker::TypeId UNKNOWN_TYPE_ID = typechecker::unknown_type_id();
const typechecker::TypeId VOID_TYPE_ID = typechecker::void_type_id();
typechecker::TypeId return_type_id = VOID_TYPE_ID;
if (((function_return_type_id).equals(UNKNOWN_TYPE_ID))){
(return_type_id = ((*this).infer_function_return_type(block)));
}
else {
(return_type_id = TRY((((*this).resolve_type_var(function_return_type_id,function_scope_id)))));
}

const bool external_linkage = (function_linkage).has<parser::FunctionLinkage::External>();
if (((!external_linkage) && ((!((return_type_id).equals(VOID_TYPE_ID))) && (!((((block).control_flow)).always_transfers_control()))))){
if ((((return_type_id).equals(typechecker::never_type_id())) && (!((((block).control_flow)).never_returns())))){
TRY((((*this).error(String("Control reaches end of never-returning function"),((parsed_function).name_span)))));
}
else if ((!((((block).control_flow)).never_returns()))){
TRY((((*this).error(String("Control reaches end of non-void function"),((parsed_function).name_span)))));
}
}
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_inline_cpp(const parser::ParsedBlock block,const utility::Span span,const typechecker::SafetyMode safety_mode) {
{
if ((safety_mode).has<typechecker::SafetyMode::Safe>()){
TRY((((*this).error(String("Use of inline cpp block outside of unsafe block"),span))));
}
Array<String> strings = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> statement = (_magic_value.value());
{
if ((statement)->has<parser::ParsedStatement::Expression>()){
const NonnullRefPtr<parser::ParsedExpression> expr = (statement->get<parser::ParsedStatement::Expression>()).expr;
if ((expr)->has<parser::ParsedExpression::QuotedString>()){
const String val = (expr->get<parser::ParsedExpression::QuotedString>()).val;
const utility::Span span = (expr->get<parser::ParsedExpression::QuotedString>()).span;
TRY((((strings).push(val))));
}
else {
TRY((((*this).error(String("Expected block of strings"),span))));
}

}
else {
TRY((((*this).error(String("Expected block of strings"),span))));
}

}

}
}

return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::InlineCpp>(strings,span))));
}
}

utility::Span typechecker::Typechecker::expression_span(const NonnullRefPtr<typechecker::CheckedExpression> expr) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<void> typechecker::Typechecker::check_restricted_access(const typechecker::ScopeId accessor,const String accessee_kind,const typechecker::ScopeId accessee,const String name,const Array<NonnullRefPtr<parser::ParsedType>> whitelist,const utility::Span span) {
{
if ((!((((*this).current_struct_type_id)).has_value()))){
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from scope {}, because {} is not in the restricted whitelist"),accessee_kind,name,((TRY((((*this).get_scope(accessor)))))->namespace_name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
return {};
}
const typechecker::TypeId own_type_id = (((*this).current_struct_type_id).value());
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(own_type_id));
if ((type)->has<typechecker::Type::Struct>()){
const typechecker::StructId id = (type->get<typechecker::Type::Struct>()).value;
bool was_whitelisted = false;
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((whitelist).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> whitelisted_type = (_magic_value.value());
{
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(whitelisted_type,accessee,JaktInternal::OptionalNone()))));
if (((type_id).equals(own_type_id))){
(was_whitelisted = true);
break;
}
}

}
}

if ((!was_whitelisted)){
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from {}, because {} is not in the restricted whitelist"),accessee_kind,name,((((*this).get_struct(id))).name),((((*this).get_struct(id))).name)))),span))));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from scope {}, because it is not in the restricted whitelist"),accessee_kind,name,((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::include_prelude() {
{
const String module_name = String("__prelude__");
const NonnullRefPtr<utility::FilePath> file_name = TRY((utility::FilePath::make(module_name)));
const Array<u8> file_contents = TRY((prelude::JaktPrelude::to_bytes()));
const Optional<utility::FileId> old_file_id = ((((*this).compiler))->current_file);
const Array<u8> old_file_contents = ((((*this).compiler))->current_file_contents);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{{
(((((*this).compiler))->current_file) = old_file_id);
(((((*this).compiler))->current_file_contents) = old_file_contents);
}

});
const utility::FileId file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
(((((*this).compiler))->current_file) = file_id);
(((((*this).compiler))->current_file_contents) = file_contents);
const typechecker::ModuleId prelude_module_id = TRY((((*this).create_module(module_name,false))));
(((*this).current_module_id) = prelude_module_id);
TRY((((((*this).program))->set_loaded_module(module_name,typechecker::LoadedModule(prelude_module_id,file_id)))));
const typechecker::ScopeId prelude_scope_id = TRY((((*this).create_scope(JaktInternal::OptionalNone(),false,String("prelude")))));
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln(String("{:#}"),parsed_namespace);
}
((((*this).compiler))->dbg_println(TRY((String::formatted(String("before typechecking parsed prelude, modules `{}`"),((((*this).program))->modules))))));
TRY((((*this).typecheck_module(parsed_namespace,prelude_scope_id))));
}
return {};
}

ErrorOr<bool> typechecker::Typechecker::add_function_to_scope(const typechecker::ScopeId parent_scope_id,const String name,const typechecker::FunctionId function_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(parent_scope_id))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> existing_function = (_magic_value.value());
{
if ((name == ((existing_function).get<0>()))){
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((*this).get_function(((existing_function).get<1>())));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Redefinition of function {}"),name))),span,String("previous definition here"),((function_)->name_span)))));
return (false);
}
}

}
}

TRY((((((scope)->functions)).set(name,function_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_while(const NonnullRefPtr<parser::ParsedExpression> condition,const parser::ParsedBlock block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A while block is not allowed to yield values"),(((block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::While>(checked_condition,checked_block,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_expression_and_dereference_if_needed(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const utility::Span span) {
{
NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,type_hint))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
(checked_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,typename typechecker::CheckedUnaryOperator::Dereference(),span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
(checked_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,typename typechecker::CheckedUnaryOperator::Dereference(),span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (checked_expr);
}
}

ErrorOr<NonnullRefPtr<utility::FilePath>> typechecker::Typechecker::get_root_path() const {
{
const utility::FileId file_id = (((((((*this).program))->get_loaded_module(String("Root Module"))).value())).file_id);
return ((TRY((((((*this).compiler))->get_file_path(file_id)))).value()));
}
}

ErrorOr<bool> typechecker::Typechecker::scope_can_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee) const {
{
if (((accessor).equals(accessee))){
return (true);
}
NonnullRefPtr<typechecker::Scope> accessor_scope = TRY((((*this).get_scope(accessor))));
while (((((accessor_scope)->parent)).has_value())){
const typechecker::ScopeId parent = (((accessor_scope)->parent).value());
if (((parent).equals(accessee))){
return (true);
}
(accessor_scope = TRY((((*this).get_scope(parent)))));
}
return (false);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_fields(const parser::ParsedRecord record,const typechecker::StructId struct_id) {
{
typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
const typechecker::ScopeId checked_struct_scope_id = ((((*this).get_struct(struct_id))).scope_id);
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
const Array<parser::ParsedField> parsed_fields = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<parser::ParsedField>, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();Array<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();Array<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_struct_fields cannot handle non-structs")))));
}
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<parser::ParsedField> _magic = ((parsed_fields).iterator());
for (;;){
Optional<parser::ParsedField> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedField unchecked_member = (_magic_value.value());
{
const parser::ParsedVarDecl parsed_var_decl = ((unchecked_member).var_decl);
const typechecker::TypeId checked_member_type = TRY((((*this).typecheck_typename(((parsed_var_decl).parsed_type),checked_struct_scope_id,((parsed_var_decl).name)))));
TRY((((*this).check_that_type_doesnt_contain_reference(checked_member_type,((((parsed_var_decl).parsed_type))->span())))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((parsed_var_decl).name),checked_member_type,((parsed_var_decl).is_mutable),((parsed_var_decl).span),JaktInternal::OptionalNone(),((unchecked_member).visibility))))));
TRY((((((structure).fields)).push(var_id))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_expression(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
String const& field = __jakt_match_value.field;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_struct(expr,field,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Boolean>(val,span))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_97; {
__jakt_var_97 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I8>();
i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I8(val),span,typechecker::builtin(BuiltinType::I8)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I16>();
i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I16(val),span,typechecker::builtin(BuiltinType::I16)))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I32>();
i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I32(val),span,typechecker::builtin(BuiltinType::I32)))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I64>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I64(val),span,typechecker::builtin(BuiltinType::I64)))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U8>();
u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U8(val),span,typechecker::builtin(BuiltinType::U8)))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U16>();
u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U16(val),span,typechecker::builtin(BuiltinType::U16)))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U32>();
u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U32(val),span,typechecker::builtin(BuiltinType::U32)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U64>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U64(val),span,typechecker::builtin(BuiltinType::U64)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::USize>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::USize(val),span,typechecker::builtin(BuiltinType::Usize)))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::F32>();
f32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F32(val),span,typechecker::builtin(BuiltinType::F32)))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::F64>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F64(val),span,typechecker::builtin(BuiltinType::F64)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_97;

}
__jakt_label_97:; __jakt_var_97.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::CharacterConstant>(val,span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::ByteConstant>(val,span))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_98; {
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
TRY((((*this).unify_with_type(typechecker::builtin(BuiltinType::String),type_hint,span))));
__jakt_var_98 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::QuotedString>(val,span))); goto __jakt_label_98;

}
__jakt_label_98:; __jakt_var_98.release_value(); }));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_99; {
__jakt_var_99 = TRY((((*this).typecheck_call(call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,false)))); goto __jakt_label_99;

}
__jakt_label_99:; __jakt_var_99.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_100; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId checked_expr_type_id = typechecker::expression_type(checked_expr);
bool found_optional = false;
const typechecker::StructOrEnumId parent_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(checked_expr_type_id));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(id));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(TRY((((*this).find_struct_in_prelude(String("String")))))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_101; {
__jakt_var_101 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (is_optional);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_102; {
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
Optional<typechecker::StructOrEnumId> struct_id = JaktInternal::OptionalNone();
if ((!((id).equals(optional_struct_id)))){
TRY((((*this).error(TRY((String::formatted(String("Can't use {} as an optional type in optional chained call"),((((*this).get_struct(id))).name)))),span))));
}
else {
(found_optional = true);
(struct_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((args)[static_cast<i64>(0LL)])));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(struct_id));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(struct_id));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_103; {
TRY((((*this).error(String("Can't use non-struct type as an optional type in optional chained call"),span))));
(found_optional = false);
__jakt_var_103 = typename typechecker::StructOrEnumId::Struct(optional_struct_id); goto __jakt_label_103;

}
__jakt_label_103:; __jakt_var_103.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}

__jakt_var_102 = struct_id.value_or_lazy_evaluated([&] { return typename typechecker::StructOrEnumId::Struct(optional_struct_id); }); goto __jakt_label_102;

}
__jakt_label_102:; __jakt_var_102.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(id));
}
}()))
; goto __jakt_label_101;

}
__jakt_label_101:; __jakt_var_101.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("no methods available on value (type: {})"),TRY((((*this).type_name(checked_expr_type_id))))))),((*this).expression_span(checked_expr))))));
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> checked_args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,typechecker::CheckedCall((TRY((Array<typechecker::ResolvedNamespace>::create_with({})))),((call).name),checked_args,(TRY((Array<typechecker::TypeId>::create_with({})))),JaktInternal::OptionalNone(),typechecker::unknown_type_id(),false),span,is_optional,typechecker::unknown_type_id()))));
}
};/*case end*/
}/*switch end*/
}()
));
if ((is_optional && (!found_optional))){
TRY((((*this).error(TRY((String::formatted(String("Optional chain mismatch: expected optional chain, found {}"),TRY((((*this).type_name(checked_expr_type_id))))))),((*this).expression_span(checked_expr))))));
}
const NonnullRefPtr<typechecker::CheckedExpression> checked_call_expr = TRY((((*this).typecheck_call(call,scope_id,span,checked_expr,parent_id,safety_mode,type_hint,false))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_call_expr);
__jakt_var_100 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_call_expr;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_104; {
typechecker::TypeId result_type = ((call).return_type);
if (is_optional){
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
(result_type = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({result_type}))))))))))));
}
__jakt_var_104 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,call,span,is_optional,result_type))); goto __jakt_label_104;

}
__jakt_label_104:; __jakt_var_104.release_value(); }));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_call should return `CheckedExpression::Call()`")))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_100;

}
__jakt_label_100:; __jakt_var_100.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_105; {
NonnullRefPtr<typechecker::CheckedExpression> checked_from = TRY((((*this).typecheck_expression(from,scope_id,safety_mode,JaktInternal::OptionalNone()))));
NonnullRefPtr<typechecker::CheckedExpression> checked_to = TRY((((*this).typecheck_expression(to,scope_id,safety_mode,JaktInternal::OptionalNone()))));
typechecker::TypeId from_type = typechecker::expression_type(checked_from);
typechecker::TypeId to_type = typechecker::expression_type(checked_to);
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_to = TRY((((*this).try_to_promote_constant_expr_to_type(from_type,checked_to,span))));
if (((promoted_to).has_value())){
(checked_to = (promoted_to.value()));
(to_type = typechecker::expression_type(checked_to));
}
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_from = TRY((((*this).try_to_promote_constant_expr_to_type(to_type,checked_from,span))));
if (((promoted_from).has_value())){
(checked_from = (promoted_from.value()));
(from_type = typechecker::expression_type(checked_from));
}
const utility::Span from_span = ((*this).expression_span(checked_from));
const utility::Span to_span = ((*this).expression_span(checked_to));
const Optional<typechecker::TypeId> values_type_id = TRY((((*this).unify(from_type,from_span,to_type,from_span))));
if ((!((values_type_id).has_value()))){
TRY((((*this).error(String("Range values differ in types"),span))));
}
const typechecker::StructId range_struct_id = TRY((((*this).find_struct_in_prelude(String("Range")))));
const NonnullRefPtr<typechecker::Type> range_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(range_struct_id,(TRY((Array<typechecker::TypeId>::create_with({((values_type_id).value_or(typechecker::unknown_type_id()))})))))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(range_type))));
__jakt_var_105 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Range>(checked_from,checked_to,span,type_id))); goto __jakt_label_105;

}
__jakt_label_105:; __jakt_var_105.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_106; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span)))));
};/*case end*/
}/*switch end*/
}()
));
const typechecker::CheckedUnaryOperator checked_op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedUnaryOperator, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PreIncrement());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PostIncrement());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PreDecrement());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PostDecrement());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Negate>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Negate());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Dereference());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::RawAddress());
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Reference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Reference());
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::MutableReference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::MutableReference());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::LogicalNot());
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::BitwiseNot());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
parser::TypeCast const& cast = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedUnaryOperator> __jakt_var_107; {
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((cast).parsed_type()),scope_id,JaktInternal::OptionalNone()))));
const typechecker::CheckedTypeCast checked_cast = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedTypeCast, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = cast;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Fallible>();
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedTypeCast> __jakt_var_108; {
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> optional_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({type_id})))))));
const typechecker::TypeId optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_108 = typename typechecker::CheckedTypeCast::Fallible(optional_type_id); goto __jakt_label_108;

}
__jakt_label_108:; __jakt_var_108.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Infallible>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedTypeCast::Infallible(type_id));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_107 = typename typechecker::CheckedUnaryOperator::TypeCast(checked_cast); goto __jakt_label_107;

}
__jakt_label_107:; __jakt_var_107.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
NonnullRefPtr<parser::ParsedType> const& unchecked_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedUnaryOperator> __jakt_var_109; {
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(unchecked_type,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::CheckedUnaryOperator operator_is = typename typechecker::CheckedUnaryOperator::Is(type_id);
if (((type_id).equals(typechecker::unknown_type_id()))){
if ((unchecked_type)->has<parser::ParsedType::Name>()){
const String name = (unchecked_type->get<parser::ParsedType::Name>()).name;
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
if ((((*this).get_type(expr_type_id)))->has<typechecker::Type::Enum>()){
const typechecker::EnumId enum_id = (((*this).get_type(expr_type_id))->get<typechecker::Type::Enum>()).value;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool exists = false;
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
(exists = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
if (exists){
(operator_is = typename typechecker::CheckedUnaryOperator::IsEnumVariant(variant,(TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({})))),expr_type_id));
break;
}
}

}
}

if ((!exists)){
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),name,TRY((((*this).type_name(expr_type_id))))))),span))));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),name))),span))));
}

}
else {
TRY((((*this).error(String("The right-hand side of an `is` operator must be a type name or enum variant"),span))));
}

}
__jakt_var_109 = operator_is; goto __jakt_label_109;

}
__jakt_label_109:; __jakt_var_109.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
Array<parser::EnumVariantPatternArgument> const& bindings = __jakt_match_value.bindings;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedUnaryOperator> __jakt_var_110; {
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(inner,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::CheckedUnaryOperator checked_op = typename typechecker::CheckedUnaryOperator::Is(type_id);
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = typename typechecker::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),variant_name,TRY((((*this).type_name(type_id))))))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = typename typechecker::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),variant_name,TRY((((*this).type_name(type_id))))))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_110 = checked_op; goto __jakt_label_110;

}
__jakt_label_110:; __jakt_var_110.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_106 = TRY((((*this).typecheck_unary_operation(checked_expr,checked_op,span,scope_id,safety_mode)))); goto __jakt_label_106;

}
__jakt_label_106:; __jakt_var_106.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_111; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs = TRY((((*this).typecheck_expression_and_dereference_if_needed(lhs,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId lhs_type = typechecker::expression_type(checked_lhs);
NonnullRefPtr<typechecker::CheckedExpression> checked_rhs = TRY((((*this).typecheck_expression_and_dereference_if_needed(rhs,scope_id,safety_mode,lhs_type,span))));
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_rhs = TRY((((*this).try_to_promote_constant_expr_to_type(lhs_type,checked_rhs,span))));
if (((promoted_rhs).has_value())){
(checked_rhs = (promoted_rhs.value()));
}
const typechecker::TypeId output_type = TRY((((*this).typecheck_binary_operation(checked_lhs,op,checked_rhs,scope_id,span))));
__jakt_var_111 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::BinaryOp>(checked_lhs,op,checked_rhs,span,output_type))); goto __jakt_label_111;

}
__jakt_label_111:; __jakt_var_111.release_value(); }));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_112; {
__jakt_var_112 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalNone>(span,typechecker::unknown_type_id()))); goto __jakt_label_112;

}
__jakt_label_112:; __jakt_var_112.release_value(); }));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_113; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_expr);
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> optional_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({type_id})))))));
const typechecker::TypeId optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_113 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalSome>(checked_expr,span,optional_type_id))); goto __jakt_label_113;

}
__jakt_label_113:; __jakt_var_113.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const Optional<typechecker::CheckedVariable> var = TRY((((*this).find_var_in_scope(scope_id,name))));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((var).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Var>((var.value()),span))));
}
else {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_114; {
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),name))),span))));
__jakt_var_114 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Var>(typechecker::CheckedVariable(name,((type_hint).value_or(typechecker::unknown_type_id())),false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public()),span))); goto __jakt_label_114;

}
__jakt_label_114:; __jakt_var_114.release_value(); }));
}
}()))
);
}
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_115; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(typechecker::expression_type(checked_expr)));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_116; {
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
if ((((id).equals(optional_struct_id)) || ((id).equals(weakptr_struct_id)))){
(inner_type_id = ((args)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(String("Forced unwrap only works on Optional"),span))));
}

__jakt_var_116 = inner_type_id; goto __jakt_label_116;

}
__jakt_label_116:; __jakt_var_116.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_117; {
TRY((((*this).error(String("Forced unwrap only works on Optional"),span))));
__jakt_var_117 = typechecker::unknown_type_id(); goto __jakt_label_117;

}
__jakt_label_117:; __jakt_var_117.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_115 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::ForcedUnwrap>(checked_expr,span,type_id))); goto __jakt_label_115;

}
__jakt_label_115:; __jakt_var_115.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& fill_size = __jakt_match_value.fill_size;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_array(scope_id,values,fill_size,span,safety_mode,type_hint)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_118; {
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
Array<NonnullRefPtr<typechecker::CheckedExpression>> checked_values = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
Array<typechecker::TypeId> checked_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_value);
if (((type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Cannot create a tuple that contains a value of type void"),((value)->span())))));
}
TRY((((checked_types).push(type_id))));
TRY((((checked_values).push(checked_value))));
}

}
}

const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(tuple_struct_id,checked_types)))))));
__jakt_var_118 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktTuple>(checked_values,span,type_id))); goto __jakt_label_118;

}
__jakt_label_118:; __jakt_var_118.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_119; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_base = TRY((((*this).typecheck_expression_and_dereference_if_needed(base,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const NonnullRefPtr<typechecker::CheckedExpression> checked_index = TRY((((*this).typecheck_expression_and_dereference_if_needed(index,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
__jakt_var_119 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_base)));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_120; {
NonnullRefPtr<typechecker::CheckedExpression> result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span)));
if (((id).equals(array_struct_id))){
if (((*this).is_integer(typechecker::expression_type(checked_index)))){
(result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedExpression>(checked_base,checked_index,span,((args)[static_cast<i64>(0LL)])))));
}
else {
TRY((((*this).error(String("Index is not an integer"),span))));
}

}
else if (((id).equals(dictionary_struct_id))){
(result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedDictionary>(checked_base,checked_index,span,((args)[static_cast<i64>(1LL)])))));
}
__jakt_var_120 = result; goto __jakt_label_120;

}
__jakt_label_120:; __jakt_var_120.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_121; {
TRY((((*this).error(String("Index used on value that cannot be indexed"),span))));
__jakt_var_121 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span))); goto __jakt_label_121;

}
__jakt_label_121:; __jakt_var_121.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_119;

}
__jakt_label_119:; __jakt_var_119.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_122; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
if ((((*this).get_type(typechecker::expression_type(checked_expr))))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(typechecker::expression_type(checked_expr)))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(typechecker::expression_type(checked_expr)))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(tuple_struct_id))){
if (is_optional){
TRY((((*this).error(String("Optional chaining is not allowed on a non-optional tuple type"),span))));
}
if ((index >= ((args).size()))){
TRY((((*this).error(String("Tuple index past the end of the tuple"),span))));
}
else {
(expr_type_id = ((args)[index]));
}

}
else if ((is_optional && ((id).equals(optional_struct_id)))){
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if ((((*this).get_type(inner_type_id)))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type(inner_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(inner_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(tuple_struct_id))){
if ((index >= ((args).size()))){
TRY((((*this).error(String("Optional-chained tuple index past the end of the tuple"),span))));
}
else {
(expr_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({((args)[index])}))))))))))));
}

}
}
else {
TRY((((*this).error(String("Optional-chained tuple index used on non-tuple value"),span))));
}

}
}
else if (is_optional){
TRY((((*this).error(String("Optional-chained tuple index used on non-tuple value"),span))));
}
else {
TRY((((*this).error(String("Tuple index used on non-tuple value"),span))));
}

__jakt_var_122 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedTuple>(checked_expr,index,span,is_optional,expr_type_id))); goto __jakt_label_122;

}
__jakt_label_122:; __jakt_var_122.release_value(); }));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span))));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& name = __jakt_match_value.name;
Array<String> const& namespace_ = __jakt_match_value.namespace_;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_namespaced_var_or_simple_enum_constructor_call(name,namespace_,scope_id,safety_mode,type_hint,span)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
Array<parser::ParsedMatchCase> const& cases = __jakt_match_value.cases;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_match(expr,cases,span,scope_id,safety_mode)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& inner_expr = __jakt_match_value.expr;
parser::EnumVariantPatternArgument const& arg = __jakt_match_value.arg;
NonnullRefPtr<parser::ParsedType> const& enum_variant = __jakt_match_value.enum_variant;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_123; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(inner_expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
typechecker::CheckedEnumVariantBinding checked_binding = typechecker::CheckedEnumVariantBinding(String(""),String(""),typechecker::unknown_type_id(),span);
Optional<typechecker::CheckedEnumVariant> checked_enum_variant = JaktInternal::OptionalNone();
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *enum_variant;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((Array<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
const Array<typechecker::CheckedEnumVariantBinding> bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist"),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((Array<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
const Array<typechecker::CheckedEnumVariantBinding> bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist"),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_123 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::EnumVariantArg>(checked_expr,checked_binding,(checked_enum_variant.value()),span))); goto __jakt_label_123;

}
__jakt_label_123:; __jakt_var_123.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_dictionary(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_set(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();Array<parser::ParsedCapture> const& captures = __jakt_match_value.captures;
Array<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
NonnullRefPtr<parser::ParsedType> const& return_type = __jakt_match_value.return_type;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_lambda(captures,params,can_throw,return_type,block,span,scope_id,safety_mode)))));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("typechecker needs support for {}"),expr)))))));
}
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<void> typechecker::Typechecker::dump_type_hint(const typechecker::TypeId type_id,const utility::Span span) const {
{
outln(String("{{\"type\":\"hint\",\"file_id\":{},\"position\":{},\"typename\":\"{}\"}}"),((((span).file_id)).id),((span).end),TRY((((*this).type_name(type_id)))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_imports(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((parsed_namespace).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedModuleImport module_import = (_magic_value.value());
{
TRY((((*this).typecheck_module_import(module_import,scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedExternImport> _magic = ((((parsed_namespace).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
TRY((((*this).typecheck_extern_import(extern_import,scope_id,parsed_namespace))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_block_statement(const parser::ParsedBlock parsed_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A block used as a statement cannot yield values, as the value cannot be observed in any way"),(((parsed_block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Block>(checked_block,span))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_typename(const NonnullRefPtr<parser::ParsedType> parsed_type,const typechecker::ScopeId scope_id,const Optional<String> name) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *parsed_type;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Reference>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Reference>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::MutableReference>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::MutableReference>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& name = __jakt_match_value.name;
Array<String> const& namespaces = __jakt_match_value.namespaces;
Array<NonnullRefPtr<parser::ParsedType>> const& params = __jakt_match_value.params;
utility::Span const& span = __jakt_match_value.span;
{
typechecker::ScopeId current_namespace_scope_id = scope_id;
{
ArrayIterator<String> _magic = ((namespaces).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String ns = (_magic_value.value());
{
const Optional<Tuple<typechecker::ScopeId,bool>> result = TRY((((*this).find_namespace_in_scope(current_namespace_scope_id,ns))));
if (((result).has_value())){
(current_namespace_scope_id = (((result.value())).get<0>()));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown namespace: '{}'"),ns))),span))));
return (typechecker::unknown_type_id());
}

}

}
}

Array<typechecker::TypeId> generic_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((params).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> param = (_magic_value.value());
{
const typechecker::TypeId checked_arg = TRY((((*this).typecheck_typename(param,scope_id,name))));
TRY((((generic_args).push(checked_arg))));
}

}
}

if (((generic_args).is_empty())){
const NonnullRefPtr<parser::ParsedType> synthetic_typename = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(name,span)));
return (TRY((((*this).typecheck_typename(synthetic_typename,current_namespace_scope_id,name)))));
}
else {
return (TRY((((*this).typecheck_generic_resolved_type(name,generic_args,current_namespace_scope_id,span)))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>> maybe_type_and_scope = TRY((((*this).find_type_scope(scope_id,name))));
if (((maybe_type_and_scope).has_value())){
if ((!(((((maybe_type_and_scope.value())).get<1>())).equals(((*this).prelude_scope_id()))))){
return ((((maybe_type_and_scope.value())).get<0>()));
}
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<typechecker::TypeId>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == String("i8")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I8));
}
else if (__jakt_enum_value == String("i16")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I16));
}
else if (__jakt_enum_value == String("i32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I32));
}
else if (__jakt_enum_value == String("i64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I64));
}
else if (__jakt_enum_value == String("u8")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
}
else if (__jakt_enum_value == String("u16")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U16));
}
else if (__jakt_enum_value == String("u32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U32));
}
else if (__jakt_enum_value == String("u64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U64));
}
else if (__jakt_enum_value == String("f32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::F32));
}
else if (__jakt_enum_value == String("f64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::F64));
}
else if (__jakt_enum_value == String("c_char")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CChar));
}
else if (__jakt_enum_value == String("c_int")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CInt));
}
else if (__jakt_enum_value == String("usize")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Usize));
}
else if (__jakt_enum_value == String("String")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::String));
}
else if (__jakt_enum_value == String("bool")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Bool));
}
else if (__jakt_enum_value == String("void")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
}
else if (__jakt_enum_value == String("never")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Never));
}
else {
{
if (((maybe_type_and_scope).has_value())){
return ((((maybe_type_and_scope.value())).get<0>()));
}
TRY((((*this).error(TRY((String::formatted(String("Unknown type {}"),name))),span))));
return (typechecker::unknown_type_id());
}
}
}()))
);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
{
return (typechecker::unknown_type_id());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktTuple>();Array<NonnullRefPtr<parser::ParsedType>> const& types = __jakt_match_value.types;
utility::Span const& span = __jakt_match_value.span;
{
Array<typechecker::TypeId> checked_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((types).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> parsed_type = (_magic_value.value());
{
TRY((((checked_types).push(TRY((((*this).typecheck_typename(parsed_type,scope_id,name))))))));
}

}
}

const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(tuple_struct_id,checked_types)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktArray>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Dictionary>();NonnullRefPtr<parser::ParsedType> const& key = __jakt_match_value.key;
NonnullRefPtr<parser::ParsedType> const& value = __jakt_match_value.value;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId key_type_id = TRY((((*this).typecheck_typename(key,scope_id,name))));
const typechecker::TypeId value_type_id = TRY((((*this).typecheck_typename(value,scope_id,name))));
const typechecker::StructId dict_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(dict_struct_id,(TRY((Array<typechecker::TypeId>::create_with({key_type_id, value_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Set>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(set_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::WeakPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(weakptr_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::RawPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::GenericType>();String const& name = __jakt_match_value.name;
Array<NonnullRefPtr<parser::ParsedType>> const& generic_parameters = __jakt_match_value.generic_parameters;
utility::Span const& span = __jakt_match_value.span;
{
Array<typechecker::TypeId> checked_inner_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((generic_parameters).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedType> inner_type = (_magic_value.value());
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner_type,scope_id,name))));
TRY((((checked_inner_types).push(inner_type_id))));
}

}
}

return (TRY((((*this).typecheck_generic_resolved_type(name,checked_inner_types,scope_id,span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Function>();Array<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
NonnullRefPtr<parser::ParsedType> const& return_type = __jakt_match_value.return_type;
utility::Span const& span = __jakt_match_value.span;
{
const String function_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<typechecker::TypeId>>{
auto __jakt_enum_value = (((name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((name.value()));
}
else {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_124; {
String default_name = String("");
{auto _jakt_try_result = [&]() -> ErrorOr<void> {{
(default_name = TRY((String::formatted(String("lambda{}"),(((*this).lambda_count)++)))));
}

;return {};}();if (_jakt_try_result.is_error()) {{
}
}}
__jakt_var_124 = default_name; goto __jakt_label_124;

}
__jakt_label_124:; __jakt_var_124.release_value(); }));
}
}()))
;
Array<typechecker::CheckedParameter> checked_params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
bool first = true;
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((checked_params).push(TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))))))));
(first = false);
}

}
}

const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(function_name,span,typename parser::Visibility::Public(),TRY((((*this).typecheck_typename(return_type,scope_id,JaktInternal::OptionalNone())))),((return_type)->span()),checked_params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),scope_id,typename typechecker::BlockControlFlow::MayReturn(),JaktInternal::OptionalNone()),can_throw,typename parser::FunctionType::Normal(),typename parser::FunctionLinkage::Internal(),scope_id,false,JaktInternal::OptionalNone())));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(scope_id,((checked_function)->name),function_id,span))));
Array<typechecker::TypeId> param_type_ids = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((param_type_ids).push(TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),scope_id,name))))))));
}

}
}

const typechecker::TypeId return_type_id = TRY((((*this).typecheck_typename(return_type,scope_id,name))));
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Function>(param_type_ids,can_throw,return_type_id))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
TRY((((((*this).compiler))->panic(String("should be unreachable")))));
}
}

ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>> typechecker::Typechecker::expand_context_for_bindings(const NonnullRefPtr<parser::ParsedExpression> condition,const Optional<NonnullRefPtr<parser::ParsedExpression>> acc,const parser::ParsedBlock then_block,const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>>>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
{
if ((op).has<parser::BinaryOperator::LogicalAnd>()){
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> rhs_condition_rhs_then_block_rhs_else_statement_ = TRY((((*this).expand_context_for_bindings(rhs,acc,then_block,else_statement,span))));
const NonnullRefPtr<parser::ParsedExpression> rhs_condition = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<0>());
const parser::ParsedBlock rhs_then_block = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> rhs_else_statement = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<2>());

NonnullRefPtr<parser::ParsedExpression> accumulated_condition = rhs_condition;
return (TRY((((*this).expand_context_for_bindings(lhs,accumulated_condition,rhs_then_block,rhs_else_statement,span)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
Array<parser::EnumVariantPatternArgument> const& bindings = __jakt_match_value.bindings;
{
const NonnullRefPtr<parser::ParsedExpression> unary_op_single_condition = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Is(inner),span)));
Array<NonnullRefPtr<parser::ParsedStatement>> outer_if_stmts = (TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
const parser::ParsedVarDecl var = parser::ParsedVarDecl(((binding).binding),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),((binding).span));
const NonnullRefPtr<parser::ParsedExpression> enum_variant_arg = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::EnumVariantArg>(expr,binding,inner,span)));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(var,enum_variant_arg,span)))))));
}

}
}

NonnullRefPtr<parser::ParsedExpression> inner_condition = condition;
parser::ParsedBlock new_then_block = then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = else_statement;
if (((acc).has_value())){
(inner_condition = (acc.value()));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(inner_condition,then_block,else_statement,span)))))));
}
else {
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((then_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
TRY((((outer_if_stmts).push(stmt))));
}

}
}

}

(new_then_block = parser::ParsedBlock(outer_if_stmts));
return (TRY((((*this).expand_context_for_bindings(unary_op_single_condition,JaktInternal::OptionalNone(),new_then_block,new_else_statement,span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedExpression> base_condition = condition;
if (((acc).has_value())){
(base_condition = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(condition,typename parser::BinaryOperator::LogicalAnd(),(acc.value()),span))));
}
return ((Tuple{base_condition, then_block, else_statement}));
}
}

ErrorOr<Optional<typechecker::TypeId>> typechecker::Typechecker::unify(const typechecker::TypeId lhs,const utility::Span lhs_span,const typechecker::TypeId rhs,const utility::Span rhs_span) {
{
if ((((lhs).id) != ((rhs).id))){
TRY((((*this).error(String("types incompatible "),rhs_span))));
return (JaktInternal::OptionalNone());
}
else {
return (lhs);
}

}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::find_type_in_prelude(const String name) const {
{
const typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
const Optional<typechecker::TypeId> type_id = TRY((((*this).find_type_in_scope(scope_id,name))));
if (((type_id).has_value())){
return (((type_id).value()));
}
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("internal error: {} builtin definition not found"),name)))))));
}
}

bool typechecker::Typechecker::is_numeric(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_numeric(type_id)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_array(const typechecker::ScopeId scope_id,const Array<NonnullRefPtr<parser::ParsedExpression>> values,const Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size,const utility::Span span,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
Optional<NonnullRefPtr<typechecker::CheckedExpression>> repeat = JaktInternal::OptionalNone();
if (((fill_size).has_value())){
const NonnullRefPtr<parser::ParsedExpression> fill_size_value = ((fill_size).value());
const NonnullRefPtr<typechecker::CheckedExpression> fill_size_checked = TRY((((*this).typecheck_expression_and_dereference_if_needed(fill_size_value,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId fill_size_type = typechecker::expression_type(fill_size_checked);
if ((!((*this).is_integer(fill_size_type)))){
TRY((((*this).error(TRY((String::formatted(String("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions."),TRY((((*this).type_name(fill_size_type))))))),((fill_size_value)->span())))));
}
(repeat = fill_size_checked);
}
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
Optional<utility::Span> inferred_type_span = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> inner_hint = JaktInternal::OptionalNone();
if (((type_hint).has_value())){
if ((((*this).get_type((type_hint.value()))))->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(array_struct_id))){
(inner_hint = (((args)[static_cast<i64>(0LL)])));
}
}
}
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_expr);
if (((current_value_type_id).equals(typechecker::void_type_id()))){
TRY((((*this).error(String("Cannot create an array with values of type void\n"),span))));
}
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
(inner_type_id = current_value_type_id);
(inferred_type_span = ((value)->span()));
}
else if ((!((inner_type_id).equals(current_value_type_id)))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in array"),TRY((((*this).type_name(current_value_type_id)))),TRY((((*this).type_name(inner_type_id))))))),((value)->span()),TRY((String::formatted(String("Array was inferred to store type '{}' here"),TRY((((*this).type_name(inner_type_id))))))),(inferred_type_span.value())))));
}
TRY((((vals).push(checked_expr))));
}

}
}

if (((inner_type_id).equals(typechecker::unknown_type_id()))){
if (((inner_hint).has_value())){
(inner_type_id = (inner_hint.value()));
}
else if ((((type_hint).has_value()) && (((type_hint.value())).equals(typechecker::unknown_type_id())))){
TRY((((*this).error(String("Cannot infer generic type for Array<T>"),span))));
}
}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktArray>(vals,repeat,span,type_id,inner_type_id))));
}
}

ErrorOr<bool> typechecker::Typechecker::add_var_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::VarId var_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
{
DictionaryIterator<String,typechecker::VarId> _magic = ((((scope)->vars)).iterator());
for (;;){
Optional<Tuple<String,typechecker::VarId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::VarId> existing_var = (_magic_value.value());
{
if ((name == ((existing_var).get<0>()))){
const typechecker::CheckedVariable variable_ = ((*this).get_variable(((existing_var).get<1>())));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Redefinition of variable {}"),name))),span,String("previous definition here"),((variable_).definition_span)))));
}
}

}
}

TRY((((((scope)->vars)).set(name,var_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::Scope>> typechecker::Typechecker::get_scope(const typechecker::ScopeId id) const {
{
return (TRY((((((*this).program))->get_scope(id)))));
}
}

ErrorOr<bool> typechecker::Typechecker::check_types_for_compat(const typechecker::TypeId lhs_type_id,const typechecker::TypeId rhs_type_id,Dictionary<String,String> generic_inferences,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
const String lhs_type_id_string = TRY((((lhs_type_id).to_string())));
const String rhs_type_id_string = TRY((((rhs_type_id).to_string())));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
if ((((lhs_type_id).equals(typechecker::unknown_type_id())) || ((rhs_type_id).equals(typechecker::unknown_type_id())))){
return (true);
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *lhs_type;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((generic_inferences).get(lhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != rhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value())))))))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
else {
TRY((((generic_inferences).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& lhs_enum_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::GenericEnumInstance>()){
const typechecker::EnumId rhs_enum_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (((*this).get_type(rhs_type_id))->get<typechecker::Type::GenericEnumInstance>()).args;
if (((lhs_enum_id).equals(rhs_enum_id))){
const typechecker::CheckedEnum lhs_enum = ((*this).get_enum(lhs_enum_id));
if ((((lhs_args).size()) == ((rhs_args).size()))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span)))))){
return (false);
}
(++idx);
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_enum).name)))),span))));
return (false);
}

}
}
else {
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::StructId lhs_struct_id = id;
const Array<typechecker::TypeId> lhs_args = args;
if ((((lhs_struct_id).equals(optional_struct_id)) || ((lhs_struct_id).equals(weakptr_struct_id)))){
if ((((lhs_args).size()) > static_cast<size_t>(0ULL))){
if (((((lhs_args)[static_cast<i64>(0LL)])).equals(rhs_type_id))){
return (true);
}
}
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
if ((rhs_type)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (rhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (rhs_type->get<typechecker::Type::GenericInstance>()).args;
const typechecker::StructId rhs_struct_id = id;
if (((lhs_struct_id).equals(rhs_struct_id))){
const Array<typechecker::TypeId> rhs_args = args;
const typechecker::CheckedStruct lhs_struct = ((*this).get_struct(lhs_struct_id));
if ((((lhs_args).size()) == ((rhs_args).size()))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span)))))){
return (false);
}
(++idx);
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_struct).name)))),span))));
return (false);
}

}
else if (((lhs_struct_id).equals(array_struct_id))){
const typechecker::TypeId array_value_type_id = ((args)[static_cast<i64>(0LL)]);
if (((array_value_type_id).equals(typechecker::unknown_type_id()))){
return (true);
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}

}
else {
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
if (((lhs_type_id).equals(rhs_type_id))){
return (true);
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
if (((enum_id).equals(id))){
const typechecker::CheckedEnum lhs_enum = ((*this).get_enum(enum_id));
if ((((args).size()) != ((((lhs_enum).generic_parameters)).size()))){
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_enum).name)))),span))));
return (false);
}
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!TRY((((*this).check_types_for_compat(((((lhs_enum).generic_parameters))[idx]),((args)[idx]),generic_inferences,span)))))){
return (false);
}
(++idx);
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((generic_inferences).get(rhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != lhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value()))))))))))),span))));
return (false);
}
}
else {
TRY((((generic_inferences).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& lhs_struct_id = __jakt_match_value.value;
{
if (((lhs_type_id).equals(rhs_type_id))){
return (true);
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
if ((!((lhs_struct_id).equals(id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
const typechecker::CheckedStruct lhs_struct = ((*this).get_struct(lhs_struct_id));
if ((((args).size()) != ((((lhs_struct).generic_parameters)).size()))){
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_struct).name)))),span))));
return (false);
}
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!TRY((((*this).check_types_for_compat(((((lhs_struct).generic_parameters))[idx]),((args)[idx]),generic_inferences,span)))))){
return (false);
}
(++idx);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((generic_inferences).get(rhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != lhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value())))))))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
else {
TRY((((generic_inferences).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& lhs_rawptr_type_id = __jakt_match_value.value;
{
if (((lhs_rawptr_type_id).equals(rhs_type_id))){
return (true);
}
if ((((*this).get_type(rhs_type_id)))->has<typechecker::Type::RawPtr>()){
const typechecker::TypeId rhs_rawptr_type_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::RawPtr>()).value;
if ((!TRY((((*this).check_types_for_compat(lhs_rawptr_type_id,rhs_rawptr_type_id,generic_inferences,span)))))){
return (false);
}
}
else {
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!((rhs_type_id).equals(lhs_type_id)))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (true);
}
}

ErrorOr<Optional<typechecker::CheckedVariable>> typechecker::Typechecker::find_var_in_scope(const typechecker::ScopeId scope_id,const String var) const {
{
return (TRY((((((*this).program))->find_var_in_scope(scope_id,var)))));
}
}

typechecker::CheckedStruct typechecker::Typechecker::get_struct(const typechecker::StructId id) const {
{
return (((((*this).program))->get_struct(id)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_lambda(const Array<parser::ParsedCapture> captures,const Array<parser::ParsedParameter> params,const bool can_throw,const NonnullRefPtr<parser::ParsedType> return_type,const parser::ParsedBlock block,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const typechecker::ScopeId lambda_scope_id = TRY((((*this).create_scope(scope_id,can_throw,String("lambda")))));
Array<typechecker::CheckedCapture> checked_captures = (TRY((Array<typechecker::CheckedCapture>::create_with({}))));
{
ArrayIterator<parser::ParsedCapture> _magic = ((captures).iterator());
for (;;){
Optional<parser::ParsedCapture> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedCapture capture = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((TRY((((*this).find_var_in_scope(scope_id,((capture).name())))))).has_value()));
if (__jakt_enum_value == true) {
{
TRY((((checked_captures).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedCapture, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = capture;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByValue(name,span));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByReference(name,span));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByMutableReference(name,span));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),((capture).name())))),span))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
Array<typechecker::CheckedParameter> checked_params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
bool first = true;
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
const typechecker::CheckedParameter checked_param = TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
TRY((((checked_params).push(checked_param))));
const typechecker::VarId var_id = TRY((((module)->add_variable(((checked_param).variable)))));
TRY((((*this).add_var_to_scope(lambda_scope_id,((((checked_param).variable)).name),var_id,((((checked_param).variable)).definition_span)))));
(first = false);
}

}
}

const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,lambda_scope_id,safety_mode))));
Array<typechecker::TypeId> param_type_ids = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((param_type_ids).push(TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),scope_id,((((param).variable)).name)))))))));
}

}
}

const typechecker::TypeId return_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *return_type;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
return JaktInternal::ExplicitValue(((*this).infer_function_return_type(checked_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_typename(return_type,scope_id,JaktInternal::OptionalNone())))));
};/*case end*/
}/*switch end*/
}()
));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Function>(param_type_ids,can_throw,return_type_id)))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Function>(checked_captures,checked_params,can_throw,return_type_id,checked_block,span,type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_try(const NonnullRefPtr<parser::ParsedStatement> stmt,const String error_name,const utility::Span error_span,const parser::ParsedBlock catch_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::ScopeId try_scope_id = TRY((((*this).create_scope(scope_id,true,String("try")))));
const NonnullRefPtr<typechecker::CheckedStatement> checked_stmt = TRY((((*this).typecheck_statement(stmt,try_scope_id,safety_mode))));
const typechecker::StructId error_struct_id = TRY((((*this).find_struct_in_prelude(String("Error")))));
const typechecker::CheckedVariable error_decl = typechecker::CheckedVariable(error_name,((((*this).get_struct(error_struct_id))).type_id),false,error_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public());
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId error_id = TRY((((module)->add_variable(error_decl))));
const typechecker::ScopeId catch_scope_id = TRY((((*this).create_scope(scope_id,false,String("catch")))));
TRY((((*this).add_var_to_scope(catch_scope_id,error_name,error_id,error_span))));
const typechecker::CheckedBlock checked_catch_block = TRY((((*this).typecheck_block(catch_block,catch_scope_id,safety_mode))));
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Try>(checked_stmt,error_name,checked_catch_block,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_return(const Optional<NonnullRefPtr<parser::ParsedExpression>> expr,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
if (((*this).inside_defer)){
TRY((((*this).error(String("return is not allowed inside defer"),span))));
}
if ((!((expr).has_value()))){
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Return>(JaktInternal::OptionalNone(),span))));
}
if (((expr.value()))->has<parser::ParsedExpression::Function>()){
TRY((((*this).error(String("Returning a function is not currently supported"),span))));
}
Optional<typechecker::TypeId> type_hint = JaktInternal::OptionalNone();
if (((((*this).current_function_id)).has_value())){
(type_hint = (((((*this).get_function((((*this).current_function_id).value()))))->return_type_id)));
}
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression((expr.value()),scope_id,safety_mode,type_hint))));
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Return>(checked_expr,span))));
}
}

ErrorOr<void> typechecker::Typechecker::check_that_type_doesnt_contain_reference(const typechecker::TypeId type_id,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
const bool contains_reference = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
if (contains_reference){
TRY((((*this).error(TRY((String::formatted(String("Reference type {} not usable in this context"),TRY((((*this).type_name(type_id))))))),span))));
}
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_fields(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_fields(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
if (((((record).record_type)).has<parser::RecordType::Struct>() || (((record).record_type)).has<parser::RecordType::Class>())){
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!((struct_id).has_value()))){
TRY((((((*this).compiler))->panic(String("can't find previously added struct")))));
}
TRY((((*this).typecheck_struct_fields(record,(struct_id.value())))));
}
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_and_specialize_generic_function(const typechecker::FunctionId function_id,const Array<typechecker::TypeId> generic_arguments,const typechecker::ScopeId parent_scope_id,const Optional<typechecker::TypeId> this_type_id,const Dictionary<String,String> generic_substitutions) {
{
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function(function_id));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::FunctionId function_id = ((module)->next_function_id());
if ((!((((checked_function)->parsed_function)).has_value()))){
return {};
}
parser::ParsedFunction parsed_function = ((checked_function)->to_parsed_function());
const typechecker::ScopeId scope_id = TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),TRY((String::formatted(String("function-specialization({})"),((parsed_function).name))))))));
if ((((((parsed_function).generic_parameters)).size()) != ((generic_arguments).size()))){
TRY((((*this).error(TRY((String::formatted(String("Generic function {} expects {} generic arguments, but {} were given"),((parsed_function).name),((((parsed_function).generic_parameters)).size()),((generic_arguments).size())))),((parsed_function).name_span)))));
}
const utility::Span span = ((parsed_function).name_span);
{
DictionaryIterator<String,String> _magic = ((generic_substitutions).iterator());
for (;;){
Optional<Tuple<String,String>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,String> substitution = (_magic_value.value());
{
if ((((*this).get_type(TRY((typechecker::TypeId::from_string(((substitution).get<0>())))))))->has<typechecker::Type::TypeVariable>()){
const String type_name = (((*this).get_type(TRY((typechecker::TypeId::from_string(((substitution).get<0>()))))))->get<typechecker::Type::TypeVariable>()).value;
TRY((((*this).add_type_to_scope(scope_id,type_name,TRY((typechecker::TypeId::from_string(((substitution).get<1>())))),span))));
}
}

}
}

(((parsed_function).must_instantiate) = true);
(((*this).current_function_id) = (function_id));
TRY((((*this).typecheck_function_predecl(parsed_function,scope_id,this_type_id))));
TRY((((*this).typecheck_function(parsed_function,scope_id))));
(((*this).current_function_id) = JaktInternal::OptionalNone());
(((checked_function)->is_instantiated) = true);
(((checked_function)->function_scope_id) = scope_id);
}
return {};
}

ErrorOr<Optional<parser::ParsedNamespace>> typechecker::Typechecker::lex_and_parse_file_contents(const utility::FileId file_id) {
{
const utility::FileId old_file_id = (((((*this).compiler))->current_file).value());
if ((!((((*this).compiler))->set_current_file(file_id)))){
return (JaktInternal::OptionalNone());
}

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{((((*this).compiler))->set_current_file(old_file_id));
});
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln(String("{:#}"),parsed_namespace);
}
return (parsed_namespace);
}
}

ErrorOr<Optional<NonnullRefPtr<typechecker::CheckedExpression>>> typechecker::Typechecker::try_to_promote_constant_expr_to_type(const typechecker::TypeId lhs_type,const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs,const utility::Span span) {
{
if ((!((*this).is_integer(lhs_type)))){
return (JaktInternal::OptionalNone());
}
const Optional<typechecker::NumberConstant> rhs_constant_opt = ((checked_rhs)->to_number_constant(((*this).program)));
if ((!((rhs_constant_opt).has_value()))){
return (JaktInternal::OptionalNone());
}
const typechecker::NumberConstant rhs_constant = (rhs_constant_opt.value());
const Optional<typechecker::CheckedNumericConstant> result = typechecker::promote(rhs_constant,lhs_type,((*this).program));
if ((!((result).has_value()))){
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(lhs_type));
TRY((((*this).error_with_hint(String("Integer promotion failed"),span,TRY((String::formatted(String("Cannot fit value into range [{}, {}] of type {}."),((type)->min()),((type)->max()),TRY((((*this).type_name(lhs_type))))))),span))));
return (JaktInternal::OptionalNone());
}
const typechecker::CheckedNumericConstant new_constant = (result.value());
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(new_constant,span,lhs_type))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::resolve_type_var(const typechecker::TypeId type_var_type_id,const typechecker::ScopeId scope_id) const {
{
typechecker::TypeId current_type_id = type_var_type_id;
for (;;){
const NonnullRefPtr<typechecker::Type> type_var_type = ((*this).get_type(current_type_id));
if ((type_var_type)->has<typechecker::Type::TypeVariable>()){
const String type_name = (type_var_type->get<typechecker::Type::TypeVariable>()).value;
const Optional<typechecker::TypeId> maybe_found_type_id = TRY((((*this).find_type_in_scope(scope_id,type_name))));
if (((maybe_found_type_id).has_value())){
const typechecker::TypeId found_type_id = ((maybe_found_type_id).value());
if (((found_type_id).equals(current_type_id))){
return (current_type_id);
}
(current_type_id = found_type_id);
}
else {
return (current_type_id);
}

}
else {
return (current_type_id);
}

}
return (current_type_id);
}
}

NonnullRefPtr<typechecker::CheckedFunction> typechecker::Typechecker::get_function(const typechecker::FunctionId id) const {
{
return (((((*this).program))->get_function(id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl(const parser::ParsedRecord parsed_record,const typechecker::StructId struct_id,const typechecker::ScopeId scope_id) {
{
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
const typechecker::ScopeId struct_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((String::formatted(String("struct({})"),((parsed_record).name))))))));
TRY((((*this).add_struct_to_scope(scope_id,((parsed_record).name),struct_id,((parsed_record).name_span)))));
const bool is_extern = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).definition_linkage);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
(((((module)->structures))[((struct_id).id)]) = typechecker::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::VarId>::create_with({})))),struct_scope_id,((parsed_record).definition_linkage),((parsed_record).record_type),struct_type_id));
Array<typechecker::TypeId> generic_parameters = ((((((module)->structures))[((struct_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId parameter_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(parameter_type_id))));
TRY((((*this).add_type_to_scope(struct_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
const parser::ParsedFunction func = ((method).parsed_function);
const typechecker::ScopeId method_scope_id = TRY((((*this).create_scope(struct_scope_id,((func).can_throw),TRY((String::formatted(String("method({}::{})"),((parsed_record).name),((func).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-block({}::{})"),((parsed_record).name),((func).name))))))));
const bool is_generic = ((!((((parsed_record).generic_parameters)).is_empty())) || (!((((func).generic_parameters)).is_empty())));
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((func).name),((func).name_span),((method).visibility),typechecker::unknown_type_id(),((func).return_type_span),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((func).can_throw),((func).type),((func).linkage),method_scope_id,((!is_generic) || is_extern),((method).parsed_function))));
TRY((((((module)->functions)).push(checked_function))));
const typechecker::FunctionId function_id = typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL))));
const Optional<typechecker::FunctionId> previous_index = ((*this).current_function_id);
(((*this).current_function_id) = function_id);
Optional<typechecker::ScopeId> check_scope = JaktInternal::OptionalNone();
if (is_generic){
(check_scope = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-checking({}::{})"),((parsed_record).name),((func).name)))))))));
}
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((func).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((((checked_function)->generic_params)).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
TRY((((*this).add_type_to_scope(method_scope_id,((gen_parameter).name),type_var_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedParameter> _magic = ((((func).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
if ((((((param).variable)).name) == String("this"))){
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),struct_type_id,((((param).variable)).is_mutable),((((param).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable)))));
if (((check_scope).has_value())){
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((param).variable)).name),var_id,((((param).variable)).span)))));
}
}
else {
const typechecker::TypeId param_type = TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),method_scope_id,((((param).variable)).name)))));
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),param_type,((((param).variable)).is_mutable),((((param).variable)).span),((((((param).variable)).parsed_type))->span()),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable)))));
if (((check_scope).has_value())){
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((param).variable)).name),var_id,((((param).variable)).span)))));
}
}

}

}
}

TRY((((*this).add_function_to_scope(struct_scope_id,((func).name),typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL)))),((parsed_record).name_span)))));
const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),method_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
if (is_generic){
if ((!((check_scope).has_value()))){
TRY((((((*this).compiler))->panic(String("Generic method with generic parameters must have a check scope")))));
}
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((func).block),(check_scope.value()),typename typechecker::SafetyMode::Safe()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::TypeId return_type_id = typechecker::builtin(BuiltinType::Void);
if (((function_return_type_id).equals(typechecker::unknown_type_id()))){
if ((!((((block).statements)).is_empty()))){
if (((((((block).statements)).last()).value()))->has<typechecker::CheckedStatement::Return>()){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = ((((((block).statements)).last()).value())->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
(return_type_id = TRY((((*this).resolve_type_var(typechecker::expression_type((val.value())),method_scope_id)))));
}
}
}
}
else {
(return_type_id = TRY((((*this).resolve_type_var(function_return_type_id,scope_id)))));
}

(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
(((((module)->functions))[((function_id).id)]) = checked_function);
(((*this).current_function_id) = previous_index);
}

}
}

(((((((module)->structures))[((struct_id).id)])).generic_parameters) = generic_parameters);
(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl_initial(const parser::ParsedRecord parsed_record,const size_t enum_index,const size_t module_enum_len,const typechecker::ScopeId scope_id) {
{
const typechecker::ModuleId module_id = ((*this).current_module_id);
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id)))))));
const typechecker::TypeId enum_type_id = typechecker::TypeId(module_id,(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),enum_type_id,((parsed_record).name_span)))));
const bool is_boxed = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
TRY((((((module)->enums)).push(typechecker::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::CheckedEnumVariant>::create_with({})))),((*this).prelude_scope_id()),((parsed_record).definition_linkage),((parsed_record).record_type),enum_type_id,enum_type_id,is_boxed)))));
}
return {};
}

NonnullRefPtr<typechecker::Type> typechecker::Typechecker::get_type(const typechecker::TypeId id) const {
{
return (((((*this).program))->get_type(id)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_guard(const NonnullRefPtr<parser::ParsedExpression> expr,const parser::ParsedBlock else_block,const parser::ParsedBlock remaining_code,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
bool seen_scope_exit = false;
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((else_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<parser::ParsedStatement> statement = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

const typechecker::CheckedBlock checked_else_block = TRY((((*this).typecheck_block(else_block,scope_id,safety_mode))));
if ((!seen_scope_exit)){
bool seen_never_returning_statement = false;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((checked_else_block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
if (((*this).statement_never_returns(statement))){
(seen_never_returning_statement = true);
}
}

}
}

if ((!seen_never_returning_statement)){
TRY((((*this).error(String("Else block of guard must either `return`, `break`, `continue`, or `throw`"),span))));
}
}
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(expr,JaktInternal::OptionalNone(),remaining_code,TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(else_block,span))),span))));
const NonnullRefPtr<parser::ParsedExpression> new_condition = ((new_condition_new_then_block_new_else_statement_).get<0>());
const parser::ParsedBlock new_then_block = ((new_condition_new_then_block_new_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = ((new_condition_new_then_block_new_else_statement_).get<2>());

const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((new_condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(new_then_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A 'guard' block is not allowed to yield values"),(((new_then_block).find_yield_span()).value())))));
}
Optional<NonnullRefPtr<typechecker::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode)))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::If>(checked_condition,checked_block,checked_else,span))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_extern_import(const parser::ParsedExternImport import_,const typechecker::ScopeId scope_id,parser::ParsedNamespace parent) {
{
{
ArrayIterator<parser::ParsedFunction> _magic = ((((((import_).assigned_namespace)).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedFunction f = (_magic_value.value());
{
if ((!(((f).linkage)).has<parser::FunctionLinkage::External>())){
TRY((((*this).error(String("Expected all functions in an `import extern` to be be external"),((f).name_span)))));
}
if ((((import_).is_c) && (!((((f).generic_parameters)).is_empty())))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("imported function '{}' is declared to have C linkage, but is generic"),((f).name)))),((f).name_span),String("this function may not be generic"),((f).name_span)))));
}
if ((!((((((f).block)).stmts)).is_empty()))){
TRY((((*this).error(String("imported extern function is not allowed to have a body"),((f).name_span)))));
}
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((((import_).assigned_namespace)).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
if ((!(((record).definition_linkage)).has<parser::DefinitionLinkage::External>())){
TRY((((*this).error(String("Expected all records in an `import extern` to be external"),((record).name_span)))));
}
if ((((import_).is_c) && (!((((record).generic_parameters)).is_empty())))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("imported {} '{}' is declared to have C linkage, but is generic"),((((record).record_type)).record_type_name()),((record).name)))),((record).name_span),TRY((String::formatted(String("this {} may not be generic"),((((record).record_type)).record_type_name())))),((record).name_span)))));
}
}

}
}

TRY((((parent).add_child_namespace(((import_).assigned_namespace)))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::check_member_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee,const typechecker::CheckedVariable member,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((member).visibility);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
{
if ((!TRY((((*this).scope_can_access(accessor,accessee)))))){
TRY((((*this).error(TRY((String::formatted(String("Can't access variable {} from scope {}, because it is marked private"),((member).name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();Array<NonnullRefPtr<parser::ParsedType>> const& whitelist = __jakt_match_value.whitelist;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((*this).check_restricted_access(accessor,String("variable"),accessee,((member).name),whitelist,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_method(const parser::ParsedFunction func,const typechecker::StructOrEnumId parent_id) {
{
Array<typechecker::TypeId> parent_generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
parser::DefinitionLinkage definition_linkage = typename parser::DefinitionLinkage::Internal();
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = parent_id;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
(parent_generic_parameters = ((structure).generic_parameters));
(scope_id = ((structure).scope_id));
(definition_linkage = ((structure).definition_linkage));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
(definition_linkage = ((enum_).definition_linkage));
(scope_id = ((enum_).scope_id));
(parent_generic_parameters = ((enum_).generic_parameters));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((!((((func).generic_parameters)).is_empty())) || (!((parent_generic_parameters).is_empty()))) && (!((func).must_instantiate)))){
return {};
}
const typechecker::ScopeId structure_scope_id = scope_id;
const parser::DefinitionLinkage structure_linkage = definition_linkage;
const Optional<typechecker::FunctionId> method_id = TRY((((*this).find_function_in_scope(structure_scope_id,((func).name)))));
if ((!((method_id).has_value()))){
TRY((((((*this).compiler))->panic(String("we just pushed the checked function, but it's not present")))));
}
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function((method_id.value())));
const typechecker::ScopeId function_scope_id = ((checked_function)->function_scope_id);
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope(function_scope_id,((variable).name),var_id,((variable).definition_span)))));
}

}
}

(((*this).current_function_id) = method_id);
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((func).block),function_scope_id,typename typechecker::SafetyMode::Safe()))));
const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),function_scope_id,JaktInternal::OptionalNone()))));
typechecker::TypeId return_type_id = function_return_type_id;
if ((((function_return_type_id).equals(typechecker::unknown_type_id())) && (!((((block).statements)).is_empty())))){
if ((((((block).statements))[static_cast<i64>(0LL)]))->has<typechecker::CheckedStatement::Return>()){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = (((((block).statements))[static_cast<i64>(0LL)])->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
(return_type_id = typechecker::expression_type((val.value())));
}
else {
(return_type_id = VOID_TYPE_ID);
}

}
else {
(return_type_id = VOID_TYPE_ID);
}

}
else if (((function_return_type_id).equals(typechecker::unknown_type_id()))){
(return_type_id = VOID_TYPE_ID);
}
if (((!(structure_linkage).has<parser::DefinitionLinkage::External>()) && ((!((return_type_id).equals(VOID_TYPE_ID))) && (!((((block).control_flow)).always_transfers_control()))))){
if ((((return_type_id).equals(typechecker::never_type_id())) && (!((((block).control_flow)).never_returns())))){
TRY((((*this).error(String("Control reaches end of never-returning function"),((func).name_span)))));
}
else if ((!((((block).control_flow)).never_returns()))){
TRY((((*this).error(String("Control reaches end of non-void function"),((func).name_span)))));
}
}
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
return {};
}

bool typechecker::Typechecker::expression_is_mutable(const NonnullRefPtr<typechecker::CheckedExpression> expr) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).is_mutable));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<bool> typechecker::Typechecker::add_struct_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::StructId struct_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::StructId> maybe_scope_id = ((((scope)->structs)).get(name));
if (((maybe_scope_id).has_value())){
const typechecker::StructId existing_struct_id = (maybe_scope_id.value());
const utility::Span definition_span = ((((*this).get_struct(existing_struct_id))).name_span);
TRY((((*this).error_with_hint(TRY((String::formatted(String("redefinition of struct/class {}"),name))),span,TRY((String::formatted(String("struct/class {} was first defined here"),name))),definition_span))));
return (false);
}
TRY((((((scope)->structs)).set(name,struct_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_unary_negate(const NonnullRefPtr<typechecker::CheckedExpression> expr,const utility::Span span,const typechecker::TypeId type_id) {
{
if (((!((((*this).program))->is_integer(type_id))) || ((((*this).program))->is_signed(type_id)))){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
const typechecker::TypeId flipped_sign_type = TRY((typechecker::flip_signedness(((*this).get_type(type_id)))));
const typechecker::CheckedNumericConstant constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(val);
};/*case end*/
default: {
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
};/*case end*/
}/*switch end*/
}()
));
const typechecker::NumberConstant number = (((constant).number_constant()).value());
const size_t raw_number = ((number).to_usize());
const size_t max_signed = (infallible_integer_cast<size_t>(((TRY((typechecker::Type::template create<typename typechecker::Type::I64>())))->max())));
i64 negated_number = static_cast<i64>(0LL);
if ((raw_number == (JaktInternal::checked_add<size_t>(max_signed,static_cast<size_t>(1ULL))))){
(negated_number = ((TRY((typechecker::Type::template create<typename typechecker::Type::I64>())))->min()));
}
if ((raw_number <= max_signed)){
(negated_number = (JaktInternal::checked_sub<i64>(static_cast<i64>(0LL),(infallible_integer_cast<i64>(raw_number)))));
}
const typechecker::NumberConstant negated_number_constant = typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>(negated_number)));
if (((raw_number > (JaktInternal::checked_add<size_t>(max_signed,static_cast<size_t>(1ULL)))) || (!((negated_number_constant).can_fit_number(flipped_sign_type,((*this).program)))))){
TRY((((*this).error(TRY((String::formatted(String("Negative literal -{} too small for type {}"),raw_number,TRY((((*this).type_name(flipped_sign_type))))))),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
const typechecker::CheckedNumericConstant new_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(flipped_sign_type));
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>(negated_number))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>(negated_number))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>(negated_number))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64((infallible_integer_cast<i64>(negated_number))));
};/*case end*/
default: {
{
utility::panic(String("Unreachable"));
}
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(new_constant,span,type_id))),typename typechecker::CheckedUnaryOperator::Negate(),span,flipped_sign_type))));
}
}

ErrorOr<Optional<typechecker::FunctionId>> typechecker::Typechecker::resolve_call(const parser::ParsedCall call,Array<typechecker::ResolvedNamespace> namespaces,const utility::Span span,const typechecker::ScopeId scope_id,const bool must_be_enum_constructor) {
{
Optional<typechecker::FunctionId> callee = JaktInternal::OptionalNone();
typechecker::ScopeId current_scope_id = scope_id;
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).namespace_)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t namespace_index = (_magic_value.value());
{
const String scope_name = ((((call).namespace_))[namespace_index]);
const Optional<Tuple<typechecker::ScopeId,bool>> maybe_ns_scope = TRY((((*this).find_namespace_in_scope(current_scope_id,scope_name))));
if (((maybe_ns_scope).has_value())){
const typechecker::ScopeId scope_id = (((maybe_ns_scope.value())).get<0>());
const bool is_import = (((maybe_ns_scope.value())).get<1>());
if (is_import){
(((((namespaces)[namespace_index])).name) = ((((((((*this).program))->modules))[((((scope_id).module_id)).id)]))->name));
}
(current_scope_id = scope_id);
continue;
}
const Optional<typechecker::StructId> maybe_struct_scope = TRY((((*this).find_struct_in_scope(current_scope_id,scope_name))));
if (((maybe_struct_scope).has_value())){
const typechecker::CheckedStruct structure = ((*this).get_struct((maybe_struct_scope.value())));
(current_scope_id = ((structure).scope_id));
continue;
}
const Optional<typechecker::EnumId> maybe_enum_scope = TRY((((((*this).program))->find_enum_in_scope(current_scope_id,scope_name))));
if (((maybe_enum_scope).has_value())){
const typechecker::CheckedEnum enum_ = ((*this).get_enum((maybe_enum_scope.value())));
(current_scope_id = ((enum_).scope_id));
continue;
}
TRY((((*this).error(TRY((String::formatted(String("Not a namespace, enum, class, or struct: {}"),utility::join(((call).namespace_),String("::"))))),span))));
}

}
}

const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(current_scope_id,((call).name)))));
if (((maybe_function_id).has_value())){
const typechecker::FunctionId function_id = (maybe_function_id.value());
if (((!must_be_enum_constructor) || (((((*this).get_function(function_id)))->type)).has<parser::FunctionType::ImplicitEnumConstructor>())){
return (function_id);
}
}
if (must_be_enum_constructor){
TRY((((*this).error(TRY((String::formatted(String("No such enum constructor {}"),((call).name)))),span))));
return (callee);
}
const Optional<typechecker::StructId> maybe_struct_id = TRY((((*this).find_struct_in_scope(current_scope_id,((call).name)))));
if (((maybe_struct_id).has_value())){
const typechecker::StructId struct_id = (maybe_struct_id.value());
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(((structure).scope_id),((call).name)))));
if (((maybe_function_id).has_value())){
return ((maybe_function_id.value()));
}
return (callee);
}
TRY((((*this).error(TRY((String::formatted(String("Call to unknown function: {}"),((call).name)))),span))));
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedProgram>> typechecker::Typechecker::typecheck(NonnullRefPtr<compiler::Compiler> compiler,const parser::ParsedNamespace parsed_namespace) {
{
const Optional<utility::FileId> input_file = ((compiler)->current_file);
if ((!((input_file).has_value()))){
TRY((((compiler)->panic(String("trying to typecheck a non-existant file")))));
}
const typechecker::ModuleId placeholder_module_id = typechecker::ModuleId(static_cast<size_t>(0ULL));
typechecker::Typechecker typechecker = typechecker::Typechecker(compiler,TRY((typechecker::CheckedProgram::create(compiler,(TRY((Array<NonnullRefPtr<typechecker::Module>>::create_with({})))),(TRY((Dictionary<String, typechecker::LoadedModule>::create_with_entries({}))))))),placeholder_module_id,typechecker::TypeId::none(),JaktInternal::OptionalNone(),false,static_cast<size_t>(0ULL),false,((compiler)->dump_type_hints),((compiler)->dump_try_hints),static_cast<u64>(0ULL));
TRY((((typechecker).include_prelude())));
const String root_module_name = String("Root Module");
const typechecker::ModuleId root_module_id = TRY((((typechecker).create_module(root_module_name,true))));
(((typechecker).current_module_id) = root_module_id);
((compiler)->set_current_file((input_file.value())));
TRY((((((typechecker).program))->set_loaded_module(root_module_name,typechecker::LoadedModule(root_module_id,(input_file.value()))))));
const typechecker::ScopeId PRELUDE_SCOPE_ID = ((typechecker).prelude_scope_id());
const typechecker::ScopeId root_scope_id = TRY((((typechecker).create_scope(PRELUDE_SCOPE_ID,false,String("root")))));
TRY((((typechecker).typecheck_module(parsed_namespace,root_scope_id))));
return (((typechecker).program));
}
}

ErrorOr<bool> typechecker::Typechecker::add_enum_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::EnumId enum_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::EnumId> maybe_enum_id = ((((scope)->enums)).get(name));
if (((maybe_enum_id).has_value())){
const typechecker::EnumId existing_enum_id = (maybe_enum_id.value());
const utility::Span definition_span = ((((*this).get_enum(existing_enum_id))).name_span);
TRY((((*this).error_with_hint(TRY((String::formatted(String("redefinition of enum {}"),name))),span,TRY((String::formatted(String("enum {} was first defined here"),name))),definition_span))));
return (false);
}
TRY((((((scope)->enums)).set(name,enum_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_dictionary(const Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> checked_kv_pairs = (TRY((Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
typechecker::TypeId key_type_id = typechecker::unknown_type_id();
Optional<utility::Span> key_type_span = JaktInternal::OptionalNone();
typechecker::TypeId value_type_id = typechecker::unknown_type_id();
Optional<utility::Span> value_type_span = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> key_hint = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> value_hint = JaktInternal::OptionalNone();
if ((((type_hint).has_value()) && (((*this).get_type((type_hint.value()))))->has<typechecker::Type::GenericInstance>())){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(dictionary_struct_id))){
(key_hint = ((args)[static_cast<i64>(0LL)]));
(value_hint = ((args)[static_cast<i64>(1LL)]));
}
}
{
ArrayIterator<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((values).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>> kv_pair = (_magic_value.value());
{
const NonnullRefPtr<parser::ParsedExpression> key = ((kv_pair).get<0>());
const NonnullRefPtr<parser::ParsedExpression> value = ((kv_pair).get<1>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_key = TRY((((*this).typecheck_expression(key,scope_id,safety_mode,key_hint))));
const typechecker::TypeId current_key_type_id = typechecker::expression_type(checked_key);
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,value_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_value);
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
if ((((key_type_id).equals(typechecker::unknown_type_id())) && ((value_type_id).equals(typechecker::unknown_type_id())))){
if (((current_key_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Can't create a dictionary with keys of type void"),((key)->span())))));
}
if (((current_value_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Can't create a dictionary with values of type void"),((value)->span())))));
}
(key_type_id = current_key_type_id);
(key_type_span = (((key)->span())));
(value_type_id = current_value_type_id);
(value_type_span = (((value)->span())));
}
else {
if ((!((key_type_id).equals(current_key_type_id)))){
const String key_type_name = TRY((((*this).type_name(key_type_id))));
const String current_key_type_name = TRY((((*this).type_name(current_key_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous keys in dictionary"),current_key_type_name,key_type_name))),((key)->span()),TRY((String::formatted(String("Dictionary was inferred to store keys of type '{}' here"),key_type_name))),(key_type_span.value())))));
}
if ((!((value_type_id).equals(current_value_type_id)))){
const String value_type_name = TRY((((*this).type_name(value_type_id))));
const String current_value_type_name = TRY((((*this).type_name(current_value_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in dictionary"),current_value_type_name,value_type_name))),((value)->span()),TRY((String::formatted(String("Dictionary was inferred to store values of type '{}' here"),value_type_name))),(value_type_span.value())))));
}
}

TRY((((checked_kv_pairs).push((Tuple{checked_key, checked_value})))));
}

}
}

if (((key_type_id).equals(typechecker::unknown_type_id()))){
if (((key_hint).has_value())){
(key_type_id = (key_hint.value()));
}
else {
TRY((((*this).error(String("Cannot infer key type for Dictionary<K, V>"),span))));
}

}
if (((value_type_id).equals(typechecker::unknown_type_id()))){
if (((value_hint).has_value())){
(value_type_id = (value_hint.value()));
}
else {
TRY((((*this).error(String("Cannot infer value type for Dictionary"),span))));
}

}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(dictionary_struct_id,(TRY((Array<typechecker::TypeId>::create_with({key_type_id, value_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktDictionary>(checked_kv_pairs,span,type_id,key_type_id,value_type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_if(const NonnullRefPtr<parser::ParsedExpression> condition,const parser::ParsedBlock then_block,const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(condition,JaktInternal::OptionalNone(),then_block,else_statement,span))));
const NonnullRefPtr<parser::ParsedExpression> new_condition = ((new_condition_new_then_block_new_else_statement_).get<0>());
const parser::ParsedBlock new_then_block = ((new_condition_new_then_block_new_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = ((new_condition_new_then_block_new_else_statement_).get<2>());

const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((new_condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(new_then_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("An 'if' block is not allowed to yield values"),(((new_then_block).find_yield_span()).value())))));
}
Optional<NonnullRefPtr<typechecker::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode)))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::If>(checked_condition,checked_block,checked_else,span))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::unify_with_type(const typechecker::TypeId found_type,const Optional<typechecker::TypeId> expected_type,const utility::Span span) {
{
if ((!((expected_type).has_value()))){
return (found_type);
}
if ((((expected_type.value())).equals(typechecker::unknown_type_id()))){
return (found_type);
}
const Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
if (TRY((((*this).check_types_for_compat((expected_type.value()),found_type,generic_inferences,span))))){
return (found_type);
}
return (TRY((((*this).substitute_typevars_in_type(found_type,generic_inferences)))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_throw(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId error_type_id = TRY((((*this).find_type_in_prelude(String("Error")))));
if ((!((typechecker::expression_type(checked_expr)).equals(error_type_id)))){
TRY((((*this).error(String("throw expression does not produce an error"),((expr)->span())))));
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
if ((!((scope)->can_throw))){
TRY((((*this).error(String("Throw statement needs to be in a try statement or a function marked as throws"),((expr)->span())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Throw>(checked_expr,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_destructuring_assignment(const Array<parser::ParsedVarDecl> vars,const NonnullRefPtr<parser::ParsedStatement> var_decl,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
Array<NonnullRefPtr<typechecker::CheckedStatement>> var_decls = (TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({}))));
const NonnullRefPtr<typechecker::CheckedStatement> checked_tuple_var_decl = TRY((((*this).typecheck_statement(var_decl,scope_id,safety_mode))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
typechecker::VarId tuple_var_id = typechecker::VarId(typechecker::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL));
if ((checked_tuple_var_decl)->has<typechecker::CheckedStatement::VarDecl>()){
const typechecker::VarId var_id = (checked_tuple_var_decl->get<typechecker::CheckedStatement::VarDecl>()).var_id;
const NonnullRefPtr<typechecker::CheckedExpression> init = (checked_tuple_var_decl->get<typechecker::CheckedStatement::VarDecl>()).init;
(expr_type_id = typechecker::expression_type(init));
(tuple_var_id = var_id);
}
else {
TRY((((*this).error(String("Destructuting assignment should be a variable declaration"),span))));
}

Array<typechecker::TypeId> inner_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
const NonnullRefPtr<typechecker::Type> tuple_type = ((*this).get_type(expr_type_id));
if ((tuple_type)->has<typechecker::Type::GenericInstance>()){
const Array<typechecker::TypeId> args = (tuple_type->get<typechecker::Type::GenericInstance>()).args;
(inner_types = args);
}
else {
TRY((((*this).error(String("Tuple Type should be Generic Instance"),span))));
}

const typechecker::CheckedVariable tuple_variable = ((((*this).program))->get_variable(tuple_var_id));
if ((((vars).size()) == ((inner_types).size()))){
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vars).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedVarDecl new_var = ((vars)[i]);
(((new_var).parsed_type) = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(TRY((((*this).type_name(((inner_types)[i]))))),span))));
const NonnullRefPtr<parser::ParsedExpression> init = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(((tuple_variable).name),span))),i,false,span)));
TRY((((var_decls).push(TRY((((*this).typecheck_var_decl(((vars)[i]),init,scope_id,safety_mode,span))))))));
}

}
}

}
else {
TRY((((*this).error(String("Tuple inner types sould have same size as tuple members"),span))));
}

return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::DestructuringAssignment>(var_decls,checked_tuple_var_decl,span))));
}
}

typechecker::ScopeId typechecker::Typechecker::prelude_scope_id() const {
{
return (((((*this).program))->prelude_scope_id()));
}
}

typechecker::BlockControlFlow typechecker::Typechecker::statement_control_flow(const NonnullRefPtr<typechecker::CheckedStatement> statement) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(true));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(false));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((typechecker::checked_expression_control_flow(expr)).updated(typename typechecker::BlockControlFlow::AlwaysTransfersControl(false))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((then_block).control_flow));
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).statement_control_flow((else_statement.value()))));
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((then_block).control_flow);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow)));
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((((block).control_flow)).may_break()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}()))
);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<typechecker::ScopeId> typechecker::Typechecker::create_scope(const Optional<typechecker::ScopeId> parent_scope_id,const bool can_throw,const String debug_name) {
{
if (((parent_scope_id).has_value())){
if (((((((parent_scope_id.value())).module_id)).id) >= ((((((*this).program))->modules)).size()))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("create_scope: parent_scope_id.module is invalid! No module with id {}."),(((((parent_scope_id.value())).module_id)).id))))))));
}
if (((((parent_scope_id.value())).id) >= ((((((((((*this).program))->modules))[(((((parent_scope_id.value())).module_id)).id)]))->scopes)).size()))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}."),(((((parent_scope_id.value())).module_id)).id),(((parent_scope_id.value())).id))))))));
}
}
const Optional<String> none_string = JaktInternal::OptionalNone();
const NonnullRefPtr<typechecker::Scope> scope = TRY((typechecker::Scope::create(none_string,(TRY((Dictionary<String, typechecker::VarId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::StructId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::FunctionId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::EnumId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::TypeId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::ModuleId>::create_with_entries({})))),parent_scope_id,(TRY((Array<typechecker::ScopeId>::create_with({})))),can_throw,JaktInternal::OptionalNone(),debug_name)));
TRY((((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->scopes)).push(scope))));
return (typechecker::ScopeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->scopes)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<bool> typechecker::Typechecker::validate_argument_label(const typechecker::CheckedParameter param,const String label,const utility::Span span,const NonnullRefPtr<parser::ParsedExpression> expr) {
{
if ((label == ((((param).variable)).name))){
return (true);
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((name == ((((param).variable)).name))){
return (true);
}
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got '{}', expected '{}')"),name,((((param).variable)).name)))),span))));
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
if (((op).has<parser::UnaryOperator::Reference>() || (op).has<parser::UnaryOperator::MutableReference>())){
if ((expr)->has<parser::ParsedExpression::Var>()){
const String name = (expr->get<parser::ParsedExpression::Var>()).name;
const utility::Span span = (expr->get<parser::ParsedExpression::Var>()).span;
if ((name == ((((param).variable)).name))){
return (true);
}
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got {}, expected {})"),name,((((param).variable)).name)))),span))));
return (false);
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got '{}', expected '{}')"),label,((((param).variable)).name)))),span))));
return (false);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_indexed_struct(const NonnullRefPtr<parser::ParsedExpression> expr,const String field,const typechecker::ScopeId scope_id,const bool is_optional,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId checked_expr_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> checked_expr_type = ((*this).get_type(checked_expr_type_id));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_expr_type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
typechecker::TypeId type_id = checked_expr_type_id;
if (is_optional){
if ((!((id).equals(optional_struct_id)))){
TRY((((*this).error(String("Optional chaining is only allowed on optional types"),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,typechecker::unknown_type_id()))));
}
(type_id = ((args)[static_cast<i64>(0LL)]));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
{
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((String::formatted(String("Member field access on value of non-struct type {}"),TRY((((*this).type_name(checked_expr_type_id))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
if (is_optional){
TRY((((*this).error(String("Optional chaining is not allowed on non-optional types"),span))));
}
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
const typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((String::formatted(String("Member field access on value of non-struct type {}"),TRY((((*this).type_name(checked_expr_type_id))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,typechecker::unknown_type_id()))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_function_predecl(const parser::ParsedFunction parsed_function,const typechecker::ScopeId parent_scope_id,const Optional<typechecker::TypeId> this_arg_type_id) {
{
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),TRY((String::formatted(String("function({})"),((parsed_function).name))))))));
const String scope_debug_name = TRY((String::formatted(String("function-block({})"),((parsed_function).name))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,((parsed_function).can_throw),scope_debug_name))));
const size_t module_id = ((((*this).current_module_id)).id);
const bool is_generic_function = (!((((parsed_function).generic_parameters)).is_empty()));
const bool is_generic = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool,ErrorOr<void>>{
auto __jakt_enum_value = (((this_arg_type_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = *((*this).get_type((this_arg_type_id.value())));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(is_generic_function);
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(is_generic_function);
}
}()))
;
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((parsed_function).name),((parsed_function).name_span),((parsed_function).visibility),typechecker::unknown_type_id(),((parsed_function).return_type_span),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((parsed_function).can_throw),typename parser::FunctionType::Normal(),((parsed_function).linkage),function_scope_id,(!is_generic),parsed_function)));
NonnullRefPtr<typechecker::Module> current_module = ((*this).current_module());
const typechecker::FunctionId function_id = TRY((((current_module)->add_function(checked_function))));
const typechecker::ScopeId checked_function_scope_id = ((checked_function)->function_scope_id);
const bool external_linkage = (((parsed_function).linkage)).has<parser::FunctionLinkage::External>();
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_function).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
TRY((((((current_module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((generic_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((current_module)->id),(JaktInternal::checked_sub<size_t>(((((current_module)->types)).size()),static_cast<size_t>(1ULL))));
TRY((((((checked_function)->generic_params)).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
if (((!((parsed_function).must_instantiate)) || external_linkage)){
TRY((((*this).add_type_to_scope(checked_function_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
}

}
}

const Optional<typechecker::ScopeId> check_scope = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::ScopeId>,ErrorOr<void>>{
auto __jakt_enum_value = (is_generic);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),scope_debug_name))))));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}()))
;
bool first = true;
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::ParsedParameter> _magic = ((((parsed_function).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedParameter parameter = (_magic_value.value());
{
TRY((((((checked_function)->params)).push(TRY((((*this).typecheck_parameter(parameter,checked_function_scope_id,first,this_arg_type_id,check_scope))))))));
(first = false);
}

}
}

const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),checked_function_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
TRY((((*this).check_that_type_doesnt_contain_reference(function_return_type_id,((parsed_function).return_type_span)))));
if ((!((((parsed_function).generic_parameters)).is_empty()))){
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((parsed_function).block),(check_scope.value()),typename typechecker::SafetyMode::Safe()))));
(((*this).ignore_errors) = old_ignore_errors);
const typechecker::TypeId return_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((function_return_type_id).equals(typechecker::unknown_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_125; {
const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement = ((((block).statements)).last());
__jakt_var_125 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<void>>{
auto&& __jakt_match_variant = *(statement.value());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typechecker::expression_type((val.value())));
}
else {
return JaktInternal::ExplicitValue(typechecker::void_type_id());
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::void_type_id());
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(typechecker::unknown_type_id());
}
}()))
; goto __jakt_label_125;

}
__jakt_label_125:; __jakt_var_125.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).resolve_type_var(function_return_type_id,parent_scope_id)))));
}
}()))
;
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
TRY((((*this).add_function_to_scope(parent_scope_id,((parsed_function).name),function_id,((parsed_function).name_span)))));
}
return {};
}

typechecker::CheckedVariable typechecker::Typechecker::get_variable(const typechecker::VarId id) const {
{
return (((((*this).program))->get_variable(id)));
}
}

ErrorOr<void> typechecker::Typechecker::error(const String message,const utility::Span span) {
{
if ((!((*this).ignore_errors))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
}
return {};
}

ErrorOr<typechecker::ModuleId> typechecker::Typechecker::create_module(const String name,const bool is_root) {
{
const size_t new_id = ((((((*this).program))->modules)).size());
const typechecker::ModuleId module_id = typechecker::ModuleId(new_id);
const NonnullRefPtr<typechecker::Module> module = TRY((typechecker::Module::create(module_id,name,(TRY((Array<NonnullRefPtr<typechecker::CheckedFunction>>::create_with({})))),(TRY((Array<typechecker::CheckedStruct>::create_with({})))),(TRY((Array<typechecker::CheckedEnum>::create_with({})))),(TRY((Array<NonnullRefPtr<typechecker::Scope>>::create_with({})))),(TRY((Array<NonnullRefPtr<typechecker::Type>>::create_with({TRY((typechecker::Type::template create<typename typechecker::Type::Void>())), TRY((typechecker::Type::template create<typename typechecker::Type::Bool>())), TRY((typechecker::Type::template create<typename typechecker::Type::U8>())), TRY((typechecker::Type::template create<typename typechecker::Type::U16>())), TRY((typechecker::Type::template create<typename typechecker::Type::U32>())), TRY((typechecker::Type::template create<typename typechecker::Type::U64>())), TRY((typechecker::Type::template create<typename typechecker::Type::I8>())), TRY((typechecker::Type::template create<typename typechecker::Type::I16>())), TRY((typechecker::Type::template create<typename typechecker::Type::I32>())), TRY((typechecker::Type::template create<typename typechecker::Type::I64>())), TRY((typechecker::Type::template create<typename typechecker::Type::F32>())), TRY((typechecker::Type::template create<typename typechecker::Type::F64>())), TRY((typechecker::Type::template create<typename typechecker::Type::Usize>())), TRY((typechecker::Type::template create<typename typechecker::Type::JaktString>())), TRY((typechecker::Type::template create<typename typechecker::Type::CChar>())), TRY((typechecker::Type::template create<typename typechecker::Type::CInt>())), TRY((typechecker::Type::template create<typename typechecker::Type::Unknown>())), TRY((typechecker::Type::template create<typename typechecker::Type::Never>()))})))),(TRY((Array<typechecker::CheckedVariable>::create_with({})))),(TRY((Array<typechecker::ModuleId>::create_with({})))),is_root)));
TRY((((((((*this).program))->modules)).push(module))));
return (module_id);
}
}

typechecker::TypeId typechecker::Typechecker::infer_function_return_type(const typechecker::CheckedBlock block) const {
{
if (((((block).statements)).is_empty())){
return (typechecker::void_type_id());
}
if (((((((block).statements)).last()).value()))->has<typechecker::CheckedStatement::Return>()){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = ((((((block).statements)).last()).value())->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
return (typechecker::expression_type((val.value())));
}
}
return (typechecker::void_type_id());
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::substitute_typevars_in_type_helper(const typechecker::TypeId type_id,const Dictionary<String,String> generic_inferences) {
{
const NonnullRefPtr<typechecker::Type> type_ = ((*this).get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> replacment_type_id_string = ((generic_inferences).get(TRY((((type_id).to_string())))));
if (((replacment_type_id_string).has_value())){
return (TRY((typechecker::TypeId::from_string(((replacment_type_id_string).value())))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((args).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(id,new_args))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((args).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>(id,new_args))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(struct_id));
if ((!((((struct_).generic_parameters)).is_empty()))){
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((((struct_).generic_parameters)).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(struct_id,new_args))))))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
if ((!((((enum_).generic_parameters)).is_empty()))){
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((((enum_).generic_parameters)).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>(enum_id,new_args))))))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& rawptr_type_id = __jakt_match_value.value;
{
const NonnullRefPtr<typechecker::Type> rawptr_type = TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(TRY((((*this).substitute_typevars_in_type(rawptr_type_id,generic_inferences)))))));
return (TRY((((*this).find_or_add_type_id(rawptr_type)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (type_id);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_statement(const NonnullRefPtr<parser::ParsedStatement> statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedStatement>, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Expression>(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,typechecker::TypeId::none())))),span))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Block>(TRY((((*this).typecheck_block(block,scope_id,typename typechecker::SafetyMode::Unsafe())))),span))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Yield>(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,typechecker::TypeId::none())))),span))));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_return(expr,span,scope_id,safety_mode)))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_block_statement(block,scope_id,safety_mode,span)))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_inline_cpp(block,span,safety_mode)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& statement = __jakt_match_value.statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_defer(statement,scope_id,safety_mode,span)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_loop(block,scope_id,safety_mode,span)))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Try>();NonnullRefPtr<parser::ParsedStatement> const& stmt = __jakt_match_value.stmt;
String const& error_name = __jakt_match_value.error_name;
utility::Span const& error_span = __jakt_match_value.error_span;
parser::ParsedBlock const& catch_block = __jakt_match_value.catch_block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_try(stmt,error_name,error_span,catch_block,scope_id,safety_mode,span)))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_throw(expr,scope_id,safety_mode,span)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_while(condition,block,scope_id,safety_mode,span)))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Continue>(span))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Break>(span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& init = __jakt_match_value.init;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_var_decl(var,init,scope_id,safety_mode,span)))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& var_decl = __jakt_match_value.var_decl;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_destructuring_assignment(vars,var_decl,scope_id,safety_mode,span)))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& else_statement = __jakt_match_value.else_statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_if(condition,then_block,else_statement,scope_id,safety_mode,span)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Garbage>(span))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& iterator_name = __jakt_match_value.iterator_name;
utility::Span const& name_span = __jakt_match_value.name_span;
NonnullRefPtr<parser::ParsedExpression> const& range = __jakt_match_value.range;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_for(iterator_name,name_span,range,block,scope_id,safety_mode,span)))));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedBlock const& else_block = __jakt_match_value.else_block;
parser::ParsedBlock const& remaining_code = __jakt_match_value.remaining_code;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_guard(expr,else_block,remaining_code,scope_id,safety_mode,span)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::Typechecker::statement_never_returns(const NonnullRefPtr<typechecker::CheckedStatement> statement) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_126; {
bool never_returns = false;
if (((((call).function_id)).has_value())){
(never_returns = ((((((*this).get_function((((call).function_id).value()))))->return_type_id)).equals(typechecker::never_type_id())));
}
__jakt_var_126 = never_returns; goto __jakt_label_126;

}
__jakt_label_126:; __jakt_var_126.release_value(); }));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_127; {
bool never_returns = false;
if (((((call).function_id)).has_value())){
(never_returns = ((((((*this).get_function((((call).function_id).value()))))->return_type_id)).equals(typechecker::never_type_id())));
}
__jakt_var_127 = never_returns; goto __jakt_label_127;

}
__jakt_label_127:; __jakt_var_127.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(((((block).control_flow)).never_returns()));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::CheckedEnum typechecker::Typechecker::get_enum(const typechecker::EnumId id) const {
{
return (((((*this).program))->get_enum(id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum(const parser::ParsedRecord record,const typechecker::EnumId enum_id,const typechecker::ScopeId parent_scope_id) {
{
Array<typechecker::CheckedEnumVariant> checked_variants = (TRY((Array<typechecker::CheckedEnumVariant>::create_with({}))));
u64 next_constant_value = static_cast<u64>(0ULL);
Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();NonnullRefPtr<parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
Array<parser::ValueEnumVariant> const& variants = __jakt_match_value.variants;
{
const typechecker::TypeId underlying_type_id = TRY((((*this).typecheck_typename(underlying_type,parent_scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::ValueEnumVariant> _magic = ((variants).iterator());
for (;;){
Optional<parser::ValueEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ValueEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' is defined more than once"),((variant).name)))),((variant).span)))));
}
else {
TRY((((seen_names).add(((variant).name)))));
const NonnullRefPtr<typechecker::CheckedExpression> expr = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>,ErrorOr<void>>{
auto __jakt_enum_value = (((((variant).value)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_128; {
const NonnullRefPtr<typechecker::CheckedExpression> value_expression = TRY((((*this).cast_to_underlying((((variant).value).value()),parent_scope_id,underlying_type))));
const Optional<typechecker::NumberConstant> number_constant = ((value_expression)->to_number_constant(((*this).program)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<void>>{
auto __jakt_enum_value = (((number_constant).has_value()));
if (__jakt_enum_value == true) {
{
(next_constant_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u64, ErrorOr<void>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<u64>((JaktInternal::checked_add<i64>(val,static_cast<i64>(1LL))))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue((JaktInternal::checked_add<u64>(val,static_cast<u64>(1ULL))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<u64> __jakt_var_129; {
utility::todo(String("Implement floats"));
__jakt_var_129 = static_cast<u64>(0ULL); goto __jakt_label_129;

}
__jakt_label_129:; __jakt_var_129.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' in enum '{}' has a non-constant value: {}"),((variant).name),((enum_).name),value_expression))),((variant).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_128 = value_expression; goto __jakt_label_128;

}
__jakt_label_128:; __jakt_var_128.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).cast_to_underlying(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NumericConstant>(typename lexer::NumericConstant::U64((next_constant_value++)),((variant).span)))),parent_scope_id,underlying_type)))));
}
}()))
;
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::WithValue(enum_id,((variant).name),expr,((variant).span))))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant).name),((enum_).type_id),false,((variant).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(((enum_).scope_id),((variant).name),var_id,((variant).span)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
Array<parser::SumEnumVariant> const& variants = __jakt_match_value.variants;
{
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::SumEnumVariant> _magic = ((variants).iterator());
for (;;){
Optional<parser::SumEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::SumEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' is defined more than once"),((variant).name)))),((variant).span)))));
continue;
}
TRY((((seen_names).add(((variant).name)))));
const bool is_structlike = ((((((variant).params)).has_value()) && ((((((variant).params).value())).size()) > static_cast<size_t>(0ULL))) && ((((((((variant).params).value()))[static_cast<i64>(0LL)])).name) != String("")));
const bool is_typed = ((((((variant).params)).has_value()) && ((((((variant).params).value())).size()) == static_cast<size_t>(1ULL))) && ((((((((variant).params).value()))[static_cast<i64>(0LL)])).name) == String("")));
if (is_structlike){
Set<String> seen_fields = (TRY((Set<String>::create_with_values({}))));
Array<typechecker::VarId> fields = (TRY((Array<typechecker::VarId>::create_with({}))));
Array<typechecker::CheckedParameter> params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = (((((variant).params).value())).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedVarDecl param = (_magic_value.value());
{
if (((seen_fields).contains(((param).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' has a member named '{}' more than once"),((variant).name),((param).name)))),((param).span)))));
continue;
}
TRY((((seen_fields).add(((param).name)))));
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
const typechecker::CheckedVariable checked_var = typechecker::CheckedVariable(((param).name),type_id,((param).is_mutable),((param).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((params).push(typechecker::CheckedParameter(true,checked_var)))));
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint(type_id,((param).span)))));
}
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_var))));
TRY((((fields).push(var_id))));
}

}
}

TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::StructLike(enum_id,((variant).name),fields,((variant).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!((maybe_enum_variant_constructor).has_value()))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone())));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}
else if (is_typed){
const parser::ParsedVarDecl param = (((((variant).params).value()))[static_cast<i64>(0LL)]);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::Typed(enum_id,((variant).name),type_id,((param).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!((maybe_enum_variant_constructor).has_value()))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::CheckedVariable variable = typechecker::CheckedVariable(String("value"),type_id,false,((param).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({typechecker::CheckedParameter(false,variable)})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::AlwaysReturns(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone())));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}
else {
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::Untyped(enum_id,((variant).name),((variant).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!((maybe_enum_variant_constructor).has_value()))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::AlwaysReturns(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone())));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_method(((method).parsed_function),typename typechecker::StructOrEnumId::Enum(enum_id)))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_var_decl(const parser::ParsedVarDecl var,const NonnullRefPtr<parser::ParsedExpression> init,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
typechecker::TypeId lhs_type_id = TRY((((*this).typecheck_typename(((var).parsed_type),scope_id,((var).name)))));
NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(init,scope_id,safety_mode,lhs_type_id))));
const typechecker::TypeId rhs_type_id = typechecker::expression_type(checked_expr);
if ((((lhs_type_id).equals(typechecker::unknown_type_id())) && (!((rhs_type_id).equals(typechecker::unknown_type_id()))))){
(lhs_type_id = rhs_type_id);
}
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_rhs = TRY((((*this).try_to_promote_constant_expr_to_type(lhs_type_id,checked_expr,((init)->span())))));
if (((promoted_rhs).has_value())){
(checked_expr = (promoted_rhs.value()));
}
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
TRY((((*this).check_that_type_doesnt_contain_reference(lhs_type_id,span))));
if ((lhs_type)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (lhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (lhs_type->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(weak_ptr_struct_id))){
if ((!((var).is_mutable))){
TRY((((*this).error(String("Weak reference must be mutable"),((var).span)))));
}
if (((!((lhs_type_id).equals(rhs_type_id))) && ((!((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id))) && (!((rhs_type_id).equals(typechecker::unknown_type_id())))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),((*this).expression_span(checked_expr))))));
}
}
else if (((id).equals(optional_struct_id))){
if (((!((lhs_type_id).equals(rhs_type_id))) && ((!((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id))) && (!((rhs_type_id).equals(typechecker::unknown_type_id())))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),((*this).expression_span(checked_expr))))));
}
}
else {
if (((!((lhs_type_id).equals(rhs_type_id))) && (!((rhs_type_id).equals(typechecker::unknown_type_id()))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),((*this).expression_span(checked_expr))))));
}
}

}
else if (((lhs_type)->is_builtin())){
const Optional<typechecker::NumberConstant> number_constant = ((checked_expr)->to_number_constant(((*this).program)));
bool is_rhs_zero = false;
if (((number_constant).has_value())){
(is_rhs_zero = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<i64>(0LL)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<u64>(0ULL)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<f64>(0)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
if (((!(((*this).is_numeric(lhs_type_id)) && is_rhs_zero)) && (((*this).is_integer(lhs_type_id)) ^ ((*this).is_integer(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),((*this).expression_span(checked_expr))))));
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Garbage>(span))));
}
}
else {
if (((!((lhs_type_id).equals(rhs_type_id))) && (!((rhs_type_id).equals(typechecker::unknown_type_id()))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),((*this).expression_span(checked_expr))))));
}
}

const typechecker::CheckedVariable checked_var = typechecker::CheckedVariable(((var).name),lhs_type_id,((var).is_mutable),((var).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
if ((((*this).dump_type_hints) && ((((var).inlay_span)).has_value()))){
TRY((((*this).dump_type_hint(lhs_type_id,(((var).inlay_span).value())))));
}
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_var))));
TRY((((*this).add_var_to_scope(scope_id,((var).name),var_id,((checked_var).definition_span)))));
if ((checked_expr)->has<typechecker::CheckedExpression::Function>()){
const Array<typechecker::CheckedParameter> params = (checked_expr->get<typechecker::CheckedExpression::Function>()).params;
const bool can_throw = (checked_expr->get<typechecker::CheckedExpression::Function>()).can_throw;
const typechecker::TypeId return_type_id = (checked_expr->get<typechecker::CheckedExpression::Function>()).return_type_id;
const typechecker::CheckedBlock block = (checked_expr->get<typechecker::CheckedExpression::Function>()).block;
const utility::Span span = (checked_expr->get<typechecker::CheckedExpression::Function>()).span;
const typechecker::TypeId type_id = (checked_expr->get<typechecker::CheckedExpression::Function>()).type_id;
if ((!((TRY((((*this).find_function_in_scope(scope_id,((var).name)))))).has_value()))){
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((var).name),((var).span),typename parser::Visibility::Public(),return_type_id,JaktInternal::OptionalNone(),params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),block,can_throw,typename parser::FunctionType::Normal(),typename parser::FunctionLinkage::Internal(),scope_id,false,JaktInternal::OptionalNone())));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(scope_id,((var).name),function_id,span))));
}
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::VarDecl>(var_id,checked_expr,span))));
}
}

ErrorOr<Optional<Array<typechecker::CheckedEnumVariantBinding>>> typechecker::Typechecker::typecheck_enum_variant_bindings(const typechecker::CheckedEnumVariant variant,const Array<parser::EnumVariantPatternArgument> bindings,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<Array<typechecker::CheckedEnumVariantBinding>>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
Array<typechecker::CheckedVariable> checked_vars = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
Array<typechecker::CheckedEnumVariantBinding> checked_enum_variant_bindings = (TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
TRY((((checked_vars).push(((*this).get_variable(field))))));
}

}
}

{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((checked_vars).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
const String binding_name = ((binding).name).value_or_lazy_evaluated([&] { return ((binding).binding); });
const typechecker::TypeId type_id = ((var).type_id);
if ((binding_name == ((var).name))){
TRY((((checked_enum_variant_bindings).push(typechecker::CheckedEnumVariantBinding(((binding).name),((binding).binding),type_id,span)))));
break;
}
}

}
}

}

}
}

if ((((checked_enum_variant_bindings).size()) > static_cast<size_t>(0ULL))){
return (checked_enum_variant_bindings);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
if ((((bindings).size()) == static_cast<size_t>(1ULL))){
return ((TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({typechecker::CheckedEnumVariantBinding(JaktInternal::OptionalNone(),((((bindings)[static_cast<i64>(0LL)])).binding),type_id,span)})))));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} must have exactly one argument"),((variant).name())))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (JaktInternal::OptionalNone());
}
}

ErrorOr<typechecker::CheckedParameter> typechecker::Typechecker::typecheck_parameter(const parser::ParsedParameter parameter,const typechecker::ScopeId scope_id,const bool first,const Optional<typechecker::TypeId> this_arg_type_id,const Optional<typechecker::ScopeId> check_scope) {
{
typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((((parameter).variable)).parsed_type),scope_id,((((parameter).variable)).name)))));
if ((first && (((((parameter).variable)).name) == String("this")))){
if (((this_arg_type_id).has_value())){
(type_id = (this_arg_type_id.value()));
}
}
const typechecker::CheckedVariable variable = typechecker::CheckedVariable(((((parameter).variable)).name),type_id,((((parameter).variable)).is_mutable),((((parameter).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
const typechecker::CheckedParameter checked_parameter = typechecker::CheckedParameter(((parameter).requires_label),variable);
if (((check_scope).has_value())){
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((parameter).variable)).name),var_id,((((parameter).variable)).span)))));
}
return (checked_parameter);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct(const parser::ParsedRecord record,const typechecker::StructId struct_id,const typechecker::ScopeId parent_scope_id) {
{
const typechecker::ScopeId checked_struct_scope_id = ((((*this).get_struct(struct_id))).scope_id);
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
const typechecker::ModuleId module_id = ((*this).current_module_id);
(((*this).current_struct_type_id) = struct_type_id);
const Optional<typechecker::FunctionId> constructor_id = TRY((((*this).find_function_in_scope(checked_struct_scope_id,((record).name)))));
if (((constructor_id).has_value())){
if (((((record).record_type)).has<parser::RecordType::Class>() && (((record).definition_linkage)).has<parser::DefinitionLinkage::External>())){
NonnullRefPtr<typechecker::CheckedFunction> func = ((*this).get_function((constructor_id.value())));
(((func)->linkage) = typename parser::FunctionLinkage::External());
}
}
else if ((!(((record).definition_linkage)).has<parser::DefinitionLinkage::External>())){
const bool constructor_can_throw = (((record).record_type)).has<parser::RecordType::Class>();
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,constructor_can_throw,TRY((String::formatted(String("generated-constructor({})"),((record).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,constructor_can_throw,TRY((String::formatted(String("generated-constructor-block({})"),((record).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_constructor = TRY((typechecker::CheckedFunction::create(((record).name),((record).name_span),typename parser::Visibility::Public(),struct_type_id,JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),constructor_can_throw,typename parser::FunctionType::ImplicitConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone())));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->functions)).push(checked_constructor))));
NonnullRefPtr<typechecker::CheckedFunction> func = (((((module)->functions)).last()).value());
{
ArrayIterator<typechecker::VarId> _magic = ((((((*this).get_struct(struct_id))).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
const typechecker::CheckedVariable field = ((*this).get_variable(field_id));
TRY((((((func)->params)).push(typechecker::CheckedParameter(true,field)))));
}

}
}

TRY((((*this).add_function_to_scope(checked_struct_scope_id,((record).name),typechecker::FunctionId(module_id,(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL)))),((record).name_span)))));
}
{
ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_method(((method).parsed_function),typename typechecker::StructOrEnumId::Struct(struct_id)))));
}

}
}

(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl_initial(const parser::ParsedRecord parsed_record,const size_t struct_index,const size_t module_struct_len,const typechecker::ScopeId scope_id) {
{
const typechecker::ModuleId module_id = ((*this).current_module_id);
const typechecker::StructId struct_id = typechecker::StructId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(struct_index,module_struct_len)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
const typechecker::TypeId struct_type_id = typechecker::TypeId(module_id,(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),struct_type_id,((parsed_record).name_span)))));
TRY((((((module)->structures)).push(typechecker::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::VarId>::create_with({})))),((*this).prelude_scope_id()),((parsed_record).definition_linkage),((parsed_record).record_type),struct_type_id)))));
}
return {};
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_generic_resolved_type(const String name,const Array<typechecker::TypeId> checked_inner_types,const typechecker::ScopeId scope_id,const utility::Span span) {
{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,name))));
if (((struct_id).has_value())){
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>((struct_id.value()),checked_inner_types))))))));
}
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,name))));
if (((enum_id).has_value())){
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>((enum_id.value()),checked_inner_types))))))));
}
TRY((((*this).error(TRY((String::formatted(String("could not find {}"),name))),span))));
return (typechecker::unknown_type_id());
}
}

typechecker::BlockControlFlow typechecker::Typechecker::maybe_statement_control_flow(const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement,const typechecker::BlockControlFlow other_branch) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).statement_control_flow((statement.value()))));
}
else {
return JaktInternal::ExplicitValue(((other_branch).partial()));
}
}()))
);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_jakt_main(const parser::ParsedFunction parsed_function) {
{
const String param_type_error = String("Main function must take a single array of strings as its parameter");
if ((((((parsed_function).params)).size()) > static_cast<size_t>(1ULL))){
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}
if ((!((((parsed_function).params)).is_empty()))){
if ((((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type))->has<parser::ParsedType::JaktArray>()){
const NonnullRefPtr<parser::ParsedType> inner = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type)->get<parser::ParsedType::JaktArray>()).inner;
const utility::Span span = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type)->get<parser::ParsedType::JaktArray>()).span;
if ((inner)->has<parser::ParsedType::Name>()){
const String name = (inner->get<parser::ParsedType::Name>()).name;
const utility::Span span = (inner->get<parser::ParsedType::Name>()).span;
if ((name != String("String"))){
TRY((((*this).error(param_type_error,span))));
}
}
else {
TRY((((*this).error(param_type_error,span))));
}

}
else {
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}

}
const String return_type_error = String("Main function must return c_int");
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((parsed_function).return_type);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((name != String("c_int"))){
TRY((((*this).error(return_type_error,span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(return_type_error,((parsed_function).return_type_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_for(const String iterator_name,const utility::Span name_span,const NonnullRefPtr<parser::ParsedExpression> range,const parser::ParsedBlock block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const Optional<utility::Span> maybe_span = ((block).find_yield_span());
if (((maybe_span).has_value())){
TRY((((*this).error(String("a 'for' loop block is not allowed to yield values"),(maybe_span.value())))));
}
const NonnullRefPtr<typechecker::CheckedExpression> iterable_expr = TRY((((*this).typecheck_expression(range,scope_id,safety_mode,JaktInternal::OptionalNone()))));
bool iterable_should_be_mutable = false;
const NonnullRefPtr<typechecker::Type> iterable_type = ((((*this).program))->get_type(typechecker::expression_type(iterable_expr)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *iterable_type;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
(iterable_should_be_mutable = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(id));
const Optional<typechecker::FunctionId> next_method_function_id = TRY((((*this).find_function_in_scope(((struct_).scope_id),String("next")))));
if ((!((next_method_function_id).has_value()))){
TRY((((*this).error(String("Iterator must have a .next() method"),((range)->span())))));
}
else {
const NonnullRefPtr<typechecker::CheckedFunction> next_method_function = ((*this).get_function((next_method_function_id.value())));
if (((next_method_function)->is_mutating())){
(iterable_should_be_mutable = true);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(id));
const Optional<typechecker::FunctionId> next_method_function_id = TRY((((*this).find_function_in_scope(((struct_).scope_id),String("next")))));
if ((!((next_method_function_id).has_value()))){
TRY((((*this).error(String("Iterator must have a .next() method"),((range)->span())))));
}
else {
const NonnullRefPtr<typechecker::CheckedFunction> next_method_function = ((*this).get_function((next_method_function_id.value())));
if (((next_method_function)->is_mutating())){
(iterable_should_be_mutable = true);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Iterator must have a .next() method"),name_span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const NonnullRefPtr<parser::ParsedStatement> rewritten_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(String("_magic"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,JaktInternal::OptionalNone(),name_span),range,span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Loop>(parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(String("_magic_value"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,JaktInternal::OptionalNone(),name_span),TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic"),name_span))),parser::ParsedCall((TRY((Array<String>::create_with({})))),String("next"),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))))),false,name_span))),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic_value"),name_span))),parser::ParsedCall((TRY((Array<String>::create_with({})))),String("has_value"),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))))),false,name_span))),typename parser::UnaryOperator::LogicalNot(),name_span))),parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Break>(span)))}))))),JaktInternal::OptionalNone(),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(iterator_name,TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,name_span,name_span),TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::ForcedUnwrap>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic_value"),name_span))),name_span))),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,span)))}))))),span)))}))))),span)));
return (TRY((((*this).typecheck_statement(rewritten_statement,scope_id,safety_mode)))));
}
}

ErrorOr<String> typechecker::TypeId::to_string() const {
{
return (TRY((String::formatted(String("{}_{}"),((((*this).module)).id),((*this).id)))));
}
}

Optional<typechecker::TypeId> typechecker::TypeId::none() {
{
return (JaktInternal::OptionalNone());
}
}

bool typechecker::TypeId::equals(const typechecker::TypeId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

ErrorOr<typechecker::TypeId> typechecker::TypeId::from_string(const String type_id_string) {
{
const Array<String> parts = TRY((((type_id_string).split('_'))));
if ((!(((parts).size()) == static_cast<size_t>(2ULL)))){
utility::panic(TRY((String::formatted(String("Failed to convert string `{}` to a TypeId: Wrong number of parts. (Wanted 2, got {})"),type_id_string,((parts).size())))));
}
const Optional<u32> module_id = ((((parts)[static_cast<i64>(0LL)])).to_uint());
const Optional<u32> type_id = ((((parts)[static_cast<i64>(1LL)])).to_uint());
if (((!((module_id).has_value())) || (!((type_id).has_value())))){
utility::panic(TRY((String::formatted(String("Failed to convert string `{}` to a TypeId. (module_id = {} ({}), type_id = {} ({}))"),type_id_string,module_id,((parts)[static_cast<i64>(0LL)]),type_id,((parts)[static_cast<i64>(1LL)])))));
}
return (typechecker::TypeId(typechecker::ModuleId((infallible_integer_cast<size_t>(((module_id).value())))),(infallible_integer_cast<size_t>(((type_id).value())))));
}
}

bool typechecker::ModuleId::equals(const typechecker::ModuleId rhs) const {
{
return ((((*this).id) == ((rhs).id)));
}
}

u64 typechecker::Type::max() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u64, u64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(static_cast<u64>(127ULL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(static_cast<u64>(2147483647ULL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(static_cast<u64>(127ULL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(static_cast<u64>(32767ULL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(static_cast<u64>(2147483647ULL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(static_cast<u64>(9223372036854775807ULL));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<u64>(255ULL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<u64>(65535ULL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<u64>(4294967295ULL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<u64>(18446744073709551615ULL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<u64>(18446744073709551615ULL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<u64>(0ULL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::equals(const NonnullRefPtr<typechecker::Type> rhs) const {
{
if (((*this).has<typechecker::Type::Void>() && (rhs)->has<typechecker::Type::Void>())){
return (true);
}
else if (((*this).has<typechecker::Type::Bool>() && (rhs)->has<typechecker::Type::Bool>())){
return (true);
}
else if (((*this).has<typechecker::Type::U8>() && (rhs)->has<typechecker::Type::U8>())){
return (true);
}
else if (((*this).has<typechecker::Type::U16>() && (rhs)->has<typechecker::Type::U16>())){
return (true);
}
else if (((*this).has<typechecker::Type::U32>() && (rhs)->has<typechecker::Type::U32>())){
return (true);
}
else if (((*this).has<typechecker::Type::U64>() && (rhs)->has<typechecker::Type::U64>())){
return (true);
}
else if (((*this).has<typechecker::Type::I8>() && (rhs)->has<typechecker::Type::I8>())){
return (true);
}
else if (((*this).has<typechecker::Type::I16>() && (rhs)->has<typechecker::Type::I16>())){
return (true);
}
else if (((*this).has<typechecker::Type::I32>() && (rhs)->has<typechecker::Type::I32>())){
return (true);
}
else if (((*this).has<typechecker::Type::I64>() && (rhs)->has<typechecker::Type::I64>())){
return (true);
}
else if (((*this).has<typechecker::Type::F32>() && (rhs)->has<typechecker::Type::F32>())){
return (true);
}
else if (((*this).has<typechecker::Type::F64>() && (rhs)->has<typechecker::Type::F64>())){
return (true);
}
else if (((*this).has<typechecker::Type::Usize>() && (rhs)->has<typechecker::Type::Usize>())){
return (true);
}
else if (((*this).has<typechecker::Type::JaktString>() && (rhs)->has<typechecker::Type::JaktString>())){
return (true);
}
else if (((*this).has<typechecker::Type::CChar>() && (rhs)->has<typechecker::Type::CChar>())){
return (true);
}
else if (((*this).has<typechecker::Type::CInt>() && (rhs)->has<typechecker::Type::CInt>())){
return (true);
}
else {
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& lhs_name = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::TypeVariable>()){
const String rhs_name = (rhs->get<typechecker::Type::TypeVariable>()).value;
return ((lhs_name == rhs_name));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& lhs_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if ((rhs)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId rhs_id = (rhs->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (rhs->get<typechecker::Type::GenericInstance>()).args;
if ((((lhs_id).equals(rhs_id)) && (((lhs_args).size()) == ((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!((((lhs_args)[idx])).equals(((rhs_args)[idx]))))){
return (false);
}
(idx++);
}
return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& lhs_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if ((rhs)->has<typechecker::Type::GenericEnumInstance>()){
const typechecker::EnumId rhs_id = (rhs->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (rhs->get<typechecker::Type::GenericEnumInstance>()).args;
if ((((lhs_id).equals(rhs_id)) && (((lhs_args).size()) == ((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!((((lhs_args)[idx])).equals(((rhs_args)[idx]))))){
return (false);
}
(idx++);
}
return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& lhs_id = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::Struct>()){
const typechecker::StructId rhs_id = (rhs->get<typechecker::Type::Struct>()).value;
return (((lhs_id).equals(rhs_id)));
}
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& lhs_id = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::Enum>()){
const typechecker::EnumId rhs_id = (rhs->get<typechecker::Type::Enum>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::RawPtr>()){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::RawPtr>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::Reference>()){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::Reference>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if ((rhs)->has<typechecker::Type::MutableReference>()){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::MutableReference>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
{
if ((rhs)->has<typechecker::Type::Function>()){
const Array<typechecker::TypeId> rhs_params = (rhs->get<typechecker::Type::Function>()).params;
const bool rhs_can_throw = (rhs->get<typechecker::Type::Function>()).can_throw;
const typechecker::TypeId rhs_return_type_id = (rhs->get<typechecker::Type::Function>()).return_type_id;
if (((((params).size()) == ((rhs_params).size())) && (((return_type_id).equals(rhs_return_type_id)) && (can_throw == rhs_can_throw)))){
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((params).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
if ((!((((params)[i])).equals(((rhs_params)[i]))))){
return (false);
}
}

}
}

return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (false);
}

}
}

i64 typechecker::Type::get_bits() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<i64>(16LL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(static_cast<i64>(16LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::is_builtin() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

i64 typechecker::Type::min() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue((-static_cast<i64>(128LL)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue((-static_cast<i64>(2147483648LL)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue((-static_cast<i64>(128LL)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue((-static_cast<i64>(32768LL)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue((-static_cast<i64>(2147483648LL)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue((JaktInternal::checked_sub<i64>((-static_cast<i64>(9223372036854775807LL)),static_cast<i64>(1LL))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::is_signed() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

Optional<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::CheckedStatement::none() {
{
return (JaktInternal::OptionalNone());
}
}

Optional<utility::Span> typechecker::CheckedStatement::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<utility::Span>, Optional<utility::Span>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue((span));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<utility::Span> const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Try>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::always_transfers_control() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::partial() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(false));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(false));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::always_returns() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::updated(const typechecker::BlockControlFlow second) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(second);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::may_break() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::is_reachable() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(false);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(true);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::never_returns() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::may_return() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(true);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::unify_with(const typechecker::BlockControlFlow second) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(second);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns((lhs || might_break)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(lhs));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(lhs));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns((lhs || might_break)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(lhs));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::EnumId typechecker::CheckedEnumVariant::enum_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, typechecker::EnumId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String typechecker::CheckedEnumVariant::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::CheckedEnumVariant::equals(const typechecker::CheckedEnumVariant other) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& this_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = other;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& other_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((this_name == other_name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

utility::Span typechecker::CheckedEnumVariant::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::TypeId typechecker::FunctionGenericParameter::type_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::TypeId typechecker::CheckedTypeCast::type_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Fallible>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Infallible>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

size_t typechecker::NumberConstant::to_usize() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t, size_t>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(value)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>(value)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
{
utility::panic(String("to_usize on a floating point constant"));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::NumberConstant::can_fit_number(const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedProgram> program) const {
{
const NonnullRefPtr<typechecker::Type> type_ = ((program)->get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue((value >= static_cast<i64>(0LL)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue((value >= static_cast<i64>(0LL)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(((((program)->is_integer(type_id)) && (value >= ((type_)->min()))) && (value <= (infallible_integer_cast<i64>(((type_)->max()))))));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue((((program)->is_integer(type_id)) && (value <= ((type_)->max()))));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_130; {
utility::todo(String("Implement casting f32 to f64"));
__jakt_var_130 = false; goto __jakt_label_130;

}
__jakt_label_130:; __jakt_var_130.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String typechecker::CheckedCapture::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span typechecker::CheckedCapture::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

Optional<typechecker::NumberConstant> typechecker::CheckedExpression::to_number_constant(const NonnullRefPtr<typechecker::CheckedProgram> program) const {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
return (((val).number_constant()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
{
if ((!(cast).has<typechecker::CheckedTypeCast::Infallible>())){
return (JaktInternal::OptionalNone());
}
if (((!((program)->is_integer(type_id))) && (!((program)->is_floating(type_id))))){
return (JaktInternal::OptionalNone());
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
utility::Span const& span_ = __jakt_match_value.span;
typechecker::TypeId const& type_id_ = __jakt_match_value.type_id;
{
return (((val).number_constant()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (JaktInternal::OptionalNone());
}
}

Optional<typechecker::NumberConstant> typechecker::CheckedNumericConstant::number_constant() const {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>(value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Floating(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (JaktInternal::OptionalNone());
}
}

}
namespace codegen {
struct CodegenDebugInfo {
  public:
NonnullRefPtr<compiler::Compiler> compiler;Dictionary<size_t,Array<codegen::LineSpan>> line_spans;bool statement_span_comments;ErrorOr<void> gather_line_spans();
ErrorOr<String> span_to_source_location(const utility::Span span);
CodegenDebugInfo(NonnullRefPtr<compiler::Compiler> a_compiler, Dictionary<size_t,Array<codegen::LineSpan>> a_line_spans, bool a_statement_span_comments) :compiler(a_compiler), line_spans(a_line_spans), statement_span_comments(a_statement_span_comments){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CodegenDebugInfo("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("line_spans: "));TRY(builder.appendff("{}, ", line_spans));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statement_span_comments: "));TRY(builder.appendff("{}", statement_span_comments));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace AllowedControlExits_Details {
struct Nothing {};
struct JustReturn {};
struct AtLoop {};
}
struct AllowedControlExits : public Variant<AllowedControlExits_Details::Nothing, AllowedControlExits_Details::JustReturn, AllowedControlExits_Details::AtLoop> {
using Variant<AllowedControlExits_Details::Nothing, AllowedControlExits_Details::JustReturn, AllowedControlExits_Details::AtLoop>::Variant;
    using Nothing = AllowedControlExits_Details::Nothing;
    using JustReturn = AllowedControlExits_Details::JustReturn;
    using AtLoop = AllowedControlExits_Details::AtLoop;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Nothing const& that) -> ErrorOr<void> {
TRY(builder.append("AllowedControlExits::Nothing"));return {}; },[&]([[maybe_unused]] JustReturn const& that) -> ErrorOr<void> {
TRY(builder.append("AllowedControlExits::JustReturn"));return {}; },[&]([[maybe_unused]] AtLoop const& that) -> ErrorOr<void> {
TRY(builder.append("AllowedControlExits::AtLoop"));return {}; }));return builder.to_string();}codegen::AllowedControlExits allow_return() const;
};
struct ControlFlowState {
  public:
codegen::AllowedControlExits allowed_exits;bool passes_through_match;bool passes_through_try;size_t match_nest_level;codegen::ControlFlowState enter_function() const;
codegen::ControlFlowState enter_loop() const;
static codegen::ControlFlowState no_control_flow();
bool is_match_nested() const;
String choose_control_flow_macro() const;
codegen::ControlFlowState enter_match() const;
ControlFlowState(codegen::AllowedControlExits a_allowed_exits, bool a_passes_through_match, bool a_passes_through_try, size_t a_match_nest_level) :allowed_exits(a_allowed_exits), passes_through_match(a_passes_through_match), passes_through_try(a_passes_through_try), match_nest_level(a_match_nest_level){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ControlFlowState("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("allowed_exits: "));TRY(builder.appendff("{}, ", allowed_exits));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("passes_through_match: "));TRY(builder.appendff("{}, ", passes_through_match));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("passes_through_try: "));TRY(builder.appendff("{}, ", passes_through_try));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("match_nest_level: "));TRY(builder.appendff("{}", match_nest_level));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CodeGenerator {
  public:
NonnullRefPtr<compiler::Compiler> compiler;NonnullRefPtr<typechecker::CheckedProgram> program;codegen::ControlFlowState control_flow_state;Array<Tuple<String,String>> entered_yieldable_blocks;String deferred_output;Optional<NonnullRefPtr<typechecker::CheckedFunction>> current_function;codegen::CodegenDebugInfo debug_info;Array<String> namespace_stack;size_t fresh_var_counter;size_t fresh_label_counter;ErrorOr<String> codegen_function(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_generic_type_instance(const typechecker::StructId id, const Array<typechecker::TypeId> args, const bool as_namespace) const;
ErrorOr<Array<typechecker::ModuleId>> topologically_sort_modules() const;
ErrorOr<String> codegen_debug_description_getter(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_namespace(const NonnullRefPtr<typechecker::Scope> scope, const NonnullRefPtr<typechecker::Module> current_module);
ErrorOr<Dictionary<String,Array<String>>> produce_codegen_dependency_graph(const NonnullRefPtr<typechecker::Scope> scope) const;
ErrorOr<String> codegen_struct_predecl(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement);
ErrorOr<String> codegen_enum(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_struct_type(const typechecker::StructId id, const bool as_namespace) const;
ErrorOr<String> codegen_generic_match(const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> cases, const typechecker::TypeId return_type_id, const bool all_variants_constant);
ErrorOr<String> codegen_checked_binary_op(const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op, const typechecker::TypeId type_id);
ErrorOr<Array<String>> extract_dependencies_from_enum(const typechecker::EnumId enum_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level) const;
ErrorOr<String> codegen_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression);
ErrorOr<Array<String>> extract_dependencies_from_struct(const typechecker::StructId struct_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level, const Array<typechecker::TypeId> args) const;
ErrorOr<String> codegen_function_in_namespace(const NonnullRefPtr<typechecker::CheckedFunction> function_, const Optional<typechecker::TypeId> containing_struct);
ErrorOr<String> codegen_method_call(const NonnullRefPtr<typechecker::CheckedExpression> expr, const typechecker::CheckedCall call, const bool is_optional);
CodeGenerator(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<typechecker::CheckedProgram> a_program, codegen::ControlFlowState a_control_flow_state, Array<Tuple<String,String>> a_entered_yieldable_blocks, String a_deferred_output, Optional<NonnullRefPtr<typechecker::CheckedFunction>> a_current_function, codegen::CodegenDebugInfo a_debug_info, Array<String> a_namespace_stack, size_t a_fresh_var_counter, size_t a_fresh_label_counter) :compiler(a_compiler), program(a_program), control_flow_state(a_control_flow_state), entered_yieldable_blocks(a_entered_yieldable_blocks), deferred_output(a_deferred_output), current_function(a_current_function), debug_info(a_debug_info), namespace_stack(a_namespace_stack), fresh_var_counter(a_fresh_var_counter), fresh_label_counter(a_fresh_label_counter){}

ErrorOr<String> codegen_struct(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_enum_predecl(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_binary_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression, const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op);
ErrorOr<String> codegen_namespace_predecl(const NonnullRefPtr<typechecker::Scope> scope, const NonnullRefPtr<typechecker::Module> current_module);
ErrorOr<String> current_error_handler() const;
ErrorOr<String> codegen_namespace_qualifier(const typechecker::ScopeId scope_id) const;
ErrorOr<String> codegen_namespace_path(const typechecker::CheckedCall call) const;
ErrorOr<String> codegen_type_possibly_as_namespace(const typechecker::TypeId type_id, const bool as_namespace) const;
ErrorOr<Array<String>> extract_dependencies_from(const typechecker::TypeId type_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level) const;
ErrorOr<String> codegen_match_body(const typechecker::CheckedMatchBody body, const typechecker::TypeId return_type_id);
ErrorOr<String> codegen_function_predecl(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> fresh_var();
ErrorOr<String> codegen_block(const typechecker::CheckedBlock block);
ErrorOr<String> codegen_checked_binary_op_assignment(const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op, const typechecker::TypeId type_id);
ErrorOr<String> codegen_enum_type(const typechecker::EnumId id, const bool as_namespace) const;
ErrorOr<String> codegen_constructor(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_enum_debug_description_getter(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_enum_match(const typechecker::CheckedEnum enum_, const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> match_cases, const typechecker::TypeId type_id, const bool all_variants_constant);
ErrorOr<String> codegen_match(const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> match_cases, const typechecker::TypeId type_id, const bool all_variants_constant);
ErrorOr<String> codegen_function_return_type(const NonnullRefPtr<typechecker::CheckedFunction> function_);
static ErrorOr<String> generate(const NonnullRefPtr<compiler::Compiler> compiler, const NonnullRefPtr<typechecker::CheckedProgram> program, const bool debug_info);
ErrorOr<String> codegen_call(const typechecker::CheckedCall call);
ErrorOr<String> codegen_generic_enum_instance(const typechecker::EnumId id, const Array<typechecker::TypeId> args, const bool as_namespace) const;
ErrorOr<String> codegen_function_generic_parameters(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_ak_formatter(const String name, const Array<String> generic_parameter_names);
ErrorOr<String> codegen_type(const typechecker::TypeId type_id) const;
ErrorOr<void> postorder_traversal(const String encoded_type_id, Set<String> visited, const Dictionary<String,Array<String>> encoded_dependency_graph, Array<typechecker::TypeId> output) const;
ErrorOr<String> fresh_label();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CodeGenerator("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("program: "));TRY(builder.appendff("{}, ", *program));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("control_flow_state: "));TRY(builder.appendff("{}, ", control_flow_state));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("entered_yieldable_blocks: "));TRY(builder.appendff("{}, ", entered_yieldable_blocks));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("deferred_output: "));TRY(builder.appendff("\"{}\", ", deferred_output));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_function: "));TRY(builder.appendff("{}, ", current_function));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_info: "));TRY(builder.appendff("{}, ", debug_info));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_stack: "));TRY(builder.appendff("{}, ", namespace_stack));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fresh_var_counter: "));TRY(builder.appendff("{}, ", fresh_var_counter));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fresh_label_counter: "));TRY(builder.appendff("{}", fresh_label_counter));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct LineSpan {
  public:
size_t start;size_t end;LineSpan(size_t a_start, size_t a_end) :start(a_start), end(a_end){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("LineSpan("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("start: "));TRY(builder.appendff("{}, ", start));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("end: "));TRY(builder.appendff("{}", end));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static bool are_loop_exits_allowed(const codegen::AllowedControlExits allowed_control_exits) {
{
return ((allowed_control_exits).has<codegen::AllowedControlExits::AtLoop>());
}
}

static bool is_return_allowed(const codegen::AllowedControlExits allowed_control_exits) {
{
return ((!(allowed_control_exits).has<codegen::AllowedControlExits::Nothing>()));
}
}

ErrorOr<void> codegen::CodegenDebugInfo::gather_line_spans() {
{
{
DictionaryIterator<String,utility::FileId> _magic = ((((((*this).compiler))->file_ids)).iterator());
for (;;){
Optional<Tuple<String,utility::FileId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,utility::FileId> file = (_magic_value.value());
{
if ((((file).get<0>()) == String("__prelude__"))){
continue;
}
((((*this).compiler))->set_current_file(((file).get<1>())));
const size_t file_idx = ((((file).get<1>())).id);
const Array<codegen::LineSpan> empty_array = (TRY((Array<codegen::LineSpan>::create_with({}))));
TRY((((((*this).line_spans)).set(file_idx,empty_array))));
size_t idx = static_cast<size_t>(0ULL);
size_t start = idx;
while ((idx < ((((((*this).compiler))->current_file_contents)).size()))){
if ((((((((*this).compiler))->current_file_contents))[idx]) == '\n')){
TRY((((((((*this).line_spans))[file_idx])).push(codegen::LineSpan(start,idx)))));
(start = (JaktInternal::checked_add<size_t>(idx,static_cast<size_t>(1ULL))));
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
if ((start < idx)){
TRY((((((((*this).line_spans))[file_idx])).push(codegen::LineSpan(start,idx)))));
}
}

}
}

}
return {};
}

ErrorOr<String> codegen::CodegenDebugInfo::span_to_source_location(const utility::Span span) {
{
if (((((*this).line_spans)).is_empty())){
TRY((((*this).gather_line_spans())));
}
const size_t file_idx = ((((span).file_id)).id);
if ((!((((*this).line_spans)).contains(file_idx)))){
return (String(""));
}
size_t line_index = static_cast<size_t>(0ULL);
while ((line_index < ((((((*this).line_spans))[file_idx])).size()))){
if (((((span).start) >= ((((((((*this).line_spans))[file_idx]))[line_index])).start)) && (((span).start) <= ((((((((*this).line_spans))[file_idx]))[line_index])).end)))){
const size_t column_index = (JaktInternal::checked_sub<size_t>(((span).start),((((((((*this).line_spans))[file_idx]))[line_index])).start)));
return (TRY((String::formatted(String("{}:{}:{}"),(((TRY((((((*this).compiler))->get_file_path(((span).file_id))))).value()))->path),(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),(JaktInternal::checked_add<size_t>(column_index,static_cast<size_t>(1ULL)))))));
}
({auto& _jakt_ref = line_index;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
utility::panic(String("Reached end of file and could not find index"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
return (TRY((((*this).codegen_function_in_namespace(function_,JaktInternal::OptionalNone())))));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_type_instance(const typechecker::StructId id,const Array<typechecker::TypeId> args,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
if ((!(((type_module)->is_root) || (((((type_module)->id)).id) == static_cast<size_t>(0ULL))))){
(output += ((type_module)->name));
(output += String("::"));
}
const Optional<typechecker::StructId> inner_weak_ptr_struct_id = TRY((((((*this).program))->check_and_extract_weak_ptr(id,args))));
if (((inner_weak_ptr_struct_id).has_value())){
(output += String("WeakPtr<"));
const typechecker::StructId inner_struct_id = ((inner_weak_ptr_struct_id).value());
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(inner_struct_id));
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String(">"));
}
else {
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
const bool acquired_by_ref = ((!as_namespace) && (((struct_).record_type)).has<parser::RecordType::Class>());
if (acquired_by_ref){
(output += String("NonnullRefPtr<"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
if ((!first)){
(output += String(","));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">"));
if (acquired_by_ref){
(output += String(">"));
}
}

return (output);
}
}

ErrorOr<Array<typechecker::ModuleId>> codegen::CodeGenerator::topologically_sort_modules() const {
{
Dictionary<size_t,i64> in_degrees = (TRY((Dictionary<size_t, i64>::create_with_entries({}))));
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
ArrayIterator<typechecker::ModuleId> _magic = ((((module)->imports)).iterator());
for (;;){
Optional<typechecker::ModuleId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ModuleId imported_module = (_magic_value.value());
{
const i64 existing = ((in_degrees).get(((imported_module).id))).value_or_lazy_evaluated([&] { return static_cast<i64>(0LL); });
TRY((((in_degrees).set(((imported_module).id),(JaktInternal::checked_add<i64>(existing,static_cast<i64>(1LL)))))));
}

}
}

if ((!((in_degrees).contains(((((module)->id)).id))))){
TRY((((in_degrees).set(((((module)->id)).id),static_cast<i64>(0LL)))));
}
}

}
}

Array<typechecker::ModuleId> stack = (TRY((Array<typechecker::ModuleId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
if ((((in_degrees)[((((module)->id)).id)]) == static_cast<i64>(0LL))){
TRY((((stack).push(((module)->id)))));
}
}

}
}

Array<typechecker::ModuleId> sorted_modules = (TRY((Array<typechecker::ModuleId>::create_with({}))));
while ((!((stack).is_empty()))){
const typechecker::ModuleId id = (((stack).pop()).value());
TRY((((sorted_modules).push(id))));
{
ArrayIterator<typechecker::ModuleId> _magic = ((((((((((*this).program))->modules))[((id).id)]))->imports)).iterator());
for (;;){
Optional<typechecker::ModuleId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ModuleId imported_module = (_magic_value.value());
{
const i64 module_in_degrees = ((in_degrees)[((imported_module).id)]);
TRY((((in_degrees).set(((imported_module).id),(JaktInternal::checked_sub<i64>(module_in_degrees,static_cast<i64>(1LL)))))));
if ((module_in_degrees == static_cast<i64>(1LL))){
TRY((((stack).push(typechecker::ModuleId(((imported_module).id))))));
}
}

}
}

}
if ((((sorted_modules).size()) == ((((((*this).program))->modules)).size()))){
return (sorted_modules);
}
utility::panic(String("Cyclic module imports"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_debug_description_getter(const typechecker::CheckedStruct struct_) {
{
String output = String("ErrorOr<String> debug_description() const { ");
(output += String("auto builder = MUST(StringBuilder::create());"));
(output += TRY((String::formatted(String("TRY(builder.append(\"{}(\"));"),((struct_).name)))));
(output += String("JaktInternal::_pretty_print_level++;\n"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((((*this).program))->get_variable(field));
(output += String("TRY(JaktInternal::_output_pretty_indent(builder));"));
(output += TRY((String::formatted(String("TRY(builder.append(\"{}: \"));"),((field_var).name)))));
(output += String("TRY(builder.appendff(\""));
if (((((*this).program))->is_string(((field_var).type_id)))){
(output += String("\\\"{}\\\""));
}
else {
(output += String("{}"));
}

if ((i != (JaktInternal::checked_sub<size_t>(((((struct_).fields)).size()),static_cast<size_t>(1ULL))))){
(output += String(", "));
}
(output += String("\", "));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(((field_var).type_id)));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((((((*this).program))->get_struct(struct_id))).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("*"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += (((field_var).name) + String("));\n")));
(i++);
}

}
}

(output += String("JaktInternal::_pretty_print_level--;\n"));
(output += String("TRY(builder.append(\")\"));"));
(output += String("return builder.to_string();"));
(output += String(" }"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace(const NonnullRefPtr<typechecker::Scope> scope,const NonnullRefPtr<typechecker::Module> current_module) {
{
if (((((scope)->import_path_if_extern)).has_value())){
return (String(""));
}
String output = String("");
const Dictionary<String,Array<String>> encoded_dependency_graph = TRY((((*this).produce_codegen_dependency_graph(scope))));
Set<String> seen_types = (TRY((Set<String>::create_with_values({}))));
{
DictionaryIterator<String,Array<String>> _magic = ((encoded_dependency_graph).iterator());
for (;;){
Optional<Tuple<String,Array<String>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,Array<String>> entry = (_magic_value.value());
{
const Array<typechecker::TypeId> traversal = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((*this).postorder_traversal(((entry).get<0>()),seen_types,encoded_dependency_graph,traversal))));
{
ArrayIterator<typechecker::TypeId> _magic = ((traversal).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
if ((!((((enum_id).module)).equals(((current_module)->id))))){
return JaktInternal::LoopContinue{};
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
const String enum_output = TRY((((*this).codegen_enum(enum_))));
if ((!((enum_output).is_empty()))){
(output += enum_output);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
if ((!((((struct_id).module)).equals(((current_module)->id))))){
return JaktInternal::LoopContinue{};
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
const String struct_output = TRY((((*this).codegen_struct(struct_))));
if ((!((struct_output).is_empty()))){
(output += struct_output);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Unexpected type in dependency graph: {}"),type_))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
TRY((((seen_types).add(TRY((((type_id).to_string())))))));
}

}
}

}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!((((struct_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if (((seen_types).contains(TRY((((((struct_).type_id)).to_string())))))){
continue;
}
(output += TRY((((*this).codegen_struct(struct_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!((((enum_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if (((seen_types).contains(TRY((((((enum_).type_id)).to_string())))))){
continue;
}
(output += TRY((((*this).codegen_enum(enum_)))));
(output += String("\n"));
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_scope_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((((*this).program))->get_scope(child_scope_id))));
if (((((child_scope)->namespace_name)).has_value())){
const String name = (((child_scope)->namespace_name).value());
TRY((((((*this).namespace_stack)).push(name))));
(output += String("namespace "));
(output += name);
(output += String(" {\n"));
(output += TRY((((*this).codegen_namespace(child_scope,current_module)))));
(output += String("}\n"));
const Optional<String> dummy = ((((*this).namespace_stack)).pop());
}
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
if ((!((((function_id).module)).equals(((current_module)->id))))){
continue;
}
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if ((((((function_)->linkage)).has<parser::FunctionLinkage::External>() || (((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()) || (((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>())){
continue;
}
(output += TRY((((*this).codegen_function(function_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!((((struct_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if ((((struct_).definition_linkage)).has<parser::DefinitionLinkage::External>()){
continue;
}
if ((!((((struct_).generic_parameters)).is_empty()))){
continue;
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((struct_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if (((!(((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()) && (!(((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>()))){
(output += TRY((((*this).codegen_function_in_namespace(function_,((struct_).type_id))))));
(output += String("\n"));
}
}

}
}

}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!((((enum_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if ((((enum_).definition_linkage)).has<parser::DefinitionLinkage::External>()){
continue;
}
if ((!((((enum_).generic_parameters)).is_empty()))){
continue;
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((enum_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if (((!(((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()) && (!(((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>()))){
(output += TRY((((*this).codegen_function_in_namespace(function_,((enum_).type_id))))));
(output += String("\n"));
}
}

}
}

}

}
}

return (output);
}
}

ErrorOr<Dictionary<String,Array<String>>> codegen::CodeGenerator::produce_codegen_dependency_graph(const NonnullRefPtr<typechecker::Scope> scope) const {
{
Dictionary<String,Array<String>> dependency_graph = (TRY((Dictionary<String, Array<String>>::create_with_entries({}))));
{
DictionaryIterator<String,typechecker::TypeId> _magic = ((((scope)->types)).iterator());
for (;;){
Optional<Tuple<String,typechecker::TypeId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::TypeId> type_ = (_magic_value.value());
{
TRY((((dependency_graph).set(TRY((((((type_).get<1>())).to_string()))),TRY((((*this).extract_dependencies_from(((type_).get<1>()),dependency_graph,true))))))));
}

}
}

return (dependency_graph);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct_predecl(const typechecker::CheckedStruct struct_) {
{
if ((((struct_).definition_linkage)).has<parser::DefinitionLinkage::External>()){
return (String(""));
}
String output = String("");
if ((!((((struct_).generic_parameters)).is_empty()))){
(output += String("template <"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += String("typename "));
(output += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

(output += String(">"));
}
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += ((struct_).name));
(output += String(";"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement) {
{
bool add_newline = true;
String output = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((String("return ") + TRY((((*this).codegen_expression(expr))))) + String(";")));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((*this).control_flow_state)).passes_through_match));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return JaktInternal::LoopContinue{};"));
}
else {
return JaktInternal::ExplicitValue(String("continue;"));
}
}()))
);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((*this).control_flow_state)).passes_through_match));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return JaktInternal::LoopBreak{};"));
}
else {
return JaktInternal::ExplicitValue(String("break;"));
}
}()))
);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_expression(expr)))) + String(";")));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();NonnullRefPtr<typechecker::CheckedStatement> const& statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_131; {
String output = String("");
(output += String("\n#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__\n"));
(output += String("ScopeGuard __SCOPE_GUARD_NAME ([&] \n"));
(output += String("#undef __SCOPE_GUARD_NAME\n{"));
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((((*this).control_flow_state)).passes_through_match) = false);
(output += TRY((((*this).codegen_statement(statement)))));
(output += String("});"));
(((*this).control_flow_state) = last_control_flow);
}

__jakt_var_131 = output; goto __jakt_label_131;

}
__jakt_label_131:; __jakt_var_131.release_value(); }));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((String("return (") + TRY((((*this).codegen_expression((val.value())))))) + String(");")));
}
else {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_132; {
__jakt_var_132 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = ((((((*this).current_function).value()))->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return {};"));
}
else {
return JaktInternal::ExplicitValue(String("return;"));
}
}()))
; goto __jakt_label_132;

}
__jakt_label_132:; __jakt_var_132.release_value(); }));
}
}()))
);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_133; {
String output = String("");
(output += String("for (;;)"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
(add_newline = false);
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_loop()));
const String block_str = TRY((((*this).codegen_block(block))));
(((*this).control_flow_state) = last_control_flow);
(output += block_str);
__jakt_var_133 = output; goto __jakt_label_133;

}
__jakt_label_133:; __jakt_var_133.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_134; {
String output = String("");
(output += String("while ("));
(output += TRY((((*this).codegen_expression(condition)))));
(output += String(")"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_loop()));
const String code = TRY((((*this).codegen_block(block))));
(((*this).control_flow_state) = last_control_flow);
(output += code);
}

(add_newline = false);
__jakt_var_134 = output; goto __jakt_label_134;

}
__jakt_label_134:; __jakt_var_134.release_value(); }));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_block(block)))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
{
utility::panic(String("Garbage statement in codegen"));
}
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();Array<NonnullRefPtr<typechecker::CheckedStatement>> const& vars = __jakt_match_value.vars;
NonnullRefPtr<typechecker::CheckedStatement> const& var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_135; {
String output = String("");
(output += TRY((((*this).codegen_statement(var_decl)))));
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((vars).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> v = (_magic_value.value());
{
(output += TRY((((*this).codegen_statement(v)))));
}

}
}

__jakt_var_135 = output; goto __jakt_label_135;

}
__jakt_label_135:; __jakt_var_135.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();typechecker::VarId const& var_id = __jakt_match_value.var_id;
NonnullRefPtr<typechecker::CheckedExpression> const& init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_136; {
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(var_id));
String output = String("");
const NonnullRefPtr<typechecker::Type> var_type = ((((*this).program))->get_type(((var).type_id)));
if (((!((var).is_mutable)) && (!((var_type)->has<typechecker::Type::Reference>() || (var_type)->has<typechecker::Type::MutableReference>())))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((var).type_id))))));
(output += String(" "));
(output += ((var).name));
(output += String(" = "));
(output += TRY((((*this).codegen_expression(init)))));
(output += String(";"));
__jakt_var_136 = output; goto __jakt_label_136;

}
__jakt_label_136:; __jakt_var_136.release_value(); }));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();Array<String> const& lines = __jakt_match_value.lines;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_137; {
String output = String("");
{
ArrayIterator<String> _magic = ((lines).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String line = (_magic_value.value());
{
String escaped_line = line;
(escaped_line = TRY((((escaped_line).replace(String("\\\""),String("\""))))));
(escaped_line = TRY((((escaped_line).replace(String("\\\\"),String("\\"))))));
(output += escaped_line);
}

}
}

__jakt_var_137 = output; goto __jakt_label_137;

}
__jakt_label_137:; __jakt_var_137.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_138; {
String output = String("if (");
(output += TRY((((*this).codegen_expression(condition)))));
(output += String(")"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
(output += TRY((((*this).codegen_block(then_block)))));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((String("else ") + TRY((((*this).codegen_statement((else_statement.value())))))));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
);
(add_newline = false);
__jakt_var_138 = output; goto __jakt_label_138;

}
__jakt_label_138:; __jakt_var_138.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_139; {
String output = String("");
if ((((((*this).entered_yieldable_blocks)).size()) == static_cast<size_t>(0ULL))){
utility::panic(String("Must be in a block to yield"));
}
const Tuple<String,String> block_tuple = (((((*this).entered_yieldable_blocks)).last()).value());
const String block_var_name = ((block_tuple).get<0>());
const String block_end_label = ((block_tuple).get<1>());
(output += block_var_name);
(output += String(" = "));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String("; goto "));
(output += block_end_label);
(output += String(";\n"));
__jakt_var_139 = output; goto __jakt_label_139;

}
__jakt_label_139:; __jakt_var_139.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Try>();NonnullRefPtr<typechecker::CheckedStatement> const& stmt = __jakt_match_value.stmt;
String const& error_name = __jakt_match_value.error_name;
typechecker::CheckedBlock const& catch_block = __jakt_match_value.catch_block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_140; {
String output = String("{");
(output += String("auto _jakt_try_result = [&]() -> ErrorOr<void> {"));
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((((*this).control_flow_state)).passes_through_match) = false);
(((((*this).control_flow_state)).passes_through_try) = true);
(output += TRY((((*this).codegen_statement(stmt)))));
(output += String(";"));
(output += String("return {};"));
(output += String("}();"));
(output += String("if (_jakt_try_result.is_error()) {"));
if ((!((error_name).is_empty()))){
(output += String("auto "));
(output += error_name);
(output += String(" = _jakt_try_result.release_error();"));
}
(output += TRY((((*this).codegen_block(catch_block)))));
(((*this).control_flow_state) = last_control_flow);
}

(output += String("}}"));
__jakt_var_140 = output; goto __jakt_label_140;

}
__jakt_label_140:; __jakt_var_140.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((((*this).debug_info)).statement_span_comments) && (((((statement)->span())).has_value()) && add_newline))){
(output += TRY((String::formatted(String(" /* {} */"),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
if (add_newline){
(output += String("\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum(const typechecker::CheckedEnum enum_) {
{
String output = String("");
if ((!((((enum_).underlying_type_id)).equals(typechecker::void_type_id())))){
if (((((*this).program))->is_integer(((enum_).underlying_type_id)))){
(output += ((((String("enum class ") + ((enum_).name)) + String(": ")) + TRY((((*this).codegen_type(((enum_).underlying_type_id)))))) + String(" {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((((name + String(" = ")) + TRY((((*this).codegen_expression(expr))))) + String(",\n")));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_141; {
utility::todo(TRY((String::formatted(String("codegen_enum can't generate variant: {}"),variant))));
__jakt_var_141 = String(""); goto __jakt_label_141;

}
__jakt_label_141:; __jakt_var_141.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}

}
}

return ((output + String("};\n")));
}
else {
utility::todo(String("Enums with a non-integer underlying type"));
}

}
const bool is_generic = (!((((enum_).generic_parameters)).is_empty()));
Array<String> generic_parameter_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((((((*this).program))->get_type(generic_parameter)))->has<typechecker::Type::TypeVariable>()){
const String name = (((((*this).program))->get_type(generic_parameter))->get<typechecker::Type::TypeVariable>()).value;
TRY((((generic_parameter_names).push(name))));
}
}

}
}

String template_args = utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "));
(output += ((String("namespace ") + ((enum_).name)) + String("_Details {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String(" {};\n")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String(" {\n")));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(field));
(output += TRY((String::formatted(String("{} {};\n"),TRY((((*this).codegen_type(((var).type_id))))),((var).name)))));
}

}
}

(output += String("template<"));
Array<String> generic_typenames = (TRY((Array<String>::create_with({}))));
Array<String> generic_argument_types = (TRY((Array<String>::create_with({}))));
Array<String> initializers = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((fields).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((generic_typenames).push(TRY((String::formatted(String("typename _MemberT{}"),i)))))));
TRY((((generic_argument_types).push(TRY((String::formatted(String("_MemberT{}&& member_{}"),i,i)))))));
String initializer = (((((((*this).program))->get_variable(((fields)[i])))).name) + String("{ forward<_MemberT"));
(initializer += (TRY((String::formatted(String("{}>(member_{}"),i,i))) + String(")}")));
TRY((((initializers).push(initializer))));
}

}
}

(output += utility::join(generic_typenames,String(", ")));
(output += String(">\n"));
(output += (((name + String("(")) + utility::join(generic_argument_types,String(", "))) + String("):\n")));
(output += (utility::join(initializers,String(",\n")) + String("\n{}\n")));
(output += String("};\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String("{\n")));
(output += (TRY((((*this).codegen_type(type_id)))) + String(" value;\n")));
(output += String("template<typename... Args>\n"));
(output += (name + String("(Args&&... args): value { forward<Args>(args)... } {}\n")));
(output += String("};\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("codegen enum variant: {}"),variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

(output += String("}\n"));
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
Array<String> variant_names = (TRY((Array<String>::create_with({}))));
Array<String> variant_arguments_array = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
String argument = ((((enum_).name) + String("_Details::")) + ((variant).name()));
if (is_generic){
(argument += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
TRY((((variant_arguments_array).push(argument))));
TRY((((variant_names).push(((variant).name())))));
}

}
}

const String variant_args = utility::join(variant_arguments_array,String(", "));
(output += TRY((String::formatted(String("struct {} : public Variant<{}>"),((enum_).name),variant_args))));
if (((enum_).is_boxed)){
(output += TRY((String::formatted(String(", public RefCounted<{}"),((enum_).name)))));
if (is_generic){
(output += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
(output += String(">"));
}
(output += String(" {\n"));
(output += ((String("using Variant<") + variant_args) + String(">::Variant;\n")));
{
ArrayIterator<String> _magic = ((variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
(output += (((((String("    using ") + name) + String(" = ")) + ((enum_).name)) + String("_Details::")) + name));
if (is_generic){
(output += String("<"));
(output += utility::join(generic_parameter_names,String(", ")));
(output += String(">"));
}
(output += String(";\n"));
}

}
}

if (((enum_).is_boxed)){
String fully_instantiated_name = ((enum_).name);
if (is_generic){
(fully_instantiated_name += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
(output += String("template<typename V, typename... Args> static auto create(Args&&... args) {\n"));
(output += TRY((String::formatted(String("return adopt_nonnull_ref_or_enomem(new (nothrow) {}(V(forward<Args>(args)...)));\n"),fully_instantiated_name))));
(output += String("}\n"));
}
(output += TRY((((*this).codegen_enum_debug_description_getter(enum_)))));
const NonnullRefPtr<typechecker::Scope> enum_scope = TRY((((((*this).program))->get_scope(((enum_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((enum_scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> function_item = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(((function_item).get<1>())));
if ((!(((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>())){
if (((((enum_).generic_parameters)).is_empty())){
(output += TRY((((*this).codegen_function_predecl(function_)))));
}
else {
(output += TRY((((*this).codegen_function(function_)))));
}

}
}

}
}

(output += String("};\n"));
(((*this).deferred_output) += TRY((((*this).codegen_ak_formatter(((enum_).name),generic_parameter_names)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct_type(const typechecker::StructId id,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
const typechecker::CheckedStruct checked_struct = ((((*this).program))->get_struct(id));
if (((!as_namespace) && (((checked_struct).record_type)).has<parser::RecordType::Class>())){
(output += String("NonnullRefPtr<"));
if (((!((type_module)->is_root)) && (!((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((checked_struct).scope_id))))));
(output += ((checked_struct).name));
(output += String(">"));
}
else {
if ((!((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))) || (((checked_struct).definition_linkage)).has<parser::DefinitionLinkage::External>()))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((checked_struct).scope_id))))));
(output += ((checked_struct).name));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_match(const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> cases,const typechecker::TypeId return_type_id,const bool all_variants_constant) {
{
String output = String("");
bool is_generic_enum = false;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
if ((case_).has<typechecker::CheckedMatchCase::EnumVariant>()){
(is_generic_enum = true);
break;
}
}

}
}

const bool match_values_all_constant = (all_variants_constant && (!is_generic_enum));
(output += ((((*this).control_flow_state)).choose_control_flow_macro()));
(output += (TRY((String::formatted(String("(([&]() -> JaktInternal::ExplicitValueOrControlFlow<{},{}>"),TRY((((*this).codegen_type(return_type_id)))),TRY((((*this).codegen_function_return_type((((*this).current_function).value())))))))) + String("{\n")));
if (is_generic_enum){
(output += String("auto&& __jakt_enum_value = JaktInternal::deref_if_ref_pointer("));
}
else {
(output += String("auto __jakt_enum_value = ("));
}

(output += TRY((((*this).codegen_expression(expr)))));
(output += String(");\n"));
bool has_default = false;
bool first = true;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = case_;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
(output += String("if (__jakt_enum_value.template has<"));
String variant_type_name = String("");
const String qualifier = TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true))));
if ((!((qualifier).is_empty()))){
(variant_type_name += String("typename JaktInternal::RemoveRefPtr<"));
(variant_type_name += qualifier);
(variant_type_name += String(">::"));
}
(variant_type_name += name);
(output += variant_type_name);
(output += String(">()) {\n"));
(output += String("auto& __jakt_match_value = __jakt_enum_value.template get<"));
(output += variant_type_name);
(output += String(">();\n"));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((args).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
(output += String("auto& "));
(output += ((arg).binding));
(output += String(" = __jakt_match_value."));
(output += ((arg).name).value_or_lazy_evaluated([&] { return String("value"); }));
(output += String(";\n"));
}

}
}

(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
{
(has_default = true);
if (first){
(output += String("{"));
}
else {
(output += String("else {\n"));
}

(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expression = __jakt_match_value.expression;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
{
if ((!first)){
(output += String("else "));
}
(output += String("if (__jakt_enum_value == "));
(output += TRY((((*this).codegen_expression(expression)))));
(output += String(") {\n"));
(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(first = false);
}

}
}

if ((((return_type_id).equals(typechecker::void_type_id())) || ((return_type_id).equals(typechecker::unknown_type_id())))){
(output += String("return JaktInternal::ExplicitValue<void>();\n"));
}
else if ((!has_default)){
(output += String("VERIFY_NOT_REACHED();\n"));
}
(output += String("}()))\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_checked_binary_op(const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op,const typechecker::TypeId type_id) {
{
String output = String("");
(output += String("JaktInternal::"));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(String("checked_add"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(String("checked_sub"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(String("checked_mul"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(String("checked_div"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(String("checked_mod"));
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Checked binary operation codegen is not supported for BinaryOperator::{}"),op))));
}
};/*case end*/
}/*switch end*/
}()
)));
(output += String("<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(","));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from_enum(const typechecker::EnumId enum_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if ((((enum_).definition_linkage)).has<parser::DefinitionLinkage::External>()){
return (dependencies);
}
if ((((enum_).is_boxed) && (!top_level))){
return (dependencies);
}
TRY((((dependencies).push(TRY((((((enum_).type_id)).to_string())))))));
if ((!((((enum_).underlying_type_id)).equals(typechecker::unknown_type_id())))){
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(((enum_).underlying_type_id),dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::TypeId type_id = ((((((*this).program))->get_variable(field))).type_id);
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *expression;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();NonnullRefPtr<typechecker::CheckedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<typechecker::CheckedExpression> const& to = __jakt_match_value.to;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_142; {
String output = String("");
const NonnullRefPtr<typechecker::Type> type = ((((*this).program))->get_type(type_id));
const typechecker::TypeId index_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
default: {
{
utility::panic(String("Internal error: range expression doesn't have Range type"));
}
};/*case end*/
}/*switch end*/
}()
));
(output += String("("));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String("{"));
(output += String("static_cast<"));
(output += TRY((((*this).codegen_type(index_type)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(from)))));
(output += String("),static_cast<"));
(output += TRY((((*this).codegen_type(index_type)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(to)))));
(output += String(")})"));
__jakt_var_142 = output; goto __jakt_label_142;

}
__jakt_label_142:; __jakt_var_142.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();return JaktInternal::ExplicitValue(String("JaktInternal::OptionalNone()"));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(((String("(") + TRY((((*this).codegen_expression(expr))))) + String(")")));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(((String("(") + TRY((((*this).codegen_expression(expr))))) + String(".value())")));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_143; {
const String escaped_value = TRY((((val).replace(String("\n"),String("\\n")))));
__jakt_var_143 = ((String("String(\"") + escaped_value) + String("\")")); goto __jakt_label_143;

}
__jakt_label_143:; __jakt_var_143.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(((String("'") + val) + String("'")));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(((String("'") + val) + String("'")));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((var).name));
if (__jakt_enum_value == String("this")) {
return JaktInternal::ExplicitValue(String("*this"));
}
else {
return JaktInternal::ExplicitValue(((var).name));
}
}()))
);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(((((String("((") + TRY((((*this).codegen_expression(expr))))) + String(")[")) + TRY((((*this).codegen_expression(index))))) + String("])")));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(((((String("((") + TRY((((*this).codegen_expression(expr))))) + String(")[")) + TRY((((*this).codegen_expression(index))))) + String("])")));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_optional);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("(({}).map([](auto& _value) {{ return _value.template get<{}>(); }}))"),TRY((((*this).codegen_expression(expr)))),index))));
}
else {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("(({}).get<{}>())"),TRY((((*this).codegen_expression(expr)))),index))));
}
}()))
);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_144; {
String output = String("");
const String object = TRY((((*this).codegen_expression(expr))));
(output += String("(("));
(output += object);
(output += String(")"));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
{
(output += String("->"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((((*this).program))->get_struct(struct_id));
if (((((structure).record_type)).has<parser::RecordType::Class>() && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
(output += String("."));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if (is_optional){
(output += String("map([](auto& _value) { return _value."));
(output += index);
(output += String("; })"));
}
else {
(output += index);
}

(output += String(")"));
__jakt_var_144 = output; goto __jakt_label_144;

}
__jakt_label_144:; __jakt_var_144.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_block(block)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_call(call)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedCall const& call = __jakt_match_value.call;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_method_call(expr,call,is_optional)))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("true"));
}
else {
return JaktInternal::ExplicitValue(String("false"));
}
}()))
);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_145; {
String output = String("(");
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue(String("++"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue(String("--"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Negate>();
return JaktInternal::ExplicitValue(String("-"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
return JaktInternal::ExplicitValue(String("*"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue(String("&"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(String("!"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue(String("~"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_146; {
const String is_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_147; {
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
__jakt_var_147 = ((((((*this).program))->get_struct(id))).name); goto __jakt_label_147;

}
__jakt_label_147:; __jakt_var_147.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(type_id)))));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_146 = ((String("is<") + is_type) + String(">(")); goto __jakt_label_146;

}
__jakt_label_146:; __jakt_var_146.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_148; {
typechecker::TypeId final_type_id = ((cast).type_id());
const String cast_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = cast;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Fallible>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_149; {
const NonnullRefPtr<typechecker::Type> ty = ((((*this).program))->get_type(((cast).type_id())));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = *ty;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
default: {
{
utility::panic(String("Fallible type cast must have Optional result."));
}
};/*case end*/
}/*switch end*/
}()
));
String cast_type = String("dynamic_cast");
if (((((*this).program))->is_integer(type_id))){
(final_type_id = type_id);
(cast_type = String("fallible_integer_cast"));
}
__jakt_var_149 = cast_type; goto __jakt_label_149;

}
__jakt_label_149:; __jakt_var_149.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Infallible>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_150; {
String cast_type = String("verify_cast");
if (((((*this).program))->is_integer(type_id))){
(cast_type = String("infallible_integer_cast"));
}
__jakt_var_150 = cast_type; goto __jakt_label_150;

}
__jakt_label_150:; __jakt_var_150.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_148 = (((cast_type + String("<")) + TRY((((*this).codegen_type(final_type_id))))) + String(">(")); goto __jakt_label_148;

}
__jakt_label_148:; __jakt_var_148.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
const String object = TRY((((*this).codegen_expression(expr))));
(output += object);
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue(String("++"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue(String("--"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(String(")"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
return JaktInternal::ExplicitValue(String(")"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedUnaryOperator::IsEnumVariant>();typechecker::CheckedEnumVariant const& enum_variant = __jakt_match_value.enum_variant;
typechecker::TypeId const& enum_type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_151; {
const String name = ((enum_variant).name());
String suffix = String(")");
const bool is_boxed = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(enum_type_id));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((((*this).program))->get_enum(enum_id))).is_boxed));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
if ((is_boxed && (object != String("*this")))){
(suffix += String("->"));
}
else {
(suffix += String("."));
}

(suffix += String("has<"));
(suffix += TRY((((*this).codegen_type_possibly_as_namespace(enum_type_id,true)))));
(suffix += String("::"));
(suffix += name);
(suffix += String(">("));
__jakt_var_151 = suffix; goto __jakt_label_151;

}
__jakt_label_151:; __jakt_var_151.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += String(")"));
__jakt_var_145 = output; goto __jakt_label_145;

}
__jakt_label_145:; __jakt_var_145.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& lhs = __jakt_match_value.lhs;
NonnullRefPtr<typechecker::CheckedExpression> const& rhs = __jakt_match_value.rhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_binary_expression(expression,type_id,lhs,rhs,op)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_152; {
const String suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
return JaktInternal::ExplicitValue(String("LL"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
return JaktInternal::ExplicitValue(String("ULL"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
return JaktInternal::ExplicitValue(String("ULL"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
return JaktInternal::ExplicitValue(String("size_t"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(type_id)))));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_152 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F32>();
f32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_152;

}
__jakt_label_152:; __jakt_var_152.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();Array<typechecker::CheckedNamespace> const& namespaces = __jakt_match_value.namespaces;
typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_153; {
String output = String("");
{
ArrayIterator<typechecker::CheckedNamespace> _magic = ((namespaces).iterator());
for (;;){
Optional<typechecker::CheckedNamespace> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedNamespace ns = (_magic_value.value());
{
(output += (((ns).name) + String("::")));
}

}
}

__jakt_var_153 = (output + ((var).name)); goto __jakt_label_153;

}
__jakt_label_153:; __jakt_var_153.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
bool const& all_variants_constant = __jakt_match_value.all_variants_constant;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_match(expr,match_cases,type_id,all_variants_constant)))));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedEnumVariantBinding const& arg = __jakt_match_value.arg;
typechecker::CheckedEnumVariant const& enum_variant = __jakt_match_value.enum_variant;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_154; {
const String var_name = TRY((((*this).codegen_expression(expr))));
const String enum_type = TRY((((*this).codegen_type_possibly_as_namespace(typechecker::expression_type(expr),true))));
const String variant_name = ((enum_variant).name());
String arg_name = String("value");
if ((enum_variant).has<typechecker::CheckedEnumVariant::StructLike>()){
(arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); }));
}
const String cpp_deref_operator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((((*this).program))->get_enum(((enum_variant).enum_id())))).is_boxed));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("->"));
}
else {
return JaktInternal::ExplicitValue(String("."));
}
}()))
;
__jakt_var_154 = TRY((String::formatted(String("({}{}get<{}::{}>()).{}"),var_name,cpp_deref_operator,enum_type,variant_name,arg_name))); goto __jakt_label_154;

}
__jakt_label_154:; __jakt_var_154.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& repeat = __jakt_match_value.repeat;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& inner_type_id = __jakt_match_value.inner_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_155; {
String output = String("");
if (((repeat).has_value())){
const NonnullRefPtr<typechecker::CheckedExpression> repeat_val = ((repeat).value());
(output += String("("));
(output += TRY((((*this).current_error_handler()))));
(output += String("((Array<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String(">::filled("));
(output += TRY((((*this).codegen_expression(repeat_val)))));
(output += String(", "));
(output += TRY((((*this).codegen_expression(((vals)[static_cast<i64>(0LL)]))))));
(output += String("))))"));
}
else {
(output += String("("));
(output += TRY((((*this).current_error_handler()))));
(output += String("((Array<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String(">::create_with({"));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(val)))));
}

}
}

(output += String("}))))"));
}

__jakt_var_155 = output; goto __jakt_label_155;

}
__jakt_label_155:; __jakt_var_155.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& key_type_id = __jakt_match_value.key_type_id;
typechecker::TypeId const& value_type_id = __jakt_match_value.value_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_156; {
String output = TRY((String::formatted(String("({}((Dictionary<{}, {}>::create_with_entries({{"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_type(key_type_id)))),TRY((((*this).codegen_type(value_type_id)))))));
bool first = true;
{
ArrayIterator<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((vals).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>> val = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> key = ((val).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> value = ((val).get<1>());
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += String("{"));
(output += TRY((((*this).codegen_expression(key)))));
(output += String(", "));
(output += TRY((((*this).codegen_expression(value)))));
(output += String("}"));
}

}
}

(output += String("}))))"));
__jakt_var_156 = output; goto __jakt_label_156;

}
__jakt_label_156:; __jakt_var_156.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& inner_type_id = __jakt_match_value.inner_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_157; {
String output = String("");
(output += TRY((String::formatted(String("({}((Set<{}>::create_with_values({{"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_type(inner_type_id))))))));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> value = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(value)))));
}

}
}

(output += String("}))))"));
__jakt_var_157 = output; goto __jakt_label_157;

}
__jakt_label_157:; __jakt_var_157.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_158; {
String output = String("");
(output += String("(Tuple{"));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(val)))));
}

}
}

(output += String("})"));
__jakt_var_158 = output; goto __jakt_label_158;

}
__jakt_label_158:; __jakt_var_158.release_value(); }));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();Array<typechecker::CheckedCapture> const& captures = __jakt_match_value.captures;
Array<typechecker::CheckedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_159; {
Array<String> generated_captures = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedCapture> _magic = ((captures).iterator());
for (;;){
Optional<typechecker::CheckedCapture> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedCapture capture = (_magic_value.value());
{
TRY((((generated_captures).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = capture;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();return JaktInternal::ExplicitValue(((capture).name()));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),((capture).name())))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),((capture).name())))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

Array<String> generated_params = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((params).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
TRY((((generated_params).push(TRY((String::formatted(String("{} {}"),TRY((((*this).codegen_type(((((param).variable)).type_id))))),((((param).variable)).name))))))));
}

}
}

const String return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (can_throw);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),TRY((((*this).codegen_type(return_type_id))))))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(return_type_id)))));
}
}()))
;
__jakt_var_159 = TRY((String::formatted(String("[{}]({}) -> {} {}"),utility::join(generated_captures,String(", ")),utility::join(generated_params,String(", ")),return_type,TRY((((*this).codegen_block(block))))))); goto __jakt_label_159;

}
__jakt_label_159:; __jakt_var_159.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_160; {
utility::todo(TRY((String::formatted(String("codegen_expression else: {}"),expression))));
__jakt_var_160 = String(""); goto __jakt_label_160;

}
__jakt_label_160:; __jakt_var_160.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from_struct(const typechecker::StructId struct_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level,const Array<typechecker::TypeId> args) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if (((((struct_).definition_linkage)).has<parser::DefinitionLinkage::External>() && (((struct_).name) != String("Optional")))){
return (dependencies);
}
if (((((struct_).record_type)).has<parser::RecordType::Class>() && (!top_level))){
return (dependencies);
}
if ((!((args).is_empty()))){
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId inner_type = (_magic_value.value());
{
const Array<String> inner_dependencies = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(inner_type));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from(inner_type,dependency_graph,false)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from(inner_type,dependency_graph,false)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

}
TRY((((dependencies).push(TRY((((((struct_).type_id)).to_string())))))));
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::TypeId type_id = ((((((*this).program))->get_variable(field))).type_id);
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_in_namespace(const NonnullRefPtr<typechecker::CheckedFunction> function_,const Optional<typechecker::TypeId> containing_struct) {
{
if ((!((((function_)->generic_params)).is_empty()))){
if ((((function_)->linkage)).has<parser::FunctionLinkage::External>()){
return (String(""));
}
}
String output = String("");
(output += TRY((((*this).codegen_function_generic_parameters(function_)))));
const bool is_main = ((((function_)->name) == String("main")) && (!((containing_struct).has_value())));
if (((((function_)->return_type_id)).equals(typechecker::never_type_id()))){
(output += String("[[noreturn]] "));
}
if (is_main){
(output += String("ErrorOr<int>"));
}
else {
if ((((function_)->is_static()) && (!((containing_struct).has_value())))){
(output += String("static "));
}
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((function_)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),TRY((((*this).codegen_type(((function_)->return_type_id)))))))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(((function_)->return_type_id))))));
}
}()))
);
}

(output += String(" "));
if (is_main){
(output += String("main"));
}
else {
const String qualifier = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((containing_struct).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type_possibly_as_namespace((containing_struct.value()),true)))));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
if ((!((qualifier).is_empty()))){
(output += qualifier);
(output += String("::"));
}
(output += ((function_)->name));
}

(output += String("("));
if ((is_main && ((((function_)->params)).is_empty()))){
(output += String("Array<String>"));
}
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
if ((((variable).name) == String("this"))){
continue;
}
if ((!first)){
(output += String(","));
}
else {
(first = false);
}

const NonnullRefPtr<typechecker::Type> variable_type = ((((*this).program))->get_type(((variable).type_id)));
if (((!((variable).is_mutable)) && (!((variable_type)->has<typechecker::Type::Reference>() || (variable_type)->has<typechecker::Type::MutableReference>())))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((variable).type_id))))));
(output += String(" "));
(output += ((variable).name));
}

}
}

(output += String(")"));
if (((!((function_)->is_static())) && (!((function_)->is_mutating())))){
(output += String(" const"));
}
(output += String(" {\n"));
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_function()));
const String block = TRY((((*this).codegen_block(((function_)->block)))));
(((*this).control_flow_state) = last_control_flow);
(output += block);
if (is_main){
(output += String("return 0;\n"));
}
else {
if ((((function_)->can_throw) && (((((function_)->return_type_id)).id) == static_cast<size_t>(0ULL)))){
(output += String("return {};\n"));
}
}

(output += String("}\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_method_call(const NonnullRefPtr<typechecker::CheckedExpression> expr,const typechecker::CheckedCall call,const bool is_optional) {
{
String output = String("");
if (((call).callee_throws)){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
const String object = TRY((((*this).codegen_expression(expr))));
(output += String("(("));
(output += object);
(output += String(")"));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
{
(output += String("->"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
if (((((struct_).record_type)).has<parser::RecordType::Class>() && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(id));
if ((((enum_).is_boxed) && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
(output += String("."));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if (is_optional){
(output += String("map([&](auto& _value) { return _value."));
}
(output += ((call).name));
(output += String("("));
bool first = true;
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> name_and_expr = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += TRY((((*this).codegen_expression(((name_and_expr).get<1>()))))));
}

}
}

(output += String(")"));
if (is_optional){
(output += String("; })"));
}
(output += String(")"));
if (((call).callee_throws)){
(output += String("))"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct(const typechecker::CheckedStruct struct_) {
{
String output = String("");
if ((((struct_).definition_linkage)).has<parser::DefinitionLinkage::External>()){
return (String(""));
}
Array<String> generic_parameter_names = (TRY((Array<String>::create_with({}))));
if ((!((((struct_).generic_parameters)).is_empty()))){
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
TRY((((generic_parameter_names).push(TRY((((*this).codegen_type(generic_parameter))))))));
}

}
}

(output += TRY((String::formatted(String("template <{}>"),utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "))))));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
String class_name_with_generics = String("");
(class_name_with_generics += ((struct_).name));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((!first)){
(class_name_with_generics += String(", "));
}
else {
(class_name_with_generics += String("<"));
(first = false);
}

(class_name_with_generics += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

if ((!((((struct_).generic_parameters)).is_empty()))){
(class_name_with_generics += String(">"));
}
(output += TRY((String::formatted(String("class {} : public RefCounted<{}>, public Weakable<{}> {{\n"),((struct_).name),class_name_with_generics,class_name_with_generics))));
(output += String("  public:\n"));
(output += TRY((String::formatted(String("virtual ~{}() = default;\n"),((struct_).name)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
(output += TRY((String::formatted(String("struct {}"),((struct_).name)))));
(output += String(" {\n"));
(output += String("  public:\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
utility::todo(String("codegen_struct SumEnum"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
utility::todo(String("codegen_struct ValueEnum"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
const typechecker::CheckedVariable field = ((((*this).program))->get_variable(field_id));
(output += TRY((((*this).codegen_type(((field).type_id))))));
(output += String(" "));
(output += ((field).name));
(output += String(";"));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((struct_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> fn = (_magic_value.value());
{
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function_id = ((*this).current_function);
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(((fn).get<1>())));
(((*this).current_function) = (function_));
if ((((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()){
const String function_output = TRY((((*this).codegen_constructor(function_))));
(output += function_output);
(output += String("\n"));
}
else {
if (((((struct_).generic_parameters)).is_empty())){
(output += TRY((((*this).codegen_function_predecl(function_)))));
}
else {
(output += TRY((((*this).codegen_function(function_)))));
}

}

(((*this).current_function) = previous_function_id);
}

}
}

(output += TRY((((*this).codegen_debug_description_getter(struct_)))));
(output += String("};"));
(((*this).deferred_output) += TRY((((*this).codegen_ak_formatter(((struct_).name),generic_parameter_names)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_predecl(const typechecker::CheckedEnum enum_) {
{
String output = String("");
if ((!((((enum_).underlying_type_id)).equals(typechecker::void_type_id())))){
if (((((*this).program))->is_integer(((enum_).underlying_type_id)))){
return (TRY((String::formatted(String("enum class {}: {};"),((enum_).name),TRY((((*this).codegen_type(((enum_).underlying_type_id)))))))));
}
else {
utility::todo(String("Enums with a non-integer underlying type"));
}

}
const bool is_generic = (!((((enum_).generic_parameters)).is_empty()));
Array<String> template_args_array = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((((((*this).program))->get_type(generic_parameter)))->has<typechecker::Type::TypeVariable>()){
const String name = (((((*this).program))->get_type(generic_parameter))->get<typechecker::Type::TypeVariable>()).value;
TRY((((template_args_array).push((String("typename ") + name)))));
}
}

}
}

String template_args = utility::join(template_args_array,String(", "));
(output += (TRY((String::formatted(String("namespace {}_Details"),((enum_).name)))) + String(" {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

(output += String("}\n"));
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),((enum_).name)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_binary_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression,const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op) {
{
if ((op).has<parser::BinaryOperator::NoneCoalescing>()){
const typechecker::TypeId rhs_type_id = typechecker::expression_type(rhs);
const NonnullRefPtr<typechecker::Type> rhs_type = ((((*this).program))->get_type(rhs_type_id));
const bool rhs_can_throw = typechecker::expression_can_throw(rhs);
String output = String("");
if (rhs_can_throw){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
(output += TRY((((*this).codegen_expression(lhs)))));
if ((rhs_type)->has<typechecker::Type::GenericInstance>()){
const typechecker::StructId id = (rhs_type->get<typechecker::Type::GenericInstance>()).id;
if ((((((((*this).program))->get_struct(id))).name) == String("Optional"))){
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated_optional"));
}
else {
(output += String(".value_or_lazy_evaluated_optional"));
}

}
else {
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated"));
}
else {
(output += String(".value_or_lazy_evaluated"));
}

}

}
else {
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated"));
}
else {
(output += String(".value_or_lazy_evaluated"));
}

}

if (rhs_can_throw){
(output += String("([&]() -> ErrorOr<"));
(output += TRY((((*this).codegen_type(rhs_type_id)))));
(output += String("> { return "));
}
else {
(output += String("([&] { return "));
}

(output += TRY((((*this).codegen_expression(rhs)))));
(output += String("; })"));
if (rhs_can_throw){
(output += String("))"));
}
return (output);
}
if ((op).has<parser::BinaryOperator::NoneCoalescingAssign>()){
String output = TRY((((*this).codegen_expression(lhs))));
(output += String(".lazy_emplace([&] { return "));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String("; })"));
return (output);
}
if ((op).has<parser::BinaryOperator::ArithmeticRightShift>()){
String output = String("JaktInternal::arithmetic_shift_right(");
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(","));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
if (((op).has<parser::BinaryOperator::Assign>() && (lhs)->has<typechecker::CheckedExpression::IndexedDictionary>())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *lhs;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}({}.set({}, {}))"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_expression(expr)))),TRY((((*this).codegen_expression(index)))),TRY((((*this).codegen_expression(rhs))))))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
}
if (((((*this).program))->is_integer(type_id))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
String output = String("(");
(output += TRY((((*this).codegen_expression(lhs)))));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(String(" + "));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(String(" - "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(String(" * "));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(String(" % "));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(String(" / "));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(String(" = "));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(String(" += "));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(String(" -= "));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(String(" *= "));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(String(" %= "));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(String(" /= "));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(String(" &= "));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(String(" |= "));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(String(" ^= "));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(String(" <<= "));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(String(" >>= "));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(String(" == "));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue(String(" != "));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(String(" < "));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue(String(" <= "));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(String(" > "));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(String(" >= "));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(String(" && "));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(String(" || "));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue(String(" & "));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue(String(" | "));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue(String(" ^ "));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue(String(" << "));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue(String(" << "));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue(String(" >> "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_161; {
utility::todo(TRY((String::formatted(String("codegen_binary_expression {}"),op))));
__jakt_var_161 = String(""); goto __jakt_label_161;

}
__jakt_label_161:; __jakt_var_161.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_predecl(const NonnullRefPtr<typechecker::Scope> scope,const NonnullRefPtr<typechecker::Module> current_module) {
{
if (((((scope)->import_path_if_extern)).has_value())){
return (String(""));
}
String output = String("");
if (((((scope)->namespace_name)).has_value())){
(output += String("namespace "));
(output += (((scope)->namespace_name).value()));
(output += String(" {\n"));
}
{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!((((struct_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
(output += TRY((((*this).codegen_struct_predecl(struct_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!((((enum_id).module)).equals(((current_module)->id))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
(output += TRY((((*this).codegen_enum_predecl(enum_)))));
(output += String("\n"));
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
(output += TRY((((*this).codegen_namespace_predecl(TRY((((((*this).program))->get_scope(child)))),current_module)))));
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
if ((!((((function_id).module)).equals(((current_module)->id))))){
continue;
}
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
if ((((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>()){
continue;
}
const String function_output = TRY((((*this).codegen_function_predecl(function_))));
if (((!(((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()) && (((function_)->name) != String("main")))){
(output += function_output);
(output += String("\n"));
}
}

}
}

if (((((scope)->namespace_name)).has_value())){
(output += String("}\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::current_error_handler() const {
{
if ((((((*this).current_function)).has_value()) && ((((((((*this).current_function).value()))->return_type_id)).equals(typechecker::never_type_id())) && (!((((*this).control_flow_state)).passes_through_try))))){
return (String("MUST"));
}
return (String("TRY"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_qualifier(const typechecker::ScopeId scope_id) const {
{
String output = String("");
Optional<typechecker::ScopeId> current_scope_id = ((TRY((((((*this).program))->get_scope(scope_id)))))->parent);
while (((current_scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope((current_scope_id.value())))));
if (((((scope)->namespace_name)).has_value())){
const String namespace_name = (((scope)->namespace_name).value());
(output = TRY((String::formatted(String("{}::{}"),namespace_name,output))));
}
(current_scope_id = ((scope)->parent));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_path(const typechecker::CheckedCall call) const {
{
String output = String("");
size_t index = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::ResolvedNamespace> _magic = ((((call).namespace_)).iterator());
for (;;){
Optional<typechecker::ResolvedNamespace> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ResolvedNamespace namespace_ = (_magic_value.value());
{
if (((index == (JaktInternal::checked_sub<size_t>(((((call).namespace_)).size()),static_cast<size_t>(1ULL)))) && (((namespace_).name) == ((call).name)))){
break;
}
(output += ((namespace_).name));
if (((((namespace_).generic_parameters)).has_value())){
(output += String("<"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::TypeId> _magic = (((((namespace_).generic_parameters).value())).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId param = (_magic_value.value());
{
(output += TRY((((*this).codegen_type(param)))));
if ((i != (JaktInternal::checked_sub<size_t>((((((namespace_).generic_parameters).value())).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
(++i);
}

}
}

(output += String(">"));
}
(output += String("::"));
(++index);
}

}
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_type_possibly_as_namespace(const typechecker::TypeId type_id,const bool as_namespace) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("size_t"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("char"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("int"));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String("*")));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String(" const&")));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String("&")));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_type_instance(id,args,as_namespace)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_type_instance(id,args,as_namespace)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_struct_type(id,as_namespace)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_enum_type(id,as_namespace)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_enum_instance(id,args,as_namespace)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_162; {
__jakt_var_162 = String("auto"); goto __jakt_label_162;

}
__jakt_label_162:; __jakt_var_162.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from(const typechecker::TypeId type_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
if (((dependency_graph).contains(TRY((((type_id).to_string())))))){
{
ArrayIterator<String> _magic = (((((dependency_graph).get(TRY((((type_id).to_string()))))).value())).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

return (dependencies);
}
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
const Array<String> inner_dependencies = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_enum(enum_id,dependency_graph,top_level)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_enum(id,dependency_graph,top_level)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_struct(id,dependency_graph,top_level,(TRY((Array<typechecker::TypeId>::create_with({})))))))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_struct(id,dependency_graph,top_level,args)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_match_body(const typechecker::CheckedMatchBody body,const typechecker::TypeId return_type_id) {
{
String output = String("");
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
{
(output += TRY((((*this).codegen_block(block)))));
if ((((return_type_id).equals(typechecker::void_type_id())) || ((return_type_id).equals(typechecker::unknown_type_id())))){
(output += String("return JaktInternal::ExplicitValue<void>();\n"));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
{
if ((((typechecker::expression_type(expr)).equals(typechecker::void_type_id())) || (((typechecker::expression_type(expr)).equals(typechecker::unknown_type_id())) && (!(expr)->has<typechecker::CheckedExpression::OptionalNone>())))){
(output += String("return ("));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String("), JaktInternal::ExplicitValue<void>();\n"));
}
else {
(output += String("return JaktInternal::ExplicitValue("));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String(");\n"));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_predecl(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
String output = String("");
if (((!((((function_)->generic_params)).is_empty())) && (((function_)->linkage)).has<parser::FunctionLinkage::External>())){
return (String(""));
}
if ((((function_)->type)).has<parser::FunctionType::ImplicitConstructor>()){
return (String(""));
}
if ((((function_)->linkage)).has<parser::FunctionLinkage::External>()){
(output += String("extern "));
}
(output += TRY((((*this).codegen_function_generic_parameters(function_)))));
if (((((function_)->return_type_id)).equals(typechecker::never_type_id()))){
(output += String("[[noreturn]] "));
}
if ((((function_)->name) == String("main"))){
(output += String("ErrorOr<int>"));
}
else {
if ((((function_)->is_static()) && (!(((function_)->linkage)).has<parser::FunctionLinkage::External>()))){
(output += String("static "));
}
const String naked_return_type = TRY((((*this).codegen_type(((function_)->return_type_id)))));
const String return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((function_)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),naked_return_type))));
}
else {
return JaktInternal::ExplicitValue(naked_return_type);
}
}()))
;
(output += return_type);
}

(output += String(" "));
(output += ((function_)->name));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((first && (((((param).variable)).name) == String("this")))){
continue;
}
if (first){
(first = false);
}
else {
(output += String(", "));
}

const NonnullRefPtr<typechecker::Type> param_type = ((((*this).program))->get_type(((((param).variable)).type_id)));
if (((!((((param).variable)).is_mutable)) && (!((param_type)->has<typechecker::Type::Reference>() || (param_type)->has<typechecker::Type::MutableReference>())))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" "));
(output += ((((param).variable)).name));
}

}
}

(output += String(")"));
if (((!((function_)->is_static())) && (!((function_)->is_mutating())))){
(output += String(" const;"));
}
else {
(output += String(";"));
}

(output += String("\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::fresh_var() {
{
return (TRY((String::formatted(String("__jakt_var_{}"),(((*this).fresh_var_counter)++)))));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_block(const typechecker::CheckedBlock block) {
{
String output = String("");
if (((((block).yielded_type)).has_value())){
const typechecker::TypeId yielded_type = (((block).yielded_type).value());
const String type_output = TRY((((*this).codegen_type(yielded_type))));
const String fresh_var = TRY((((*this).fresh_var())));
const String fresh_label = TRY((((*this).fresh_label())));
TRY((((((*this).entered_yieldable_blocks)).push((Tuple{fresh_var, fresh_label})))));
(output += String("({ Optional<"));
(output += type_output);
(output += String("> "));
(output += fresh_var);
(output += String("; "));
}
(output += String("{\n"));
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
(output += TRY((((*this).codegen_statement(statement)))));
}

}
}

(output += String("}\n"));
if (((((block).yielded_type)).has_value())){
const Tuple<String,String> block_tuple = (((((*this).entered_yieldable_blocks)).pop()).value());
const String block_var = ((block_tuple).get<0>());
const String block_label = ((block_tuple).get<1>());
(output += block_label);
(output += String(":; "));
(output += block_var);
(output += String(".release_value(); })"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_checked_binary_op_assignment(const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op,const typechecker::TypeId type_id) {
{
String output = String("");
(output += String("{"));
(output += String("auto& _jakt_ref = "));
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(";"));
(output += String("_jakt_ref = JaktInternal::"));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(String("checked_add"));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(String("checked_sub"));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(String("checked_mul"));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(String("checked_div"));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(String("checked_mod"));
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Checked binary operation assignment codegen is not supported for BinaryOperator::{}"),op))));
}
};/*case end*/
}/*switch end*/
}()
)));
(output += String("<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(">(_jakt_ref, "));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(");"));
(output += String("}"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_type(const typechecker::EnumId id,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
const typechecker::CheckedEnum checked_enum = ((((*this).program))->get_enum(id));
if (((!as_namespace) && ((checked_enum).is_boxed))){
(output += String("NonnullRefPtr<"));
if ((!(((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))))){
(output += ((type_module)->name));
(output += String("::"));
}
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((checked_enum).scope_id)))));
if ((!((qualifier).is_empty()))){
(output += String("typename "));
(output += qualifier);
}
(output += ((checked_enum).name));
(output += String(">"));
}
else {
if ((!(((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))))){
(output += ((type_module)->name));
(output += String("::"));
}
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((checked_enum).scope_id)))));
if ((!((qualifier).is_empty()))){
(output += qualifier);
}
(output += ((checked_enum).name));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_constructor(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
const typechecker::TypeId type_id = ((function_)->return_type_id);
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
if ((type_)->has<typechecker::Type::Struct>()){
const typechecker::StructId struct_id = (type_->get<typechecker::Type::Struct>()).value;
const typechecker::CheckedStruct structure = ((((*this).program))->get_struct(struct_id));
if ((((structure).record_type)).has<parser::RecordType::Class>()){
String output = String("");
(output += String("private:\n"));
(output += TRY((String::formatted(String("explicit {}("),((function_)->name)))));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

const typechecker::TypeId param_type_id = ((((param).variable)).type_id);
(output += TRY((((*this).codegen_type(param_type_id)))));
(output += String("&& a_"));
(output += ((((param).variable)).name));
}

}
}

(output += String(")"));
if ((!((((function_)->params)).is_empty()))){
(output += String(": "));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += ((((param).variable)).name));
(output += String("(move(a_"));
(output += ((((param).variable)).name));
(output += String("))"));
}

}
}

}
(output += String("{}\n"));
String class_name_with_generics = String("");
(class_name_with_generics += ((structure).name));
(first = true);
{
ArrayIterator<typechecker::TypeId> _magic = ((((structure).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((!first)){
(class_name_with_generics += String(", "));
}
else {
(class_name_with_generics += String("<"));
(first = false);
}

(class_name_with_generics += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

if ((!((((structure).generic_parameters)).is_empty()))){
(class_name_with_generics += String(">"));
}
(output += String("public:\n"));
(output += TRY((String::formatted(String("static ErrorOr<NonnullRefPtr<{}>> create"),class_name_with_generics))));
(output += String("("));
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" "));
(output += ((((param).variable)).name));
}

}
}

(output += TRY((String::formatted(String(") {{ auto o = {}(adopt_nonnull_ref_or_enomem(new (nothrow) {} ("),TRY((((*this).current_error_handler()))),class_name_with_generics))));
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += String("move("));
(output += ((((param).variable)).name));
(output += String(")"));
}

}
}

(output += String("))); return o; }"));
return (output);
}
else {
String output = String("");
(output += ((function_)->name));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" a_"));
(output += ((((param).variable)).name));
}

}
}

(output += String(") "));
if ((!((((function_)->params)).is_empty()))){
(output += String(":"));
}
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += ((((param).variable)).name));
(output += String("(a_"));
(output += ((((param).variable)).name));
(output += String(")"));
}

}
}

(output += String("{}\n"));
return (output);
}

return (String(""));
}
else {
utility::panic(String("internal error: call to a constructor, but not a struct/class type"));
}

}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_debug_description_getter(const typechecker::CheckedEnum enum_) {
{
String output = String("");
(output += String("ErrorOr<String> debug_description() const { "));
(output += String("auto builder = TRY(StringBuilder::create());"));
(output += String("TRY(this->visit("));
Array<String> variant_lambdas = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
const String name = ((variant).name());
String lambda = (TRY((String::formatted(String("[&]([[maybe_unused]] {} const& that)"),name))) + String(" -> ErrorOr<void> {\n"));
(lambda += TRY((String::formatted(String("TRY(builder.append(\"{}::{}\"));"),((enum_).name),name))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
(lambda += String("TRY(builder.append(\"(\"));"));
(lambda += String("JaktInternal::_pretty_print_level++;"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
(lambda += String("TRY(JaktInternal::_output_pretty_indent(builder));"));
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(field));
(lambda += TRY((String::formatted(String("TRY(builder.append(\"{}: \"));"),((var).name)))));
if (((((*this).program))->is_string(((var).type_id)))){
(lambda += String("TRY(builder.append(\"\\\"\"));"));
}
(lambda += ((String("TRY(builder.appendff(\"{}\", that.") + ((var).name)) + String("));")));
if (((((*this).program))->is_string(((var).type_id)))){
(lambda += String("TRY(builder.append(\"\\\"\"));"));
}
if ((i != (JaktInternal::checked_sub<size_t>(((fields).size()),static_cast<size_t>(1ULL))))){
(lambda += String("TRY(builder.append(\", \"));"));
}
(i++);
}

}
}

(lambda += String("JaktInternal::_pretty_print_level--;"));
(lambda += String("TRY(builder.append(\")\"));"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
(lambda += String("TRY(builder.append(\"(\"));"));
if (((((*this).program))->is_string(type_id))){
(lambda += String("TRY(builder.append(\"\\\"\"));"));
}
(lambda += String("TRY(builder.appendff(\"{}\", that.value));"));
if (((((*this).program))->is_string(type_id))){
(lambda += String("TRY(builder.append(\"\\\"\"));"));
}
(lambda += String("TRY(builder.append(\")\"));"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
(lambda += String("return {}; }"));
TRY((((variant_lambdas).push(lambda))));
}

}
}

(output += utility::join(variant_lambdas,String(",")));
(output += ((String("));") + String("return builder.to_string();")) + String("}")));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_match(const typechecker::CheckedEnum enum_,const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> match_cases,const typechecker::TypeId type_id,const bool all_variants_constant) {
{
String output = String("");
(output += ((((*this).control_flow_state)).choose_control_flow_macro()));
const String subject = TRY((((*this).codegen_expression(expr))));
const bool needs_deref = (((enum_).is_boxed) && (subject != String("*this")));
if (((((enum_).underlying_type_id)).equals(typechecker::void_type_id()))){
(output += String("(([&]() -> JaktInternal::ExplicitValueOrControlFlow<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(", "));
(output += TRY((((*this).codegen_function_return_type((((*this).current_function).value()))))));
(output += String(">{\n"));
(output += String("auto&& __jakt_match_variant = "));
if (needs_deref){
(output += String("*"));
}
(output += (TRY((((*this).codegen_expression(expr)))) + String(";\n")));
(output += String("switch(__jakt_match_variant.index()) {\n"));
bool has_default = false;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase match_case = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = match_case;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
size_t const& index = __jakt_match_value.index;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
const NonnullRefPtr<typechecker::Type> enum_type = ((((*this).program))->get_type(subject_type_id));
const typechecker::EnumId enum_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, ErrorOr<String>>{
auto&& __jakt_match_variant = *enum_type;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: {
{
utility::panic(String("Expected enum type"));
}
};/*case end*/
}/*switch end*/
}()
));
const typechecker::CheckedEnum match_case_enum = ((((*this).program))->get_enum(enum_id));
const typechecker::CheckedEnumVariant variant = ((((match_case_enum).variants))[index]);
(output += (TRY((String::formatted(String("case {}: "),index))) + String("{\n")));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
if ((!((args).is_empty()))){
const parser::EnumVariantPatternArgument arg = ((args)[static_cast<i64>(0LL)]);
const typechecker::CheckedVariable var = (TRY((((((*this).program))->find_var_in_scope(scope_id,((arg).binding))))).value());
(output += TRY((String::formatted(String("{} const& {} = __jakt_match_value.value;\n"),TRY((((*this).codegen_type(((var).type_id))))),((arg).binding)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<{}::{}>();"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
if ((!((args).is_empty()))){
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((args).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
const typechecker::CheckedVariable var = (TRY((((((*this).program))->find_var_in_scope(scope_id,((arg).binding))))).value());
(output += TRY((((*this).codegen_type(((var).type_id))))));
(output += String(" const& "));
(output += ((arg).binding));
(output += String(" = __jakt_match_value."));
(output += ((((arg).name)).value_or(((arg).binding))));
(output += String(";\n"));
}

}
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("codegen_enum_match match variant else: {}"),variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
(output += TRY((((*this).codegen_match_body(body,type_id)))));
(output += String("};/*case end*/\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
(has_default = true);
(output += String("default: {\n"));
(output += TRY((((*this).codegen_match_body(body,type_id)))));
(output += String("};/*case end*/\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("Matching enum subject with non-enum value"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

if ((!has_default)){
if ((((((enum_).variants)).size()) != ((match_cases).size()))){
utility::panic(String("Inexhaustive match statement"));
}
(output += String("default: VERIFY_NOT_REACHED();"));
}
(output += String("}/*switch end*/\n"));
(output += String("}()\n))"));
}
else {
utility::todo(String("underlying type enum match"));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_match(const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> match_cases,const typechecker::TypeId type_id,const bool all_variants_constant) {
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((((*this).control_flow_state)).enter_match()));
String output = String("");
const NonnullRefPtr<typechecker::Type> expr_type = ((((*this).program))->get_type(typechecker::expression_type(expr)));
if ((expr_type)->has<typechecker::Type::Enum>()){
const typechecker::EnumId enum_id = (expr_type->get<typechecker::Type::Enum>()).value;
(output += TRY((((*this).codegen_enum_match(((((*this).program))->get_enum(enum_id)),expr,match_cases,type_id,all_variants_constant)))));
}
else {
(output += TRY((((*this).codegen_generic_match(expr,match_cases,type_id,all_variants_constant)))));
}

(((*this).control_flow_state) = last_control_flow);
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_return_type(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
if ((((function_)->is_static()) && (((function_)->name) == String("main")))){
return (String("ErrorOr<int>"));
}
const String type_name = TRY((((*this).codegen_type(((function_)->return_type_id)))));
if (((function_)->can_throw)){
return (TRY((String::formatted(String("ErrorOr<{}>"),type_name))));
}
return (type_name);
}
}

ErrorOr<String> codegen::CodeGenerator::generate(const NonnullRefPtr<compiler::Compiler> compiler,const NonnullRefPtr<typechecker::CheckedProgram> program,const bool debug_info) {
{
codegen::CodeGenerator generator = codegen::CodeGenerator(compiler,program,codegen::ControlFlowState(typename codegen::AllowedControlExits::Nothing(),false,false,static_cast<size_t>(0ULL)),(TRY((Array<Tuple<String,String>>::create_with({})))),String(""),JaktInternal::OptionalNone(),codegen::CodegenDebugInfo(compiler,(TRY((Dictionary<size_t, Array<codegen::LineSpan>>::create_with_entries({})))),debug_info),(TRY((Array<String>::create_with({})))),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL));
String output = String("");
(output += String("#include <lib.h>\n"));
const Array<typechecker::ModuleId> sorted_modules = TRY((((generator).topologically_sort_modules())));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child_scope = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(child_scope))));
if (((((scope)->import_path_if_extern)).has_value())){
const bool has_name = ((((scope)->namespace_name)).has_value());
if (has_name){
(output += TRY((String::formatted(String("namespace {} {{\n"),(((scope)->namespace_name).value())))));
}
(output += TRY((String::formatted(String("#include <{}>\n"),(((scope)->import_path_if_extern).value())))));
if (has_name){
(output += ((String(" } // namespace ") + (((scope)->namespace_name).value())) + String("\n")));
}
}
}

}
}

}

}
}

(output += String("namespace Jakt {\n"));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
((((generator).compiler))->dbg_println(TRY((String::formatted(String("generate: module idx: {}, module.name {}"),i,((module)->name))))));
if ((!((module)->is_root))){
(output += String("namespace "));
(output += ((module)->name));
(output += String(" {\n"));
}
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
(output += TRY((((generator).codegen_namespace_predecl(scope,module)))));
if ((!((module)->is_root))){
(output += String("}\n"));
}
}

}
}

{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
((((generator).compiler))->dbg_println(TRY((String::formatted(String("generate: module idx: {}, module.name {}"),i,((module)->name))))));
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
if ((!((module)->is_root))){
(output += String("namespace "));
(output += ((module)->name));
(output += String(" {\n"));
TRY((((((generator).namespace_stack)).push(((module)->name)))));
}
(output += TRY((((generator).codegen_namespace(scope,module)))));
if ((!((module)->is_root))){
const Optional<String> dummy = ((((generator).namespace_stack)).pop());
}
if ((!((module)->is_root))){
(output += String("}\n"));
}
}

}
}

(output += ((generator).deferred_output));
(output += String("} // namespace Jakt\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_call(const typechecker::CheckedCall call) {
{
String output = String("");
if (((call).callee_throws)){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("println")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprint")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("format")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
if (((((call).function_id)).has_value())){
const typechecker::FunctionId function_id = (((call).function_id).value());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if (((((function_)->type)).has<parser::FunctionType::ImplicitConstructor>() || (((function_)->type)).has<parser::FunctionType::ExternalClassConstructor>())){
const typechecker::TypeId type_id = ((call).return_type);
const NonnullRefPtr<typechecker::Type> type = ((((*this).program))->get_type(type_id));
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if ((!(((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if ((((struct_).record_type)).has<parser::RecordType::Class>()){
(output += ((call).name));
(output += String("::"));
(output += String("create"));
}
else {
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
if ((((struct_).record_type)).has<parser::RecordType::Class>()){
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(arg)))));
}

}
}

(output += String(">::create"));
}
else {
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("Should be unreachable"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
else if ((((function_)->type)).has<parser::FunctionType::ImplicitEnumConstructor>()){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(((function_)->return_type_id)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
const NonnullRefPtr<typechecker::Module> enum_type_module = ((((*this).program))->get_module(((enum_id).module)));
if (((enum_).is_boxed)){
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if ((!(((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += String("template create<typename "));
(output += TRY((((*this).codegen_type_possibly_as_namespace(((call).return_type),true)))));
(output += ((String("::") + ((call).name)) + String(">")));
}
else {
(output += String("typename "));
(output += TRY((((*this).codegen_type(((call).return_type))))));
(output += String("::"));
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
{
utility::todo(String("codegen generic enum instance"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("constructor expected enum type"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
else {
if ((!(((((type_module)->is_root) || (((((type_module)->id)).id) == static_cast<size_t>(0ULL))) || (((function_)->linkage)).has<parser::FunctionLinkage::External>()) || ((!((((call).namespace_)).is_empty())) && (((((((call).namespace_))[static_cast<i64>(0LL)])).name) == ((type_module)->name)))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += ((call).name));
}

}
else {
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += ((call).name));
}

const Array<typechecker::TypeId> generic_parameters = ((call).type_args);
if ((!((generic_parameters).is_empty()))){
Array<String> types = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((generic_parameters).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId gen_param = (_magic_value.value());
{
TRY((((types).push(TRY((((*this).codegen_type_possibly_as_namespace(gen_param,false))))))));
}

}
}

(output += TRY((String::formatted(String("<{}>"),utility::join(types,String(", "))))));
}
Array<String> arguments = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(TRY((((*this).codegen_expression(((arg).get<1>())))))))));
}

}
}

(output += TRY((String::formatted(String("({})"),utility::join(arguments,String(","))))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
if (((call).callee_throws)){
(output += String("))"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_enum_instance(const typechecker::EnumId id,const Array<typechecker::TypeId> args,const bool as_namespace) const {
{
String output = String("");
bool close_tag = false;
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(id));
if (((!as_namespace) && ((enum_).is_boxed))){
(output += String("NonnullRefPtr<"));
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((enum_).scope_id)))));
if ((!((qualifier).is_empty()))){
(output += String("typename "));
(output += qualifier);
}
(output += ((enum_).name));
(close_tag = true);
}
else {
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((enum_).scope_id)))));
if ((!((qualifier).is_empty()))){
(output += String("typename "));
(output += qualifier);
}
(output += ((enum_).name));
}

(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
if ((!first)){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">"));
if (close_tag){
(output += String(">"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_generic_parameters(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
String output = String("");
if ((!((((function_)->generic_params)).is_empty()))){
(output += String("template <"));
bool first = true;
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((function_)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::FunctionGenericParameter generic_parameter = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += String("typename "));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = generic_parameter;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_ak_formatter(const String name,const Array<String> generic_parameter_names) {
{
String output = String("");
const String template_args = utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "));
const String generic_type_args = utility::join(generic_parameter_names,String(", "));
String qualified_name = String("");
{
ArrayIterator<String> _magic = ((((*this).namespace_stack)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String namespace_ = (_magic_value.value());
{
(qualified_name += TRY((String::formatted(String("{}::"),namespace_))));
}

}
}

(qualified_name += name);
if ((!((generic_parameter_names).is_empty()))){
(qualified_name += TRY((String::formatted(String("<{}>\n"),generic_type_args))));
}
(output += TRY((String::formatted(String("template<{}>"),template_args))));
(output += TRY((String::formatted(String("struct Formatter<{}> : Formatter<StringView>"),qualified_name))));
(output += String("{\n"));
(output += TRY((String::formatted(String("ErrorOr<void> format(FormatBuilder& builder, {} const& value)\n"),qualified_name))));
(output += String("{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }"));
(output += String("return Formatter<StringView>::format(builder, MUST(value.debug_description())); }"));
return ((output + String("};\n")));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_type(const typechecker::TypeId type_id) const {
{
return (TRY((((*this).codegen_type_possibly_as_namespace(type_id,false)))));
}
}

ErrorOr<void> codegen::CodeGenerator::postorder_traversal(const String encoded_type_id,Set<String> visited,const Dictionary<String,Array<String>> encoded_dependency_graph,Array<typechecker::TypeId> output) const {
{
const typechecker::TypeId type_id = TRY((typechecker::TypeId::from_string(encoded_type_id)));
if (((visited).contains(TRY((((type_id).to_string())))))){
return {};
}
TRY((((visited).add(TRY((((type_id).to_string())))))));
if (((encoded_dependency_graph).contains(encoded_type_id))){
{
ArrayIterator<String> _magic = (((((encoded_dependency_graph).get(encoded_type_id)).value())).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((*this).postorder_traversal(dependency,visited,encoded_dependency_graph,output))));
}

}
}

}
TRY((((output).push(type_id))));
}
return {};
}

ErrorOr<String> codegen::CodeGenerator::fresh_label() {
{
return (TRY((String::formatted(String("__jakt_label_{}"),(((*this).fresh_label_counter)++)))));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_function() const {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::JustReturn(),false,false,((*this).match_nest_level)));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_loop() const {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::AtLoop(),false,((*this).passes_through_try),static_cast<size_t>(0ULL)));
}
}

codegen::ControlFlowState codegen::ControlFlowState::no_control_flow() {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::Nothing(),false,false,static_cast<size_t>(0ULL)));
}
}

bool codegen::ControlFlowState::is_match_nested() const {
{
return ((((*this).match_nest_level) != static_cast<size_t>(0ULL)));
}
}

String codegen::ControlFlowState::choose_control_flow_macro() const {
{
if (codegen::are_loop_exits_allowed(((*this).allowed_exits))){
if (((*this).is_match_nested())){
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH"));
}
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP"));
}
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY"));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_match() const {
{
size_t level = ((*this).match_nest_level);
if (((*this).passes_through_match)){
(level = (JaktInternal::checked_add<size_t>(((*this).match_nest_level),static_cast<size_t>(1ULL))));
}
return (codegen::ControlFlowState(((((*this).allowed_exits)).allow_return()),true,((*this).passes_through_try),level));
}
}

codegen::AllowedControlExits codegen::AllowedControlExits::allow_return() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<codegen::AllowedControlExits, codegen::AllowedControlExits>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::Nothing>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::JustReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::JustReturn>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::JustReturn());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::AtLoop>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::AtLoop());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace ide {
namespace VarVisibility_Details {
struct DoesNotApply {};
struct Public {};
struct Private {};
struct Restricted {};
}
struct VarVisibility : public Variant<VarVisibility_Details::DoesNotApply, VarVisibility_Details::Public, VarVisibility_Details::Private, VarVisibility_Details::Restricted> {
using Variant<VarVisibility_Details::DoesNotApply, VarVisibility_Details::Public, VarVisibility_Details::Private, VarVisibility_Details::Restricted>::Variant;
    using DoesNotApply = VarVisibility_Details::DoesNotApply;
    using Public = VarVisibility_Details::Public;
    using Private = VarVisibility_Details::Private;
    using Restricted = VarVisibility_Details::Restricted;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] DoesNotApply const& that) -> ErrorOr<void> {
TRY(builder.append("VarVisibility::DoesNotApply"));return {}; },[&]([[maybe_unused]] Public const& that) -> ErrorOr<void> {
TRY(builder.append("VarVisibility::Public"));return {}; },[&]([[maybe_unused]] Private const& that) -> ErrorOr<void> {
TRY(builder.append("VarVisibility::Private"));return {}; },[&]([[maybe_unused]] Restricted const& that) -> ErrorOr<void> {
TRY(builder.append("VarVisibility::Restricted"));return {}; }));return builder.to_string();}};
namespace Mutability_Details {
struct DoesNotApply {};
struct Immutable {};
struct Mutable {};
}
struct Mutability : public Variant<Mutability_Details::DoesNotApply, Mutability_Details::Immutable, Mutability_Details::Mutable> {
using Variant<Mutability_Details::DoesNotApply, Mutability_Details::Immutable, Mutability_Details::Mutable>::Variant;
    using DoesNotApply = Mutability_Details::DoesNotApply;
    using Immutable = Mutability_Details::Immutable;
    using Mutable = Mutability_Details::Mutable;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] DoesNotApply const& that) -> ErrorOr<void> {
TRY(builder.append("Mutability::DoesNotApply"));return {}; },[&]([[maybe_unused]] Immutable const& that) -> ErrorOr<void> {
TRY(builder.append("Mutability::Immutable"));return {}; },[&]([[maybe_unused]] Mutable const& that) -> ErrorOr<void> {
TRY(builder.append("Mutability::Mutable"));return {}; }));return builder.to_string();}};
namespace VarType_Details {
struct Variable {};
struct Field {};
}
struct VarType : public Variant<VarType_Details::Variable, VarType_Details::Field> {
using Variant<VarType_Details::Variable, VarType_Details::Field>::Variant;
    using Variable = VarType_Details::Variable;
    using Field = VarType_Details::Field;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Variable const& that) -> ErrorOr<void> {
TRY(builder.append("VarType::Variable"));return {}; },[&]([[maybe_unused]] Field const& that) -> ErrorOr<void> {
TRY(builder.append("VarType::Field"));return {}; }));return builder.to_string();}};
namespace Usage_Details {
struct Variable {
utility::Span span;
String name;
typechecker::TypeId type_id;
ide::Mutability mutability;
ide::VarType var_type;
ide::VarVisibility visibility;
Optional<typechecker::TypeId> struct_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
Variable(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
span{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
mutability{ forward<_MemberT3>(member_3)},
var_type{ forward<_MemberT4>(member_4)},
visibility{ forward<_MemberT5>(member_5)},
struct_type_id{ forward<_MemberT6>(member_6)}
{}
};
struct Call{
typechecker::FunctionId value;
template<typename... Args>
Call(Args&&... args): value { forward<Args>(args)... } {}
};
struct Typename{
typechecker::TypeId value;
template<typename... Args>
Typename(Args&&... args): value { forward<Args>(args)... } {}
};
struct NameSet{
Array<String> value;
template<typename... Args>
NameSet(Args&&... args): value { forward<Args>(args)... } {}
};
struct EnumVariant {
utility::Span span;
String name;
typechecker::TypeId type_id;
Array<Tuple<Optional<String>,typechecker::TypeId>> variants;
Optional<typechecker::NumberConstant> number_constant;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
span{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
variants{ forward<_MemberT3>(member_3)},
number_constant{ forward<_MemberT4>(member_4)}
{}
};
}
struct Usage : public Variant<Usage_Details::Variable, Usage_Details::Call, Usage_Details::Typename, Usage_Details::NameSet, Usage_Details::EnumVariant> {
using Variant<Usage_Details::Variable, Usage_Details::Call, Usage_Details::Typename, Usage_Details::NameSet, Usage_Details::EnumVariant>::Variant;
    using Variable = Usage_Details::Variable;
    using Call = Usage_Details::Call;
    using Typename = Usage_Details::Typename;
    using NameSet = Usage_Details::NameSet;
    using EnumVariant = Usage_Details::EnumVariant;
ErrorOr<String> debug_description() const { auto builder = TRY(StringBuilder::create());TRY(this->visit([&]([[maybe_unused]] Variable const& that) -> ErrorOr<void> {
TRY(builder.append("Usage::Variable"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("mutability: "));TRY(builder.appendff("{}", that.mutability));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_type: "));TRY(builder.appendff("{}", that.var_type));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", that.visibility));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("struct_type_id: "));TRY(builder.appendff("{}", that.struct_type_id));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Call const& that) -> ErrorOr<void> {
TRY(builder.append("Usage::Call"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] Typename const& that) -> ErrorOr<void> {
TRY(builder.append("Usage::Typename"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] NameSet const& that) -> ErrorOr<void> {
TRY(builder.append("Usage::NameSet"));TRY(builder.append("("));TRY(builder.appendff("{}", that.value));TRY(builder.append(")"));return {}; },[&]([[maybe_unused]] EnumVariant const& that) -> ErrorOr<void> {
TRY(builder.append("Usage::EnumVariant"));TRY(builder.append("("));JaktInternal::_pretty_print_level++;TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", that.span));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.append("\""));TRY(builder.appendff("{}", that.name));TRY(builder.append("\""));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", that.type_id));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variants: "));TRY(builder.appendff("{}", that.variants));TRY(builder.append(", "));TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("number_constant: "));TRY(builder.appendff("{}", that.number_constant));JaktInternal::_pretty_print_level--;TRY(builder.append(")"));return {}; }));return builder.to_string();}};
static ErrorOr<ide::Usage> get_enum_variant_usage_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const String name) {
{
{
ArrayIterator<typechecker::CheckedEnum> _magic = ((((((program)->get_module(((type_id).module))))->enums)).iterator());
for (;;){
Optional<typechecker::CheckedEnum> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnum enum_ = (_magic_value.value());
{
if ((!((((enum_).type_id)).equals(type_id)))){
continue;
}
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> variants = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> number_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::NumberConstant>, ErrorOr<ide::Usage>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((expr)->to_number_constant(program)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
const utility::Span span = ((variant).span());
return (typename ide::Usage::EnumVariant(span,name,type_id,variants,number_constant));
}
}

}
}

utility::panic(String("unreachable: should have found variant"));
}

}
}

utility::panic(String("unreachable: should have found enum"));
}
}

static ErrorOr<Array<String>> completions_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
const NonnullRefPtr<typechecker::Type> ty = ((program)->get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *ty;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((enum_).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((program)->get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((program)->get_variable(field));
TRY((((output).push(((field_var).name)))));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((structure).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
{
const typechecker::CheckedStruct structure = ((program)->get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((program)->get_variable(field));
TRY((((output).push(((field_var).name)))));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((structure).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!first)){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (output);
}
}

static ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>> enum_variant_fields(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedEnumVariant checked_enum_variant) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<Tuple<Optional<String>,typechecker::TypeId>>, ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>>>{
auto&& __jakt_match_variant = checked_enum_variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(({ Optional<Array<Tuple<Optional<String>,typechecker::TypeId>>> __jakt_var_163; {
Array<Tuple<Optional<String>,typechecker::TypeId>> output = (TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((program)->get_variable(field));
const Optional<String> var_name = (((variable).name));
const Tuple<Optional<String>,typechecker::TypeId> o = (Tuple{var_name, ((variable).type_id)});
TRY((((output).push(o))));
}

}
}

__jakt_var_163 = output; goto __jakt_label_163;

}
__jakt_label_163:; __jakt_var_163.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Array<Tuple<Optional<String>,typechecker::TypeId>>> __jakt_var_164; {
const Optional<String> string_none = JaktInternal::OptionalNone();
__jakt_var_164 = (TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({(Tuple{string_none, type_id})})))); goto __jakt_label_164;

}
__jakt_label_164:; __jakt_var_164.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static ErrorOr<String> get_enum_variant_signature_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const String name) {
{
const NonnullRefPtr<typechecker::Module> mod = ((((program)->modules))[((((type_id).module)).id)]);
{
ArrayIterator<typechecker::CheckedEnum> _magic = ((((mod)->enums)).iterator());
for (;;){
Optional<typechecker::CheckedEnum> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnum enum_ = (_magic_value.value());
{
if (((((enum_).type_id)).equals(type_id))){
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::NumberConstant>, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(({ Optional<Optional<typechecker::NumberConstant>> __jakt_var_165; {
__jakt_var_165 = ((expr)->to_number_constant(program)); goto __jakt_label_165;

}
__jakt_label_165:; __jakt_var_165.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Optional<typechecker::NumberConstant>> __jakt_var_166; {
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
__jakt_var_166 = none; goto __jakt_label_166;

}
__jakt_label_166:; __jakt_var_166.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,value))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

}
}

}
}

return (String(""));
}
}

static ErrorOr<String> get_type_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id) {
{
const typechecker::StructId array_struct_id = TRY((((program)->find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((program)->find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((program)->find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((program)->find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((program)->find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((program)->find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((program)->find_struct_in_prelude(String("WeakPtr")))));
const NonnullRefPtr<typechecker::Type> type = ((program)->get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("never"));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("usize"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("c_int"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("c_char"));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_167; {
Array<String> param_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((params).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::TypeId x = (_magic_value.value());
{
TRY((((param_names).push(TRY((((program)->type_name(x))))))));
}

}
}

const String return_type = TRY((((program)->type_name(return_type_id))));
__jakt_var_167 = TRY((String::formatted(String("function({}) -> {}"),utility::join(param_names,String(", ")),return_type))); goto __jakt_label_167;

}
__jakt_label_167:; __jakt_var_167.release_value(); }));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((String("raw ") + TRY((ide::get_type_signature(program,type_id)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_168; {
const typechecker::CheckedEnum enum_ = ((program)->get_enum(id));
__jakt_var_168 = ((JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((enum_).is_boxed));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("boxed "));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
 + String("enum ")) + ((enum_).name)); goto __jakt_label_168;

}
__jakt_label_168:; __jakt_var_168.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_169; {
const typechecker::CheckedStruct struct_ = ((program)->get_struct(id));
__jakt_var_169 = (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
default: {
{
utility::panic(String("unreachable: should've been struct"));
}
};/*case end*/
}/*switch end*/
}()
)) + ((struct_).name)); goto __jakt_label_169;

}
__jakt_label_169:; __jakt_var_169.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_170; {
const typechecker::CheckedStruct record = ((program)->get_struct(id));
String output = ((record).name);
(output += String("<"));
if ((!((args).is_empty()))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_170 = (output + String(">")); goto __jakt_label_170;

}
__jakt_label_170:; __jakt_var_170.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_171; {
const typechecker::CheckedEnum enum_ = ((program)->get_enum(id));
String output = String("");
if (((enum_).is_boxed)){
(output += String("boxed "));
}
(output += String("enum "));
(output += ((enum_).name));
(output += String("<"));
if ((!((args).is_empty()))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_171 = (output + String(">")); goto __jakt_label_171;

}
__jakt_label_171:; __jakt_var_171.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_172; {
if (((id).equals(array_struct_id))){
if (((args).is_empty())){
return (String("[]"));
}
return (TRY((String::formatted(String("[{}]"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(dictionary_struct_id))){
if ((((args).size()) < static_cast<size_t>(2ULL))){
return (String("[:]"));
}
return (TRY((String::formatted(String("[{}: {}]"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(1LL)]))))))));
}
if (((id).equals(optional_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{}?"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(range_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{}..{}"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))),TRY((((program)->type_name(((args)[static_cast<i64>(0LL)])))))))));
}
if (((id).equals(set_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{{{}}}"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(tuple_struct_id))){
String output = String("(");
if ((!((args).is_empty()))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
return ((output + String(")")));
}
if (((id).equals(weak_ptr_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("weak {}?"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
const typechecker::CheckedStruct record = ((program)->get_struct(id));
String output = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
utility::panic(String("unreachable: can't be an enum"));
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
utility::panic(String("unreachable: can't be an enum"));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(output += ((record).name));
(output += String("<"));
if ((!((args).is_empty()))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_172 = (output + String(">")); goto __jakt_label_172;

}
__jakt_label_172:; __jakt_var_172.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),TRY((((program)->type_name(type_id))))))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&mut {}"),TRY((((program)->type_name(type_id))))))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_scope(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::Scope> scope,const utility::Span span) {
{
{
DictionaryIterator<String,typechecker::VarId> _magic = ((((scope)->vars)).iterator());
for (;;){
Optional<Tuple<String,typechecker::VarId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::VarId> scope_var = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(((scope_var).get<1>())));
if (((((var).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((var).type_id))));
}
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::FunctionId> function_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(((function_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_function(program,checked_function,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::StructId> struct_id = (_magic_value.value());
{
const typechecker::CheckedStruct checked_struct = ((program)->get_struct(((struct_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_struct(program,checked_struct,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,typechecker::EnumId> enum_id = (_magic_value.value());
{
const typechecker::CheckedEnum checked_enum = ((program)->get_enum(((enum_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_enum(program,checked_enum,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(child))));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<String> get_constructor_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::FunctionId function_id) {
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
const typechecker::TypeId type_id = ((checked_function)->return_type_id);
const NonnullRefPtr<typechecker::Module> mod = ((((program)->modules))[((((type_id).module)).id)]);
{
ArrayIterator<typechecker::CheckedStruct> _magic = ((((mod)->structures)).iterator());
for (;;){
Optional<typechecker::CheckedStruct> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedStruct struct_ = (_magic_value.value());
{
if (((((struct_).type_id)).equals(type_id))){
String output = TRY((ide::get_type_signature(program,type_id)));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(", "));
}

const typechecker::CheckedVariable variable = ((program)->get_variable(field));
if (((variable).is_mutable)){
(output += String("mut "));
}
(output += TRY((String::formatted(String("{}: {}"),((variable).name),TRY((((program)->type_name(((variable).type_id)))))))));
}

}
}

(output += String(")"));
return (output);
}
}

}
}

return (String(""));
}
}

static ErrorOr<Array<String>> find_dot_completions(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Array<String>> __jakt_var_173; {
__jakt_var_173 = TRY((ide::completions_for_type_id(program,type_id))); goto __jakt_label_173;

}
__jakt_label_173:; __jakt_var_173.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Array<String>> __jakt_var_174; {
const typechecker::TypeId result_type_id = ((((program)->get_function(function_id)))->return_type_id);
__jakt_var_174 = TRY((ide::completions_for_type_id(program,result_type_id))); goto __jakt_label_174;

}
__jakt_label_174:; __jakt_var_174.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return ((TRY((Array<String>::create_with({})))));
}

}
}

static ErrorOr<utility::Span> find_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_function(function_id)))->name_span));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (span);
}

}
}

static ErrorOr<String> get_var_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const String name,const typechecker::TypeId var_type_id,const ide::Mutability mutability,const ide::VarType var_type,const ide::VarVisibility visibility,const Optional<typechecker::TypeId> struct_type_id) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = var_type;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarType::Variable>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_175; {
const String mut_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = mutability;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Mutability::Mutable>();
return JaktInternal::ExplicitValue(String("mut"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Mutability::Immutable>();
return JaktInternal::ExplicitValue(String("let"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = TRY((ide::get_type_signature(program,var_type_id)));
__jakt_var_175 = TRY((String::formatted(String("{} {}: {}"),mut_string,name,type_name))); goto __jakt_label_175;

}
__jakt_label_175:; __jakt_var_175.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarType::Field>();
{
String record_string = String("");
if (((struct_type_id).has_value())){
(record_string = TRY((ide::get_type_signature(program,(struct_type_id.value())))));
}
const String visibility_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = visibility;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarVisibility::Public>();
return JaktInternal::ExplicitValue(String("public "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarVisibility::Private>();
return JaktInternal::ExplicitValue(String("private "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = TRY((ide::get_type_signature(program,var_type_id)));
if ((record_string != String(""))){
return (TRY((String::formatted(String("{}\\n\\t{}{}: {}"),record_string,visibility_string,name,type_name))));
}
else {
return (TRY((String::formatted(String("{}{}: {}"),visibility_string,name,type_name))));
}

}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_expression(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedExpression> expr,const utility::Span span) {
{
const Optional<ide::Usage> none = JaktInternal::OptionalNone();
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typechecker::CheckedExpression> const& rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_176; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,lhs,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_176 = TRY((ide::find_span_in_expression(program,rhs,span))); goto __jakt_label_176;

}
__jakt_label_176:; __jakt_var_176.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& repeat = __jakt_match_value.repeat;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_177; {
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,val,span)));
if (((found).has_value())){
return (found);
}
}

}
}

if (((repeat).has_value())){
return (TRY((ide::find_span_in_expression(program,(repeat.value()),span))));
}
__jakt_var_177 = none; goto __jakt_label_177;

}
__jakt_label_177:; __jakt_var_177.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& call_span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_178; {
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,((arg).get<1>()),span)));
if (((found).has_value())){
return (found);
}
}

}
}

if ((((((call).function_id)).has_value()) && ((call_span).contains(span)))){
return ((typename ide::Usage::Call((((call).function_id).value()))));
}
__jakt_var_178 = none; goto __jakt_label_178;

}
__jakt_label_178:; __jakt_var_178.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_179; {
{
ArrayIterator<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((vals).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>> item = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> key = ((item).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> value = ((item).get<1>());
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,key,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_expression(program,value,span))));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_179 = none; goto __jakt_label_179;

}
__jakt_label_179:; __jakt_var_179.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_180; {
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_expression(program,index,span))));
if (((found).has_value())){
return (found);
}
__jakt_var_180 = none; goto __jakt_label_180;

}
__jakt_label_180:; __jakt_var_180.release_value(); }));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
utility::Span const& index_span = __jakt_match_value.span;
typechecker::TypeId const& known_type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_181; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
if (((index_span).contains(span))){
const typechecker::TypeId type_id = typechecker::expression_type(expr);
Optional<typechecker::TypeId> result_type = JaktInternal::OptionalNone();
if ((!((known_type_id).equals(typechecker::unknown_type_id())))){
(result_type = (known_type_id));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *((program)->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((program)->get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(field));
if ((index == ((var).name))){
return ((typename ide::Usage::Variable(((var).definition_span),index,result_type.value_or_lazy_evaluated([&] { return ((var).type_id); }),typename ide::Mutability::DoesNotApply(),typename ide::VarType::Field(),JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::VarVisibility, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = ((var).visibility);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Public>();
return JaktInternal::ExplicitValue(typename ide::VarVisibility::Public());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
return JaktInternal::ExplicitValue(typename ide::VarVisibility::Private());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();return JaktInternal::ExplicitValue(typename ide::VarVisibility::Restricted());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)),(type_id))));
}
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
__jakt_var_181 = none; goto __jakt_label_181;

}
__jakt_label_181:; __jakt_var_181.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_182; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_182 = TRY((ide::find_span_in_expression(program,index,span))); goto __jakt_label_182;

}
__jakt_label_182:; __jakt_var_182.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
utility::Span const& match_span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_183; {
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase match_case = (_magic_value.value());
{
const Optional<ide::Usage> found = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = match_case;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
size_t const& index = __jakt_match_value.index;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_184; {
if (((marker_span).contains(span))){
return ((TRY((ide::get_enum_variant_usage_from_type_id_and_name(program,subject_type_id,name)))));
}
__jakt_var_184 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_184;

}
__jakt_label_184:; __jakt_var_184.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expression;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_185; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_185 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_185;

}
__jakt_label_185:; __jakt_var_185.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((marker_span).contains(span)));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_186; {
const Set<String> all_cases = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Set<String>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *((program)->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_187; {
Set<String> names = (TRY((Set<String>::create_with_values({}))));
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((names).add(((variant).name())))));
}

}
}

__jakt_var_187 = names; goto __jakt_label_187;

}
__jakt_label_187:; __jakt_var_187.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& enum_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_188; {
Set<String> names = (TRY((Set<String>::create_with_values({}))));
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((names).add(((variant).name())))));
}

}
}

__jakt_var_188 = names; goto __jakt_label_188;

}
__jakt_label_188:; __jakt_var_188.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_189; {
__jakt_var_189 = (TRY((Set<String>::create_with_values({String("else (expression)")})))); goto __jakt_label_189;

}
__jakt_label_189:; __jakt_var_189.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
Set<String> remaining_cases = all_cases;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedMatchCase other_case = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = other_case;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
{
((remaining_cases).remove(name));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

__jakt_var_186 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((remaining_cases).is_empty()));
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_190; {
Array<String> cases_array = (TRY((Array<String>::create_with({}))));
TRY((((cases_array).ensure_capacity(((remaining_cases).size())))));
{
SetIterator<String> _magic = ((remaining_cases).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
TRY((((cases_array).push(name))));
}

}
}

__jakt_var_190 = (typename ide::Usage::NameSet(cases_array)); goto __jakt_label_190;

}
__jakt_label_190:; __jakt_var_190.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}()))
; goto __jakt_label_186;

}
__jakt_label_186:; __jakt_var_186.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}()))
);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_183 = TRY((ide::find_span_in_expression(program,expr,span))); goto __jakt_label_183;

}
__jakt_label_183:; __jakt_var_183.release_value(); }));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& method_span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
(found = TRY((ide::find_span_in_expression(program,((arg).get<1>()),span))));
if (((found).has_value())){
return (found);
}
}

}
}

if ((((((call).function_id)).has_value()) && ((method_span).contains(span)))){
return ((typename ide::Usage::Call((((call).function_id).value()))));
}
return (none);
}
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
utility::Span const& var_span = __jakt_match_value.span;
{
const Optional<typechecker::TypeId> none_type_id = JaktInternal::OptionalNone();
if (((var_span).contains(span))){
const ide::Mutability mutability = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::Mutability,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((var).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename ide::Mutability::Mutable());
}
else {
return JaktInternal::ExplicitValue(typename ide::Mutability::Immutable());
}
}()))
;
return ((typename ide::Usage::Variable(((var).definition_span),((var).name),((var).type_id),mutability,typename ide::VarType::Variable(),typename ide::VarVisibility::DoesNotApply(),none_type_id)));
}
return (none);
}
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();Array<typechecker::CheckedNamespace> const& namespaces = __jakt_match_value.namespaces;
typechecker::CheckedVariable const& var = __jakt_match_value.var;
utility::Span const& var_span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_191; {
if ((((var_span).contains(span)) && (!((namespaces).is_empty())))){
const typechecker::CheckedNamespace last_ns = (((namespaces).last()).value());
if (((((TRY((((program)->get_scope(((last_ns).scope))))))->namespace_name)).has_value())){
const Optional<typechecker::EnumId> enum_id = TRY((((program)->find_enum_in_scope(((last_ns).scope),((last_ns).name)))));
if (((enum_id).has_value())){
const typechecker::CheckedEnum enum_ = ((program)->get_enum((enum_id.value())));
return ((TRY((ide::get_enum_variant_usage_from_type_id_and_name(program,((enum_).type_id),((var).name))))));
}
}
}
__jakt_var_191 = none; goto __jakt_label_191;

}
__jakt_label_191:; __jakt_var_191.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(none);
};/*case end*/
}/*switch end*/
}()
)));
}
}

static ErrorOr<utility::Span> find_type_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_192; {
__jakt_var_192 = TRY((ide::find_type_definition_for_type_id(program,type_id,span))); goto __jakt_label_192;

}
__jakt_label_192:; __jakt_var_192.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_193; {
__jakt_var_193 = ((((program)->get_function(function_id)))->name_span); goto __jakt_label_193;

}
__jakt_label_193:; __jakt_var_193.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_194; {
__jakt_var_194 = TRY((ide::find_type_definition_for_type_id(program,type_id,span))); goto __jakt_label_194;

}
__jakt_label_194:; __jakt_var_194.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (span);
}

}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_block(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedBlock block,const utility::Span span) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,statement,span)));
if (((found).has_value())){
return (found);
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> iterator = ((((program)->modules)).iterator());
const Optional<NonnullRefPtr<typechecker::Module>> dummy = ((iterator).next());
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = iterator;
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL))))));
return (TRY((ide::find_span_in_scope(program,scope,span))));
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_function(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedFunction> checked_function,const utility::Span span) {
{
if (((((checked_function)->return_type_span)).has_value())){
if ((((((checked_function)->return_type_span).value())).contains(span))){
return ((typename ide::Usage::Typename(((checked_function)->return_type_id))));
}
}
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if (((((((param).variable)).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((((param).variable)).type_id))));
}
}

}
}

return (TRY((ide::find_span_in_block(program,((checked_function)->block),span))));
}
}

static ErrorOr<Optional<String>> find_typename_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<String>, ErrorOr<Optional<String>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
ide::Mutability const& mutability = __jakt_match_value.mutability;
ide::VarType const& var_type = __jakt_match_value.var_type;
ide::VarVisibility const& visibility = __jakt_match_value.visibility;
Optional<typechecker::TypeId> const& struct_type_id = __jakt_match_value.struct_type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_195; {
const String result = TRY((ide::get_var_signature(program,name,type_id,mutability,var_type,visibility,struct_type_id)));
__jakt_var_195 = (result); goto __jakt_label_195;

}
__jakt_label_195:; __jakt_var_195.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_196; {
const String result = TRY((ide::get_function_signature(program,function_id)));
__jakt_var_196 = (result); goto __jakt_label_196;

}
__jakt_label_196:; __jakt_var_196.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_197; {
const String result = TRY((ide::get_type_signature(program,type_id)));
__jakt_var_197 = (result); goto __jakt_label_197;

}
__jakt_label_197:; __jakt_var_197.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
Array<String> const& names = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_198; {
String output = String("");
bool first = true;
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String name = (_magic_value.value());
{
if ((!first)){
(output += String(" | "));
}
else {
(first = false);
}

(output += name);
}

}
}

__jakt_var_198 = (output); goto __jakt_label_198;

}
__jakt_label_198:; __jakt_var_198.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
Array<Tuple<Optional<String>,typechecker::TypeId>> const& variants = __jakt_match_value.variants;
Optional<typechecker::NumberConstant> const& number_constant = __jakt_match_value.number_constant;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_199; {
const String result = TRY((ide::get_enum_variant_signature(program,name,type_id,variants,number_constant)));
__jakt_var_199 = (result); goto __jakt_label_199;

}
__jakt_label_199:; __jakt_var_199.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (JaktInternal::OptionalNone());
}

}
}

static ErrorOr<utility::Span> find_type_definition_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const utility::Span span) {
{
const typechecker::StructId array_struct_id = TRY((((program)->find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((program)->find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((program)->find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((program)->find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((program)->find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((program)->find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((program)->find_struct_in_prelude(String("WeakPtr")))));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = *((program)->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_200; {
utility::Span output = span;
if ((((((((struct_id).equals(array_struct_id)) || ((struct_id).equals(optional_struct_id))) || ((struct_id).equals(range_struct_id))) || ((struct_id).equals(set_struct_id))) || ((struct_id).equals(tuple_struct_id))) || ((struct_id).equals(weak_ptr_struct_id)))){
(output = TRY((ide::find_type_definition_for_type_id(program,((args)[static_cast<i64>(0LL)]),span))));
}
else if (((struct_id).equals(dictionary_struct_id))){
(output = TRY((ide::find_type_definition_for_type_id(program,((args)[static_cast<i64>(1LL)]),span))));
}
else {
(output = ((((program)->get_struct(struct_id))).name_span));
}

__jakt_var_200 = output; goto __jakt_label_200;

}
__jakt_label_200:; __jakt_var_200.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_struct(struct_id))).name_span));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((program)->get_enum(id))).name_span));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_enum(id))).name_span));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((program)->get_struct(id))).name_span));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<String> get_enum_variant_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const String name,const typechecker::TypeId type_id,const Array<Tuple<Optional<String>,typechecker::TypeId>> variants,const Optional<typechecker::NumberConstant> number_constant) {
{
String output = TRY((ide::get_type_signature(program,type_id)));
(output += String("::"));
(output += name);
if ((!((variants).is_empty()))){
(output += String("("));
bool first = true;
{
ArrayIterator<Tuple<Optional<String>,typechecker::TypeId>> _magic = ((variants).iterator());
for (;;){
Optional<Tuple<Optional<String>,typechecker::TypeId>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
Tuple<Optional<String>,typechecker::TypeId> variant = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(", "));
}

if (((((variant).get<0>())).has_value())){
(output += (((variant).get<0>()).value()));
(output += String(": "));
}
(output += TRY((((program)->type_name(((variant).get<1>()))))));
}

}
}

(output += String(")"));
}
if (((number_constant).has_value())){
(output += String(" = "));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return (output);
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_enum(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedEnum checked_enum,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((checked_enum).scope_id)))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((checked_enum).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
utility::Span const& variant_span = __jakt_match_value.span;
{
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(field));
if (((((var).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((var).type_id))));
}
}

}
}

if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(span,name,((checked_enum).type_id),(TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))),JaktInternal::OptionalNone())));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
utility::Span const& variant_span = __jakt_match_value.span;
{
if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),TRY((ide::enum_variant_fields(program,variant))),JaktInternal::OptionalNone())));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
utility::Span const& variant_span = __jakt_match_value.span;
{
const Optional<typechecker::NumberConstant> number_constant_none = JaktInternal::OptionalNone();
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),(TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))),number_constant_none)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& variant_span = __jakt_match_value.span;
{
if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),TRY((ide::enum_variant_fields(program,variant))),((expr)->to_number_constant(program)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
return (usage);
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_statement(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedStatement> statement,const utility::Span span) {
{
const Optional<ide::Usage> none = JaktInternal::OptionalNone();
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();NonnullRefPtr<typechecker::CheckedStatement> const& statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_statement(program,statement,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_201; {
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,condition,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_block(program,then_block,span))));
if (((found).has_value())){
return (found);
}
if (((else_statement).has_value())){
return (TRY((ide::find_span_in_statement(program,(else_statement.value()),span))));
}
__jakt_var_201 = none; goto __jakt_label_201;

}
__jakt_label_201:; __jakt_var_201.release_value(); }));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_202; {
const Optional<ide::Usage> output = JaktInternal::OptionalNone();
__jakt_var_202 = output; goto __jakt_label_202;

}
__jakt_label_202:; __jakt_var_202.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,(val.value()),span))));
}
else {
return JaktInternal::ExplicitValue(none);
}
}()))
);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Try>();NonnullRefPtr<typechecker::CheckedStatement> const& stmt = __jakt_match_value.stmt;
String const& error_name = __jakt_match_value.error_name;
typechecker::CheckedBlock const& catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_203; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,stmt,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_203 = TRY((ide::find_span_in_block(program,catch_block,span))); goto __jakt_label_203;

}
__jakt_label_203:; __jakt_var_203.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();typechecker::VarId const& var_id = __jakt_match_value.var_id;
NonnullRefPtr<typechecker::CheckedExpression> const& init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_204; {
const typechecker::CheckedVariable checked_var = ((program)->get_variable(var_id));
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,init,span)));
if (((found).has_value())){
return (found);
}
if (((((checked_var).type_span)).has_value())){
const utility::Span type_span = (((checked_var).type_span).value());
if (((type_span).contains(span))){
return ((typename ide::Usage::Typename(((checked_var).type_id))));
}
}
if (((((checked_var).definition_span)).contains(span))){
const ide::Mutability mutability = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::Mutability,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((checked_var).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename ide::Mutability::Mutable());
}
else {
return JaktInternal::ExplicitValue(typename ide::Mutability::Immutable());
}
}()))
;
return ((typename ide::Usage::Variable(((checked_var).definition_span),((checked_var).name),((checked_var).type_id),mutability,typename ide::VarType::Variable(),typename ide::VarVisibility::DoesNotApply(),JaktInternal::OptionalNone())));
}
__jakt_var_204 = none; goto __jakt_label_204;

}
__jakt_label_204:; __jakt_var_204.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_205; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,condition,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_205 = TRY((ide::find_span_in_block(program,block,span))); goto __jakt_label_205;

}
__jakt_label_205:; __jakt_var_205.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();Array<NonnullRefPtr<typechecker::CheckedStatement>> const& vars = __jakt_match_value.vars;
NonnullRefPtr<typechecker::CheckedStatement> const& var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_206; {
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((vars).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> var = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,var,span)));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_206 = TRY((ide::find_span_in_statement(program,var_decl,span))); goto __jakt_label_206;

}
__jakt_label_206:; __jakt_var_206.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_struct(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedStruct checked_struct,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((checked_struct).scope_id)))));
{
ArrayIterator<typechecker::VarId> _magic = ((((checked_struct).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((program)->get_variable(field));
if (((((variable).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((variable).type_id))));
}
}

}
}

const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
return (usage);
}
}

static ErrorOr<String> get_function_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::FunctionId function_id) {
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = ((checked_function)->type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::ImplicitEnumConstructor>();
{
const typechecker::TypeId type_id = ((checked_function)->return_type_id);
const String name = ((checked_function)->name);
return (TRY((ide::get_enum_variant_signature_from_type_id_and_name(program,type_id,name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::ImplicitConstructor>();
{
return (TRY((ide::get_constructor_signature(program,function_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
String generic_parameters = String("");
bool is_first_param = true;
if ((!((((checked_function)->generic_params)).is_empty()))){
(generic_parameters += String("<"));
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((checked_function)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::FunctionGenericParameter parameter = (_magic_value.value());
{
const String generic_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = parameter;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_207; {
__jakt_var_207 = TRY((((program)->type_name(type_id)))); goto __jakt_label_207;

}
__jakt_label_207:; __jakt_var_207.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_208; {
__jakt_var_208 = TRY((((program)->type_name(type_id)))); goto __jakt_label_208;

}
__jakt_label_208:; __jakt_var_208.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const String separator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_first_param);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String(", "));
}
}()))
;
(generic_parameters += TRY((String::formatted(String("{}{}"),separator,generic_type))));
(is_first_param = false);
}

}
}

(generic_parameters += String(">"));
}
String parameters = String("");
(is_first_param = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const String anon_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((param).requires_label));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String("anon "));
}
}()))
;
const String is_mutable = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((param).variable)).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("mut "));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
String variable_type = TRY((((program)->type_name(((((param).variable)).type_id)))));
if ((variable_type != String("void"))){
(variable_type = (String(": ") + variable_type));
}
else {
(variable_type = String(""));
}

const String separator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_first_param);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String(", "));
}
}()))
;
(parameters += TRY((String::formatted(String("{}{}{}{}{}"),separator,anon_value,is_mutable,((((param).variable)).name),variable_type))));
(is_first_param = false);
}

}
}

const String throws_str = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((checked_function)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(" throws"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
String returns = TRY((((program)->type_name(((checked_function)->return_type_id)))));
if ((returns != String("void"))){
(returns = (String(" -> ") + returns));
}
else {
(returns = String(""));
}

return (TRY((String::formatted(String("function {}{}({}){}{}"),((checked_function)->name),generic_parameters,parameters,throws_str,returns))));
}
}

}
static ErrorOr<void> write_to_file(const String data,const String output_filename) {
{
NonnullRefPtr<File> outfile = TRY((File::open_for_writing(output_filename)));
Array<u8> bytes = (TRY((Array<u8>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((data).length()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((bytes).push(((data).byte_at(i))))));
}

}
}

TRY((((outfile)->write(bytes))));
}
return {};
}

ErrorOr<int> main(const Array<String> args) {
{
if ((((args).size()) <= static_cast<size_t>(1ULL))){
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
utility::ArgsParser args_parser = TRY((utility::ArgsParser::from_args(args)));
if (TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-h"), String("--help")}))))))))){
outln(String("{}\n"),usage());
outln(String("{}"),help());
return (static_cast<i64>(0LL));
}
if (TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-v"), String("--version")}))))))))){
outln(String("unreleased"));
return (static_cast<i64>(0LL));
}
const bool optimize = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-O")}))))))));
const bool lexer_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dl")}))))))));
const bool parser_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dp")}))))))));
const bool typechecker_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dt")}))))))));
const bool build_executable = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-b")}))))))));
const bool run_executable = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-r")}))))))));
const bool codegen_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-d")}))))))));
const bool debug_print = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--debug-print")}))))))));
const bool prettify_cpp_source = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--prettify-cpp-source")}))))))));
const bool json_errors = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-j"), String("--json-errors")}))))))));
const bool dump_type_hints = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-H"), String("--type-hints")}))))))));
const bool dump_try_hints = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--try-hints")}))))))));
const bool check_only = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-c"), String("--check-only")}))))))));
const bool write_source_to_file = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-S"), String("--emit-cpp-source-only")}))))))));
const String clang_format_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-F"), String("--clang-format-path")})))))))).value_or_lazy_evaluated([&] { return String("clang-format"); });
const String runtime_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-R"), String("--runtime-path")})))))))).value_or_lazy_evaluated([&] { return String("runtime"); });
const String binary_dir = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-B"), String("--binary-dir")})))))))).value_or_lazy_evaluated([&] { return String("build"); });
const Optional<String> dot_clang_format_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-D"), String("--dot-clang-format-path")}))))))));
const String cxx_compiler_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-C"), String("--cxx-compiler-path")})))))))).value_or_lazy_evaluated([&] { return String("clang++"); });
const Array<String> extra_include_paths = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-I")}))))))));
const Array<String> extra_lib_paths = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-L")}))))))));
const Array<String> extra_link_libs = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-l")}))))))));
const Optional<String> set_output_filename = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-o"), String("--output-filename")}))))))));
const Optional<String> goto_def = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-g"), String("--goto-def")}))))))));
const Optional<String> goto_type_def = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-t"), String("--goto-type-def")}))))))));
const Optional<String> hover = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-e"), String("--hover")}))))))));
const Optional<String> completions = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-m"), String("--completions")}))))))));
const Array<String> positional_arguments = TRY((((args_parser).remaining_arguments())));
Optional<String> file_name = JaktInternal::OptionalNone();
bool first_arg = true;
{
ArrayIterator<String> _magic = ((positional_arguments).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String arg = (_magic_value.value());
{
if (first_arg){
(first_arg = false);
continue;
}
if (((file_name).has_value())){
warnln(String("you can only pass one source file"));
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
else {
(file_name = arg);
}

}

}
}

if ((!((file_name).has_value()))){
warnln(String("you must pass a source file"));
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
const NonnullRefPtr<utility::FilePath> file_path = TRY((utility::FilePath::make((file_name.value()))));
Array<error::JaktError> errors = (TRY((Array<error::JaktError>::create_with({}))));
NonnullRefPtr<compiler::Compiler> compiler = TRY((compiler::Compiler::create((TRY((Array<NonnullRefPtr<utility::FilePath>>::create_with({})))),(TRY((Dictionary<String, utility::FileId>::create_with_entries({})))),(TRY((Array<error::JaktError>::create_with({})))),JaktInternal::OptionalNone(),(TRY((Array<u8>::create_with({})))),lexer_debug,parser_debug,false,debug_print,extra_include_paths,json_errors,dump_type_hints,dump_try_hints)));
TRY((((compiler)->load_prelude())));
const utility::FileId main_file_id = TRY((((compiler)->get_file_id_or_register(file_path))));
const bool file_is_set = ((compiler)->set_current_file(main_file_id));
if ((!file_is_set)){
return (static_cast<i64>(1LL));
}
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(compiler)));
if (lexer_debug){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(compiler,tokens)));
if (parser_debug){
outln(String("{:#}"),parsed_namespace);
}
const NonnullRefPtr<typechecker::CheckedProgram> checked_program = TRY((typechecker::Typechecker::typecheck(compiler,parsed_namespace)));
if (((goto_def).has_value())){
const size_t index = (infallible_integer_cast<size_t>(((((goto_def.value())).to_uint()).value())));
const utility::Span result = TRY((ide::find_definition_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if ((((((result).file_id)).id) == static_cast<size_t>(1ULL))){
outln(String("{{\"start\": {}, \"end\": {}}}"),((result).start),((result).end));
}
else {
const Optional<NonnullRefPtr<utility::FilePath>> file_path = TRY((((compiler)->get_file_path(((result).file_id)))));
outln(String("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}"),((result).start),((result).end),(((file_path.value()))->path));
}

return (static_cast<i64>(0LL));
}
if (((goto_type_def).has_value())){
const size_t index = (infallible_integer_cast<size_t>(((((goto_type_def.value())).to_uint()).value())));
const utility::Span result = TRY((ide::find_type_definition_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if ((((((result).file_id)).id) == static_cast<size_t>(1ULL))){
outln(String("{{\"start\": {}, \"end\": {}}}"),((result).start),((result).end));
}
else {
const Optional<NonnullRefPtr<utility::FilePath>> file_path = TRY((((compiler)->get_file_path(((result).file_id)))));
outln(String("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}"),((result).start),((result).end),(((file_path.value()))->path));
}

return (static_cast<i64>(0LL));
}
if (((hover).has_value())){
const size_t index = (infallible_integer_cast<size_t>(((((hover.value())).to_uint()).value())));
const Optional<String> result = TRY((ide::find_typename_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if (((result).has_value())){
outln(String("{{\"hover\": \"{}\"}}"),(result.value()));
}
return (static_cast<i64>(0LL));
}
if (((completions).has_value())){
const size_t index = (infallible_integer_cast<size_t>(((((completions.value())).to_uint()).value())));
const Array<String> result = TRY((ide::find_dot_completions(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
out(String("{{\"completions\": ["));
bool first = true;
{
ArrayIterator<String> _magic = ((result).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String completion = (_magic_value.value());
{
if ((!first)){
out(String(", "));
}
else {
(first = false);
}

out(String("\"{}\""),completion);
}

}
}

outln(String("]}}"));
return (static_cast<i64>(0LL));
}
if (typechecker_debug){
outln(String("{:#}"),checked_program);
}
TRY((((compiler)->print_errors())));
if ((!((((compiler)->errors)).is_empty()))){
return (static_cast<i64>(1LL));
}
if (check_only){
return (static_cast<i64>(0LL));
}
const String output = TRY((codegen::CodeGenerator::generate(compiler,checked_program,codegen_debug)));
String cpp_filename = String("");
String output_filename = String("");
if (((write_source_to_file || build_executable) || run_executable)){
if (((set_output_filename).has_value())){
(cpp_filename = (((binary_dir + String("/")) + (set_output_filename.value())) + String(".cpp")));
(output_filename = ((binary_dir + String("/")) + (set_output_filename.value())));
}
else {
const String basename_without_extension = TRY((((TRY((((file_path)->basename())))).substring(static_cast<size_t>(0ULL),(JaktInternal::checked_sub<size_t>(((TRY((((file_path)->basename())))).length()),static_cast<size_t>(5ULL)))))));
(cpp_filename = (((binary_dir + String("/")) + basename_without_extension) + String(".cpp")));
(output_filename = ((binary_dir + String("/")) + basename_without_extension));
}

TRY((write_to_file(output,cpp_filename)));
if (prettify_cpp_source){
String command = ((clang_format_path + String(" -i ")) + cpp_filename);
if (((dot_clang_format_path).has_value())){
(command += (String(" --style=file:") + (dot_clang_format_path.value())));
}
system(((command).c_string()));
}
}
else {
outln(String("{}"),output);
}

if ((build_executable || run_executable)){
TRY((run_compiler(cxx_compiler_path,cpp_filename,output_filename,runtime_path,extra_include_paths,extra_lib_paths,extra_link_libs,optimize)));
if (run_executable){
system(((output_filename).c_string()));
}
}
}
return 0;
}

static ErrorOr<void> run_compiler(const String cxx_compiler_path,const String cpp_filename,const String output_filename,const String runtime_path,const Array<String> extra_include_paths,const Array<String> extra_lib_paths,const Array<String> extra_link_libs,const bool optimize) {
{
NonnullRefPtr<utility::FilePath> file_path = TRY((utility::FilePath::create(cxx_compiler_path)));
String color_flag = String("-fcolor-diagnostics");
Array<String> extra_flags = (TRY((Array<String>::create_with({}))));
if ((TRY((((file_path)->basename()))) == String("g++"))){
(color_flag = String("-fdiagnostics-color=always"));
TRY((((extra_flags).push(String("-Wno-literal-suffix")))));
}
Array<String> compile_args = (TRY((Array<String>::create_with({cxx_compiler_path, color_flag, String("-std=c++20"), String("-Wno-unknown-warning-option"), String("-Wno-trigraphs"), String("-Wno-parentheses-equality"), String("-Wno-unqualified-std-cast-call"), String("-Wno-user-defined-literals"), String("-Wno-deprecated-declarations")}))));
if (optimize){
TRY((((compile_args).push(String("-O3")))));
}
if ((!((extra_flags).is_empty()))){
{
ArrayIterator<String> _magic = ((extra_flags).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String flag = (_magic_value.value());
{
TRY((((compile_args).push(flag))));
}

}
}

}
TRY((((compile_args).push(String("-I")))));
TRY((((compile_args).push(runtime_path))));
TRY((((compile_args).push(String("-o")))));
TRY((((compile_args).push(output_filename))));
TRY((((compile_args).push(cpp_filename))));
if ((!((extra_include_paths).is_empty()))){
TRY((((compile_args).add_capacity((JaktInternal::checked_mul<size_t>(((extra_include_paths).size()),static_cast<size_t>(2ULL)))))));
{
ArrayIterator<String> _magic = ((extra_include_paths).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push(String("-I")))));
TRY((((compile_args).push(path))));
}

}
}

}
if ((!((extra_lib_paths).is_empty()))){
TRY((((compile_args).add_capacity((JaktInternal::checked_mul<size_t>(((extra_lib_paths).size()),static_cast<size_t>(2ULL)))))));
{
ArrayIterator<String> _magic = ((extra_lib_paths).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push(String("-L")))));
TRY((((compile_args).push(path))));
}

}
}

}
if ((!((extra_link_libs).is_empty()))){
TRY((((compile_args).add_capacity(((extra_link_libs).size())))));
{
ArrayIterator<String> _magic = ((extra_link_libs).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push((String("-l") + path)))));
}

}
}

}
String command = String("");
{
ArrayIterator<String> _magic = ((compile_args).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!((_magic_value).has_value()))){
break;
}
String compile_arg = (_magic_value.value());
{
(command += compile_arg);
(command += String(" "));
}

}
}

system(((command).c_string()));
}
return {};
}

static String usage() {
{
return (String("usage: jakt [-h] [OPTIONS] <filename>"));
}
}

static String help() {
{
String output = String("Flags:\n");
(output += String("  -h,--help\t\tPrint this help and exit.\n"));
(output += String("  -O\t\tBuild an optimized executable.\n"));
(output += String("  -dl\t\tPrint debug info for the lexer.\n"));
(output += String("  -dp\t\tPrint debug info for the parser.\n"));
(output += String("  -dt\t\tPrint debug info for the typechecker.\n"));
(output += String("  -b\t\tBuild an executable file.\n"));
(output += String("  -r\t\tBuild and run an executable file.\n"));
(output += String("  -d\t\tInsert debug statement spans in generated C++ code.\n"));
(output += String("  --debug-print\t\tOutput debug print.\n"));
(output += String("  --prettify-cpp-source\t\tRun emitted C++ source through clang-format.\n"));
(output += String("  -S,--emit-cpp-source-only\t\tWrite the C++ source to file, even when not building/\n"));
(output += String("  -c,--check-only\t\tOnly check the code for errors.\n"));
(output += String("  -j,--json-errors\t\tEmit machine-readable (JSON) errors.\n"));
(output += String("  -H,--type-hints\t\tEmit machine-readable type hints (for IDE integration).\n"));
(output += String("  --try-hints\t\tEmit machine-readable try hints (for IDE integration).\n"));
(output += String("\nOptions:\n"));
(output += String("  -F,--clang-format-path PATH\t\tPath to clang-format executable.\n\t\tDefaults to clang-format\n"));
(output += String("  -D,--dot-clang-format-path PATH\t\tPath to the .clang-format file to use.\n\t\tDefaults to none, invoking clangs default .clang-format file handling.\n"));
(output += String("  -R,--runtime-path PATH\t\tPath of the Jakt runtime headers.\n\t\tDefaults to $PWD/runtime.\n"));
(output += String("  -B,--binary-dir PATH\t\tOutput directory for compiled files.\n\t\tDefaults to $PWD/build.\n"));
(output += String("  -C,--cxx-compiler-path PATH\t\tPath of the C++ compiler to use when compiling the generated sources.\n\t\tDefaults to clang++.\n"));
(output += String("  -I PATH\t\tAdd PATH to compiler's include list. Can be specified multiple times.\n"));
(output += String("  -L PATH\t\tAdd PATH to linker's search list. Can be specified multiple times.\n"));
(output += String("  -l,--link-with LIB\t\tLink executable with LIB. Can be specified multiple times.\n"));
(output += String("  -o,--output-filename FILE\t\tName of the output C++ file and binary.\n\t\tDefaults to the input-filename.\n"));
(output += String("  -g,--goto-def INDEX\t\tReturn the span for the definition at index.\n"));
(output += String("  -t,--goto-type-def INDEX\t\tReturn the span for the type definition at index.\n"));
(output += String("  -e,--hover INDEX                  Return the type of element at index.\n"));
(output += String("  -m,--completions INDEX            Return dot completions at index.\n"));
return (output);
}
}

template<>struct Formatter<utility::FileId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::FileId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::ArgsParser> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::ArgsParser const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::Span> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::Span const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::FilePath> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::FilePath const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<error::MessageSeverity> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, error::MessageSeverity const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<error::JaktError> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, error::JaktError const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<prelude::JaktPrelude> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, prelude::JaktPrelude const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<compiler::Compiler> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, compiler::Compiler const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::LiteralSuffix> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::LiteralSuffix const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::NumericConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::NumericConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::Token> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::Token const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::Lexer> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::Lexer const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::DefinitionLinkage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::DefinitionLinkage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::FunctionType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::FunctionType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::Visibility> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::Visibility const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedBlock> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedBlock const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::FunctionLinkage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::FunctionLinkage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedFunction> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedFunction const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::TypeCast> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::TypeCast const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::RecordType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::RecordType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedRecord> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedRecord const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedCall> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedCall const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::UnaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::UnaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::BinaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::BinaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::EnumVariantPatternArgument> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::EnumVariantPatternArgument const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedExpression> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedExpression const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedVarDecl> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedVarDecl const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedStatement> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedStatement const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchBody> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchBody const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchPattern> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchPattern const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::Parser> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::Parser const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ImportName> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ImportName const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedModuleImport> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedModuleImport const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedField> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedField const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMethod> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMethod const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchCase> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchCase const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedVariable> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedVariable const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedGenericParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedGenericParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedExternImport> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedExternImport const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedCapture> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedCapture const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ValueEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ValueEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::SumEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::SumEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ModuleId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ModuleId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Module> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Module const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::NumberConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::NumberConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::EnumId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::EnumId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::TypeId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::TypeId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ScopeId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ScopeId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::SafetyMode> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::SafetyMode const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::StructId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::StructId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::BlockControlFlow> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::BlockControlFlow const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedBlock> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedBlock const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedMatchBody> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedMatchBody const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedStruct> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedStruct const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedVariable> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedVariable const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedTypeCast> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedTypeCast const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedUnaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedUnaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::FunctionId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::FunctionId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedCall> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedCall const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::LoadedModule> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::LoadedModule const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedMatchCase> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedMatchCase const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::StructOrEnumId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::StructOrEnumId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedProgram> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedProgram const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Typechecker> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Typechecker const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnum> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnum const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedVarDecl> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedVarDecl const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedCapture> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedCapture const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::VarId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::VarId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedStatement> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedStatement const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedNumericConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedNumericConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnumVariantBinding> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnumVariantBinding const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedExpression> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedExpression const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Type> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Type const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Scope> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Scope const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedFunction> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedFunction const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ResolvedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ResolvedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::FunctionGenericParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::FunctionGenericParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::CodegenDebugInfo> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::CodegenDebugInfo const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::AllowedControlExits> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::AllowedControlExits const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::ControlFlowState> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::ControlFlowState const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::CodeGenerator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::CodeGenerator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::LineSpan> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::LineSpan const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::VarVisibility> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::VarVisibility const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::Mutability> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::Mutability const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::VarType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::VarType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::Usage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::Usage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
} // namespace Jakt

