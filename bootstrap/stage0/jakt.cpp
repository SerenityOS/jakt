#include <lib.h>
#include <stdio.h>
namespace Jakt {
namespace utility {
struct Span;
struct FileId;
class FilePath;
struct ArgsParser;
static ErrorOr<Array<String>> append_to_each(const Array<String> strings, const String suffix);

static String join(const Array<String> strings, const String separator);

template <typename T>
static ErrorOr<void> extend_array(Array<T> target, const Array<T> extend_with);

[[noreturn]] static void panic(const String message);

static ErrorOr<String> escape_for_quotes(const String s);

static ErrorOr<Array<String>> prepend_to_each(const Array<String> strings, const String prefix);

static void todo(const String message);

}
namespace error {
namespace JaktError_Details {
struct Message;
struct MessageWithHint;
}
struct JaktError;

namespace MessageSeverity_Details {
struct Hint;
struct Error;
}
struct MessageSeverity;

static ErrorOr<void> print_error_json(const String file_name, const error::JaktError error);

static ErrorOr<Array<Tuple<size_t,size_t>>> gather_line_spans(const Array<u8> file_contents);

static ErrorOr<void> display_message_with_span(const error::MessageSeverity severity, const String file_name, const Optional<Array<u8>> contents, const String message, const utility::Span span);

static ErrorOr<void> print_source_line(const error::MessageSeverity severity, const Array<u8> file_contents, const Tuple<size_t,size_t> file_span, const utility::Span error_span, const size_t line_number, const size_t largest_line_number);

static ErrorOr<void> display_message_with_span_json(const error::MessageSeverity severity, const String file_name, const String message, const utility::Span span);

static ErrorOr<void> print_error(const String file_name, const Optional<Array<u8>> file_contents, const error::JaktError error);

}
namespace compiler {
class Compiler;
}
namespace lexer {
struct Lexer;
namespace LiteralSuffix_Details {
struct None;
struct UZ;
struct U8;
struct U16;
struct U32;
struct U64;
struct I8;
struct I16;
struct I32;
struct I64;
struct F32;
struct F64;
}
struct LiteralSuffix;

namespace NumericConstant_Details {
struct I8;
struct I16;
struct I32;
struct I64;
struct U8;
struct U16;
struct U32;
struct U64;
struct USize;
struct F32;
struct F64;
}
struct NumericConstant;

namespace Token_Details {
struct SingleQuotedString;
struct SingleQuotedByteString;
struct QuotedString;
struct Number;
struct Identifier;
struct Semicolon;
struct Colon;
struct ColonColon;
struct LParen;
struct RParen;
struct LCurly;
struct RCurly;
struct LSquare;
struct RSquare;
struct PercentSign;
struct Plus;
struct Minus;
struct Equal;
struct PlusEqual;
struct PlusPlus;
struct MinusEqual;
struct MinusMinus;
struct AsteriskEqual;
struct ForwardSlashEqual;
struct PercentSignEqual;
struct NotEqual;
struct DoubleEqual;
struct GreaterThan;
struct GreaterThanOrEqual;
struct LessThan;
struct LessThanOrEqual;
struct LeftArithmeticShift;
struct LeftShift;
struct LeftShiftEqual;
struct RightShift;
struct RightArithmeticShift;
struct RightShiftEqual;
struct Asterisk;
struct Ampersand;
struct AmpersandEqual;
struct Pipe;
struct PipeEqual;
struct Caret;
struct CaretEqual;
struct Dollar;
struct Tilde;
struct ForwardSlash;
struct ExclamationPoint;
struct QuestionMark;
struct QuestionMarkQuestionMark;
struct QuestionMarkQuestionMarkEqual;
struct Comma;
struct Dot;
struct DotDot;
struct Eol;
struct Eof;
struct FatArrow;
struct Arrow;
struct And;
struct Anon;
struct As;
struct Boxed;
struct Break;
struct Catch;
struct Class;
struct Continue;
struct Cpp;
struct Defer;
struct Else;
struct Enum;
struct Extern;
struct False;
struct For;
struct Function;
struct Comptime;
struct If;
struct Import;
struct In;
struct Is;
struct Let;
struct Loop;
struct Match;
struct Mut;
struct Namespace;
struct Not;
struct Or;
struct Private;
struct Public;
struct Raw;
struct Return;
struct Restricted;
struct Struct;
struct This;
struct Throw;
struct Throws;
struct True;
struct Try;
struct Unsafe;
struct Weak;
struct While;
struct Yield;
struct Guard;
struct Garbage;
}
struct Token;

static bool is_ascii_alphanumeric(const u8 c);

static bool is_ascii_alpha(const u8 c);

static f32 f64_to_f32(const f64 number);

static ErrorOr<lexer::Token> make_float_token(const f64 number, const lexer::LiteralSuffix suffix, const utility::Span span);

static bool is_ascii_octdigit(const u8 c);

static bool is_ascii_hexdigit(const u8 c);

template <typename T>
static T u64_to_float(const u64 number);

static bool is_ascii_digit(const u8 c);

}
namespace parser {
struct ParsedGenericParameter;
struct EnumVariantPatternArgument;
struct ParsedBlock;
struct ParsedRecord;
struct ParsedVarDecl;
struct ParsedFunction;
struct ParsedExternImport;
struct ParsedModuleImport;
struct ParsedVariable;
struct SumEnumVariant;
struct ParsedMatchCase;
struct ImportName;
struct Parser;
struct ParsedCall;
struct ParsedNamespace;
struct ParsedMethod;
struct ParsedField;
struct ParsedParameter;
struct ValueEnumVariant;
namespace ParsedMatchBody_Details {
struct Expression;
struct Block;
}
struct ParsedMatchBody;

namespace ParsedType_Details {
struct Name;
struct NamespacedName;
struct GenericType;
struct JaktArray;
struct Dictionary;
struct JaktTuple;
struct Set;
struct Optional;
struct Reference;
struct MutableReference;
struct RawPtr;
struct WeakPtr;
struct Function;
struct Empty;
}
struct ParsedType;

namespace ParsedExpression_Details {
struct Boolean;
struct NumericConstant;
struct QuotedString;
struct SingleQuotedString;
struct SingleQuotedByteString;
struct Call;
struct MethodCall;
struct IndexedTuple;
struct IndexedStruct;
struct Var;
struct IndexedExpression;
struct IndexedRangeExpression;
struct UnaryOp;
struct BinaryOp;
struct Operator;
struct OptionalSome;
struct OptionalNone;
struct JaktArray;
struct JaktDictionary;
struct Set;
struct JaktTuple;
struct Range;
struct ForcedUnwrap;
struct Match;
struct EnumVariantArg;
struct NamespacedVar;
struct Function;
struct Try;
struct TryBlock;
struct Garbage;
}
struct ParsedExpression;

namespace TypeCast_Details {
struct Fallible;
struct Infallible;
}
struct TypeCast;

namespace DefinitionLinkage_Details {
struct Internal;
struct External;
}
struct DefinitionLinkage;

namespace RecordType_Details {
struct Struct;
struct Class;
struct ValueEnum;
struct SumEnum;
struct Garbage;
}
struct RecordType;

namespace ParsedCapture_Details {
struct ByValue;
struct ByReference;
struct ByMutableReference;
}
struct ParsedCapture;

namespace BinaryOperator_Details {
struct Add;
struct Subtract;
struct Multiply;
struct Divide;
struct Modulo;
struct LessThan;
struct LessThanOrEqual;
struct GreaterThan;
struct GreaterThanOrEqual;
struct Equal;
struct NotEqual;
struct BitwiseAnd;
struct BitwiseXor;
struct BitwiseOr;
struct BitwiseLeftShift;
struct BitwiseRightShift;
struct ArithmeticLeftShift;
struct ArithmeticRightShift;
struct LogicalAnd;
struct LogicalOr;
struct NoneCoalescing;
struct Assign;
struct BitwiseAndAssign;
struct BitwiseOrAssign;
struct BitwiseXorAssign;
struct BitwiseLeftShiftAssign;
struct BitwiseRightShiftAssign;
struct AddAssign;
struct SubtractAssign;
struct MultiplyAssign;
struct ModuloAssign;
struct DivideAssign;
struct NoneCoalescingAssign;
struct Garbage;
}
struct BinaryOperator;

namespace Visibility_Details {
struct Public;
struct Private;
struct Restricted;
}
struct Visibility;

namespace FunctionType_Details {
struct Normal;
struct ImplicitConstructor;
struct ImplicitEnumConstructor;
struct ExternalClassConstructor;
}
struct FunctionType;

namespace ParsedStatement_Details {
struct Expression;
struct Defer;
struct UnsafeBlock;
struct DestructuringAssignment;
struct VarDecl;
struct If;
struct Block;
struct Loop;
struct While;
struct For;
struct Break;
struct Continue;
struct Return;
struct Throw;
struct Yield;
struct InlineCpp;
struct Guard;
struct Garbage;
}
struct ParsedStatement;

namespace ParsedMatchPattern_Details {
struct EnumVariant;
struct Expression;
struct CatchAll;
}
struct ParsedMatchPattern;

namespace FunctionLinkage_Details {
struct Internal;
struct External;
}
struct FunctionLinkage;

namespace UnaryOperator_Details {
struct PreIncrement;
struct PostIncrement;
struct PreDecrement;
struct PostDecrement;
struct Negate;
struct Dereference;
struct RawAddress;
struct Reference;
struct MutableReference;
struct LogicalNot;
struct BitwiseNot;
struct TypeCast;
struct Is;
struct IsEnumVariant;
}
struct UnaryOperator;

static ErrorOr<utility::Span> merge_spans(const utility::Span start, const utility::Span end);

static bool binary_operator_equals(const parser::BinaryOperator lhs_op, const parser::BinaryOperator rhs_op);

static bool unary_operator_equals(const parser::UnaryOperator lhs_op, const parser::UnaryOperator rhs_op);

static bool parsed_statement_equals(const NonnullRefPtr<parser::ParsedStatement> lhs_statement, const NonnullRefPtr<parser::ParsedStatement> rhs_statement);

static bool parsed_var_decl_equals(const parser::ParsedVarDecl lhs_var_decl, const parser::ParsedVarDecl rhs_var_decl);

static bool parsed_call_equals(const parser::ParsedCall lhs_parsed_call, const parser::ParsedCall rhs_parsed_call);

static bool parsed_expression_equals(const NonnullRefPtr<parser::ParsedExpression> lhs_expression, const NonnullRefPtr<parser::ParsedExpression> rhs_expression);

static bool parsed_block_equals(const parser::ParsedBlock lhs_block, const parser::ParsedBlock rhs_block);

}
namespace typechecker {
struct CheckedStruct;
struct Interpreter;
struct CheckedVariable;
class CheckedProgram;
struct Value;
struct CheckedParameter;
struct CheckedCall;
struct CheckedNamespace;
struct CheckedBlock;
struct FunctionId;
class Module;
struct VarId;
class CheckedFunction;
struct EnumId;
struct StructId;
struct ScopeId;
struct LoadedModule;
struct Typechecker;
struct ResolvedNamespace;
struct CheckedVarDecl;
class Scope;
struct TypeId;
class InterpreterScope;
struct CheckedEnum;
struct ModuleId;
struct CheckedEnumVariantBinding;
namespace StatementResult_Details {
struct Return;
struct Throw;
struct Continue;
struct Break;
struct JustValue;
}
struct StatementResult;

namespace Type_Details {
struct Void;
struct Bool;
struct U8;
struct U16;
struct U32;
struct U64;
struct I8;
struct I16;
struct I32;
struct I64;
struct F32;
struct F64;
struct Usize;
struct JaktString;
struct CChar;
struct CInt;
struct Unknown;
struct Never;
struct TypeVariable;
struct GenericInstance;
struct GenericEnumInstance;
struct GenericResolvedType;
struct Struct;
struct Enum;
struct RawPtr;
struct Reference;
struct MutableReference;
struct Function;
}
struct Type;

enum class InterpretError: i32;
namespace CheckedMatchBody_Details {
struct Expression;
struct Block;
}
struct CheckedMatchBody;

namespace CheckedStatement_Details {
struct Expression;
struct Defer;
struct DestructuringAssignment;
struct VarDecl;
struct If;
struct Block;
struct Loop;
struct While;
struct Return;
struct Break;
struct Continue;
struct Throw;
struct Yield;
struct InlineCpp;
struct Garbage;
}
struct CheckedStatement;

namespace BlockControlFlow_Details {
struct AlwaysReturns;
struct AlwaysTransfersControl;
struct NeverReturns;
struct MayReturn;
struct PartialAlwaysReturns;
struct PartialAlwaysTransfersControl;
struct PartialNeverReturns;
}
struct BlockControlFlow;

namespace StructOrEnumId_Details {
struct Struct;
struct Enum;
}
struct StructOrEnumId;

namespace CheckedEnumVariant_Details {
struct Untyped;
struct Typed;
struct WithValue;
struct StructLike;
}
struct CheckedEnumVariant;

namespace CheckedMatchCase_Details {
struct EnumVariant;
struct Expression;
struct CatchAll;
}
struct CheckedMatchCase;

namespace FunctionGenericParameter_Details {
struct InferenceGuide;
struct Parameter;
}
struct FunctionGenericParameter;

namespace CheckedTypeCast_Details {
struct Fallible;
struct Infallible;
}
struct CheckedTypeCast;

namespace NumberConstant_Details {
struct Signed;
struct Unsigned;
struct Floating;
}
struct NumberConstant;

namespace ExecutionResult_Details {
struct Return;
struct Throw;
}
struct ExecutionResult;

namespace CheckedUnaryOperator_Details {
struct PreIncrement;
struct PostIncrement;
struct PreDecrement;
struct PostDecrement;
struct Negate;
struct Dereference;
struct RawAddress;
struct Reference;
struct MutableReference;
struct LogicalNot;
struct BitwiseNot;
struct TypeCast;
struct Is;
struct IsEnumVariant;
}
struct CheckedUnaryOperator;

namespace CheckedCapture_Details {
struct ByValue;
struct ByReference;
struct ByMutableReference;
}
struct CheckedCapture;

namespace SafetyMode_Details {
struct Safe;
struct Unsafe;
}
struct SafetyMode;

namespace CheckedExpression_Details {
struct Boolean;
struct NumericConstant;
struct QuotedString;
struct ByteConstant;
struct CharacterConstant;
struct UnaryOp;
struct BinaryOp;
struct JaktTuple;
struct Range;
struct JaktArray;
struct JaktSet;
struct JaktDictionary;
struct IndexedExpression;
struct IndexedRangeExpression;
struct IndexedDictionary;
struct IndexedTuple;
struct IndexedStruct;
struct Match;
struct EnumVariantArg;
struct Call;
struct MethodCall;
struct NamespacedVar;
struct Var;
struct OptionalNone;
struct OptionalSome;
struct ForcedUnwrap;
struct Block;
struct Function;
struct Try;
struct TryBlock;
struct Garbage;
}
struct CheckedExpression;

namespace ValueImpl_Details {
struct Void;
struct Bool;
struct U8;
struct U16;
struct U32;
struct U64;
struct I8;
struct I16;
struct I32;
struct I64;
struct F32;
struct F64;
struct USize;
struct JaktString;
struct CChar;
struct CInt;
struct Struct;
struct Class;
struct Enum;
struct JaktArray;
struct RawPtr;
struct OptionalSome;
struct OptionalNone;
}
struct ValueImpl;

namespace CheckedNumericConstant_Details {
struct I8;
struct I16;
struct I32;
struct I64;
struct U8;
struct U16;
struct U32;
struct U64;
struct USize;
struct F32;
struct F64;
}
struct CheckedNumericConstant;

enum class BuiltinType: size_t;
static typechecker::TypeId void_type_id();

static typechecker::TypeId expression_type(const NonnullRefPtr<typechecker::CheckedExpression> expr);

static typechecker::TypeId unknown_type_id();

static bool expression_can_throw(const NonnullRefPtr<typechecker::CheckedExpression> expr);

static typechecker::TypeId builtin(const typechecker::BuiltinType builtin);

static utility::Span expression_span(const NonnullRefPtr<typechecker::CheckedExpression> expr);

static ErrorOr<typechecker::TypeId> flip_signedness(const NonnullRefPtr<typechecker::Type> type);

static typechecker::BlockControlFlow checked_expression_control_flow(const NonnullRefPtr<typechecker::CheckedExpression> check_expression);

static Optional<typechecker::CheckedNumericConstant> promote(const typechecker::NumberConstant num_const, const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedProgram> program);

static typechecker::TypeId never_type_id();

template <typename T,typename U>
static bool is_same_type();

}
namespace codegen {
struct LineSpan;
struct CodegenDebugInfo;
struct CodeGenerator;
struct ControlFlowState;
namespace AllowedControlExits_Details {
struct Nothing;
struct JustReturn;
struct AtLoop;
}
struct AllowedControlExits;

static bool are_loop_exits_allowed(const codegen::AllowedControlExits allowed_control_exits);

static bool is_return_allowed(const codegen::AllowedControlExits allowed_control_exits);

}
namespace repl {
struct Editor;
struct REPL;
namespace LineResult_Details {
struct Line;
struct Eof;
}
struct LineResult;

static ErrorOr<String> serialize_ast_node(const NonnullRefPtr<typechecker::CheckedExpression> node);

static String serialize_unary_operation(const typechecker::CheckedUnaryOperator op, const String expr);

template <typename T>
static T* allocate(const size_t count);

template <typename T>
static T* null();

}
namespace ide {
namespace Mutability_Details {
struct DoesNotApply;
struct Immutable;
struct Mutable;
}
struct Mutability;

namespace Usage_Details {
struct Variable;
struct Call;
struct Typename;
struct NameSet;
struct EnumVariant;
}
struct Usage;

namespace VarType_Details {
struct Variable;
struct Field;
}
struct VarType;

namespace VarVisibility_Details {
struct DoesNotApply;
struct Public;
struct Private;
struct Restricted;
}
struct VarVisibility;

static ErrorOr<ide::Usage> get_enum_variant_usage_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const String name);

static ErrorOr<Array<String>> completions_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id);

static ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>> enum_variant_fields(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedEnumVariant checked_enum_variant);

static ErrorOr<String> get_enum_variant_signature_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const String name);

static ErrorOr<String> get_type_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id);

static ErrorOr<Optional<ide::Usage>> find_span_in_scope(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::Scope> scope, const utility::Span span);

static ErrorOr<String> get_constructor_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::FunctionId function_id);

static ErrorOr<Array<String>> find_dot_completions(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<utility::Span> find_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<String> get_var_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const String name, const typechecker::TypeId var_type_id, const ide::Mutability mutability, const ide::VarType var_type, const ide::VarVisibility visibility, const Optional<typechecker::TypeId> struct_type_id);

static ErrorOr<Optional<ide::Usage>> find_span_in_expression(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedExpression> expr, const utility::Span span);

static ErrorOr<utility::Span> find_type_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_block(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedBlock block, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_function(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedFunction> checked_function, const utility::Span span);

static ErrorOr<Optional<String>> find_typename_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program, const utility::Span span);

static ErrorOr<utility::Span> find_type_definition_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::TypeId type_id, const utility::Span span);

static ErrorOr<String> get_enum_variant_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const String name, const typechecker::TypeId type_id, const Array<Tuple<Optional<String>,typechecker::TypeId>> variants, const Optional<typechecker::NumberConstant> number_constant);

static ErrorOr<Optional<ide::Usage>> find_span_in_enum(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedEnum checked_enum, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_statement(const NonnullRefPtr<typechecker::CheckedProgram> program, const NonnullRefPtr<typechecker::CheckedStatement> statement, const utility::Span span);

static ErrorOr<Optional<ide::Usage>> find_span_in_struct(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::CheckedStruct checked_struct, const utility::Span span);

static ErrorOr<String> get_function_signature(const NonnullRefPtr<typechecker::CheckedProgram> program, const typechecker::FunctionId function_id);

}
static ErrorOr<void> write_to_file(const String data, const String output_filename);

static ErrorOr<int> run_compiler(const String cxx_compiler_path, const String cpp_filename, const String output_filename, const String runtime_path, const Array<String> extra_include_paths, const Array<String> extra_lib_paths, const Array<String> extra_link_libs, const bool optimize);

static String usage();

static String help();

namespace utility {
struct FileId {
  public:
size_t id;bool equals(const utility::FileId rhs) const;
FileId(size_t a_id) :id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FileId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ArgsParser {
  public:
Array<String> args;Array<size_t> removed_indices;static ErrorOr<utility::ArgsParser> from_args(const Array<String> args);
ErrorOr<Array<String>> option_multiple(const Array<String> names);
ErrorOr<bool> flag(const Array<String> names);
ArgsParser(Array<String> a_args, Array<size_t> a_removed_indices) :args(a_args), removed_indices(a_removed_indices){}

ErrorOr<Array<String>> remaining_arguments() const;
ErrorOr<Optional<String>> option(const Array<String> names);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ArgsParser("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("removed_indices: "));TRY(builder.appendff("{}", removed_indices));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Span {
  public:
utility::FileId file_id;size_t start;size_t end;bool contains(const utility::Span span) const;
Span(utility::FileId a_file_id, size_t a_start, size_t a_end) :file_id(a_file_id), start(a_start), end(a_end){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Span("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_id: "));TRY(builder.appendff("{}, ", file_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("start: "));TRY(builder.appendff("{}, ", start));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("end: "));TRY(builder.appendff("{}", end));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class FilePath : public RefCounted<FilePath>, public Weakable<FilePath> {
  public:
virtual ~FilePath() = default;
String path;static ErrorOr<NonnullRefPtr<utility::FilePath>> make(const String filepath);
ErrorOr<Tuple<String,String>> split_at_last_slash() const;
ErrorOr<String> dirname() const;
private:
explicit FilePath(String&& a_path): path(move(a_path)){}
public:
static ErrorOr<NonnullRefPtr<FilePath>> create(String path) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) FilePath (move(path)))); return o; }
static Optional<size_t> last_slash(const String path);
ErrorOr<String> basename() const;
ErrorOr<String> ext() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FilePath("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("path: "));TRY(builder.appendff("\"{}\"", path));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static ErrorOr<Array<String>> append_to_each(const Array<String> strings,const String suffix) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String str = (_magic_value.value());
{
TRY((((output).push((str + suffix)))));
}

}
}

return (output);
}
}

static String join(const Array<String> strings,const String separator) {
{
String output = String("");
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String s = (_magic_value.value());
{
(output += s);
if ((i < (JaktInternal::checked_sub<size_t>(((strings).size()),static_cast<size_t>(1ULL))))){
(output += separator);
}
((i++));
}

}
}

return (output);
}
}

template <typename T>
static ErrorOr<void> extend_array(Array<T> target,const Array<T> extend_with) {
{
TRY((((target).add_capacity(((extend_with).size())))));
{
ArrayIterator<T> _magic = ((extend_with).iterator());
for (;;){
Optional<T> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
T v = (_magic_value.value());
{
TRY((((target).push(v))));
}

}
}

}
return {};
}

[[noreturn]] static void panic(const String message) {
{
warnln(String("internal error: {}"),message);
abort();
}
}

static ErrorOr<String> escape_for_quotes(const String s) {
{
StringBuilder builder = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((s).length()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const u8 c = ((s).byte_at(i));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<String>>{
auto __jakt_enum_value = (c);
if (__jakt_enum_value == '"') {
{
TRY((((builder).append_string(String("\\\"")))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == '\\') {
{
TRY((((builder).append_string(String("\\\\")))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == '\n') {
{
TRY((((builder).append_string(String("\\n")))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((builder).append(c))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

return (TRY((((builder).to_string()))));
}
}

static ErrorOr<Array<String>> prepend_to_each(const Array<String> strings,const String prefix) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((strings).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String str = (_magic_value.value());
{
TRY((((output).push((prefix + str)))));
}

}
}

return (output);
}
}

static void todo(const String message) {
{
warnln(String("TODO: {}"),message);
abort();
}
}

bool utility::Span::contains(const utility::Span span) const {
{
return (((((((*this).file_id)).equals(((span).file_id))) && (((span).start) >= ((*this).start))) && (((span).end) <= ((*this).end))));
}
}

bool utility::FileId::equals(const utility::FileId rhs) const {
{
return ((((*this).id) == ((rhs).id)));
}
}

ErrorOr<NonnullRefPtr<utility::FilePath>> utility::FilePath::make(const String filepath) {
{
return (TRY((utility::FilePath::create(filepath))));
}
}

ErrorOr<Tuple<String,String>> utility::FilePath::split_at_last_slash() const {
{
const size_t len = ((((*this).path)).length());
const Optional<size_t> last_slash = utility::FilePath::last_slash(((*this).path));
if (((last_slash).has_value())){
const String dir = TRY((((((*this).path)).substring(static_cast<size_t>(0ULL),(JaktInternal::checked_add<size_t>((last_slash.value()),static_cast<size_t>(1ULL)))))));
const String base = TRY((((((*this).path)).substring((JaktInternal::checked_add<size_t>((last_slash.value()),static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>((JaktInternal::checked_sub<size_t>(len,(last_slash.value()))),static_cast<size_t>(1ULL)))))));
return ((Tuple{dir, base}));
}
return ((Tuple{String(""), ((*this).path)}));
}
}

ErrorOr<String> utility::FilePath::dirname() const {
{
const Tuple<String,String> parts = TRY((((*this).split_at_last_slash())));
if ((((parts).get<0>()) == String(""))){
return (String("."));
}
return (((parts).get<0>()));
}
}

Optional<size_t> utility::FilePath::last_slash(const String path) {
{
size_t i = (JaktInternal::checked_sub<size_t>(((path).length()),static_cast<size_t>(1ULL)));
while (((i >= static_cast<size_t>(1ULL)) && (((path).byte_at(i)) != '/'))){
((i--));
}
if (((i == static_cast<size_t>(0ULL)) && (((path).byte_at(i)) != '/'))){
return (JaktInternal::OptionalNone());
}
return (i);
}
}

ErrorOr<String> utility::FilePath::basename() const {
{
const Tuple<String,String> parts = TRY((((*this).split_at_last_slash())));
return (((parts).get<1>()));
}
}

ErrorOr<String> utility::FilePath::ext() const {
{
{
Range<size_t> _magic = (((Range<size_t>{static_cast<size_t>((JaktInternal::checked_sub<size_t>(((((*this).path)).length()),static_cast<size_t>(1ULL)))),static_cast<size_t>(static_cast<size_t>(0ULL))})).inclusive());
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const u8 c = ((((*this).path)).byte_at(i));
if ((c == '/')){
break;
}
if ((c == '.')){
return (TRY((((((*this).path)).substring((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>((JaktInternal::checked_sub<size_t>(((((*this).path)).length()),static_cast<size_t>(1ULL))),i)))))));
}
}

}
}

return (String(""));
}
}

ErrorOr<utility::ArgsParser> utility::ArgsParser::from_args(const Array<String> args) {
{
return (utility::ArgsParser(args,(TRY((Array<size_t>::create_with({}))))));
}
}

ErrorOr<Array<String>> utility::ArgsParser::option_multiple(const Array<String> names) {
{
Array<String> result = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
if ((((((*this).args)).size()) <= (JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))))){
warnln(String("The option '{}' requires a value, but none was supplied"),name);
return Error::from_errno(static_cast<i32>(200));
}
TRY((((((*this).removed_indices)).push(i))));
TRY((((((*this).removed_indices)).push((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))))));
TRY((((result).push(((((*this).args))[(JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))])))));
}
}

}
}

}

}
}

return (result);
}
}

ErrorOr<bool> utility::ArgsParser::flag(const Array<String> names) {
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
TRY((((((*this).removed_indices)).push(i))));
return (true);
}
}

}
}

}

}
}

return (false);
}
}

ErrorOr<Array<String>> utility::ArgsParser::remaining_arguments() const {
{
Array<String> remaining = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(((((*this).removed_indices)).contains(i))))){
TRY((((remaining).push(((((*this).args))[i])))));
}
}

}
}

return (remaining);
}
}

ErrorOr<Optional<String>> utility::ArgsParser::option(const Array<String> names) {
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((((*this).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
if ((((((*this).args))[i]) == name)){
if ((((((*this).args)).size()) <= (JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL))))){
warnln(String("The option '{}' requires a value, but none was supplied"),name);
return Error::from_errno(static_cast<i32>(200));
}
TRY((((((*this).removed_indices)).push(i))));
TRY((((((*this).removed_indices)).push((JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))))));
return (((((*this).args))[(JaktInternal::checked_add<size_t>(i,static_cast<size_t>(1ULL)))]));
}
}

}
}

}

}
}

return (JaktInternal::OptionalNone());
}
}

}
namespace error {
namespace MessageSeverity_Details {
struct Hint {};
struct Error {};
}
struct MessageSeverity : public Variant<MessageSeverity_Details::Hint, MessageSeverity_Details::Error> {
using Variant<MessageSeverity_Details::Hint, MessageSeverity_Details::Error>::Variant;
    using Hint = MessageSeverity_Details::Hint;
    using Error = MessageSeverity_Details::Error;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Hint */: {
[[maybe_unused]] auto const& that = this->template get<MessageSeverity::Hint>();
TRY(builder.append("MessageSeverity::Hint"));
break;}
case 1 /* Error */: {
[[maybe_unused]] auto const& that = this->template get<MessageSeverity::Error>();
TRY(builder.append("MessageSeverity::Error"));
break;}
}
return builder.to_string();
}ErrorOr<String> ansi_color_code() const;
ErrorOr<String> name() const;
};
namespace JaktError_Details {
struct Message {
String message;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Message(_MemberT0&& member_0, _MemberT1&& member_1):
message{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MessageWithHint {
String message;
utility::Span span;
String hint;
utility::Span hint_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
MessageWithHint(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
message{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
hint{ forward<_MemberT2>(member_2)},
hint_span{ forward<_MemberT3>(member_3)}
{}
};
}
struct JaktError : public Variant<JaktError_Details::Message, JaktError_Details::MessageWithHint> {
using Variant<JaktError_Details::Message, JaktError_Details::MessageWithHint>::Variant;
    using Message = JaktError_Details::Message;
    using MessageWithHint = JaktError_Details::MessageWithHint;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Message */: {
[[maybe_unused]] auto const& that = this->template get<JaktError::Message>();
TRY(builder.append("JaktError::Message"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("message: \"{}\"", that.message));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* MessageWithHint */: {
[[maybe_unused]] auto const& that = this->template get<JaktError::MessageWithHint>();
TRY(builder.append("JaktError::MessageWithHint"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("message: \"{}\"", that.message));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("hint: \"{}\"", that.hint));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("hint_span: {}", that.hint_span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}utility::Span span() const;
};
static ErrorOr<void> print_error_json(const String file_name,const error::JaktError error) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = error;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
{
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Error(),file_name,message,span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
String const& hint = __jakt_match_value.hint;
utility::Span const& hint_span = __jakt_match_value.hint_span;
{
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Error(),file_name,message,span)));
TRY((error::display_message_with_span_json(typename error::MessageSeverity::Hint(),file_name,hint,hint_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return {};
}

static ErrorOr<Array<Tuple<size_t,size_t>>> gather_line_spans(const Array<u8> file_contents) {
{
size_t idx = static_cast<size_t>(0ULL);
Array<Tuple<size_t,size_t>> output = (TRY((Array<Tuple<size_t,size_t>>::create_with({}))));
size_t start = idx;
while ((idx < ((file_contents).size()))){
if ((((file_contents)[idx]) == '\n')){
TRY((((output).push((Tuple{start, idx})))));
(start = (JaktInternal::checked_add<size_t>(idx,static_cast<size_t>(1ULL))));
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
if ((start < idx)){
TRY((((output).push((Tuple{start, idx})))));
}
return (output);
}
}

static ErrorOr<void> display_message_with_span(const error::MessageSeverity severity,const String file_name,const Optional<Array<u8>> contents,const String message,const utility::Span span) {
{
warnln(String("{}: {}"),TRY((((severity).name()))),message);
if ((!(((contents).has_value())))){
return {};
}
const Array<u8> file_contents = (contents.value());
const Array<Tuple<size_t,size_t>> line_spans = TRY((error::gather_line_spans(file_contents)));
size_t line_index = static_cast<size_t>(1ULL);
const size_t largest_line_number = ((line_spans).size());
const size_t width = ((TRY((String::formatted(String("{}"),largest_line_number)))).length());
while ((line_index < ((line_spans).size()))){
if (((((span).start) >= ((((line_spans)[line_index])).get<0>())) && (((span).start) <= ((((line_spans)[line_index])).get<1>())))){
const size_t column_index = (JaktInternal::checked_sub<size_t>(((span).start),((((line_spans)[line_index])).get<0>())));
warnln(String("----- \u001b[33m{}:{}:{}\u001b[0m"),file_name,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),(JaktInternal::checked_add<size_t>(column_index,static_cast<size_t>(1ULL))));
if ((line_index > static_cast<size_t>(0ULL))){
TRY((error::print_source_line(severity,file_contents,((line_spans)[(JaktInternal::checked_sub<size_t>(line_index,static_cast<size_t>(1ULL)))]),span,line_index,largest_line_number)));
}
TRY((error::print_source_line(severity,file_contents,((line_spans)[line_index]),span,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),largest_line_number)));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>((JaktInternal::checked_add<size_t>((JaktInternal::checked_add<size_t>((JaktInternal::checked_sub<size_t>(((span).start),((((line_spans)[line_index])).get<0>()))),width)),static_cast<size_t>(4ULL))))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t x = (_magic_value.value());
{
warn(String(" "));
}

}
}

warnln(String("\u001b[{}m^- {}\u001b[0m"),TRY((((severity).ansi_color_code()))),message);
while (((line_index < ((line_spans).size())) && (((span).end) > ((((line_spans)[line_index])).get<0>())))){
(++(line_index));
if ((line_index >= ((line_spans).size()))){
break;
}
TRY((error::print_source_line(severity,file_contents,((line_spans)[line_index]),span,(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),largest_line_number)));
break;
}
}
else {
(++(line_index));
}

}
warnln(String("\u001b[0m-----"));
}
return {};
}

static ErrorOr<void> print_source_line(const error::MessageSeverity severity,const Array<u8> file_contents,const Tuple<size_t,size_t> file_span,const utility::Span error_span,const size_t line_number,const size_t largest_line_number) {
{
size_t index = ((file_span).get<0>());
const size_t width = ((TRY((String::formatted(String("{}"),largest_line_number)))).length());
warn(String(" {} | "),line_number);
while ((index <= ((file_span).get<1>()))){
u8 c = ' ';
if ((index < ((file_span).get<1>()))){
(c = ((file_contents)[index]));
}
else if (((((error_span).start) == ((error_span).end)) && (index == ((error_span).start)))){
(c = '_');
}
if ((index == ((error_span).start))){
warn(String("\u001b[{}m"),TRY((((severity).ansi_color_code()))));
}
if ((index == ((error_span).end))){
warn(String("\u001b[0m"));
}
warn(String("{:c}"),c);
(++(index));
}
warnln(String(""));
}
return {};
}

static ErrorOr<void> display_message_with_span_json(const error::MessageSeverity severity,const String file_name,const String message,const utility::Span span) {
{
outln(String("{{\"type\":\"diagnostic\",\"message\":\"{}\",\"severity\":\"{}\",\"file_id\":{},\"span\":{{\"start\":{},\"end\":{}}}}}"),message,TRY((((severity).name()))),((((span).file_id)).id),((span).start),((span).end));
}
return {};
}

static ErrorOr<void> print_error(const String file_name,const Optional<Array<u8>> file_contents,const error::JaktError error) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = error;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
{
TRY((error::display_message_with_span(typename error::MessageSeverity::Error(),file_name,file_contents,message,span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();String const& message = __jakt_match_value.message;
utility::Span const& span = __jakt_match_value.span;
String const& hint = __jakt_match_value.hint;
utility::Span const& hint_span = __jakt_match_value.hint_span;
{
TRY((error::display_message_with_span(typename error::MessageSeverity::Error(),file_name,file_contents,message,span)));
TRY((error::display_message_with_span(typename error::MessageSeverity::Hint(),file_name,file_contents,hint,hint_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return {};
}

utility::Span error::JaktError::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::Message>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<error::JaktError::MessageWithHint>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<String> error::MessageSeverity::ansi_color_code() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Hint>();
return JaktInternal::ExplicitValue(String("94"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Error>();
return JaktInternal::ExplicitValue(String("31"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<String> error::MessageSeverity::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Hint>();
return JaktInternal::ExplicitValue(String("Hint"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename error::MessageSeverity::Error>();
return JaktInternal::ExplicitValue(String("Error"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace compiler {
class Compiler : public RefCounted<Compiler>, public Weakable<Compiler> {
  public:
virtual ~Compiler() = default;
Array<NonnullRefPtr<utility::FilePath>> files;Dictionary<String,utility::FileId> file_ids;Array<error::JaktError> errors;Optional<utility::FileId> current_file;Array<u8> current_file_contents;bool dump_lexer;bool dump_parser;bool ignore_parser_errors;bool debug_print;Array<String> include_paths;bool json_errors;bool dump_type_hints;bool dump_try_hints;ErrorOr<void> load_prelude();
ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> get_file_path(const utility::FileId file_id) const;
bool set_current_file(const utility::FileId file_id);
ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> search_for_path(const String module_name) const;
ErrorOr<utility::FileId> get_file_id_or_register(const NonnullRefPtr<utility::FilePath> file);
Optional<utility::FileId> current_file_id() const;
private:
explicit Compiler(Array<NonnullRefPtr<utility::FilePath>>&& a_files, Dictionary<String,utility::FileId>&& a_file_ids, Array<error::JaktError>&& a_errors, Optional<utility::FileId>&& a_current_file, Array<u8>&& a_current_file_contents, bool&& a_dump_lexer, bool&& a_dump_parser, bool&& a_ignore_parser_errors, bool&& a_debug_print, Array<String>&& a_include_paths, bool&& a_json_errors, bool&& a_dump_type_hints, bool&& a_dump_try_hints): files(move(a_files)), file_ids(move(a_file_ids)), errors(move(a_errors)), current_file(move(a_current_file)), current_file_contents(move(a_current_file_contents)), dump_lexer(move(a_dump_lexer)), dump_parser(move(a_dump_parser)), ignore_parser_errors(move(a_ignore_parser_errors)), debug_print(move(a_debug_print)), include_paths(move(a_include_paths)), json_errors(move(a_json_errors)), dump_type_hints(move(a_dump_type_hints)), dump_try_hints(move(a_dump_try_hints)){}
public:
static ErrorOr<NonnullRefPtr<Compiler>> create(Array<NonnullRefPtr<utility::FilePath>> files, Dictionary<String,utility::FileId> file_ids, Array<error::JaktError> errors, Optional<utility::FileId> current_file, Array<u8> current_file_contents, bool dump_lexer, bool dump_parser, bool ignore_parser_errors, bool debug_print, Array<String> include_paths, bool json_errors, bool dump_type_hints, bool dump_try_hints) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Compiler (move(files), move(file_ids), move(errors), move(current_file), move(current_file_contents), move(dump_lexer), move(dump_parser), move(ignore_parser_errors), move(debug_print), move(include_paths), move(json_errors), move(dump_type_hints), move(dump_try_hints)))); return o; }
Optional<NonnullRefPtr<utility::FilePath>> current_file_path() const;
[[noreturn]] ErrorOr<void> panic(const String message) const;
ErrorOr<void> print_errors() const;
void dbg_println(const String message) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Compiler("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("files: "));TRY(builder.appendff("{}, ", files));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_ids: "));TRY(builder.appendff("{}, ", file_ids));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("errors: "));TRY(builder.appendff("{}, ", errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_file: "));TRY(builder.appendff("{}, ", current_file));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_file_contents: "));TRY(builder.appendff("{}, ", current_file_contents));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_lexer: "));TRY(builder.appendff("{}, ", dump_lexer));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_parser: "));TRY(builder.appendff("{}, ", dump_parser));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("ignore_parser_errors: "));TRY(builder.appendff("{}, ", ignore_parser_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_print: "));TRY(builder.appendff("{}, ", debug_print));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("include_paths: "));TRY(builder.appendff("{}, ", include_paths));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("json_errors: "));TRY(builder.appendff("{}, ", json_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_type_hints: "));TRY(builder.appendff("{}, ", dump_type_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_try_hints: "));TRY(builder.appendff("{}", dump_try_hints));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};ErrorOr<void> compiler::Compiler::load_prelude() {
{
const String module_name = String("__prelude__");
const NonnullRefPtr<utility::FilePath> file_name = TRY((utility::FilePath::make(module_name)));
TRY((((*this).get_file_id_or_register(file_name))));
}
return {};
}

ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> compiler::Compiler::get_file_path(const utility::FileId file_id) const {
{
if ((((file_id).id) >= ((((*this).files)).size()))){
return (JaktInternal::OptionalNone());
}
return (((((*this).files))[((file_id).id)]));
}
}

bool compiler::Compiler::set_current_file(const utility::FileId file_id) {
{
const i32 ErrNOENT = static_cast<i32>(2);
const i32 ErrACCES = static_cast<i32>(13);
const i32 ErrFBIG = static_cast<i32>(27);
const i32 ErrNAMETOOLONG = static_cast<i32>(36);
const Optional<utility::FileId> old_file_id = ((*this).current_file);
(((*this).current_file) = file_id);
auto __jakt_var_0 = [&]() -> ErrorOr<void> {{
NonnullRefPtr<File> file = TRY((File::open_for_reading(((((((*this).files))[((file_id).id)]))->path))));
(((*this).current_file_contents) = TRY((((file)->read_all()))));
}

;return {};}();
if (__jakt_var_0.is_error()) {auto error = __jakt_var_0.release_error();{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,bool>{
auto __jakt_enum_value = (((error).code()));
if (__jakt_enum_value == ErrNOENT) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: File not found"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrACCES) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: Permission denied"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrFBIG) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: File too big"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == ErrNAMETOOLONG) {
return (warnln(String("\u001b[31;1mError\u001b[0m Could not access {}: Name too long"),((((((*this).files))[((file_id).id)]))->path))), JaktInternal::ExplicitValue<void>();
}
else {
{
utility::panic(String("Incurred unrecognized error while trying to open file"));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(((*this).current_file) = old_file_id);
return (false);
}
};
return (true);
}
}

ErrorOr<Optional<NonnullRefPtr<utility::FilePath>>> compiler::Compiler::search_for_path(const String module_name) const {
{
{
ArrayIterator<String> _magic = ((((*this).include_paths)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String include_path = (_magic_value.value());
{
const String candidate_path = (((include_path + String("/")) + module_name) + String(".jakt"));
if (File::exists(candidate_path)){
return (TRY((utility::FilePath::make(candidate_path))));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

ErrorOr<utility::FileId> compiler::Compiler::get_file_id_or_register(const NonnullRefPtr<utility::FilePath> file) {
{
Optional<utility::FileId> file_id = ((((*this).file_ids)).get(((file)->path)));
if (((file_id).has_value())){
return ((file_id.value()));
}
TRY((((((*this).files)).push(file))));
(file_id = utility::FileId((JaktInternal::checked_sub<size_t>(((((*this).files)).size()),static_cast<size_t>(1ULL)))));
TRY((((((*this).file_ids)).set(((file)->path),(file_id.value())))));
return ((file_id.value()));
}
}

Optional<utility::FileId> compiler::Compiler::current_file_id() const {
{
return (((*this).current_file));
}
}

Optional<NonnullRefPtr<utility::FilePath>> compiler::Compiler::current_file_path() const {
{
if (((((*this).current_file)).has_value())){
return (((((*this).files))[(((((*this).current_file).value())).id)]));
}
return (JaktInternal::OptionalNone());
}
}

[[noreturn]] ErrorOr<void> compiler::Compiler::panic(const String message) const {
{
MUST((((*this).print_errors())));
utility::panic(message);
}
}

ErrorOr<void> compiler::Compiler::print_errors() const {
{
size_t idx = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<utility::FilePath>> _magic = ((((*this).files)).iterator());
for (;;){
Optional<NonnullRefPtr<utility::FilePath>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<utility::FilePath> file = (_magic_value.value());
{
Optional<Array<u8>> file_contents = JaktInternal::OptionalNone();
const String file_name = ((file)->path);
{
ArrayIterator<error::JaktError> _magic = ((((*this).errors)).iterator());
for (;;){
Optional<error::JaktError> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
error::JaktError error = (_magic_value.value());
{
const utility::Span span = ((error).span());
if ((((((span).file_id)).id) == idx)){
if (((*this).json_errors)){
TRY((error::print_error_json(file_name,error)));
}
else {
if ((!(((file_contents).has_value())))){
auto __jakt_var_1 = [&]() -> ErrorOr<void> {{
NonnullRefPtr<File> file = TRY((File::open_for_reading(file_name)));
(file_contents = TRY((((file)->read_all()))));
}

;return {};}();
if (__jakt_var_1.is_error()) {auto error = __jakt_var_1.release_error();{
}
};
}
TRY((error::print_error(file_name,file_contents,error)));
}

}
}

}
}

((idx++));
}

}
}

}
return {};
}

void compiler::Compiler::dbg_println(const String message) const {
{
if (((*this).debug_print)){
outln(String("{}"),message);
}
}
}

}
namespace lexer {
struct Lexer {
  public:
size_t index;Array<u8> input;NonnullRefPtr<compiler::Compiler> compiler;ErrorOr<lexer::Token> lex_quoted_string(const u8 delimiter);
ErrorOr<Optional<lexer::Token>> next();
bool is_whitespace(const u8 ch) const;
ErrorOr<lexer::Token> lex_character_constant_or_name();
lexer::Token lex_dot();
ErrorOr<lexer::Token> make_integer_token(const u64 number, const lexer::LiteralSuffix suffix, const utility::Span span);
ErrorOr<lexer::Token> lex_forward_slash();
lexer::Token lex_question_mark();
u8 peek_behind(const size_t steps) const;
u8 peek_ahead(const size_t steps) const;
lexer::Token lex_asterisk();
u8 peek() const;
lexer::Token lex_percent_sign();
ErrorOr<lexer::Token> lex_number_or_name();
lexer::Token lex_minus();
bool eof() const;
lexer::Token lex_ampersand();
utility::Span span(const size_t start, const size_t end) const;
lexer::Token lex_plus();
lexer::Token lex_exclamation_point();
Optional<lexer::LiteralSuffix> consume_numeric_literal_suffix();
lexer::Token lex_colon();
Lexer(size_t a_index, Array<u8> a_input, NonnullRefPtr<compiler::Compiler> a_compiler) :index(a_index), input(a_input), compiler(a_compiler){}

ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<String> substring(const size_t start, const size_t length) const;
lexer::Token lex_greater_than();
lexer::Token lex_pipe();
lexer::Token lex_caret();
ErrorOr<lexer::Token> lex_number();
lexer::Token lex_less_than();
lexer::Token lex_equals();
static ErrorOr<Array<lexer::Token>> lex(const NonnullRefPtr<compiler::Compiler> compiler);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Lexer("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}, ", index));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("input: "));TRY(builder.appendff("{}, ", input));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}", *compiler));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace NumericConstant_Details {
struct I8{
i8 value;
template<typename... Args>
I8(Args&&... args): value { forward<Args>(args)... } {}
};
struct I16{
i16 value;
template<typename... Args>
I16(Args&&... args): value { forward<Args>(args)... } {}
};
struct I32{
i32 value;
template<typename... Args>
I32(Args&&... args): value { forward<Args>(args)... } {}
};
struct I64{
i64 value;
template<typename... Args>
I64(Args&&... args): value { forward<Args>(args)... } {}
};
struct U8{
u8 value;
template<typename... Args>
U8(Args&&... args): value { forward<Args>(args)... } {}
};
struct U16{
u16 value;
template<typename... Args>
U16(Args&&... args): value { forward<Args>(args)... } {}
};
struct U32{
u32 value;
template<typename... Args>
U32(Args&&... args): value { forward<Args>(args)... } {}
};
struct U64{
u64 value;
template<typename... Args>
U64(Args&&... args): value { forward<Args>(args)... } {}
};
struct USize{
u64 value;
template<typename... Args>
USize(Args&&... args): value { forward<Args>(args)... } {}
};
struct F32{
f32 value;
template<typename... Args>
F32(Args&&... args): value { forward<Args>(args)... } {}
};
struct F64{
f64 value;
template<typename... Args>
F64(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct NumericConstant : public Variant<NumericConstant_Details::I8, NumericConstant_Details::I16, NumericConstant_Details::I32, NumericConstant_Details::I64, NumericConstant_Details::U8, NumericConstant_Details::U16, NumericConstant_Details::U32, NumericConstant_Details::U64, NumericConstant_Details::USize, NumericConstant_Details::F32, NumericConstant_Details::F64> {
using Variant<NumericConstant_Details::I8, NumericConstant_Details::I16, NumericConstant_Details::I32, NumericConstant_Details::I64, NumericConstant_Details::U8, NumericConstant_Details::U16, NumericConstant_Details::U32, NumericConstant_Details::U64, NumericConstant_Details::USize, NumericConstant_Details::F32, NumericConstant_Details::F64>::Variant;
    using I8 = NumericConstant_Details::I8;
    using I16 = NumericConstant_Details::I16;
    using I32 = NumericConstant_Details::I32;
    using I64 = NumericConstant_Details::I64;
    using U8 = NumericConstant_Details::U8;
    using U16 = NumericConstant_Details::U16;
    using U32 = NumericConstant_Details::U32;
    using U64 = NumericConstant_Details::U64;
    using USize = NumericConstant_Details::USize;
    using F32 = NumericConstant_Details::F32;
    using F64 = NumericConstant_Details::F64;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* I8 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::I8>();
TRY(builder.append("NumericConstant::I8"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* I16 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::I16>();
TRY(builder.append("NumericConstant::I16"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* I32 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::I32>();
TRY(builder.append("NumericConstant::I32"));
TRY(builder.appendff("({})", that.value));
break;}
case 3 /* I64 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::I64>();
TRY(builder.append("NumericConstant::I64"));
TRY(builder.appendff("({})", that.value));
break;}
case 4 /* U8 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::U8>();
TRY(builder.append("NumericConstant::U8"));
TRY(builder.appendff("({})", that.value));
break;}
case 5 /* U16 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::U16>();
TRY(builder.append("NumericConstant::U16"));
TRY(builder.appendff("({})", that.value));
break;}
case 6 /* U32 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::U32>();
TRY(builder.append("NumericConstant::U32"));
TRY(builder.appendff("({})", that.value));
break;}
case 7 /* U64 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::U64>();
TRY(builder.append("NumericConstant::U64"));
TRY(builder.appendff("({})", that.value));
break;}
case 8 /* USize */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::USize>();
TRY(builder.append("NumericConstant::USize"));
TRY(builder.appendff("({})", that.value));
break;}
case 9 /* F32 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::F32>();
TRY(builder.append("NumericConstant::F32"));
TRY(builder.appendff("({})", that.value));
break;}
case 10 /* F64 */: {
[[maybe_unused]] auto const& that = this->template get<NumericConstant::F64>();
TRY(builder.append("NumericConstant::F64"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}size_t to_usize() const;
};
namespace Token_Details {
struct SingleQuotedString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedByteString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedByteString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct QuotedString {
String quote;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
quote{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Number {
lexer::NumericConstant number;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Number(_MemberT0&& member_0, _MemberT1&& member_1):
number{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Identifier {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Identifier(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Semicolon{
utility::Span value;
template<typename... Args>
Semicolon(Args&&... args): value { forward<Args>(args)... } {}
};
struct Colon{
utility::Span value;
template<typename... Args>
Colon(Args&&... args): value { forward<Args>(args)... } {}
};
struct ColonColon{
utility::Span value;
template<typename... Args>
ColonColon(Args&&... args): value { forward<Args>(args)... } {}
};
struct LParen{
utility::Span value;
template<typename... Args>
LParen(Args&&... args): value { forward<Args>(args)... } {}
};
struct RParen{
utility::Span value;
template<typename... Args>
RParen(Args&&... args): value { forward<Args>(args)... } {}
};
struct LCurly{
utility::Span value;
template<typename... Args>
LCurly(Args&&... args): value { forward<Args>(args)... } {}
};
struct RCurly{
utility::Span value;
template<typename... Args>
RCurly(Args&&... args): value { forward<Args>(args)... } {}
};
struct LSquare{
utility::Span value;
template<typename... Args>
LSquare(Args&&... args): value { forward<Args>(args)... } {}
};
struct RSquare{
utility::Span value;
template<typename... Args>
RSquare(Args&&... args): value { forward<Args>(args)... } {}
};
struct PercentSign{
utility::Span value;
template<typename... Args>
PercentSign(Args&&... args): value { forward<Args>(args)... } {}
};
struct Plus{
utility::Span value;
template<typename... Args>
Plus(Args&&... args): value { forward<Args>(args)... } {}
};
struct Minus{
utility::Span value;
template<typename... Args>
Minus(Args&&... args): value { forward<Args>(args)... } {}
};
struct Equal{
utility::Span value;
template<typename... Args>
Equal(Args&&... args): value { forward<Args>(args)... } {}
};
struct PlusEqual{
utility::Span value;
template<typename... Args>
PlusEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct PlusPlus{
utility::Span value;
template<typename... Args>
PlusPlus(Args&&... args): value { forward<Args>(args)... } {}
};
struct MinusEqual{
utility::Span value;
template<typename... Args>
MinusEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct MinusMinus{
utility::Span value;
template<typename... Args>
MinusMinus(Args&&... args): value { forward<Args>(args)... } {}
};
struct AsteriskEqual{
utility::Span value;
template<typename... Args>
AsteriskEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct ForwardSlashEqual{
utility::Span value;
template<typename... Args>
ForwardSlashEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct PercentSignEqual{
utility::Span value;
template<typename... Args>
PercentSignEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct NotEqual{
utility::Span value;
template<typename... Args>
NotEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct DoubleEqual{
utility::Span value;
template<typename... Args>
DoubleEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct GreaterThan{
utility::Span value;
template<typename... Args>
GreaterThan(Args&&... args): value { forward<Args>(args)... } {}
};
struct GreaterThanOrEqual{
utility::Span value;
template<typename... Args>
GreaterThanOrEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct LessThan{
utility::Span value;
template<typename... Args>
LessThan(Args&&... args): value { forward<Args>(args)... } {}
};
struct LessThanOrEqual{
utility::Span value;
template<typename... Args>
LessThanOrEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftArithmeticShift{
utility::Span value;
template<typename... Args>
LeftArithmeticShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftShift{
utility::Span value;
template<typename... Args>
LeftShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct LeftShiftEqual{
utility::Span value;
template<typename... Args>
LeftShiftEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightShift{
utility::Span value;
template<typename... Args>
RightShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightArithmeticShift{
utility::Span value;
template<typename... Args>
RightArithmeticShift(Args&&... args): value { forward<Args>(args)... } {}
};
struct RightShiftEqual{
utility::Span value;
template<typename... Args>
RightShiftEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Asterisk{
utility::Span value;
template<typename... Args>
Asterisk(Args&&... args): value { forward<Args>(args)... } {}
};
struct Ampersand{
utility::Span value;
template<typename... Args>
Ampersand(Args&&... args): value { forward<Args>(args)... } {}
};
struct AmpersandEqual{
utility::Span value;
template<typename... Args>
AmpersandEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Pipe{
utility::Span value;
template<typename... Args>
Pipe(Args&&... args): value { forward<Args>(args)... } {}
};
struct PipeEqual{
utility::Span value;
template<typename... Args>
PipeEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Caret{
utility::Span value;
template<typename... Args>
Caret(Args&&... args): value { forward<Args>(args)... } {}
};
struct CaretEqual{
utility::Span value;
template<typename... Args>
CaretEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Dollar{
utility::Span value;
template<typename... Args>
Dollar(Args&&... args): value { forward<Args>(args)... } {}
};
struct Tilde{
utility::Span value;
template<typename... Args>
Tilde(Args&&... args): value { forward<Args>(args)... } {}
};
struct ForwardSlash{
utility::Span value;
template<typename... Args>
ForwardSlash(Args&&... args): value { forward<Args>(args)... } {}
};
struct ExclamationPoint{
utility::Span value;
template<typename... Args>
ExclamationPoint(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMark{
utility::Span value;
template<typename... Args>
QuestionMark(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMarkQuestionMark{
utility::Span value;
template<typename... Args>
QuestionMarkQuestionMark(Args&&... args): value { forward<Args>(args)... } {}
};
struct QuestionMarkQuestionMarkEqual{
utility::Span value;
template<typename... Args>
QuestionMarkQuestionMarkEqual(Args&&... args): value { forward<Args>(args)... } {}
};
struct Comma{
utility::Span value;
template<typename... Args>
Comma(Args&&... args): value { forward<Args>(args)... } {}
};
struct Dot{
utility::Span value;
template<typename... Args>
Dot(Args&&... args): value { forward<Args>(args)... } {}
};
struct DotDot{
utility::Span value;
template<typename... Args>
DotDot(Args&&... args): value { forward<Args>(args)... } {}
};
struct Eol{
utility::Span value;
template<typename... Args>
Eol(Args&&... args): value { forward<Args>(args)... } {}
};
struct Eof{
utility::Span value;
template<typename... Args>
Eof(Args&&... args): value { forward<Args>(args)... } {}
};
struct FatArrow{
utility::Span value;
template<typename... Args>
FatArrow(Args&&... args): value { forward<Args>(args)... } {}
};
struct Arrow{
utility::Span value;
template<typename... Args>
Arrow(Args&&... args): value { forward<Args>(args)... } {}
};
struct And{
utility::Span value;
template<typename... Args>
And(Args&&... args): value { forward<Args>(args)... } {}
};
struct Anon{
utility::Span value;
template<typename... Args>
Anon(Args&&... args): value { forward<Args>(args)... } {}
};
struct As{
utility::Span value;
template<typename... Args>
As(Args&&... args): value { forward<Args>(args)... } {}
};
struct Boxed{
utility::Span value;
template<typename... Args>
Boxed(Args&&... args): value { forward<Args>(args)... } {}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Catch{
utility::Span value;
template<typename... Args>
Catch(Args&&... args): value { forward<Args>(args)... } {}
};
struct Class{
utility::Span value;
template<typename... Args>
Class(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Cpp{
utility::Span value;
template<typename... Args>
Cpp(Args&&... args): value { forward<Args>(args)... } {}
};
struct Defer{
utility::Span value;
template<typename... Args>
Defer(Args&&... args): value { forward<Args>(args)... } {}
};
struct Else{
utility::Span value;
template<typename... Args>
Else(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
utility::Span value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
struct Extern{
utility::Span value;
template<typename... Args>
Extern(Args&&... args): value { forward<Args>(args)... } {}
};
struct False{
utility::Span value;
template<typename... Args>
False(Args&&... args): value { forward<Args>(args)... } {}
};
struct For{
utility::Span value;
template<typename... Args>
For(Args&&... args): value { forward<Args>(args)... } {}
};
struct Function{
utility::Span value;
template<typename... Args>
Function(Args&&... args): value { forward<Args>(args)... } {}
};
struct Comptime{
utility::Span value;
template<typename... Args>
Comptime(Args&&... args): value { forward<Args>(args)... } {}
};
struct If{
utility::Span value;
template<typename... Args>
If(Args&&... args): value { forward<Args>(args)... } {}
};
struct Import{
utility::Span value;
template<typename... Args>
Import(Args&&... args): value { forward<Args>(args)... } {}
};
struct In{
utility::Span value;
template<typename... Args>
In(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
utility::Span value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct Let{
utility::Span value;
template<typename... Args>
Let(Args&&... args): value { forward<Args>(args)... } {}
};
struct Loop{
utility::Span value;
template<typename... Args>
Loop(Args&&... args): value { forward<Args>(args)... } {}
};
struct Match{
utility::Span value;
template<typename... Args>
Match(Args&&... args): value { forward<Args>(args)... } {}
};
struct Mut{
utility::Span value;
template<typename... Args>
Mut(Args&&... args): value { forward<Args>(args)... } {}
};
struct Namespace{
utility::Span value;
template<typename... Args>
Namespace(Args&&... args): value { forward<Args>(args)... } {}
};
struct Not{
utility::Span value;
template<typename... Args>
Not(Args&&... args): value { forward<Args>(args)... } {}
};
struct Or{
utility::Span value;
template<typename... Args>
Or(Args&&... args): value { forward<Args>(args)... } {}
};
struct Private{
utility::Span value;
template<typename... Args>
Private(Args&&... args): value { forward<Args>(args)... } {}
};
struct Public{
utility::Span value;
template<typename... Args>
Public(Args&&... args): value { forward<Args>(args)... } {}
};
struct Raw{
utility::Span value;
template<typename... Args>
Raw(Args&&... args): value { forward<Args>(args)... } {}
};
struct Return{
utility::Span value;
template<typename... Args>
Return(Args&&... args): value { forward<Args>(args)... } {}
};
struct Restricted{
utility::Span value;
template<typename... Args>
Restricted(Args&&... args): value { forward<Args>(args)... } {}
};
struct Struct{
utility::Span value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct This{
utility::Span value;
template<typename... Args>
This(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw{
utility::Span value;
template<typename... Args>
Throw(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throws{
utility::Span value;
template<typename... Args>
Throws(Args&&... args): value { forward<Args>(args)... } {}
};
struct True{
utility::Span value;
template<typename... Args>
True(Args&&... args): value { forward<Args>(args)... } {}
};
struct Try{
utility::Span value;
template<typename... Args>
Try(Args&&... args): value { forward<Args>(args)... } {}
};
struct Unsafe{
utility::Span value;
template<typename... Args>
Unsafe(Args&&... args): value { forward<Args>(args)... } {}
};
struct Weak{
utility::Span value;
template<typename... Args>
Weak(Args&&... args): value { forward<Args>(args)... } {}
};
struct While{
utility::Span value;
template<typename... Args>
While(Args&&... args): value { forward<Args>(args)... } {}
};
struct Yield{
utility::Span value;
template<typename... Args>
Yield(Args&&... args): value { forward<Args>(args)... } {}
};
struct Guard{
utility::Span value;
template<typename... Args>
Guard(Args&&... args): value { forward<Args>(args)... } {}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct Token : public Variant<Token_Details::SingleQuotedString, Token_Details::SingleQuotedByteString, Token_Details::QuotedString, Token_Details::Number, Token_Details::Identifier, Token_Details::Semicolon, Token_Details::Colon, Token_Details::ColonColon, Token_Details::LParen, Token_Details::RParen, Token_Details::LCurly, Token_Details::RCurly, Token_Details::LSquare, Token_Details::RSquare, Token_Details::PercentSign, Token_Details::Plus, Token_Details::Minus, Token_Details::Equal, Token_Details::PlusEqual, Token_Details::PlusPlus, Token_Details::MinusEqual, Token_Details::MinusMinus, Token_Details::AsteriskEqual, Token_Details::ForwardSlashEqual, Token_Details::PercentSignEqual, Token_Details::NotEqual, Token_Details::DoubleEqual, Token_Details::GreaterThan, Token_Details::GreaterThanOrEqual, Token_Details::LessThan, Token_Details::LessThanOrEqual, Token_Details::LeftArithmeticShift, Token_Details::LeftShift, Token_Details::LeftShiftEqual, Token_Details::RightShift, Token_Details::RightArithmeticShift, Token_Details::RightShiftEqual, Token_Details::Asterisk, Token_Details::Ampersand, Token_Details::AmpersandEqual, Token_Details::Pipe, Token_Details::PipeEqual, Token_Details::Caret, Token_Details::CaretEqual, Token_Details::Dollar, Token_Details::Tilde, Token_Details::ForwardSlash, Token_Details::ExclamationPoint, Token_Details::QuestionMark, Token_Details::QuestionMarkQuestionMark, Token_Details::QuestionMarkQuestionMarkEqual, Token_Details::Comma, Token_Details::Dot, Token_Details::DotDot, Token_Details::Eol, Token_Details::Eof, Token_Details::FatArrow, Token_Details::Arrow, Token_Details::And, Token_Details::Anon, Token_Details::As, Token_Details::Boxed, Token_Details::Break, Token_Details::Catch, Token_Details::Class, Token_Details::Continue, Token_Details::Cpp, Token_Details::Defer, Token_Details::Else, Token_Details::Enum, Token_Details::Extern, Token_Details::False, Token_Details::For, Token_Details::Function, Token_Details::Comptime, Token_Details::If, Token_Details::Import, Token_Details::In, Token_Details::Is, Token_Details::Let, Token_Details::Loop, Token_Details::Match, Token_Details::Mut, Token_Details::Namespace, Token_Details::Not, Token_Details::Or, Token_Details::Private, Token_Details::Public, Token_Details::Raw, Token_Details::Return, Token_Details::Restricted, Token_Details::Struct, Token_Details::This, Token_Details::Throw, Token_Details::Throws, Token_Details::True, Token_Details::Try, Token_Details::Unsafe, Token_Details::Weak, Token_Details::While, Token_Details::Yield, Token_Details::Guard, Token_Details::Garbage> {
using Variant<Token_Details::SingleQuotedString, Token_Details::SingleQuotedByteString, Token_Details::QuotedString, Token_Details::Number, Token_Details::Identifier, Token_Details::Semicolon, Token_Details::Colon, Token_Details::ColonColon, Token_Details::LParen, Token_Details::RParen, Token_Details::LCurly, Token_Details::RCurly, Token_Details::LSquare, Token_Details::RSquare, Token_Details::PercentSign, Token_Details::Plus, Token_Details::Minus, Token_Details::Equal, Token_Details::PlusEqual, Token_Details::PlusPlus, Token_Details::MinusEqual, Token_Details::MinusMinus, Token_Details::AsteriskEqual, Token_Details::ForwardSlashEqual, Token_Details::PercentSignEqual, Token_Details::NotEqual, Token_Details::DoubleEqual, Token_Details::GreaterThan, Token_Details::GreaterThanOrEqual, Token_Details::LessThan, Token_Details::LessThanOrEqual, Token_Details::LeftArithmeticShift, Token_Details::LeftShift, Token_Details::LeftShiftEqual, Token_Details::RightShift, Token_Details::RightArithmeticShift, Token_Details::RightShiftEqual, Token_Details::Asterisk, Token_Details::Ampersand, Token_Details::AmpersandEqual, Token_Details::Pipe, Token_Details::PipeEqual, Token_Details::Caret, Token_Details::CaretEqual, Token_Details::Dollar, Token_Details::Tilde, Token_Details::ForwardSlash, Token_Details::ExclamationPoint, Token_Details::QuestionMark, Token_Details::QuestionMarkQuestionMark, Token_Details::QuestionMarkQuestionMarkEqual, Token_Details::Comma, Token_Details::Dot, Token_Details::DotDot, Token_Details::Eol, Token_Details::Eof, Token_Details::FatArrow, Token_Details::Arrow, Token_Details::And, Token_Details::Anon, Token_Details::As, Token_Details::Boxed, Token_Details::Break, Token_Details::Catch, Token_Details::Class, Token_Details::Continue, Token_Details::Cpp, Token_Details::Defer, Token_Details::Else, Token_Details::Enum, Token_Details::Extern, Token_Details::False, Token_Details::For, Token_Details::Function, Token_Details::Comptime, Token_Details::If, Token_Details::Import, Token_Details::In, Token_Details::Is, Token_Details::Let, Token_Details::Loop, Token_Details::Match, Token_Details::Mut, Token_Details::Namespace, Token_Details::Not, Token_Details::Or, Token_Details::Private, Token_Details::Public, Token_Details::Raw, Token_Details::Return, Token_Details::Restricted, Token_Details::Struct, Token_Details::This, Token_Details::Throw, Token_Details::Throws, Token_Details::True, Token_Details::Try, Token_Details::Unsafe, Token_Details::Weak, Token_Details::While, Token_Details::Yield, Token_Details::Guard, Token_Details::Garbage>::Variant;
    using SingleQuotedString = Token_Details::SingleQuotedString;
    using SingleQuotedByteString = Token_Details::SingleQuotedByteString;
    using QuotedString = Token_Details::QuotedString;
    using Number = Token_Details::Number;
    using Identifier = Token_Details::Identifier;
    using Semicolon = Token_Details::Semicolon;
    using Colon = Token_Details::Colon;
    using ColonColon = Token_Details::ColonColon;
    using LParen = Token_Details::LParen;
    using RParen = Token_Details::RParen;
    using LCurly = Token_Details::LCurly;
    using RCurly = Token_Details::RCurly;
    using LSquare = Token_Details::LSquare;
    using RSquare = Token_Details::RSquare;
    using PercentSign = Token_Details::PercentSign;
    using Plus = Token_Details::Plus;
    using Minus = Token_Details::Minus;
    using Equal = Token_Details::Equal;
    using PlusEqual = Token_Details::PlusEqual;
    using PlusPlus = Token_Details::PlusPlus;
    using MinusEqual = Token_Details::MinusEqual;
    using MinusMinus = Token_Details::MinusMinus;
    using AsteriskEqual = Token_Details::AsteriskEqual;
    using ForwardSlashEqual = Token_Details::ForwardSlashEqual;
    using PercentSignEqual = Token_Details::PercentSignEqual;
    using NotEqual = Token_Details::NotEqual;
    using DoubleEqual = Token_Details::DoubleEqual;
    using GreaterThan = Token_Details::GreaterThan;
    using GreaterThanOrEqual = Token_Details::GreaterThanOrEqual;
    using LessThan = Token_Details::LessThan;
    using LessThanOrEqual = Token_Details::LessThanOrEqual;
    using LeftArithmeticShift = Token_Details::LeftArithmeticShift;
    using LeftShift = Token_Details::LeftShift;
    using LeftShiftEqual = Token_Details::LeftShiftEqual;
    using RightShift = Token_Details::RightShift;
    using RightArithmeticShift = Token_Details::RightArithmeticShift;
    using RightShiftEqual = Token_Details::RightShiftEqual;
    using Asterisk = Token_Details::Asterisk;
    using Ampersand = Token_Details::Ampersand;
    using AmpersandEqual = Token_Details::AmpersandEqual;
    using Pipe = Token_Details::Pipe;
    using PipeEqual = Token_Details::PipeEqual;
    using Caret = Token_Details::Caret;
    using CaretEqual = Token_Details::CaretEqual;
    using Dollar = Token_Details::Dollar;
    using Tilde = Token_Details::Tilde;
    using ForwardSlash = Token_Details::ForwardSlash;
    using ExclamationPoint = Token_Details::ExclamationPoint;
    using QuestionMark = Token_Details::QuestionMark;
    using QuestionMarkQuestionMark = Token_Details::QuestionMarkQuestionMark;
    using QuestionMarkQuestionMarkEqual = Token_Details::QuestionMarkQuestionMarkEqual;
    using Comma = Token_Details::Comma;
    using Dot = Token_Details::Dot;
    using DotDot = Token_Details::DotDot;
    using Eol = Token_Details::Eol;
    using Eof = Token_Details::Eof;
    using FatArrow = Token_Details::FatArrow;
    using Arrow = Token_Details::Arrow;
    using And = Token_Details::And;
    using Anon = Token_Details::Anon;
    using As = Token_Details::As;
    using Boxed = Token_Details::Boxed;
    using Break = Token_Details::Break;
    using Catch = Token_Details::Catch;
    using Class = Token_Details::Class;
    using Continue = Token_Details::Continue;
    using Cpp = Token_Details::Cpp;
    using Defer = Token_Details::Defer;
    using Else = Token_Details::Else;
    using Enum = Token_Details::Enum;
    using Extern = Token_Details::Extern;
    using False = Token_Details::False;
    using For = Token_Details::For;
    using Function = Token_Details::Function;
    using Comptime = Token_Details::Comptime;
    using If = Token_Details::If;
    using Import = Token_Details::Import;
    using In = Token_Details::In;
    using Is = Token_Details::Is;
    using Let = Token_Details::Let;
    using Loop = Token_Details::Loop;
    using Match = Token_Details::Match;
    using Mut = Token_Details::Mut;
    using Namespace = Token_Details::Namespace;
    using Not = Token_Details::Not;
    using Or = Token_Details::Or;
    using Private = Token_Details::Private;
    using Public = Token_Details::Public;
    using Raw = Token_Details::Raw;
    using Return = Token_Details::Return;
    using Restricted = Token_Details::Restricted;
    using Struct = Token_Details::Struct;
    using This = Token_Details::This;
    using Throw = Token_Details::Throw;
    using Throws = Token_Details::Throws;
    using True = Token_Details::True;
    using Try = Token_Details::Try;
    using Unsafe = Token_Details::Unsafe;
    using Weak = Token_Details::Weak;
    using While = Token_Details::While;
    using Yield = Token_Details::Yield;
    using Guard = Token_Details::Guard;
    using Garbage = Token_Details::Garbage;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* SingleQuotedString */: {
[[maybe_unused]] auto const& that = this->template get<Token::SingleQuotedString>();
TRY(builder.append("Token::SingleQuotedString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("quote: \"{}\"", that.quote));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* SingleQuotedByteString */: {
[[maybe_unused]] auto const& that = this->template get<Token::SingleQuotedByteString>();
TRY(builder.append("Token::SingleQuotedByteString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("quote: \"{}\"", that.quote));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* QuotedString */: {
[[maybe_unused]] auto const& that = this->template get<Token::QuotedString>();
TRY(builder.append("Token::QuotedString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("quote: \"{}\"", that.quote));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* Number */: {
[[maybe_unused]] auto const& that = this->template get<Token::Number>();
TRY(builder.append("Token::Number"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("number: {}", that.number));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* Identifier */: {
[[maybe_unused]] auto const& that = this->template get<Token::Identifier>();
TRY(builder.append("Token::Identifier"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* Semicolon */: {
[[maybe_unused]] auto const& that = this->template get<Token::Semicolon>();
TRY(builder.append("Token::Semicolon"));
TRY(builder.appendff("({})", that.value));
break;}
case 6 /* Colon */: {
[[maybe_unused]] auto const& that = this->template get<Token::Colon>();
TRY(builder.append("Token::Colon"));
TRY(builder.appendff("({})", that.value));
break;}
case 7 /* ColonColon */: {
[[maybe_unused]] auto const& that = this->template get<Token::ColonColon>();
TRY(builder.append("Token::ColonColon"));
TRY(builder.appendff("({})", that.value));
break;}
case 8 /* LParen */: {
[[maybe_unused]] auto const& that = this->template get<Token::LParen>();
TRY(builder.append("Token::LParen"));
TRY(builder.appendff("({})", that.value));
break;}
case 9 /* RParen */: {
[[maybe_unused]] auto const& that = this->template get<Token::RParen>();
TRY(builder.append("Token::RParen"));
TRY(builder.appendff("({})", that.value));
break;}
case 10 /* LCurly */: {
[[maybe_unused]] auto const& that = this->template get<Token::LCurly>();
TRY(builder.append("Token::LCurly"));
TRY(builder.appendff("({})", that.value));
break;}
case 11 /* RCurly */: {
[[maybe_unused]] auto const& that = this->template get<Token::RCurly>();
TRY(builder.append("Token::RCurly"));
TRY(builder.appendff("({})", that.value));
break;}
case 12 /* LSquare */: {
[[maybe_unused]] auto const& that = this->template get<Token::LSquare>();
TRY(builder.append("Token::LSquare"));
TRY(builder.appendff("({})", that.value));
break;}
case 13 /* RSquare */: {
[[maybe_unused]] auto const& that = this->template get<Token::RSquare>();
TRY(builder.append("Token::RSquare"));
TRY(builder.appendff("({})", that.value));
break;}
case 14 /* PercentSign */: {
[[maybe_unused]] auto const& that = this->template get<Token::PercentSign>();
TRY(builder.append("Token::PercentSign"));
TRY(builder.appendff("({})", that.value));
break;}
case 15 /* Plus */: {
[[maybe_unused]] auto const& that = this->template get<Token::Plus>();
TRY(builder.append("Token::Plus"));
TRY(builder.appendff("({})", that.value));
break;}
case 16 /* Minus */: {
[[maybe_unused]] auto const& that = this->template get<Token::Minus>();
TRY(builder.append("Token::Minus"));
TRY(builder.appendff("({})", that.value));
break;}
case 17 /* Equal */: {
[[maybe_unused]] auto const& that = this->template get<Token::Equal>();
TRY(builder.append("Token::Equal"));
TRY(builder.appendff("({})", that.value));
break;}
case 18 /* PlusEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::PlusEqual>();
TRY(builder.append("Token::PlusEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 19 /* PlusPlus */: {
[[maybe_unused]] auto const& that = this->template get<Token::PlusPlus>();
TRY(builder.append("Token::PlusPlus"));
TRY(builder.appendff("({})", that.value));
break;}
case 20 /* MinusEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::MinusEqual>();
TRY(builder.append("Token::MinusEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 21 /* MinusMinus */: {
[[maybe_unused]] auto const& that = this->template get<Token::MinusMinus>();
TRY(builder.append("Token::MinusMinus"));
TRY(builder.appendff("({})", that.value));
break;}
case 22 /* AsteriskEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::AsteriskEqual>();
TRY(builder.append("Token::AsteriskEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 23 /* ForwardSlashEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::ForwardSlashEqual>();
TRY(builder.append("Token::ForwardSlashEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 24 /* PercentSignEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::PercentSignEqual>();
TRY(builder.append("Token::PercentSignEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 25 /* NotEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::NotEqual>();
TRY(builder.append("Token::NotEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 26 /* DoubleEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::DoubleEqual>();
TRY(builder.append("Token::DoubleEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 27 /* GreaterThan */: {
[[maybe_unused]] auto const& that = this->template get<Token::GreaterThan>();
TRY(builder.append("Token::GreaterThan"));
TRY(builder.appendff("({})", that.value));
break;}
case 28 /* GreaterThanOrEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::GreaterThanOrEqual>();
TRY(builder.append("Token::GreaterThanOrEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 29 /* LessThan */: {
[[maybe_unused]] auto const& that = this->template get<Token::LessThan>();
TRY(builder.append("Token::LessThan"));
TRY(builder.appendff("({})", that.value));
break;}
case 30 /* LessThanOrEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::LessThanOrEqual>();
TRY(builder.append("Token::LessThanOrEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 31 /* LeftArithmeticShift */: {
[[maybe_unused]] auto const& that = this->template get<Token::LeftArithmeticShift>();
TRY(builder.append("Token::LeftArithmeticShift"));
TRY(builder.appendff("({})", that.value));
break;}
case 32 /* LeftShift */: {
[[maybe_unused]] auto const& that = this->template get<Token::LeftShift>();
TRY(builder.append("Token::LeftShift"));
TRY(builder.appendff("({})", that.value));
break;}
case 33 /* LeftShiftEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::LeftShiftEqual>();
TRY(builder.append("Token::LeftShiftEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 34 /* RightShift */: {
[[maybe_unused]] auto const& that = this->template get<Token::RightShift>();
TRY(builder.append("Token::RightShift"));
TRY(builder.appendff("({})", that.value));
break;}
case 35 /* RightArithmeticShift */: {
[[maybe_unused]] auto const& that = this->template get<Token::RightArithmeticShift>();
TRY(builder.append("Token::RightArithmeticShift"));
TRY(builder.appendff("({})", that.value));
break;}
case 36 /* RightShiftEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::RightShiftEqual>();
TRY(builder.append("Token::RightShiftEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 37 /* Asterisk */: {
[[maybe_unused]] auto const& that = this->template get<Token::Asterisk>();
TRY(builder.append("Token::Asterisk"));
TRY(builder.appendff("({})", that.value));
break;}
case 38 /* Ampersand */: {
[[maybe_unused]] auto const& that = this->template get<Token::Ampersand>();
TRY(builder.append("Token::Ampersand"));
TRY(builder.appendff("({})", that.value));
break;}
case 39 /* AmpersandEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::AmpersandEqual>();
TRY(builder.append("Token::AmpersandEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 40 /* Pipe */: {
[[maybe_unused]] auto const& that = this->template get<Token::Pipe>();
TRY(builder.append("Token::Pipe"));
TRY(builder.appendff("({})", that.value));
break;}
case 41 /* PipeEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::PipeEqual>();
TRY(builder.append("Token::PipeEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 42 /* Caret */: {
[[maybe_unused]] auto const& that = this->template get<Token::Caret>();
TRY(builder.append("Token::Caret"));
TRY(builder.appendff("({})", that.value));
break;}
case 43 /* CaretEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::CaretEqual>();
TRY(builder.append("Token::CaretEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 44 /* Dollar */: {
[[maybe_unused]] auto const& that = this->template get<Token::Dollar>();
TRY(builder.append("Token::Dollar"));
TRY(builder.appendff("({})", that.value));
break;}
case 45 /* Tilde */: {
[[maybe_unused]] auto const& that = this->template get<Token::Tilde>();
TRY(builder.append("Token::Tilde"));
TRY(builder.appendff("({})", that.value));
break;}
case 46 /* ForwardSlash */: {
[[maybe_unused]] auto const& that = this->template get<Token::ForwardSlash>();
TRY(builder.append("Token::ForwardSlash"));
TRY(builder.appendff("({})", that.value));
break;}
case 47 /* ExclamationPoint */: {
[[maybe_unused]] auto const& that = this->template get<Token::ExclamationPoint>();
TRY(builder.append("Token::ExclamationPoint"));
TRY(builder.appendff("({})", that.value));
break;}
case 48 /* QuestionMark */: {
[[maybe_unused]] auto const& that = this->template get<Token::QuestionMark>();
TRY(builder.append("Token::QuestionMark"));
TRY(builder.appendff("({})", that.value));
break;}
case 49 /* QuestionMarkQuestionMark */: {
[[maybe_unused]] auto const& that = this->template get<Token::QuestionMarkQuestionMark>();
TRY(builder.append("Token::QuestionMarkQuestionMark"));
TRY(builder.appendff("({})", that.value));
break;}
case 50 /* QuestionMarkQuestionMarkEqual */: {
[[maybe_unused]] auto const& that = this->template get<Token::QuestionMarkQuestionMarkEqual>();
TRY(builder.append("Token::QuestionMarkQuestionMarkEqual"));
TRY(builder.appendff("({})", that.value));
break;}
case 51 /* Comma */: {
[[maybe_unused]] auto const& that = this->template get<Token::Comma>();
TRY(builder.append("Token::Comma"));
TRY(builder.appendff("({})", that.value));
break;}
case 52 /* Dot */: {
[[maybe_unused]] auto const& that = this->template get<Token::Dot>();
TRY(builder.append("Token::Dot"));
TRY(builder.appendff("({})", that.value));
break;}
case 53 /* DotDot */: {
[[maybe_unused]] auto const& that = this->template get<Token::DotDot>();
TRY(builder.append("Token::DotDot"));
TRY(builder.appendff("({})", that.value));
break;}
case 54 /* Eol */: {
[[maybe_unused]] auto const& that = this->template get<Token::Eol>();
TRY(builder.append("Token::Eol"));
TRY(builder.appendff("({})", that.value));
break;}
case 55 /* Eof */: {
[[maybe_unused]] auto const& that = this->template get<Token::Eof>();
TRY(builder.append("Token::Eof"));
TRY(builder.appendff("({})", that.value));
break;}
case 56 /* FatArrow */: {
[[maybe_unused]] auto const& that = this->template get<Token::FatArrow>();
TRY(builder.append("Token::FatArrow"));
TRY(builder.appendff("({})", that.value));
break;}
case 57 /* Arrow */: {
[[maybe_unused]] auto const& that = this->template get<Token::Arrow>();
TRY(builder.append("Token::Arrow"));
TRY(builder.appendff("({})", that.value));
break;}
case 58 /* And */: {
[[maybe_unused]] auto const& that = this->template get<Token::And>();
TRY(builder.append("Token::And"));
TRY(builder.appendff("({})", that.value));
break;}
case 59 /* Anon */: {
[[maybe_unused]] auto const& that = this->template get<Token::Anon>();
TRY(builder.append("Token::Anon"));
TRY(builder.appendff("({})", that.value));
break;}
case 60 /* As */: {
[[maybe_unused]] auto const& that = this->template get<Token::As>();
TRY(builder.append("Token::As"));
TRY(builder.appendff("({})", that.value));
break;}
case 61 /* Boxed */: {
[[maybe_unused]] auto const& that = this->template get<Token::Boxed>();
TRY(builder.append("Token::Boxed"));
TRY(builder.appendff("({})", that.value));
break;}
case 62 /* Break */: {
[[maybe_unused]] auto const& that = this->template get<Token::Break>();
TRY(builder.append("Token::Break"));
TRY(builder.appendff("({})", that.value));
break;}
case 63 /* Catch */: {
[[maybe_unused]] auto const& that = this->template get<Token::Catch>();
TRY(builder.append("Token::Catch"));
TRY(builder.appendff("({})", that.value));
break;}
case 64 /* Class */: {
[[maybe_unused]] auto const& that = this->template get<Token::Class>();
TRY(builder.append("Token::Class"));
TRY(builder.appendff("({})", that.value));
break;}
case 65 /* Continue */: {
[[maybe_unused]] auto const& that = this->template get<Token::Continue>();
TRY(builder.append("Token::Continue"));
TRY(builder.appendff("({})", that.value));
break;}
case 66 /* Cpp */: {
[[maybe_unused]] auto const& that = this->template get<Token::Cpp>();
TRY(builder.append("Token::Cpp"));
TRY(builder.appendff("({})", that.value));
break;}
case 67 /* Defer */: {
[[maybe_unused]] auto const& that = this->template get<Token::Defer>();
TRY(builder.append("Token::Defer"));
TRY(builder.appendff("({})", that.value));
break;}
case 68 /* Else */: {
[[maybe_unused]] auto const& that = this->template get<Token::Else>();
TRY(builder.append("Token::Else"));
TRY(builder.appendff("({})", that.value));
break;}
case 69 /* Enum */: {
[[maybe_unused]] auto const& that = this->template get<Token::Enum>();
TRY(builder.append("Token::Enum"));
TRY(builder.appendff("({})", that.value));
break;}
case 70 /* Extern */: {
[[maybe_unused]] auto const& that = this->template get<Token::Extern>();
TRY(builder.append("Token::Extern"));
TRY(builder.appendff("({})", that.value));
break;}
case 71 /* False */: {
[[maybe_unused]] auto const& that = this->template get<Token::False>();
TRY(builder.append("Token::False"));
TRY(builder.appendff("({})", that.value));
break;}
case 72 /* For */: {
[[maybe_unused]] auto const& that = this->template get<Token::For>();
TRY(builder.append("Token::For"));
TRY(builder.appendff("({})", that.value));
break;}
case 73 /* Function */: {
[[maybe_unused]] auto const& that = this->template get<Token::Function>();
TRY(builder.append("Token::Function"));
TRY(builder.appendff("({})", that.value));
break;}
case 74 /* Comptime */: {
[[maybe_unused]] auto const& that = this->template get<Token::Comptime>();
TRY(builder.append("Token::Comptime"));
TRY(builder.appendff("({})", that.value));
break;}
case 75 /* If */: {
[[maybe_unused]] auto const& that = this->template get<Token::If>();
TRY(builder.append("Token::If"));
TRY(builder.appendff("({})", that.value));
break;}
case 76 /* Import */: {
[[maybe_unused]] auto const& that = this->template get<Token::Import>();
TRY(builder.append("Token::Import"));
TRY(builder.appendff("({})", that.value));
break;}
case 77 /* In */: {
[[maybe_unused]] auto const& that = this->template get<Token::In>();
TRY(builder.append("Token::In"));
TRY(builder.appendff("({})", that.value));
break;}
case 78 /* Is */: {
[[maybe_unused]] auto const& that = this->template get<Token::Is>();
TRY(builder.append("Token::Is"));
TRY(builder.appendff("({})", that.value));
break;}
case 79 /* Let */: {
[[maybe_unused]] auto const& that = this->template get<Token::Let>();
TRY(builder.append("Token::Let"));
TRY(builder.appendff("({})", that.value));
break;}
case 80 /* Loop */: {
[[maybe_unused]] auto const& that = this->template get<Token::Loop>();
TRY(builder.append("Token::Loop"));
TRY(builder.appendff("({})", that.value));
break;}
case 81 /* Match */: {
[[maybe_unused]] auto const& that = this->template get<Token::Match>();
TRY(builder.append("Token::Match"));
TRY(builder.appendff("({})", that.value));
break;}
case 82 /* Mut */: {
[[maybe_unused]] auto const& that = this->template get<Token::Mut>();
TRY(builder.append("Token::Mut"));
TRY(builder.appendff("({})", that.value));
break;}
case 83 /* Namespace */: {
[[maybe_unused]] auto const& that = this->template get<Token::Namespace>();
TRY(builder.append("Token::Namespace"));
TRY(builder.appendff("({})", that.value));
break;}
case 84 /* Not */: {
[[maybe_unused]] auto const& that = this->template get<Token::Not>();
TRY(builder.append("Token::Not"));
TRY(builder.appendff("({})", that.value));
break;}
case 85 /* Or */: {
[[maybe_unused]] auto const& that = this->template get<Token::Or>();
TRY(builder.append("Token::Or"));
TRY(builder.appendff("({})", that.value));
break;}
case 86 /* Private */: {
[[maybe_unused]] auto const& that = this->template get<Token::Private>();
TRY(builder.append("Token::Private"));
TRY(builder.appendff("({})", that.value));
break;}
case 87 /* Public */: {
[[maybe_unused]] auto const& that = this->template get<Token::Public>();
TRY(builder.append("Token::Public"));
TRY(builder.appendff("({})", that.value));
break;}
case 88 /* Raw */: {
[[maybe_unused]] auto const& that = this->template get<Token::Raw>();
TRY(builder.append("Token::Raw"));
TRY(builder.appendff("({})", that.value));
break;}
case 89 /* Return */: {
[[maybe_unused]] auto const& that = this->template get<Token::Return>();
TRY(builder.append("Token::Return"));
TRY(builder.appendff("({})", that.value));
break;}
case 90 /* Restricted */: {
[[maybe_unused]] auto const& that = this->template get<Token::Restricted>();
TRY(builder.append("Token::Restricted"));
TRY(builder.appendff("({})", that.value));
break;}
case 91 /* Struct */: {
[[maybe_unused]] auto const& that = this->template get<Token::Struct>();
TRY(builder.append("Token::Struct"));
TRY(builder.appendff("({})", that.value));
break;}
case 92 /* This */: {
[[maybe_unused]] auto const& that = this->template get<Token::This>();
TRY(builder.append("Token::This"));
TRY(builder.appendff("({})", that.value));
break;}
case 93 /* Throw */: {
[[maybe_unused]] auto const& that = this->template get<Token::Throw>();
TRY(builder.append("Token::Throw"));
TRY(builder.appendff("({})", that.value));
break;}
case 94 /* Throws */: {
[[maybe_unused]] auto const& that = this->template get<Token::Throws>();
TRY(builder.append("Token::Throws"));
TRY(builder.appendff("({})", that.value));
break;}
case 95 /* True */: {
[[maybe_unused]] auto const& that = this->template get<Token::True>();
TRY(builder.append("Token::True"));
TRY(builder.appendff("({})", that.value));
break;}
case 96 /* Try */: {
[[maybe_unused]] auto const& that = this->template get<Token::Try>();
TRY(builder.append("Token::Try"));
TRY(builder.appendff("({})", that.value));
break;}
case 97 /* Unsafe */: {
[[maybe_unused]] auto const& that = this->template get<Token::Unsafe>();
TRY(builder.append("Token::Unsafe"));
TRY(builder.appendff("({})", that.value));
break;}
case 98 /* Weak */: {
[[maybe_unused]] auto const& that = this->template get<Token::Weak>();
TRY(builder.append("Token::Weak"));
TRY(builder.appendff("({})", that.value));
break;}
case 99 /* While */: {
[[maybe_unused]] auto const& that = this->template get<Token::While>();
TRY(builder.append("Token::While"));
TRY(builder.appendff("({})", that.value));
break;}
case 100 /* Yield */: {
[[maybe_unused]] auto const& that = this->template get<Token::Yield>();
TRY(builder.append("Token::Yield"));
TRY(builder.appendff("({})", that.value));
break;}
case 101 /* Guard */: {
[[maybe_unused]] auto const& that = this->template get<Token::Guard>();
TRY(builder.append("Token::Guard"));
TRY(builder.appendff("({})", that.value));
break;}
case 102 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<Token::Garbage>();
TRY(builder.append("Token::Garbage"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}static lexer::Token from_keyword_or_identifier(const String string, const utility::Span span);
utility::Span span() const;
};
namespace LiteralSuffix_Details {
struct None {};
struct UZ {};
struct U8 {};
struct U16 {};
struct U32 {};
struct U64 {};
struct I8 {};
struct I16 {};
struct I32 {};
struct I64 {};
struct F32 {};
struct F64 {};
}
struct LiteralSuffix : public Variant<LiteralSuffix_Details::None, LiteralSuffix_Details::UZ, LiteralSuffix_Details::U8, LiteralSuffix_Details::U16, LiteralSuffix_Details::U32, LiteralSuffix_Details::U64, LiteralSuffix_Details::I8, LiteralSuffix_Details::I16, LiteralSuffix_Details::I32, LiteralSuffix_Details::I64, LiteralSuffix_Details::F32, LiteralSuffix_Details::F64> {
using Variant<LiteralSuffix_Details::None, LiteralSuffix_Details::UZ, LiteralSuffix_Details::U8, LiteralSuffix_Details::U16, LiteralSuffix_Details::U32, LiteralSuffix_Details::U64, LiteralSuffix_Details::I8, LiteralSuffix_Details::I16, LiteralSuffix_Details::I32, LiteralSuffix_Details::I64, LiteralSuffix_Details::F32, LiteralSuffix_Details::F64>::Variant;
    using None = LiteralSuffix_Details::None;
    using UZ = LiteralSuffix_Details::UZ;
    using U8 = LiteralSuffix_Details::U8;
    using U16 = LiteralSuffix_Details::U16;
    using U32 = LiteralSuffix_Details::U32;
    using U64 = LiteralSuffix_Details::U64;
    using I8 = LiteralSuffix_Details::I8;
    using I16 = LiteralSuffix_Details::I16;
    using I32 = LiteralSuffix_Details::I32;
    using I64 = LiteralSuffix_Details::I64;
    using F32 = LiteralSuffix_Details::F32;
    using F64 = LiteralSuffix_Details::F64;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* None */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::None>();
TRY(builder.append("LiteralSuffix::None"));
break;}
case 1 /* UZ */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::UZ>();
TRY(builder.append("LiteralSuffix::UZ"));
break;}
case 2 /* U8 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::U8>();
TRY(builder.append("LiteralSuffix::U8"));
break;}
case 3 /* U16 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::U16>();
TRY(builder.append("LiteralSuffix::U16"));
break;}
case 4 /* U32 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::U32>();
TRY(builder.append("LiteralSuffix::U32"));
break;}
case 5 /* U64 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::U64>();
TRY(builder.append("LiteralSuffix::U64"));
break;}
case 6 /* I8 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::I8>();
TRY(builder.append("LiteralSuffix::I8"));
break;}
case 7 /* I16 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::I16>();
TRY(builder.append("LiteralSuffix::I16"));
break;}
case 8 /* I32 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::I32>();
TRY(builder.append("LiteralSuffix::I32"));
break;}
case 9 /* I64 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::I64>();
TRY(builder.append("LiteralSuffix::I64"));
break;}
case 10 /* F32 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::F32>();
TRY(builder.append("LiteralSuffix::F32"));
break;}
case 11 /* F64 */: {
[[maybe_unused]] auto const& that = this->template get<LiteralSuffix::F64>();
TRY(builder.append("LiteralSuffix::F64"));
break;}
}
return builder.to_string();
}};
static bool is_ascii_alphanumeric(const u8 c) {
{
return ((lexer::is_ascii_alpha(c) || lexer::is_ascii_digit(c)));
}
}

static bool is_ascii_alpha(const u8 c) {
{
return ((((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))));
}
}

static f32 f64_to_f32(const f64 number) {
{
f32 f32_value = static_cast<i64>(0LL);
{
f32_value = (f32)number;
}

return (f32_value);
}
}

static ErrorOr<lexer::Token> make_float_token(const f64 number,const lexer::LiteralSuffix suffix,const utility::Span span) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(typename lexer::Token::Number(typename lexer::NumericConstant::F32(lexer::f64_to_f32(number)),span));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(typename lexer::Token::Number(typename lexer::NumericConstant::F64(number),span));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename lexer::Token::Garbage(span));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static bool is_ascii_octdigit(const u8 c) {
{
return (((c >= '0') && (c <= '7')));
}
}

static bool is_ascii_hexdigit(const u8 c) {
{
return (((((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'f'))) || ((c >= 'A') && (c <= 'F'))));
}
}

template <typename T>
static T u64_to_float(const u64 number) {
{
i64 float_value = static_cast<i64>(0LL);
{
float_value = number;
}

return (float_value);
}
}

static bool is_ascii_digit(const u8 c) {
{
return (((c >= '0') && (c <= '9')));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_quoted_string(const u8 delimiter) {
{
const size_t start = ((*this).index);
(++(((*this).index)));
if (((*this).eof())){
TRY((((*this).error(String("unexpected eof"),((*this).span(start,start))))));
return (typename lexer::Token::Garbage(((*this).span(start,start))));
}
bool escaped = false;
while (((!(((*this).eof()))) && (escaped || (((*this).peek()) != delimiter)))){
if (((((*this).peek()) == '\r') || (((*this).peek()) == '\n'))){
(++(((*this).index)));
continue;
}
if (((!(escaped)) && (((*this).peek()) == '\\'))){
(escaped = true);
}
else {
(escaped = false);
}

(++(((*this).index)));
}
const String str = TRY((((*this).substring((JaktInternal::checked_add<size_t>(start,static_cast<size_t>(1ULL))),((*this).index)))));
((((*this).index)++));
const size_t end = ((*this).index);
if ((delimiter == '\'')){
return (typename lexer::Token::SingleQuotedString(str,((*this).span(start,end))));
}
return (typename lexer::Token::QuotedString(str,((*this).span(start,end))));
}
}

ErrorOr<Optional<lexer::Token>> lexer::Lexer::next() {
{
for (;;){
if ((((*this).index) == ((((*this).input)).size()))){
(++(((*this).index)));
return (typename lexer::Token::Eof(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),(JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)))))));
}
if (((*this).eof())){
return (JaktInternal::OptionalNone());
}
const u8 ch = ((*this).peek());
if (((*this).is_whitespace(ch))){
((((*this).index)++));
}
else {
break;
}

}
const size_t start = ((*this).index);
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,ErrorOr<Optional<lexer::Token>>>{
auto __jakt_enum_value = (((((*this).input))[((*this).index)]));
if (__jakt_enum_value == '(') {
return JaktInternal::ExplicitValue(typename lexer::Token::LParen(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == ')') {
return JaktInternal::ExplicitValue(typename lexer::Token::RParen(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '[') {
return JaktInternal::ExplicitValue(typename lexer::Token::LSquare(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == ']') {
return JaktInternal::ExplicitValue(typename lexer::Token::RSquare(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '{') {
return JaktInternal::ExplicitValue(typename lexer::Token::LCurly(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '}') {
return JaktInternal::ExplicitValue(typename lexer::Token::RCurly(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(((*this).lex_less_than()));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(((*this).lex_greater_than()));
}
else if (__jakt_enum_value == '.') {
return JaktInternal::ExplicitValue(((*this).lex_dot()));
}
else if (__jakt_enum_value == ',') {
return JaktInternal::ExplicitValue(typename lexer::Token::Comma(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '~') {
return JaktInternal::ExplicitValue(typename lexer::Token::Tilde(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == ';') {
return JaktInternal::ExplicitValue(typename lexer::Token::Semicolon(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == ':') {
return JaktInternal::ExplicitValue(((*this).lex_colon()));
}
else if (__jakt_enum_value == '?') {
return JaktInternal::ExplicitValue(((*this).lex_question_mark()));
}
else if (__jakt_enum_value == '+') {
return JaktInternal::ExplicitValue(((*this).lex_plus()));
}
else if (__jakt_enum_value == '-') {
return JaktInternal::ExplicitValue(((*this).lex_minus()));
}
else if (__jakt_enum_value == '*') {
return JaktInternal::ExplicitValue(((*this).lex_asterisk()));
}
else if (__jakt_enum_value == '/') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_forward_slash()))));
}
else if (__jakt_enum_value == '^') {
return JaktInternal::ExplicitValue(((*this).lex_caret()));
}
else if (__jakt_enum_value == '|') {
return JaktInternal::ExplicitValue(((*this).lex_pipe()));
}
else if (__jakt_enum_value == '%') {
return JaktInternal::ExplicitValue(((*this).lex_percent_sign()));
}
else if (__jakt_enum_value == '!') {
return JaktInternal::ExplicitValue(((*this).lex_exclamation_point()));
}
else if (__jakt_enum_value == '&') {
return JaktInternal::ExplicitValue(((*this).lex_ampersand()));
}
else if (__jakt_enum_value == '$') {
return JaktInternal::ExplicitValue(typename lexer::Token::Dollar(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(((*this).lex_equals()));
}
else if (__jakt_enum_value == '\n') {
return JaktInternal::ExplicitValue(typename lexer::Token::Eol(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '\'') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_quoted_string('\'')))));
}
else if (__jakt_enum_value == '\"') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_quoted_string('"')))));
}
else if (__jakt_enum_value == 'b') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_character_constant_or_name()))));
}
else if (__jakt_enum_value == 'c') {
return JaktInternal::ExplicitValue(TRY((((*this).lex_character_constant_or_name()))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).lex_number_or_name()))));
}
}()))
);
}
}

bool lexer::Lexer::is_whitespace(const u8 ch) const {
{
return ((((((ch == ' ') || (ch == '\t')) || (ch == '\r')) || (ch == '\f')) || (ch == '\v')));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_character_constant_or_name() {
{
if ((((*this).peek_ahead(static_cast<size_t>(1ULL))) != '\'')){
return (TRY((((*this).lex_number_or_name()))));
}
const bool is_byte = (((*this).peek()) == 'b');
if (is_byte){
((((*this).index)++));
}
const size_t start = ((*this).index);
((((*this).index)++));
bool escaped = false;
while (((!(((*this).eof()))) && (escaped || (((*this).peek()) != '\'')))){
if ((escaped && ((JaktInternal::checked_sub<size_t>(((*this).index),start)) > static_cast<size_t>(3ULL)))){
break;
}
else if (((JaktInternal::checked_sub<size_t>(((*this).index),start)) > static_cast<size_t>(2ULL))){
break;
}
if (((!(escaped)) && (((*this).peek()) == '\\'))){
(escaped = true);
}
((((*this).index)++));
}
if ((((*this).eof()) || (((*this).peek()) != '\''))){
TRY((((*this).error(String("Expected single quote"),((*this).span(start,start))))));
}
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append(((((*this).input))[(JaktInternal::checked_add<size_t>(start,static_cast<size_t>(1ULL)))])))));
if (escaped){
TRY((((builder).append(((((*this).input))[(JaktInternal::checked_add<size_t>(start,static_cast<size_t>(2ULL)))])))));
}
const String quote = TRY((((builder).to_string())));
const size_t end = ((*this).index);
if (is_byte){
return (typename lexer::Token::SingleQuotedByteString(quote,((*this).span(start,end))));
}
return (typename lexer::Token::SingleQuotedString(quote,((*this).span(start,end))));
}
}

lexer::Token lexer::Lexer::lex_dot() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '.') {
return JaktInternal::ExplicitValue(typename lexer::Token::DotDot(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Dot(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::make_integer_token(const u64 number,const lexer::LiteralSuffix suffix,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::None>();
{
const Optional<i64> n = (fallible_integer_cast<i64>((number)));
if (((n).has_value())){
return (typename lexer::Token::Number(typename lexer::NumericConstant::I64((n.value())),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U8>();
{
const Optional<u8> n = (fallible_integer_cast<u8>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U8((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U16>();
{
const Optional<u16> n = (fallible_integer_cast<u16>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U16((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U32>();
{
const Optional<u32> n = (fallible_integer_cast<u32>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U32((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::U64>();
{
const Optional<u64> n = (fallible_integer_cast<u64>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::UZ>();
{
const Optional<size_t> n = (fallible_integer_cast<size_t>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::USize((infallible_integer_cast<u64>(((n.value()))))),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I8>();
{
const Optional<i8> n = (fallible_integer_cast<i8>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I8((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I16>();
{
const Optional<i16> n = (fallible_integer_cast<i16>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I16((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I32>();
{
const Optional<i32> n = (fallible_integer_cast<i32>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I32((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::I64>();
{
const Optional<i64> n = (fallible_integer_cast<i64>((number)));
if ((!(((n).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Number {} cannot fit in integer type {}"),number,suffix))),span))));
return (typename lexer::Token::Number(typename lexer::NumericConstant::U64(number),span));
}
return (typename lexer::Token::Number(typename lexer::NumericConstant::I64((n.value())),span));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (typename lexer::Token::Garbage(span));
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_forward_slash() {
{
const size_t start = ((((*this).index)++));
if ((((*this).peek()) == '=')){
return (typename lexer::Token::ForwardSlashEqual(((*this).span(start,(++(((*this).index)))))));
}
if ((((*this).peek()) != '/')){
return (typename lexer::Token::ForwardSlash(((*this).span(start,((*this).index)))));
}
while ((!(((*this).eof())))){
const u8 c = ((*this).peek());
((((*this).index)++));
if ((c == '\n')){
break;
}
}
return (TRY((((*this).next()))).value_or_lazy_evaluated([&] { return typename lexer::Token::Eof(((*this).span(((*this).index),((*this).index)))); }));
}
}

lexer::Token lexer::Lexer::lex_question_mark() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '?') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_2; {
((((*this).index)++));
__jakt_var_2 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMarkQuestionMarkEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMarkQuestionMark(((*this).span(start,((*this).index)))));
}
}()))
; goto __jakt_label_0;

}
__jakt_label_0:; __jakt_var_2.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::QuestionMark(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

u8 lexer::Lexer::peek_behind(const size_t steps) const {
{
if ((((*this).index) < steps)){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[(JaktInternal::checked_sub<size_t>(((*this).index),steps))]));
}
}

u8 lexer::Lexer::peek_ahead(const size_t steps) const {
{
if (((JaktInternal::checked_add<size_t>(((*this).index),steps)) >= ((((*this).input)).size()))){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[(JaktInternal::checked_add<size_t>(((*this).index),steps))]));
}
}

lexer::Token lexer::Lexer::lex_asterisk() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::AsteriskEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Asterisk(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

u8 lexer::Lexer::peek() const {
{
if (((*this).eof())){
return (static_cast<i64>(0LL));
}
return (((((*this).input))[((*this).index)]));
}
}

lexer::Token lexer::Lexer::lex_percent_sign() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PercentSignEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::PercentSign(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_number_or_name() {
{
const size_t start = ((*this).index);
if (((*this).eof())){
TRY((((*this).error(String("unexpected eof"),((*this).span(start,start))))));
return (typename lexer::Token::Garbage(((*this).span(start,start))));
}
if (lexer::is_ascii_digit(((*this).peek()))){
return (TRY((((*this).lex_number()))));
}
else if ((lexer::is_ascii_alpha(((*this).peek())) || (((*this).peek()) == '_'))){
StringBuilder string_builder = TRY((StringBuilder::create()));
while ((lexer::is_ascii_alphanumeric(((*this).peek())) || (((*this).peek()) == '_'))){
const u8 value = ((((*this).input))[((*this).index)]);
(++(((*this).index)));
TRY((((string_builder).append(value))));
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
const String string = TRY((((string_builder).to_string())));
return (lexer::Token::from_keyword_or_identifier(string,span));
}
const u8 unknown_char = ((((*this).input))[((*this).index)]);
const size_t end = (++(((*this).index)));
TRY((((*this).error(TRY((String::formatted(String("unknown character: {:c}"),unknown_char))),((*this).span(start,end))))));
return (typename lexer::Token::Garbage(((*this).span(start,end))));
}
}

lexer::Token lexer::Lexer::lex_minus() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::MinusEqual(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '-') {
return JaktInternal::ExplicitValue(typename lexer::Token::MinusMinus(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::Arrow(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Minus(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

bool lexer::Lexer::eof() const {
{
return ((((*this).index) >= ((((*this).input)).size())));
}
}

lexer::Token lexer::Lexer::lex_ampersand() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::AmpersandEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Ampersand(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

utility::Span lexer::Lexer::span(const size_t start,const size_t end) const {
{
return (utility::Span((((((*this).compiler))->current_file).value()),start,end));
}
}

lexer::Token lexer::Lexer::lex_plus() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PlusEqual(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '+') {
return JaktInternal::ExplicitValue(typename lexer::Token::PlusPlus(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Plus(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_exclamation_point() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::NotEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::ExclamationPoint(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

Optional<lexer::LiteralSuffix> lexer::Lexer::consume_numeric_literal_suffix() {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == 'u') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'i') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'f') {
{
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
return (JaktInternal::OptionalNone());
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
if (((((*this).peek()) == 'u') && (((*this).peek_ahead(static_cast<size_t>(1ULL))) == 'z'))){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
return (typename lexer::LiteralSuffix::UZ());
}
size_t local_index = static_cast<size_t>(1ULL);
i64 width = static_cast<i64>(0LL);
while (lexer::is_ascii_digit(((*this).peek_ahead(local_index)))){
if ((local_index > static_cast<size_t>(3ULL))){
return (JaktInternal::OptionalNone());
}
const u8 value = ((((*this).input))[(JaktInternal::checked_add<size_t>(((*this).index),local_index))]);
(++(local_index));
const i64 digit = as_saturated<i64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(width = (JaktInternal::checked_add<i64>((JaktInternal::checked_mul<i64>(width,static_cast<i64>(10LL))),digit)));
}
const lexer::LiteralSuffix suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == 'u') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U8());
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U16());
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::U64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else if (__jakt_enum_value == 'i') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I8());
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I16());
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::I64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else if (__jakt_enum_value == 'f') {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,Optional<lexer::LiteralSuffix>>{
auto __jakt_enum_value = (width);
if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F32());
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F64());
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
);
}
else {
{
return (JaktInternal::OptionalNone());
}
}
}()))
;
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, local_index);});
return (suffix);
}
}

lexer::Token lexer::Lexer::lex_colon() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == ':') {
return JaktInternal::ExplicitValue(typename lexer::Token::ColonColon(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Colon(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<void> lexer::Lexer::error(const String message,const utility::Span span) {
{
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
return {};
}

ErrorOr<String> lexer::Lexer::substring(const size_t start,const size_t length) const {
{
StringBuilder builder = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(start),static_cast<size_t>(length)});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((builder).append(((((*this).input))[i])))));
}

}
}

return (TRY((((builder).to_string()))));
}
}

lexer::Token lexer::Lexer::lex_greater_than() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::GreaterThanOrEqual(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_3; {
((((*this).index)++));
__jakt_var_3 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::RightArithmeticShift(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::RightShiftEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::RightShift(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
; goto __jakt_label_1;

}
__jakt_label_1:; __jakt_var_3.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::GreaterThan(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_pipe() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::PipeEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Pipe(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_caret() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::CaretEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Caret(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<lexer::Token> lexer::Lexer::lex_number() {
{
const size_t start = ((*this).index);
u64 total = static_cast<u64>(0ULL);
if ((((*this).peek()) == '0')){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<lexer::Token>>{
auto __jakt_enum_value = (((*this).peek_ahead(static_cast<size_t>(1ULL))));
if (__jakt_enum_value == 'x') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (lexer::is_ascii_hexdigit(((*this).peek()))){
u8 offset = static_cast<u8>(0);
if (((((*this).peek()) >= 'a') && (((*this).peek()) <= 'z'))){
(offset = static_cast<u8>(39));
}
else if (((((*this).peek()) >= 'A') && (((*this).peek()) <= 'Z'))){
(offset = static_cast<u8>(7));
}
const u8 value = (JaktInternal::checked_sub<u8>(((((*this).input))[((*this).index)]),offset));
(++(((*this).index)));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(16ULL))),digit)));
if ((((*this).peek()) == '_')){
(++(((*this).index)));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Hexadecimal number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
return (TRY((((*this).make_integer_token(total,suffix,((*this).span(start,end)))))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'o') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (lexer::is_ascii_octdigit(((*this).peek()))){
const u8 value = ((((*this).input))[((*this).index)]);
(++(((*this).index)));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(8ULL))),digit)));
if ((((*this).peek()) == '_')){
(++(((*this).index)));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Octal number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse octal number"),span))));
return (typename lexer::Token::Garbage(span));
}
return (TRY((((*this).make_integer_token(total,suffix,span)))));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == 'b') {
{
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
while (((((*this).peek()) == '0') || (((*this).peek()) == '1'))){
const u8 value = ((((*this).input))[((*this).index)]);
(++(((*this).index)));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
(total = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(total,static_cast<u64>(2ULL))),digit)));
if ((((*this).peek()) == '_')){
(++(((*this).index)));
}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if ((((*this).peek_behind(static_cast<size_t>(1ULL))) == '_')){
TRY((((*this).error(String("Binary number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return typename lexer::LiteralSuffix::None(); });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse binary number"),span))));
return (typename lexer::Token::Garbage(span));
}
return (TRY((((*this).make_integer_token(total,suffix,span)))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}
bool number_too_large = false;
bool floating = false;
u64 fraction_nominator = static_cast<u64>(0ULL);
u64 fraction_denominator = static_cast<u64>(1ULL);
while ((!(((*this).eof())))){
const u8 value = ((((*this).input))[((*this).index)]);
if ((value == '.')){
if (((!(lexer::is_ascii_digit(((*this).peek_ahead(static_cast<size_t>(1ULL)))))) || floating)){
break;
}
(floating = true);
((((*this).index)++));
continue;
}
else if ((!(lexer::is_ascii_digit(value)))){
break;
}
(++(((*this).index)));
const u64 digit = as_saturated<u64, u8>((JaktInternal::checked_sub<u8>(value,'0')));
if ((!(floating))){
const u64 old_total = total;
(total = unchecked_add<u64>(unchecked_mul<u64>(total,static_cast<u64>(10ULL)),digit));
if ((total < old_total)){
(number_too_large = true);
}
}
else {
(fraction_nominator = (JaktInternal::checked_add<u64>((JaktInternal::checked_mul<u64>(fraction_nominator,static_cast<u64>(10ULL))),digit)));
({auto& _jakt_ref = fraction_denominator;_jakt_ref = JaktInternal::checked_mul<u64>(_jakt_ref, static_cast<u64>(10ULL));});
}

if ((((*this).peek()) == '_')){
if (lexer::is_ascii_digit(((*this).peek_ahead(static_cast<size_t>(1ULL))))){
(++(((*this).index)));
}
else {
break;
}

}
}
const size_t end = ((*this).index);
const utility::Span span = ((*this).span(start,end));
if (number_too_large){
TRY((((*this).error(TRY((String::formatted(String("Integer literal too large")))),span))));
return (typename lexer::Token::Garbage(span));
}
if ((((*this).peek()) == '_')){
TRY((((*this).error(String("Number literal cannot end with underscore"),span))));
return (typename lexer::Token::Garbage(span));
}
const lexer::LiteralSuffix default_suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::LiteralSuffix,ErrorOr<lexer::Token>>{
auto __jakt_enum_value = (floating);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::F64());
}
else {
return JaktInternal::ExplicitValue(typename lexer::LiteralSuffix::None());
}
}()))
;
const lexer::LiteralSuffix suffix = ((*this).consume_numeric_literal_suffix()).value_or_lazy_evaluated([&] { return default_suffix; });
if (lexer::is_ascii_alphanumeric(((*this).peek()))){
TRY((((*this).error(String("Could not parse number"),span))));
return (typename lexer::Token::Garbage(span));
}
const bool is_float_suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
if ((floating && (!(is_float_suffix)))){
return (typename lexer::Token::Garbage(((*this).span(start,((*this).index)))));
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token, ErrorOr<lexer::Token>>{
auto&& __jakt_match_variant = suffix;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F32>();
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_4; {
const f64 number = (lexer::u64_to_float<f64>(total) + (lexer::u64_to_float<f64>(fraction_nominator) / lexer::u64_to_float<f64>(fraction_denominator)));
__jakt_var_4 = TRY((lexer::make_float_token(number,suffix,((*this).span(start,end))))); goto __jakt_label_2;

}
__jakt_label_2:; __jakt_var_4.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::LiteralSuffix::F64>();
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_5; {
const f64 number = (lexer::u64_to_float<f64>(total) + (lexer::u64_to_float<f64>(fraction_nominator) / lexer::u64_to_float<f64>(fraction_denominator)));
__jakt_var_5 = TRY((lexer::make_float_token(number,suffix,((*this).span(start,end))))); goto __jakt_label_3;

}
__jakt_label_3:; __jakt_var_5.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).make_integer_token(total,suffix,((*this).span(start,end)))))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

lexer::Token lexer::Lexer::lex_less_than() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::LessThanOrEqual(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(({ Optional<lexer::Token> __jakt_var_6; {
((((*this).index)++));
__jakt_var_6 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '<') {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftArithmeticShift(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftShiftEqual(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::LeftShift(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
; goto __jakt_label_4;

}
__jakt_label_4:; __jakt_var_6.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::LessThan(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

lexer::Token lexer::Lexer::lex_equals() {
{
const size_t start = ((((*this).index)++));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (((*this).peek()));
if (__jakt_enum_value == '=') {
return JaktInternal::ExplicitValue(typename lexer::Token::DoubleEqual(((*this).span(start,(++(((*this).index)))))));
}
else if (__jakt_enum_value == '>') {
return JaktInternal::ExplicitValue(typename lexer::Token::FatArrow(((*this).span(start,(++(((*this).index)))))));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Equal(((*this).span((JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL))),((*this).index)))));
}
}()))
);
}
}

ErrorOr<Array<lexer::Token>> lexer::Lexer::lex(const NonnullRefPtr<compiler::Compiler> compiler) {
{
lexer::Lexer lexer = lexer::Lexer(static_cast<size_t>(0ULL),((compiler)->current_file_contents),compiler);
Array<lexer::Token> tokens = (TRY((Array<lexer::Token>::create_with({}))));
{
lexer::Lexer _magic = lexer;
for (;;){
Optional<lexer::Token> _magic_value = TRY((((_magic).next())));
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
TRY((((tokens).push(token))));
}

}
}

return (tokens);
}
}

size_t lexer::NumericConstant::to_usize() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t, size_t>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I8>();
i8 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I16>();
i16 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I32>();
i32 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I64>();
i64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U8>();
u8 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U16>();
u16 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U32>();
u32 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U64>();
u64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::USize>();
u64 const& num = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((num))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((static_cast<i64>(0LL)))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

lexer::Token lexer::Token::from_keyword_or_identifier(const String string,const utility::Span span) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<lexer::Token,lexer::Token>{
auto __jakt_enum_value = (string);
if (__jakt_enum_value == String("and")) {
return JaktInternal::ExplicitValue(typename lexer::Token::And(span));
}
else if (__jakt_enum_value == String("anon")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Anon(span));
}
else if (__jakt_enum_value == String("as")) {
return JaktInternal::ExplicitValue(typename lexer::Token::As(span));
}
else if (__jakt_enum_value == String("boxed")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Boxed(span));
}
else if (__jakt_enum_value == String("break")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Break(span));
}
else if (__jakt_enum_value == String("catch")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Catch(span));
}
else if (__jakt_enum_value == String("class")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Class(span));
}
else if (__jakt_enum_value == String("continue")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Continue(span));
}
else if (__jakt_enum_value == String("cpp")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Cpp(span));
}
else if (__jakt_enum_value == String("defer")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Defer(span));
}
else if (__jakt_enum_value == String("else")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Else(span));
}
else if (__jakt_enum_value == String("enum")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Enum(span));
}
else if (__jakt_enum_value == String("extern")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Extern(span));
}
else if (__jakt_enum_value == String("false")) {
return JaktInternal::ExplicitValue(typename lexer::Token::False(span));
}
else if (__jakt_enum_value == String("for")) {
return JaktInternal::ExplicitValue(typename lexer::Token::For(span));
}
else if (__jakt_enum_value == String("function")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Function(span));
}
else if (__jakt_enum_value == String("comptime")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Comptime(span));
}
else if (__jakt_enum_value == String("if")) {
return JaktInternal::ExplicitValue(typename lexer::Token::If(span));
}
else if (__jakt_enum_value == String("import")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Import(span));
}
else if (__jakt_enum_value == String("in")) {
return JaktInternal::ExplicitValue(typename lexer::Token::In(span));
}
else if (__jakt_enum_value == String("is")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Is(span));
}
else if (__jakt_enum_value == String("let")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Let(span));
}
else if (__jakt_enum_value == String("loop")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Loop(span));
}
else if (__jakt_enum_value == String("match")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Match(span));
}
else if (__jakt_enum_value == String("mut")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Mut(span));
}
else if (__jakt_enum_value == String("namespace")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Namespace(span));
}
else if (__jakt_enum_value == String("not")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Not(span));
}
else if (__jakt_enum_value == String("or")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Or(span));
}
else if (__jakt_enum_value == String("private")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Private(span));
}
else if (__jakt_enum_value == String("public")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Public(span));
}
else if (__jakt_enum_value == String("raw")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Raw(span));
}
else if (__jakt_enum_value == String("return")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Return(span));
}
else if (__jakt_enum_value == String("restricted")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Restricted(span));
}
else if (__jakt_enum_value == String("struct")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Struct(span));
}
else if (__jakt_enum_value == String("this")) {
return JaktInternal::ExplicitValue(typename lexer::Token::This(span));
}
else if (__jakt_enum_value == String("throw")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Throw(span));
}
else if (__jakt_enum_value == String("throws")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Throws(span));
}
else if (__jakt_enum_value == String("true")) {
return JaktInternal::ExplicitValue(typename lexer::Token::True(span));
}
else if (__jakt_enum_value == String("try")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Try(span));
}
else if (__jakt_enum_value == String("unsafe")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Unsafe(span));
}
else if (__jakt_enum_value == String("weak")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Weak(span));
}
else if (__jakt_enum_value == String("while")) {
return JaktInternal::ExplicitValue(typename lexer::Token::While(span));
}
else if (__jakt_enum_value == String("yield")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Yield(span));
}
else if (__jakt_enum_value == String("guard")) {
return JaktInternal::ExplicitValue(typename lexer::Token::Guard(span));
}
else {
return JaktInternal::ExplicitValue(typename lexer::Token::Identifier(string,span));
}
}()))
);
}
}

utility::Span lexer::Token::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Colon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 66: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Cpp>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSign>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Plus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 57: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Arrow>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AsteriskEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlashEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSignEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::NotEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DoubleEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThanOrEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThan>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThanOrEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftArithmeticShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShiftEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 34: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 35: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightArithmeticShift>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 36: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShiftEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 39: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AmpersandEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 40: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Pipe>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 41: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PipeEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 42: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Caret>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 43: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::CaretEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 44: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dollar>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 45: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Tilde>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 46: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlash>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 49: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMark>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 50: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMarkEqual>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 53: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DotDot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 55: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eof>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 56: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::FatArrow>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 58: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::And>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 59: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Anon>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 60: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::As>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 62: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 63: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Catch>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 65: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 67: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Defer>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 68: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Else>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 70: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Extern>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 72: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::For>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comptime>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 75: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 76: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Import>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 77: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::In>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 78: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Is>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 79: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Let>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 80: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Loop>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Match>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 83: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Namespace>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 84: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Not>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Or>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 88: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Raw>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Restricted>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 89: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Return>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 92: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 93: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throw>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 94: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throws>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 95: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 96: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Try>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 97: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Unsafe>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 98: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Weak>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 99: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::While>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 100: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Yield>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 101: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Guard>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 102: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace parser {
namespace Visibility_Details {
struct Public {};
struct Private {};
struct Restricted {
Array<NonnullRefPtr<parser::ParsedType>> whitelist;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Restricted(_MemberT0&& member_0, _MemberT1&& member_1):
whitelist{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct Visibility : public Variant<Visibility_Details::Public, Visibility_Details::Private, Visibility_Details::Restricted> {
using Variant<Visibility_Details::Public, Visibility_Details::Private, Visibility_Details::Restricted>::Variant;
    using Public = Visibility_Details::Public;
    using Private = Visibility_Details::Private;
    using Restricted = Visibility_Details::Restricted;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Public */: {
[[maybe_unused]] auto const& that = this->template get<Visibility::Public>();
TRY(builder.append("Visibility::Public"));
break;}
case 1 /* Private */: {
[[maybe_unused]] auto const& that = this->template get<Visibility::Private>();
TRY(builder.append("Visibility::Private"));
break;}
case 2 /* Restricted */: {
[[maybe_unused]] auto const& that = this->template get<Visibility::Restricted>();
TRY(builder.append("Visibility::Restricted"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("whitelist: {}", that.whitelist));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}};
struct ParsedBlock {
  public:
Array<NonnullRefPtr<parser::ParsedStatement>> stmts;Optional<utility::Span> find_yield_span() const;
ErrorOr<Optional<utility::Span>> span(const parser::Parser parser) const;
ParsedBlock(Array<NonnullRefPtr<parser::ParsedStatement>> a_stmts) :stmts(a_stmts){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedBlock("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("stmts: "));TRY(builder.appendff("{}", stmts));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace FunctionType_Details {
struct Normal {};
struct ImplicitConstructor {};
struct ImplicitEnumConstructor {};
struct ExternalClassConstructor {};
}
struct FunctionType : public Variant<FunctionType_Details::Normal, FunctionType_Details::ImplicitConstructor, FunctionType_Details::ImplicitEnumConstructor, FunctionType_Details::ExternalClassConstructor> {
using Variant<FunctionType_Details::Normal, FunctionType_Details::ImplicitConstructor, FunctionType_Details::ImplicitEnumConstructor, FunctionType_Details::ExternalClassConstructor>::Variant;
    using Normal = FunctionType_Details::Normal;
    using ImplicitConstructor = FunctionType_Details::ImplicitConstructor;
    using ImplicitEnumConstructor = FunctionType_Details::ImplicitEnumConstructor;
    using ExternalClassConstructor = FunctionType_Details::ExternalClassConstructor;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Normal */: {
[[maybe_unused]] auto const& that = this->template get<FunctionType::Normal>();
TRY(builder.append("FunctionType::Normal"));
break;}
case 1 /* ImplicitConstructor */: {
[[maybe_unused]] auto const& that = this->template get<FunctionType::ImplicitConstructor>();
TRY(builder.append("FunctionType::ImplicitConstructor"));
break;}
case 2 /* ImplicitEnumConstructor */: {
[[maybe_unused]] auto const& that = this->template get<FunctionType::ImplicitEnumConstructor>();
TRY(builder.append("FunctionType::ImplicitEnumConstructor"));
break;}
case 3 /* ExternalClassConstructor */: {
[[maybe_unused]] auto const& that = this->template get<FunctionType::ExternalClassConstructor>();
TRY(builder.append("FunctionType::ExternalClassConstructor"));
break;}
}
return builder.to_string();
}};
namespace FunctionLinkage_Details {
struct Internal {};
struct External {};
}
struct FunctionLinkage : public Variant<FunctionLinkage_Details::Internal, FunctionLinkage_Details::External> {
using Variant<FunctionLinkage_Details::Internal, FunctionLinkage_Details::External>::Variant;
    using Internal = FunctionLinkage_Details::Internal;
    using External = FunctionLinkage_Details::External;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Internal */: {
[[maybe_unused]] auto const& that = this->template get<FunctionLinkage::Internal>();
TRY(builder.append("FunctionLinkage::Internal"));
break;}
case 1 /* External */: {
[[maybe_unused]] auto const& that = this->template get<FunctionLinkage::External>();
TRY(builder.append("FunctionLinkage::External"));
break;}
}
return builder.to_string();
}};
struct ParsedFunction {
  public:
String name;utility::Span name_span;parser::Visibility visibility;Array<parser::ParsedParameter> params;Array<parser::ParsedGenericParameter> generic_parameters;parser::ParsedBlock block;NonnullRefPtr<parser::ParsedType> return_type;utility::Span return_type_span;bool can_throw;parser::FunctionType type;parser::FunctionLinkage linkage;bool must_instantiate;bool is_comptime;ParsedFunction(String a_name, utility::Span a_name_span, parser::Visibility a_visibility, Array<parser::ParsedParameter> a_params, Array<parser::ParsedGenericParameter> a_generic_parameters, parser::ParsedBlock a_block, NonnullRefPtr<parser::ParsedType> a_return_type, utility::Span a_return_type_span, bool a_can_throw, parser::FunctionType a_type, parser::FunctionLinkage a_linkage, bool a_must_instantiate, bool a_is_comptime) :name(a_name), name_span(a_name_span), visibility(a_visibility), params(a_params), generic_parameters(a_generic_parameters), block(a_block), return_type(a_return_type), return_type_span(a_return_type_span), can_throw(a_can_throw), type(a_type), linkage(a_linkage), must_instantiate(a_must_instantiate), is_comptime(a_is_comptime){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedFunction("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}, ", visibility));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}, ", params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}, ", block));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}, ", return_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_span: "));TRY(builder.appendff("{}, ", return_type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type: "));TRY(builder.appendff("{}, ", type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("linkage: "));TRY(builder.appendff("{}, ", linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("must_instantiate: "));TRY(builder.appendff("{}, ", must_instantiate));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_comptime: "));TRY(builder.appendff("{}", is_comptime));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedNamespace {
  public:
Optional<String> name;Optional<utility::Span> name_span;Array<parser::ParsedFunction> functions;Array<parser::ParsedRecord> records;Array<parser::ParsedNamespace> namespaces;Array<parser::ParsedModuleImport> module_imports;Array<parser::ParsedExternImport> extern_imports;Optional<String> import_path_if_extern;ErrorOr<void> add_child_namespace(const parser::ParsedNamespace namespace_);
ParsedNamespace(Optional<String> a_name, Optional<utility::Span> a_name_span, Array<parser::ParsedFunction> a_functions, Array<parser::ParsedRecord> a_records, Array<parser::ParsedNamespace> a_namespaces, Array<parser::ParsedModuleImport> a_module_imports, Array<parser::ParsedExternImport> a_extern_imports, Optional<String> a_import_path_if_extern) :name(a_name), name_span(a_name_span), functions(a_functions), records(a_records), namespaces(a_namespaces), module_imports(a_module_imports), extern_imports(a_extern_imports), import_path_if_extern(a_import_path_if_extern){}

bool is_equivalent_to(const parser::ParsedNamespace other) const;
ErrorOr<void> add_extern_import(const parser::ParsedExternImport import_);
ErrorOr<void> merge_with(const parser::ParsedNamespace namespace_);
ErrorOr<void> add_module_import(const parser::ParsedModuleImport import_);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("records: "));TRY(builder.appendff("{}, ", records));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespaces: "));TRY(builder.appendff("{}, ", namespaces));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_imports: "));TRY(builder.appendff("{}, ", module_imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("extern_imports: "));TRY(builder.appendff("{}, ", extern_imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_path_if_extern: "));TRY(builder.appendff("{}", import_path_if_extern));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedExternImport {
  public:
bool is_c;parser::ParsedNamespace assigned_namespace;ErrorOr<bool> is_equivalent_to(const parser::ParsedExternImport other) const;
ParsedExternImport(bool a_is_c, parser::ParsedNamespace a_assigned_namespace) :is_c(a_is_c), assigned_namespace(a_assigned_namespace){}

String get_name() const;
String get_path() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedExternImport("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_c: "));TRY(builder.appendff("{}, ", is_c));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("assigned_namespace: "));TRY(builder.appendff("{}", assigned_namespace));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedVarDecl {
  public:
String name;NonnullRefPtr<parser::ParsedType> parsed_type;bool is_mutable;Optional<utility::Span> inlay_span;utility::Span span;ParsedVarDecl(String a_name, NonnullRefPtr<parser::ParsedType> a_parsed_type, bool a_is_mutable, Optional<utility::Span> a_inlay_span, utility::Span a_span) :name(a_name), parsed_type(a_parsed_type), is_mutable(a_is_mutable), inlay_span(a_inlay_span), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedVarDecl("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_type: "));TRY(builder.appendff("{}, ", parsed_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inlay_span: "));TRY(builder.appendff("{}, ", inlay_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedField {
  public:
parser::ParsedVarDecl var_decl;parser::Visibility visibility;ParsedField(parser::ParsedVarDecl a_var_decl, parser::Visibility a_visibility) :var_decl(a_var_decl), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedField("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("var_decl: "));TRY(builder.appendff("{}, ", var_decl));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace TypeCast_Details {
struct Fallible{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Fallible(Args&&... args): value { forward<Args>(args)... } {}
};
struct Infallible{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Infallible(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct TypeCast : public Variant<TypeCast_Details::Fallible, TypeCast_Details::Infallible> {
using Variant<TypeCast_Details::Fallible, TypeCast_Details::Infallible>::Variant;
    using Fallible = TypeCast_Details::Fallible;
    using Infallible = TypeCast_Details::Infallible;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Fallible */: {
[[maybe_unused]] auto const& that = this->template get<TypeCast::Fallible>();
TRY(builder.append("TypeCast::Fallible"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Infallible */: {
[[maybe_unused]] auto const& that = this->template get<TypeCast::Infallible>();
TRY(builder.append("TypeCast::Infallible"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}NonnullRefPtr<parser::ParsedType> parsed_type() const;
};
namespace ParsedType_Details {
struct Name {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Name(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NamespacedName {
String name;
Array<String> namespaces;
Array<NonnullRefPtr<parser::ParsedType>> params;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
NamespacedName(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
name{ forward<_MemberT0>(member_0)},
namespaces{ forward<_MemberT1>(member_1)},
params{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct GenericType {
String name;
Array<NonnullRefPtr<parser::ParsedType>> generic_parameters;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
GenericType(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
name{ forward<_MemberT0>(member_0)},
generic_parameters{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktArray {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Dictionary {
NonnullRefPtr<parser::ParsedType> key;
NonnullRefPtr<parser::ParsedType> value;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Dictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
key{ forward<_MemberT0>(member_0)},
value{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<parser::ParsedType>> types;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1):
types{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Set {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Set(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Optional {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Optional(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Reference {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Reference(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MutableReference {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
MutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct RawPtr {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
RawPtr(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct WeakPtr {
NonnullRefPtr<parser::ParsedType> inner;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
WeakPtr(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Function {
Array<parser::ParsedParameter> params;
bool can_throw;
NonnullRefPtr<parser::ParsedType> return_type;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
params{ forward<_MemberT0>(member_0)},
can_throw{ forward<_MemberT1>(member_1)},
return_type{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Empty {};
}
struct ParsedType : public Variant<ParsedType_Details::Name, ParsedType_Details::NamespacedName, ParsedType_Details::GenericType, ParsedType_Details::JaktArray, ParsedType_Details::Dictionary, ParsedType_Details::JaktTuple, ParsedType_Details::Set, ParsedType_Details::Optional, ParsedType_Details::Reference, ParsedType_Details::MutableReference, ParsedType_Details::RawPtr, ParsedType_Details::WeakPtr, ParsedType_Details::Function, ParsedType_Details::Empty>, public RefCounted<ParsedType> {
using Variant<ParsedType_Details::Name, ParsedType_Details::NamespacedName, ParsedType_Details::GenericType, ParsedType_Details::JaktArray, ParsedType_Details::Dictionary, ParsedType_Details::JaktTuple, ParsedType_Details::Set, ParsedType_Details::Optional, ParsedType_Details::Reference, ParsedType_Details::MutableReference, ParsedType_Details::RawPtr, ParsedType_Details::WeakPtr, ParsedType_Details::Function, ParsedType_Details::Empty>::Variant;
    using Name = ParsedType_Details::Name;
    using NamespacedName = ParsedType_Details::NamespacedName;
    using GenericType = ParsedType_Details::GenericType;
    using JaktArray = ParsedType_Details::JaktArray;
    using Dictionary = ParsedType_Details::Dictionary;
    using JaktTuple = ParsedType_Details::JaktTuple;
    using Set = ParsedType_Details::Set;
    using Optional = ParsedType_Details::Optional;
    using Reference = ParsedType_Details::Reference;
    using MutableReference = ParsedType_Details::MutableReference;
    using RawPtr = ParsedType_Details::RawPtr;
    using WeakPtr = ParsedType_Details::WeakPtr;
    using Function = ParsedType_Details::Function;
    using Empty = ParsedType_Details::Empty;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedType(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Name */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Name>();
TRY(builder.append("ParsedType::Name"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* NamespacedName */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::NamespacedName>();
TRY(builder.append("ParsedType::NamespacedName"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("namespaces: {}", that.namespaces));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("params: {}", that.params));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* GenericType */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::GenericType>();
TRY(builder.append("ParsedType::GenericType"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("generic_parameters: {}", that.generic_parameters));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* JaktArray */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::JaktArray>();
TRY(builder.append("ParsedType::JaktArray"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* Dictionary */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Dictionary>();
TRY(builder.append("ParsedType::Dictionary"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("key: {}", that.key));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("value: {}", that.value));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* JaktTuple */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::JaktTuple>();
TRY(builder.append("ParsedType::JaktTuple"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("types: {}", that.types));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* Set */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Set>();
TRY(builder.append("ParsedType::Set"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 7 /* Optional */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Optional>();
TRY(builder.append("ParsedType::Optional"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 8 /* Reference */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Reference>();
TRY(builder.append("ParsedType::Reference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 9 /* MutableReference */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::MutableReference>();
TRY(builder.append("ParsedType::MutableReference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 10 /* RawPtr */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::RawPtr>();
TRY(builder.append("ParsedType::RawPtr"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 11 /* WeakPtr */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::WeakPtr>();
TRY(builder.append("ParsedType::WeakPtr"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 12 /* Function */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Function>();
TRY(builder.append("ParsedType::Function"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("params: {}", that.params));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("can_throw: {}", that.can_throw));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("return_type: {}", that.return_type));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 13 /* Empty */: {
[[maybe_unused]] auto const& that = this->template get<ParsedType::Empty>();
TRY(builder.append("ParsedType::Empty"));
break;}
}
return builder.to_string();
}utility::Span span() const;
};
namespace UnaryOperator_Details {
struct PreIncrement {};
struct PostIncrement {};
struct PreDecrement {};
struct PostDecrement {};
struct Negate {};
struct Dereference {};
struct RawAddress {};
struct Reference {};
struct MutableReference {};
struct LogicalNot {};
struct BitwiseNot {};
struct TypeCast{
parser::TypeCast value;
template<typename... Args>
TypeCast(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
NonnullRefPtr<parser::ParsedType> value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct IsEnumVariant {
NonnullRefPtr<parser::ParsedType> inner;
Array<parser::EnumVariantPatternArgument> bindings;
template<typename _MemberT0, typename _MemberT1>
IsEnumVariant(_MemberT0&& member_0, _MemberT1&& member_1):
inner{ forward<_MemberT0>(member_0)},
bindings{ forward<_MemberT1>(member_1)}
{}
};
}
struct UnaryOperator : public Variant<UnaryOperator_Details::PreIncrement, UnaryOperator_Details::PostIncrement, UnaryOperator_Details::PreDecrement, UnaryOperator_Details::PostDecrement, UnaryOperator_Details::Negate, UnaryOperator_Details::Dereference, UnaryOperator_Details::RawAddress, UnaryOperator_Details::Reference, UnaryOperator_Details::MutableReference, UnaryOperator_Details::LogicalNot, UnaryOperator_Details::BitwiseNot, UnaryOperator_Details::TypeCast, UnaryOperator_Details::Is, UnaryOperator_Details::IsEnumVariant> {
using Variant<UnaryOperator_Details::PreIncrement, UnaryOperator_Details::PostIncrement, UnaryOperator_Details::PreDecrement, UnaryOperator_Details::PostDecrement, UnaryOperator_Details::Negate, UnaryOperator_Details::Dereference, UnaryOperator_Details::RawAddress, UnaryOperator_Details::Reference, UnaryOperator_Details::MutableReference, UnaryOperator_Details::LogicalNot, UnaryOperator_Details::BitwiseNot, UnaryOperator_Details::TypeCast, UnaryOperator_Details::Is, UnaryOperator_Details::IsEnumVariant>::Variant;
    using PreIncrement = UnaryOperator_Details::PreIncrement;
    using PostIncrement = UnaryOperator_Details::PostIncrement;
    using PreDecrement = UnaryOperator_Details::PreDecrement;
    using PostDecrement = UnaryOperator_Details::PostDecrement;
    using Negate = UnaryOperator_Details::Negate;
    using Dereference = UnaryOperator_Details::Dereference;
    using RawAddress = UnaryOperator_Details::RawAddress;
    using Reference = UnaryOperator_Details::Reference;
    using MutableReference = UnaryOperator_Details::MutableReference;
    using LogicalNot = UnaryOperator_Details::LogicalNot;
    using BitwiseNot = UnaryOperator_Details::BitwiseNot;
    using TypeCast = UnaryOperator_Details::TypeCast;
    using Is = UnaryOperator_Details::Is;
    using IsEnumVariant = UnaryOperator_Details::IsEnumVariant;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* PreIncrement */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::PreIncrement>();
TRY(builder.append("UnaryOperator::PreIncrement"));
break;}
case 1 /* PostIncrement */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::PostIncrement>();
TRY(builder.append("UnaryOperator::PostIncrement"));
break;}
case 2 /* PreDecrement */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::PreDecrement>();
TRY(builder.append("UnaryOperator::PreDecrement"));
break;}
case 3 /* PostDecrement */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::PostDecrement>();
TRY(builder.append("UnaryOperator::PostDecrement"));
break;}
case 4 /* Negate */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::Negate>();
TRY(builder.append("UnaryOperator::Negate"));
break;}
case 5 /* Dereference */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::Dereference>();
TRY(builder.append("UnaryOperator::Dereference"));
break;}
case 6 /* RawAddress */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::RawAddress>();
TRY(builder.append("UnaryOperator::RawAddress"));
break;}
case 7 /* Reference */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::Reference>();
TRY(builder.append("UnaryOperator::Reference"));
break;}
case 8 /* MutableReference */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::MutableReference>();
TRY(builder.append("UnaryOperator::MutableReference"));
break;}
case 9 /* LogicalNot */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::LogicalNot>();
TRY(builder.append("UnaryOperator::LogicalNot"));
break;}
case 10 /* BitwiseNot */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::BitwiseNot>();
TRY(builder.append("UnaryOperator::BitwiseNot"));
break;}
case 11 /* TypeCast */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::TypeCast>();
TRY(builder.append("UnaryOperator::TypeCast"));
TRY(builder.appendff("({})", that.value));
break;}
case 12 /* Is */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::Is>();
TRY(builder.append("UnaryOperator::Is"));
TRY(builder.appendff("({})", that.value));
break;}
case 13 /* IsEnumVariant */: {
[[maybe_unused]] auto const& that = this->template get<UnaryOperator::IsEnumVariant>();
TRY(builder.append("UnaryOperator::IsEnumVariant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner: {}", that.inner));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("bindings: {}", that.bindings));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}};
struct ParsedCall {
  public:
Array<String> namespace_;String name;Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> args;Array<NonnullRefPtr<parser::ParsedType>> type_args;ParsedCall(Array<String> a_namespace_, String a_name, Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> a_args, Array<NonnullRefPtr<parser::ParsedType>> a_type_args) :namespace_(a_namespace_), name(a_name), args(a_args), type_args(a_type_args){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedCall("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_: "));TRY(builder.appendff("{}, ", namespace_));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_args: "));TRY(builder.appendff("{}", type_args));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace BinaryOperator_Details {
struct Add {};
struct Subtract {};
struct Multiply {};
struct Divide {};
struct Modulo {};
struct LessThan {};
struct LessThanOrEqual {};
struct GreaterThan {};
struct GreaterThanOrEqual {};
struct Equal {};
struct NotEqual {};
struct BitwiseAnd {};
struct BitwiseXor {};
struct BitwiseOr {};
struct BitwiseLeftShift {};
struct BitwiseRightShift {};
struct ArithmeticLeftShift {};
struct ArithmeticRightShift {};
struct LogicalAnd {};
struct LogicalOr {};
struct NoneCoalescing {};
struct Assign {};
struct BitwiseAndAssign {};
struct BitwiseOrAssign {};
struct BitwiseXorAssign {};
struct BitwiseLeftShiftAssign {};
struct BitwiseRightShiftAssign {};
struct AddAssign {};
struct SubtractAssign {};
struct MultiplyAssign {};
struct ModuloAssign {};
struct DivideAssign {};
struct NoneCoalescingAssign {};
struct Garbage {};
}
struct BinaryOperator : public Variant<BinaryOperator_Details::Add, BinaryOperator_Details::Subtract, BinaryOperator_Details::Multiply, BinaryOperator_Details::Divide, BinaryOperator_Details::Modulo, BinaryOperator_Details::LessThan, BinaryOperator_Details::LessThanOrEqual, BinaryOperator_Details::GreaterThan, BinaryOperator_Details::GreaterThanOrEqual, BinaryOperator_Details::Equal, BinaryOperator_Details::NotEqual, BinaryOperator_Details::BitwiseAnd, BinaryOperator_Details::BitwiseXor, BinaryOperator_Details::BitwiseOr, BinaryOperator_Details::BitwiseLeftShift, BinaryOperator_Details::BitwiseRightShift, BinaryOperator_Details::ArithmeticLeftShift, BinaryOperator_Details::ArithmeticRightShift, BinaryOperator_Details::LogicalAnd, BinaryOperator_Details::LogicalOr, BinaryOperator_Details::NoneCoalescing, BinaryOperator_Details::Assign, BinaryOperator_Details::BitwiseAndAssign, BinaryOperator_Details::BitwiseOrAssign, BinaryOperator_Details::BitwiseXorAssign, BinaryOperator_Details::BitwiseLeftShiftAssign, BinaryOperator_Details::BitwiseRightShiftAssign, BinaryOperator_Details::AddAssign, BinaryOperator_Details::SubtractAssign, BinaryOperator_Details::MultiplyAssign, BinaryOperator_Details::ModuloAssign, BinaryOperator_Details::DivideAssign, BinaryOperator_Details::NoneCoalescingAssign, BinaryOperator_Details::Garbage> {
using Variant<BinaryOperator_Details::Add, BinaryOperator_Details::Subtract, BinaryOperator_Details::Multiply, BinaryOperator_Details::Divide, BinaryOperator_Details::Modulo, BinaryOperator_Details::LessThan, BinaryOperator_Details::LessThanOrEqual, BinaryOperator_Details::GreaterThan, BinaryOperator_Details::GreaterThanOrEqual, BinaryOperator_Details::Equal, BinaryOperator_Details::NotEqual, BinaryOperator_Details::BitwiseAnd, BinaryOperator_Details::BitwiseXor, BinaryOperator_Details::BitwiseOr, BinaryOperator_Details::BitwiseLeftShift, BinaryOperator_Details::BitwiseRightShift, BinaryOperator_Details::ArithmeticLeftShift, BinaryOperator_Details::ArithmeticRightShift, BinaryOperator_Details::LogicalAnd, BinaryOperator_Details::LogicalOr, BinaryOperator_Details::NoneCoalescing, BinaryOperator_Details::Assign, BinaryOperator_Details::BitwiseAndAssign, BinaryOperator_Details::BitwiseOrAssign, BinaryOperator_Details::BitwiseXorAssign, BinaryOperator_Details::BitwiseLeftShiftAssign, BinaryOperator_Details::BitwiseRightShiftAssign, BinaryOperator_Details::AddAssign, BinaryOperator_Details::SubtractAssign, BinaryOperator_Details::MultiplyAssign, BinaryOperator_Details::ModuloAssign, BinaryOperator_Details::DivideAssign, BinaryOperator_Details::NoneCoalescingAssign, BinaryOperator_Details::Garbage>::Variant;
    using Add = BinaryOperator_Details::Add;
    using Subtract = BinaryOperator_Details::Subtract;
    using Multiply = BinaryOperator_Details::Multiply;
    using Divide = BinaryOperator_Details::Divide;
    using Modulo = BinaryOperator_Details::Modulo;
    using LessThan = BinaryOperator_Details::LessThan;
    using LessThanOrEqual = BinaryOperator_Details::LessThanOrEqual;
    using GreaterThan = BinaryOperator_Details::GreaterThan;
    using GreaterThanOrEqual = BinaryOperator_Details::GreaterThanOrEqual;
    using Equal = BinaryOperator_Details::Equal;
    using NotEqual = BinaryOperator_Details::NotEqual;
    using BitwiseAnd = BinaryOperator_Details::BitwiseAnd;
    using BitwiseXor = BinaryOperator_Details::BitwiseXor;
    using BitwiseOr = BinaryOperator_Details::BitwiseOr;
    using BitwiseLeftShift = BinaryOperator_Details::BitwiseLeftShift;
    using BitwiseRightShift = BinaryOperator_Details::BitwiseRightShift;
    using ArithmeticLeftShift = BinaryOperator_Details::ArithmeticLeftShift;
    using ArithmeticRightShift = BinaryOperator_Details::ArithmeticRightShift;
    using LogicalAnd = BinaryOperator_Details::LogicalAnd;
    using LogicalOr = BinaryOperator_Details::LogicalOr;
    using NoneCoalescing = BinaryOperator_Details::NoneCoalescing;
    using Assign = BinaryOperator_Details::Assign;
    using BitwiseAndAssign = BinaryOperator_Details::BitwiseAndAssign;
    using BitwiseOrAssign = BinaryOperator_Details::BitwiseOrAssign;
    using BitwiseXorAssign = BinaryOperator_Details::BitwiseXorAssign;
    using BitwiseLeftShiftAssign = BinaryOperator_Details::BitwiseLeftShiftAssign;
    using BitwiseRightShiftAssign = BinaryOperator_Details::BitwiseRightShiftAssign;
    using AddAssign = BinaryOperator_Details::AddAssign;
    using SubtractAssign = BinaryOperator_Details::SubtractAssign;
    using MultiplyAssign = BinaryOperator_Details::MultiplyAssign;
    using ModuloAssign = BinaryOperator_Details::ModuloAssign;
    using DivideAssign = BinaryOperator_Details::DivideAssign;
    using NoneCoalescingAssign = BinaryOperator_Details::NoneCoalescingAssign;
    using Garbage = BinaryOperator_Details::Garbage;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Add */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Add>();
TRY(builder.append("BinaryOperator::Add"));
break;}
case 1 /* Subtract */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Subtract>();
TRY(builder.append("BinaryOperator::Subtract"));
break;}
case 2 /* Multiply */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Multiply>();
TRY(builder.append("BinaryOperator::Multiply"));
break;}
case 3 /* Divide */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Divide>();
TRY(builder.append("BinaryOperator::Divide"));
break;}
case 4 /* Modulo */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Modulo>();
TRY(builder.append("BinaryOperator::Modulo"));
break;}
case 5 /* LessThan */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::LessThan>();
TRY(builder.append("BinaryOperator::LessThan"));
break;}
case 6 /* LessThanOrEqual */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::LessThanOrEqual>();
TRY(builder.append("BinaryOperator::LessThanOrEqual"));
break;}
case 7 /* GreaterThan */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::GreaterThan>();
TRY(builder.append("BinaryOperator::GreaterThan"));
break;}
case 8 /* GreaterThanOrEqual */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::GreaterThanOrEqual>();
TRY(builder.append("BinaryOperator::GreaterThanOrEqual"));
break;}
case 9 /* Equal */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Equal>();
TRY(builder.append("BinaryOperator::Equal"));
break;}
case 10 /* NotEqual */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::NotEqual>();
TRY(builder.append("BinaryOperator::NotEqual"));
break;}
case 11 /* BitwiseAnd */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseAnd>();
TRY(builder.append("BinaryOperator::BitwiseAnd"));
break;}
case 12 /* BitwiseXor */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseXor>();
TRY(builder.append("BinaryOperator::BitwiseXor"));
break;}
case 13 /* BitwiseOr */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseOr>();
TRY(builder.append("BinaryOperator::BitwiseOr"));
break;}
case 14 /* BitwiseLeftShift */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseLeftShift>();
TRY(builder.append("BinaryOperator::BitwiseLeftShift"));
break;}
case 15 /* BitwiseRightShift */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseRightShift>();
TRY(builder.append("BinaryOperator::BitwiseRightShift"));
break;}
case 16 /* ArithmeticLeftShift */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::ArithmeticLeftShift>();
TRY(builder.append("BinaryOperator::ArithmeticLeftShift"));
break;}
case 17 /* ArithmeticRightShift */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::ArithmeticRightShift>();
TRY(builder.append("BinaryOperator::ArithmeticRightShift"));
break;}
case 18 /* LogicalAnd */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::LogicalAnd>();
TRY(builder.append("BinaryOperator::LogicalAnd"));
break;}
case 19 /* LogicalOr */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::LogicalOr>();
TRY(builder.append("BinaryOperator::LogicalOr"));
break;}
case 20 /* NoneCoalescing */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::NoneCoalescing>();
TRY(builder.append("BinaryOperator::NoneCoalescing"));
break;}
case 21 /* Assign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Assign>();
TRY(builder.append("BinaryOperator::Assign"));
break;}
case 22 /* BitwiseAndAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseAndAssign>();
TRY(builder.append("BinaryOperator::BitwiseAndAssign"));
break;}
case 23 /* BitwiseOrAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseOrAssign>();
TRY(builder.append("BinaryOperator::BitwiseOrAssign"));
break;}
case 24 /* BitwiseXorAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseXorAssign>();
TRY(builder.append("BinaryOperator::BitwiseXorAssign"));
break;}
case 25 /* BitwiseLeftShiftAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseLeftShiftAssign>();
TRY(builder.append("BinaryOperator::BitwiseLeftShiftAssign"));
break;}
case 26 /* BitwiseRightShiftAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::BitwiseRightShiftAssign>();
TRY(builder.append("BinaryOperator::BitwiseRightShiftAssign"));
break;}
case 27 /* AddAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::AddAssign>();
TRY(builder.append("BinaryOperator::AddAssign"));
break;}
case 28 /* SubtractAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::SubtractAssign>();
TRY(builder.append("BinaryOperator::SubtractAssign"));
break;}
case 29 /* MultiplyAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::MultiplyAssign>();
TRY(builder.append("BinaryOperator::MultiplyAssign"));
break;}
case 30 /* ModuloAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::ModuloAssign>();
TRY(builder.append("BinaryOperator::ModuloAssign"));
break;}
case 31 /* DivideAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::DivideAssign>();
TRY(builder.append("BinaryOperator::DivideAssign"));
break;}
case 32 /* NoneCoalescingAssign */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::NoneCoalescingAssign>();
TRY(builder.append("BinaryOperator::NoneCoalescingAssign"));
break;}
case 33 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<BinaryOperator::Garbage>();
TRY(builder.append("BinaryOperator::Garbage"));
break;}
}
return builder.to_string();
}bool is_assignment() const;
};
struct EnumVariantPatternArgument {
  public:
Optional<String> name;String binding;utility::Span span;EnumVariantPatternArgument(Optional<String> a_name, String a_binding, utility::Span a_span) :name(a_name), binding(a_binding), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("EnumVariantPatternArgument("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("binding: "));TRY(builder.appendff("\"{}\", ", binding));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedExpression_Details {
struct Boolean {
bool val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Boolean(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NumericConstant {
lexer::NumericConstant val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
NumericConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct QuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct SingleQuotedByteString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
SingleQuotedByteString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Call {
parser::ParsedCall call;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Call(_MemberT0&& member_0, _MemberT1&& member_1):
call{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct MethodCall {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::ParsedCall call;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
MethodCall(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
call{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedTuple {
NonnullRefPtr<parser::ParsedExpression> expr;
size_t index;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedStruct {
NonnullRefPtr<parser::ParsedExpression> expr;
String field;
bool is_optional;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedStruct(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
field{ forward<_MemberT1>(member_1)},
is_optional{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Var {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Var(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct IndexedExpression {
NonnullRefPtr<parser::ParsedExpression> base;
NonnullRefPtr<parser::ParsedExpression> index;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
IndexedExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
base{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct IndexedRangeExpression {
NonnullRefPtr<parser::ParsedExpression> base;
NonnullRefPtr<parser::ParsedExpression> from;
NonnullRefPtr<parser::ParsedExpression> to;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedRangeExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
base{ forward<_MemberT0>(member_0)},
from{ forward<_MemberT1>(member_1)},
to{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct UnaryOp {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::UnaryOperator op;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
UnaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct BinaryOp {
NonnullRefPtr<parser::ParsedExpression> lhs;
parser::BinaryOperator op;
NonnullRefPtr<parser::ParsedExpression> rhs;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
BinaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
lhs{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
rhs{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Operator {
parser::BinaryOperator op;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Operator(_MemberT0&& member_0, _MemberT1&& member_1):
op{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalSome {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
OptionalSome(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalNone{
utility::Span value;
template<typename... Args>
OptionalNone(Args&&... args): value { forward<Args>(args)... } {}
};
struct JaktArray {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
values{ forward<_MemberT0>(member_0)},
fill_size{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct JaktDictionary {
Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktDictionary(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Set {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Set(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<parser::ParsedExpression>> values;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Range {
NonnullRefPtr<parser::ParsedExpression> from;
NonnullRefPtr<parser::ParsedExpression> to;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Range(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
from{ forward<_MemberT0>(member_0)},
to{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct ForcedUnwrap {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ForcedUnwrap(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Match {
NonnullRefPtr<parser::ParsedExpression> expr;
Array<parser::ParsedMatchCase> cases;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Match(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
cases{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct EnumVariantArg {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::EnumVariantPatternArgument arg;
NonnullRefPtr<parser::ParsedType> enum_variant;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
EnumVariantArg(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
arg{ forward<_MemberT1>(member_1)},
enum_variant{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct NamespacedVar {
String name;
Array<String> namespace_;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NamespacedVar(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
name{ forward<_MemberT0>(member_0)},
namespace_{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Function {
Array<parser::ParsedCapture> captures;
Array<parser::ParsedParameter> params;
bool can_throw;
NonnullRefPtr<parser::ParsedType> return_type;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5):
captures{ forward<_MemberT0>(member_0)},
params{ forward<_MemberT1>(member_1)},
can_throw{ forward<_MemberT2>(member_2)},
return_type{ forward<_MemberT3>(member_3)},
block{ forward<_MemberT4>(member_4)},
span{ forward<_MemberT5>(member_5)}
{}
};
struct Try {
NonnullRefPtr<parser::ParsedExpression> expr;
Optional<parser::ParsedBlock> catch_block;
Optional<String> catch_name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Try(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
catch_block{ forward<_MemberT1>(member_1)},
catch_name{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct TryBlock {
NonnullRefPtr<parser::ParsedStatement> stmt;
String error_name;
utility::Span error_span;
parser::ParsedBlock catch_block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
TryBlock(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
stmt{ forward<_MemberT0>(member_0)},
error_name{ forward<_MemberT1>(member_1)},
error_span{ forward<_MemberT2>(member_2)},
catch_block{ forward<_MemberT3>(member_3)},
span{ forward<_MemberT4>(member_4)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedExpression : public Variant<ParsedExpression_Details::Boolean, ParsedExpression_Details::NumericConstant, ParsedExpression_Details::QuotedString, ParsedExpression_Details::SingleQuotedString, ParsedExpression_Details::SingleQuotedByteString, ParsedExpression_Details::Call, ParsedExpression_Details::MethodCall, ParsedExpression_Details::IndexedTuple, ParsedExpression_Details::IndexedStruct, ParsedExpression_Details::Var, ParsedExpression_Details::IndexedExpression, ParsedExpression_Details::IndexedRangeExpression, ParsedExpression_Details::UnaryOp, ParsedExpression_Details::BinaryOp, ParsedExpression_Details::Operator, ParsedExpression_Details::OptionalSome, ParsedExpression_Details::OptionalNone, ParsedExpression_Details::JaktArray, ParsedExpression_Details::JaktDictionary, ParsedExpression_Details::Set, ParsedExpression_Details::JaktTuple, ParsedExpression_Details::Range, ParsedExpression_Details::ForcedUnwrap, ParsedExpression_Details::Match, ParsedExpression_Details::EnumVariantArg, ParsedExpression_Details::NamespacedVar, ParsedExpression_Details::Function, ParsedExpression_Details::Try, ParsedExpression_Details::TryBlock, ParsedExpression_Details::Garbage>, public RefCounted<ParsedExpression> {
using Variant<ParsedExpression_Details::Boolean, ParsedExpression_Details::NumericConstant, ParsedExpression_Details::QuotedString, ParsedExpression_Details::SingleQuotedString, ParsedExpression_Details::SingleQuotedByteString, ParsedExpression_Details::Call, ParsedExpression_Details::MethodCall, ParsedExpression_Details::IndexedTuple, ParsedExpression_Details::IndexedStruct, ParsedExpression_Details::Var, ParsedExpression_Details::IndexedExpression, ParsedExpression_Details::IndexedRangeExpression, ParsedExpression_Details::UnaryOp, ParsedExpression_Details::BinaryOp, ParsedExpression_Details::Operator, ParsedExpression_Details::OptionalSome, ParsedExpression_Details::OptionalNone, ParsedExpression_Details::JaktArray, ParsedExpression_Details::JaktDictionary, ParsedExpression_Details::Set, ParsedExpression_Details::JaktTuple, ParsedExpression_Details::Range, ParsedExpression_Details::ForcedUnwrap, ParsedExpression_Details::Match, ParsedExpression_Details::EnumVariantArg, ParsedExpression_Details::NamespacedVar, ParsedExpression_Details::Function, ParsedExpression_Details::Try, ParsedExpression_Details::TryBlock, ParsedExpression_Details::Garbage>::Variant;
    using Boolean = ParsedExpression_Details::Boolean;
    using NumericConstant = ParsedExpression_Details::NumericConstant;
    using QuotedString = ParsedExpression_Details::QuotedString;
    using SingleQuotedString = ParsedExpression_Details::SingleQuotedString;
    using SingleQuotedByteString = ParsedExpression_Details::SingleQuotedByteString;
    using Call = ParsedExpression_Details::Call;
    using MethodCall = ParsedExpression_Details::MethodCall;
    using IndexedTuple = ParsedExpression_Details::IndexedTuple;
    using IndexedStruct = ParsedExpression_Details::IndexedStruct;
    using Var = ParsedExpression_Details::Var;
    using IndexedExpression = ParsedExpression_Details::IndexedExpression;
    using IndexedRangeExpression = ParsedExpression_Details::IndexedRangeExpression;
    using UnaryOp = ParsedExpression_Details::UnaryOp;
    using BinaryOp = ParsedExpression_Details::BinaryOp;
    using Operator = ParsedExpression_Details::Operator;
    using OptionalSome = ParsedExpression_Details::OptionalSome;
    using OptionalNone = ParsedExpression_Details::OptionalNone;
    using JaktArray = ParsedExpression_Details::JaktArray;
    using JaktDictionary = ParsedExpression_Details::JaktDictionary;
    using Set = ParsedExpression_Details::Set;
    using JaktTuple = ParsedExpression_Details::JaktTuple;
    using Range = ParsedExpression_Details::Range;
    using ForcedUnwrap = ParsedExpression_Details::ForcedUnwrap;
    using Match = ParsedExpression_Details::Match;
    using EnumVariantArg = ParsedExpression_Details::EnumVariantArg;
    using NamespacedVar = ParsedExpression_Details::NamespacedVar;
    using Function = ParsedExpression_Details::Function;
    using Try = ParsedExpression_Details::Try;
    using TryBlock = ParsedExpression_Details::TryBlock;
    using Garbage = ParsedExpression_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedExpression(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Boolean */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Boolean>();
TRY(builder.append("ParsedExpression::Boolean"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: {}", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* NumericConstant */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::NumericConstant>();
TRY(builder.append("ParsedExpression::NumericConstant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: {}", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* QuotedString */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::QuotedString>();
TRY(builder.append("ParsedExpression::QuotedString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* SingleQuotedString */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::SingleQuotedString>();
TRY(builder.append("ParsedExpression::SingleQuotedString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* SingleQuotedByteString */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::SingleQuotedByteString>();
TRY(builder.append("ParsedExpression::SingleQuotedByteString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* Call */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Call>();
TRY(builder.append("ParsedExpression::Call"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("call: {}", that.call));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* MethodCall */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::MethodCall>();
TRY(builder.append("ParsedExpression::MethodCall"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("call: {}", that.call));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 7 /* IndexedTuple */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::IndexedTuple>();
TRY(builder.append("ParsedExpression::IndexedTuple"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 8 /* IndexedStruct */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::IndexedStruct>();
TRY(builder.append("ParsedExpression::IndexedStruct"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("field: \"{}\"", that.field));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 9 /* Var */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Var>();
TRY(builder.append("ParsedExpression::Var"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 10 /* IndexedExpression */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::IndexedExpression>();
TRY(builder.append("ParsedExpression::IndexedExpression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("base: {}", that.base));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 11 /* IndexedRangeExpression */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::IndexedRangeExpression>();
TRY(builder.append("ParsedExpression::IndexedRangeExpression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("base: {}", that.base));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("from: {}", that.from));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("to: {}", that.to));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 12 /* UnaryOp */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::UnaryOp>();
TRY(builder.append("ParsedExpression::UnaryOp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("op: {}", that.op));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 13 /* BinaryOp */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::BinaryOp>();
TRY(builder.append("ParsedExpression::BinaryOp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("lhs: {}", that.lhs));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("op: {}", that.op));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("rhs: {}", that.rhs));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 14 /* Operator */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Operator>();
TRY(builder.append("ParsedExpression::Operator"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("op: {}", that.op));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 15 /* OptionalSome */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::OptionalSome>();
TRY(builder.append("ParsedExpression::OptionalSome"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 16 /* OptionalNone */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::OptionalNone>();
TRY(builder.append("ParsedExpression::OptionalNone"));
TRY(builder.appendff("({})", that.value));
break;}
case 17 /* JaktArray */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::JaktArray>();
TRY(builder.append("ParsedExpression::JaktArray"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("values: {}", that.values));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fill_size: {}", that.fill_size));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 18 /* JaktDictionary */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::JaktDictionary>();
TRY(builder.append("ParsedExpression::JaktDictionary"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("values: {}", that.values));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 19 /* Set */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Set>();
TRY(builder.append("ParsedExpression::Set"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("values: {}", that.values));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 20 /* JaktTuple */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::JaktTuple>();
TRY(builder.append("ParsedExpression::JaktTuple"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("values: {}", that.values));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 21 /* Range */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Range>();
TRY(builder.append("ParsedExpression::Range"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("from: {}", that.from));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("to: {}", that.to));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 22 /* ForcedUnwrap */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::ForcedUnwrap>();
TRY(builder.append("ParsedExpression::ForcedUnwrap"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 23 /* Match */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Match>();
TRY(builder.append("ParsedExpression::Match"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("cases: {}", that.cases));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 24 /* EnumVariantArg */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::EnumVariantArg>();
TRY(builder.append("ParsedExpression::EnumVariantArg"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("arg: {}", that.arg));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_variant: {}", that.enum_variant));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 25 /* NamespacedVar */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::NamespacedVar>();
TRY(builder.append("ParsedExpression::NamespacedVar"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("namespace_: {}", that.namespace_));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 26 /* Function */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Function>();
TRY(builder.append("ParsedExpression::Function"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("captures: {}", that.captures));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("params: {}", that.params));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("can_throw: {}", that.can_throw));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("return_type: {}", that.return_type));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 27 /* Try */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Try>();
TRY(builder.append("ParsedExpression::Try"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_block: {}", that.catch_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_name: {}", that.catch_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 28 /* TryBlock */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::TryBlock>();
TRY(builder.append("ParsedExpression::TryBlock"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("stmt: {}", that.stmt));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("error_name: \"{}\"", that.error_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("error_span: {}", that.error_span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_block: {}", that.catch_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 29 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<ParsedExpression::Garbage>();
TRY(builder.append("ParsedExpression::Garbage"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}utility::Span span() const;
i64 precedence() const;
};
struct ValueEnumVariant {
  public:
String name;utility::Span span;Optional<NonnullRefPtr<parser::ParsedExpression>> value;ValueEnumVariant(String a_name, utility::Span a_span, Optional<NonnullRefPtr<parser::ParsedExpression>> a_value) :name(a_name), span(a_span), value(a_value){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ValueEnumVariant("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("value: "));TRY(builder.appendff("{}", value));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedMethod {
  public:
parser::ParsedFunction parsed_function;parser::Visibility visibility;ParsedMethod(parser::ParsedFunction a_parsed_function, parser::Visibility a_visibility) :parsed_function(a_parsed_function), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedMethod("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_function: "));TRY(builder.appendff("{}, ", parsed_function));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace DefinitionLinkage_Details {
struct Internal {};
struct External {};
}
struct DefinitionLinkage : public Variant<DefinitionLinkage_Details::Internal, DefinitionLinkage_Details::External> {
using Variant<DefinitionLinkage_Details::Internal, DefinitionLinkage_Details::External>::Variant;
    using Internal = DefinitionLinkage_Details::Internal;
    using External = DefinitionLinkage_Details::External;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Internal */: {
[[maybe_unused]] auto const& that = this->template get<DefinitionLinkage::Internal>();
TRY(builder.append("DefinitionLinkage::Internal"));
break;}
case 1 /* External */: {
[[maybe_unused]] auto const& that = this->template get<DefinitionLinkage::External>();
TRY(builder.append("DefinitionLinkage::External"));
break;}
}
return builder.to_string();
}};
struct ImportName {
  public:
String name;utility::Span span;ImportName(String a_name, utility::Span a_span) :name(a_name), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ImportName("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedCapture_Details {
struct ByValue {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByValue(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByMutableReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByMutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct ParsedCapture : public Variant<ParsedCapture_Details::ByValue, ParsedCapture_Details::ByReference, ParsedCapture_Details::ByMutableReference> {
using Variant<ParsedCapture_Details::ByValue, ParsedCapture_Details::ByReference, ParsedCapture_Details::ByMutableReference>::Variant;
    using ByValue = ParsedCapture_Details::ByValue;
    using ByReference = ParsedCapture_Details::ByReference;
    using ByMutableReference = ParsedCapture_Details::ByMutableReference;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* ByValue */: {
[[maybe_unused]] auto const& that = this->template get<ParsedCapture::ByValue>();
TRY(builder.append("ParsedCapture::ByValue"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* ByReference */: {
[[maybe_unused]] auto const& that = this->template get<ParsedCapture::ByReference>();
TRY(builder.append("ParsedCapture::ByReference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* ByMutableReference */: {
[[maybe_unused]] auto const& that = this->template get<ParsedCapture::ByMutableReference>();
TRY(builder.append("ParsedCapture::ByMutableReference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}String name() const;
utility::Span span() const;
};
struct ParsedVariable {
  public:
String name;NonnullRefPtr<parser::ParsedType> parsed_type;bool is_mutable;utility::Span span;ParsedVariable(String a_name, NonnullRefPtr<parser::ParsedType> a_parsed_type, bool a_is_mutable, utility::Span a_span) :name(a_name), parsed_type(a_parsed_type), is_mutable(a_is_mutable), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedVariable("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_type: "));TRY(builder.appendff("{}, ", parsed_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedParameter {
  public:
bool requires_label;parser::ParsedVariable variable;Optional<NonnullRefPtr<parser::ParsedExpression>> default_argument;utility::Span span;ParsedParameter(bool a_requires_label, parser::ParsedVariable a_variable, Optional<NonnullRefPtr<parser::ParsedExpression>> a_default_argument, utility::Span a_span) :requires_label(a_requires_label), variable(a_variable), default_argument(a_default_argument), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("requires_label: "));TRY(builder.appendff("{}, ", requires_label));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variable: "));TRY(builder.appendff("{}, ", variable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("default_argument: "));TRY(builder.appendff("{}, ", default_argument));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace RecordType_Details {
struct Struct {
Array<parser::ParsedField> fields;
template<typename _MemberT0>
Struct(_MemberT0&& member_0):
fields{ forward<_MemberT0>(member_0)}
{}
};
struct Class {
Array<parser::ParsedField> fields;
Optional<NonnullRefPtr<parser::ParsedType>> super_class;
template<typename _MemberT0, typename _MemberT1>
Class(_MemberT0&& member_0, _MemberT1&& member_1):
fields{ forward<_MemberT0>(member_0)},
super_class{ forward<_MemberT1>(member_1)}
{}
};
struct ValueEnum {
NonnullRefPtr<parser::ParsedType> underlying_type;
Array<parser::ValueEnumVariant> variants;
template<typename _MemberT0, typename _MemberT1>
ValueEnum(_MemberT0&& member_0, _MemberT1&& member_1):
underlying_type{ forward<_MemberT0>(member_0)},
variants{ forward<_MemberT1>(member_1)}
{}
};
struct SumEnum {
bool is_boxed;
Array<parser::SumEnumVariant> variants;
template<typename _MemberT0, typename _MemberT1>
SumEnum(_MemberT0&& member_0, _MemberT1&& member_1):
is_boxed{ forward<_MemberT0>(member_0)},
variants{ forward<_MemberT1>(member_1)}
{}
};
struct Garbage {};
}
struct RecordType : public Variant<RecordType_Details::Struct, RecordType_Details::Class, RecordType_Details::ValueEnum, RecordType_Details::SumEnum, RecordType_Details::Garbage> {
using Variant<RecordType_Details::Struct, RecordType_Details::Class, RecordType_Details::ValueEnum, RecordType_Details::SumEnum, RecordType_Details::Garbage>::Variant;
    using Struct = RecordType_Details::Struct;
    using Class = RecordType_Details::Class;
    using ValueEnum = RecordType_Details::ValueEnum;
    using SumEnum = RecordType_Details::SumEnum;
    using Garbage = RecordType_Details::Garbage;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Struct */: {
[[maybe_unused]] auto const& that = this->template get<RecordType::Struct>();
TRY(builder.append("RecordType::Struct"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Class */: {
[[maybe_unused]] auto const& that = this->template get<RecordType::Class>();
TRY(builder.append("RecordType::Class"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("super_class: {}", that.super_class));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* ValueEnum */: {
[[maybe_unused]] auto const& that = this->template get<RecordType::ValueEnum>();
TRY(builder.append("RecordType::ValueEnum"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("underlying_type: {}", that.underlying_type));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("variants: {}", that.variants));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* SumEnum */: {
[[maybe_unused]] auto const& that = this->template get<RecordType::SumEnum>();
TRY(builder.append("RecordType::SumEnum"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_boxed: {}", that.is_boxed));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("variants: {}", that.variants));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<RecordType::Garbage>();
TRY(builder.append("RecordType::Garbage"));
break;}
}
return builder.to_string();
}String record_type_name() const;
};
struct ParsedGenericParameter {
  public:
String name;utility::Span span;ParsedGenericParameter(String a_name, utility::Span a_span) :name(a_name), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedGenericParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Parser {
  public:
size_t index;Array<lexer::Token> tokens;NonnullRefPtr<compiler::Compiler> compiler;ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>> parse_value_enum_body(const parser::ParsedRecord partial_enum, const parser::DefinitionLinkage definition_linkage);
ErrorOr<parser::ParsedMethod> parse_method(const parser::FunctionLinkage linkage, const parser::Visibility visibility, const bool is_comptime);
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_statement(const bool inside_block);
ErrorOr<String> parse_argument_label();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_array_or_dictionary();
ErrorOr<parser::ParsedBlock> parse_fat_arrow();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_typename();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_match_expression();
ErrorOr<void> error_with_hint(const String message, const utility::Span span, const String hint, const utility::Span hint_span);
ErrorOr<parser::ParsedField> parse_field(const parser::Visibility visibility);
ErrorOr<parser::ParsedRecord> parse_class(const parser::DefinitionLinkage definition_linkage);
bool eof() const;
ErrorOr<parser::ParsedRecord> parse_enum(const parser::DefinitionLinkage definition_linkage, const bool is_boxed);
utility::Span span(const size_t start, const size_t end) const;
ErrorOr<Array<parser::ParsedVarDecl>> parse_destructuring_assignment(const bool is_mutable);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand_base();
ErrorOr<parser::ParsedFunction> parse_function(const parser::FunctionLinkage linkage, const parser::Visibility visibility, const bool is_comptime);
static ErrorOr<parser::ParsedNamespace> parse(const NonnullRefPtr<compiler::Compiler> compiler, const Array<lexer::Token> tokens);
ErrorOr<parser::ParsedModuleImport> parse_module_import();
ErrorOr<parser::ParsedBlock> parse_block();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_longhand();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand();
ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operator(const bool allow_assignments);
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_for_statement();
ErrorOr<Array<parser::ParsedParameter>> parse_function_parameters();
ErrorOr<Optional<parser::ParsedCall>> parse_call();
ErrorOr<Array<parser::ParsedMatchCase>> parse_match_cases();
ErrorOr<parser::ParsedRecord> parse_struct(const parser::DefinitionLinkage definition_linkage);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_array_or_dictionary_literal();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand();
void skip_newlines();
bool eol() const;
ErrorOr<parser::ParsedMatchPattern> parse_match_pattern();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_lambda();
ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>> parse_struct_class_body(const parser::DefinitionLinkage definition_linkage, const parser::Visibility default_visibility, const bool is_class);
ErrorOr<parser::ParsedExternImport> parse_extern_import(parser::ParsedNamespace& parent);
ErrorOr<Array<parser::EnumVariantPatternArgument>> parse_variant_arguments();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_set_literal();
ErrorOr<parser::ParsedNamespace> parse_namespace();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_ampersand();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_asterisk();
ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>> parse_sum_enum_body(const parser::ParsedRecord partial_enum, const parser::DefinitionLinkage definition_linkage, const bool is_boxed);
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_tuple();
ErrorOr<Array<parser::ParsedCapture>> parse_captures();
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_postfix_colon_colon(const utility::Span start, const NonnullRefPtr<parser::ParsedExpression> expr);
Parser(size_t a_index, Array<lexer::Token> a_tokens, NonnullRefPtr<compiler::Compiler> a_compiler) :index(a_index), tokens(a_tokens), compiler(a_compiler){}

ErrorOr<void> parse_import(parser::ParsedNamespace& parent);
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_if_statement();
ErrorOr<NonnullRefPtr<parser::ParsedType>> parse_type_shorthand_set();
ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parse_guard_statement();
ErrorOr<parser::ParsedVarDecl> parse_variable_declaration(const bool is_mutable);
lexer::Token current() const;
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_expression(const bool allow_assignments, const bool allow_newlines);
ErrorOr<parser::Visibility> parse_restricted_visibility_modifier();
lexer::Token peek(const size_t steps) const;
ErrorOr<parser::ParsedRecord> parse_record(const parser::DefinitionLinkage definition_linkage);
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_try_block();
utility::Span empty_span() const;
ErrorOr<Array<parser::ParsedMatchPattern>> parse_match_patterns();
lexer::Token previous() const;
ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parse_operand_postfix_operator(const utility::Span start, const NonnullRefPtr<parser::ParsedExpression> expr);
ErrorOr<Array<parser::ParsedGenericParameter>> parse_generic_parameters();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Parser("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("index: "));TRY(builder.appendff("{}, ", index));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("tokens: "));TRY(builder.appendff("{}, ", tokens));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}", *compiler));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedMatchBody_Details {
struct Expression{
NonnullRefPtr<parser::ParsedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct Block{
parser::ParsedBlock value;
template<typename... Args>
Block(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedMatchBody : public Variant<ParsedMatchBody_Details::Expression, ParsedMatchBody_Details::Block> {
using Variant<ParsedMatchBody_Details::Expression, ParsedMatchBody_Details::Block>::Variant;
    using Expression = ParsedMatchBody_Details::Expression;
    using Block = ParsedMatchBody_Details::Block;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<ParsedMatchBody::Expression>();
TRY(builder.append("ParsedMatchBody::Expression"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Block */: {
[[maybe_unused]] auto const& that = this->template get<ParsedMatchBody::Block>();
TRY(builder.append("ParsedMatchBody::Block"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}};
struct ParsedMatchCase {
  public:
Array<parser::ParsedMatchPattern> patterns;utility::Span marker_span;parser::ParsedMatchBody body;ParsedMatchCase(Array<parser::ParsedMatchPattern> a_patterns, utility::Span a_marker_span, parser::ParsedMatchBody a_body) :patterns(a_patterns), marker_span(a_marker_span), body(a_body){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedMatchCase("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("patterns: "));TRY(builder.appendff("{}, ", patterns));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("marker_span: "));TRY(builder.appendff("{}, ", marker_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("body: "));TRY(builder.appendff("{}", body));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedStatement_Details {
struct Expression {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Expression(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Defer {
NonnullRefPtr<parser::ParsedStatement> statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Defer(_MemberT0&& member_0, _MemberT1&& member_1):
statement{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct UnsafeBlock {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
UnsafeBlock(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct DestructuringAssignment {
Array<parser::ParsedVarDecl> vars;
NonnullRefPtr<parser::ParsedStatement> var_decl;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
DestructuringAssignment(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vars{ forward<_MemberT0>(member_0)},
var_decl{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct VarDecl {
parser::ParsedVarDecl var;
NonnullRefPtr<parser::ParsedExpression> init;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
VarDecl(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
var{ forward<_MemberT0>(member_0)},
init{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct If {
NonnullRefPtr<parser::ParsedExpression> condition;
parser::ParsedBlock then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
If(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
condition{ forward<_MemberT0>(member_0)},
then_block{ forward<_MemberT1>(member_1)},
else_statement{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Block {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Block(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Loop {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Loop(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct While {
NonnullRefPtr<parser::ParsedExpression> condition;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
While(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
condition{ forward<_MemberT0>(member_0)},
block{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct For {
String iterator_name;
utility::Span name_span;
NonnullRefPtr<parser::ParsedExpression> range;
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
For(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
iterator_name{ forward<_MemberT0>(member_0)},
name_span{ forward<_MemberT1>(member_1)},
range{ forward<_MemberT2>(member_2)},
block{ forward<_MemberT3>(member_3)},
span{ forward<_MemberT4>(member_4)}
{}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Return {
Optional<NonnullRefPtr<parser::ParsedExpression>> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Return(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Throw {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Throw(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Yield {
NonnullRefPtr<parser::ParsedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Yield(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct InlineCpp {
parser::ParsedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
InlineCpp(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Guard {
NonnullRefPtr<parser::ParsedExpression> expr;
parser::ParsedBlock else_block;
parser::ParsedBlock remaining_code;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Guard(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
else_block{ forward<_MemberT1>(member_1)},
remaining_code{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ParsedStatement : public Variant<ParsedStatement_Details::Expression, ParsedStatement_Details::Defer, ParsedStatement_Details::UnsafeBlock, ParsedStatement_Details::DestructuringAssignment, ParsedStatement_Details::VarDecl, ParsedStatement_Details::If, ParsedStatement_Details::Block, ParsedStatement_Details::Loop, ParsedStatement_Details::While, ParsedStatement_Details::For, ParsedStatement_Details::Break, ParsedStatement_Details::Continue, ParsedStatement_Details::Return, ParsedStatement_Details::Throw, ParsedStatement_Details::Yield, ParsedStatement_Details::InlineCpp, ParsedStatement_Details::Guard, ParsedStatement_Details::Garbage>, public RefCounted<ParsedStatement> {
using Variant<ParsedStatement_Details::Expression, ParsedStatement_Details::Defer, ParsedStatement_Details::UnsafeBlock, ParsedStatement_Details::DestructuringAssignment, ParsedStatement_Details::VarDecl, ParsedStatement_Details::If, ParsedStatement_Details::Block, ParsedStatement_Details::Loop, ParsedStatement_Details::While, ParsedStatement_Details::For, ParsedStatement_Details::Break, ParsedStatement_Details::Continue, ParsedStatement_Details::Return, ParsedStatement_Details::Throw, ParsedStatement_Details::Yield, ParsedStatement_Details::InlineCpp, ParsedStatement_Details::Guard, ParsedStatement_Details::Garbage>::Variant;
    using Expression = ParsedStatement_Details::Expression;
    using Defer = ParsedStatement_Details::Defer;
    using UnsafeBlock = ParsedStatement_Details::UnsafeBlock;
    using DestructuringAssignment = ParsedStatement_Details::DestructuringAssignment;
    using VarDecl = ParsedStatement_Details::VarDecl;
    using If = ParsedStatement_Details::If;
    using Block = ParsedStatement_Details::Block;
    using Loop = ParsedStatement_Details::Loop;
    using While = ParsedStatement_Details::While;
    using For = ParsedStatement_Details::For;
    using Break = ParsedStatement_Details::Break;
    using Continue = ParsedStatement_Details::Continue;
    using Return = ParsedStatement_Details::Return;
    using Throw = ParsedStatement_Details::Throw;
    using Yield = ParsedStatement_Details::Yield;
    using InlineCpp = ParsedStatement_Details::InlineCpp;
    using Guard = ParsedStatement_Details::Guard;
    using Garbage = ParsedStatement_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ParsedStatement(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Expression>();
TRY(builder.append("ParsedStatement::Expression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Defer */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Defer>();
TRY(builder.append("ParsedStatement::Defer"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("statement: {}", that.statement));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* UnsafeBlock */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::UnsafeBlock>();
TRY(builder.append("ParsedStatement::UnsafeBlock"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* DestructuringAssignment */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::DestructuringAssignment>();
TRY(builder.append("ParsedStatement::DestructuringAssignment"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vars: {}", that.vars));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var_decl: {}", that.var_decl));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* VarDecl */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::VarDecl>();
TRY(builder.append("ParsedStatement::VarDecl"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var: {}", that.var));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("init: {}", that.init));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* If */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::If>();
TRY(builder.append("ParsedStatement::If"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("condition: {}", that.condition));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("then_block: {}", that.then_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("else_statement: {}", that.else_statement));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* Block */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Block>();
TRY(builder.append("ParsedStatement::Block"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 7 /* Loop */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Loop>();
TRY(builder.append("ParsedStatement::Loop"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 8 /* While */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::While>();
TRY(builder.append("ParsedStatement::While"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("condition: {}", that.condition));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 9 /* For */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::For>();
TRY(builder.append("ParsedStatement::For"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("iterator_name: \"{}\"", that.iterator_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name_span: {}", that.name_span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("range: {}", that.range));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 10 /* Break */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Break>();
TRY(builder.append("ParsedStatement::Break"));
TRY(builder.appendff("({})", that.value));
break;}
case 11 /* Continue */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Continue>();
TRY(builder.append("ParsedStatement::Continue"));
TRY(builder.appendff("({})", that.value));
break;}
case 12 /* Return */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Return>();
TRY(builder.append("ParsedStatement::Return"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 13 /* Throw */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Throw>();
TRY(builder.append("ParsedStatement::Throw"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 14 /* Yield */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Yield>();
TRY(builder.append("ParsedStatement::Yield"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 15 /* InlineCpp */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::InlineCpp>();
TRY(builder.append("ParsedStatement::InlineCpp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 16 /* Guard */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Guard>();
TRY(builder.append("ParsedStatement::Guard"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("else_block: {}", that.else_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("remaining_code: {}", that.remaining_code));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 17 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<ParsedStatement::Garbage>();
TRY(builder.append("ParsedStatement::Garbage"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}utility::Span span() const;
};
struct ParsedModuleImport {
  public:
parser::ImportName module_name;Optional<parser::ImportName> alias_name;Array<parser::ImportName> import_list;ParsedModuleImport(parser::ImportName a_module_name, Optional<parser::ImportName> a_alias_name, Array<parser::ImportName> a_import_list) :module_name(a_module_name), alias_name(a_alias_name), import_list(a_import_list){}

bool is_equivalent_to(const parser::ParsedModuleImport other) const;
bool has_same_alias_than(const parser::ParsedModuleImport other) const;
bool has_same_import_semantics(const parser::ParsedModuleImport other) const;
ErrorOr<void> merge_import_list(const Array<parser::ImportName> list);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedModuleImport("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_name: "));TRY(builder.appendff("{}, ", module_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("alias_name: "));TRY(builder.appendff("{}, ", alias_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_list: "));TRY(builder.appendff("{}", import_list));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ParsedRecord {
  public:
String name;utility::Span name_span;Array<parser::ParsedGenericParameter> generic_parameters;parser::DefinitionLinkage definition_linkage;Array<parser::ParsedMethod> methods;parser::RecordType record_type;ParsedRecord(String a_name, utility::Span a_name_span, Array<parser::ParsedGenericParameter> a_generic_parameters, parser::DefinitionLinkage a_definition_linkage, Array<parser::ParsedMethod> a_methods, parser::RecordType a_record_type) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), definition_linkage(a_definition_linkage), methods(a_methods), record_type(a_record_type){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ParsedRecord("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("methods: "));TRY(builder.appendff("{}, ", methods));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}", record_type));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct SumEnumVariant {
  public:
String name;utility::Span span;Optional<Array<parser::ParsedVarDecl>> params;SumEnumVariant(String a_name, utility::Span a_span, Optional<Array<parser::ParsedVarDecl>> a_params) :name(a_name), span(a_span), params(a_params){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("SumEnumVariant("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}", params));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ParsedMatchPattern_Details {
struct EnumVariant {
Array<Tuple<String,utility::Span>> variant_name;
Array<parser::EnumVariantPatternArgument> variant_arguments;
utility::Span arguments_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
variant_name{ forward<_MemberT0>(member_0)},
variant_arguments{ forward<_MemberT1>(member_1)},
arguments_span{ forward<_MemberT2>(member_2)}
{}
};
struct Expression{
NonnullRefPtr<parser::ParsedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct CatchAll {};
}
struct ParsedMatchPattern : public Variant<ParsedMatchPattern_Details::EnumVariant, ParsedMatchPattern_Details::Expression, ParsedMatchPattern_Details::CatchAll> {
using Variant<ParsedMatchPattern_Details::EnumVariant, ParsedMatchPattern_Details::Expression, ParsedMatchPattern_Details::CatchAll>::Variant;
    using EnumVariant = ParsedMatchPattern_Details::EnumVariant;
    using Expression = ParsedMatchPattern_Details::Expression;
    using CatchAll = ParsedMatchPattern_Details::CatchAll;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* EnumVariant */: {
[[maybe_unused]] auto const& that = this->template get<ParsedMatchPattern::EnumVariant>();
TRY(builder.append("ParsedMatchPattern::EnumVariant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("variant_name: {}", that.variant_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("variant_arguments: {}", that.variant_arguments));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("arguments_span: {}", that.arguments_span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<ParsedMatchPattern::Expression>();
TRY(builder.append("ParsedMatchPattern::Expression"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* CatchAll */: {
[[maybe_unused]] auto const& that = this->template get<ParsedMatchPattern::CatchAll>();
TRY(builder.append("ParsedMatchPattern::CatchAll"));
break;}
}
return builder.to_string();
}};
static ErrorOr<utility::Span> merge_spans(const utility::Span start,const utility::Span end) {
{
if (((((((end).file_id)).id) == static_cast<size_t>(0ULL)) && ((((end).start) == static_cast<size_t>(0ULL)) && (((end).end) == static_cast<size_t>(0ULL))))){
return (start);
}
if ((((((start).file_id)).id) != ((((end).file_id)).id))){
utility::panic(TRY((String::formatted(String("cannot merge spans from two different files ({} and {})"),start,end))));
}
return (utility::Span(((start).file_id),((start).start),((end).end)));
}
}

static bool binary_operator_equals(const parser::BinaryOperator lhs_op,const parser::BinaryOperator rhs_op) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = lhs_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 0 /* Add */));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 1 /* Subtract */));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 2 /* Multiply */));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 3 /* Divide */));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 4 /* Modulo */));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 5 /* LessThan */));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 6 /* LessThanOrEqual */));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 7 /* GreaterThan */));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 8 /* GreaterThanOrEqual */));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 9 /* Equal */));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 10 /* NotEqual */));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 11 /* BitwiseAnd */));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 12 /* BitwiseXor */));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 13 /* BitwiseOr */));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 14 /* BitwiseLeftShift */));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 15 /* BitwiseRightShift */));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 16 /* ArithmeticLeftShift */));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticRightShift>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 17 /* ArithmeticRightShift */));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 19 /* LogicalOr */));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 18 /* LogicalAnd */));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 20 /* NoneCoalescing */));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 21 /* Assign */));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 22 /* BitwiseAndAssign */));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 23 /* BitwiseOrAssign */));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 24 /* BitwiseXorAssign */));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 25 /* BitwiseLeftShiftAssign */));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 26 /* BitwiseRightShiftAssign */));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 27 /* AddAssign */));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 28 /* SubtractAssign */));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 29 /* MultiplyAssign */));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 30 /* ModuloAssign */));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 31 /* DivideAssign */));
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 32 /* NoneCoalescingAssign */));
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Garbage>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 33 /* Garbage */));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool unary_operator_equals(const parser::UnaryOperator lhs_op,const parser::UnaryOperator rhs_op) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = lhs_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 0 /* PreIncrement */));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 1 /* PostIncrement */));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 2 /* PreDecrement */));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 3 /* PostDecrement */));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Negate>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 4 /* Negate */));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 5 /* Dereference */));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 6 /* RawAddress */));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Reference>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 7 /* Reference */));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::MutableReference>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 8 /* MutableReference */));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 9 /* LogicalNot */));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue(((rhs_op).index() == 10 /* BitwiseNot */));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = rhs_op;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_statement_equals(const NonnullRefPtr<parser::ParsedStatement> lhs_statement,const NonnullRefPtr<parser::ParsedStatement> rhs_statement) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *lhs_statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& lhs_statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& rhs_statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(parser::parsed_statement_equals(lhs_statement,rhs_statement));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& lhs_var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& lhs_init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& rhs_var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& rhs_init = __jakt_match_value.init;
return JaktInternal::ExplicitValue((parser::parsed_var_decl_equals(lhs_var,rhs_var) && parser::parsed_expression_equals(lhs_init,rhs_init)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& lhs_vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& lhs_var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& rhs_vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& rhs_var_decl = __jakt_match_value.var_decl;
{
if ((((lhs_vars).size()) != ((rhs_vars).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_vars).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(parser::parsed_var_decl_equals(((lhs_vars)[i]),((rhs_vars)[i]))))){
return (false);
}
}

}
}

if ((!(parser::parsed_statement_equals(lhs_var_decl,rhs_var_decl)))){
return (false);
}
return (true);
}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& lhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& lhs_then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& lhs_else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& rhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& rhs_then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& rhs_else_statement = __jakt_match_value.else_statement;
{
if ((!((parser::parsed_expression_equals(lhs_condition,rhs_condition) && parser::parsed_block_equals(lhs_then_block,rhs_then_block))))){
return (false);
}
if ((!(((lhs_else_statement).has_value())))){
return ((!(((rhs_else_statement).has_value()))));
}
else {
if ((!(((rhs_else_statement).has_value())))){
return (false);
}
if (parser::parsed_statement_equals((lhs_else_statement.value()),(rhs_else_statement.value()))){
return (true);
}
return (false);
}

}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,rhs_block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& lhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& rhs_condition = __jakt_match_value.condition;
parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_condition,rhs_condition) && parser::parsed_block_equals(lhs_block,rhs_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& lhs_iterator_name = __jakt_match_value.iterator_name;
NonnullRefPtr<parser::ParsedExpression> const& lhs_range = __jakt_match_value.range;
parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& rhs_iterator_name = __jakt_match_value.iterator_name;
NonnullRefPtr<parser::ParsedExpression> const& rhs_range = __jakt_match_value.range;
parser::ParsedBlock const& rhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_7; {
__jakt_var_7 = (((lhs_iterator_name == rhs_iterator_name) && parser::parsed_expression_equals(lhs_range,rhs_range)) && parser::parsed_block_equals(lhs_block,rhs_block)); goto __jakt_label_5;

}
__jakt_label_5:; __jakt_var_7.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
return JaktInternal::ExplicitValue(((rhs_statement)->index() == 10 /* Break */));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
return JaktInternal::ExplicitValue(((rhs_statement)->index() == 11 /* Continue */));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& rhs_expr = __jakt_match_value.expr;
{
if ((!(((lhs_expr).has_value())))){
return ((!(((rhs_expr).has_value()))));
}
else {
if ((!(((rhs_expr).has_value())))){
return (false);
}
if (parser::parsed_expression_equals((lhs_expr.value()),(rhs_expr.value()))){
return (true);
}
return (false);
}

}
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& lhs_block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(parser::parsed_block_equals(lhs_block,block));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedBlock const& else_block = __jakt_match_value.else_block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_statement;
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::ParsedBlock const& rhs_else_block = __jakt_match_value.else_block;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(expr,rhs_expr) && parser::parsed_block_equals(else_block,rhs_else_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
return JaktInternal::ExplicitValue(((rhs_statement)->index() == 17 /* Garbage */));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_var_decl_equals(const parser::ParsedVarDecl lhs_var_decl,const parser::ParsedVarDecl rhs_var_decl) {
{
return (((((lhs_var_decl).name) == ((rhs_var_decl).name)) && (((lhs_var_decl).is_mutable) == ((rhs_var_decl).is_mutable))));
}
}

static bool parsed_call_equals(const parser::ParsedCall lhs_parsed_call,const parser::ParsedCall rhs_parsed_call) {
{
if ((((lhs_parsed_call).name) != ((rhs_parsed_call).name))){
return (false);
}
if ((((((lhs_parsed_call).args)).size()) != ((((rhs_parsed_call).args)).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((lhs_parsed_call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const String lhs_str = ((((((lhs_parsed_call).args))[i])).get<0>());
const String rhs_str = ((((((rhs_parsed_call).args))[i])).get<0>());
const NonnullRefPtr<parser::ParsedExpression> lhs_expr = ((((((lhs_parsed_call).args))[i])).get<2>());
const NonnullRefPtr<parser::ParsedExpression> rhs_expr = ((((((rhs_parsed_call).args))[i])).get<2>());
if (((lhs_str != rhs_str) || (!(parser::parsed_expression_equals(lhs_expr,rhs_expr))))){
return (false);
}
}

}
}

return (true);
}
}

static bool parsed_expression_equals(const NonnullRefPtr<parser::ParsedExpression> lhs_expression,const NonnullRefPtr<parser::ParsedExpression> rhs_expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *lhs_expression;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((((lhs_val).to_usize()) == ((rhs_val).to_usize())));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& lhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& rhs_val = __jakt_match_value.val;
return JaktInternal::ExplicitValue((lhs_val == rhs_val));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& lhs_call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& rhs_call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(parser::parsed_call_equals(lhs_call,rhs_call));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
parser::ParsedCall const& lhs_call = __jakt_match_value.call;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::ParsedCall const& rhs_call = __jakt_match_value.call;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && parser::parsed_call_equals(lhs_call,rhs_call)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
size_t const& lhs_index = __jakt_match_value.index;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
size_t const& rhs_index = __jakt_match_value.index;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && (lhs_index == rhs_index)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
String const& lhs_field = __jakt_match_value.field;
bool const& lhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
String const& rhs_field = __jakt_match_value.field;
bool const& rhs_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue((((lhs_optional == rhs_optional) && parser::parsed_expression_equals(lhs_expr,rhs_expr)) && (lhs_field == rhs_field)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& lhs_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& rhs_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((lhs_name == rhs_name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& lhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& lhs_index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& rhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& rhs_index = __jakt_match_value.index;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_base,rhs_base) && parser::parsed_expression_equals(lhs_index,rhs_index)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedRangeExpression>();NonnullRefPtr<parser::ParsedExpression> const& lhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& lhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& lhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedRangeExpression>();NonnullRefPtr<parser::ParsedExpression> const& rhs_base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& rhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& rhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(((parser::parsed_expression_equals(lhs_base,rhs_base) && parser::parsed_expression_equals(lhs_from,rhs_from)) && parser::parsed_expression_equals(lhs_to,rhs_to)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
parser::UnaryOperator const& lhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
parser::UnaryOperator const& rhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_expr,rhs_expr) && parser::unary_operator_equals(lhs_op,rhs_op)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs_lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& lhs_op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& lhs_rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& rhs_lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& rhs_op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs_rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(((parser::parsed_expression_equals(lhs_lhs,rhs_lhs) && parser::binary_operator_equals(lhs_op,rhs_op)) && parser::parsed_expression_equals(lhs_rhs,rhs_rhs)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& lhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& rhs_op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(parser::binary_operator_equals(lhs_op,rhs_op));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
return JaktInternal::ExplicitValue(((rhs_expression)->index() == 16 /* OptionalNone */));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& lhs_fill_size = __jakt_match_value.fill_size;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& rhs_fill_size = __jakt_match_value.fill_size;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_8; {
if ((!(((lhs_fill_size).has_value())))){
if (((rhs_fill_size).has_value())){
return (false);
}
}
else {
if ((!(((rhs_fill_size).has_value())))){
return (false);
}
if ((!(parser::parsed_expression_equals((lhs_fill_size.value()),(rhs_fill_size.value()))))){
return (false);
}
}

if (((!(((lhs_values).size()))) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i]))))){
return (false);
}
}

}
}

__jakt_var_8 = true; goto __jakt_label_6;

}
__jakt_label_6:; __jakt_var_8.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_9; {
if (((!(((lhs_values).size()))) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!((parser::parsed_expression_equals(((((lhs_values)[i])).get<0>()),((((rhs_values)[i])).get<0>())) && parser::parsed_expression_equals(((((lhs_values)[i])).get<1>()),((((rhs_values)[i])).get<1>())))))){
return (false);
}
}

}
}

__jakt_var_9 = true; goto __jakt_label_7;

}
__jakt_label_7:; __jakt_var_9.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_10; {
if (((!(((lhs_values).size()))) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i]))))){
return (false);
}
}

}
}

__jakt_var_10 = true; goto __jakt_label_8;

}
__jakt_label_8:; __jakt_var_10.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& lhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& rhs_values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_11; {
if (((!(((lhs_values).size()))) == ((rhs_values).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_values).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(parser::parsed_expression_equals(((lhs_values)[i]),((rhs_values)[i]))))){
return (false);
}
}

}
}

__jakt_var_11 = true; goto __jakt_label_9;

}
__jakt_label_9:; __jakt_var_11.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& lhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& lhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& rhs_from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& rhs_to = __jakt_match_value.to;
return JaktInternal::ExplicitValue((parser::parsed_expression_equals(lhs_from,rhs_from) && parser::parsed_expression_equals(lhs_to,rhs_to)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(parser::parsed_expression_equals(lhs_expr,rhs_expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& lhs_name = __jakt_match_value.name;
Array<String> const& lhs_namespace = __jakt_match_value.namespace_;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& rhs_name = __jakt_match_value.name;
Array<String> const& rhs_namespace = __jakt_match_value.namespace_;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_12; {
if ((((lhs_namespace).size()) != ((rhs_namespace).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((lhs_namespace).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((((lhs_namespace)[i]) != ((rhs_namespace)[i]))){
return (false);
}
}

}
}

__jakt_var_12 = (lhs_name == rhs_name); goto __jakt_label_10;

}
__jakt_label_10:; __jakt_var_12.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Try>();NonnullRefPtr<parser::ParsedExpression> const& lhs_expr = __jakt_match_value.expr;
Optional<parser::ParsedBlock> const& lhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Try>();NonnullRefPtr<parser::ParsedExpression> const& rhs_expr = __jakt_match_value.expr;
Optional<parser::ParsedBlock> const& rhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_13; {
bool equals = parser::parsed_expression_equals(lhs_expr,rhs_expr);
if (equals){
if (((lhs_catch_block).has_value())){
if (((rhs_catch_block).has_value())){
(equals = parser::parsed_block_equals((lhs_catch_block.value()),(rhs_catch_block.value())));
}
else {
(equals = false);
}

}
else {
(equals = (!(((rhs_catch_block).has_value()))));
}

}
__jakt_var_13 = equals; goto __jakt_label_11;

}
__jakt_label_11:; __jakt_var_13.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::TryBlock>();NonnullRefPtr<parser::ParsedStatement> const& lhs_stmt = __jakt_match_value.stmt;
String const& lhs_error_name = __jakt_match_value.error_name;
parser::ParsedBlock const& lhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *rhs_expression;
switch(__jakt_match_variant.index()) {
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::TryBlock>();NonnullRefPtr<parser::ParsedStatement> const& rhs_stmt = __jakt_match_value.stmt;
String const& rhs_error_name = __jakt_match_value.error_name;
parser::ParsedBlock const& rhs_catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(((parser::parsed_statement_equals(lhs_stmt,rhs_stmt) && (lhs_error_name == rhs_error_name)) && parser::parsed_block_equals(lhs_catch_block,rhs_catch_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();return JaktInternal::ExplicitValue(false);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
return JaktInternal::ExplicitValue(((rhs_expression)->index() == 29 /* Garbage */));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static bool parsed_block_equals(const parser::ParsedBlock lhs_block,const parser::ParsedBlock rhs_block) {
{
if ((((((lhs_block).stmts)).size()) != ((((rhs_block).stmts)).size()))){
return (false);
}
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((lhs_block).stmts)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t x = (_magic_value.value());
{
const NonnullRefPtr<parser::ParsedStatement> lhs_statement = ((((lhs_block).stmts))[x]);
const NonnullRefPtr<parser::ParsedStatement> rhs_statement = ((((rhs_block).stmts))[x]);
const bool are_statements_equal = parser::parsed_statement_equals(((((lhs_block).stmts))[x]),((((rhs_block).stmts))[x]));
if ((!(are_statements_equal))){
return (false);
}
}

}
}

return (true);
}
}

Optional<utility::Span> parser::ParsedBlock::find_yield_span() const {
{
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((*this).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
if (((stmt)->index() == 14 /* Yield */)){
const NonnullRefPtr<parser::ParsedExpression> expr = (stmt->get<parser::ParsedStatement::Yield>()).expr;
return (((expr)->span()));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

ErrorOr<Optional<utility::Span>> parser::ParsedBlock::span(const parser::Parser parser) const {
{
Optional<size_t> start = JaktInternal::OptionalNone();
size_t end = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((*this).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
const utility::Span stmt_span = ((stmt)->span());
if ((!(((start).has_value())))){
(start = ((stmt_span).start));
}
(end = ((stmt_span).end));
}

}
}

if (((start).has_value())){
return (((parser).span((start.value()),end)));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<bool> parser::ParsedExternImport::is_equivalent_to(const parser::ParsedExternImport other) const {
{
return ((((((*this).is_c) && ((other).is_c)) && (((*this).get_path()) == ((other).get_path()))) && (((*this).get_name()) == ((other).get_name()))));
}
}

String parser::ParsedExternImport::get_name() const {
{
return ((((((*this).assigned_namespace)).name).value()));
}
}

String parser::ParsedExternImport::get_path() const {
{
return ((((((*this).assigned_namespace)).import_path_if_extern).value()));
}
}

bool parser::ParsedModuleImport::is_equivalent_to(const parser::ParsedModuleImport other) const {
{
return ((((((((*this).module_name)).name) == ((((other).module_name)).name)) && ((*this).has_same_alias_than(other))) && ((*this).has_same_import_semantics(other))));
}
}

bool parser::ParsedModuleImport::has_same_alias_than(const parser::ParsedModuleImport other) const {
{
if (((((*this).alias_name)).has_value())){
return ((((((other).alias_name)).has_value()) && ((((((other).alias_name).value())).name) == (((((*this).alias_name).value())).name))));
}
else {
return ((!(((((other).alias_name)).has_value()))));
}

}
}

bool parser::ParsedModuleImport::has_same_import_semantics(const parser::ParsedModuleImport other) const {
{
return ((((((*this).import_list)).is_empty()) == ((((other).import_list)).is_empty())));
}
}

ErrorOr<void> parser::ParsedModuleImport::merge_import_list(const Array<parser::ImportName> list) {
{
TRY((((((*this).import_list)).add_capacity(((list).size())))));
Set<String> name_set = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ImportName> _magic = ((((*this).import_list)).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ImportName import_ = (_magic_value.value());
{
TRY((((name_set).add(((import_).name)))));
}

}
}

{
ArrayIterator<parser::ImportName> _magic = ((list).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ImportName import_ = (_magic_value.value());
{
if ((!(((name_set).contains(((import_).name)))))){
TRY((((name_set).add(((import_).name)))));
TRY((((((*this).import_list)).push(import_))));
}
}

}
}

}
return {};
}

ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>> parser::Parser::parse_value_enum_body(const parser::ParsedRecord partial_enum,const parser::DefinitionLinkage definition_linkage) {
{
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Array<parser::ValueEnumVariant> variants = (TRY((Array<parser::ValueEnumVariant>::create_with({}))));
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `{` to start the enum body"),((((*this).current())).span())))));
}

((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected variant name"),((((*this).previous())).span())))));
return ((Tuple{variants, methods}));
}
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if (((((*this).peek(static_cast<size_t>(1ULL)))).index() == 17 /* Equal */)){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
TRY((((variants).push(parser::ValueEnumVariant(name,span,expr)))));
}
else {
((((*this).index)++));
TRY((((variants).push(parser::ValueEnumVariant(name,span,JaktInternal::OptionalNone())))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,is_comptime))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comptime>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,is_comptime))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected identifier or the end of enum block"),((((*this).current())).span())))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (((*this).eof())){
TRY((((*this).error(String("Invalid enum definition, expected `}`"),((((*this).current())).span())))));
return ((Tuple{variants, methods}));
}
if (((variants).is_empty())){
TRY((((*this).error(String("Empty enums are not allowed"),((partial_enum).name_span)))));
}
return ((Tuple{variants, methods}));
}
}

ErrorOr<parser::ParsedMethod> parser::Parser::parse_method(const parser::FunctionLinkage linkage,const parser::Visibility visibility,const bool is_comptime) {
{
parser::ParsedFunction parsed_function = TRY((((*this).parse_function(linkage,visibility,is_comptime))));
if (((linkage).index() == 1 /* External */)){
(((parsed_function).must_instantiate) = true);
}
return (parser::ParsedMethod(parsed_function,visibility));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_statement(const bool inside_block) {
{
const utility::Span start = ((((*this).current())).span());
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedStatement>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 66: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Cpp>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_14; {
((((*this).index)++));
__jakt_var_14 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::InlineCpp>(TRY((((*this).parse_block()))),TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_12;

}
__jakt_label_12:; __jakt_var_14.release_value(); }));
};/*case end*/
case 67: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Defer>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_15; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedStatement> statement = TRY((((*this).parse_statement(false))));
__jakt_var_15 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Defer>(statement,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_13;

}
__jakt_label_13:; __jakt_var_15.release_value(); }));
};/*case end*/
case 97: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Unsafe>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_16; {
((((*this).index)++));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_16 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::UnsafeBlock>(block,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_14;

}
__jakt_label_14:; __jakt_var_16.release_value(); }));
};/*case end*/
case 62: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Break>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_17; {
((((*this).index)++));
__jakt_var_17 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Break>(start))); goto __jakt_label_15;

}
__jakt_label_15:; __jakt_var_17.release_value(); }));
};/*case end*/
case 65: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Continue>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_18; {
((((*this).index)++));
__jakt_var_18 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Continue>(start))); goto __jakt_label_16;

}
__jakt_label_16:; __jakt_var_18.release_value(); }));
};/*case end*/
case 80: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Loop>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_19; {
((((*this).index)++));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_19 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Loop>(block,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_17;

}
__jakt_label_17:; __jakt_var_19.release_value(); }));
};/*case end*/
case 93: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Throw>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_20; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
__jakt_var_20 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Throw>(expr,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_18;

}
__jakt_label_18:; __jakt_var_20.release_value(); }));
};/*case end*/
case 99: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::While>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_21; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> condition = TRY((((*this).parse_expression(false,true))));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_21 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::While>(condition,block,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_19;

}
__jakt_label_19:; __jakt_var_21.release_value(); }));
};/*case end*/
case 100: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Yield>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_22; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if ((!(inside_block))){
TRY((((*this).error(String("yield can only be used inside a block"),TRY((parser::merge_spans(start,((expr)->span()))))))));
}
__jakt_var_22 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Yield>(expr,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_20;

}
__jakt_label_20:; __jakt_var_22.release_value(); }));
};/*case end*/
case 89: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Return>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_23; {
((((*this).index)++));
__jakt_var_23 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedStatement>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
case 55: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eof>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(JaktInternal::OptionalNone(),((((*this).current())).span())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(TRY((((*this).parse_expression(false,false)))),TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_21;

}
__jakt_label_21:; __jakt_var_23.release_value(); }));
};/*case end*/
case 79: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Let>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_24; {
const bool is_mutable = ((((*this).current())).index() == 82 /* Mut */);
((((*this).index)++));
Array<parser::ParsedVarDecl> vars = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
bool is_destructuring_assingment = false;
String tuple_var_name = String("");
parser::ParsedVarDecl tuple_var_decl = parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,JaktInternal::OptionalNone(),((((*this).current())).span()));
if (((((*this).current())).index() == 8 /* LParen */)){
(vars = TRY((((*this).parse_destructuring_assignment(is_mutable)))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = ((vars).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedVarDecl var = (_magic_value.value());
{
(tuple_var_name += ((var).name));
(tuple_var_name += String("_"));
}

}
}

(((tuple_var_decl).name) = tuple_var_name);
(is_destructuring_assingment = true);
}
else {
(tuple_var_decl = TRY((((*this).parse_variable_declaration(is_mutable)))));
}

const NonnullRefPtr<parser::ParsedExpression> init = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_25; {
((((*this).index)++));
__jakt_var_25 = TRY((((*this).parse_expression(false,false)))); goto __jakt_label_23;

}
__jakt_label_23:; __jakt_var_25.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_26; {
TRY((((*this).error(String("Expected initializer"),((((*this).current())).span())))));
__jakt_var_26 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))); goto __jakt_label_24;

}
__jakt_label_24:; __jakt_var_26.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(tuple_var_decl,init,TRY((parser::merge_spans(start,((((*this).previous())).span())))))));
if (is_destructuring_assingment){
const NonnullRefPtr<parser::ParsedStatement> old_return_statement = return_statement;
(return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::DestructuringAssignment>(vars,old_return_statement,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
}
__jakt_var_24 = return_statement; goto __jakt_label_22;

}
__jakt_label_22:; __jakt_var_24.release_value(); }));
};/*case end*/
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_27; {
const bool is_mutable = ((((*this).current())).index() == 82 /* Mut */);
((((*this).index)++));
Array<parser::ParsedVarDecl> vars = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
bool is_destructuring_assingment = false;
String tuple_var_name = String("");
parser::ParsedVarDecl tuple_var_decl = parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,JaktInternal::OptionalNone(),((((*this).current())).span()));
if (((((*this).current())).index() == 8 /* LParen */)){
(vars = TRY((((*this).parse_destructuring_assignment(is_mutable)))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = ((vars).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedVarDecl var = (_magic_value.value());
{
(tuple_var_name += ((var).name));
(tuple_var_name += String("_"));
}

}
}

(((tuple_var_decl).name) = tuple_var_name);
(is_destructuring_assingment = true);
}
else {
(tuple_var_decl = TRY((((*this).parse_variable_declaration(is_mutable)))));
}

const NonnullRefPtr<parser::ParsedExpression> init = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_28; {
((((*this).index)++));
__jakt_var_28 = TRY((((*this).parse_expression(false,false)))); goto __jakt_label_26;

}
__jakt_label_26:; __jakt_var_28.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_29; {
TRY((((*this).error(String("Expected initializer"),((((*this).current())).span())))));
__jakt_var_29 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))); goto __jakt_label_27;

}
__jakt_label_27:; __jakt_var_29.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(tuple_var_decl,init,TRY((parser::merge_spans(start,((((*this).previous())).span())))))));
if (is_destructuring_assingment){
const NonnullRefPtr<parser::ParsedStatement> old_return_statement = return_statement;
(return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::DestructuringAssignment>(vars,old_return_statement,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
}
__jakt_var_27 = return_statement; goto __jakt_label_25;

}
__jakt_label_25:; __jakt_var_27.release_value(); }));
};/*case end*/
case 75: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_if_statement()))));
};/*case end*/
case 72: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::For>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_for_statement()))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_30; {
const parser::ParsedBlock block = TRY((((*this).parse_block())));
__jakt_var_30 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_28;

}
__jakt_label_28:; __jakt_var_30.release_value(); }));
};/*case end*/
case 101: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Guard>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_guard_statement()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_31; {
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(true,false))));
__jakt_var_31 = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Expression>(expr,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_29;

}
__jakt_label_29:; __jakt_var_31.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<String> parser::Parser::parse_argument_label() {
{
if ((((((*this).peek(static_cast<size_t>(1ULL)))).index() == 6 /* Colon */) && ((((*this).current())).index() == 4 /* Identifier */))){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
return (name);
}
return (String(""));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_array_or_dictionary() {
{
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
if (((((*this).current())).index() == 13 /* RSquare */)){
((((*this).index)++));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::JaktArray>(inner,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
}
if (((((*this).current())).index() == 6 /* Colon */)){
((((*this).index)++));
const NonnullRefPtr<parser::ParsedType> value = TRY((((*this).parse_typename())));
if (((((*this).current())).index() == 13 /* RSquare */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected ']'"),((((*this).current())).span())))));
}

return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Dictionary>(inner,value,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
}
TRY((((*this).error(String("Expected shorthand type"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<parser::ParsedBlock> parser::Parser::parse_fat_arrow() {
{
((((*this).index)++));
const utility::Span start = ((((*this).current())).span());
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
const NonnullRefPtr<parser::ParsedStatement> return_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(expr,TRY((parser::merge_spans(start,((((*this).current())).span())))))));
return (parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({return_statement}))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_typename() {
{
const utility::Span start = ((((*this).current())).span());
bool is_reference = false;
bool is_mutable_reference = false;
if (((((*this).current())).index() == 38 /* Ampersand */)){
(is_reference = true);
((((*this).index)++));
if (((((*this).current())).index() == 82 /* Mut */)){
(is_mutable_reference = true);
((((*this).index)++));
}
}
NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_type_shorthand())));
if (((parsed_type)->index() == 13 /* Empty */)){
(parsed_type = TRY((((*this).parse_type_longhand()))));
}
if (((((*this).current())).index() == 48 /* QuestionMark */)){
((((*this).index)++));
const utility::Span span = TRY((parser::merge_spans(start,((((*this).current())).span()))));
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Optional>(parsed_type,span))));
}
if (is_reference){
const utility::Span span = TRY((parser::merge_spans(start,((((*this).current())).span()))));
if (is_mutable_reference){
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::MutableReference>(parsed_type,span))));
}
else {
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Reference>(parsed_type,span))));
}

}
return (parsed_type);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_match_expression() {
{
utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,true))));
const Array<parser::ParsedMatchCase> cases = TRY((((*this).parse_match_cases())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Match>(expr,cases,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
}
}

ErrorOr<void> parser::Parser::error_with_hint(const String message,const utility::Span span,const String hint,const utility::Span hint_span) {
{
if ((!(((((*this).compiler))->ignore_parser_errors)))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::MessageWithHint(message,span,hint,hint_span)))));
}
}
return {};
}

ErrorOr<parser::ParsedField> parser::Parser::parse_field(const parser::Visibility visibility) {
{
const parser::ParsedVarDecl parsed_variable_declaration = TRY((((*this).parse_variable_declaration(true))));
if (((((parsed_variable_declaration).parsed_type))->index() == 13 /* Empty */)){
TRY((((*this).error(String("Field missing type"),((parsed_variable_declaration).span)))));
}
return (parser::ParsedField(parsed_variable_declaration,visibility));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_class(const parser::DefinitionLinkage definition_linkage) {
{
parser::ParsedRecord parsed_class = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
Optional<NonnullRefPtr<parser::ParsedType>> super_class = JaktInternal::OptionalNone();
if (((((*this).current())).index() == 64 /* Class */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `class` keyword"),((((*this).current())).span())))));
return (parsed_class);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected name"),((((*this).current())).span())))));
return (parsed_class);
}
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
((((*this).index)++));
(((parsed_class).name) = name);
(((parsed_class).name_span) = span);
}
else {
TRY((((*this).error(String("Incomplete class definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected generic parameters or super class or body"),((((*this).current())).span())))));
return (parsed_class);
}
(((parsed_class).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected super class or body"),((((*this).current())).span())))));
return (parsed_class);
}
if (((((*this).current())).index() == 6 /* Colon */)){
((((*this).index)++));
(super_class = TRY((((*this).parse_typename()))));
}
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete class definition, expected body"),((((*this).current())).span())))));
return (parsed_class);
}
const Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>> fields_methods = TRY((((*this).parse_struct_class_body(definition_linkage,typename parser::Visibility::Private(),true))));
(((parsed_class).methods) = ((fields_methods).get<1>()));
(((parsed_class).record_type) = typename parser::RecordType::Class(((fields_methods).get<0>()),super_class));
return (parsed_class);
}
}

bool parser::Parser::eof() const {
{
return ((((*this).index) >= (JaktInternal::checked_sub<size_t>(((((*this).tokens)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_enum(const parser::DefinitionLinkage definition_linkage,const bool is_boxed) {
{
parser::ParsedRecord parsed_enum = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
Optional<NonnullRefPtr<parser::ParsedType>> underlying_type = JaktInternal::OptionalNone();
if (((((*this).current())).index() == 69 /* Enum */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected enum keyword"),((((*this).current())).span())))));
return (parsed_enum);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected name"),((((*this).current())).span())))));
return (parsed_enum);
}
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
(((parsed_enum).name) = name);
(((parsed_enum).name_span) = span);
((((*this).index)++));
}
else {
TRY((((*this).error(String("Incomplete enum definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected generic parameters or underlying type or body"),((((*this).current())).span())))));
return (parsed_enum);
}
if (((((*this).current())).index() == 29 /* LessThan */)){
(((parsed_enum).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
}
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected underlying type or body"),((((*this).current())).span())))));
return (parsed_enum);
}
if (((((*this).current())).index() == 6 /* Colon */)){
if (is_boxed){
TRY((((*this).error(String("Invalid enum definition: Value enums must not have an underlying type"),((((*this).current())).span())))));
}
((((*this).index)++));
(underlying_type = TRY((((*this).parse_typename()))));
}
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected body"),((((*this).current())).span())))));
return (parsed_enum);
}
if (((underlying_type).has_value())){
const Tuple<Array<parser::ValueEnumVariant>,Array<parser::ParsedMethod>> variants_methods = TRY((((*this).parse_value_enum_body(parsed_enum,definition_linkage))));
(((parsed_enum).methods) = ((variants_methods).get<1>()));
(((parsed_enum).record_type) = typename parser::RecordType::ValueEnum((underlying_type.value()),((variants_methods).get<0>())));
}
else {
const Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>> variants_methods = TRY((((*this).parse_sum_enum_body(parsed_enum,definition_linkage,is_boxed))));
(((parsed_enum).methods) = ((variants_methods).get<1>()));
(((parsed_enum).record_type) = typename parser::RecordType::SumEnum(is_boxed,((variants_methods).get<0>())));
}

return (parsed_enum);
}
}

utility::Span parser::Parser::span(const size_t start,const size_t end) const {
{
return (utility::Span((((((*this).compiler))->current_file).value()),start,end));
}
}

ErrorOr<Array<parser::ParsedVarDecl>> parser::Parser::parse_destructuring_assignment(const bool is_mutable) {
{
((((*this).index)++));
Array<parser::ParsedVarDecl> var_declarations = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
for (;;){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedVarDecl>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
TRY((((var_declarations).push(TRY((((*this).parse_variable_declaration(is_mutable))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return (var_declarations);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected close of destructuring assignment block"),((((*this).current())).span())))));
return ((TRY((Array<parser::ParsedVarDecl>::create_with({})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return ((TRY((Array<parser::ParsedVarDecl>::create_with({parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),((((*this).current())).span()))})))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand_base() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_32; {
__jakt_var_32 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("this"),span))); goto __jakt_label_30;

}
__jakt_label_30:; __jakt_var_32.release_value(); }));
};/*case end*/
case 96: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Try>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_33; {
((((*this).index)++));
__jakt_var_33 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_try_block()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_34; {
const NonnullRefPtr<parser::ParsedExpression> expression = TRY((((*this).parse_expression(true,true))));
Optional<parser::ParsedBlock> catch_block = JaktInternal::OptionalNone();
Optional<String> catch_name = JaktInternal::OptionalNone();
if (((((*this).current())).index() == 63 /* Catch */)){
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(catch_name = name);
((((*this).index)++));
}
(catch_block = TRY((((*this).parse_block()))));
}
__jakt_var_34 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Try>(expression,catch_block,catch_name,span))); goto __jakt_label_32;

}
__jakt_label_32:; __jakt_var_34.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_31;

}
__jakt_label_31:; __jakt_var_33.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_35; {
((((*this).index)++));
__jakt_var_35 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::QuotedString>(quote,span))); goto __jakt_label_33;

}
__jakt_label_33:; __jakt_var_35.release_value(); }));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_36; {
((((*this).index)++));
__jakt_var_36 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::SingleQuotedString>(quote,span))); goto __jakt_label_34;

}
__jakt_label_34:; __jakt_var_36.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();String const& quote = __jakt_match_value.quote;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_37; {
((((*this).index)++));
__jakt_var_37 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::SingleQuotedByteString>(quote,span))); goto __jakt_label_35;

}
__jakt_label_35:; __jakt_var_37.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_38; {
((((*this).index)++));
__jakt_var_38 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NumericConstant>(number,span))); goto __jakt_label_36;

}
__jakt_label_36:; __jakt_var_38.release_value(); }));
};/*case end*/
case 95: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_39; {
((((*this).index)++));
__jakt_var_39 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Boolean>(true,span))); goto __jakt_label_37;

}
__jakt_label_37:; __jakt_var_39.release_value(); }));
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_40; {
((((*this).index)++));
__jakt_var_40 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Boolean>(false,span))); goto __jakt_label_38;

}
__jakt_label_38:; __jakt_var_40.release_value(); }));
};/*case end*/
case 92: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_41; {
((((*this).index)++));
__jakt_var_41 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("this"),span))); goto __jakt_label_39;

}
__jakt_label_39:; __jakt_var_41.release_value(); }));
};/*case end*/
case 84: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Not>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_42; {
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = TRY((parser::merge_spans(start,((expr)->span()))));
__jakt_var_42 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::LogicalNot(),span))); goto __jakt_label_40;

}
__jakt_label_40:; __jakt_var_42.release_value(); }));
};/*case end*/
case 45: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Tilde>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_43; {
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = TRY((parser::merge_spans(start,((expr)->span()))));
__jakt_var_43 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::BitwiseNot(),span))); goto __jakt_label_41;

}
__jakt_label_41:; __jakt_var_43.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_44; {
if (((((*this).peek(static_cast<size_t>(1ULL)))).index() == 8 /* LParen */)){
if ((name == String("Some"))){
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalSome>(expr,span))));
}
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),span))));
}
if (((((*this).peek(static_cast<size_t>(1ULL)))).index() == 29 /* LessThan */)){
(((((*this).compiler))->ignore_parser_errors) = true);
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
(((((*this).compiler))->ignore_parser_errors) = false);
if ((!(((call).has_value())))){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>,ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == String("None")) {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalNone>(span))));
}
else {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(name,span))));
}
}()))
);
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),span))));
}
((((*this).index)++));
if ((name == String("None"))){
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::OptionalNone>(span))));
}
__jakt_var_44 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(name,span))); goto __jakt_label_42;

}
__jakt_label_42:; __jakt_var_44.release_value(); }));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_45; {
const utility::Span start_span = ((((*this).current())).span());
((((*this).index)++));
NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
((*this).skip_newlines());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
Array<NonnullRefPtr<parser::ParsedExpression>> tuple_exprs = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({expr}))));
utility::Span end_span = start_span;
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
(end_span = ((expr)->span()));
TRY((((tuple_exprs).push(expr))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (((*this).eof())){
TRY((((*this).error(String("Expected ')'"),((((*this).current())).span())))));
}
(expr = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktTuple>(tuple_exprs,TRY((parser::merge_spans(start_span,end_span)))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected ')'"),((((*this).current())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_45 = expr; goto __jakt_label_43;

}
__jakt_label_43:; __jakt_var_45.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_46; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = TRY((parser::merge_spans(start,((expr)->span()))));
__jakt_var_46 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_44;

}
__jakt_label_44:; __jakt_var_46.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_47; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = TRY((parser::merge_spans(start,((expr)->span()))));
__jakt_var_47 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_45;

}
__jakt_label_45:; __jakt_var_47.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_48; {
const parser::UnaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::UnaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreIncrement());
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::PreDecrement());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::UnaryOperator::Negate());
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("unreachable")))));
}
};/*case end*/
}/*switch end*/
}()
));
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
const utility::Span span = TRY((parser::merge_spans(start,((expr)->span()))));
__jakt_var_48 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,op,span))); goto __jakt_label_46;

}
__jakt_label_46:; __jakt_var_48.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_49; {
__jakt_var_49 = TRY((((*this).parse_array_or_dictionary_literal()))); goto __jakt_label_47;

}
__jakt_label_47:; __jakt_var_49.release_value(); }));
};/*case end*/
case 81: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Match>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_50; {
__jakt_var_50 = TRY((((*this).parse_match_expression()))); goto __jakt_label_48;

}
__jakt_label_48:; __jakt_var_50.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_51; {
__jakt_var_51 = TRY((((*this).parse_set_literal()))); goto __jakt_label_49;

}
__jakt_label_49:; __jakt_var_51.release_value(); }));
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_ampersand()))));
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_asterisk()))));
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_lambda()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_52; {
const utility::Span span = ((((*this).current())).span());
((((*this).index)++));
TRY((((*this).error(String("Unsupported expression"),span))));
__jakt_var_52 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(span))); goto __jakt_label_50;

}
__jakt_label_50:; __jakt_var_52.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<parser::ParsedFunction> parser::Parser::parse_function(const parser::FunctionLinkage linkage,const parser::Visibility visibility,const bool is_comptime) {
{
parser::ParsedFunction parsed_function = parser::ParsedFunction(String(""),((*this).empty_span()),visibility,(TRY((Array<parser::ParsedParameter>::create_with({})))),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({}))))),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))),false,typename parser::FunctionType::Normal(),linkage,false,is_comptime);
((((*this).index)++));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete function definition"),((((*this).current())).span())))));
return (parsed_function);
}
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(((parsed_function).name) = name);
(((parsed_function).name_span) = ((((*this).current())).span()));
((((*this).index)++));
(((parsed_function).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete function"),((((*this).current())).span())))));
}
(((parsed_function).params) = TRY((((*this).parse_function_parameters()))));
bool can_throw = (name == String("main"));
if (((((*this).current())).index() == 94 /* Throws */)){
(can_throw = true);
((((*this).index)++));
}
(((parsed_function).can_throw) = can_throw);
if (((((*this).current())).index() == 57 /* Arrow */)){
((((*this).index)++));
const utility::Span start = ((((*this).current())).span());
(((parsed_function).return_type) = TRY((((*this).parse_typename()))));
(((parsed_function).return_type_span) = TRY((parser::merge_spans(start,((((*this).previous())).span())))));
}
if (((linkage).index() == 1 /* External */)){
return (parsed_function);
}
if (((((*this).current())).index() == 56 /* FatArrow */)){
(((parsed_function).block) = TRY((((*this).parse_fat_arrow()))));
}
else {
(((parsed_function).block) = TRY((((*this).parse_block()))));
}

return (parsed_function);
}
else {
return (parsed_function);
}

}
}

ErrorOr<parser::ParsedNamespace> parser::Parser::parse(const NonnullRefPtr<compiler::Compiler> compiler,const Array<lexer::Token> tokens) {
{
parser::Parser parser = parser::Parser(static_cast<size_t>(0ULL),tokens,compiler);
return (TRY((((parser).parse_namespace()))));
}
}

ErrorOr<parser::ParsedModuleImport> parser::Parser::parse_module_import() {
{
parser::ParsedModuleImport parsed_import = parser::ParsedModuleImport(parser::ImportName(String(""),((*this).empty_span())),JaktInternal::OptionalNone(),(TRY((Array<parser::ImportName>::create_with({})))));
(((parsed_import).module_name) = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ImportName, ErrorOr<parser::ParsedModuleImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(parser::ImportName(name,span));
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected module name"),((((*this).current())).span())))));
return (parsed_import);
}
};/*case end*/
}/*switch end*/
}()
)));
((((*this).index)++));
if (((*this).eol())){
return (parsed_import);
}
if (((((*this).current())).index() == 60 /* As */)){
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
((((*this).index)++));
(((parsed_import).alias_name) = parser::ImportName(name,span));
}
else {
TRY((((*this).error(String("Expected name"),((((*this).current())).span())))));
((((*this).index)++));
}

}
if (((*this).eol())){
return (parsed_import);
}
if ((!(((((*this).current())).index() == 10 /* LCurly */)))){
TRY((((*this).error(String("Expected '{'"),((((*this).current())).span())))));
}
((((*this).index)++));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedModuleImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((((parsed_import).import_list)).push(parser::ImportName(name,span)))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected import symbol"),((((*this).current())).span())))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (parsed_import);
}
}

ErrorOr<parser::ParsedBlock> parser::Parser::parse_block() {
{
const utility::Span start = ((((*this).current())).span());
parser::ParsedBlock block = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({})))));
if (((*this).eof())){
TRY((((*this).error(String("Incomplete block"),start))));
return (block);
}
((*this).skip_newlines());
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected '{'"),start))));
}

while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedBlock>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
((((*this).index)++));
return (block);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((block).stmts)).push(TRY((((*this).parse_statement(true))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((*this).error(String("Expected complete block"),((((*this).current())).span())))));
return (block);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_longhand() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 88: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Raw>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_53; {
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
const utility::Span span = TRY((parser::merge_spans(start,((((*this).current())).span()))));
__jakt_var_53 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Optional>(TRY((parser::ParsedType::template create<typename parser::ParsedType::RawPtr>(inner,span))),span))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::RawPtr>(inner,span))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_51;

}
__jakt_label_51:; __jakt_var_53.release_value(); }));
};/*case end*/
case 98: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Weak>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_54; {
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
const utility::Span span = TRY((parser::merge_spans(start,((((*this).current())).span()))));
__jakt_var_54 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::WeakPtr>(inner,span))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_55; {
TRY((((*this).error(String("missing `?` after weak pointer type name"),span))));
__jakt_var_55 = TRY((parser::ParsedType::template create<typename parser::ParsedType::WeakPtr>(inner,span))); goto __jakt_label_53;

}
__jakt_label_53:; __jakt_var_55.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_52;

}
__jakt_label_52:; __jakt_var_54.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_56; {
const utility::Span span = ((((*this).current())).span());
((((*this).index)++));
NonnullRefPtr<parser::ParsedType> parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(name,span)));
if (((((*this).current())).index() == 29 /* LessThan */)){
Array<NonnullRefPtr<parser::ParsedType>> params = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
if (((((*this).current())).index() == 29 /* LessThan */)){
((((*this).index)++));
while (((!(((((*this).current())).index() == 27 /* GreaterThan */))) && (!(((*this).eof()))))){
TRY((((params).push(TRY((((*this).parse_typename())))))));
if (((((*this).current())).index() == 51 /* Comma */)){
((((*this).index)++));
}
}
if (((((*this).current())).index() == 27 /* GreaterThan */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `>` after type parameters"),((((*this).current())).span())))));
}

}
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::GenericType>(name,params,span))));
}
if (((((*this).current())).index() == 7 /* ColonColon */)){
((((*this).index)++));
Array<String> namespaces = (TRY((Array<String>::create_with({name}))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& namespace_name = __jakt_match_value.name;
{
if (((((*this).previous())).index() == 7 /* ColonColon */)){
TRY((((namespaces).push(namespace_name))));
((((*this).index)++));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
{
if (((((*this).previous())).index() == 4 /* Identifier */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected name after"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const String type_name = (((namespaces).pop()).value());
Array<NonnullRefPtr<parser::ParsedType>> params = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
if (((((*this).current())).index() == 29 /* LessThan */)){
((((*this).index)++));
while (((!(((((*this).current())).index() == 27 /* GreaterThan */))) && (!(((*this).eof()))))){
TRY((((params).push(TRY((((*this).parse_typename())))))));
if (((((*this).current())).index() == 51 /* Comma */)){
((((*this).index)++));
}
}
if (((((*this).current())).index() == 27 /* GreaterThan */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `>` after type parameters"),((((*this).current())).span())))));
}

}
(parsed_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::NamespacedName>(type_name,namespaces,params,((((*this).previous())).span())))));
}
__jakt_var_56 = parsed_type; goto __jakt_label_54;

}
__jakt_label_54:; __jakt_var_56.release_value(); }));
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_57; {
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const Array<parser::ParsedParameter> params = TRY((((*this).parse_function_parameters())));
const bool can_throw = ((((*this).current())).index() == 94 /* Throws */);
if (can_throw){
((((*this).index)++));
}
NonnullRefPtr<parser::ParsedType> return_type = TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>()));
if (((((*this).current())).index() == 57 /* Arrow */)){
((((*this).index)++));
(return_type = TRY((((*this).parse_typename()))));
}
else {
TRY((((*this).error(String("Expected '->'"),((((*this).current())).span())))));
}

__jakt_var_57 = TRY((parser::ParsedType::template create<typename parser::ParsedType::Function>(params,can_throw,return_type,TRY((parser::merge_spans(start,((return_type)->span()))))))); goto __jakt_label_55;

}
__jakt_label_55:; __jakt_var_57.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_58; {
TRY((((*this).error(String("Expected type name"),((((*this).current())).span())))));
__jakt_var_58 = TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())); goto __jakt_label_56;

}
__jakt_label_56:; __jakt_var_58.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedType>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_array_or_dictionary()))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_set()))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_type_shorthand_tuple()))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<void> parser::Parser::error(const String message,const utility::Span span) {
{
if ((!(((((*this).compiler))->ignore_parser_errors)))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
}
return {};
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operator(const bool allow_assignments) {
{
const utility::Span span = ((((*this).current())).span());
const parser::BinaryOperator op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::BinaryOperator, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 49: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMark>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NoneCoalescing());
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Plus>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Add());
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Minus>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Subtract());
};/*case end*/
case 37: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Asterisk>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Multiply());
};/*case end*/
case 46: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlash>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Divide());
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSign>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Modulo());
};/*case end*/
case 58: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::And>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LogicalAnd());
};/*case end*/
case 85: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Or>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LogicalOr());
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DoubleEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Equal());
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::NotEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NotEqual());
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThan>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LessThan());
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LessThanOrEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::LessThanOrEqual());
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::GreaterThan());
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::GreaterThanOrEqual());
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseAnd());
};/*case end*/
case 40: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Pipe>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseOr());
};/*case end*/
case 42: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Caret>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseXor());
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseLeftShift());
};/*case end*/
case 34: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseRightShift());
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftArithmeticShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ArithmeticLeftShift());
};/*case end*/
case 35: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightArithmeticShift>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ArithmeticRightShift());
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Equal>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::Assign());
};/*case end*/
case 33: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LeftShiftEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseLeftShiftAssign());
};/*case end*/
case 36: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RightShiftEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseRightShiftAssign());
};/*case end*/
case 39: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AmpersandEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseAndAssign());
};/*case end*/
case 41: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PipeEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseOrAssign());
};/*case end*/
case 43: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::CaretEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::BitwiseXorAssign());
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::AddAssign());
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::SubtractAssign());
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::AsteriskEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::MultiplyAssign());
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ForwardSlashEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::DivideAssign());
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PercentSignEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::ModuloAssign());
};/*case end*/
case 50: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMarkQuestionMarkEqual>();
return JaktInternal::ExplicitValue(typename parser::BinaryOperator::NoneCoalescingAssign());
};/*case end*/
default: {
{
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(span))));
}
};/*case end*/
}/*switch end*/
}()
));
((((*this).index)++));
if (((!(allow_assignments)) && ((op).is_assignment()))){
TRY((((*this).error(String("Assignment is not allowed in this position"),span))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Operator>(op,span))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Operator>(op,span))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_for_statement() {
{
const utility::Span start_span = ((((*this).current())).span());
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const String iterator_name = name;
const utility::Span name_span = ((((*this).current())).span());
((((*this).index)++));
if (((((*this).current())).index() == 77 /* In */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected in"),((((*this).current())).span())))));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(TRY((parser::merge_spans(start_span,((((*this).current())).span()))))))));
}

const NonnullRefPtr<parser::ParsedExpression> range = TRY((((*this).parse_expression(false,false))));
const parser::ParsedBlock block = TRY((((*this).parse_block())));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::For>(iterator_name,name_span,range,block,TRY((parser::merge_spans(start_span,((((*this).previous())).span()))))))));
}
else {
TRY((((*this).error(String("Expected iterator name"),((((*this).current())).span())))));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(TRY((parser::merge_spans(start_span,((((*this).current())).span()))))))));
}

}
}

ErrorOr<Array<parser::ParsedParameter>> parser::Parser::parse_function_parameters() {
{
if (((((*this).current())).index() == 8 /* LParen */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected '('"),((((*this).current())).span())))));
}

((*this).skip_newlines());
Array<parser::ParsedParameter> params = (TRY((Array<parser::ParsedParameter>::create_with({}))));
bool current_param_requires_label = true;
bool current_param_is_mutable = false;
bool error = false;
bool parameter_complete = false;
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedParameter>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
if (((!(parameter_complete)) && (!(error)))){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
((((*this).index)++));
(current_param_requires_label = true);
(current_param_is_mutable = false);
(parameter_complete = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
if (((!(parameter_complete)) && (!(error)))){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
((((*this).index)++));
(current_param_requires_label = true);
(current_param_is_mutable = false);
(parameter_complete = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 59: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Anon>();
{
if ((parameter_complete && (!(error)))){
TRY((((*this).error(String("anon must appear at start of parameter declaration, not the end"),((((*this).current())).span())))));
(error = true);
}
if ((current_param_is_mutable && (!(error)))){
TRY((((*this).error(String("anon must appear before mut"),((((*this).current())).span())))));
(error = true);
}
if (((!(current_param_requires_label)) && (!(error)))){
TRY((((*this).error(String("anon cannot appear multiple times in one parameter declaration"),((((*this).current())).span())))));
(error = true);
}
((((*this).index)++));
(current_param_requires_label = false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
{
if ((parameter_complete && (!(error)))){
TRY((((*this).error(String("mut must appear at start of parameter declaration, not the end"),((((*this).current())).span())))));
(error = true);
}
if ((current_param_is_mutable && (!(error)))){
TRY((((*this).error(String("mut cannot appear multiple times in one parameter declaration"),((((*this).current())).span())))));
(error = true);
}
((((*this).index)++));
(current_param_is_mutable = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 92: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::This>();
{
TRY((((params).push(parser::ParsedParameter(false,parser::ParsedVariable(String("this"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),current_param_is_mutable,((((*this).current())).span())),JaktInternal::OptionalNone(),((((*this).current())).span()))))));
((((*this).index)++));
(parameter_complete = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const parser::ParsedVarDecl var_decl = TRY((((*this).parse_variable_declaration(current_param_is_mutable))));
Optional<NonnullRefPtr<parser::ParsedExpression>> default_argument = JaktInternal::OptionalNone();
if (((((*this).current())).index() == 17 /* Equal */)){
((((*this).index)++));
(default_argument = TRY((((*this).parse_expression(false,true)))));
}
TRY((((params).push(parser::ParsedParameter(current_param_requires_label,parser::ParsedVariable(((var_decl).name),((var_decl).parsed_type),((var_decl).is_mutable),((((*this).previous())).span())),default_argument,((((*this).previous())).span()))))));
(parameter_complete = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(error))){
TRY((((*this).error(String("Expected parameter"),((((*this).current())).span())))));
(error = true);
}
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (params);
}
}

ErrorOr<Optional<parser::ParsedCall>> parser::Parser::parse_call() {
{
parser::ParsedCall call = parser::ParsedCall((TRY((Array<String>::create_with({})))),String(""),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({})))));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(((call).name) = name);
((((*this).index)++));
const size_t index_reset = ((*this).index);
if (((((*this).current())).index() == 29 /* LessThan */)){
((((*this).index)++));
Array<NonnullRefPtr<parser::ParsedType>> inner_types = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<parser::ParsedCall>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::GreaterThan>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const size_t index_before = ((*this).index);
const NonnullRefPtr<parser::ParsedType> inner_type = TRY((((*this).parse_typename())));
if ((index_before == ((*this).index))){
(((*this).index) = index_reset);
return JaktInternal::LoopBreak{};
}
TRY((((inner_types).push(inner_type))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
(((call).type_args) = inner_types);
}
if (((((*this).current())).index() == 8 /* LParen */)){
((((*this).index)++));
}
else {
(((*this).index) = index_reset);
TRY((((*this).error(String("Expected '('"),((((*this).current())).span())))));
return (JaktInternal::OptionalNone());
}

while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<parser::ParsedCall>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const utility::Span label_span = ((((*this).current())).span());
const String label = TRY((((*this).parse_argument_label())));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
TRY((((((call).args)).push((Tuple{label, label_span, expr})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (call);
}
else {
TRY((((*this).error(String("Expected function call"),((((*this).current())).span())))));
return (call);
}

}
}

ErrorOr<Array<parser::ParsedMatchCase>> parser::Parser::parse_match_cases() {
{
Array<parser::ParsedMatchCase> cases = (TRY((Array<parser::ParsedMatchCase>::create_with({}))));
((*this).skip_newlines());
if ((!(((((*this).current())).index() == 10 /* LCurly */)))){
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
return (cases);
}
((((*this).index)++));
((*this).skip_newlines());
while (((!(((*this).eof()))) && (!(((((*this).current())).index() == 11 /* RCurly */))))){
const size_t pattern_start_index = ((*this).index);
const Array<parser::ParsedMatchPattern> patterns = TRY((((*this).parse_match_patterns())));
((*this).skip_newlines());
const utility::Span marker_span = ((((*this).current())).span());
if (((((*this).current())).index() == 56 /* FatArrow */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected =>"),((((*this).current())).span())))));
}

((*this).skip_newlines());
const parser::ParsedMatchBody body = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedMatchBody, ErrorOr<Array<parser::ParsedMatchCase>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchBody::Block(TRY((((*this).parse_block())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename parser::ParsedMatchBody::Expression(TRY((((*this).parse_expression(false,false))))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((patterns).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
TRY((((cases).push(parser::ParsedMatchCase((TRY((Array<parser::ParsedMatchPattern>::create_with({pattern})))),marker_span,body)))));
}

}
}

if ((((*this).index) == pattern_start_index)){
break;
}
if ((((((*this).current())).index() == 54 /* Eol */) || ((((*this).current())).index() == 51 /* Comma */))){
((((*this).index)++));
}
((*this).skip_newlines());
}
((*this).skip_newlines());
if ((!(((((*this).current())).index() == 11 /* RCurly */)))){
TRY((((*this).error(String("Expected }"),((((*this).current())).span())))));
}
((((*this).index)++));
return (cases);
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_struct(const parser::DefinitionLinkage definition_linkage) {
{
parser::ParsedRecord parsed_struct = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage());
if (((((*this).current())).index() == 91 /* Struct */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `struct` keyword"),((((*this).current())).span())))));
return (parsed_struct);
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected name"),((((*this).current())).span())))));
return (parsed_struct);
}
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
((((*this).index)++));
(((parsed_struct).name) = name);
(((parsed_struct).name_span) = span);
}
else {
TRY((((*this).error(String("Incomplete struct definition, expected name"),((((*this).current())).span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected generic parameters or body"),((((*this).current())).span())))));
return (parsed_struct);
}
(((parsed_struct).generic_parameters) = TRY((((*this).parse_generic_parameters()))));
((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete struct definition, expected body"),((((*this).current())).span())))));
return (parsed_struct);
}
const Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>> fields_methods = TRY((((*this).parse_struct_class_body(definition_linkage,typename parser::Visibility::Public(),false))));
(((parsed_struct).methods) = ((fields_methods).get<1>()));
(((parsed_struct).record_type) = typename parser::RecordType::Struct(((fields_methods).get<0>())));
return (parsed_struct);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_array_or_dictionary_literal() {
{
bool is_dictionary = false;
const utility::Span start = ((((*this).current())).span());
if ((!(((((*this).current())).index() == 12 /* LSquare */)))){
TRY((((*this).error(String("Expected ["),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
((((*this).index)++));
Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size_expr = JaktInternal::OptionalNone();
Array<NonnullRefPtr<parser::ParsedExpression>> output = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> dict_output = (TRY((Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>>::create_with({}))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
if ((((output).size()) == static_cast<size_t>(1ULL))){
((((*this).index)++));
(fill_size_expr = TRY((((*this).parse_expression(false,false)))));
}
else {
TRY((((*this).error(String("Can't fill an Array with more than one expression"),((((*this).current())).span())))));
((((*this).index)++));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Colon>();
{
((((*this).index)++));
if (((dict_output).is_empty())){
if (((((*this).current())).index() == 13 /* RSquare */)){
((((*this).index)++));
(is_dictionary = true);
return JaktInternal::LoopBreak{};
}
else {
TRY((((*this).error(String("Expected ]"),((((*this).current())).span())))));
}

}
else {
TRY((((*this).error(String("Missing key in dictionary literal"),((((*this).current())).span())))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if (((expr)->index() == 29 /* Garbage */)){
return JaktInternal::LoopBreak{};
}
if (((((*this).current())).index() == 6 /* Colon */)){
if ((!(((output).is_empty())))){
TRY((((*this).error(String("Mixing dictionary and array values"),((((*this).current())).span())))));
}
(is_dictionary = true);
((((*this).index)++));
if (((*this).eof())){
TRY((((*this).error(String("Key missing value in dictionary"),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
const NonnullRefPtr<parser::ParsedExpression> value = TRY((((*this).parse_expression(false,false))));
TRY((((dict_output).push((Tuple{expr, value})))));
}
else if ((!(is_dictionary))){
TRY((((output).push(expr))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const size_t end = (JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)));
if (((end >= ((((*this).tokens)).size())) || (!(((((((*this).tokens))[end])).index() == 13 /* RSquare */))))){
TRY((((*this).error(String("Expected ] to close the array"),((((((*this).tokens))[end])).span())))));
}
if (is_dictionary){
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktDictionary>(dict_output,TRY((parser::merge_spans(start,((((((*this).tokens))[end])).span()))))))));
}
else {
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::JaktArray>(output,fill_size_expr,TRY((parser::merge_spans(start,((((((*this).tokens))[end])).span()))))))));
}

}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand() {
{
((*this).skip_newlines());
const utility::Span start = ((((*this).current())).span());
((*this).skip_newlines());
NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand_base())));
return (TRY((((*this).parse_operand_postfix_operator(start,expr)))));
}
}

void parser::Parser::skip_newlines() {
{
while (((((*this).current())).index() == 54 /* Eol */)){
((((*this).index)++));
}
}
}

bool parser::Parser::eol() const {
{
return ((((*this).eof()) || ((((((*this).tokens))[((*this).index)])).index() == 54 /* Eol */)));
}
}

ErrorOr<parser::ParsedMatchPattern> parser::Parser::parse_match_pattern() {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedMatchPattern, ErrorOr<parser::ParsedMatchPattern>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 95: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::True>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 71: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::False>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::SingleQuotedByteString>();return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(typename parser::ParsedMatchPattern::Expression(TRY((((*this).parse_operand())))));
};/*case end*/
case 68: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Else>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_59; {
((((*this).index)++));
__jakt_var_59 = typename parser::ParsedMatchPattern::CatchAll(); goto __jakt_label_57;

}
__jakt_label_57:; __jakt_var_59.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_60; {
const size_t pattern_start_index = ((*this).index);
Array<Tuple<String,utility::Span>> variant_name = (TRY((Array<Tuple<String,utility::Span>>::create_with({}))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedMatchPattern>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
((((*this).index)++));
TRY((((variant_name).push((Tuple{name, ((((*this).current())).span())})))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
Array<parser::EnumVariantPatternArgument> variant_arguments = TRY((((*this).parse_variant_arguments())));
const utility::Span arguments_start = ((((*this).current())).span());
const utility::Span arguments_end = ((((*this).previous())).span());
const utility::Span arguments_span = TRY((parser::merge_spans(arguments_start,arguments_end)));
__jakt_var_60 = typename parser::ParsedMatchPattern::EnumVariant(variant_name,variant_arguments,arguments_span); goto __jakt_label_58;

}
__jakt_label_58:; __jakt_var_60.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedMatchPattern> __jakt_var_61; {
TRY((((*this).error(String("Expected pattern or else"),((((*this).current())).span())))));
__jakt_var_61 = typename parser::ParsedMatchPattern::CatchAll(); goto __jakt_label_59;

}
__jakt_label_59:; __jakt_var_61.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_lambda() {
{
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const Array<parser::ParsedCapture> captures = TRY((((*this).parse_captures())));
const Array<parser::ParsedParameter> params = TRY((((*this).parse_function_parameters())));
const bool can_throw = ((((*this).current())).index() == 94 /* Throws */);
if (can_throw){
((((*this).index)++));
}
NonnullRefPtr<parser::ParsedType> return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 57: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Arrow>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedType>> __jakt_var_62; {
((((*this).index)++));
__jakt_var_62 = TRY((((*this).parse_typename()))); goto __jakt_label_60;

}
__jakt_label_60:; __jakt_var_62.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
};/*case end*/
}/*switch end*/
}()
));
const parser::ParsedBlock block = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedBlock, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 56: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::FatArrow>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedBlock> __jakt_var_63; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(true,false))));
const utility::Span span = ((expr)->span());
__jakt_var_63 = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Return>(expr,span)))}))))); goto __jakt_label_61;

}
__jakt_label_61:; __jakt_var_63.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).parse_block()))));
};/*case end*/
}/*switch end*/
}()
));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Function>(captures,params,can_throw,return_type,block,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
}
}

ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>> parser::Parser::parse_struct_class_body(const parser::DefinitionLinkage definition_linkage,const parser::Visibility default_visibility,const bool is_class) {
{
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
}

Array<parser::ParsedField> fields = (TRY((Array<parser::ParsedField>::create_with({}))));
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
bool error = false;
while ((!(((*this).eof())))){
const lexer::Token token = ((*this).current());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = token;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
if (((last_visibility).has_value())){
TRY((((*this).error(String("Expected function or parameter after visibility modifier"),((token).span())))));
}
((((*this).index)++));
return ((Tuple{fields, methods}));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 90: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Restricted>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = TRY((((*this).parse_restricted_visibility_modifier()))));
(last_visibility_span = span);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return default_visibility; });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedField field = TRY((((*this).parse_field(visibility))));
TRY((((fields).push(field))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return default_visibility; });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,((((*this).current())).index() == 74 /* Comptime */)))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comptime>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::ParsedField>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return default_visibility; });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,((((*this).current())).index() == 74 /* Comptime */)))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(error))){
TRY((((*this).error(TRY((String::formatted(String("Invalid member, did not expect a {} here"),token))),((token).span())))));
(error = true);
}
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if (is_class){
TRY((((*this).error(String("Incomplete class body, expected }"),((((*this).current())).span())))));
}
else {
TRY((((*this).error(String("Incomplete struct body, expected }"),((((*this).current())).span())))));
}

return ((Tuple{fields, methods}));
}
}

ErrorOr<parser::ParsedExternImport> parser::Parser::parse_extern_import(parser::ParsedNamespace& parent) {
{
parser::ParsedExternImport parsed_import = parser::ParsedExternImport(false,parser::ParsedNamespace(JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),(TRY((Array<parser::ParsedFunction>::create_with({})))),(TRY((Array<parser::ParsedRecord>::create_with({})))),(TRY((Array<parser::ParsedNamespace>::create_with({})))),(TRY((Array<parser::ParsedModuleImport>::create_with({})))),(TRY((Array<parser::ParsedExternImport>::create_with({})))),JaktInternal::OptionalNone()));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
((((*this).index)++));
if (((name == String("c")) || (name == String("C")))){
(((parsed_import).is_c) = true);
}
else {
TRY((((*this).error(String("Expected 'c' or path after `import extern`"),((((*this).current())).span())))));
}

}
const String import_path = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<parser::ParsedExternImport>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::QuotedString>();String const& quote = __jakt_match_value.quote;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_64; {
((((*this).index)++));
__jakt_var_64 = quote; goto __jakt_label_62;

}
__jakt_label_62:; __jakt_var_64.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_65; {
TRY((((*this).error(String("Expected path after `import extern`"),((((*this).current())).span())))));
__jakt_var_65 = String(""); goto __jakt_label_63;

}
__jakt_label_63:; __jakt_var_65.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
if (((((*this).current())).index() == 60 /* As */)){
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
((((*this).index)++));
(((((parsed_import).assigned_namespace)).name) = name);
(((((parsed_import).assigned_namespace)).name_span) = span);
}
else {
TRY((((*this).error(String("Expected name after 'as' keyword to name the extern import"),((((*this).current())).span())))));
}

}
if ((!(((((*this).current())).index() == 10 /* LCurly */)))){
TRY((((*this).error(String("Expected '{' to start namespace for the extern import"),((((*this).current())).span())))));
}
((((*this).index)++));
(((parsed_import).assigned_namespace) = TRY((((*this).parse_namespace()))));
(((((parsed_import).assigned_namespace)).import_path_if_extern) = (import_path));
if (((((*this).current())).index() == 11 /* RCurly */)){
((((*this).index)++));
}
TRY((((((parent))).add_child_namespace(((parsed_import).assigned_namespace)))));
return (parsed_import);
}
}

ErrorOr<Array<parser::EnumVariantPatternArgument>> parser::Parser::parse_variant_arguments() {
{
Array<parser::EnumVariantPatternArgument> variant_arguments = (TRY((Array<parser::EnumVariantPatternArgument>::create_with({}))));
bool has_parens = false;
if (((((*this).current())).index() == 8 /* LParen */)){
(has_parens = true);
((((*this).index)++));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::EnumVariantPatternArgument>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& arg_name = __jakt_match_value.name;
{
if (((((*this).peek(static_cast<size_t>(1ULL)))).index() == 6 /* Colon */)){
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
if (((((*this).current())).index() == 4 /* Identifier */)){
const String arg_binding = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = ((((*this).current())).span());
((((*this).index)++));
TRY((((variant_arguments).push(parser::EnumVariantPatternArgument((arg_name),arg_binding,span)))));
}
else {
TRY((((*this).error(String("Expected binding after :"),((((*this).current())).span())))));
}

}
else {
TRY((((variant_arguments).push(parser::EnumVariantPatternArgument(JaktInternal::OptionalNone(),arg_name,((((*this).current())).span()))))));
((((*this).index)++));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected pattern argument name"),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
}
return (variant_arguments);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_set_literal() {
{
const utility::Span start = ((((*this).current())).span());
if ((!(((((*this).current())).index() == 10 /* LCurly */)))){
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
((((*this).index)++));
Array<NonnullRefPtr<parser::ParsedExpression>> output = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,false))));
if (((expr)->index() == 29 /* Garbage */)){
return JaktInternal::LoopBreak{};
}
TRY((((output).push(expr))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
const size_t end = (JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)));
if (((end >= ((((*this).tokens)).size())) || (!(((((((*this).tokens))[end])).index() == 11 /* RCurly */))))){
TRY((((*this).error(String("Expected } to close the set"),((((((*this).tokens))[end])).span())))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Set>(output,TRY((parser::merge_spans(start,((((((*this).tokens))[end])).span()))))))));
}
}

ErrorOr<parser::ParsedNamespace> parser::Parser::parse_namespace() {
{
parser::ParsedNamespace parsed_namespace = parser::ParsedNamespace(JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),(TRY((Array<parser::ParsedFunction>::create_with({})))),(TRY((Array<parser::ParsedRecord>::create_with({})))),(TRY((Array<parser::ParsedNamespace>::create_with({})))),(TRY((Array<parser::ParsedModuleImport>::create_with({})))),(TRY((Array<parser::ParsedExternImport>::create_with({})))),JaktInternal::OptionalNone());
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 76: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Import>();
{
((((*this).index)++));
TRY((((*this).parse_import(((parsed_namespace))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::ParsedFunction parsed_function = TRY((((*this).parse_function(typename parser::FunctionLinkage::Internal(),typename parser::Visibility::Public(),((((*this).current())).index() == 74 /* Comptime */)))));
TRY((((((parsed_namespace).functions)).push(parsed_function))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comptime>();
{
const parser::ParsedFunction parsed_function = TRY((((*this).parse_function(typename parser::FunctionLinkage::Internal(),typename parser::Visibility::Public(),((((*this).current())).index() == 74 /* Comptime */)))));
TRY((((((parsed_namespace).functions)).push(parsed_function))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
{
const parser::ParsedRecord parsed_record = TRY((((*this).parse_record(typename parser::DefinitionLinkage::Internal()))));
TRY((((((parsed_namespace).records)).push(parsed_record))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 83: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Namespace>();
{
((((*this).index)++));
const Optional<Tuple<String,utility::Span>> name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<Tuple<String,utility::Span>>, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<Tuple<String,utility::Span>>> __jakt_var_66; {
((((*this).index)++));
__jakt_var_66 = ((Tuple{name, span})); goto __jakt_label_64;

}
__jakt_label_64:; __jakt_var_66.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Optional<Tuple<String,utility::Span>>> __jakt_var_67; {
const Optional<Tuple<String,utility::Span>> tuple_none = JaktInternal::OptionalNone();
__jakt_var_67 = tuple_none; goto __jakt_label_65;

}
__jakt_label_65:; __jakt_var_67.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected {"),((((*this).current())).span())))));
}

parser::ParsedNamespace namespace_ = TRY((((*this).parse_namespace())));
if (((((*this).current())).index() == 11 /* RCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Incomplete namespace"),((((*this).previous())).span())))));
}

if (((name).has_value())){
(((namespace_).name) = (((name.value())).get<0>()));
(((namespace_).name_span) = (((name.value())).get<1>()));
}
TRY((((parsed_namespace).add_child_namespace(namespace_))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 70: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Extern>();
{
((((*this).index)++));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::ParsedNamespace>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const parser::ParsedFunction parsed_function = TRY((((*this).parse_function(typename parser::FunctionLinkage::External(),typename parser::Visibility::Public(),false))));
TRY((((((parsed_namespace).functions)).push(parsed_function))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
{
const parser::ParsedRecord parsed_struct = TRY((((*this).parse_struct(typename parser::DefinitionLinkage::External()))));
TRY((((((parsed_namespace).records)).push(parsed_struct))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
{
const parser::ParsedRecord parsed_class = TRY((((*this).parse_class(typename parser::DefinitionLinkage::External()))));
TRY((((((parsed_namespace).records)).push(parsed_class))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Unexpected keyword"),((((*this).current())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Unexpected token (expected keyword)"),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (parsed_namespace);
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_ampersand() {
{
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
if (((((*this).current())).index() == 88 /* Raw */)){
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::RawAddress(),TRY((parser::merge_spans(start,((expr)->span()))))))));
}
if (((((*this).current())).index() == 82 /* Mut */)){
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::MutableReference(),TRY((parser::merge_spans(start,((expr)->span()))))))));
}
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Reference(),TRY((parser::merge_spans(start,((expr)->span()))))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_asterisk() {
{
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_operand())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Dereference(),TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
}
}

ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>> parser::Parser::parse_sum_enum_body(const parser::ParsedRecord partial_enum,const parser::DefinitionLinkage definition_linkage,const bool is_boxed) {
{
Array<parser::ParsedMethod> methods = (TRY((Array<parser::ParsedMethod>::create_with({}))));
Array<parser::SumEnumVariant> variants = (TRY((Array<parser::SumEnumVariant>::create_with({}))));
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `{` to start the enum body"),((((*this).current())).span())))));
}

((*this).skip_newlines());
if (((*this).eof())){
TRY((((*this).error(String("Incomplete enum definition, expected variant name"),((((*this).previous())).span())))));
return ((Tuple{variants, methods}));
}
Optional<parser::Visibility> last_visibility = JaktInternal::OptionalNone();
Optional<utility::Span> last_visibility_span = JaktInternal::OptionalNone();
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((!(((((*this).peek(static_cast<size_t>(1ULL)))).index() == 8 /* LParen */)))){
((((*this).index)++));
TRY((((variants).push(parser::SumEnumVariant(name,span,JaktInternal::OptionalNone())))));
return JaktInternal::LoopContinue{};
}
({auto& _jakt_ref = ((*this).index);_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(2ULL));});
Array<parser::ParsedVarDecl> var_decls = (TRY((Array<parser::ParsedVarDecl>::create_with({}))));
while ((!(((*this).eof())))){
if (((((*this).peek(static_cast<size_t>(1ULL)))).index() == 6 /* Colon */)){
parser::ParsedVarDecl var_decl = TRY((((*this).parse_variable_declaration(false))));
if (((((var_decl).parsed_type))->index() == 0 /* Name */)){
const String name = (((var_decl).parsed_type)->get<parser::ParsedType::Name>()).name;
const utility::Span span = (((var_decl).parsed_type)->get<parser::ParsedType::Name>()).span;
(((var_decl).inlay_span) = span);
if (((name == ((partial_enum).name)) && (!(is_boxed)))){
TRY((((*this).error(String("use 'boxed enum' to make the enum recursive"),((var_decl).span)))));
}
}
TRY((((var_decls).push(var_decl))));
continue;
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
{
TRY((((var_decls).push(parser::ParsedVarDecl(String(""),TRY((((*this).parse_typename()))),false,JaktInternal::OptionalNone(),((((*this).current())).span()))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Incomplete enum variant defintion, expected `,` or `)`; got `{}`"),((*this).current())))),((((*this).current())).span())))));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((variants).push(parser::SumEnumVariant(name,span,var_decls)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 86: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Private>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Private());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 87: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Public>();
utility::Span const& span = __jakt_match_value.value;
{
if (((last_visibility).has_value())){
TRY((((*this).error_with_hint(String("Multiple visibility modifiers on one field or method are not allowed"),span,String("Previous modifier is here"),(last_visibility_span.value())))));
}
(last_visibility = typename parser::Visibility::Public());
(last_visibility_span = span);
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 73: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Function>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,is_comptime))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 74: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comptime>();
{
const bool is_comptime = ((((*this).current())).index() == 74 /* Comptime */);
const parser::FunctionLinkage function_linkage = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::FunctionLinkage, ErrorOr<Tuple<Array<parser::SumEnumVariant>,Array<parser::ParsedMethod>>>>{
auto&& __jakt_match_variant = definition_linkage;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::Internal());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(typename parser::FunctionLinkage::External());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((function_linkage).index() == 1 /* External */) && is_comptime)){
TRY((((*this).error(String("External functions cannot be comptime"),((((*this).current())).span())))));
}
const parser::Visibility visibility = last_visibility.value_or_lazy_evaluated([&] { return typename parser::Visibility::Public(); });
(last_visibility = JaktInternal::OptionalNone());
(last_visibility_span = JaktInternal::OptionalNone());
const parser::ParsedMethod parsed_method = TRY((((*this).parse_method(function_linkage,visibility,is_comptime))));
TRY((((methods).push(parsed_method))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Expected identifier or the end of enum block"),((((*this).current())).span())))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
if ((!(((((*this).current())).index() == 11 /* RCurly */)))){
TRY((((*this).error(String("Invalid enum definition, expected `}`"),((((*this).current())).span())))));
return ((Tuple{variants, methods}));
}
((((*this).index)++));
if (((variants).is_empty())){
TRY((((*this).error(String("Empty enums are not allowed"),((partial_enum).name_span)))));
}
return ((Tuple{variants, methods}));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_tuple() {
{
const utility::Span start = ((((*this).current())).span());
((((*this).index)++));
Array<NonnullRefPtr<parser::ParsedType>> types = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
while ((!(((*this).eof())))){
if (((((*this).current())).index() == 9 /* RParen */)){
((((*this).index)++));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::JaktTuple>(types,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))));
}
if (((((*this).current())).index() == 51 /* Comma */)){
((((*this).index)++));
}
const size_t index_before = ((*this).index);
const NonnullRefPtr<parser::ParsedType> type = TRY((((*this).parse_typename())));
const size_t index_after = ((*this).index);
if ((index_before == index_after)){
break;
}
TRY((((types).push(type))));
}
TRY((((*this).error(String("Expected )"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<Array<parser::ParsedCapture>> parser::Parser::parse_captures() {
{
Array<parser::ParsedCapture> captures = (TRY((Array<parser::ParsedCapture>::create_with({}))));
if (((((*this).current())).index() == 12 /* LSquare */)){
((((*this).index)++));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedCapture>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RSquare>();
{
((((*this).index)++));
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 38: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Ampersand>();
{
((((*this).index)++));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<parser::ParsedCapture>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 82: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Mut>();
{
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
TRY((((captures).push(typename parser::ParsedCapture::ByMutableReference(name,((((*this).current())).span()))))));
((((*this).index)++));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Expected identifier, got '{}'"),((*this).current())))),((((*this).current())).span())))));
((((*this).index)++));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
TRY((((captures).push(typename parser::ParsedCapture::ByReference(name,((((*this).current())).span()))))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Expected identifier or mut, got '{}'"),((*this).current())))),((((*this).current())).span())))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
{
TRY((((captures).push(typename parser::ParsedCapture::ByValue(name,((((*this).current())).span()))))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unexpected token '{}' in captures list"),((*this).current())))),((((*this).current())).span())))));
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (captures);
}
else {
return ((TRY((Array<parser::ParsedCapture>::create_with({})))));
}

}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_postfix_colon_colon(const utility::Span start,const NonnullRefPtr<parser::ParsedExpression> expr) {
{
((((*this).index)++));
Array<String> namespace_ = (TRY((Array<String>::create_with({}))));
if (((expr)->index() == 9 /* Var */)){
const String name = (expr->get<parser::ParsedExpression::Var>()).name;
TRY((((namespace_).push(name))));
}
else {
TRY((((*this).error(String("Expected namespace"),((expr)->span())))));
}

if (((*this).eof())){
TRY((((*this).error(String("Incomplete static method call"),((((*this).current())).span())))));
}
while ((!(((*this).eof())))){
if (((((*this).current())).index() == 4 /* Identifier */)){
const String current_name = (((*this).current()).get<lexer::Token::Identifier>()).name;
((((*this).index)++));
if (((((*this).current())).index() == 8 /* LParen */)){
((((*this).index)--));
Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
((((call.value())).namespace_) = namespace_);
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>((call.value()),TRY((parser::merge_spans(((expr)->span()),((((*this).current())).span()))))))));
}
if (((((*this).current())).index() == 7 /* ColonColon */)){
if (((((*this).previous())).index() == 4 /* Identifier */)){
const String name = (((*this).previous()).get<lexer::Token::Identifier>()).name;
TRY((((namespace_).push(name))));
}
else {
TRY((((*this).error(String("Expected namespace"),((expr)->span())))));
}

((((*this).index)++));
continue;
}
if (((((*this).current())).index() == 29 /* LessThan */)){
((((*this).index)--));
const Optional<parser::ParsedCall> maybe_call = TRY((((*this).parse_call())));
if (((maybe_call).has_value())){
parser::ParsedCall call = (maybe_call.value());
(((call).namespace_) = namespace_);
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Call>(call,TRY((parser::merge_spans(((expr)->span()),((((*this).current())).span()))))))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NamespacedVar>(current_name,namespace_,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
}
else {
TRY((((*this).error(String("Unsupported static method call"),((((*this).current())).span())))));
return (expr);
}

}
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Garbage>(((((*this).current())).span())))));
}
}

ErrorOr<void> parser::Parser::parse_import(parser::ParsedNamespace& parent) {
{
if (((((*this).current())).index() == 70 /* Extern */)){
((((*this).index)++));
TRY((((((parent))).add_extern_import(TRY((((*this).parse_extern_import(parent))))))));
}
else {
TRY((((((parent))).add_module_import(TRY((((*this).parse_module_import())))))));
}

}
return {};
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_if_statement() {
{
if ((!(((((*this).current())).index() == 75 /* If */)))){
TRY((((*this).error(String("Expected if statement"),((((*this).current())).span())))));
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Garbage>(((((*this).current())).span())))));
}
const utility::Span start_span = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> condition = TRY((((*this).parse_expression(false,true))));
const parser::ParsedBlock then_block = TRY((((*this).parse_block())));
Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement = JaktInternal::OptionalNone();
((*this).skip_newlines());
if (((((*this).current())).index() == 68 /* Else */)){
((((*this).index)++));
((*this).skip_newlines());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 75: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::If>();
{
(else_statement = TRY((((*this).parse_if_statement()))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LCurly>();
{
const parser::ParsedBlock block = TRY((((*this).parse_block())));
if (parser::parsed_block_equals(then_block,block)){
TRY((((*this).error(String("if and else have identical blocks"),((((*this).current())).span())))));
}
(else_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,TRY((parser::merge_spans(start_span,((((*this).previous())).span()))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("else missing if or block"),((((*this).previous())).span())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(condition,then_block,else_statement,TRY((parser::merge_spans(start_span,((((*this).previous())).span()))))))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedType>> parser::Parser::parse_type_shorthand_set() {
{
const utility::Span start = ((((*this).current())).span());
if (((((*this).current())).index() == 10 /* LCurly */)){
((((*this).index)++));
}
const NonnullRefPtr<parser::ParsedType> inner = TRY((((*this).parse_typename())));
if (((((*this).current())).index() == 11 /* RCurly */)){
((((*this).index)++));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Set>(inner,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
}
TRY((((*this).error(String("Expected '}'"),((((*this).current())).span())))));
return (TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedStatement>> parser::Parser::parse_guard_statement() {
{
const utility::Span span = ((((*this).current())).span());
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> expr = TRY((((*this).parse_expression(false,true))));
if (((((*this).current())).index() == 68 /* Else */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `else` keyword"),((((*this).current())).span())))));
}

const parser::ParsedBlock else_block = TRY((((*this).parse_block())));
parser::ParsedBlock remaining_code = parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({})))));
while ((!(((*this).eof())))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedStatement>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RCurly>();
{
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Guard>(expr,else_block,remaining_code,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Semicolon>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 54: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Eol>();
{
((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((remaining_code).stmts)).push(TRY((((*this).parse_statement(true))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Guard>(expr,else_block,remaining_code,span))));
}
}

ErrorOr<parser::ParsedVarDecl> parser::Parser::parse_variable_declaration(const bool is_mutable) {
{
const utility::Span span = ((((*this).current())).span());
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
((((*this).index)++));
if (((((*this).current())).index() == 6 /* Colon */)){
((((*this).index)++));
}
else {
return (parser::ParsedVarDecl(name,TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),is_mutable,span,span));
}

const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
if ((is_mutable && (((parsed_type)->index() == 8 /* Reference */) || ((parsed_type)->index() == 9 /* MutableReference */)))){
TRY((((*this).error(String("Reference parameter can not be mutable"),span))));
}
return (parser::ParsedVarDecl(name,parsed_type,is_mutable,JaktInternal::OptionalNone(),span));
}
else {
return (parser::ParsedVarDecl(String(""),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),span));
}

}
}

lexer::Token parser::Parser::current() const {
{
return (((*this).peek(static_cast<size_t>(0ULL))));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_expression(const bool allow_assignments,const bool allow_newlines) {
{
Array<NonnullRefPtr<parser::ParsedExpression>> expr_stack = (TRY((Array<NonnullRefPtr<parser::ParsedExpression>>::create_with({}))));
i64 last_precedence = static_cast<i64>(1000000LL);
const NonnullRefPtr<parser::ParsedExpression> lhs = TRY((((*this).parse_operand())));
TRY((((expr_stack).push(lhs))));
for (;;){
if (allow_newlines){
if ((((*this).eof()) || ((((*this).current())).index() == 10 /* LCurly */))){
break;
}
((*this).skip_newlines());
}
else {
if (((*this).eol())){
break;
}
}

const NonnullRefPtr<parser::ParsedExpression> parsed_operator = TRY((((*this).parse_operator(allow_assignments))));
if (((parsed_operator)->index() == 29 /* Garbage */)){
break;
}
const i64 precedence = ((parsed_operator)->precedence());
((*this).skip_newlines());
const NonnullRefPtr<parser::ParsedExpression> rhs = TRY((((*this).parse_operand())));
while (((precedence <= last_precedence) && (((expr_stack).size()) > static_cast<size_t>(1ULL)))){
const NonnullRefPtr<parser::ParsedExpression> rhs = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> op = (((expr_stack).pop()).value());
(last_precedence = ((op)->precedence()));
if ((last_precedence < precedence)){
TRY((((expr_stack).push(op))));
TRY((((expr_stack).push(rhs))));
break;
}
const NonnullRefPtr<parser::ParsedExpression> lhs = (((expr_stack).pop()).value());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = *op;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
{
const utility::Span new_span = TRY((parser::merge_spans(((lhs)->span()),((rhs)->span()))));
TRY((((expr_stack).push(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(lhs,op,rhs,new_span)))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("operator is not an operator")))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
TRY((((expr_stack).push(parsed_operator))));
TRY((((expr_stack).push(rhs))));
(last_precedence = precedence);
}
while ((((expr_stack).size()) > static_cast<size_t>(1ULL))){
const NonnullRefPtr<parser::ParsedExpression> rhs = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> parsed_operator = (((expr_stack).pop()).value());
const NonnullRefPtr<parser::ParsedExpression> lhs = (((expr_stack).pop()).value());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = *parsed_operator;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
{
const utility::Span new_span = TRY((parser::merge_spans(((lhs)->span()),((rhs)->span()))));
TRY((((expr_stack).push(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(lhs,op,rhs,new_span)))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("operator is not an operator")))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return (((expr_stack)[static_cast<i64>(0LL)]));
}
}

ErrorOr<parser::Visibility> parser::Parser::parse_restricted_visibility_modifier() {
{
utility::Span restricted_span = ((((*this).current())).span());
((((*this).index)++));
if (((((*this).current())).index() == 8 /* LParen */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected ("),((((*this).current())).span())))));
}

Array<NonnullRefPtr<parser::ParsedType>> whitelist = (TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))));
bool expect_comma = false;
while ((((*this).index) < ((((*this).tokens)).size()))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<parser::Visibility>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::RParen>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 51: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Comma>();
utility::Span const& span = __jakt_match_value.value;
{
if (expect_comma){
(expect_comma = false);
}
else {
TRY((((*this).error(String("Unexpected comma"),span))));
}

((((*this).index)++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if (expect_comma){
TRY((((*this).error(String("Expected comma"),((((*this).current())).span())))));
}
((*this).skip_newlines());
const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
TRY((((whitelist).push(parsed_type))));
(expect_comma = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
(((restricted_span).end) = ((((((*this).current())).span())).end));
if (((whitelist).is_empty())){
TRY((((*this).error(String("Type list cannot be empty"),restricted_span))));
}
if (((((*this).current())).index() == 9 /* RParen */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected )"),((((*this).current())).span())))));
}

return (typename parser::Visibility::Restricted(whitelist,restricted_span));
}
}

lexer::Token parser::Parser::peek(const size_t steps) const {
{
if ((((*this).eof()) || ((JaktInternal::checked_add<size_t>(steps,((*this).index))) >= ((((*this).tokens)).size())))){
return ((((((*this).tokens)).last()).value()));
}
return (((((*this).tokens))[(JaktInternal::checked_add<size_t>(((*this).index),steps))]));
}
}

ErrorOr<parser::ParsedRecord> parser::Parser::parse_record(const parser::DefinitionLinkage definition_linkage) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::ParsedRecord, ErrorOr<parser::ParsedRecord>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 91: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Struct>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_struct(definition_linkage)))));
};/*case end*/
case 64: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Class>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_class(definition_linkage)))));
};/*case end*/
case 69: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Enum>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_enum(definition_linkage,false)))));
};/*case end*/
case 61: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Boxed>();
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedRecord> __jakt_var_68; {
((((*this).index)++));
__jakt_var_68 = TRY((((*this).parse_enum(definition_linkage,true)))); goto __jakt_label_66;

}
__jakt_label_66:; __jakt_var_68.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::ParsedRecord> __jakt_var_69; {
TRY((((*this).error(String("Expected `struct`, `class`, `enum`, or `boxed`"),((((*this).current())).span())))));
__jakt_var_69 = parser::ParsedRecord(String(""),((*this).empty_span()),(TRY((Array<parser::ParsedGenericParameter>::create_with({})))),definition_linkage,(TRY((Array<parser::ParsedMethod>::create_with({})))),typename parser::RecordType::Garbage()); goto __jakt_label_67;

}
__jakt_label_67:; __jakt_var_69.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_try_block() {
{
const utility::Span start_span = ((((*this).current())).span());
const NonnullRefPtr<parser::ParsedStatement> stmt = TRY((((*this).parse_statement(false))));
String error_name = String("");
utility::Span error_span = ((((*this).current())).span());
if (((((*this).current())).index() == 63 /* Catch */)){
((((*this).index)++));
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
(error_span = ((((*this).current())).span()));
(error_name = name);
((((*this).index)++));
}
}
else {
TRY((((*this).error(String("Expected catch"),((((*this).current())).span())))));
}

const parser::ParsedBlock catch_block = TRY((((*this).parse_block())));
return (TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::TryBlock>(stmt,error_name,error_span,catch_block,TRY((parser::merge_spans(start_span,((((*this).previous())).span()))))))));
}
}

utility::Span parser::Parser::empty_span() const {
{
return (((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL))));
}
}

ErrorOr<Array<parser::ParsedMatchPattern>> parser::Parser::parse_match_patterns() {
{
Array<parser::ParsedMatchPattern> patterns = (TRY((Array<parser::ParsedMatchPattern>::create_with({}))));
((*this).skip_newlines());
while ((!(((*this).eof())))){
const parser::ParsedMatchPattern pattern = TRY((((*this).parse_match_pattern())));
TRY((((patterns).push(pattern))));
((*this).skip_newlines());
if (((((*this).current())).index() == 40 /* Pipe */)){
((((*this).index)++));
continue;
}
break;
}
return (patterns);
}
}

lexer::Token parser::Parser::previous() const {
{
if (((((*this).index) == static_cast<size_t>(0ULL)) || (((*this).index) > ((((*this).tokens)).size())))){
return (typename lexer::Token::Eof(((*this).span(static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)))));
}
return (((((*this).tokens))[(JaktInternal::checked_sub<size_t>(((*this).index),static_cast<size_t>(1ULL)))]));
}
}

ErrorOr<NonnullRefPtr<parser::ParsedExpression>> parser::Parser::parse_operand_postfix_operator(const utility::Span start,const NonnullRefPtr<parser::ParsedExpression> expr) {
{
NonnullRefPtr<parser::ParsedExpression> result = expr;
for (;;){
(result = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 53: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::DotDot>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_70; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> to = TRY((((*this).parse_expression(false,false))));
__jakt_var_70 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Range>(result,to,TRY((parser::merge_spans(start,((to)->span()))))))); goto __jakt_label_68;

}
__jakt_label_68:; __jakt_var_70.release_value(); }));
};/*case end*/
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_71; {
((((*this).index)++));
__jakt_var_71 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::ForcedUnwrap>(result,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_69;

}
__jakt_label_69:; __jakt_var_71.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::PlusPlus>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_72; {
((((*this).index)++));
__jakt_var_72 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::PostIncrement(),TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_70;

}
__jakt_label_70:; __jakt_var_72.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::MinusMinus>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_73; {
((((*this).index)++));
__jakt_var_73 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::PostDecrement(),TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_71;

}
__jakt_label_71:; __jakt_var_73.release_value(); }));
};/*case end*/
case 60: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::As>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_74; {
((((*this).index)++));
const utility::Span cast_span = TRY((parser::merge_spans(((((*this).previous())).span()),((((*this).current())).span()))));
const parser::TypeCast cast = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<parser::TypeCast, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 47: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ExclamationPoint>();
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_75; {
((((*this).index)++));
__jakt_var_75 = typename parser::TypeCast::Infallible(TRY((((*this).parse_typename())))); goto __jakt_label_73;

}
__jakt_label_73:; __jakt_var_75.release_value(); }));
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_76; {
((((*this).index)++));
__jakt_var_76 = typename parser::TypeCast::Fallible(TRY((((*this).parse_typename())))); goto __jakt_label_74;

}
__jakt_label_74:; __jakt_var_76.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<parser::TypeCast> __jakt_var_77; {
TRY((((*this).error(String("Invalid cast syntax"),cast_span))));
__jakt_var_77 = typename parser::TypeCast::Fallible(TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>()))); goto __jakt_label_75;

}
__jakt_label_75:; __jakt_var_77.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
const utility::Span span = TRY((parser::merge_spans(start,TRY((parser::merge_spans(cast_span,((((*this).current())).span())))))));
__jakt_var_74 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::TypeCast(cast),span))); goto __jakt_label_72;

}
__jakt_label_72:; __jakt_var_74.release_value(); }));
};/*case end*/
case 78: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Is>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_78; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedType> parsed_type = TRY((((*this).parse_typename())));
const utility::Span span = TRY((parser::merge_spans(start,((((*this).current())).span()))));
Array<parser::EnumVariantPatternArgument> bindings = (TRY((Array<parser::EnumVariantPatternArgument>::create_with({}))));
Optional<NonnullRefPtr<parser::ParsedExpression>> unary_operator_is = JaktInternal::OptionalNone();
if ((((((*this).current())).index() == 8 /* LParen */) && (((parsed_type)->index() == 1 /* NamespacedName */) || ((parsed_type)->index() == 0 /* Name */)))){
(bindings = TRY((((*this).parse_variant_arguments()))));
(unary_operator_is = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::IsEnumVariant(parsed_type,bindings),span))));
}
else {
(unary_operator_is = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(result,typename parser::UnaryOperator::Is(parsed_type),span))));
}

__jakt_var_78 = (unary_operator_is.value()); goto __jakt_label_76;

}
__jakt_label_76:; __jakt_var_78.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::ColonColon>();
return JaktInternal::ExplicitValue(TRY((((*this).parse_postfix_colon_colon(start,result)))));
};/*case end*/
case 48: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::QuestionMark>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_79; {
const bool is_optional = ((((*this).current())).index() == 48 /* QuestionMark */);
if (is_optional){
((((*this).index)++));
if ((!(((((*this).current())).index() == 52 /* Dot */)))){
TRY((((*this).error(String("Expected . after ? for optional chaining access"),((((*this).current())).span())))));
}
}
((((*this).index)++));
__jakt_var_79 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_80; {
((((*this).index)++));
const size_t num = ((number).to_usize());
__jakt_var_80 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(result,num,is_optional,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_78;

}
__jakt_label_78:; __jakt_var_80.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_81; {
((((*this).index)++));
__jakt_var_81 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_82; {
((((*this).index)--));
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
__jakt_var_82 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(result,(call.value()),is_optional,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_80;

}
__jakt_label_80:; __jakt_var_82.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedStruct>(result,name,is_optional,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_79;

}
__jakt_label_79:; __jakt_var_81.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_83; {
TRY((((*this).error(String("Unsupported dot operation"),((((*this).current())).span())))));
((((*this).index)++));
__jakt_var_83 = result; goto __jakt_label_81;

}
__jakt_label_81:; __jakt_var_83.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_77;

}
__jakt_label_77:; __jakt_var_79.release_value(); }));
};/*case end*/
case 52: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::Dot>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_84; {
const bool is_optional = ((((*this).current())).index() == 48 /* QuestionMark */);
if (is_optional){
((((*this).index)++));
if ((!(((((*this).current())).index() == 52 /* Dot */)))){
TRY((((*this).error(String("Expected . after ? for optional chaining access"),((((*this).current())).span())))));
}
}
((((*this).index)++));
__jakt_var_84 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Number>();lexer::NumericConstant const& number = __jakt_match_value.number;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_85; {
((((*this).index)++));
const size_t num = ((number).to_usize());
__jakt_var_85 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(result,num,is_optional,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_83;

}
__jakt_label_83:; __jakt_var_85.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<lexer::Token::Identifier>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_86; {
((((*this).index)++));
__jakt_var_86 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = ((*this).current());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LParen>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_87; {
((((*this).index)--));
const Optional<parser::ParsedCall> call = TRY((((*this).parse_call())));
__jakt_var_87 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(result,(call.value()),is_optional,TRY((parser::merge_spans(start,((((*this).previous())).span()))))))); goto __jakt_label_85;

}
__jakt_label_85:; __jakt_var_87.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedStruct>(result,name,is_optional,TRY((parser::merge_spans(start,((((*this).current())).span()))))))));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_84;

}
__jakt_label_84:; __jakt_var_86.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_88; {
TRY((((*this).error(String("Unsupported dot operation"),((((*this).current())).span())))));
((((*this).index)++));
__jakt_var_88 = result; goto __jakt_label_86;

}
__jakt_label_86:; __jakt_var_88.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_82;

}
__jakt_label_82:; __jakt_var_84.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::Token::LSquare>();
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_89; {
((((*this).index)++));
const NonnullRefPtr<parser::ParsedExpression> index_expr = TRY((((*this).parse_expression(false,false))));
if (((((*this).current())).index() == 13 /* RSquare */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected ']'"),((((*this).current())).span())))));
}

__jakt_var_89 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedExpression>, ErrorOr<NonnullRefPtr<parser::ParsedExpression>>>{
auto&& __jakt_match_variant = *index_expr;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_90; {
__jakt_var_90 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedRangeExpression>(result,from,to,TRY((parser::merge_spans(start,((((*this).current())).span()))))))); goto __jakt_label_88;

}
__jakt_label_88:; __jakt_var_90.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_91; {
__jakt_var_91 = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedExpression>(result,index_expr,TRY((parser::merge_spans(start,((((*this).current())).span()))))))); goto __jakt_label_89;

}
__jakt_label_89:; __jakt_var_91.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_87;

}
__jakt_label_87:; __jakt_var_89.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<parser::ParsedExpression>> __jakt_var_92; {
return JaktInternal::LoopBreak{};
__jakt_var_92 = result; goto __jakt_label_90;

}
__jakt_label_90:; __jakt_var_92.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
return (result);
}
}

ErrorOr<Array<parser::ParsedGenericParameter>> parser::Parser::parse_generic_parameters() {
{
if ((!(((((*this).current())).index() == 29 /* LessThan */)))){
return ((TRY((Array<parser::ParsedGenericParameter>::create_with({})))));
}
((((*this).index)++));
Array<parser::ParsedGenericParameter> generic_parameters = (TRY((Array<parser::ParsedGenericParameter>::create_with({}))));
((*this).skip_newlines());
while (((!(((((*this).current())).index() == 27 /* GreaterThan */))) && (!(((((*this).current())).index() == 102 /* Garbage */))))){
if (((((*this).current())).index() == 4 /* Identifier */)){
const String name = (((*this).current()).get<lexer::Token::Identifier>()).name;
const utility::Span span = (((*this).current()).get<lexer::Token::Identifier>()).span;
TRY((((generic_parameters).push(parser::ParsedGenericParameter(name,span)))));
((((*this).index)++));
if ((((((*this).current())).index() == 51 /* Comma */) || ((((*this).current())).index() == 54 /* Eol */))){
((((*this).index)++));
}
}
else {
TRY((((*this).error(String("Expected generic parameter name"),((((*this).current())).span())))));
return (generic_parameters);
}

}
if (((((*this).current())).index() == 27 /* GreaterThan */)){
((((*this).index)++));
}
else {
TRY((((*this).error(String("Expected `>` to end the generic parameters"),((((*this).current())).span())))));
return (generic_parameters);
}

return (generic_parameters);
}
}

ErrorOr<void> parser::ParsedNamespace::add_child_namespace(const parser::ParsedNamespace namespace_) {
{
{
ArrayIterator<parser::ParsedNamespace> _magic = ((((*this).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNamespace child_namespace = (_magic_value.value());
{
if (((child_namespace).is_equivalent_to(namespace_))){
TRY((((child_namespace).merge_with(namespace_))));
return {};
}
}

}
}

TRY((((((*this).namespaces)).push(namespace_))));
}
return {};
}

bool parser::ParsedNamespace::is_equivalent_to(const parser::ParsedNamespace other) const {
{
return (((((*this).name) == ((other).name)) && (((*this).import_path_if_extern) == ((other).import_path_if_extern))));
}
}

ErrorOr<void> parser::ParsedNamespace::add_extern_import(const parser::ParsedExternImport import_) {
{
{
ArrayIterator<parser::ParsedExternImport> _magic = ((((*this).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
if (TRY((((extern_import).is_equivalent_to(import_))))){
TRY((((((extern_import).assigned_namespace)).merge_with(((import_).assigned_namespace)))));
return {};
}
}

}
}

TRY((((((*this).extern_imports)).push(import_))));
}
return {};
}

ErrorOr<void> parser::ParsedNamespace::merge_with(const parser::ParsedNamespace namespace_) {
{
TRY((utility::extend_array<parser::ParsedFunction>(((*this).functions),((namespace_).functions))));
TRY((utility::extend_array<parser::ParsedRecord>(((*this).records),((namespace_).records))));
TRY((((((*this).module_imports)).add_capacity(((((namespace_).module_imports)).size())))));
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((namespace_).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedModuleImport import_ = (_magic_value.value());
{
TRY((((*this).add_module_import(import_))));
}

}
}

TRY((((((*this).extern_imports)).add_capacity(((((namespace_).extern_imports)).size())))));
{
ArrayIterator<parser::ParsedExternImport> _magic = ((((namespace_).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport import_ = (_magic_value.value());
{
TRY((((*this).add_extern_import(import_))));
}

}
}

{
ArrayIterator<parser::ParsedNamespace> _magic = ((((namespace_).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNamespace child_namespace = (_magic_value.value());
{
TRY((((*this).add_child_namespace(child_namespace))));
}

}
}

}
return {};
}

ErrorOr<void> parser::ParsedNamespace::add_module_import(const parser::ParsedModuleImport import_) {
{
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((*this).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedModuleImport module_import = (_magic_value.value());
{
if (((module_import).is_equivalent_to(import_))){
TRY((((module_import).merge_import_list(((import_).import_list)))));
return {};
}
}

}
}

TRY((((((*this).module_imports)).push(import_))));
}
return {};
}

utility::Span parser::ParsedType::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& name = __jakt_match_value.name;
Array<String> const& namespaces = __jakt_match_value.namespaces;
Array<NonnullRefPtr<parser::ParsedType>> const& params = __jakt_match_value.params;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::GenericType>();String const& name = __jakt_match_value.name;
Array<NonnullRefPtr<parser::ParsedType>> const& generic_parameters = __jakt_match_value.generic_parameters;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktArray>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Dictionary>();NonnullRefPtr<parser::ParsedType> const& key = __jakt_match_value.key;
NonnullRefPtr<parser::ParsedType> const& value = __jakt_match_value.value;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktTuple>();Array<NonnullRefPtr<parser::ParsedType>> const& types = __jakt_match_value.types;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Set>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Reference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::MutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::RawPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::WeakPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
return JaktInternal::ExplicitValue(utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedExpression::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedRangeExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& fill_size = __jakt_match_value.fill_size;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
Array<parser::ParsedMatchCase> const& cases = __jakt_match_value.cases;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
String const& field = __jakt_match_value.field;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& name = __jakt_match_value.name;
Array<String> const& namespace_ = __jakt_match_value.namespace_;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Try>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::TryBlock>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

i64 parser::ParsedExpression::precedence() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();parser::BinaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(static_cast<i64>(100LL));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(static_cast<i64>(90LL));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(static_cast<i64>(90LL));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticRightShift>();
return JaktInternal::ExplicitValue(static_cast<i64>(85LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue(static_cast<i64>(80LL));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue(static_cast<i64>(73LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue(static_cast<i64>(72LL));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue(static_cast<i64>(71LL));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(static_cast<i64>(70LL));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(static_cast<i64>(69LL));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
return JaktInternal::ExplicitValue(static_cast<i64>(69LL));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue(static_cast<i64>(50LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

NonnullRefPtr<parser::ParsedType> parser::TypeCast::parsed_type() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<parser::ParsedType>, NonnullRefPtr<parser::ParsedType>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Fallible>();
NonnullRefPtr<parser::ParsedType> const& parsed_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(parsed_type);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Infallible>();
NonnullRefPtr<parser::ParsedType> const& parsed_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(parsed_type);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String parser::RecordType::record_type_name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();return JaktInternal::ExplicitValue(String("value enum"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();return JaktInternal::ExplicitValue(String("sum enum"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
return JaktInternal::ExplicitValue(String("<garbage record type>"));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String parser::ParsedCapture::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedCapture::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool parser::BinaryOperator::is_assignment() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

utility::Span parser::ParsedStatement::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace typechecker {
struct ModuleId {
  public:
size_t id;ModuleId(size_t a_id) :id(a_id){}

bool equals(const typechecker::ModuleId rhs) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ModuleId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct ScopeId {
  public:
typechecker::ModuleId module_id;size_t id;bool equals(const typechecker::ScopeId other) const;
ScopeId(typechecker::ModuleId a_module_id, size_t a_id) :module_id(a_module_id), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ScopeId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_id: "));TRY(builder.appendff("{}, ", module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct TypeId {
  public:
typechecker::ModuleId module;size_t id;ErrorOr<String> to_string() const;
static Optional<typechecker::TypeId> none();
bool equals(const typechecker::TypeId rhs) const;
TypeId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

static ErrorOr<typechecker::TypeId> from_string(const String type_id_string);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("TypeId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedEnum {
  public:
String name;utility::Span name_span;Array<typechecker::TypeId> generic_parameters;Array<typechecker::CheckedEnumVariant> variants;typechecker::ScopeId scope_id;parser::DefinitionLinkage definition_linkage;parser::RecordType record_type;typechecker::TypeId underlying_type_id;typechecker::TypeId type_id;bool is_boxed;CheckedEnum(String a_name, utility::Span a_name_span, Array<typechecker::TypeId> a_generic_parameters, Array<typechecker::CheckedEnumVariant> a_variants, typechecker::ScopeId a_scope_id, parser::DefinitionLinkage a_definition_linkage, parser::RecordType a_record_type, typechecker::TypeId a_underlying_type_id, typechecker::TypeId a_type_id, bool a_is_boxed) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), variants(a_variants), scope_id(a_scope_id), definition_linkage(a_definition_linkage), record_type(a_record_type), underlying_type_id(a_underlying_type_id), type_id(a_type_id), is_boxed(a_is_boxed){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedEnum("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variants: "));TRY(builder.appendff("{}, ", variants));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}, ", record_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("underlying_type_id: "));TRY(builder.appendff("{}, ", underlying_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_boxed: "));TRY(builder.appendff("{}", is_boxed));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedEnumVariantBinding {
  public:
Optional<String> name;String binding;typechecker::TypeId type_id;utility::Span span;CheckedEnumVariantBinding(Optional<String> a_name, String a_binding, typechecker::TypeId a_type_id, utility::Span a_span) :name(a_name), binding(a_binding), type_id(a_type_id), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedEnumVariantBinding("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("{}, ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("binding: "));TRY(builder.appendff("\"{}\", ", binding));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct VarId {
  public:
typechecker::ModuleId module;size_t id;VarId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("VarId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace BlockControlFlow_Details {
struct AlwaysReturns {};
struct AlwaysTransfersControl {
bool might_break;
template<typename _MemberT0>
AlwaysTransfersControl(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct NeverReturns {};
struct MayReturn {};
struct PartialAlwaysReturns {
bool might_break;
template<typename _MemberT0>
PartialAlwaysReturns(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct PartialAlwaysTransfersControl {
bool might_break;
template<typename _MemberT0>
PartialAlwaysTransfersControl(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
struct PartialNeverReturns {
bool might_break;
template<typename _MemberT0>
PartialNeverReturns(_MemberT0&& member_0):
might_break{ forward<_MemberT0>(member_0)}
{}
};
}
struct BlockControlFlow : public Variant<BlockControlFlow_Details::AlwaysReturns, BlockControlFlow_Details::AlwaysTransfersControl, BlockControlFlow_Details::NeverReturns, BlockControlFlow_Details::MayReturn, BlockControlFlow_Details::PartialAlwaysReturns, BlockControlFlow_Details::PartialAlwaysTransfersControl, BlockControlFlow_Details::PartialNeverReturns> {
using Variant<BlockControlFlow_Details::AlwaysReturns, BlockControlFlow_Details::AlwaysTransfersControl, BlockControlFlow_Details::NeverReturns, BlockControlFlow_Details::MayReturn, BlockControlFlow_Details::PartialAlwaysReturns, BlockControlFlow_Details::PartialAlwaysTransfersControl, BlockControlFlow_Details::PartialNeverReturns>::Variant;
    using AlwaysReturns = BlockControlFlow_Details::AlwaysReturns;
    using AlwaysTransfersControl = BlockControlFlow_Details::AlwaysTransfersControl;
    using NeverReturns = BlockControlFlow_Details::NeverReturns;
    using MayReturn = BlockControlFlow_Details::MayReturn;
    using PartialAlwaysReturns = BlockControlFlow_Details::PartialAlwaysReturns;
    using PartialAlwaysTransfersControl = BlockControlFlow_Details::PartialAlwaysTransfersControl;
    using PartialNeverReturns = BlockControlFlow_Details::PartialNeverReturns;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* AlwaysReturns */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::AlwaysReturns>();
TRY(builder.append("BlockControlFlow::AlwaysReturns"));
break;}
case 1 /* AlwaysTransfersControl */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::AlwaysTransfersControl>();
TRY(builder.append("BlockControlFlow::AlwaysTransfersControl"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("might_break: {}", that.might_break));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* NeverReturns */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::NeverReturns>();
TRY(builder.append("BlockControlFlow::NeverReturns"));
break;}
case 3 /* MayReturn */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::MayReturn>();
TRY(builder.append("BlockControlFlow::MayReturn"));
break;}
case 4 /* PartialAlwaysReturns */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::PartialAlwaysReturns>();
TRY(builder.append("BlockControlFlow::PartialAlwaysReturns"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("might_break: {}", that.might_break));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* PartialAlwaysTransfersControl */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::PartialAlwaysTransfersControl>();
TRY(builder.append("BlockControlFlow::PartialAlwaysTransfersControl"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("might_break: {}", that.might_break));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* PartialNeverReturns */: {
[[maybe_unused]] auto const& that = this->template get<BlockControlFlow::PartialNeverReturns>();
TRY(builder.append("BlockControlFlow::PartialNeverReturns"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("might_break: {}", that.might_break));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}bool always_transfers_control() const;
typechecker::BlockControlFlow partial() const;
bool always_returns() const;
typechecker::BlockControlFlow updated(const typechecker::BlockControlFlow second) const;
bool may_break() const;
bool is_reachable() const;
bool never_returns() const;
bool may_return() const;
typechecker::BlockControlFlow unify_with(const typechecker::BlockControlFlow second) const;
};
struct CheckedBlock {
  public:
Array<NonnullRefPtr<typechecker::CheckedStatement>> statements;typechecker::ScopeId scope_id;typechecker::BlockControlFlow control_flow;Optional<typechecker::TypeId> yielded_type;CheckedBlock(Array<NonnullRefPtr<typechecker::CheckedStatement>> a_statements, typechecker::ScopeId a_scope_id, typechecker::BlockControlFlow a_control_flow, Optional<typechecker::TypeId> a_yielded_type) :statements(a_statements), scope_id(a_scope_id), control_flow(a_control_flow), yielded_type(a_yielded_type){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedBlock("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statements: "));TRY(builder.appendff("{}, ", statements));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("control_flow: "));TRY(builder.appendff("{}, ", control_flow));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("yielded_type: "));TRY(builder.appendff("{}", yielded_type));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedStatement_Details {
struct Expression {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Expression(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Defer {
NonnullRefPtr<typechecker::CheckedStatement> statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Defer(_MemberT0&& member_0, _MemberT1&& member_1):
statement{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct DestructuringAssignment {
Array<NonnullRefPtr<typechecker::CheckedStatement>> vars;
NonnullRefPtr<typechecker::CheckedStatement> var_decl;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
DestructuringAssignment(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vars{ forward<_MemberT0>(member_0)},
var_decl{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct VarDecl {
typechecker::VarId var_id;
NonnullRefPtr<typechecker::CheckedExpression> init;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
VarDecl(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
var_id{ forward<_MemberT0>(member_0)},
init{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct If {
NonnullRefPtr<typechecker::CheckedExpression> condition;
typechecker::CheckedBlock then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> else_statement;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
If(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
condition{ forward<_MemberT0>(member_0)},
then_block{ forward<_MemberT1>(member_1)},
else_statement{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Block {
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Block(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Loop {
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Loop(_MemberT0&& member_0, _MemberT1&& member_1):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct While {
NonnullRefPtr<typechecker::CheckedExpression> condition;
typechecker::CheckedBlock block;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
While(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
condition{ forward<_MemberT0>(member_0)},
block{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Return {
Optional<NonnullRefPtr<typechecker::CheckedExpression>> val;
Optional<utility::Span> span;
template<typename _MemberT0, typename _MemberT1>
Return(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Break{
utility::Span value;
template<typename... Args>
Break(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue{
utility::Span value;
template<typename... Args>
Continue(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Throw(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Yield {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Yield(_MemberT0&& member_0, _MemberT1&& member_1):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct InlineCpp {
Array<String> lines;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
InlineCpp(_MemberT0&& member_0, _MemberT1&& member_1):
lines{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedStatement : public Variant<CheckedStatement_Details::Expression, CheckedStatement_Details::Defer, CheckedStatement_Details::DestructuringAssignment, CheckedStatement_Details::VarDecl, CheckedStatement_Details::If, CheckedStatement_Details::Block, CheckedStatement_Details::Loop, CheckedStatement_Details::While, CheckedStatement_Details::Return, CheckedStatement_Details::Break, CheckedStatement_Details::Continue, CheckedStatement_Details::Throw, CheckedStatement_Details::Yield, CheckedStatement_Details::InlineCpp, CheckedStatement_Details::Garbage>, public RefCounted<CheckedStatement> {
using Variant<CheckedStatement_Details::Expression, CheckedStatement_Details::Defer, CheckedStatement_Details::DestructuringAssignment, CheckedStatement_Details::VarDecl, CheckedStatement_Details::If, CheckedStatement_Details::Block, CheckedStatement_Details::Loop, CheckedStatement_Details::While, CheckedStatement_Details::Return, CheckedStatement_Details::Break, CheckedStatement_Details::Continue, CheckedStatement_Details::Throw, CheckedStatement_Details::Yield, CheckedStatement_Details::InlineCpp, CheckedStatement_Details::Garbage>::Variant;
    using Expression = CheckedStatement_Details::Expression;
    using Defer = CheckedStatement_Details::Defer;
    using DestructuringAssignment = CheckedStatement_Details::DestructuringAssignment;
    using VarDecl = CheckedStatement_Details::VarDecl;
    using If = CheckedStatement_Details::If;
    using Block = CheckedStatement_Details::Block;
    using Loop = CheckedStatement_Details::Loop;
    using While = CheckedStatement_Details::While;
    using Return = CheckedStatement_Details::Return;
    using Break = CheckedStatement_Details::Break;
    using Continue = CheckedStatement_Details::Continue;
    using Throw = CheckedStatement_Details::Throw;
    using Yield = CheckedStatement_Details::Yield;
    using InlineCpp = CheckedStatement_Details::InlineCpp;
    using Garbage = CheckedStatement_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) CheckedStatement(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Expression>();
TRY(builder.append("CheckedStatement::Expression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Defer */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Defer>();
TRY(builder.append("CheckedStatement::Defer"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("statement: {}", that.statement));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* DestructuringAssignment */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::DestructuringAssignment>();
TRY(builder.append("CheckedStatement::DestructuringAssignment"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vars: {}", that.vars));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var_decl: {}", that.var_decl));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* VarDecl */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::VarDecl>();
TRY(builder.append("CheckedStatement::VarDecl"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var_id: {}", that.var_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("init: {}", that.init));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* If */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::If>();
TRY(builder.append("CheckedStatement::If"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("condition: {}", that.condition));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("then_block: {}", that.then_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("else_statement: {}", that.else_statement));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* Block */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Block>();
TRY(builder.append("CheckedStatement::Block"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* Loop */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Loop>();
TRY(builder.append("CheckedStatement::Loop"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 7 /* While */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::While>();
TRY(builder.append("CheckedStatement::While"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("condition: {}", that.condition));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 8 /* Return */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Return>();
TRY(builder.append("CheckedStatement::Return"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: {}", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 9 /* Break */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Break>();
TRY(builder.append("CheckedStatement::Break"));
TRY(builder.appendff("({})", that.value));
break;}
case 10 /* Continue */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Continue>();
TRY(builder.append("CheckedStatement::Continue"));
TRY(builder.appendff("({})", that.value));
break;}
case 11 /* Throw */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Throw>();
TRY(builder.append("CheckedStatement::Throw"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 12 /* Yield */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Yield>();
TRY(builder.append("CheckedStatement::Yield"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 13 /* InlineCpp */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::InlineCpp>();
TRY(builder.append("CheckedStatement::InlineCpp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("lines: {}", that.lines));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 14 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<CheckedStatement::Garbage>();
TRY(builder.append("CheckedStatement::Garbage"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}static Optional<NonnullRefPtr<typechecker::CheckedStatement>> none();
Optional<utility::Span> span() const;
};
struct LoadedModule {
  public:
typechecker::ModuleId module_id;utility::FileId file_id;LoadedModule(typechecker::ModuleId a_module_id, utility::FileId a_file_id) :module_id(a_module_id), file_id(a_file_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("LoadedModule("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module_id: "));TRY(builder.appendff("{}, ", module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_id: "));TRY(builder.appendff("{}", file_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct StructId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::StructId rhs) const;
StructId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("StructId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct FunctionId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::FunctionId rhs) const;
FunctionId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("FunctionId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct EnumId {
  public:
typechecker::ModuleId module;size_t id;bool equals(const typechecker::EnumId rhs) const;
EnumId(typechecker::ModuleId a_module, size_t a_id) :module(a_module), id(a_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("EnumId("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("module: "));TRY(builder.appendff("{}, ", module));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}", id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Value {
  public:
NonnullRefPtr<typechecker::ValueImpl> impl;utility::Span span;ErrorOr<typechecker::Value> copy() const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> to_checked_expression(typechecker::Interpreter interpreter) const;
Value(NonnullRefPtr<typechecker::ValueImpl> a_impl, utility::Span a_span) :impl(a_impl), span(a_span){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Value("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("impl: "));TRY(builder.appendff("{}, ", impl));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}", span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace ValueImpl_Details {
struct Void {};
struct Bool{
bool value;
template<typename... Args>
Bool(Args&&... args): value { forward<Args>(args)... } {}
};
struct U8{
u8 value;
template<typename... Args>
U8(Args&&... args): value { forward<Args>(args)... } {}
};
struct U16{
u16 value;
template<typename... Args>
U16(Args&&... args): value { forward<Args>(args)... } {}
};
struct U32{
u32 value;
template<typename... Args>
U32(Args&&... args): value { forward<Args>(args)... } {}
};
struct U64{
u64 value;
template<typename... Args>
U64(Args&&... args): value { forward<Args>(args)... } {}
};
struct I8{
i8 value;
template<typename... Args>
I8(Args&&... args): value { forward<Args>(args)... } {}
};
struct I16{
i16 value;
template<typename... Args>
I16(Args&&... args): value { forward<Args>(args)... } {}
};
struct I32{
i32 value;
template<typename... Args>
I32(Args&&... args): value { forward<Args>(args)... } {}
};
struct I64{
i64 value;
template<typename... Args>
I64(Args&&... args): value { forward<Args>(args)... } {}
};
struct F32{
f32 value;
template<typename... Args>
F32(Args&&... args): value { forward<Args>(args)... } {}
};
struct F64{
f64 value;
template<typename... Args>
F64(Args&&... args): value { forward<Args>(args)... } {}
};
struct USize{
size_t value;
template<typename... Args>
USize(Args&&... args): value { forward<Args>(args)... } {}
};
struct JaktString{
String value;
template<typename... Args>
JaktString(Args&&... args): value { forward<Args>(args)... } {}
};
struct CChar{
char value;
template<typename... Args>
CChar(Args&&... args): value { forward<Args>(args)... } {}
};
struct CInt{
int value;
template<typename... Args>
CInt(Args&&... args): value { forward<Args>(args)... } {}
};
struct Struct {
Array<typechecker::Value> fields;
typechecker::StructId struct_id;
Optional<typechecker::FunctionId> constructor;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Struct(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
fields{ forward<_MemberT0>(member_0)},
struct_id{ forward<_MemberT1>(member_1)},
constructor{ forward<_MemberT2>(member_2)}
{}
};
struct Class {
Array<typechecker::Value> fields;
typechecker::StructId struct_id;
Optional<typechecker::FunctionId> constructor;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Class(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
fields{ forward<_MemberT0>(member_0)},
struct_id{ forward<_MemberT1>(member_1)},
constructor{ forward<_MemberT2>(member_2)}
{}
};
struct Enum {
Array<typechecker::Value> fields;
typechecker::EnumId enum_id;
typechecker::FunctionId constructor;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Enum(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
fields{ forward<_MemberT0>(member_0)},
enum_id{ forward<_MemberT1>(member_1)},
constructor{ forward<_MemberT2>(member_2)}
{}
};
struct JaktArray {
Array<typechecker::Value> values;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1):
values{ forward<_MemberT0>(member_0)},
type_id{ forward<_MemberT1>(member_1)}
{}
};
struct RawPtr{
NonnullRefPtr<typechecker::ValueImpl> value;
template<typename... Args>
RawPtr(Args&&... args): value { forward<Args>(args)... } {}
};
struct OptionalSome {
typechecker::Value value;
template<typename _MemberT0>
OptionalSome(_MemberT0&& member_0):
value{ forward<_MemberT0>(member_0)}
{}
};
struct OptionalNone {};
}
struct ValueImpl : public Variant<ValueImpl_Details::Void, ValueImpl_Details::Bool, ValueImpl_Details::U8, ValueImpl_Details::U16, ValueImpl_Details::U32, ValueImpl_Details::U64, ValueImpl_Details::I8, ValueImpl_Details::I16, ValueImpl_Details::I32, ValueImpl_Details::I64, ValueImpl_Details::F32, ValueImpl_Details::F64, ValueImpl_Details::USize, ValueImpl_Details::JaktString, ValueImpl_Details::CChar, ValueImpl_Details::CInt, ValueImpl_Details::Struct, ValueImpl_Details::Class, ValueImpl_Details::Enum, ValueImpl_Details::JaktArray, ValueImpl_Details::RawPtr, ValueImpl_Details::OptionalSome, ValueImpl_Details::OptionalNone>, public RefCounted<ValueImpl> {
using Variant<ValueImpl_Details::Void, ValueImpl_Details::Bool, ValueImpl_Details::U8, ValueImpl_Details::U16, ValueImpl_Details::U32, ValueImpl_Details::U64, ValueImpl_Details::I8, ValueImpl_Details::I16, ValueImpl_Details::I32, ValueImpl_Details::I64, ValueImpl_Details::F32, ValueImpl_Details::F64, ValueImpl_Details::USize, ValueImpl_Details::JaktString, ValueImpl_Details::CChar, ValueImpl_Details::CInt, ValueImpl_Details::Struct, ValueImpl_Details::Class, ValueImpl_Details::Enum, ValueImpl_Details::JaktArray, ValueImpl_Details::RawPtr, ValueImpl_Details::OptionalSome, ValueImpl_Details::OptionalNone>::Variant;
    using Void = ValueImpl_Details::Void;
    using Bool = ValueImpl_Details::Bool;
    using U8 = ValueImpl_Details::U8;
    using U16 = ValueImpl_Details::U16;
    using U32 = ValueImpl_Details::U32;
    using U64 = ValueImpl_Details::U64;
    using I8 = ValueImpl_Details::I8;
    using I16 = ValueImpl_Details::I16;
    using I32 = ValueImpl_Details::I32;
    using I64 = ValueImpl_Details::I64;
    using F32 = ValueImpl_Details::F32;
    using F64 = ValueImpl_Details::F64;
    using USize = ValueImpl_Details::USize;
    using JaktString = ValueImpl_Details::JaktString;
    using CChar = ValueImpl_Details::CChar;
    using CInt = ValueImpl_Details::CInt;
    using Struct = ValueImpl_Details::Struct;
    using Class = ValueImpl_Details::Class;
    using Enum = ValueImpl_Details::Enum;
    using JaktArray = ValueImpl_Details::JaktArray;
    using RawPtr = ValueImpl_Details::RawPtr;
    using OptionalSome = ValueImpl_Details::OptionalSome;
    using OptionalNone = ValueImpl_Details::OptionalNone;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) ValueImpl(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Void */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::Void>();
TRY(builder.append("ValueImpl::Void"));
break;}
case 1 /* Bool */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::Bool>();
TRY(builder.append("ValueImpl::Bool"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* U8 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::U8>();
TRY(builder.append("ValueImpl::U8"));
TRY(builder.appendff("({})", that.value));
break;}
case 3 /* U16 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::U16>();
TRY(builder.append("ValueImpl::U16"));
TRY(builder.appendff("({})", that.value));
break;}
case 4 /* U32 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::U32>();
TRY(builder.append("ValueImpl::U32"));
TRY(builder.appendff("({})", that.value));
break;}
case 5 /* U64 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::U64>();
TRY(builder.append("ValueImpl::U64"));
TRY(builder.appendff("({})", that.value));
break;}
case 6 /* I8 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::I8>();
TRY(builder.append("ValueImpl::I8"));
TRY(builder.appendff("({})", that.value));
break;}
case 7 /* I16 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::I16>();
TRY(builder.append("ValueImpl::I16"));
TRY(builder.appendff("({})", that.value));
break;}
case 8 /* I32 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::I32>();
TRY(builder.append("ValueImpl::I32"));
TRY(builder.appendff("({})", that.value));
break;}
case 9 /* I64 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::I64>();
TRY(builder.append("ValueImpl::I64"));
TRY(builder.appendff("({})", that.value));
break;}
case 10 /* F32 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::F32>();
TRY(builder.append("ValueImpl::F32"));
TRY(builder.appendff("({})", that.value));
break;}
case 11 /* F64 */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::F64>();
TRY(builder.append("ValueImpl::F64"));
TRY(builder.appendff("({})", that.value));
break;}
case 12 /* USize */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::USize>();
TRY(builder.append("ValueImpl::USize"));
TRY(builder.appendff("({})", that.value));
break;}
case 13 /* JaktString */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::JaktString>();
TRY(builder.append("ValueImpl::JaktString"));
TRY(builder.appendff("(\"{}\")", that.value));
break;}
case 14 /* CChar */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::CChar>();
TRY(builder.append("ValueImpl::CChar"));
TRY(builder.appendff("({})", that.value));
break;}
case 15 /* CInt */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::CInt>();
TRY(builder.append("ValueImpl::CInt"));
TRY(builder.appendff("({})", that.value));
break;}
case 16 /* Struct */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::Struct>();
TRY(builder.append("ValueImpl::Struct"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("struct_id: {}", that.struct_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("constructor: {}", that.constructor));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 17 /* Class */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::Class>();
TRY(builder.append("ValueImpl::Class"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("struct_id: {}", that.struct_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("constructor: {}", that.constructor));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 18 /* Enum */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::Enum>();
TRY(builder.append("ValueImpl::Enum"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_id: {}", that.enum_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("constructor: {}", that.constructor));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 19 /* JaktArray */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::JaktArray>();
TRY(builder.append("ValueImpl::JaktArray"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("values: {}", that.values));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 20 /* RawPtr */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::RawPtr>();
TRY(builder.append("ValueImpl::RawPtr"));
TRY(builder.appendff("({})", that.value));
break;}
case 21 /* OptionalSome */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::OptionalSome>();
TRY(builder.append("ValueImpl::OptionalSome"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("value: {}", that.value));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 22 /* OptionalNone */: {
[[maybe_unused]] auto const& that = this->template get<ValueImpl::OptionalNone>();
TRY(builder.append("ValueImpl::OptionalNone"));
break;}
}
return builder.to_string();
}ErrorOr<NonnullRefPtr<typechecker::ValueImpl>> copy() const;
};
namespace CheckedTypeCast_Details {
struct Fallible{
typechecker::TypeId value;
template<typename... Args>
Fallible(Args&&... args): value { forward<Args>(args)... } {}
};
struct Infallible{
typechecker::TypeId value;
template<typename... Args>
Infallible(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedTypeCast : public Variant<CheckedTypeCast_Details::Fallible, CheckedTypeCast_Details::Infallible> {
using Variant<CheckedTypeCast_Details::Fallible, CheckedTypeCast_Details::Infallible>::Variant;
    using Fallible = CheckedTypeCast_Details::Fallible;
    using Infallible = CheckedTypeCast_Details::Infallible;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Fallible */: {
[[maybe_unused]] auto const& that = this->template get<CheckedTypeCast::Fallible>();
TRY(builder.append("CheckedTypeCast::Fallible"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Infallible */: {
[[maybe_unused]] auto const& that = this->template get<CheckedTypeCast::Infallible>();
TRY(builder.append("CheckedTypeCast::Infallible"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}typechecker::TypeId type_id() const;
};
namespace CheckedEnumVariant_Details {
struct Untyped {
typechecker::EnumId enum_id;
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Untyped(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Typed {
typechecker::EnumId enum_id;
String name;
typechecker::TypeId type_id;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Typed(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct WithValue {
typechecker::EnumId enum_id;
String name;
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
WithValue(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
expr{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct StructLike {
typechecker::EnumId enum_id;
String name;
Array<typechecker::VarId> fields;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
StructLike(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
enum_id{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
fields{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
}
struct CheckedEnumVariant : public Variant<CheckedEnumVariant_Details::Untyped, CheckedEnumVariant_Details::Typed, CheckedEnumVariant_Details::WithValue, CheckedEnumVariant_Details::StructLike> {
using Variant<CheckedEnumVariant_Details::Untyped, CheckedEnumVariant_Details::Typed, CheckedEnumVariant_Details::WithValue, CheckedEnumVariant_Details::StructLike>::Variant;
    using Untyped = CheckedEnumVariant_Details::Untyped;
    using Typed = CheckedEnumVariant_Details::Typed;
    using WithValue = CheckedEnumVariant_Details::WithValue;
    using StructLike = CheckedEnumVariant_Details::StructLike;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Untyped */: {
[[maybe_unused]] auto const& that = this->template get<CheckedEnumVariant::Untyped>();
TRY(builder.append("CheckedEnumVariant::Untyped"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_id: {}", that.enum_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Typed */: {
[[maybe_unused]] auto const& that = this->template get<CheckedEnumVariant::Typed>();
TRY(builder.append("CheckedEnumVariant::Typed"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_id: {}", that.enum_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* WithValue */: {
[[maybe_unused]] auto const& that = this->template get<CheckedEnumVariant::WithValue>();
TRY(builder.append("CheckedEnumVariant::WithValue"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_id: {}", that.enum_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* StructLike */: {
[[maybe_unused]] auto const& that = this->template get<CheckedEnumVariant::StructLike>();
TRY(builder.append("CheckedEnumVariant::StructLike"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_id: {}", that.enum_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("fields: {}", that.fields));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}typechecker::EnumId enum_id() const;
String name() const;
bool equals(const typechecker::CheckedEnumVariant other) const;
utility::Span span() const;
};
namespace CheckedUnaryOperator_Details {
struct PreIncrement {};
struct PostIncrement {};
struct PreDecrement {};
struct PostDecrement {};
struct Negate {};
struct Dereference {};
struct RawAddress {};
struct Reference {};
struct MutableReference {};
struct LogicalNot {};
struct BitwiseNot {};
struct TypeCast{
typechecker::CheckedTypeCast value;
template<typename... Args>
TypeCast(Args&&... args): value { forward<Args>(args)... } {}
};
struct Is{
typechecker::TypeId value;
template<typename... Args>
Is(Args&&... args): value { forward<Args>(args)... } {}
};
struct IsEnumVariant {
typechecker::CheckedEnumVariant enum_variant;
Array<typechecker::CheckedEnumVariantBinding> bindings;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
IsEnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
enum_variant{ forward<_MemberT0>(member_0)},
bindings{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
}
struct CheckedUnaryOperator : public Variant<CheckedUnaryOperator_Details::PreIncrement, CheckedUnaryOperator_Details::PostIncrement, CheckedUnaryOperator_Details::PreDecrement, CheckedUnaryOperator_Details::PostDecrement, CheckedUnaryOperator_Details::Negate, CheckedUnaryOperator_Details::Dereference, CheckedUnaryOperator_Details::RawAddress, CheckedUnaryOperator_Details::Reference, CheckedUnaryOperator_Details::MutableReference, CheckedUnaryOperator_Details::LogicalNot, CheckedUnaryOperator_Details::BitwiseNot, CheckedUnaryOperator_Details::TypeCast, CheckedUnaryOperator_Details::Is, CheckedUnaryOperator_Details::IsEnumVariant> {
using Variant<CheckedUnaryOperator_Details::PreIncrement, CheckedUnaryOperator_Details::PostIncrement, CheckedUnaryOperator_Details::PreDecrement, CheckedUnaryOperator_Details::PostDecrement, CheckedUnaryOperator_Details::Negate, CheckedUnaryOperator_Details::Dereference, CheckedUnaryOperator_Details::RawAddress, CheckedUnaryOperator_Details::Reference, CheckedUnaryOperator_Details::MutableReference, CheckedUnaryOperator_Details::LogicalNot, CheckedUnaryOperator_Details::BitwiseNot, CheckedUnaryOperator_Details::TypeCast, CheckedUnaryOperator_Details::Is, CheckedUnaryOperator_Details::IsEnumVariant>::Variant;
    using PreIncrement = CheckedUnaryOperator_Details::PreIncrement;
    using PostIncrement = CheckedUnaryOperator_Details::PostIncrement;
    using PreDecrement = CheckedUnaryOperator_Details::PreDecrement;
    using PostDecrement = CheckedUnaryOperator_Details::PostDecrement;
    using Negate = CheckedUnaryOperator_Details::Negate;
    using Dereference = CheckedUnaryOperator_Details::Dereference;
    using RawAddress = CheckedUnaryOperator_Details::RawAddress;
    using Reference = CheckedUnaryOperator_Details::Reference;
    using MutableReference = CheckedUnaryOperator_Details::MutableReference;
    using LogicalNot = CheckedUnaryOperator_Details::LogicalNot;
    using BitwiseNot = CheckedUnaryOperator_Details::BitwiseNot;
    using TypeCast = CheckedUnaryOperator_Details::TypeCast;
    using Is = CheckedUnaryOperator_Details::Is;
    using IsEnumVariant = CheckedUnaryOperator_Details::IsEnumVariant;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* PreIncrement */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::PreIncrement>();
TRY(builder.append("CheckedUnaryOperator::PreIncrement"));
break;}
case 1 /* PostIncrement */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::PostIncrement>();
TRY(builder.append("CheckedUnaryOperator::PostIncrement"));
break;}
case 2 /* PreDecrement */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::PreDecrement>();
TRY(builder.append("CheckedUnaryOperator::PreDecrement"));
break;}
case 3 /* PostDecrement */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::PostDecrement>();
TRY(builder.append("CheckedUnaryOperator::PostDecrement"));
break;}
case 4 /* Negate */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::Negate>();
TRY(builder.append("CheckedUnaryOperator::Negate"));
break;}
case 5 /* Dereference */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::Dereference>();
TRY(builder.append("CheckedUnaryOperator::Dereference"));
break;}
case 6 /* RawAddress */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::RawAddress>();
TRY(builder.append("CheckedUnaryOperator::RawAddress"));
break;}
case 7 /* Reference */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::Reference>();
TRY(builder.append("CheckedUnaryOperator::Reference"));
break;}
case 8 /* MutableReference */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::MutableReference>();
TRY(builder.append("CheckedUnaryOperator::MutableReference"));
break;}
case 9 /* LogicalNot */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::LogicalNot>();
TRY(builder.append("CheckedUnaryOperator::LogicalNot"));
break;}
case 10 /* BitwiseNot */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::BitwiseNot>();
TRY(builder.append("CheckedUnaryOperator::BitwiseNot"));
break;}
case 11 /* TypeCast */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::TypeCast>();
TRY(builder.append("CheckedUnaryOperator::TypeCast"));
TRY(builder.appendff("({})", that.value));
break;}
case 12 /* Is */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::Is>();
TRY(builder.append("CheckedUnaryOperator::Is"));
TRY(builder.appendff("({})", that.value));
break;}
case 13 /* IsEnumVariant */: {
[[maybe_unused]] auto const& that = this->template get<CheckedUnaryOperator::IsEnumVariant>();
TRY(builder.append("CheckedUnaryOperator::IsEnumVariant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_variant: {}", that.enum_variant));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("bindings: {}", that.bindings));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}};
struct ResolvedNamespace {
  public:
String name;Optional<Array<typechecker::TypeId>> generic_parameters;ResolvedNamespace(String a_name, Optional<Array<typechecker::TypeId>> a_generic_parameters) :name(a_name), generic_parameters(a_generic_parameters){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ResolvedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}", generic_parameters));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace StructOrEnumId_Details {
struct Struct{
typechecker::StructId value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
typechecker::EnumId value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct StructOrEnumId : public Variant<StructOrEnumId_Details::Struct, StructOrEnumId_Details::Enum> {
using Variant<StructOrEnumId_Details::Struct, StructOrEnumId_Details::Enum>::Variant;
    using Struct = StructOrEnumId_Details::Struct;
    using Enum = StructOrEnumId_Details::Enum;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Struct */: {
[[maybe_unused]] auto const& that = this->template get<StructOrEnumId::Struct>();
TRY(builder.append("StructOrEnumId::Struct"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Enum */: {
[[maybe_unused]] auto const& that = this->template get<StructOrEnumId::Enum>();
TRY(builder.append("StructOrEnumId::Enum"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}};
struct CheckedNamespace {
  public:
String name;typechecker::ScopeId scope;CheckedNamespace(String a_name, typechecker::ScopeId a_scope) :name(a_name), scope(a_scope){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedNamespace("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope: "));TRY(builder.appendff("{}", scope));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedNumericConstant_Details {
struct I8{
i8 value;
template<typename... Args>
I8(Args&&... args): value { forward<Args>(args)... } {}
};
struct I16{
i16 value;
template<typename... Args>
I16(Args&&... args): value { forward<Args>(args)... } {}
};
struct I32{
i32 value;
template<typename... Args>
I32(Args&&... args): value { forward<Args>(args)... } {}
};
struct I64{
i64 value;
template<typename... Args>
I64(Args&&... args): value { forward<Args>(args)... } {}
};
struct U8{
u8 value;
template<typename... Args>
U8(Args&&... args): value { forward<Args>(args)... } {}
};
struct U16{
u16 value;
template<typename... Args>
U16(Args&&... args): value { forward<Args>(args)... } {}
};
struct U32{
u32 value;
template<typename... Args>
U32(Args&&... args): value { forward<Args>(args)... } {}
};
struct U64{
u64 value;
template<typename... Args>
U64(Args&&... args): value { forward<Args>(args)... } {}
};
struct USize{
u64 value;
template<typename... Args>
USize(Args&&... args): value { forward<Args>(args)... } {}
};
struct F32{
f32 value;
template<typename... Args>
F32(Args&&... args): value { forward<Args>(args)... } {}
};
struct F64{
f64 value;
template<typename... Args>
F64(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedNumericConstant : public Variant<CheckedNumericConstant_Details::I8, CheckedNumericConstant_Details::I16, CheckedNumericConstant_Details::I32, CheckedNumericConstant_Details::I64, CheckedNumericConstant_Details::U8, CheckedNumericConstant_Details::U16, CheckedNumericConstant_Details::U32, CheckedNumericConstant_Details::U64, CheckedNumericConstant_Details::USize, CheckedNumericConstant_Details::F32, CheckedNumericConstant_Details::F64> {
using Variant<CheckedNumericConstant_Details::I8, CheckedNumericConstant_Details::I16, CheckedNumericConstant_Details::I32, CheckedNumericConstant_Details::I64, CheckedNumericConstant_Details::U8, CheckedNumericConstant_Details::U16, CheckedNumericConstant_Details::U32, CheckedNumericConstant_Details::U64, CheckedNumericConstant_Details::USize, CheckedNumericConstant_Details::F32, CheckedNumericConstant_Details::F64>::Variant;
    using I8 = CheckedNumericConstant_Details::I8;
    using I16 = CheckedNumericConstant_Details::I16;
    using I32 = CheckedNumericConstant_Details::I32;
    using I64 = CheckedNumericConstant_Details::I64;
    using U8 = CheckedNumericConstant_Details::U8;
    using U16 = CheckedNumericConstant_Details::U16;
    using U32 = CheckedNumericConstant_Details::U32;
    using U64 = CheckedNumericConstant_Details::U64;
    using USize = CheckedNumericConstant_Details::USize;
    using F32 = CheckedNumericConstant_Details::F32;
    using F64 = CheckedNumericConstant_Details::F64;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* I8 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::I8>();
TRY(builder.append("CheckedNumericConstant::I8"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* I16 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::I16>();
TRY(builder.append("CheckedNumericConstant::I16"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* I32 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::I32>();
TRY(builder.append("CheckedNumericConstant::I32"));
TRY(builder.appendff("({})", that.value));
break;}
case 3 /* I64 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::I64>();
TRY(builder.append("CheckedNumericConstant::I64"));
TRY(builder.appendff("({})", that.value));
break;}
case 4 /* U8 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::U8>();
TRY(builder.append("CheckedNumericConstant::U8"));
TRY(builder.appendff("({})", that.value));
break;}
case 5 /* U16 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::U16>();
TRY(builder.append("CheckedNumericConstant::U16"));
TRY(builder.appendff("({})", that.value));
break;}
case 6 /* U32 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::U32>();
TRY(builder.append("CheckedNumericConstant::U32"));
TRY(builder.appendff("({})", that.value));
break;}
case 7 /* U64 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::U64>();
TRY(builder.append("CheckedNumericConstant::U64"));
TRY(builder.appendff("({})", that.value));
break;}
case 8 /* USize */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::USize>();
TRY(builder.append("CheckedNumericConstant::USize"));
TRY(builder.appendff("({})", that.value));
break;}
case 9 /* F32 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::F32>();
TRY(builder.append("CheckedNumericConstant::F32"));
TRY(builder.appendff("({})", that.value));
break;}
case 10 /* F64 */: {
[[maybe_unused]] auto const& that = this->template get<CheckedNumericConstant::F64>();
TRY(builder.append("CheckedNumericConstant::F64"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}Optional<typechecker::NumberConstant> number_constant() const;
};
class CheckedFunction : public RefCounted<CheckedFunction>, public Weakable<CheckedFunction> {
  public:
virtual ~CheckedFunction() = default;
String name;utility::Span name_span;parser::Visibility visibility;typechecker::TypeId return_type_id;Optional<utility::Span> return_type_span;Array<typechecker::CheckedParameter> params;Array<typechecker::FunctionGenericParameter> generic_params;typechecker::CheckedBlock block;bool can_throw;parser::FunctionType type;parser::FunctionLinkage linkage;typechecker::ScopeId function_scope_id;bool is_instantiated;Optional<parser::ParsedFunction> parsed_function;bool is_comptime;bool is_static() const;
bool is_mutating() const;
parser::ParsedFunction to_parsed_function() const;
private:
explicit CheckedFunction(String&& a_name, utility::Span&& a_name_span, parser::Visibility&& a_visibility, typechecker::TypeId&& a_return_type_id, Optional<utility::Span>&& a_return_type_span, Array<typechecker::CheckedParameter>&& a_params, Array<typechecker::FunctionGenericParameter>&& a_generic_params, typechecker::CheckedBlock&& a_block, bool&& a_can_throw, parser::FunctionType&& a_type, parser::FunctionLinkage&& a_linkage, typechecker::ScopeId&& a_function_scope_id, bool&& a_is_instantiated, Optional<parser::ParsedFunction>&& a_parsed_function, bool&& a_is_comptime): name(move(a_name)), name_span(move(a_name_span)), visibility(move(a_visibility)), return_type_id(move(a_return_type_id)), return_type_span(move(a_return_type_span)), params(move(a_params)), generic_params(move(a_generic_params)), block(move(a_block)), can_throw(move(a_can_throw)), type(move(a_type)), linkage(move(a_linkage)), function_scope_id(move(a_function_scope_id)), is_instantiated(move(a_is_instantiated)), parsed_function(move(a_parsed_function)), is_comptime(move(a_is_comptime)){}
public:
static ErrorOr<NonnullRefPtr<CheckedFunction>> create(String name, utility::Span name_span, parser::Visibility visibility, typechecker::TypeId return_type_id, Optional<utility::Span> return_type_span, Array<typechecker::CheckedParameter> params, Array<typechecker::FunctionGenericParameter> generic_params, typechecker::CheckedBlock block, bool can_throw, parser::FunctionType type, parser::FunctionLinkage linkage, typechecker::ScopeId function_scope_id, bool is_instantiated, Optional<parser::ParsedFunction> parsed_function, bool is_comptime) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) CheckedFunction (move(name), move(name_span), move(visibility), move(return_type_id), move(return_type_span), move(params), move(generic_params), move(block), move(can_throw), move(type), move(linkage), move(function_scope_id), move(is_instantiated), move(parsed_function), move(is_comptime)))); return o; }
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedFunction("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}, ", visibility));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_id: "));TRY(builder.appendff("{}, ", return_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type_span: "));TRY(builder.appendff("{}, ", return_type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("params: "));TRY(builder.appendff("{}, ", params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_params: "));TRY(builder.appendff("{}, ", generic_params));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("block: "));TRY(builder.appendff("{}, ", block));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type: "));TRY(builder.appendff("{}, ", type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("linkage: "));TRY(builder.appendff("{}, ", linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("function_scope_id: "));TRY(builder.appendff("{}, ", function_scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_instantiated: "));TRY(builder.appendff("{}, ", is_instantiated));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parsed_function: "));TRY(builder.appendff("{}, ", parsed_function));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_comptime: "));TRY(builder.appendff("{}", is_comptime));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace FunctionGenericParameter_Details {
struct InferenceGuide{
typechecker::TypeId value;
template<typename... Args>
InferenceGuide(Args&&... args): value { forward<Args>(args)... } {}
};
struct Parameter{
typechecker::TypeId value;
template<typename... Args>
Parameter(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct FunctionGenericParameter : public Variant<FunctionGenericParameter_Details::InferenceGuide, FunctionGenericParameter_Details::Parameter> {
using Variant<FunctionGenericParameter_Details::InferenceGuide, FunctionGenericParameter_Details::Parameter>::Variant;
    using InferenceGuide = FunctionGenericParameter_Details::InferenceGuide;
    using Parameter = FunctionGenericParameter_Details::Parameter;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* InferenceGuide */: {
[[maybe_unused]] auto const& that = this->template get<FunctionGenericParameter::InferenceGuide>();
TRY(builder.append("FunctionGenericParameter::InferenceGuide"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Parameter */: {
[[maybe_unused]] auto const& that = this->template get<FunctionGenericParameter::Parameter>();
TRY(builder.append("FunctionGenericParameter::Parameter"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}typechecker::TypeId type_id() const;
};
namespace SafetyMode_Details {
struct Safe {};
struct Unsafe {};
}
struct SafetyMode : public Variant<SafetyMode_Details::Safe, SafetyMode_Details::Unsafe> {
using Variant<SafetyMode_Details::Safe, SafetyMode_Details::Unsafe>::Variant;
    using Safe = SafetyMode_Details::Safe;
    using Unsafe = SafetyMode_Details::Unsafe;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Safe */: {
[[maybe_unused]] auto const& that = this->template get<SafetyMode::Safe>();
TRY(builder.append("SafetyMode::Safe"));
break;}
case 1 /* Unsafe */: {
[[maybe_unused]] auto const& that = this->template get<SafetyMode::Unsafe>();
TRY(builder.append("SafetyMode::Unsafe"));
break;}
}
return builder.to_string();
}};
struct CheckedVarDecl {
  public:
String name;bool is_mutable;utility::Span span;typechecker::TypeId type_id;CheckedVarDecl(String a_name, bool a_is_mutable, utility::Span a_span, typechecker::TypeId a_type_id) :name(a_name), is_mutable(a_is_mutable), span(a_span), type_id(a_type_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedVarDecl("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("span: "));TRY(builder.appendff("{}, ", span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedMatchBody_Details {
struct Expression{
NonnullRefPtr<typechecker::CheckedExpression> value;
template<typename... Args>
Expression(Args&&... args): value { forward<Args>(args)... } {}
};
struct Block{
typechecker::CheckedBlock value;
template<typename... Args>
Block(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedMatchBody : public Variant<CheckedMatchBody_Details::Expression, CheckedMatchBody_Details::Block> {
using Variant<CheckedMatchBody_Details::Expression, CheckedMatchBody_Details::Block>::Variant;
    using Expression = CheckedMatchBody_Details::Expression;
    using Block = CheckedMatchBody_Details::Block;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<CheckedMatchBody::Expression>();
TRY(builder.append("CheckedMatchBody::Expression"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Block */: {
[[maybe_unused]] auto const& that = this->template get<CheckedMatchBody::Block>();
TRY(builder.append("CheckedMatchBody::Block"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}};
namespace CheckedCapture_Details {
struct ByValue {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByValue(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByMutableReference {
String name;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByMutableReference(_MemberT0&& member_0, _MemberT1&& member_1):
name{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
}
struct CheckedCapture : public Variant<CheckedCapture_Details::ByValue, CheckedCapture_Details::ByReference, CheckedCapture_Details::ByMutableReference> {
using Variant<CheckedCapture_Details::ByValue, CheckedCapture_Details::ByReference, CheckedCapture_Details::ByMutableReference>::Variant;
    using ByValue = CheckedCapture_Details::ByValue;
    using ByReference = CheckedCapture_Details::ByReference;
    using ByMutableReference = CheckedCapture_Details::ByMutableReference;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* ByValue */: {
[[maybe_unused]] auto const& that = this->template get<CheckedCapture::ByValue>();
TRY(builder.append("CheckedCapture::ByValue"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* ByReference */: {
[[maybe_unused]] auto const& that = this->template get<CheckedCapture::ByReference>();
TRY(builder.append("CheckedCapture::ByReference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* ByMutableReference */: {
[[maybe_unused]] auto const& that = this->template get<CheckedCapture::ByMutableReference>();
TRY(builder.append("CheckedCapture::ByMutableReference"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}String name() const;
utility::Span span() const;
};
namespace StatementResult_Details {
struct Return{
typechecker::Value value;
template<typename... Args>
Return(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw{
typechecker::Value value;
template<typename... Args>
Throw(Args&&... args): value { forward<Args>(args)... } {}
};
struct Continue {};
struct Break {};
struct JustValue{
typechecker::Value value;
template<typename... Args>
JustValue(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct StatementResult : public Variant<StatementResult_Details::Return, StatementResult_Details::Throw, StatementResult_Details::Continue, StatementResult_Details::Break, StatementResult_Details::JustValue> {
using Variant<StatementResult_Details::Return, StatementResult_Details::Throw, StatementResult_Details::Continue, StatementResult_Details::Break, StatementResult_Details::JustValue>::Variant;
    using Return = StatementResult_Details::Return;
    using Throw = StatementResult_Details::Throw;
    using Continue = StatementResult_Details::Continue;
    using Break = StatementResult_Details::Break;
    using JustValue = StatementResult_Details::JustValue;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Return */: {
[[maybe_unused]] auto const& that = this->template get<StatementResult::Return>();
TRY(builder.append("StatementResult::Return"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Throw */: {
[[maybe_unused]] auto const& that = this->template get<StatementResult::Throw>();
TRY(builder.append("StatementResult::Throw"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* Continue */: {
[[maybe_unused]] auto const& that = this->template get<StatementResult::Continue>();
TRY(builder.append("StatementResult::Continue"));
break;}
case 3 /* Break */: {
[[maybe_unused]] auto const& that = this->template get<StatementResult::Break>();
TRY(builder.append("StatementResult::Break"));
break;}
case 4 /* JustValue */: {
[[maybe_unused]] auto const& that = this->template get<StatementResult::JustValue>();
TRY(builder.append("StatementResult::JustValue"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}};
struct CheckedStruct {
  public:
String name;utility::Span name_span;Array<typechecker::TypeId> generic_parameters;Array<typechecker::VarId> fields;typechecker::ScopeId scope_id;parser::DefinitionLinkage definition_linkage;parser::RecordType record_type;typechecker::TypeId type_id;CheckedStruct(String a_name, utility::Span a_name_span, Array<typechecker::TypeId> a_generic_parameters, Array<typechecker::VarId> a_fields, typechecker::ScopeId a_scope_id, parser::DefinitionLinkage a_definition_linkage, parser::RecordType a_record_type, typechecker::TypeId a_type_id) :name(a_name), name_span(a_name_span), generic_parameters(a_generic_parameters), fields(a_fields), scope_id(a_scope_id), definition_linkage(a_definition_linkage), record_type(a_record_type), type_id(a_type_id){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedStruct("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name_span: "));TRY(builder.appendff("{}, ", name_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("generic_parameters: "));TRY(builder.appendff("{}, ", generic_parameters));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fields: "));TRY(builder.appendff("{}, ", fields));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scope_id: "));TRY(builder.appendff("{}, ", scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_linkage: "));TRY(builder.appendff("{}, ", definition_linkage));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("record_type: "));TRY(builder.appendff("{}, ", record_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}", type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CheckedVariable {
  public:
String name;typechecker::TypeId type_id;bool is_mutable;utility::Span definition_span;Optional<utility::Span> type_span;parser::Visibility visibility;CheckedVariable(String a_name, typechecker::TypeId a_type_id, bool a_is_mutable, utility::Span a_definition_span, Optional<utility::Span> a_type_span, parser::Visibility a_visibility) :name(a_name), type_id(a_type_id), is_mutable(a_is_mutable), definition_span(a_definition_span), type_span(a_type_span), visibility(a_visibility){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedVariable("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_id: "));TRY(builder.appendff("{}, ", type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_mutable: "));TRY(builder.appendff("{}, ", is_mutable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("definition_span: "));TRY(builder.appendff("{}, ", definition_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_span: "));TRY(builder.appendff("{}, ", type_span));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("visibility: "));TRY(builder.appendff("{}", visibility));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace NumberConstant_Details {
struct Signed{
i64 value;
template<typename... Args>
Signed(Args&&... args): value { forward<Args>(args)... } {}
};
struct Unsigned{
u64 value;
template<typename... Args>
Unsigned(Args&&... args): value { forward<Args>(args)... } {}
};
struct Floating{
f64 value;
template<typename... Args>
Floating(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct NumberConstant : public Variant<NumberConstant_Details::Signed, NumberConstant_Details::Unsigned, NumberConstant_Details::Floating> {
using Variant<NumberConstant_Details::Signed, NumberConstant_Details::Unsigned, NumberConstant_Details::Floating>::Variant;
    using Signed = NumberConstant_Details::Signed;
    using Unsigned = NumberConstant_Details::Unsigned;
    using Floating = NumberConstant_Details::Floating;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Signed */: {
[[maybe_unused]] auto const& that = this->template get<NumberConstant::Signed>();
TRY(builder.append("NumberConstant::Signed"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Unsigned */: {
[[maybe_unused]] auto const& that = this->template get<NumberConstant::Unsigned>();
TRY(builder.append("NumberConstant::Unsigned"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* Floating */: {
[[maybe_unused]] auto const& that = this->template get<NumberConstant::Floating>();
TRY(builder.append("NumberConstant::Floating"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}size_t to_usize() const;
bool can_fit_number(const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedProgram> program) const;
};
struct CheckedCall {
  public:
Array<typechecker::ResolvedNamespace> namespace_;String name;Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args;Array<typechecker::TypeId> type_args;Optional<typechecker::FunctionId> function_id;typechecker::TypeId return_type;bool callee_throws;CheckedCall(Array<typechecker::ResolvedNamespace> a_namespace_, String a_name, Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> a_args, Array<typechecker::TypeId> a_type_args, Optional<typechecker::FunctionId> a_function_id, typechecker::TypeId a_return_type, bool a_callee_throws) :namespace_(a_namespace_), name(a_name), args(a_args), type_args(a_type_args), function_id(a_function_id), return_type(a_return_type), callee_throws(a_callee_throws){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedCall("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_: "));TRY(builder.appendff("{}, ", namespace_));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("args: "));TRY(builder.appendff("{}, ", args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("type_args: "));TRY(builder.appendff("{}, ", type_args));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("function_id: "));TRY(builder.appendff("{}, ", function_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("return_type: "));TRY(builder.appendff("{}, ", return_type));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("callee_throws: "));TRY(builder.appendff("{}", callee_throws));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace CheckedExpression_Details {
struct Boolean {
bool val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Boolean(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct NumericConstant {
typechecker::CheckedNumericConstant val;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NumericConstant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct QuotedString {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
QuotedString(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct ByteConstant {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
ByteConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct CharacterConstant {
String val;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
CharacterConstant(_MemberT0&& member_0, _MemberT1&& member_1):
val{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct UnaryOp {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedUnaryOperator op;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
UnaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct BinaryOp {
NonnullRefPtr<typechecker::CheckedExpression> lhs;
parser::BinaryOperator op;
NonnullRefPtr<typechecker::CheckedExpression> rhs;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
BinaryOp(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
lhs{ forward<_MemberT0>(member_0)},
op{ forward<_MemberT1>(member_1)},
rhs{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct JaktTuple {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
JaktTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Range {
NonnullRefPtr<typechecker::CheckedExpression> from;
NonnullRefPtr<typechecker::CheckedExpression> to;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
Range(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
from{ forward<_MemberT0>(member_0)},
to{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct JaktArray {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> repeat;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId inner_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
JaktArray(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
vals{ forward<_MemberT0>(member_0)},
repeat{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)},
inner_type_id{ forward<_MemberT4>(member_4)}
{}
};
struct JaktSet {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId inner_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
JaktSet(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
inner_type_id{ forward<_MemberT3>(member_3)}
{}
};
struct JaktDictionary {
Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> vals;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId key_type_id;
typechecker::TypeId value_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
JaktDictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
vals{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
key_type_id{ forward<_MemberT3>(member_3)},
value_type_id{ forward<_MemberT4>(member_4)}
{}
};
struct IndexedExpression {
NonnullRefPtr<typechecker::CheckedExpression> expr;
NonnullRefPtr<typechecker::CheckedExpression> index;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedRangeExpression {
NonnullRefPtr<typechecker::CheckedExpression> expr;
NonnullRefPtr<typechecker::CheckedExpression> from;
NonnullRefPtr<typechecker::CheckedExpression> to;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
IndexedRangeExpression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
from{ forward<_MemberT1>(member_1)},
to{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct IndexedDictionary {
NonnullRefPtr<typechecker::CheckedExpression> expr;
NonnullRefPtr<typechecker::CheckedExpression> index;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
IndexedDictionary(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)}
{}
};
struct IndexedTuple {
NonnullRefPtr<typechecker::CheckedExpression> expr;
size_t index;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
IndexedTuple(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct IndexedStruct {
NonnullRefPtr<typechecker::CheckedExpression> expr;
String index;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
IndexedStruct(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
index{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct Match {
NonnullRefPtr<typechecker::CheckedExpression> expr;
Array<typechecker::CheckedMatchCase> match_cases;
utility::Span span;
typechecker::TypeId type_id;
bool all_variants_constant;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
Match(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
match_cases{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
type_id{ forward<_MemberT3>(member_3)},
all_variants_constant{ forward<_MemberT4>(member_4)}
{}
};
struct EnumVariantArg {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedEnumVariantBinding arg;
typechecker::CheckedEnumVariant enum_variant;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3>
EnumVariantArg(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3):
expr{ forward<_MemberT0>(member_0)},
arg{ forward<_MemberT1>(member_1)},
enum_variant{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)}
{}
};
struct Call {
typechecker::CheckedCall call;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Call(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
call{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct MethodCall {
NonnullRefPtr<typechecker::CheckedExpression> expr;
typechecker::CheckedCall call;
utility::Span span;
bool is_optional;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
MethodCall(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
expr{ forward<_MemberT0>(member_0)},
call{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)},
is_optional{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)}
{}
};
struct NamespacedVar {
Array<typechecker::CheckedNamespace> namespaces;
typechecker::CheckedVariable var;
utility::Span span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
NamespacedVar(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
namespaces{ forward<_MemberT0>(member_0)},
var{ forward<_MemberT1>(member_1)},
span{ forward<_MemberT2>(member_2)}
{}
};
struct Var {
typechecker::CheckedVariable var;
utility::Span span;
template<typename _MemberT0, typename _MemberT1>
Var(_MemberT0&& member_0, _MemberT1&& member_1):
var{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalNone {
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1>
OptionalNone(_MemberT0&& member_0, _MemberT1&& member_1):
span{ forward<_MemberT0>(member_0)},
type_id{ forward<_MemberT1>(member_1)}
{}
};
struct OptionalSome {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
OptionalSome(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct ForcedUnwrap {
NonnullRefPtr<typechecker::CheckedExpression> expr;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
ForcedUnwrap(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expr{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Block {
typechecker::CheckedBlock block;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Block(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
block{ forward<_MemberT0>(member_0)},
span{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)}
{}
};
struct Function {
Array<typechecker::CheckedCapture> captures;
Array<typechecker::CheckedParameter> params;
bool can_throw;
typechecker::TypeId return_type_id;
typechecker::CheckedBlock block;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
captures{ forward<_MemberT0>(member_0)},
params{ forward<_MemberT1>(member_1)},
can_throw{ forward<_MemberT2>(member_2)},
return_type_id{ forward<_MemberT3>(member_3)},
block{ forward<_MemberT4>(member_4)},
span{ forward<_MemberT5>(member_5)},
type_id{ forward<_MemberT6>(member_6)}
{}
};
struct Try {
NonnullRefPtr<typechecker::CheckedExpression> expr;
Optional<typechecker::CheckedBlock> catch_block;
Optional<String> catch_name;
utility::Span span;
typechecker::TypeId type_id;
typechecker::TypeId inner_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5>
Try(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5):
expr{ forward<_MemberT0>(member_0)},
catch_block{ forward<_MemberT1>(member_1)},
catch_name{ forward<_MemberT2>(member_2)},
span{ forward<_MemberT3>(member_3)},
type_id{ forward<_MemberT4>(member_4)},
inner_type_id{ forward<_MemberT5>(member_5)}
{}
};
struct TryBlock {
NonnullRefPtr<typechecker::CheckedStatement> stmt;
typechecker::CheckedBlock catch_block;
String error_name;
utility::Span error_span;
utility::Span span;
typechecker::TypeId type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5>
TryBlock(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5):
stmt{ forward<_MemberT0>(member_0)},
catch_block{ forward<_MemberT1>(member_1)},
error_name{ forward<_MemberT2>(member_2)},
error_span{ forward<_MemberT3>(member_3)},
span{ forward<_MemberT4>(member_4)},
type_id{ forward<_MemberT5>(member_5)}
{}
};
struct Garbage{
utility::Span value;
template<typename... Args>
Garbage(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct CheckedExpression : public Variant<CheckedExpression_Details::Boolean, CheckedExpression_Details::NumericConstant, CheckedExpression_Details::QuotedString, CheckedExpression_Details::ByteConstant, CheckedExpression_Details::CharacterConstant, CheckedExpression_Details::UnaryOp, CheckedExpression_Details::BinaryOp, CheckedExpression_Details::JaktTuple, CheckedExpression_Details::Range, CheckedExpression_Details::JaktArray, CheckedExpression_Details::JaktSet, CheckedExpression_Details::JaktDictionary, CheckedExpression_Details::IndexedExpression, CheckedExpression_Details::IndexedRangeExpression, CheckedExpression_Details::IndexedDictionary, CheckedExpression_Details::IndexedTuple, CheckedExpression_Details::IndexedStruct, CheckedExpression_Details::Match, CheckedExpression_Details::EnumVariantArg, CheckedExpression_Details::Call, CheckedExpression_Details::MethodCall, CheckedExpression_Details::NamespacedVar, CheckedExpression_Details::Var, CheckedExpression_Details::OptionalNone, CheckedExpression_Details::OptionalSome, CheckedExpression_Details::ForcedUnwrap, CheckedExpression_Details::Block, CheckedExpression_Details::Function, CheckedExpression_Details::Try, CheckedExpression_Details::TryBlock, CheckedExpression_Details::Garbage>, public RefCounted<CheckedExpression> {
using Variant<CheckedExpression_Details::Boolean, CheckedExpression_Details::NumericConstant, CheckedExpression_Details::QuotedString, CheckedExpression_Details::ByteConstant, CheckedExpression_Details::CharacterConstant, CheckedExpression_Details::UnaryOp, CheckedExpression_Details::BinaryOp, CheckedExpression_Details::JaktTuple, CheckedExpression_Details::Range, CheckedExpression_Details::JaktArray, CheckedExpression_Details::JaktSet, CheckedExpression_Details::JaktDictionary, CheckedExpression_Details::IndexedExpression, CheckedExpression_Details::IndexedRangeExpression, CheckedExpression_Details::IndexedDictionary, CheckedExpression_Details::IndexedTuple, CheckedExpression_Details::IndexedStruct, CheckedExpression_Details::Match, CheckedExpression_Details::EnumVariantArg, CheckedExpression_Details::Call, CheckedExpression_Details::MethodCall, CheckedExpression_Details::NamespacedVar, CheckedExpression_Details::Var, CheckedExpression_Details::OptionalNone, CheckedExpression_Details::OptionalSome, CheckedExpression_Details::ForcedUnwrap, CheckedExpression_Details::Block, CheckedExpression_Details::Function, CheckedExpression_Details::Try, CheckedExpression_Details::TryBlock, CheckedExpression_Details::Garbage>::Variant;
    using Boolean = CheckedExpression_Details::Boolean;
    using NumericConstant = CheckedExpression_Details::NumericConstant;
    using QuotedString = CheckedExpression_Details::QuotedString;
    using ByteConstant = CheckedExpression_Details::ByteConstant;
    using CharacterConstant = CheckedExpression_Details::CharacterConstant;
    using UnaryOp = CheckedExpression_Details::UnaryOp;
    using BinaryOp = CheckedExpression_Details::BinaryOp;
    using JaktTuple = CheckedExpression_Details::JaktTuple;
    using Range = CheckedExpression_Details::Range;
    using JaktArray = CheckedExpression_Details::JaktArray;
    using JaktSet = CheckedExpression_Details::JaktSet;
    using JaktDictionary = CheckedExpression_Details::JaktDictionary;
    using IndexedExpression = CheckedExpression_Details::IndexedExpression;
    using IndexedRangeExpression = CheckedExpression_Details::IndexedRangeExpression;
    using IndexedDictionary = CheckedExpression_Details::IndexedDictionary;
    using IndexedTuple = CheckedExpression_Details::IndexedTuple;
    using IndexedStruct = CheckedExpression_Details::IndexedStruct;
    using Match = CheckedExpression_Details::Match;
    using EnumVariantArg = CheckedExpression_Details::EnumVariantArg;
    using Call = CheckedExpression_Details::Call;
    using MethodCall = CheckedExpression_Details::MethodCall;
    using NamespacedVar = CheckedExpression_Details::NamespacedVar;
    using Var = CheckedExpression_Details::Var;
    using OptionalNone = CheckedExpression_Details::OptionalNone;
    using OptionalSome = CheckedExpression_Details::OptionalSome;
    using ForcedUnwrap = CheckedExpression_Details::ForcedUnwrap;
    using Block = CheckedExpression_Details::Block;
    using Function = CheckedExpression_Details::Function;
    using Try = CheckedExpression_Details::Try;
    using TryBlock = CheckedExpression_Details::TryBlock;
    using Garbage = CheckedExpression_Details::Garbage;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) CheckedExpression(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Boolean */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Boolean>();
TRY(builder.append("CheckedExpression::Boolean"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: {}", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* NumericConstant */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::NumericConstant>();
TRY(builder.append("CheckedExpression::NumericConstant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: {}", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* QuotedString */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::QuotedString>();
TRY(builder.append("CheckedExpression::QuotedString"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 3 /* ByteConstant */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::ByteConstant>();
TRY(builder.append("CheckedExpression::ByteConstant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 4 /* CharacterConstant */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::CharacterConstant>();
TRY(builder.append("CheckedExpression::CharacterConstant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("val: \"{}\"", that.val));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 5 /* UnaryOp */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::UnaryOp>();
TRY(builder.append("CheckedExpression::UnaryOp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("op: {}", that.op));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 6 /* BinaryOp */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::BinaryOp>();
TRY(builder.append("CheckedExpression::BinaryOp"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("lhs: {}", that.lhs));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("op: {}", that.op));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("rhs: {}", that.rhs));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 7 /* JaktTuple */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::JaktTuple>();
TRY(builder.append("CheckedExpression::JaktTuple"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vals: {}", that.vals));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 8 /* Range */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Range>();
TRY(builder.append("CheckedExpression::Range"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("from: {}", that.from));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("to: {}", that.to));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 9 /* JaktArray */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::JaktArray>();
TRY(builder.append("CheckedExpression::JaktArray"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vals: {}", that.vals));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("repeat: {}", that.repeat));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner_type_id: {}", that.inner_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 10 /* JaktSet */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::JaktSet>();
TRY(builder.append("CheckedExpression::JaktSet"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vals: {}", that.vals));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner_type_id: {}", that.inner_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 11 /* JaktDictionary */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::JaktDictionary>();
TRY(builder.append("CheckedExpression::JaktDictionary"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("vals: {}", that.vals));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("key_type_id: {}", that.key_type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("value_type_id: {}", that.value_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 12 /* IndexedExpression */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::IndexedExpression>();
TRY(builder.append("CheckedExpression::IndexedExpression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 13 /* IndexedRangeExpression */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::IndexedRangeExpression>();
TRY(builder.append("CheckedExpression::IndexedRangeExpression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("from: {}", that.from));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("to: {}", that.to));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 14 /* IndexedDictionary */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::IndexedDictionary>();
TRY(builder.append("CheckedExpression::IndexedDictionary"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 15 /* IndexedTuple */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::IndexedTuple>();
TRY(builder.append("CheckedExpression::IndexedTuple"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 16 /* IndexedStruct */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::IndexedStruct>();
TRY(builder.append("CheckedExpression::IndexedStruct"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: \"{}\"", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 17 /* Match */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Match>();
TRY(builder.append("CheckedExpression::Match"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("match_cases: {}", that.match_cases));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("all_variants_constant: {}", that.all_variants_constant));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 18 /* EnumVariantArg */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::EnumVariantArg>();
TRY(builder.append("CheckedExpression::EnumVariantArg"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("arg: {}", that.arg));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("enum_variant: {}", that.enum_variant));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 19 /* Call */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Call>();
TRY(builder.append("CheckedExpression::Call"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("call: {}", that.call));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 20 /* MethodCall */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::MethodCall>();
TRY(builder.append("CheckedExpression::MethodCall"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("call: {}", that.call));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("is_optional: {}", that.is_optional));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 21 /* NamespacedVar */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::NamespacedVar>();
TRY(builder.append("CheckedExpression::NamespacedVar"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("namespaces: {}", that.namespaces));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var: {}", that.var));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 22 /* Var */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Var>();
TRY(builder.append("CheckedExpression::Var"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var: {}", that.var));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 23 /* OptionalNone */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::OptionalNone>();
TRY(builder.append("CheckedExpression::OptionalNone"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 24 /* OptionalSome */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::OptionalSome>();
TRY(builder.append("CheckedExpression::OptionalSome"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 25 /* ForcedUnwrap */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::ForcedUnwrap>();
TRY(builder.append("CheckedExpression::ForcedUnwrap"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 26 /* Block */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Block>();
TRY(builder.append("CheckedExpression::Block"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 27 /* Function */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Function>();
TRY(builder.append("CheckedExpression::Function"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("captures: {}", that.captures));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("params: {}", that.params));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("can_throw: {}", that.can_throw));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("return_type_id: {}", that.return_type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("block: {}", that.block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 28 /* Try */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Try>();
TRY(builder.append("CheckedExpression::Try"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expr: {}", that.expr));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_block: {}", that.catch_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_name: {}", that.catch_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("inner_type_id: {}", that.inner_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 29 /* TryBlock */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::TryBlock>();
TRY(builder.append("CheckedExpression::TryBlock"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("stmt: {}", that.stmt));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("catch_block: {}", that.catch_block));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("error_name: \"{}\"", that.error_name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("error_span: {}", that.error_span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 30 /* Garbage */: {
[[maybe_unused]] auto const& that = this->template get<CheckedExpression::Garbage>();
TRY(builder.append("CheckedExpression::Garbage"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}Optional<typechecker::NumberConstant> to_number_constant(const NonnullRefPtr<typechecker::CheckedProgram> program) const;
};
enum class BuiltinType: size_t {
Void = (infallible_integer_cast<size_t>((static_cast<i64>(0LL)))),
Bool = (infallible_integer_cast<size_t>((static_cast<i64>(1LL)))),
U8 = (infallible_integer_cast<size_t>((static_cast<i64>(2LL)))),
U16 = (infallible_integer_cast<size_t>((static_cast<i64>(3LL)))),
U32 = (infallible_integer_cast<size_t>((static_cast<i64>(4LL)))),
U64 = (infallible_integer_cast<size_t>((static_cast<i64>(5LL)))),
I8 = (infallible_integer_cast<size_t>((static_cast<i64>(6LL)))),
I16 = (infallible_integer_cast<size_t>((static_cast<i64>(7LL)))),
I32 = (infallible_integer_cast<size_t>((static_cast<i64>(8LL)))),
I64 = (infallible_integer_cast<size_t>((static_cast<i64>(9LL)))),
F32 = (infallible_integer_cast<size_t>((static_cast<i64>(10LL)))),
F64 = (infallible_integer_cast<size_t>((static_cast<i64>(11LL)))),
Usize = (infallible_integer_cast<size_t>((static_cast<i64>(12LL)))),
String = (infallible_integer_cast<size_t>((static_cast<i64>(13LL)))),
CChar = (infallible_integer_cast<size_t>((static_cast<i64>(14LL)))),
CInt = (infallible_integer_cast<size_t>((static_cast<i64>(15LL)))),
Unknown = (infallible_integer_cast<size_t>((static_cast<i64>(16LL)))),
Never = (infallible_integer_cast<size_t>((static_cast<i64>(17LL)))),
};
class CheckedProgram : public RefCounted<CheckedProgram>, public Weakable<CheckedProgram> {
  public:
virtual ~CheckedProgram() = default;
NonnullRefPtr<compiler::Compiler> compiler;Array<NonnullRefPtr<typechecker::Module>> modules;Dictionary<String,typechecker::LoadedModule> loaded_modules;bool is_floating(const typechecker::TypeId type_id) const;
typechecker::ScopeId prelude_scope_id() const;
ErrorOr<Optional<typechecker::StructId>> find_struct_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> set_loaded_module(const String module_name, const typechecker::LoadedModule loaded_module);
bool is_integer(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Module> get_module(const typechecker::ModuleId id) const;
bool is_numeric(const typechecker::TypeId type_id) const;
bool is_string(const typechecker::TypeId type_id) const;
typechecker::CheckedVariable get_variable(const typechecker::VarId id) const;
private:
explicit CheckedProgram(NonnullRefPtr<compiler::Compiler>&& a_compiler, Array<NonnullRefPtr<typechecker::Module>>&& a_modules, Dictionary<String,typechecker::LoadedModule>&& a_loaded_modules): compiler(move(a_compiler)), modules(move(a_modules)), loaded_modules(move(a_loaded_modules)){}
public:
static ErrorOr<NonnullRefPtr<CheckedProgram>> create(NonnullRefPtr<compiler::Compiler> compiler, Array<NonnullRefPtr<typechecker::Module>> modules, Dictionary<String,typechecker::LoadedModule> loaded_modules) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) CheckedProgram (move(compiler), move(modules), move(loaded_modules)))); return o; }
NonnullRefPtr<typechecker::CheckedFunction> get_function(const typechecker::FunctionId id) const;
i64 get_bits(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Type> get_type(const typechecker::TypeId id) const;
ErrorOr<typechecker::StructId> find_struct_in_prelude(const String name) const;
typechecker::CheckedEnum get_enum(const typechecker::EnumId id) const;
ErrorOr<String> type_name(const typechecker::TypeId type_id) const;
ErrorOr<Optional<typechecker::CheckedVariable>> find_var_in_scope(const typechecker::ScopeId scope_id, const String var) const;
typechecker::CheckedStruct get_struct(const typechecker::StructId id) const;
ErrorOr<Optional<typechecker::StructId>> check_and_extract_weak_ptr(const typechecker::StructId struct_id, const Array<typechecker::TypeId> args) const;
ErrorOr<Optional<typechecker::EnumId>> find_enum_in_scope(const typechecker::ScopeId scope_id, const String name) const;
Optional<typechecker::LoadedModule> get_loaded_module(const String module_name) const;
bool is_signed(const typechecker::TypeId type_id) const;
ErrorOr<NonnullRefPtr<typechecker::Scope>> get_scope(const typechecker::ScopeId id) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedProgram("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("modules: "));TRY(builder.appendff("{}, ", modules));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("loaded_modules: "));TRY(builder.appendff("{}", loaded_modules));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Interpreter {
  public:
NonnullRefPtr<compiler::Compiler> compiler;NonnullRefPtr<typechecker::CheckedProgram> program;Array<utility::Span> spans;ErrorOr<typechecker::StatementResult> execute_expression(const NonnullRefPtr<typechecker::CheckedExpression> expr, const NonnullRefPtr<typechecker::InterpreterScope> scope);
Interpreter(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<typechecker::CheckedProgram> a_program, Array<utility::Span> a_spans) :compiler(a_compiler), program(a_program), spans(a_spans){}

ErrorOr<typechecker::TypeId> find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type);
void leave_span();
ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<typechecker::StatementResult> call_prelude_function(const String prelude_function, const Array<typechecker::ResolvedNamespace> namespace_, const Optional<typechecker::Value> this_argument, const Array<typechecker::Value> arguments, const utility::Span call_span);
ErrorOr<typechecker::StatementResult> execute_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement, NonnullRefPtr<typechecker::InterpreterScope> scope, const utility::Span call_span);
ErrorOr<void> error_with_hint(const String message, const utility::Span span, const String hint_message, const utility::Span hint_span);
ErrorOr<typechecker::ExecutionResult> execute(const typechecker::FunctionId function_to_run_id, Optional<Array<typechecker::ResolvedNamespace>> namespace_, const Optional<typechecker::Value> this_argument, const Array<typechecker::Value> arguments, const utility::Span call_span);
ErrorOr<void> enter_span(const utility::Span span);
ErrorOr<typechecker::StatementResult> execute_block(const typechecker::CheckedBlock block, NonnullRefPtr<typechecker::InterpreterScope> scope, const utility::Span call_span);
ErrorOr<bool> get_prelude_function(const typechecker::ScopeId scope_id) const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Interpreter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("program: "));TRY(builder.appendff("{}, ", *program));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("spans: "));TRY(builder.appendff("{}", spans));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class Scope : public RefCounted<Scope>, public Weakable<Scope> {
  public:
virtual ~Scope() = default;
Optional<String> namespace_name;Dictionary<String,typechecker::VarId> vars;Dictionary<String,typechecker::StructId> structs;Dictionary<String,typechecker::FunctionId> functions;Dictionary<String,typechecker::EnumId> enums;Dictionary<String,typechecker::TypeId> types;Dictionary<String,typechecker::ModuleId> imports;Optional<typechecker::ScopeId> parent;Array<typechecker::ScopeId> children;bool can_throw;Optional<String> import_path_if_extern;String debug_name;private:
explicit Scope(Optional<String>&& a_namespace_name, Dictionary<String,typechecker::VarId>&& a_vars, Dictionary<String,typechecker::StructId>&& a_structs, Dictionary<String,typechecker::FunctionId>&& a_functions, Dictionary<String,typechecker::EnumId>&& a_enums, Dictionary<String,typechecker::TypeId>&& a_types, Dictionary<String,typechecker::ModuleId>&& a_imports, Optional<typechecker::ScopeId>&& a_parent, Array<typechecker::ScopeId>&& a_children, bool&& a_can_throw, Optional<String>&& a_import_path_if_extern, String&& a_debug_name): namespace_name(move(a_namespace_name)), vars(move(a_vars)), structs(move(a_structs)), functions(move(a_functions)), enums(move(a_enums)), types(move(a_types)), imports(move(a_imports)), parent(move(a_parent)), children(move(a_children)), can_throw(move(a_can_throw)), import_path_if_extern(move(a_import_path_if_extern)), debug_name(move(a_debug_name)){}
public:
static ErrorOr<NonnullRefPtr<Scope>> create(Optional<String> namespace_name, Dictionary<String,typechecker::VarId> vars, Dictionary<String,typechecker::StructId> structs, Dictionary<String,typechecker::FunctionId> functions, Dictionary<String,typechecker::EnumId> enums, Dictionary<String,typechecker::TypeId> types, Dictionary<String,typechecker::ModuleId> imports, Optional<typechecker::ScopeId> parent, Array<typechecker::ScopeId> children, bool can_throw, Optional<String> import_path_if_extern, String debug_name) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Scope (move(namespace_name), move(vars), move(structs), move(functions), move(enums), move(types), move(imports), move(parent), move(children), move(can_throw), move(import_path_if_extern), move(debug_name)))); return o; }
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Scope("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_name: "));TRY(builder.appendff("{}, ", namespace_name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("vars: "));TRY(builder.appendff("{}, ", vars));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("structs: "));TRY(builder.appendff("{}, ", structs));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enums: "));TRY(builder.appendff("{}, ", enums));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("types: "));TRY(builder.appendff("{}, ", types));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("imports: "));TRY(builder.appendff("{}, ", imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parent: "));TRY(builder.appendff("{}, ", parent));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("children: "));TRY(builder.appendff("{}, ", children));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("can_throw: "));TRY(builder.appendff("{}, ", can_throw));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("import_path_if_extern: "));TRY(builder.appendff("{}, ", import_path_if_extern));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_name: "));TRY(builder.appendff("\"{}\"", debug_name));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct Typechecker {
  public:
NonnullRefPtr<compiler::Compiler> compiler;NonnullRefPtr<typechecker::CheckedProgram> program;typechecker::ModuleId current_module_id;Optional<typechecker::TypeId> current_struct_type_id;Optional<typechecker::FunctionId> current_function_id;bool inside_defer;size_t checkidx;bool ignore_errors;bool dump_type_hints;bool dump_try_hints;u64 lambda_count;bool is_floating(const typechecker::TypeId type_id) const;
ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>> typecheck_match_body(const parser::ParsedMatchBody body, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, Dictionary<String,String>& generic_inferences, const Optional<typechecker::TypeId> final_result_type, const utility::Span span);
ErrorOr<void> typecheck_namespace_predecl(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_set(const Array<NonnullRefPtr<parser::ParsedExpression>> values, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
bool is_integer(const typechecker::TypeId type_id) const;
ErrorOr<void> dump_try_hint(const utility::Span span) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_call(const parser::ParsedCall call, const typechecker::ScopeId caller_scope_id, const utility::Span span, const Optional<NonnullRefPtr<typechecker::CheckedExpression>> this_expr, const Optional<typechecker::StructOrEnumId> parent_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const bool must_be_enum_constructor);
ErrorOr<bool> add_type_to_scope(const typechecker::ScopeId scope_id, const String type_name, const typechecker::TypeId type_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_namespaced_var_or_simple_enum_constructor_call(const String name, const Array<String> namespace_, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const utility::Span span);
ErrorOr<String> type_name(const typechecker::TypeId type_id) const;
NonnullRefPtr<typechecker::Module> current_module() const;
ErrorOr<void> error_with_hint(const String message, const utility::Span span, const String hint, const utility::Span hint_span);
ErrorOr<Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>>> find_type_scope(const typechecker::ScopeId scope_id, const String name) const;
static ErrorOr<Array<u8>> get_prelude_contents();
ErrorOr<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>,typechecker::TypeId>> typecheck_range(const NonnullRefPtr<parser::ParsedExpression> from, const NonnullRefPtr<parser::ParsedExpression> to, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<typechecker::TypeId> find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type);
ErrorOr<Optional<Tuple<typechecker::ScopeId,bool>>> find_namespace_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<typechecker::TypeId> typecheck_typename(const NonnullRefPtr<parser::ParsedType> parsed_type, const typechecker::ScopeId scope_id, const Optional<String> name);
ErrorOr<void> typecheck_enum_predecl(const parser::ParsedRecord parsed_record, const typechecker::EnumId enum_id, const typechecker::ScopeId scope_id);
ErrorOr<Optional<typechecker::CheckedEnumVariant>> get_enum_variant(const typechecker::CheckedEnum enum_, const String variant_name);
typechecker::ScopeId root_scope_id() const;
ErrorOr<Optional<typechecker::FunctionId>> find_function_in_scope(const typechecker::ScopeId parent_scope_id, const String function_name) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_loop(const parser::ParsedBlock parsed_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_defer(const NonnullRefPtr<parser::ParsedStatement> statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> error(const String message, const utility::Span span);
ErrorOr<void> typecheck_module(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_namespace_declarations(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<typechecker::TypeId> substitute_typevars_in_type(const typechecker::TypeId type_id, const Dictionary<String,String> generic_inferences);
ErrorOr<typechecker::StructId> find_struct_in_prelude(const String name) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> cast_to_underlying(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const NonnullRefPtr<parser::ParsedType> parsed_type);
ErrorOr<void> typecheck_module_import(const parser::ParsedModuleImport import_, const typechecker::ScopeId scope_id);
ErrorOr<typechecker::TypeId> typecheck_binary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs, const parser::BinaryOperator op, const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs, const typechecker::ScopeId scope_id, const utility::Span span);
ErrorOr<Optional<typechecker::StructId>> find_struct_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> check_method_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee, const NonnullRefPtr<typechecker::CheckedFunction> method, const utility::Span span);
ErrorOr<typechecker::CheckedBlock> typecheck_block(const parser::ParsedBlock parsed_block, const typechecker::ScopeId parent_scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<Optional<typechecker::TypeId>> find_type_in_scope(const typechecker::ScopeId scope_id, const String name) const;
ErrorOr<void> typecheck_function(const parser::ParsedFunction parsed_function, const typechecker::ScopeId parent_scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_inline_cpp(const parser::ParsedBlock block, const utility::Span span, const typechecker::SafetyMode safety_mode);
ErrorOr<void> check_restricted_access(const typechecker::ScopeId accessor, const String accessee_kind, const typechecker::ScopeId accessee, const String name, const Array<NonnullRefPtr<parser::ParsedType>> whitelist, const utility::Span span);
ErrorOr<void> include_prelude();
ErrorOr<bool> add_function_to_scope(const typechecker::ScopeId parent_scope_id, const String name, const typechecker::FunctionId function_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_while(const NonnullRefPtr<parser::ParsedExpression> condition, const parser::ParsedBlock block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_expression_and_dereference_if_needed(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint, const utility::Span span);
ErrorOr<NonnullRefPtr<utility::FilePath>> get_root_path() const;
ErrorOr<bool> scope_can_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee) const;
ErrorOr<void> typecheck_struct_fields(const parser::ParsedRecord record, const typechecker::StructId struct_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_expression(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<void> dump_type_hint(const typechecker::TypeId type_id, const utility::Span span) const;
ErrorOr<void> typecheck_namespace_imports(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_block_statement(const parser::ParsedBlock parsed_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
typechecker::CheckedStruct get_struct(const typechecker::StructId id) const;
ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>> expand_context_for_bindings(const NonnullRefPtr<parser::ParsedExpression> condition, const Optional<NonnullRefPtr<parser::ParsedExpression>> acc, const parser::ParsedBlock then_block, const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement, const utility::Span span);
ErrorOr<Optional<typechecker::TypeId>> unify(const typechecker::TypeId lhs, const utility::Span lhs_span, const typechecker::TypeId rhs, const utility::Span rhs_span);
ErrorOr<typechecker::TypeId> find_type_in_prelude(const String name) const;
bool is_numeric(const typechecker::TypeId type_id) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_array(const typechecker::ScopeId scope_id, const Array<NonnullRefPtr<parser::ParsedExpression>> values, const Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size, const utility::Span span, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<bool> add_var_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::VarId var_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::Scope>> get_scope(const typechecker::ScopeId id) const;
ErrorOr<bool> check_types_for_compat(const typechecker::TypeId lhs_type_id, const typechecker::TypeId rhs_type_id, Dictionary<String,String>& generic_inferences, const utility::Span span);
ErrorOr<Optional<typechecker::CheckedVariable>> find_var_in_scope(const typechecker::ScopeId scope_id, const String var) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_generic_arguments_method_call(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr, const parser::ParsedCall call, const typechecker::ScopeId scope_id, const utility::Span span, const bool is_optional, const typechecker::SafetyMode safety_mode);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_lambda(const Array<parser::ParsedCapture> captures, const Array<parser::ParsedParameter> params, const bool can_throw, const NonnullRefPtr<parser::ParsedType> return_type, const parser::ParsedBlock block, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_try(const NonnullRefPtr<parser::ParsedExpression> expr, const Optional<parser::ParsedBlock> catch_block, const Optional<String> catch_name, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span, const Optional<typechecker::TypeId> type_hint);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_return(const Optional<NonnullRefPtr<parser::ParsedExpression>> expr, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<void> check_that_type_doesnt_contain_reference(const typechecker::TypeId type_id, const utility::Span span);
ErrorOr<void> typecheck_namespace_fields(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_and_specialize_generic_function(const typechecker::FunctionId function_id, const Array<typechecker::TypeId> generic_arguments, const typechecker::ScopeId parent_scope_id, const Optional<typechecker::TypeId> this_type_id, const Dictionary<String,String> generic_substitutions);
ErrorOr<Optional<parser::ParsedNamespace>> lex_and_parse_file_contents(const utility::FileId file_id);
ErrorOr<Optional<NonnullRefPtr<typechecker::CheckedExpression>>> try_to_promote_constant_expr_to_type(const typechecker::TypeId lhs_type, const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_unary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr, const typechecker::CheckedUnaryOperator checked_op, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<typechecker::TypeId> resolve_type_var(const typechecker::TypeId type_var_type_id, const typechecker::ScopeId scope_id) const;
NonnullRefPtr<typechecker::CheckedFunction> get_function(const typechecker::FunctionId id) const;
ErrorOr<void> typecheck_struct_predecl(const parser::ParsedRecord parsed_record, const typechecker::StructId struct_id, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_enum_predecl_initial(const parser::ParsedRecord parsed_record, const size_t enum_index, const size_t module_enum_len, const typechecker::ScopeId scope_id);
NonnullRefPtr<typechecker::Type> get_type(const typechecker::TypeId id) const;
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_guard(const NonnullRefPtr<parser::ParsedExpression> expr, const parser::ParsedBlock else_block, const parser::ParsedBlock remaining_code, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> typecheck_extern_import(const parser::ParsedExternImport import_, const typechecker::ScopeId scope_id);
ErrorOr<void> check_member_access(const typechecker::ScopeId accessor, const typechecker::ScopeId accessee, const typechecker::CheckedVariable member, const utility::Span span);
ErrorOr<void> typecheck_method(const parser::ParsedFunction func, const typechecker::StructOrEnumId parent_id);
bool expression_is_mutable(const NonnullRefPtr<typechecker::CheckedExpression> expr) const;
ErrorOr<bool> add_struct_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::StructId struct_id, const utility::Span span);
Typechecker(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<typechecker::CheckedProgram> a_program, typechecker::ModuleId a_current_module_id, Optional<typechecker::TypeId> a_current_struct_type_id, Optional<typechecker::FunctionId> a_current_function_id, bool a_inside_defer, size_t a_checkidx, bool a_ignore_errors, bool a_dump_type_hints, bool a_dump_try_hints, u64 a_lambda_count) :compiler(a_compiler), program(a_program), current_module_id(a_current_module_id), current_struct_type_id(a_current_struct_type_id), current_function_id(a_current_function_id), inside_defer(a_inside_defer), checkidx(a_checkidx), ignore_errors(a_ignore_errors), dump_type_hints(a_dump_type_hints), dump_try_hints(a_dump_try_hints), lambda_count(a_lambda_count){}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_unary_negate(const NonnullRefPtr<typechecker::CheckedExpression> expr, const utility::Span span, const typechecker::TypeId type_id);
ErrorOr<Optional<typechecker::FunctionId>> resolve_call(const parser::ParsedCall call, Array<typechecker::ResolvedNamespace> namespaces, const utility::Span span, const typechecker::ScopeId scope_id, const bool must_be_enum_constructor);
static ErrorOr<NonnullRefPtr<typechecker::CheckedProgram>> typecheck(NonnullRefPtr<compiler::Compiler> compiler, const parser::ParsedNamespace parsed_namespace);
ErrorOr<bool> add_enum_to_scope(const typechecker::ScopeId scope_id, const String name, const typechecker::EnumId enum_id, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_dictionary(const Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const Optional<typechecker::TypeId> type_hint);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_if(const NonnullRefPtr<parser::ParsedExpression> condition, const parser::ParsedBlock then_block, const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<typechecker::TypeId> unify_with_type(const typechecker::TypeId found_type, const Optional<typechecker::TypeId> expected_type, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_throw(const NonnullRefPtr<parser::ParsedExpression> expr, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_destructuring_assignment(const Array<parser::ParsedVarDecl> vars, const NonnullRefPtr<parser::ParsedStatement> var_decl, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
typechecker::ScopeId prelude_scope_id() const;
typechecker::BlockControlFlow statement_control_flow(const NonnullRefPtr<typechecker::CheckedStatement> statement) const;
ErrorOr<typechecker::ScopeId> create_scope(const Optional<typechecker::ScopeId> parent_scope_id, const bool can_throw, const String debug_name);
ErrorOr<bool> validate_argument_label(const typechecker::CheckedParameter param, const String label, const utility::Span span, const NonnullRefPtr<parser::ParsedExpression> expr, const Optional<NonnullRefPtr<typechecker::CheckedExpression>> default_value);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_indexed_struct(const NonnullRefPtr<parser::ParsedExpression> expr, const String field, const typechecker::ScopeId scope_id, const bool is_optional, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> typecheck_function_predecl(const parser::ParsedFunction parsed_function, const typechecker::ScopeId parent_scope_id, const Optional<typechecker::TypeId> this_arg_type_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_try_block(const NonnullRefPtr<parser::ParsedStatement> stmt, const String error_name, const utility::Span error_span, const parser::ParsedBlock catch_block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<typechecker::CheckedUnaryOperator> typecheck_is_enum_variant(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr, const NonnullRefPtr<parser::ParsedType> inner, const Array<parser::EnumVariantPatternArgument> bindings, const typechecker::ScopeId scope_id);
typechecker::CheckedVariable get_variable(const typechecker::VarId id) const;
ErrorOr<typechecker::ModuleId> create_module(const String name, const bool is_root);
typechecker::TypeId infer_function_return_type(const typechecker::CheckedBlock block) const;
ErrorOr<typechecker::TypeId> substitute_typevars_in_type_helper(const typechecker::TypeId type_id, const Dictionary<String,String> generic_inferences);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_statement(const NonnullRefPtr<parser::ParsedStatement> statement, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>>> resolve_default_params(const Array<typechecker::CheckedParameter> params, const Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> args, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const size_t arg_offset, const utility::Span span);
typechecker::CheckedEnum get_enum(const typechecker::EnumId id) const;
ErrorOr<void> typecheck_namespace_function_predecl(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<void> typecheck_enum_constructor(const parser::ParsedRecord record, const typechecker::EnumId enum_id, const typechecker::ScopeId parent_scope_id);
ErrorOr<void> typecheck_struct_constructor(const parser::ParsedRecord parsed_record, const typechecker::StructId struct_id, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_var_decl(const parser::ParsedVarDecl var, const NonnullRefPtr<parser::ParsedExpression> init, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<Optional<Array<typechecker::CheckedEnumVariantBinding>>> typecheck_enum_variant_bindings(const typechecker::CheckedEnumVariant variant, const Array<parser::EnumVariantPatternArgument> bindings, const utility::Span span);
ErrorOr<void> typecheck_enum(const parser::ParsedRecord record, const typechecker::EnumId enum_id, const typechecker::ScopeId parent_scope_id);
ErrorOr<typechecker::CheckedParameter> typecheck_parameter(const parser::ParsedParameter parameter, const typechecker::ScopeId scope_id, const bool first, const Optional<typechecker::TypeId> this_arg_type_id, const Optional<typechecker::ScopeId> check_scope);
ErrorOr<void> typecheck_struct(const parser::ParsedRecord record, const typechecker::StructId struct_id, const typechecker::ScopeId parent_scope_id);
ErrorOr<void> typecheck_struct_predecl_initial(const parser::ParsedRecord parsed_record, const size_t struct_index, const size_t module_struct_len, const typechecker::ScopeId scope_id);
ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typecheck_match(const NonnullRefPtr<parser::ParsedExpression> expr, const Array<parser::ParsedMatchCase> cases, const utility::Span span, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode);
ErrorOr<typechecker::TypeId> typecheck_generic_resolved_type(const String name, const Array<typechecker::TypeId> checked_inner_types, const typechecker::ScopeId scope_id, const utility::Span span);
typechecker::BlockControlFlow maybe_statement_control_flow(const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement, const typechecker::BlockControlFlow other_branch) const;
ErrorOr<void> typecheck_jakt_main(const parser::ParsedFunction parsed_function);
ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typecheck_for(const String iterator_name, const utility::Span name_span, const NonnullRefPtr<parser::ParsedExpression> range, const parser::ParsedBlock block, const typechecker::ScopeId scope_id, const typechecker::SafetyMode safety_mode, const utility::Span span);
ErrorOr<void> typecheck_namespace_constructors(const parser::ParsedNamespace parsed_namespace, const typechecker::ScopeId scope_id);
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Typechecker("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("program: "));TRY(builder.appendff("{}, ", *program));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_module_id: "));TRY(builder.appendff("{}, ", current_module_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_struct_type_id: "));TRY(builder.appendff("{}, ", current_struct_type_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_function_id: "));TRY(builder.appendff("{}, ", current_function_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("inside_defer: "));TRY(builder.appendff("{}, ", inside_defer));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("checkidx: "));TRY(builder.appendff("{}, ", checkidx));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("ignore_errors: "));TRY(builder.appendff("{}, ", ignore_errors));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_type_hints: "));TRY(builder.appendff("{}, ", dump_type_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("dump_try_hints: "));TRY(builder.appendff("{}, ", dump_try_hints));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("lambda_count: "));TRY(builder.appendff("{}", lambda_count));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace Type_Details {
struct Void {};
struct Bool {};
struct U8 {};
struct U16 {};
struct U32 {};
struct U64 {};
struct I8 {};
struct I16 {};
struct I32 {};
struct I64 {};
struct F32 {};
struct F64 {};
struct Usize {};
struct JaktString {};
struct CChar {};
struct CInt {};
struct Unknown {};
struct Never {};
struct TypeVariable{
String value;
template<typename... Args>
TypeVariable(Args&&... args): value { forward<Args>(args)... } {}
};
struct GenericInstance {
typechecker::StructId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericInstance(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct GenericEnumInstance {
typechecker::EnumId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericEnumInstance(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct GenericResolvedType {
typechecker::StructId id;
Array<typechecker::TypeId> args;
template<typename _MemberT0, typename _MemberT1>
GenericResolvedType(_MemberT0&& member_0, _MemberT1&& member_1):
id{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)}
{}
};
struct Struct{
typechecker::StructId value;
template<typename... Args>
Struct(Args&&... args): value { forward<Args>(args)... } {}
};
struct Enum{
typechecker::EnumId value;
template<typename... Args>
Enum(Args&&... args): value { forward<Args>(args)... } {}
};
struct RawPtr{
typechecker::TypeId value;
template<typename... Args>
RawPtr(Args&&... args): value { forward<Args>(args)... } {}
};
struct Reference{
typechecker::TypeId value;
template<typename... Args>
Reference(Args&&... args): value { forward<Args>(args)... } {}
};
struct MutableReference{
typechecker::TypeId value;
template<typename... Args>
MutableReference(Args&&... args): value { forward<Args>(args)... } {}
};
struct Function {
Array<typechecker::TypeId> params;
bool can_throw;
typechecker::TypeId return_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Function(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
params{ forward<_MemberT0>(member_0)},
can_throw{ forward<_MemberT1>(member_1)},
return_type_id{ forward<_MemberT2>(member_2)}
{}
};
}
struct Type : public Variant<Type_Details::Void, Type_Details::Bool, Type_Details::U8, Type_Details::U16, Type_Details::U32, Type_Details::U64, Type_Details::I8, Type_Details::I16, Type_Details::I32, Type_Details::I64, Type_Details::F32, Type_Details::F64, Type_Details::Usize, Type_Details::JaktString, Type_Details::CChar, Type_Details::CInt, Type_Details::Unknown, Type_Details::Never, Type_Details::TypeVariable, Type_Details::GenericInstance, Type_Details::GenericEnumInstance, Type_Details::GenericResolvedType, Type_Details::Struct, Type_Details::Enum, Type_Details::RawPtr, Type_Details::Reference, Type_Details::MutableReference, Type_Details::Function>, public RefCounted<Type> {
using Variant<Type_Details::Void, Type_Details::Bool, Type_Details::U8, Type_Details::U16, Type_Details::U32, Type_Details::U64, Type_Details::I8, Type_Details::I16, Type_Details::I32, Type_Details::I64, Type_Details::F32, Type_Details::F64, Type_Details::Usize, Type_Details::JaktString, Type_Details::CChar, Type_Details::CInt, Type_Details::Unknown, Type_Details::Never, Type_Details::TypeVariable, Type_Details::GenericInstance, Type_Details::GenericEnumInstance, Type_Details::GenericResolvedType, Type_Details::Struct, Type_Details::Enum, Type_Details::RawPtr, Type_Details::Reference, Type_Details::MutableReference, Type_Details::Function>::Variant;
    using Void = Type_Details::Void;
    using Bool = Type_Details::Bool;
    using U8 = Type_Details::U8;
    using U16 = Type_Details::U16;
    using U32 = Type_Details::U32;
    using U64 = Type_Details::U64;
    using I8 = Type_Details::I8;
    using I16 = Type_Details::I16;
    using I32 = Type_Details::I32;
    using I64 = Type_Details::I64;
    using F32 = Type_Details::F32;
    using F64 = Type_Details::F64;
    using Usize = Type_Details::Usize;
    using JaktString = Type_Details::JaktString;
    using CChar = Type_Details::CChar;
    using CInt = Type_Details::CInt;
    using Unknown = Type_Details::Unknown;
    using Never = Type_Details::Never;
    using TypeVariable = Type_Details::TypeVariable;
    using GenericInstance = Type_Details::GenericInstance;
    using GenericEnumInstance = Type_Details::GenericEnumInstance;
    using GenericResolvedType = Type_Details::GenericResolvedType;
    using Struct = Type_Details::Struct;
    using Enum = Type_Details::Enum;
    using RawPtr = Type_Details::RawPtr;
    using Reference = Type_Details::Reference;
    using MutableReference = Type_Details::MutableReference;
    using Function = Type_Details::Function;
template<typename V, typename... Args> static auto create(Args&&... args) {
return adopt_nonnull_ref_or_enomem(new (nothrow) Type(V(forward<Args>(args)...)));
}
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Void */: {
[[maybe_unused]] auto const& that = this->template get<Type::Void>();
TRY(builder.append("Type::Void"));
break;}
case 1 /* Bool */: {
[[maybe_unused]] auto const& that = this->template get<Type::Bool>();
TRY(builder.append("Type::Bool"));
break;}
case 2 /* U8 */: {
[[maybe_unused]] auto const& that = this->template get<Type::U8>();
TRY(builder.append("Type::U8"));
break;}
case 3 /* U16 */: {
[[maybe_unused]] auto const& that = this->template get<Type::U16>();
TRY(builder.append("Type::U16"));
break;}
case 4 /* U32 */: {
[[maybe_unused]] auto const& that = this->template get<Type::U32>();
TRY(builder.append("Type::U32"));
break;}
case 5 /* U64 */: {
[[maybe_unused]] auto const& that = this->template get<Type::U64>();
TRY(builder.append("Type::U64"));
break;}
case 6 /* I8 */: {
[[maybe_unused]] auto const& that = this->template get<Type::I8>();
TRY(builder.append("Type::I8"));
break;}
case 7 /* I16 */: {
[[maybe_unused]] auto const& that = this->template get<Type::I16>();
TRY(builder.append("Type::I16"));
break;}
case 8 /* I32 */: {
[[maybe_unused]] auto const& that = this->template get<Type::I32>();
TRY(builder.append("Type::I32"));
break;}
case 9 /* I64 */: {
[[maybe_unused]] auto const& that = this->template get<Type::I64>();
TRY(builder.append("Type::I64"));
break;}
case 10 /* F32 */: {
[[maybe_unused]] auto const& that = this->template get<Type::F32>();
TRY(builder.append("Type::F32"));
break;}
case 11 /* F64 */: {
[[maybe_unused]] auto const& that = this->template get<Type::F64>();
TRY(builder.append("Type::F64"));
break;}
case 12 /* Usize */: {
[[maybe_unused]] auto const& that = this->template get<Type::Usize>();
TRY(builder.append("Type::Usize"));
break;}
case 13 /* JaktString */: {
[[maybe_unused]] auto const& that = this->template get<Type::JaktString>();
TRY(builder.append("Type::JaktString"));
break;}
case 14 /* CChar */: {
[[maybe_unused]] auto const& that = this->template get<Type::CChar>();
TRY(builder.append("Type::CChar"));
break;}
case 15 /* CInt */: {
[[maybe_unused]] auto const& that = this->template get<Type::CInt>();
TRY(builder.append("Type::CInt"));
break;}
case 16 /* Unknown */: {
[[maybe_unused]] auto const& that = this->template get<Type::Unknown>();
TRY(builder.append("Type::Unknown"));
break;}
case 17 /* Never */: {
[[maybe_unused]] auto const& that = this->template get<Type::Never>();
TRY(builder.append("Type::Never"));
break;}
case 18 /* TypeVariable */: {
[[maybe_unused]] auto const& that = this->template get<Type::TypeVariable>();
TRY(builder.append("Type::TypeVariable"));
TRY(builder.appendff("(\"{}\")", that.value));
break;}
case 19 /* GenericInstance */: {
[[maybe_unused]] auto const& that = this->template get<Type::GenericInstance>();
TRY(builder.append("Type::GenericInstance"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("id: {}", that.id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("args: {}", that.args));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 20 /* GenericEnumInstance */: {
[[maybe_unused]] auto const& that = this->template get<Type::GenericEnumInstance>();
TRY(builder.append("Type::GenericEnumInstance"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("id: {}", that.id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("args: {}", that.args));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 21 /* GenericResolvedType */: {
[[maybe_unused]] auto const& that = this->template get<Type::GenericResolvedType>();
TRY(builder.append("Type::GenericResolvedType"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("id: {}", that.id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("args: {}", that.args));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 22 /* Struct */: {
[[maybe_unused]] auto const& that = this->template get<Type::Struct>();
TRY(builder.append("Type::Struct"));
TRY(builder.appendff("({})", that.value));
break;}
case 23 /* Enum */: {
[[maybe_unused]] auto const& that = this->template get<Type::Enum>();
TRY(builder.append("Type::Enum"));
TRY(builder.appendff("({})", that.value));
break;}
case 24 /* RawPtr */: {
[[maybe_unused]] auto const& that = this->template get<Type::RawPtr>();
TRY(builder.append("Type::RawPtr"));
TRY(builder.appendff("({})", that.value));
break;}
case 25 /* Reference */: {
[[maybe_unused]] auto const& that = this->template get<Type::Reference>();
TRY(builder.append("Type::Reference"));
TRY(builder.appendff("({})", that.value));
break;}
case 26 /* MutableReference */: {
[[maybe_unused]] auto const& that = this->template get<Type::MutableReference>();
TRY(builder.append("Type::MutableReference"));
TRY(builder.appendff("({})", that.value));
break;}
case 27 /* Function */: {
[[maybe_unused]] auto const& that = this->template get<Type::Function>();
TRY(builder.append("Type::Function"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("params: {}", that.params));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("can_throw: {}", that.can_throw));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("return_type_id: {}", that.return_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}u64 max() const;
bool equals(const NonnullRefPtr<typechecker::Type> rhs) const;
i64 get_bits() const;
bool is_builtin() const;
i64 min() const;
bool is_signed() const;
};
namespace ExecutionResult_Details {
struct Return{
typechecker::Value value;
template<typename... Args>
Return(Args&&... args): value { forward<Args>(args)... } {}
};
struct Throw{
typechecker::Value value;
template<typename... Args>
Throw(Args&&... args): value { forward<Args>(args)... } {}
};
}
struct ExecutionResult : public Variant<ExecutionResult_Details::Return, ExecutionResult_Details::Throw> {
using Variant<ExecutionResult_Details::Return, ExecutionResult_Details::Throw>::Variant;
    using Return = ExecutionResult_Details::Return;
    using Throw = ExecutionResult_Details::Throw;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Return */: {
[[maybe_unused]] auto const& that = this->template get<ExecutionResult::Return>();
TRY(builder.append("ExecutionResult::Return"));
TRY(builder.appendff("({})", that.value));
break;}
case 1 /* Throw */: {
[[maybe_unused]] auto const& that = this->template get<ExecutionResult::Throw>();
TRY(builder.append("ExecutionResult::Throw"));
TRY(builder.appendff("({})", that.value));
break;}
}
return builder.to_string();
}};
namespace CheckedMatchCase_Details {
struct EnumVariant {
String name;
Array<parser::EnumVariantPatternArgument> args;
typechecker::TypeId subject_type_id;
size_t index;
typechecker::ScopeId scope_id;
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
name{ forward<_MemberT0>(member_0)},
args{ forward<_MemberT1>(member_1)},
subject_type_id{ forward<_MemberT2>(member_2)},
index{ forward<_MemberT3>(member_3)},
scope_id{ forward<_MemberT4>(member_4)},
body{ forward<_MemberT5>(member_5)},
marker_span{ forward<_MemberT6>(member_6)}
{}
};
struct Expression {
NonnullRefPtr<typechecker::CheckedExpression> expression;
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2>
Expression(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2):
expression{ forward<_MemberT0>(member_0)},
body{ forward<_MemberT1>(member_1)},
marker_span{ forward<_MemberT2>(member_2)}
{}
};
struct CatchAll {
typechecker::CheckedMatchBody body;
utility::Span marker_span;
template<typename _MemberT0, typename _MemberT1>
CatchAll(_MemberT0&& member_0, _MemberT1&& member_1):
body{ forward<_MemberT0>(member_0)},
marker_span{ forward<_MemberT1>(member_1)}
{}
};
}
struct CheckedMatchCase : public Variant<CheckedMatchCase_Details::EnumVariant, CheckedMatchCase_Details::Expression, CheckedMatchCase_Details::CatchAll> {
using Variant<CheckedMatchCase_Details::EnumVariant, CheckedMatchCase_Details::Expression, CheckedMatchCase_Details::CatchAll>::Variant;
    using EnumVariant = CheckedMatchCase_Details::EnumVariant;
    using Expression = CheckedMatchCase_Details::Expression;
    using CatchAll = CheckedMatchCase_Details::CatchAll;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* EnumVariant */: {
[[maybe_unused]] auto const& that = this->template get<CheckedMatchCase::EnumVariant>();
TRY(builder.append("CheckedMatchCase::EnumVariant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("args: {}", that.args));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("subject_type_id: {}", that.subject_type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("index: {}", that.index));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("scope_id: {}", that.scope_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("body: {}", that.body));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("marker_span: {}", that.marker_span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Expression */: {
[[maybe_unused]] auto const& that = this->template get<CheckedMatchCase::Expression>();
TRY(builder.append("CheckedMatchCase::Expression"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("expression: {}", that.expression));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("body: {}", that.body));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("marker_span: {}", that.marker_span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 2 /* CatchAll */: {
[[maybe_unused]] auto const& that = this->template get<CheckedMatchCase::CatchAll>();
TRY(builder.append("CheckedMatchCase::CatchAll"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("body: {}", that.body));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("marker_span: {}", that.marker_span));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}};
class InterpreterScope : public RefCounted<InterpreterScope>, public Weakable<InterpreterScope> {
  public:
virtual ~InterpreterScope() = default;
Dictionary<String,typechecker::Value> bindings;Optional<NonnullRefPtr<typechecker::InterpreterScope>> parent;ErrorOr<typechecker::Value> must_get(const String name) const;
private:
explicit InterpreterScope(Dictionary<String,typechecker::Value>&& a_bindings, Optional<NonnullRefPtr<typechecker::InterpreterScope>>&& a_parent): bindings(move(a_bindings)), parent(move(a_parent)){}
public:
static ErrorOr<NonnullRefPtr<InterpreterScope>> create(Dictionary<String,typechecker::Value> bindings, Optional<NonnullRefPtr<typechecker::InterpreterScope>> parent) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) InterpreterScope (move(bindings), move(parent)))); return o; }
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("InterpreterScope("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("bindings: "));TRY(builder.appendff("{}, ", bindings));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("parent: "));TRY(builder.appendff("{}", parent));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};enum class InterpretError: i32 {
CallToExternalFunction = (infallible_integer_cast<i32>((static_cast<i32>(42)))),
MismatchingArguments = (infallible_integer_cast<i32>((static_cast<u64>(43ULL)))),
InvalidThisArgument = (infallible_integer_cast<i32>((static_cast<u64>(44ULL)))),
InvalidType = (infallible_integer_cast<i32>((static_cast<u64>(45ULL)))),
UnknownVariable = (infallible_integer_cast<i32>((static_cast<u64>(46ULL)))),
Unimplemented = (infallible_integer_cast<i32>((static_cast<u64>(47ULL)))),
};
struct CheckedParameter {
  public:
bool requires_label;typechecker::CheckedVariable variable;Optional<NonnullRefPtr<typechecker::CheckedExpression>> default_value;CheckedParameter(bool a_requires_label, typechecker::CheckedVariable a_variable, Optional<NonnullRefPtr<typechecker::CheckedExpression>> a_default_value) :requires_label(a_requires_label), variable(a_variable), default_value(a_default_value){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CheckedParameter("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("requires_label: "));TRY(builder.appendff("{}, ", requires_label));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variable: "));TRY(builder.appendff("{}, ", variable));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("default_value: "));TRY(builder.appendff("{}", default_value));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};class Module : public RefCounted<Module>, public Weakable<Module> {
  public:
virtual ~Module() = default;
typechecker::ModuleId id;String name;Array<NonnullRefPtr<typechecker::CheckedFunction>> functions;Array<typechecker::CheckedStruct> structures;Array<typechecker::CheckedEnum> enums;Array<NonnullRefPtr<typechecker::Scope>> scopes;Array<NonnullRefPtr<typechecker::Type>> types;Array<typechecker::CheckedVariable> variables;Array<typechecker::ModuleId> imports;bool is_root;private:
explicit Module(typechecker::ModuleId&& a_id, String&& a_name, Array<NonnullRefPtr<typechecker::CheckedFunction>>&& a_functions, Array<typechecker::CheckedStruct>&& a_structures, Array<typechecker::CheckedEnum>&& a_enums, Array<NonnullRefPtr<typechecker::Scope>>&& a_scopes, Array<NonnullRefPtr<typechecker::Type>>&& a_types, Array<typechecker::CheckedVariable>&& a_variables, Array<typechecker::ModuleId>&& a_imports, bool&& a_is_root): id(move(a_id)), name(move(a_name)), functions(move(a_functions)), structures(move(a_structures)), enums(move(a_enums)), scopes(move(a_scopes)), types(move(a_types)), variables(move(a_variables)), imports(move(a_imports)), is_root(move(a_is_root)){}
public:
static ErrorOr<NonnullRefPtr<Module>> create(typechecker::ModuleId id, String name, Array<NonnullRefPtr<typechecker::CheckedFunction>> functions, Array<typechecker::CheckedStruct> structures, Array<typechecker::CheckedEnum> enums, Array<NonnullRefPtr<typechecker::Scope>> scopes, Array<NonnullRefPtr<typechecker::Type>> types, Array<typechecker::CheckedVariable> variables, Array<typechecker::ModuleId> imports, bool is_root) { auto o = TRY(adopt_nonnull_ref_or_enomem(new (nothrow) Module (move(id), move(name), move(functions), move(structures), move(enums), move(scopes), move(types), move(variables), move(imports), move(is_root)))); return o; }
ErrorOr<typechecker::TypeId> new_type_variable();
ErrorOr<typechecker::FunctionId> add_function(const NonnullRefPtr<typechecker::CheckedFunction> checked_function);
ErrorOr<typechecker::VarId> add_variable(const typechecker::CheckedVariable checked_variable);
typechecker::FunctionId next_function_id() const;
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Module("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("id: "));TRY(builder.appendff("{}, ", id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("name: "));TRY(builder.appendff("\"{}\", ", name));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("functions: "));TRY(builder.appendff("{}, ", functions));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("structures: "));TRY(builder.appendff("{}, ", structures));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("enums: "));TRY(builder.appendff("{}, ", enums));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("scopes: "));TRY(builder.appendff("{}, ", scopes));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("types: "));TRY(builder.appendff("{}, ", types));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("variables: "));TRY(builder.appendff("{}, ", variables));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("imports: "));TRY(builder.appendff("{}, ", imports));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("is_root: "));TRY(builder.appendff("{}", is_root));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static typechecker::TypeId void_type_id() {
{
return (typechecker::builtin(BuiltinType::Void));
}
}

static typechecker::TypeId expression_type(const NonnullRefPtr<typechecker::CheckedExpression> expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Bool));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::String));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CChar));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedRangeExpression>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).type_id));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).type_id));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();typechecker::CheckedEnumVariantBinding const& arg = __jakt_match_value.arg;
return JaktInternal::ExplicitValue(((arg).type_id));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Try>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::TryBlock>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedExpression::Garbage>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static typechecker::TypeId unknown_type_id() {
{
return (typechecker::builtin(BuiltinType::Unknown));
}
}

static bool expression_can_throw(const NonnullRefPtr<typechecker::CheckedExpression> expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(((call).callee_throws));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(((call).callee_throws));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

static typechecker::TypeId builtin(const typechecker::BuiltinType builtin) {
{
return (typechecker::TypeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),(infallible_integer_cast<size_t>((builtin)))));
}
}

static utility::Span expression_span(const NonnullRefPtr<typechecker::CheckedExpression> expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedRangeExpression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Try>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::TryBlock>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<typechecker::TypeId> flip_signedness(const NonnullRefPtr<typechecker::Type> type) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U16));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U32));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U64));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I8));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I16));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I32));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I64));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Unknown));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static typechecker::BlockControlFlow checked_expression_control_flow(const NonnullRefPtr<typechecker::CheckedExpression> check_expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *check_expression;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
bool const& all_variants_constant = __jakt_match_value.all_variants_constant;
return JaktInternal::ExplicitValue(({ Optional<typechecker::BlockControlFlow> __jakt_var_93; {
Optional<typechecker::BlockControlFlow> control_flow = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
const typechecker::BlockControlFlow case_control_flow = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = case_;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if (((control_flow).has_value())){
(control_flow = (((control_flow.value())).unify_with(case_control_flow)));
}
else {
(control_flow = case_control_flow);
}

}

}
}

__jakt_var_93 = control_flow.value_or_lazy_evaluated([&] { return typename typechecker::BlockControlFlow::MayReturn(); }); goto __jakt_label_91;

}
__jakt_label_91:; __jakt_var_93.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((type_id).equals(typechecker::never_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((type_id).equals(typechecker::never_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}

static Optional<typechecker::CheckedNumericConstant> promote(const typechecker::NumberConstant num_const,const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedProgram> program) {
{
if ((!(((num_const).can_fit_number(type_id,program))))){
return (JaktInternal::OptionalNone());
}
const i64 bits = ((program)->get_bits(type_id));
const bool is_signed = ((program)->is_signed(type_id));
const typechecker::CheckedNumericConstant new_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, Optional<typechecker::CheckedNumericConstant>>{
auto&& __jakt_match_variant = num_const;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U8((infallible_integer_cast<u8>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U16((infallible_integer_cast<u16>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U32((infallible_integer_cast<u32>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U64((infallible_integer_cast<u64>((value)))));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64(value));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
}()))
);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U8((infallible_integer_cast<u8>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U16((infallible_integer_cast<u16>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U32((infallible_integer_cast<u32>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::U64(value));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(8LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(16LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>((value)))));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64((infallible_integer_cast<i64>((value)))));
}
else {
{
utility::panic(String("Numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
}()))
);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (is_signed);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant,Optional<typechecker::CheckedNumericConstant>>{
auto __jakt_enum_value = (bits);
if (__jakt_enum_value == static_cast<i64>(32LL)) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedNumericConstant> __jakt_var_94; {
utility::todo(String("Add conversion from f64 to f32"));
__jakt_var_94 = typename typechecker::CheckedNumericConstant::I64(static_cast<i64>(0LL)); goto __jakt_label_92;

}
__jakt_label_92:; __jakt_var_94.release_value(); }));
}
else if (__jakt_enum_value == static_cast<i64>(64LL)) {
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::F64(value));
}
else {
{
utility::panic(String("Floating numeric constants can only be 8, 16, 32, or 64 bits long"));
}
}
}()))
);
}
else {
{
utility::panic(String("Floating numeric constant cannot be unsigned"));
}
}
}()))
);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (new_constant);
}
}

static typechecker::TypeId never_type_id() {
{
return (typechecker::builtin(BuiltinType::Never));
}
}

template <typename T,typename U>
static bool is_same_type() {
{
bool ret = false;
{
ret = IsSame<T, U>;
}

return (ret);
}
}

ErrorOr<typechecker::StatementResult> typechecker::Interpreter::execute_expression(const NonnullRefPtr<typechecker::CheckedExpression> expr,const NonnullRefPtr<typechecker::InterpreterScope> scope) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typechecker::CheckedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_95; {
const typechecker::Value lhs_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(lhs,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const typechecker::Value rhs_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(rhs,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_95 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>((JaktInternal::checked_add<u8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>((JaktInternal::checked_add<u16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>((JaktInternal::checked_add<u32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>((JaktInternal::checked_add<u64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>((JaktInternal::checked_add<i8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>((JaktInternal::checked_add<i16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>((JaktInternal::checked_add<i32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>((JaktInternal::checked_add<i64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>((x + y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>((x + y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((JaktInternal::checked_add<size_t>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>((x + y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>((JaktInternal::checked_sub<u8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>((JaktInternal::checked_sub<u16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>((JaktInternal::checked_sub<u32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>((JaktInternal::checked_sub<u64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>((JaktInternal::checked_sub<i8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>((JaktInternal::checked_sub<i16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>((JaktInternal::checked_sub<i32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>((JaktInternal::checked_sub<i64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>((x - y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>((x - y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((JaktInternal::checked_sub<size_t>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>((JaktInternal::checked_mul<u8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>((JaktInternal::checked_mul<u16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>((JaktInternal::checked_mul<u32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>((JaktInternal::checked_mul<u64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>((JaktInternal::checked_mul<i8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>((JaktInternal::checked_mul<i16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>((JaktInternal::checked_mul<i32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>((JaktInternal::checked_mul<i64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>((x * y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>((x * y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((JaktInternal::checked_mul<size_t>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>((JaktInternal::checked_div<u8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>((JaktInternal::checked_div<u16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>((JaktInternal::checked_div<u32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>((JaktInternal::checked_div<u64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>((JaktInternal::checked_div<i8>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>((JaktInternal::checked_div<i16>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>((JaktInternal::checked_div<i32>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>((JaktInternal::checked_div<i64>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>((x / y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>((x / y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((JaktInternal::checked_div<size_t>(x,y))))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x == y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x < y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x > y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x || y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((lhs_value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((rhs_value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& y = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((x && y)))));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)),span)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unimplemented binary operator '{}'"),op))),span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_93;

}
__jakt_label_93:; __jakt_var_95.release_value(); }));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_96; {
const typechecker::Value value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(expr,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_96 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>((!(value))))),span)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Invalid type for unary operator")))),span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unimplemented unary operator '{}'"),op))),span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_94;

}
__jakt_label_94:; __jakt_var_96.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_97; {
if ((!(((((call).function_id)).has_value())))){
Array<typechecker::Value> arguments = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(((arg).get<1>()),scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

return (TRY((((*this).call_prelude_function(((call).name),(TRY((Array<typechecker::ResolvedNamespace>::create_with({})))),JaktInternal::OptionalNone(),arguments,span)))));
}
const NonnullRefPtr<typechecker::CheckedFunction> function_to_run = ((((*this).program))->get_function((((call).function_id).value())));
Optional<typechecker::Value> this_argument = JaktInternal::OptionalNone();
Array<typechecker::Value> arguments = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(((arg).get<1>()),scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

__jakt_var_97 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute((((call).function_id).value()),(((call).namespace_)),this_argument,arguments,span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Throw(value));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_95;

}
__jakt_label_95:; __jakt_var_97.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_98; {
const typechecker::Value this_argument = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(expr,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
Array<typechecker::ResolvedNamespace> effective_namespace = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((this_argument).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("String"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
const Array<typechecker::TypeId> generic_parameters = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<typechecker::TypeId>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(args);
};/*case end*/
default: {
{
TRY((((*this).error(String("Attempted to call a prelude function on a non-generic array"),((this_argument).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Array"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_struct(struct_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Class>();typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_struct(struct_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Enum>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_enum(enum_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::OptionalNone>();
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Optional"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Optional"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Attempted to call an instance method on a non-struct/enum type"),((this_argument).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if ((!(((((call).function_id)).has_value())))){
Array<typechecker::Value> arguments = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(((arg).get<1>()),scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

return (TRY((((*this).call_prelude_function(((call).name),effective_namespace,this_argument,arguments,span)))));
}
const NonnullRefPtr<typechecker::CheckedFunction> function_to_run = ((((*this).program))->get_function((((call).function_id).value())));
Array<typechecker::Value> arguments = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(((arg).get<1>()),scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

__jakt_var_98 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute((((call).function_id).value()),(((call).namespace_)),this_argument,arguments,span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Throw(value));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_96;

}
__jakt_label_96:; __jakt_var_98.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_99; {
const typechecker::Value value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(expr,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if (((((value).impl))->index() == 22 /* OptionalNone */)){
TRY((((*this).error(String("Attempted to unwrap an optional value that was None"),((value).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
__jakt_var_99 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(value));
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid type for unwrap"),((value).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_97;

}
__jakt_label_97:; __jakt_var_99.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>(((val).byte_at(static_cast<size_t>(0ULL)))))),span)));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(TRY((((scope)->must_get(((var).name)))))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_100; {
const typechecker::Value value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(expr,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_100 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_101; {
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
i64 idx = static_cast<i64>(0LL);
Optional<i64> found_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
if ((((((((*this).program))->get_variable(field_id))).name) == index)){
(found_index = idx);
break;
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<i64>(_jakt_ref, static_cast<i64>(1LL));});
}

}
}

if ((!(((found_index).has_value())))){
TRY((((*this).error(String("Attempted to access a field that does not exist"),((value).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
__jakt_var_101 = typename typechecker::StatementResult::JustValue(((fields)[(found_index.value())])); goto __jakt_label_99;

}
__jakt_label_99:; __jakt_var_101.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Class>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_102; {
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
i64 idx = static_cast<i64>(0LL);
Optional<i64> found_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
if ((((((((*this).program))->get_variable(field_id))).name) == index)){
(found_index = idx);
break;
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<i64>(_jakt_ref, static_cast<i64>(1LL));});
}

}
}

if ((!(((found_index).has_value())))){
TRY((((*this).error(String("Attempted to access a field that does not exist"),((value).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
__jakt_var_102 = typename typechecker::StatementResult::JustValue(((fields)[(found_index.value())])); goto __jakt_label_100;

}
__jakt_label_100:; __jakt_var_102.release_value(); }));
};/*case end*/
default: {
{
TRY((((*this).error(String("Attempted to access a field on a non-struct/enum type"),((value).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_98;

}
__jakt_label_98:; __jakt_var_100.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>(x))),span));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>(x))),span));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>(x))),span));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>(x))),span));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>(x))),span));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>(x))),span));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>(x))),span));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>(x))),span));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((infallible_integer_cast<size_t>((x)))))),span));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>(x))),span));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>(x))),span));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(val))),span)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::CChar>((infallible_integer_cast<char>((((val).byte_at(static_cast<size_t>(0ULL))))))))),span)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("expression not implemented: {}"),expr))),typechecker::expression_span(expr)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<typechecker::TypeId> typechecker::Interpreter::find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((module)->types)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t id = (_magic_value.value());
{
if (((((((module)->types))[id]))->equals(type))){
return (typechecker::TypeId(((module)->id),id));
}
}

}
}

}

}
}

TRY((((((((((((*this).program))->modules))[static_cast<i64>(0LL)]))->types)).push(type))));
return (typechecker::TypeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),(JaktInternal::checked_sub<size_t>(((((((((((*this).program))->modules))[static_cast<i64>(0LL)]))->types)).size()),static_cast<size_t>(1ULL)))));
}
}

void typechecker::Interpreter::leave_span() {
{
((((*this).spans)).pop());
}
}

ErrorOr<void> typechecker::Interpreter::error(const String message,const utility::Span span) {
{
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
TRY((((((*this).compiler))->print_errors())));
}
return {};
}

ErrorOr<typechecker::StatementResult> typechecker::Interpreter::call_prelude_function(const String prelude_function,const Array<typechecker::ResolvedNamespace> namespace_,const Optional<typechecker::Value> this_argument,const Array<typechecker::Value> arguments,const utility::Span call_span) {
{
if ((((namespace_).size()) != static_cast<size_t>(1ULL))){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_103; {
const String format_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Expected string as first argument to format, got {}"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_103 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((arguments).size()));
if (__jakt_enum_value == static_cast<size_t>(1ULL)) {
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string))));
}
else if (__jakt_enum_value == static_cast<size_t>(2ULL)) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(format_string,x))));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format can only format primitves, got {}"),((((arguments)[static_cast<i64>(1LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format accepts at most two arguments, but got {}"),((arguments).size())))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
}
}()))
))),call_span)); goto __jakt_label_101;

}
__jakt_label_101:; __jakt_var_103.release_value(); }));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_104; {
const String format_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("println expects a string as its first argument, but got {}"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((arguments).size()));
if (__jakt_enum_value == static_cast<size_t>(1ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == static_cast<size_t>(2ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format can only format primitves, got {}"),((((arguments)[static_cast<i64>(1LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format accepts at most two arguments, but got {}"),((arguments).size())))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_104 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_102;

}
__jakt_label_102:; __jakt_var_104.release_value(); }));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_105; {
const String format_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("println expects a string as its first argument, but got {}"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((arguments).size()));
if (__jakt_enum_value == static_cast<size_t>(1ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == static_cast<size_t>(2ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format can only format primitves, got {}"),((((arguments)[static_cast<i64>(1LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format accepts at most two arguments, but got {}"),((arguments).size())))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_105 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_103;

}
__jakt_label_103:; __jakt_var_105.release_value(); }));
}
else if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_106; {
const String format_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("println expects a string as its first argument, but got {}"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((arguments).size()));
if (__jakt_enum_value == static_cast<size_t>(1ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == static_cast<size_t>(2ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format can only format primitves, got {}"),((((arguments)[static_cast<i64>(1LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format accepts at most two arguments, but got {}"),((arguments).size())))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_106 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_104;

}
__jakt_label_104:; __jakt_var_106.release_value(); }));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_107; {
const String format_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("println expects a string as its first argument, but got {}"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((arguments).size()));
if (__jakt_enum_value == static_cast<size_t>(1ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == static_cast<size_t>(2ULL)) {
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("println")) {
return (outln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
return (warnln(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("print")) {
return (out(format_string,x)), JaktInternal::ExplicitValue<void>();
}
else {
return (warn(format_string,x)), JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format can only format primitves, got {}"),((((arguments)[static_cast<i64>(1LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("comptime format accepts at most two arguments, but got {}"),((arguments).size())))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_107 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_105;

}
__jakt_label_105:; __jakt_var_107.release_value(); }));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function {}::{} is not implemented yet"),namespace_,prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((((namespace_)[static_cast<i64>(0LL)])).name));
if (__jakt_enum_value == String("Error")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("from_errno")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_108; {
const typechecker::Value err = ((arguments)[static_cast<i64>(0LL)]);
const typechecker::StructId error_struct_id = TRY((((((*this).program))->find_struct_in_prelude(String("Error")))));
const typechecker::CheckedStruct error_struct = ((((*this).program))->get_struct(error_struct_id));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((error_struct).scope_id)))));
const Optional<typechecker::FunctionId> constructor = ((((scope)->functions)).get(String("from_errno")));
__jakt_var_108 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>((TRY((Array<typechecker::Value>::create_with({err})))),error_struct_id,(constructor.value())))),call_span)); goto __jakt_label_106;

}
__jakt_label_106:; __jakt_var_108.release_value(); }));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `Error::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("File")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("open_for_reading")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_109; {
const String requested_path = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `File::{}` expects a string as its first argument, but got {}"),prelude_function,((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
const String base_path = TRY(((((TRY((((((((*this).program))->compiler))->get_file_path(((call_span).file_id))))).value()))->dirname())));
const String path_string = ((base_path + String("/")) + requested_path);
const typechecker::Value path = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(path_string))),call_span);
if ((!(File::exists(path_string)))){
TRY((((*this).error(TRY((String::formatted(String("Prelude function `File::{}` could not find file at path {}"),prelude_function,path_string))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
const typechecker::StructId file_struct_id = TRY((((((*this).program))->find_struct_in_prelude(String("File")))));
const typechecker::CheckedStruct file_struct = ((((*this).program))->get_struct(file_struct_id));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((file_struct).scope_id)))));
const Optional<typechecker::FunctionId> constructor = ((((scope)->functions)).get(String("open_for_reading")));
__jakt_var_109 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>((TRY((Array<typechecker::Value>::create_with({path})))),file_struct_id,(constructor.value())))),call_span)); goto __jakt_label_107;

}
__jakt_label_107:; __jakt_var_109.release_value(); }));
}
else if (__jakt_enum_value == String("read_all")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_110; {
const String path = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
utility::panic(String("invalid type for File::read_all"));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `File::read_all` expects a `File` as its this argument, but got {}"),(((this_argument.value())).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<File> file = TRY((File::open_for_reading(path)));
Array<typechecker::Value> result_values = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<u8> _magic = ((TRY((((file)->read_all())))).iterator());
for (;;){
Optional<u8> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
u8 byte = (_magic_value.value());
{
TRY((((result_values).push(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>(byte))),call_span)))));
}

}
}

const typechecker::StructId array_struct_id = TRY((((((*this).program))->find_struct_in_prelude(String("Array")))));
__jakt_var_110 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktArray>(result_values,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_struct_id,(TRY((Array<typechecker::TypeId>::create_with({typechecker::builtin(BuiltinType::U8)})))))))))))))),call_span)); goto __jakt_label_108;

}
__jakt_label_108:; __jakt_var_110.release_value(); }));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `File::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("StringBuilder")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("create")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_111; {
const typechecker::StructId string_builder_struct_id = TRY((((((*this).program))->find_struct_in_prelude(String("StringBuilder")))));
__jakt_var_111 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>((TRY((Array<typechecker::Value>::create_with({typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(String("")))),call_span)})))),string_builder_struct_id,JaktInternal::OptionalNone()))),call_span)); goto __jakt_label_109;

}
__jakt_label_109:; __jakt_var_111.release_value(); }));
}
else if (__jakt_enum_value == String("append")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_112; {
Tuple<Array<typechecker::Value>,String> fields_current_string_ = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{fields, value}));
};/*case end*/
default: {
{
utility::panic(String("Invalid use of prelude StringBuilder"));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
));
Array<typechecker::Value> fields = ((fields_current_string_).get<0>());
String current_string = ((fields_current_string_).get<1>());

StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(current_string))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("append")) {
return (TRY((((builder).append(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u8, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Invalid use of StringBuilder::append({})"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_string")) {
return (TRY((((builder).append_string(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_string()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_code_point")) {
return (TRY((((builder).append_code_point(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u32, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_code_point()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else {
{
abort();
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(((fields)[static_cast<i64>(0LL)]) = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(TRY((((builder).to_string())))))),call_span));
__jakt_var_112 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_110;

}
__jakt_label_110:; __jakt_var_112.release_value(); }));
}
else if (__jakt_enum_value == String("append_string")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_113; {
Tuple<Array<typechecker::Value>,String> fields_current_string_ = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{fields, value}));
};/*case end*/
default: {
{
utility::panic(String("Invalid use of prelude StringBuilder"));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
));
Array<typechecker::Value> fields = ((fields_current_string_).get<0>());
String current_string = ((fields_current_string_).get<1>());

StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(current_string))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("append")) {
return (TRY((((builder).append(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u8, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Invalid use of StringBuilder::append({})"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_string")) {
return (TRY((((builder).append_string(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_string()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_code_point")) {
return (TRY((((builder).append_code_point(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u32, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_code_point()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else {
{
abort();
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(((fields)[static_cast<i64>(0LL)]) = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(TRY((((builder).to_string())))))),call_span));
__jakt_var_113 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_111;

}
__jakt_label_111:; __jakt_var_113.release_value(); }));
}
else if (__jakt_enum_value == String("append_code_point")) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_114; {
Tuple<Array<typechecker::Value>,String> fields_current_string_ = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Tuple<Array<typechecker::Value>,String>, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((Tuple{fields, value}));
};/*case end*/
default: {
{
utility::panic(String("Invalid use of prelude StringBuilder"));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
));
Array<typechecker::Value> fields = ((fields_current_string_).get<0>());
String current_string = ((fields_current_string_).get<1>());

StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(current_string))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("append")) {
return (TRY((((builder).append(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u8, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Invalid use of StringBuilder::append({})"),((((arguments)[static_cast<i64>(0LL)])).impl)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_string")) {
return (TRY((((builder).append_string(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_string()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("append_code_point")) {
return (TRY((((builder).append_code_point(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u32, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((arguments)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
TRY((((*this).error(String("Invalid use of StringBuilder::append_code_point()"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
))))))), JaktInternal::ExplicitValue<void>();
}
else {
{
abort();
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(((fields)[static_cast<i64>(0LL)]) = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(TRY((((builder).to_string())))))),call_span));
__jakt_var_114 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)); goto __jakt_label_112;

}
__jakt_label_112:; __jakt_var_114.release_value(); }));
}
else if (__jakt_enum_value == String("to_string")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(((fields)[static_cast<i64>(0LL)])));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `StringBuilder::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("Array")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("iterator")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_115; {
const typechecker::StructId struct_id = TRY((((((*this).program))->find_struct_in_prelude(String("ArrayIterator")))));
__jakt_var_115 = typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>((TRY((Array<typechecker::Value>::create_with({(this_argument.value()), typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>(static_cast<size_t>(0ULL)))),call_span)})))),struct_id,JaktInternal::OptionalNone()))),call_span)); goto __jakt_label_113;

}
__jakt_label_113:; __jakt_var_115.release_value(); }));
};/*case end*/
default: {
{
utility::panic(String("Invalid use of Array::iterator()"));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `Array::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("ArrayIterator")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("next")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StatementResult> __jakt_var_116; {
const size_t index = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(1LL)])).impl);
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(value);
};/*case end*/
default: {
{
utility::panic(String("Invalid ArrayIterator index configuration"));
}
};/*case end*/
}/*switch end*/
}()
));
Array<typechecker::Value> mutable_fields = fields;
__jakt_var_116 = typename typechecker::StatementResult::JustValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((((fields)[static_cast<i64>(0LL)])).impl);
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();Array<typechecker::Value> const& values = __jakt_match_value.values;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = ((((values).size()) > index));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::Value> __jakt_var_117; {
(((mutable_fields)[static_cast<i64>(1LL)]) = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>((JaktInternal::checked_add<size_t>(index,static_cast<size_t>(1ULL)))))),call_span));
__jakt_var_117 = typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::OptionalSome>(((values)[index])))),call_span); goto __jakt_label_115;

}
__jakt_label_115:; __jakt_var_117.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::OptionalNone>())),call_span));
}
}()))
);
};/*case end*/
default: {
{
utility::panic(String("Invalid ArrayIterator configuration"));
}
};/*case end*/
}/*switch end*/
}()
))); goto __jakt_label_114;

}
__jakt_label_114:; __jakt_var_116.release_value(); }));
};/*case end*/
default: {
{
utility::panic(String("Invalid ArrayIterator configuration"));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `ArrayIterator::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("String")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("is_empty")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>(((value).is_empty())))),call_span)));
};/*case end*/
default: {
{
utility::panic(String("Invalid String"));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `String::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else if (__jakt_enum_value == String("Optional")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (prelude_function);
if (__jakt_enum_value == String("has_value")) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>(true))),call_span)));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::OptionalNone>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>(false))),call_span)));
};/*case end*/
default: {
{
utility::panic(String("Invalid Optional configuration"));
}
};/*case end*/
}/*switch end*/
}()
)));
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `Optional::{}` is not implemented"),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Prelude function `{}::{}` is not implemented"),((((namespace_)[static_cast<i64>(0LL)])).name),prelude_function))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
}
}()))
);
}
}

ErrorOr<typechecker::StatementResult> typechecker::Interpreter::execute_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement,NonnullRefPtr<typechecker::InterpreterScope> scope,const utility::Span call_span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
{
return (TRY((((*this).execute_expression(expr,scope)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();utility::Span const& span = __jakt_match_value.span;
return (TRY((((*this).error(String("defer statement not implemented"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();utility::Span const& span = __jakt_match_value.span;
return (TRY((((*this).error(String("destructuring assignment not implemented"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();typechecker::VarId const& var_id = __jakt_match_value.var_id;
NonnullRefPtr<typechecker::CheckedExpression> const& init = __jakt_match_value.init;
utility::Span const& span = __jakt_match_value.span;
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(init,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& var_value = __jakt_match_value.value;
{
TRY(((scope)->bindings).set(((((((*this).program))->get_variable(var_id))).name), var_value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
utility::Span const& span = __jakt_match_value.span;
{
const bool cond = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(condition,scope))));
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = *((value).impl);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("if condition must be a boolean, but got {}"),((value).impl)))),span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const Optional<typechecker::CheckedBlock> block = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::CheckedBlock>,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (cond);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((then_block));
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::CheckedBlock>,ErrorOr<typechecker::StatementResult>>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({(else_statement.value())})))),((then_block).scope_id),typename typechecker::BlockControlFlow::MayReturn(),JaktInternal::OptionalNone())));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}()))
);
}
}()))
;
if (((block).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_block((block.value()),scope,span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Return(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Throw(value));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),span)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Continue());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Break());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
{
const NonnullRefPtr<typechecker::InterpreterScope> new_scope = TRY((typechecker::InterpreterScope::create((TRY((Dictionary<String, typechecker::Value>::create_with_entries({})))),(scope))));
return (TRY((((*this).execute_block(block,new_scope,span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
{
for (;;){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_block(block,scope,span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return JaktInternal::LoopContinue{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();utility::Span const& span = __jakt_match_value.span;
return (TRY((((*this).error(String("while statement not implemented"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
{
if (((val).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StatementResult, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression((val.value()),scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Return(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Throw(value));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Return(value));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Continue());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
return JaktInternal::ExplicitValue(typename typechecker::StatementResult::Break());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
return (typename typechecker::StatementResult::Return(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
{
return (typename typechecker::StatementResult::Break());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_expression(expr,scope))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();utility::Span const& span = __jakt_match_value.span;
return (TRY((((*this).error(String("yield statement not implemented"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();utility::Span const& span = __jakt_match_value.span;
return (TRY((((*this).error(String("Cannot run inline cpp at compile time"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return (TRY((((*this).error(String("Cannot run invalid statements at compile time"),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)));
}
}

ErrorOr<void> typechecker::Interpreter::error_with_hint(const String message,const utility::Span span,const String hint_message,const utility::Span hint_span) {
{
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::MessageWithHint(message,span,hint_message,hint_span)))));
TRY((((((*this).compiler))->print_errors())));
}
return {};
}

ErrorOr<typechecker::ExecutionResult> typechecker::Interpreter::execute(const typechecker::FunctionId function_to_run_id,Optional<Array<typechecker::ResolvedNamespace>> namespace_,const Optional<typechecker::Value> this_argument,const Array<typechecker::Value> arguments,const utility::Span call_span) {
{
const NonnullRefPtr<typechecker::CheckedFunction> function_to_run = ((((*this).program))->get_function(function_to_run_id));
TRY((((*this).enter_span(call_span))));

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{((*this).leave_span());
});
bool is_prelude_function = false;
if (((((function_to_run)->linkage)).index() == 1 /* External */)){
const NonnullRefPtr<typechecker::Scope> function_scope = TRY((((((*this).program))->get_scope(((function_to_run)->function_scope_id)))));
if ((!(TRY((((*this).get_prelude_function(((function_to_run)->function_scope_id)))))))){
TRY((((*this).error(TRY((String::formatted(String("Cannot call external function '{}'"),((function_to_run)->name)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::CallToExternalFunction))));
}
(is_prelude_function = true);
}
if ((((function_to_run)->is_static()) == ((this_argument).has_value()))){
String expected = String("did not expect");
if ((!(((function_to_run)->is_static())))){
(expected = String("expected"));
}
String not_provided = String(" not");
if (((this_argument).has_value())){
(not_provided = String(""));
}
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(TRY((String::formatted(String("function call {} a this argument, yet one was{} provided"),expected,not_provided))),((function_to_run)->name_span))))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidThisArgument))));
}
size_t this_offset = static_cast<size_t>(0ULL);
if (((this_argument).has_value())){
(this_offset = static_cast<size_t>(1ULL));
}
if (((JaktInternal::checked_sub<size_t>(((((function_to_run)->params)).size()),this_offset)) != ((arguments).size()))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(TRY((String::formatted(String("Function called with wrong number of arguments, expected {} but got {}"),((((function_to_run)->params)).size()),((arguments).size())))),call_span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::MismatchingArguments))));
}
if (is_prelude_function){
if ((((this_argument).has_value()) && ((!(((namespace_).has_value()))) || (((namespace_.value())).is_empty())))){
Array<typechecker::ResolvedNamespace> effective_namespace = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = *(((this_argument.value())).impl);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("String"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
const Array<typechecker::TypeId> generic_parameters = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<typechecker::TypeId>, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(args);
};/*case end*/
default: {
{
TRY((((*this).error(String("Attempted to call a prelude function on a non-generic array"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Array"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_struct(struct_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Class>();typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_struct(struct_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Enum>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(((((((*this).program))->get_enum(enum_id))).name),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::OptionalNone>();
{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Optional"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();{
const Array<typechecker::TypeId> generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((effective_namespace).push(typechecker::ResolvedNamespace(String("Optional"),generic_parameters)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Attempted to call an instance method on a non-struct/enum type"),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
(namespace_ = effective_namespace);
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ExecutionResult, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = TRY((((*this).call_prelude_function(((function_to_run)->name),(namespace_.value()),this_argument,arguments,call_span))));
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Return(value));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Return(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Throw(value));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
utility::panic(String("Invalid control flow"));
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
utility::panic(String("Invalid control flow"));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = ((function_to_run)->type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::Normal>();
{
NonnullRefPtr<typechecker::InterpreterScope> scope = TRY((typechecker::InterpreterScope::create((TRY((Dictionary<String, typechecker::Value>::create_with_entries({})))),JaktInternal::OptionalNone())));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((function_to_run)->params)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if (((this_offset != static_cast<size_t>(0ULL)) && (i == static_cast<size_t>(0ULL)))){
continue;
}
const String param_name = ((((((((function_to_run)->params))[i])).variable)).name);
const typechecker::Value param_value = ((arguments)[i]);
TRY(((scope)->bindings).set(param_name, param_value));
}

}
}

if (((this_argument).has_value())){
TRY((((((scope)->bindings)).set(String("this"),(this_argument.value())))));
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ExecutionResult, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_block(((function_to_run)->block),scope,call_span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Return(value));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Return(value));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::ExecutionResult::Throw(value));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
utility::panic(String("Invalid control flow"));
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
utility::panic(String("Invalid control flow"));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::ImplicitConstructor>();
{
const NonnullRefPtr<typechecker::Type> result_type = ((((*this).program))->get_type(((function_to_run)->return_type_id)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = *result_type;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
const typechecker::FunctionId constructor = function_to_run_id;
const NonnullRefPtr<typechecker::ValueImpl> impl = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>(arguments,struct_id,constructor))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Class>(arguments,struct_id,constructor))));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Cannot create instance of non-struct type {}"),((struct_).name)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
return (typename typechecker::ExecutionResult::Return(typechecker::Value(impl,call_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
const typechecker::FunctionId constructor = function_to_run_id;
const NonnullRefPtr<typechecker::ValueImpl> impl = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<typechecker::ExecutionResult>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>(arguments,struct_id,constructor))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Class>(arguments,struct_id,constructor))));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Cannot create instance of non-struct type {}"),((struct_).name)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
}/*switch end*/
}()
));
return (typename typechecker::ExecutionResult::Return(typechecker::Value(impl,call_span)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Implicit constructor can only return a struct or a generic instance")))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Function type {} is not implemented"),((function_to_run)->type)))),call_span))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
}

ErrorOr<void> typechecker::Interpreter::enter_span(const utility::Span span) {
{
TRY((((((*this).spans)).push(span))));
}
return {};
}

ErrorOr<typechecker::StatementResult> typechecker::Interpreter::execute_block(const typechecker::CheckedBlock block,NonnullRefPtr<typechecker::InterpreterScope> scope,const utility::Span call_span) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
TRY((((*this).enter_span(((statement)->span()).value_or_lazy_evaluated([&] { return call_span; })))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::StatementResult>>{
auto&& __jakt_match_variant = TRY((((*this).execute_statement(statement,scope,call_span))));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Return(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
return (typename typechecker::StatementResult::Throw(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return (typename typechecker::StatementResult::Continue());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return (typename typechecker::StatementResult::Break());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{((*this).leave_span());
});
}

}
}

return (typename typechecker::StatementResult::JustValue(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())),call_span)));
}
}

ErrorOr<bool> typechecker::Interpreter::get_prelude_function(const typechecker::ScopeId scope_id) const {
{
typechecker::ScopeId current_scope_id = scope_id;
const typechecker::ScopeId prelude_scope_id = ((((*this).program))->prelude_scope_id());
for (;;){
if (((current_scope_id).equals(prelude_scope_id))){
return (true);
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(current_scope_id))));
if (((((scope)->parent)).has_value())){
(current_scope_id = (((scope)->parent).value()));
continue;
}
return (false);
}
}
}

bool typechecker::CheckedProgram::is_floating(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::ScopeId typechecker::CheckedProgram::prelude_scope_id() const {
{
return (typechecker::ScopeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL)));
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::CheckedProgram::find_struct_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
Optional<typechecker::ScopeId> current_scope_id = (scope_id);
while (((current_scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope((current_scope_id.value())))));
const Optional<typechecker::StructId> maybe_scope = ((((scope)->structs)).get(name));
if (((maybe_scope).has_value())){
return (maybe_scope);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!(((((child_scope)->namespace_name)).has_value())))){
const Optional<typechecker::StructId> maybe_scope = ((((child_scope)->structs)).get(name));
if (((maybe_scope).has_value())){
return (maybe_scope);
}
}
}

}
}

(current_scope_id = ((scope)->parent));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<void> typechecker::CheckedProgram::set_loaded_module(const String module_name,const typechecker::LoadedModule loaded_module) {
{
TRY((((((*this).loaded_modules)).set(module_name,loaded_module))));
}
return {};
}

bool typechecker::CheckedProgram::is_integer(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

NonnullRefPtr<typechecker::Module> typechecker::CheckedProgram::get_module(const typechecker::ModuleId id) const {
{
return (((((*this).modules))[((id).id)]));
}
}

bool typechecker::CheckedProgram::is_numeric(const typechecker::TypeId type_id) const {
{
return ((((*this).is_integer(type_id)) || ((*this).is_floating(type_id))));
}
}

bool typechecker::CheckedProgram::is_string(const typechecker::TypeId type_id) const {
{
return (((((*this).get_type(type_id)))->index() == 13 /* JaktString */));
}
}

typechecker::CheckedVariable typechecker::CheckedProgram::get_variable(const typechecker::VarId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->variables))[((id).id)]));
}
}

NonnullRefPtr<typechecker::CheckedFunction> typechecker::CheckedProgram::get_function(const typechecker::FunctionId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->functions))[((id).id)]));
}
}

i64 typechecker::CheckedProgram::get_bits(const typechecker::TypeId type_id) const {
{
return (((((*this).get_type(type_id)))->get_bits()));
}
}

NonnullRefPtr<typechecker::Type> typechecker::CheckedProgram::get_type(const typechecker::TypeId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->types))[((id).id)]));
}
}

ErrorOr<typechecker::StructId> typechecker::CheckedProgram::find_struct_in_prelude(const String name) const {
{
const typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,name))));
if (((struct_id).has_value())){
return (((struct_id).value()));
}
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("internal error: {} builtin definition not found"),name)))))));
}
}

typechecker::CheckedEnum typechecker::CheckedProgram::get_enum(const typechecker::EnumId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->enums))[((id).id)]));
}
}

ErrorOr<String> typechecker::CheckedProgram::type_name(const typechecker::TypeId type_id) const {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("never"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("usize"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("c_char"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("c_int"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(String("unknown"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_118; {
Array<String> param_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((params).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId x = (_magic_value.value());
{
TRY((((param_names).push(TRY((((*this).type_name(x))))))));
}

}
}

const String return_type = TRY((((*this).type_name(return_type_id))));
__jakt_var_118 = TRY((String::formatted(String("function({}) -> {}"),utility::join(param_names,String(", ")),return_type))); goto __jakt_label_116;

}
__jakt_label_116:; __jakt_var_118.release_value(); }));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(id))).name));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(id))).name));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_119; {
String output = TRY((String::formatted(String("enum {}"),((((*this).get_enum(id))).name))));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(">"));
__jakt_var_119 = output; goto __jakt_label_117;

}
__jakt_label_117:; __jakt_var_119.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_120; {
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((*this).find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
String output = String("");
if (((id).equals(array_struct_id))){
(output = TRY((String::formatted(String("[{}]"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(dictionary_struct_id))){
(output = TRY((String::formatted(String("[{}:{}]"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)]))))),TRY((((*this).type_name(((args)[static_cast<i64>(1LL)])))))))));
}
else if (((id).equals(optional_struct_id))){
(output = TRY((String::formatted(String("{}?"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(range_struct_id))){
(output = TRY((String::formatted(String("{}..{}"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)]))))),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(set_struct_id))){
(output = TRY((String::formatted(String("{{{}}}"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else if (((id).equals(tuple_struct_id))){
(output = String("("));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(")"));
}
else if (((id).equals(weak_ptr_struct_id))){
(output = TRY((String::formatted(String("weak {}?"),TRY((((*this).type_name(((args)[static_cast<i64>(0LL)])))))))));
}
else {
const typechecker::CheckedStruct structure = ((*this).get_struct(id));
(output = ((structure).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(arg)))));
}

}
}

(output += String(">"));
}

__jakt_var_120 = output; goto __jakt_label_118;

}
__jakt_label_118:; __jakt_var_120.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_121; {
String output = ((((*this).get_struct(id))).name);
bool first = true;
(output += String("<"));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).type_name(type_id)))));
}

}
}

(output += String(">"));
__jakt_var_121 = output; goto __jakt_label_119;

}
__jakt_label_119:; __jakt_var_121.release_value(); }));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("raw {}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&mut {}"),TRY((((*this).type_name(type_id))))))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<Optional<typechecker::CheckedVariable>> typechecker::CheckedProgram::find_var_in_scope(const typechecker::ScopeId scope_id,const String var) const {
{
typechecker::ScopeId current_scope_id = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current_scope_id))));
const Optional<typechecker::VarId> maybe_var = ((((scope)->vars)).get(var));
if (((maybe_var).has_value())){
return (((*this).get_variable((maybe_var.value()))));
}
if ((!(((((scope)->parent)).has_value())))){
break;
}
(current_scope_id = (((scope)->parent).value()));
}
return (JaktInternal::OptionalNone());
}
}

typechecker::CheckedStruct typechecker::CheckedProgram::get_struct(const typechecker::StructId id) const {
{
return (((((((((*this).modules))[((((id).module)).id)]))->structures))[((id).id)]));
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::CheckedProgram::check_and_extract_weak_ptr(const typechecker::StructId struct_id,const Array<typechecker::TypeId> args) const {
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((struct_id).equals(weak_ptr_struct_id))){
if ((((args).size()) != static_cast<size_t>(1ULL))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("Internal error: Generic type is WeakPtr but there are not exactly 1 type parameter. There are {} parameters."),((args).size()))))))));
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
const NonnullRefPtr<typechecker::Type> inner_type = ((*this).get_type(inner_type_id));
if (((inner_type)->index() == 22 /* Struct */)){
const typechecker::StructId inner_struct_id = (inner_type->get<typechecker::Type::Struct>()).value;
return (inner_struct_id);
}
utility::panic(TRY((String::formatted(String("Internal error: Inner type of WeakPtr is not a struct. It is {}."),inner_type))));
}
else {
return (JaktInternal::OptionalNone());
}

}
}

ErrorOr<Optional<typechecker::EnumId>> typechecker::CheckedProgram::find_enum_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::EnumId> maybe_enum = ((((scope)->enums)).get(name));
if (((maybe_enum).has_value())){
return (maybe_enum);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!(((((child_scope)->namespace_name)).has_value())))){
const Optional<typechecker::EnumId> maybe_enum = ((((child_scope)->enums)).get(name));
if (((maybe_enum).has_value())){
return (maybe_enum);
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

Optional<typechecker::LoadedModule> typechecker::CheckedProgram::get_loaded_module(const String module_name) const {
{
return (((((*this).loaded_modules)).get(module_name)));
}
}

bool typechecker::CheckedProgram::is_signed(const typechecker::TypeId type_id) const {
{
return (((((*this).get_type(type_id)))->is_signed()));
}
}

ErrorOr<NonnullRefPtr<typechecker::Scope>> typechecker::CheckedProgram::get_scope(const typechecker::ScopeId id) const {
{
const size_t max_scope = (JaktInternal::checked_sub<size_t>(((((((((*this).modules))[((((id).module_id)).id)]))->scopes)).size()),static_cast<size_t>(1ULL)));
if ((((id).id) > max_scope)){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("scope_id {} does not exist in module"),id)))))));
}
return (((((((((*this).modules))[((((id).module_id)).id)]))->scopes))[((id).id)]));
}
}

ErrorOr<typechecker::Value> typechecker::Value::copy() const {
{
return (typechecker::Value(TRY((((((*this).impl))->copy()))),((*this).span)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Value::to_checked_expression(typechecker::Interpreter interpreter) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).impl);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Void>();
{
TRY((((interpreter).error(String("Cannot convert void to expression"),((*this).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Boolean>(x,((*this).span)))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U8(x),((*this).span),typechecker::builtin(BuiltinType::U8)))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U16(x),((*this).span),typechecker::builtin(BuiltinType::U16)))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U32(x),((*this).span),typechecker::builtin(BuiltinType::U32)))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U64(x),((*this).span),typechecker::builtin(BuiltinType::U64)))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I8(x),((*this).span),typechecker::builtin(BuiltinType::I8)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I16(x),((*this).span),typechecker::builtin(BuiltinType::I16)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I32(x),((*this).span),typechecker::builtin(BuiltinType::I32)))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I64(x),((*this).span),typechecker::builtin(BuiltinType::I64)))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F32(x),((*this).span),typechecker::builtin(BuiltinType::F32)))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F64(x),((*this).span),typechecker::builtin(BuiltinType::F64)))));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::USize((infallible_integer_cast<u64>((x)))),((*this).span),typechecker::builtin(BuiltinType::Usize)))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::QuotedString>(TRY((utility::escape_for_quotes(x))),((*this).span)))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::CharacterConstant>(TRY((String::formatted(String("{}"),x))),((*this).span)))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>((x)))),((*this).span),typechecker::builtin(BuiltinType::CInt)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::OptionalNone>();
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalNone>(((*this).span),typechecker::unknown_type_id()))));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalSome>(TRY((((value).to_checked_expression(interpreter)))),((*this).span),typechecker::unknown_type_id()))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
Optional<typechecker::FunctionId> const& constructor = __jakt_match_value.constructor;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_122; {
if ((!(((constructor).has_value())))){
TRY((((interpreter).error_with_hint(String("Cannot convert struct to expression without constructor"),((*this).span),String("Given struct cannot be created from its contents in any known way"),((*this).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
Array<NonnullRefPtr<typechecker::CheckedExpression>> materialised_fields = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value field = (_magic_value.value());
{
TRY((((materialised_fields).push(TRY((((field).to_checked_expression(interpreter))))))));
}

}
}

const typechecker::CheckedStruct struct_ = ((((interpreter).program))->get_struct(struct_id));
Array<typechecker::ResolvedNamespace> reversed_namespace = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
Optional<typechecker::ScopeId> scope_id = ((struct_).scope_id);
while (((scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((interpreter).program))->get_scope((scope_id.value())))));
if (((((scope)->namespace_name)).has_value())){
TRY((((reversed_namespace).push(typechecker::ResolvedNamespace((((scope)->namespace_name).value()),JaktInternal::OptionalNone())))));
}
(scope_id = ((scope)->parent));
}
Array<typechecker::ResolvedNamespace> namespace_ = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((reversed_namespace).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((namespace_).push(((reversed_namespace)[(JaktInternal::checked_sub<size_t>(i,static_cast<size_t>(1ULL)))])))));
}

}
}

const String name = ((struct_).name);
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((materialised_fields).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> arg = ((materialised_fields)[i]);
const String label = ((((((interpreter).program))->get_variable(((((struct_).fields))[i])))).name);
TRY((((args).push((Tuple{label, arg})))));
}

}
}

const NonnullRefPtr<typechecker::CheckedFunction> callee = ((((interpreter).program))->get_function((constructor.value())));
const typechecker::CheckedCall call = typechecker::CheckedCall(namespace_,name,args,(TRY((Array<typechecker::TypeId>::create_with({})))),constructor,((struct_).type_id),((callee)->can_throw));
__jakt_var_122 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(call,((*this).span),((struct_).type_id)))); goto __jakt_label_120;

}
__jakt_label_120:; __jakt_var_122.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Class>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
Optional<typechecker::FunctionId> const& constructor = __jakt_match_value.constructor;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_123; {
if ((!(((constructor).has_value())))){
TRY((((interpreter).error_with_hint(String("Cannot convert struct to expression without constructor"),((*this).span),String("Given struct cannot be created from its contents in any known way"),((*this).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::InvalidType))));
}
Array<NonnullRefPtr<typechecker::CheckedExpression>> materialised_fields = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value field = (_magic_value.value());
{
TRY((((materialised_fields).push(TRY((((field).to_checked_expression(interpreter))))))));
}

}
}

const typechecker::CheckedStruct struct_ = ((((interpreter).program))->get_struct(struct_id));
Array<typechecker::ResolvedNamespace> reversed_namespace = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
Optional<typechecker::ScopeId> scope_id = ((struct_).scope_id);
while (((scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((interpreter).program))->get_scope((scope_id.value())))));
if (((((scope)->namespace_name)).has_value())){
TRY((((reversed_namespace).push(typechecker::ResolvedNamespace((((scope)->namespace_name).value()),JaktInternal::OptionalNone())))));
}
(scope_id = ((scope)->parent));
}
Array<typechecker::ResolvedNamespace> namespace_ = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((reversed_namespace).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((namespace_).push(((reversed_namespace)[(JaktInternal::checked_sub<size_t>(i,static_cast<size_t>(1ULL)))])))));
}

}
}

const String name = ((struct_).name);
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((materialised_fields).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> arg = ((materialised_fields)[i]);
const String label = ((((((interpreter).program))->get_variable(((((struct_).fields))[i])))).name);
TRY((((args).push((Tuple{label, arg})))));
}

}
}

const NonnullRefPtr<typechecker::CheckedFunction> callee = ((((interpreter).program))->get_function((constructor.value())));
const typechecker::CheckedCall call = typechecker::CheckedCall(namespace_,name,args,(TRY((Array<typechecker::TypeId>::create_with({})))),constructor,((struct_).type_id),((callee)->can_throw));
__jakt_var_123 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(call,((*this).span),((struct_).type_id)))); goto __jakt_label_121;

}
__jakt_label_121:; __jakt_var_123.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();Array<typechecker::Value> const& values = __jakt_match_value.values;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_124; {
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((values).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value value = (_magic_value.value());
{
TRY((((vals).push(TRY((((value).to_checked_expression(interpreter))))))));
}

}
}

const typechecker::TypeId inner_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((((interpreter).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
default: {
{
utility::panic(String("Expected generic instance of Array while materialising an array"));
}
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_124 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktArray>(vals,JaktInternal::OptionalNone(),((*this).span),type_id,inner_type_id))); goto __jakt_label_122;

}
__jakt_label_122:; __jakt_var_124.release_value(); }));
};/*case end*/
default: {
{
TRY((((interpreter).error(TRY((String::formatted(String("Cannot materialise the type {}"),((*this).impl)))),((*this).span)))));
return Error::from_errno((infallible_integer_cast<i32>((InterpretError::Unimplemented))));
}
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::FunctionId::equals(const typechecker::FunctionId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Module::new_type_variable() {
{
const size_t new_id = ((((*this).types)).size());
TRY((((((*this).types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(TRY((String::formatted(String("T{}"),new_id))))))))));
return (typechecker::TypeId(((*this).id),new_id));
}
}

ErrorOr<typechecker::FunctionId> typechecker::Module::add_function(const NonnullRefPtr<typechecker::CheckedFunction> checked_function) {
{
const typechecker::FunctionId new_id = ((*this).next_function_id());
TRY((((((*this).functions)).push(checked_function))));
return (new_id);
}
}

ErrorOr<typechecker::VarId> typechecker::Module::add_variable(const typechecker::CheckedVariable checked_variable) {
{
const size_t new_id = ((((*this).variables)).size());
TRY((((((*this).variables)).push(checked_variable))));
return (typechecker::VarId(((*this).id),new_id));
}
}

typechecker::FunctionId typechecker::Module::next_function_id() const {
{
return (typechecker::FunctionId(((*this).id),((((*this).functions)).size())));
}
}

bool typechecker::CheckedFunction::is_static() const {
{
if ((((((*this).params)).size()) < static_cast<size_t>(1ULL))){
return (true);
}
return ((((((((((*this).params))[static_cast<i64>(0LL)])).variable)).name) != String("this")));
}
}

bool typechecker::CheckedFunction::is_mutating() const {
{
if ((((((*this).params)).size()) < static_cast<size_t>(1ULL))){
return (false);
}
const typechecker::CheckedVariable first_param_variable = ((((((*this).params))[static_cast<i64>(0LL)])).variable);
return (((((first_param_variable).name) == String("this")) && ((first_param_variable).is_mutable)));
}
}

parser::ParsedFunction typechecker::CheckedFunction::to_parsed_function() const {
{
if ((!(((((*this).parsed_function)).has_value())))){
utility::panic(String("to_parsed_function() called on a synthetic function"));
}
return ((((*this).parsed_function).value()));
}
}

bool typechecker::EnumId::equals(const typechecker::EnumId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

bool typechecker::StructId::equals(const typechecker::StructId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

bool typechecker::ScopeId::equals(const typechecker::ScopeId other) const {
{
return (((((((*this).module_id)).id) == ((((other).module_id)).id)) && (((*this).id) == ((other).id))));
}
}

bool typechecker::Typechecker::is_floating(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_floating(type_id)));
}
}

ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>> typechecker::Typechecker::typecheck_match_body(const parser::ParsedMatchBody body,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,Dictionary<String,String>& generic_inferences,const Optional<typechecker::TypeId> final_result_type,const utility::Span span) {
{
Optional<typechecker::TypeId> result_type = final_result_type;
const typechecker::CheckedMatchBody checked_match_body = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedMatchBody, ErrorOr<Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchBody::Block>();
parser::ParsedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedMatchBody> __jakt_var_125; {
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode))));
if ((((((checked_block).control_flow)).may_return()) || ((((checked_block).yielded_type)).has_value()))){
const typechecker::TypeId block_type_id = ((checked_block).yielded_type).value_or_lazy_evaluated([&] { return typechecker::void_type_id(); });
const utility::Span yield_span = ((block).find_yield_span()).value_or_lazy_evaluated([&] { return span; });
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),block_type_id,generic_inferences,yield_span))));
}
else {
(result_type = block_type_id);
}

}
Optional<typechecker::CheckedMatchBody> final_body = JaktInternal::OptionalNone();
if ((((((checked_block).yielded_type)).has_value()) && (!(((((checked_block).control_flow)).never_returns()))))){
(final_body = typename typechecker::CheckedMatchBody::Expression(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Block>(checked_block,span,(((checked_block).yielded_type).value()))))));
}
else {
(final_body = typename typechecker::CheckedMatchBody::Block(checked_block));
}

__jakt_var_125 = (final_body.value()); goto __jakt_label_123;

}
__jakt_label_123:; __jakt_var_125.release_value(); }));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchBody::Expression>();
NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedMatchBody> __jakt_var_126; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expression = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,result_type))));
if (((result_type).has_value())){
TRY((((*this).check_types_for_compat((result_type.value()),typechecker::expression_type(checked_expression),generic_inferences,span))));
}
else {
(result_type = typechecker::expression_type(checked_expression));
}

__jakt_var_126 = typename typechecker::CheckedMatchBody::Expression(checked_expression); goto __jakt_label_124;

}
__jakt_label_124:; __jakt_var_126.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return ((Tuple{checked_match_body, result_type}));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_predecl(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const size_t module_struct_len = ((((((*this).current_module()))->structures)).size());
const size_t module_enum_len = ((((((*this).current_module()))->enums)).size());
size_t struct_index = static_cast<size_t>(0ULL);
size_t enum_index = static_cast<size_t>(0ULL);
{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,((struct_index++)),module_struct_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
TRY((((*this).typecheck_struct_predecl_initial(parsed_record,((struct_index++)),module_struct_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,((enum_index++)),module_enum_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
TRY((((*this).typecheck_enum_predecl_initial(parsed_record,((enum_index++)),module_enum_len,scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedNamespace> _magic = ((((parsed_namespace).namespaces)).iterator());
for (;;){
Optional<parser::ParsedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedNamespace namespace_ = (_magic_value.value());
{
String debug_name = String("namespace(");
if (((((namespace_).name)).has_value())){
(debug_name += (((namespace_).name).value()));
}
else {
(debug_name += String("unnamed-namespace"));
}

(debug_name += String(")"));
const typechecker::ScopeId namespace_scope_id = TRY((((*this).create_scope(scope_id,false,debug_name))));
NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(namespace_scope_id))));
(((child_scope)->namespace_name) = ((namespace_).name));
(((child_scope)->import_path_if_extern) = ((namespace_).import_path_if_extern));
NonnullRefPtr<typechecker::Scope> parent_scope = TRY((((*this).get_scope(scope_id))));
TRY((((((parent_scope)->children)).push(namespace_scope_id))));
TRY((((*this).typecheck_namespace_predecl(namespace_,namespace_scope_id))));
}

}
}

(struct_index = static_cast<size_t>(0ULL));
(enum_index = static_cast<size_t>(0ULL));
{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord parsed_record = (_magic_value.value());
{
const typechecker::StructId struct_id = typechecker::StructId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(struct_index,module_struct_len)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
((struct_index++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
TRY((((*this).typecheck_struct_predecl(parsed_record,struct_id,scope_id))));
((struct_index++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
((enum_index++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
TRY((((*this).typecheck_enum_predecl(parsed_record,enum_id,scope_id))));
((enum_index++));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_set(const Array<NonnullRefPtr<parser::ParsedExpression>> values,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
Optional<utility::Span> inner_type_span = JaktInternal::OptionalNone();
Array<NonnullRefPtr<typechecker::CheckedExpression>> output = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
Optional<typechecker::TypeId> inner_hint = JaktInternal::OptionalNone();
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_value);
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
if ((((current_value_type_id).equals(typechecker::void_type_id())) || ((current_value_type_id).equals(typechecker::unknown_type_id())))){
TRY((((*this).error(String("Cannot create a set with values of type void"),((value)->span())))));
}
(inner_type_id = current_value_type_id);
(inner_type_span = ((value)->span()));
}
else if ((!(((inner_type_id).equals(current_value_type_id))))){
const String set_type_name = TRY((((*this).type_name(inner_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in set"),TRY((((*this).type_name(current_value_type_id)))),set_type_name))),((value)->span()),TRY((String::formatted(String("Set was inferred to store type '{}' here"),set_type_name))),(inner_type_span.value())))));
}
TRY((((output).push(checked_value))));
}

}
}

if ((((inner_type_id).equals(typechecker::unknown_type_id())) && (((type_hint).has_value()) && (!((((type_hint.value())).equals(typechecker::unknown_type_id()))))))){
if (((((*this).get_type((type_hint.value()))))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(set_struct_id))){
(inner_type_id = ((args)[static_cast<i64>(0LL)]));
}
else {
utility::panic(String("expected Set struct"));
}

}
else {
utility::panic(String("expected Set struct"));
}

}
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
TRY((((*this).error(String("Cannot infer generic type for Set<T>"),span))));
}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(set_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktSet>(output,span,type_id,inner_type_id))));
}
}

bool typechecker::Typechecker::is_integer(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_integer(type_id)));
}
}

ErrorOr<void> typechecker::Typechecker::dump_try_hint(const utility::Span span) const {
{
outln(String("{{\"type\":\"try\",\"file_id\":{},\"position\":{}}}"),((((span).file_id)).id),((span).start));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_call(const parser::ParsedCall call,const typechecker::ScopeId caller_scope_id,const utility::Span span,const Optional<NonnullRefPtr<typechecker::CheckedExpression>> this_expr,const Optional<typechecker::StructOrEnumId> parent_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const bool must_be_enum_constructor) {
{
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
typechecker::TypeId return_type = typechecker::builtin(BuiltinType::Void);
Array<typechecker::TypeId> generic_arguments = (TRY((Array<typechecker::TypeId>::create_with({}))));
bool callee_throws = false;
Array<typechecker::ResolvedNamespace> resolved_namespaces = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
Optional<typechecker::FunctionId> resolved_function_id = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> maybe_this_type_id = JaktInternal::OptionalNone();
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
Optional<typechecker::FunctionId> generic_checked_function_to_instantiate = JaktInternal::OptionalNone();
{
ArrayIterator<String> _magic = ((((call).namespace_)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
TRY((((resolved_namespaces).push(typechecker::ResolvedNamespace(name,JaktInternal::OptionalNone())))));
}

}
}

const typechecker::ScopeId callee_scope_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ScopeId,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((parent_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::ScopeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (parent_id.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_struct(id))).scope_id));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((*this).get_enum(id))).scope_id));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(caller_scope_id);
}
}()))
;
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("println")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprint")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("format")) {
{
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> arg = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = TRY((((*this).typecheck_expression(((arg).get<2>()),caller_scope_id,safety_mode,JaktInternal::OptionalNone()))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

if ((((call).name) == String("format"))){
(return_type = typechecker::builtin(BuiltinType::String));
(callee_throws = true);
}
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
(resolved_function_id = TRY((((*this).resolve_call(call,resolved_namespaces,span,callee_scope_id,must_be_enum_constructor)))));
if ((!(((resolved_function_id).has_value())))){
Array<typechecker::TypeId> checked_type_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,caller_scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(typechecker::CheckedCall(resolved_namespaces,((call).name),args,checked_type_args,resolved_function_id,return_type,callee_throws),span,return_type))));
}
const typechecker::FunctionId function_id = (resolved_function_id.value());
const NonnullRefPtr<typechecker::CheckedFunction> callee = ((*this).get_function(function_id));
(callee_throws = ((callee)->can_throw));
(return_type = ((callee)->return_type_id));
const typechecker::ScopeId scope_containing_callee = (((TRY((((*this).get_scope(((callee)->function_scope_id))))))->parent).value());
TRY((((*this).check_method_access(caller_scope_id,scope_containing_callee,callee,span))));
size_t type_arg_index = static_cast<size_t>(0ULL);
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> parsed_type = (_magic_value.value());
{
const typechecker::TypeId checked_type = TRY((((*this).typecheck_typename(parsed_type,caller_scope_id,JaktInternal::OptionalNone()))));
if ((((((callee)->generic_params)).size()) <= type_arg_index)){
TRY((((*this).error(String("Trying to access generic parameter out of bounds"),((parsed_type)->span())))));
continue;
}
const typechecker::TypeId typevar_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = ((((callee)->generic_params))[type_arg_index]);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
TRY((((generic_inferences).set(TRY((((typevar_type_id).to_string()))),TRY((((checked_type).to_string())))))));
({auto& _jakt_ref = type_arg_index;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}

}
}

size_t arg_offset = static_cast<size_t>(0ULL);
if (((this_expr).has_value())){
const typechecker::TypeId type_id = typechecker::expression_type((this_expr.value()));
(maybe_this_type_id = type_id);
const NonnullRefPtr<typechecker::Type> param_type = ((*this).get_type(type_id));
if (((param_type)->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (param_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (param_type->get<typechecker::Type::GenericInstance>()).args;
const typechecker::CheckedStruct structure = ((*this).get_struct(id));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((structure).generic_parameters)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((generic_inferences).set(TRY((((((((structure).generic_parameters))[i])).to_string()))),TRY((((((args)[i])).to_string())))))));
}

}
}

}
if (((callee)->is_static())){
TRY((((*this).error(String("Cannot call static method on an instance of an object"),span))));
}
else {
(arg_offset = static_cast<size_t>(1ULL));
}

if ((((callee)->is_mutating()) && (!(((*this).expression_is_mutable((this_expr.value()))))))){
TRY((((*this).error(String("Cannot call mutating method on an immutable object instance"),span))));
}
}
if ((!(((callee)->is_instantiated)))){
(generic_checked_function_to_instantiate = (function_id));
}
Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>> resolved_args = TRY((((*this).resolve_default_params(((callee)->params),((call).args),caller_scope_id,safety_mode,arg_offset,span))));
if ((((((callee)->params)).size()) == (JaktInternal::checked_add<size_t>(((resolved_args).size()),arg_offset)))){
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>((JaktInternal::checked_sub<size_t>(((((callee)->params)).size()),arg_offset)))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>> name_span_checked_arg_ = ((resolved_args)[i]);
const String name = ((name_span_checked_arg_).get<0>());
const utility::Span span = ((name_span_checked_arg_).get<1>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg = ((name_span_checked_arg_).get<2>());

TRY((((*this).check_types_for_compat(((((((((callee)->params))[(JaktInternal::checked_add<size_t>(i,arg_offset))])).variable)).type_id),typechecker::expression_type(checked_arg),((generic_inferences)),typechecker::expression_span(checked_arg)))));
TRY((((args).push((Tuple{((call).name), checked_arg})))));
}

}
}

}
if ((((type_hint).has_value()) && (!(((((type_hint).value())).equals(typechecker::unknown_type_id())))))){
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
TRY((((*this).check_types_for_compat(return_type,(type_hint.value()),((generic_inferences)),span))));
(((*this).ignore_errors) = old_ignore_errors);
}
(return_type = TRY((((*this).substitute_typevars_in_type(return_type,generic_inferences)))));
if ((((type_hint).has_value()) && (!(((((type_hint).value())).equals(typechecker::unknown_type_id())))))){
TRY((((*this).check_types_for_compat((type_hint.value()),return_type,((generic_inferences)),span))));
}
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((callee)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::FunctionGenericParameter generic_typevar = (_magic_value.value());
{
if (((generic_typevar).index() == 1 /* Parameter */)){
const typechecker::TypeId id = (generic_typevar.get<typechecker::FunctionGenericParameter::Parameter>()).value;
const Optional<String> substitution = ((generic_inferences).get(TRY((((id).to_string())))));
if (((substitution).has_value())){
TRY((((generic_arguments).push(TRY((typechecker::TypeId::from_string((substitution.value()))))))));
}
else {
TRY((((*this).error(String("Not all generic parameters have known types"),span))));
}

}
}

}
}

}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
(return_type = TRY((((*this).substitute_typevars_in_type(return_type,generic_inferences)))));
if ((callee_throws && (!(((TRY((((*this).get_scope(caller_scope_id)))))->can_throw))))){
TRY((((*this).error(String("Call to function that may throw needs to be in a try statement or a function marked as throws"),span))));
}
if (((generic_checked_function_to_instantiate).has_value())){
if (((maybe_this_type_id).has_value())){
(maybe_this_type_id = TRY((((*this).substitute_typevars_in_type((maybe_this_type_id.value()),generic_inferences)))));
}
TRY((((*this).typecheck_and_specialize_generic_function((generic_checked_function_to_instantiate.value()),generic_arguments,callee_scope_id,maybe_this_type_id,generic_inferences))));
}
if ((((*this).dump_try_hints) && callee_throws)){
TRY((((*this).dump_try_hint(span))));
}
const NonnullRefPtr<typechecker::CheckedExpression> checked_call = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(typechecker::CheckedCall(resolved_namespaces,((call).name),args,generic_arguments,resolved_function_id,return_type,callee_throws),span,return_type)));
const bool in_comptime_function = (((((*this).current_function_id)).has_value()) && ((((*this).get_function(((((*this).current_function_id)).value()))))->is_comptime));
if (((!(in_comptime_function)) && (((resolved_function_id).has_value()) && ((((*this).get_function((resolved_function_id.value()))))->is_comptime)))){
typechecker::Interpreter interpreter = typechecker::Interpreter(((*this).compiler),((*this).program),(TRY((Array<utility::Span>::create_with({})))));
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function((resolved_function_id.value())));
Array<typechecker::Value> call_args = (TRY((Array<typechecker::Value>::create_with({}))));
Optional<typechecker::Value> this_argument = JaktInternal::OptionalNone();
NonnullRefPtr<typechecker::InterpreterScope> eval_scope = TRY((typechecker::InterpreterScope::create((TRY((Dictionary<String, typechecker::Value>::create_with_entries({})))),JaktInternal::OptionalNone())));
if (((this_expr).has_value())){
auto __jakt_var_127 = [&]() -> ErrorOr<void> {{
const typechecker::StatementResult evaluated_this = TRY((((interpreter).execute_expression((this_expr.value()),eval_scope))));
if (((evaluated_this).index() == 4 /* JustValue */)){
const typechecker::Value value = (evaluated_this.get<typechecker::StatementResult::JustValue>()).value;
(this_argument = value);
}
else if (((evaluated_this).index() == 1 /* Throw */)){
const typechecker::Value value = (evaluated_this.get<typechecker::StatementResult::Throw>()).value;
TRY((((*this).error(TRY((String::formatted(String("Error executing this expression (evaluation threw {})"),value))),typechecker::expression_span((this_expr.value()))))));
}
else {
TRY((((*this).error(String("Invalid this expression"),typechecker::expression_span((this_expr.value()))))));
}

}

;return {};}();
if (__jakt_var_127.is_error()) {{
TRY((((*this).error(String("Error executing this expression"),typechecker::expression_span((this_expr.value()))))));
}
};
}
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((args).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> argument = (_magic_value.value());
{
const typechecker::StatementResult value = ({ Optional<typechecker::StatementResult> __jakt_var_128;
auto __jakt_var_129 = [&]() -> ErrorOr<typechecker::StatementResult> { return TRY((((interpreter).execute_expression(((argument).get<1>()),eval_scope)))); }();
if (__jakt_var_129.is_error()) {{
TRY((((*this).error(String("Error in argument"),span))));
continue;
}
} else {__jakt_var_128 = __jakt_var_129.release_value();
}
__jakt_var_128.release_value(); });
if (((value).index() == 1 /* Throw */)){
TRY((((*this).error(TRY((String::formatted(String("Compiletime call failed: {}"),value))),typechecker::expression_span(((argument).get<1>()))))));
break;
}
const typechecker::Value evaluated_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::Value, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = value;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(x);
};/*case end*/
default: {
{
return Error::from_errno(static_cast<i32>(69));
}
};/*case end*/
}/*switch end*/
}()
));
TRY((((call_args).push(evaluated_value))));
}

}
}

Optional<typechecker::ExecutionResult> result = JaktInternal::OptionalNone();
auto __jakt_var_130 = [&]() -> ErrorOr<void> {{
(result = TRY((((interpreter).execute((resolved_function_id.value()),resolved_namespaces,this_argument,call_args,span)))));
}

;return {};}();
if (__jakt_var_130.is_error()) {auto error = __jakt_var_130.release_error();{
TRY((((*this).error(TRY((String::formatted(String("Compiletime call failed: {}"),error))),span))));
return (checked_call);
}
};
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Return>();
typechecker::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((x).to_checked_expression(interpreter)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Throw>();
typechecker::Value const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_131; {
TRY((((*this).error(TRY((String::formatted(String("Compiletime call failed: {}"),x))),span))));
__jakt_var_131 = checked_call; goto __jakt_label_126;

}
__jakt_label_126:; __jakt_var_131.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
return (checked_call);
}
}

ErrorOr<bool> typechecker::Typechecker::add_type_to_scope(const typechecker::ScopeId scope_id,const String type_name,const typechecker::TypeId type_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::TypeId> found_type_id = ((((scope)->types)).get(type_name));
if ((((found_type_id).has_value()) && (!((((found_type_id.value())).equals(type_id)))))){
TRY((((*this).error(TRY((String::formatted(String("Redefinition of type {}"),type_name))),span))));
return (false);
}
TRY((((((scope)->types)).set(type_name,type_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_namespaced_var_or_simple_enum_constructor_call(const String name,const Array<String> namespace_,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const utility::Span span) {
{
Array<typechecker::ScopeId> scopes = (TRY((Array<typechecker::ScopeId>::create_with({scope_id}))));
{
ArrayIterator<String> _magic = ((namespace_).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String ns = (_magic_value.value());
{
const typechecker::ScopeId scope = ((scopes)[(JaktInternal::checked_sub<size_t>(((scopes).size()),static_cast<size_t>(1ULL)))]);
const Optional<Tuple<typechecker::ScopeId,bool>> ns_in_scope = TRY((((*this).find_namespace_in_scope(scope,ns))));
const Optional<typechecker::EnumId> enum_in_scope = TRY((((((*this).program))->find_enum_in_scope(scope,ns))));
typechecker::ScopeId next_scope = scope;
if (((ns_in_scope).has_value())){
(next_scope = (((ns_in_scope.value())).get<0>()));
}
else if (((enum_in_scope).has_value())){
(next_scope = ((((*this).get_enum((enum_in_scope.value())))).scope_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Namespace {} not found"),ns))),span))));
}

TRY((((scopes).push(next_scope))));
}

}
}

const typechecker::ScopeId scope = (((scopes).last()).value());
size_t i = static_cast<size_t>(0ULL);
const size_t min_length = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = ((((scopes).size()) <= ((namespace_).size())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((scopes).size()));
}
else {
return JaktInternal::ExplicitValue(((namespace_).size()));
}
}()))
;
Array<typechecker::CheckedNamespace> checked_namespaces = (TRY((Array<typechecker::CheckedNamespace>::create_with({}))));
while ((i < min_length)){
TRY((((checked_namespaces).push(typechecker::CheckedNamespace(((namespace_)[i]),scope)))));
((i++));
}
const Optional<typechecker::CheckedVariable> var = TRY((((*this).find_var_in_scope(scope,name))));
if (((var).has_value())){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NamespacedVar>(checked_namespaces,(var.value()),span))));
}
const parser::ParsedCall implicit_constructor_call = parser::ParsedCall(namespace_,name,(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({})))));
const NonnullRefPtr<typechecker::CheckedExpression> call_expression = TRY((((*this).typecheck_call(implicit_constructor_call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,true))));
const typechecker::TypeId type_id = typechecker::expression_type(call_expression);
const typechecker::CheckedCall call = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedCall, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *call_expression;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(call);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_call returned something other than a CheckedCall")))));
}
};/*case end*/
}/*switch end*/
}()
));
if (((((call).function_id)).has_value())){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Call>(call,span,type_id))));
}
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),name))),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NamespacedVar>(checked_namespaces,typechecker::CheckedVariable(name,typechecker::unknown_type_id(),false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public()),span))));
}
}

ErrorOr<String> typechecker::Typechecker::type_name(const typechecker::TypeId type_id) const {
{
return (TRY((((((*this).program))->type_name(type_id)))));
}
}

NonnullRefPtr<typechecker::Module> typechecker::Typechecker::current_module() const {
{
return (((((*this).program))->get_module(((*this).current_module_id))));
}
}

ErrorOr<void> typechecker::Typechecker::error_with_hint(const String message,const utility::Span span,const String hint,const utility::Span hint_span) {
{
if ((!(((*this).ignore_errors)))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::MessageWithHint(message,span,hint,hint_span)))));
}
}
return {};
}

ErrorOr<Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>>> typechecker::Typechecker::find_type_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::TypeId> maybe_type = ((((scope)->types)).get(name));
if (((maybe_type).has_value())){
return ((Tuple{(maybe_type.value()), current}));
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!(((((child_scope)->namespace_name)).has_value())))){
const Optional<typechecker::TypeId> maybe_type = ((((child_scope)->types)).get(name));
if (((maybe_type).has_value())){
return ((Tuple{(maybe_type.value()), child_id}));
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>,typechecker::TypeId>> typechecker::Typechecker::typecheck_range(const NonnullRefPtr<parser::ParsedExpression> from,const NonnullRefPtr<parser::ParsedExpression> to,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
NonnullRefPtr<typechecker::CheckedExpression> checked_from = TRY((((*this).typecheck_expression(from,scope_id,safety_mode,JaktInternal::OptionalNone()))));
NonnullRefPtr<typechecker::CheckedExpression> checked_to = TRY((((*this).typecheck_expression(to,scope_id,safety_mode,JaktInternal::OptionalNone()))));
typechecker::TypeId from_type = typechecker::expression_type(checked_from);
typechecker::TypeId to_type = typechecker::expression_type(checked_to);
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_to = TRY((((*this).try_to_promote_constant_expr_to_type(from_type,checked_to,span))));
if (((promoted_to).has_value())){
(checked_to = (promoted_to.value()));
(to_type = typechecker::expression_type(checked_to));
}
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_from = TRY((((*this).try_to_promote_constant_expr_to_type(to_type,checked_from,span))));
if (((promoted_from).has_value())){
(checked_from = (promoted_from.value()));
(from_type = typechecker::expression_type(checked_from));
}
const utility::Span from_span = typechecker::expression_span(checked_from);
const utility::Span to_span = typechecker::expression_span(checked_to);
const Optional<typechecker::TypeId> values_type_id = TRY((((*this).unify(from_type,from_span,to_type,from_span))));
if ((!(((values_type_id).has_value())))){
TRY((((*this).error(String("Range values differ in types"),span))));
}
const typechecker::StructId range_struct_id = TRY((((*this).find_struct_in_prelude(String("Range")))));
const NonnullRefPtr<typechecker::Type> range_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(range_struct_id,(TRY((Array<typechecker::TypeId>::create_with({((values_type_id).value_or(typechecker::unknown_type_id()))})))))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(range_type))));
return ((Tuple{checked_from, checked_to, type_id}));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::find_or_add_type_id(const NonnullRefPtr<typechecker::Type> type) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((module)->types)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t id = (_magic_value.value());
{
if (((((((module)->types))[id]))->equals(type))){
return (typechecker::TypeId(((module)->id),id));
}
}

}
}

}

}
}

TRY((((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->types)).push(type))));
return (typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<Optional<Tuple<typechecker::ScopeId,bool>>> typechecker::Typechecker::find_namespace_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child))));
if (((((child_scope)->namespace_name)).has_value())){
if ((name == ((((child_scope)->namespace_name)).value()))){
return ((Tuple{child, false}));
}
}
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!(((((child_scope)->namespace_name)).has_value())))){
{
ArrayIterator<typechecker::ScopeId> _magic = ((((TRY((((*this).get_scope(child_id)))))->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId scope = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> descendant_scope = TRY((((*this).get_scope(scope))));
if (((((descendant_scope)->namespace_name)).has_value())){
if ((name == ((((descendant_scope)->namespace_name)).value()))){
return ((Tuple{scope, false}));
}
}
}

}
}

}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
const typechecker::ModuleId module_id = ((scope_id).module_id);
const typechecker::ScopeId search_scope_id = typechecker::ScopeId(module_id,static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> search_scope = TRY((((*this).get_scope(search_scope_id))));
const Dictionary<String,typechecker::ModuleId> search_imports = ((search_scope)->imports);
const Optional<typechecker::ModuleId> maybe_import = ((search_imports).get(name));
if (((maybe_import).has_value())){
const typechecker::ModuleId import_module_id = (maybe_import.value());
const typechecker::ScopeId import_scope_id = typechecker::ScopeId(import_module_id,static_cast<size_t>(0ULL));
return ((Tuple{import_scope_id, true}));
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_typename(const NonnullRefPtr<parser::ParsedType> parsed_type,const typechecker::ScopeId scope_id,const Optional<String> name) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *parsed_type;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Reference>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Reference>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::MutableReference>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::MutableReference>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& name = __jakt_match_value.name;
Array<String> const& namespaces = __jakt_match_value.namespaces;
Array<NonnullRefPtr<parser::ParsedType>> const& params = __jakt_match_value.params;
utility::Span const& span = __jakt_match_value.span;
{
typechecker::ScopeId current_namespace_scope_id = scope_id;
{
ArrayIterator<String> _magic = ((namespaces).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String ns = (_magic_value.value());
{
const Optional<Tuple<typechecker::ScopeId,bool>> result = TRY((((*this).find_namespace_in_scope(current_namespace_scope_id,ns))));
if (((result).has_value())){
(current_namespace_scope_id = (((result.value())).get<0>()));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown namespace: '{}'"),ns))),span))));
return (typechecker::unknown_type_id());
}

}

}
}

Array<typechecker::TypeId> generic_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((params).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> param = (_magic_value.value());
{
const typechecker::TypeId checked_arg = TRY((((*this).typecheck_typename(param,scope_id,name))));
TRY((((generic_args).push(checked_arg))));
}

}
}

if (((generic_args).is_empty())){
const NonnullRefPtr<parser::ParsedType> synthetic_typename = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(name,span)));
return (TRY((((*this).typecheck_typename(synthetic_typename,current_namespace_scope_id,name)))));
}
else {
return (TRY((((*this).typecheck_generic_resolved_type(name,generic_args,current_namespace_scope_id,span)))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const Optional<Tuple<typechecker::TypeId,typechecker::ScopeId>> maybe_type_and_scope = TRY((((*this).find_type_scope(scope_id,name))));
if (((maybe_type_and_scope).has_value())){
if ((!((((((maybe_type_and_scope.value())).get<1>())).equals(((*this).prelude_scope_id())))))){
return ((((maybe_type_and_scope.value())).get<0>()));
}
}
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<typechecker::TypeId>>{
auto __jakt_enum_value = (name);
if (__jakt_enum_value == String("i8")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I8));
}
else if (__jakt_enum_value == String("i16")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I16));
}
else if (__jakt_enum_value == String("i32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I32));
}
else if (__jakt_enum_value == String("i64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::I64));
}
else if (__jakt_enum_value == String("u8")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U8));
}
else if (__jakt_enum_value == String("u16")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U16));
}
else if (__jakt_enum_value == String("u32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U32));
}
else if (__jakt_enum_value == String("u64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::U64));
}
else if (__jakt_enum_value == String("f32")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::F32));
}
else if (__jakt_enum_value == String("f64")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::F64));
}
else if (__jakt_enum_value == String("c_char")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CChar));
}
else if (__jakt_enum_value == String("c_int")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::CInt));
}
else if (__jakt_enum_value == String("usize")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Usize));
}
else if (__jakt_enum_value == String("String")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::String));
}
else if (__jakt_enum_value == String("bool")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Bool));
}
else if (__jakt_enum_value == String("void")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
}
else if (__jakt_enum_value == String("never")) {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Never));
}
else {
{
if (((maybe_type_and_scope).has_value())){
return ((((maybe_type_and_scope.value())).get<0>()));
}
TRY((((*this).error(TRY((String::formatted(String("Unknown type {}"),name))),span))));
return (typechecker::unknown_type_id());
}
}
}()))
);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
{
return (typechecker::unknown_type_id());
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktTuple>();Array<NonnullRefPtr<parser::ParsedType>> const& types = __jakt_match_value.types;
utility::Span const& span = __jakt_match_value.span;
{
Array<typechecker::TypeId> checked_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((types).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> parsed_type = (_magic_value.value());
{
TRY((((checked_types).push(TRY((((*this).typecheck_typename(parsed_type,scope_id,name))))))));
}

}
}

const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(tuple_struct_id,checked_types)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::JaktArray>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Dictionary>();NonnullRefPtr<parser::ParsedType> const& key = __jakt_match_value.key;
NonnullRefPtr<parser::ParsedType> const& value = __jakt_match_value.value;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId key_type_id = TRY((((*this).typecheck_typename(key,scope_id,name))));
const typechecker::TypeId value_type_id = TRY((((*this).typecheck_typename(value,scope_id,name))));
const typechecker::StructId dict_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(dict_struct_id,(TRY((Array<typechecker::TypeId>::create_with({key_type_id, value_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Set>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId set_struct_id = TRY((((*this).find_struct_in_prelude(String("Set")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(set_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Optional>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::WeakPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(weakptr_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::RawPtr>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
utility::Span const& span = __jakt_match_value.span;
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner,scope_id,name))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(inner_type_id)))))));
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::GenericType>();String const& name = __jakt_match_value.name;
Array<NonnullRefPtr<parser::ParsedType>> const& generic_parameters = __jakt_match_value.generic_parameters;
utility::Span const& span = __jakt_match_value.span;
{
Array<typechecker::TypeId> checked_inner_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((generic_parameters).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> inner_type = (_magic_value.value());
{
const typechecker::TypeId inner_type_id = TRY((((*this).typecheck_typename(inner_type,scope_id,name))));
TRY((((checked_inner_types).push(inner_type_id))));
}

}
}

return (TRY((((*this).typecheck_generic_resolved_type(name,checked_inner_types,scope_id,span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Function>();Array<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
NonnullRefPtr<parser::ParsedType> const& return_type = __jakt_match_value.return_type;
utility::Span const& span = __jakt_match_value.span;
{
const String function_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<typechecker::TypeId>>{
auto __jakt_enum_value = (((name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((name.value()));
}
else {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_132; {
String default_name = String("");
auto __jakt_var_133 = [&]() -> ErrorOr<void> {{
(default_name = TRY((String::formatted(String("lambda{}"),((((*this).lambda_count)++))))));
}

;return {};}();
if (__jakt_var_133.is_error()) {auto foo = __jakt_var_133.release_error();{
}
};
__jakt_var_132 = default_name; goto __jakt_label_127;

}
__jakt_label_127:; __jakt_var_132.release_value(); }));
}
}()))
;
Array<typechecker::CheckedParameter> checked_params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
bool first = true;
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((checked_params).push(TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))))))));
(first = false);
}

}
}

const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(function_name,span,typename parser::Visibility::Public(),TRY((((*this).typecheck_typename(return_type,scope_id,JaktInternal::OptionalNone())))),((return_type)->span()),checked_params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),scope_id,typename typechecker::BlockControlFlow::MayReturn(),JaktInternal::OptionalNone()),can_throw,typename parser::FunctionType::Normal(),typename parser::FunctionLinkage::Internal(),scope_id,false,JaktInternal::OptionalNone(),false)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(scope_id,((checked_function)->name),function_id,span))));
Array<typechecker::TypeId> param_type_ids = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((param_type_ids).push(TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),scope_id,name))))))));
}

}
}

const typechecker::TypeId return_type_id = TRY((((*this).typecheck_typename(return_type,scope_id,name))));
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Function>(param_type_ids,can_throw,return_type_id))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
TRY((((((*this).compiler))->panic(String("should be unreachable")))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl(const parser::ParsedRecord parsed_record,const typechecker::EnumId enum_id,const typechecker::ScopeId scope_id) {
{
const typechecker::TypeId enum_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id)))))));
const typechecker::ScopeId enum_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((String::formatted(String("enum({})"),((parsed_record).name))))))));
TRY((((*this).add_enum_to_scope(scope_id,((parsed_record).name),enum_id,((parsed_record).name_span)))));
const bool is_extern = ((((parsed_record).definition_linkage)).index() == 1 /* External */);
const typechecker::TypeId underlying_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();NonnullRefPtr<parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_typename(underlying_type,scope_id,JaktInternal::OptionalNone())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::builtin(BuiltinType::Void));
};/*case end*/
}/*switch end*/
}()
));
const bool is_boxed = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
(((((module)->enums))[((enum_id).id)]) = typechecker::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::CheckedEnumVariant>::create_with({})))),enum_scope_id,((parsed_record).definition_linkage),((parsed_record).record_type),underlying_type_id,enum_type_id,is_boxed));
Array<typechecker::TypeId> generic_parameters = ((((((module)->enums))[((enum_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId parameter_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(parameter_type_id))));
TRY((((*this).add_type_to_scope(enum_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
const parser::ParsedFunction func = ((method).parsed_function);
const typechecker::ScopeId method_scope_id = TRY((((*this).create_scope(enum_scope_id,((func).can_throw),TRY((String::formatted(String("method({}::{})"),((parsed_record).name),((func).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-block({}::{})"),((parsed_record).name),((func).name))))))));
const bool is_generic = ((!(((((parsed_record).generic_parameters)).is_empty()))) || (!(((((func).generic_parameters)).is_empty()))));
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((func).name),((func).name_span),((method).visibility),typechecker::unknown_type_id(),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((func).can_throw),((func).type),((func).linkage),method_scope_id,((!(is_generic)) || is_extern),func,((func).is_comptime))));
TRY((((((module)->functions)).push(checked_function))));
const typechecker::FunctionId function_id = typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL))));
Array<typechecker::FunctionGenericParameter> generic_parameters = (TRY((Array<typechecker::FunctionGenericParameter>::create_with({}))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((func).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((generic_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
if ((!(((func).must_instantiate)))){
TRY((((*this).add_type_to_scope(method_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
}

}
}

(((checked_function)->generic_params) = generic_parameters);
{
ArrayIterator<parser::ParsedParameter> _magic = ((((func).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
if ((((((param).variable)).name) == String("this"))){
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),enum_type_id,((((param).variable)).is_mutable),((((param).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable,JaktInternal::OptionalNone())))));
}
else {
const typechecker::TypeId param_type = TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),method_scope_id,((((param).variable)).name)))));
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),param_type,((((param).variable)).is_mutable),((((param).variable)).span),((((((param).variable)).parsed_type))->span()),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable,JaktInternal::OptionalNone())))));
}

}

}
}

TRY((((*this).add_function_to_scope(enum_scope_id,((func).name),function_id,((parsed_record).name_span)))));
const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),method_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
}

}
}

}
return {};
}

ErrorOr<Optional<typechecker::CheckedEnumVariant>> typechecker::Typechecker::get_enum_variant(const typechecker::CheckedEnum enum_,const String variant_name) {
{
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == variant_name)){
return (variant);
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

typechecker::ScopeId typechecker::Typechecker::root_scope_id() const {
{
return (typechecker::ScopeId(typechecker::ModuleId(static_cast<size_t>(1ULL)),static_cast<size_t>(0ULL)));
}
}

ErrorOr<Optional<typechecker::FunctionId>> typechecker::Typechecker::find_function_in_scope(const typechecker::ScopeId parent_scope_id,const String function_name) const {
{
Array<typechecker::ScopeId> visited = (TRY((Array<typechecker::ScopeId>::create_with({}))));
Array<typechecker::ScopeId> queue = (TRY((Array<typechecker::ScopeId>::create_with({parent_scope_id}))));
Optional<typechecker::ScopeId> scope_id = (parent_scope_id);
while ((!(((queue).is_empty())))){
const typechecker::ScopeId scope_id = (((queue).pop()).value());
{
bool was_visited = false;
{
ArrayIterator<typechecker::ScopeId> _magic = ((visited).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId visited_id = (_magic_value.value());
{
if (((visited_id).equals(scope_id))){
(was_visited = true);
break;
}
}

}
}

if (was_visited){
continue;
}
}

TRY((((visited).push(scope_id))));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::FunctionId> maybe_function = ((((scope)->functions)).get(function_name));
if (((maybe_function).has_value())){
return (maybe_function);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_scope_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(child_scope_id))));
if ((!(((((scope)->namespace_name)).has_value())))){
TRY((((queue).push(child_scope_id))));
}
}

}
}

if (((((scope)->parent)).has_value())){
const typechecker::ScopeId parent = (((scope)->parent).value());
if (((parent).equals(scope_id))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("Scope {} is its own parent!"),scope_id)))))));
}
TRY((((queue).push(parent))));
}
}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_loop(const parser::ParsedBlock parsed_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A loop block is not allowed to yield values"),(((parsed_block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Loop>(checked_block,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_defer(const NonnullRefPtr<parser::ParsedStatement> statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const bool was_inside_defer = ((*this).inside_defer);
(((*this).inside_defer) = true);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).inside_defer) = was_inside_defer);
});
const NonnullRefPtr<typechecker::CheckedStatement> checked_statement = TRY((((*this).typecheck_statement(statement,scope_id,safety_mode))));
if (((checked_statement)->index() == 5 /* Block */)){
const typechecker::CheckedBlock block = (checked_statement->get<typechecker::CheckedStatement::Block>()).block;
if (((((block).yielded_type)).has_value())){
TRY((((*this).error(String("yield inside defer is meaningless"),span))));
}
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Defer>(checked_statement,span))));
}
}

ErrorOr<void> typechecker::Typechecker::error(const String message,const utility::Span span) {
{
if ((!(((*this).ignore_errors)))){
TRY((((((((*this).compiler))->errors)).push(typename error::JaktError::Message(message,span)))));
}
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_module(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
TRY((((*this).typecheck_namespace_imports(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_predecl(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_fields(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_constructors(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_function_predecl(parsed_namespace,scope_id))));
TRY((((*this).typecheck_namespace_declarations(parsed_namespace,scope_id))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_declarations(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_declarations(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find struct that has been previous added")))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find struct that has been previous added")))));
}
TRY((((*this).typecheck_struct(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find enum that has been previous added")))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find enum that has been previous added")))));
}
TRY((((*this).typecheck_enum(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

{
ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
(((*this).current_function_id) = TRY((((*this).find_function_in_scope(scope_id,((fun).name))))));
TRY((((*this).typecheck_function(fun,scope_id))));
(((*this).current_function_id) = JaktInternal::OptionalNone());
}

}
}

}
return {};
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::substitute_typevars_in_type(const typechecker::TypeId type_id,const Dictionary<String,String> generic_inferences) {
{
typechecker::TypeId result = TRY((((*this).substitute_typevars_in_type_helper(type_id,generic_inferences))));
for (;;){
const typechecker::TypeId fixed_point = TRY((((*this).substitute_typevars_in_type_helper(type_id,generic_inferences))));
if (((fixed_point).equals(result))){
break;
}
else {
(result = fixed_point);
}

}
return (result);
}
}

ErrorOr<typechecker::StructId> typechecker::Typechecker::find_struct_in_prelude(const String name) const {
{
return (TRY((((((*this).program))->find_struct_in_prelude(name)))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::cast_to_underlying(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const NonnullRefPtr<parser::ParsedType> parsed_type) {
{
const NonnullRefPtr<parser::ParsedExpression> cast_expression = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::TypeCast(typename parser::TypeCast::Infallible(parsed_type)),((expr)->span()))));
return (TRY((((*this).typecheck_expression(cast_expression,scope_id,typename typechecker::SafetyMode::Safe(),JaktInternal::OptionalNone())))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_module_import(const parser::ParsedModuleImport import_,const typechecker::ScopeId scope_id) {
{
typechecker::ModuleId imported_module_id = typechecker::ModuleId(static_cast<size_t>(0ULL));
Optional<typechecker::LoadedModule> maybe_loaded_module = ((((*this).program))->get_loaded_module(((((import_).module_name)).name)));
if ((!(((maybe_loaded_module).has_value())))){
const Optional<NonnullRefPtr<utility::FilePath>> maybe_file_name = TRY((((((*this).compiler))->search_for_path(((((import_).module_name)).name)))));
const NonnullRefPtr<utility::FilePath> file_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<utility::FilePath>,ErrorOr<void>>{
auto __jakt_enum_value = (((maybe_file_name).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((maybe_file_name.value()));
}
else {
return JaktInternal::ExplicitValue(TRY((utility::FilePath::make(TRY((String::formatted(String("{}/{}.jakt"),TRY((((TRY((((*this).get_root_path()))))->dirname()))),((((import_).module_name)).name))))))));
}
}()))
;
const utility::FileId file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
const Optional<parser::ParsedNamespace> parsed_namespace = TRY((((*this).lex_and_parse_file_contents(file_id))));
if ((!(((parsed_namespace).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Module '{}' not found"),((((import_).module_name)).name)))),((((import_).module_name)).span)))));
return {};
}
const typechecker::ModuleId original_current_module_id = ((*this).current_module_id);
(imported_module_id = TRY((((*this).create_module(((((import_).module_name)).name),false)))));
TRY((((((*this).program))->set_loaded_module(((((import_).module_name)).name),typechecker::LoadedModule(imported_module_id,file_id)))));
(((*this).current_module_id) = imported_module_id);
const typechecker::ScopeId imported_scope_id = TRY((((*this).create_scope(((*this).root_scope_id()),false,TRY((String::formatted(String("module({})"),((((import_).module_name)).name))))))));
TRY((((*this).typecheck_module((parsed_namespace.value()),imported_scope_id))));
(((*this).current_module_id) = original_current_module_id);
}
else {
(imported_module_id = (((maybe_loaded_module.value())).module_id));
}

Array<typechecker::ModuleId> current_module_imports = ((((*this).current_module()))->imports);
TRY((((current_module_imports).push(imported_module_id))));
if (((((import_).import_list)).is_empty())){
Dictionary<String,typechecker::ModuleId> scope_imports = ((TRY((((*this).get_scope(scope_id)))))->imports);
String import_name = ((((import_).module_name)).name);
if (((((import_).alias_name)).has_value())){
(import_name = (((((import_).alias_name).value())).name));
}
TRY((((scope_imports).set(import_name,imported_module_id))));
}
else {
const typechecker::ScopeId import_scope_id = typechecker::ScopeId(imported_module_id,static_cast<size_t>(0ULL));
{
ArrayIterator<parser::ImportName> _magic = ((((import_).import_list)).iterator());
for (;;){
Optional<parser::ImportName> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ImportName imported_name = (_magic_value.value());
{
const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_function_id).has_value())){
TRY((((*this).add_function_to_scope(scope_id,((imported_name).name),(maybe_function_id.value()),((imported_name).span)))));
}
const Optional<typechecker::EnumId> maybe_enum_id = TRY((((((*this).program))->find_enum_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_enum_id).has_value())){
TRY((((*this).add_enum_to_scope(scope_id,((imported_name).name),(maybe_enum_id.value()),((imported_name).span)))));
}
const Optional<typechecker::TypeId> maybe_type_id = TRY((((*this).find_type_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_type_id).has_value())){
TRY((((*this).add_type_to_scope(scope_id,((imported_name).name),(maybe_type_id.value()),((imported_name).span)))));
}
const Optional<typechecker::StructId> maybe_struct_id = TRY((((*this).find_struct_in_scope(import_scope_id,((imported_name).name)))));
if (((maybe_struct_id).has_value())){
TRY((((*this).add_struct_to_scope(scope_id,((imported_name).name),(maybe_struct_id.value()),((imported_name).span)))));
}
}

}
}

}

}
return {};
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_binary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs,const parser::BinaryOperator op,const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs,const typechecker::ScopeId scope_id,const utility::Span span) {
{
const typechecker::TypeId lhs_type_id = typechecker::expression_type(checked_lhs);
const typechecker::TypeId rhs_type_id = typechecker::expression_type(checked_rhs);
const utility::Span lhs_span = typechecker::expression_span(checked_lhs);
const utility::Span rhs_span = typechecker::expression_span(checked_rhs);
typechecker::TypeId type_id = typechecker::expression_type(checked_lhs);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescing>();
{
if (((op).index() == 32 /* NoneCoalescingAssign */)){
if (((checked_lhs)->index() == 22 /* Var */)){
const typechecker::CheckedVariable var = (checked_lhs->get<typechecker::CheckedExpression::Var>()).var;
const utility::Span span = (checked_lhs->get<typechecker::CheckedExpression::Var>()).span;
if ((!(((var).is_mutable)))){
TRY((((*this).error_with_hint(String("left-hand side of ??= must be a mutable variable"),span,String("This variable isn't marked as mutable"),((var).definition_span)))));
return (typechecker::unknown_type_id());
}
}
else {
TRY((((*this).error(String("left-hand side of ??= must be a mutable variable"),span))));
return (typechecker::unknown_type_id());
}

}
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (lhs_type_id);
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (inner_type_id);
}
}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

TRY((((*this).error(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 32: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NoneCoalescingAssign>();
{
if (((op).index() == 32 /* NoneCoalescingAssign */)){
if (((checked_lhs)->index() == 22 /* Var */)){
const typechecker::CheckedVariable var = (checked_lhs->get<typechecker::CheckedExpression::Var>()).var;
const utility::Span span = (checked_lhs->get<typechecker::CheckedExpression::Var>()).span;
if ((!(((var).is_mutable)))){
TRY((((*this).error_with_hint(String("left-hand side of ??= must be a mutable variable"),span,String("This variable isn't marked as mutable"),((var).definition_span)))));
return (typechecker::unknown_type_id());
}
}
else {
TRY((((*this).error(String("left-hand side of ??= must be a mutable variable"),span))));
return (typechecker::unknown_type_id());
}

}
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
if (((lhs_type_id).equals(rhs_type_id))){
return (lhs_type_id);
}
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((inner_type_id).equals(rhs_type_id))){
return (inner_type_id);
}
}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

}
else {
TRY((((*this).error_with_hint(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span,String("Left side of ?? must be an Optional but isn't"),lhs_span))));
}

TRY((((*this).error(TRY((String::formatted(String("None coalescing (??) with incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary comparison between incompatible types ({} vs {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
{
if ((!(((lhs_type_id).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("left side of logical binary operation is not a boolean"),lhs_span))));
}
if ((!(((rhs_type_id).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("right side of logical binary operation is not a boolean"),rhs_span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
{
if ((!(((lhs_type_id).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("left side of logical binary operation is not a boolean"),lhs_span))));
}
if ((!(((rhs_type_id).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("right side of logical binary operation is not a boolean"),rhs_span))));
}
(type_id = typechecker::builtin(BuiltinType::Bool));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
{
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
return (lhs_type_id);
}
if (((checked_rhs)->index() == 23 /* OptionalNone */)){
const utility::Span span = (checked_rhs->get<typechecker::CheckedExpression::OptionalNone>()).span;
const typechecker::TypeId type_id = (checked_rhs->get<typechecker::CheckedExpression::OptionalNone>()).type_id;
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(TRY((((*this).find_struct_in_prelude(String("Optional")))))))){
return (lhs_type_id);
}
}
}
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
if (((lhs_type)->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (lhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (lhs_type->get<typechecker::Type::GenericInstance>()).args;
if (((((((((*this).program))->get_struct(id))).name) == String("Optional")) && ((typechecker::expression_type(checked_rhs)).equals(((args)[static_cast<i64>(0LL)]))))){
return (lhs_type_id);
}
if (((((((((*this).program))->get_struct(id))).name) == String("WeakPtr")) && ((typechecker::expression_type(checked_rhs)).equals(((args)[static_cast<i64>(0LL)]))))){
return (lhs_type_id);
}
}
const Optional<typechecker::TypeId> result = TRY((((*this).unify(rhs_type_id,rhs_span,lhs_type_id,lhs_span))));
if ((!(((result).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
return (((result).value_or(lhs_type_id)));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
{
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
if (((((*this).get_type(lhs_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(lhs_type_id))->get<typechecker::Type::GenericInstance>()).args;
if ((((id).equals(weak_ptr_struct_id)) && ((((*this).get_type(((args)[static_cast<i64>(0LL)]))))->index() == 22 /* Struct */))){
const typechecker::StructId lhs_struct_id = (((*this).get_type(((args)[static_cast<i64>(0LL)])))->get<typechecker::Type::Struct>()).value;
if (((((*this).get_type(rhs_type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId rhs_struct_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::Struct>()).value;
if (((lhs_struct_id).equals(rhs_struct_id))){
return (lhs_type_id);
}
}
}
}
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Assignment between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
if ((!(((*this).expression_is_mutable(checked_lhs))))){
TRY((((*this).error(String("Assignment to immutable variable"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
{
if ((!(((lhs_type_id).equals(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Binary arithmetic operation between incompatible types ({} and {})"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
}
(type_id = lhs_type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (type_id);
}
}

ErrorOr<Optional<typechecker::StructId>> typechecker::Typechecker::find_struct_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
return (TRY((((((*this).program))->find_struct_in_scope(scope_id,name)))));
}
}

ErrorOr<void> typechecker::Typechecker::check_method_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee,const NonnullRefPtr<typechecker::CheckedFunction> method,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((method)->visibility);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
{
if ((!(TRY((((*this).scope_can_access(accessor,accessee))))))){
TRY((((*this).error(TRY((String::formatted(String("Can't access function {} from scope {}, because it is marked private"),((method)->name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();Array<NonnullRefPtr<parser::ParsedType>> const& whitelist = __jakt_match_value.whitelist;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((*this).check_restricted_access(accessor,String("function"),accessee,((method)->name),whitelist,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<typechecker::CheckedBlock> typechecker::Typechecker::typecheck_block(const parser::ParsedBlock parsed_block,const typechecker::ScopeId parent_scope_id,const typechecker::SafetyMode safety_mode) {
{
const bool parent_throws = ((TRY((((*this).get_scope(parent_scope_id)))))->can_throw);
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(parent_scope_id,parent_throws,String("block")))));
typechecker::CheckedBlock checked_block = typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none());
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((parsed_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> parsed_statement = (_magic_value.value());
{
if (((((checked_block).control_flow)).never_returns())){
TRY((((*this).error(String("Unreachable code"),((parsed_statement)->span())))));
}
const NonnullRefPtr<typechecker::CheckedStatement> checked_statement = TRY((((*this).typecheck_statement(parsed_statement,block_scope_id,safety_mode))));
(((checked_block).control_flow) = ((((checked_block).control_flow)).updated(((*this).statement_control_flow(checked_statement)))));
const Optional<utility::Span> yield_span = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<utility::Span>, ErrorOr<typechecker::CheckedBlock>>{
auto&& __jakt_match_variant = *parsed_statement;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((((expr)->span())));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> checked_yield_expression = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<NonnullRefPtr<typechecker::CheckedExpression>>, ErrorOr<typechecker::CheckedBlock>>{
auto&& __jakt_match_variant = *checked_statement;
switch(__jakt_match_variant.index()) {
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
if ((((yield_span).has_value()) && ((checked_yield_expression).has_value()))){
const typechecker::TypeId type_var_type_id = typechecker::expression_type(((checked_yield_expression).value()));
const typechecker::TypeId type_ = TRY((((*this).resolve_type_var(type_var_type_id,block_scope_id))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).check_types_for_compat(((((checked_block).yielded_type)).value()),type_,((generic_inferences)),((yield_span).value())))));
}
else {
(((checked_block).yielded_type) = (type_));
}

}
TRY((((((checked_block).statements)).push(checked_statement))));
}

}
}

if (((((checked_block).yielded_type)).has_value())){
(((checked_block).yielded_type) = (TRY((((*this).substitute_typevars_in_type(((((checked_block).yielded_type)).value()),generic_inferences))))));
}
return (checked_block);
}
}

ErrorOr<Optional<typechecker::TypeId>> typechecker::Typechecker::find_type_in_scope(const typechecker::ScopeId scope_id,const String name) const {
{
typechecker::ScopeId current = scope_id;
for (;;){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(current))));
const Optional<typechecker::TypeId> maybe_type = ((((scope)->types)).get(name));
if (((maybe_type).has_value())){
return (maybe_type);
}
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((*this).get_scope(child_id))));
if ((!(((((child_scope)->namespace_name)).has_value())))){
const Optional<typechecker::TypeId> maybe_type = ((((child_scope)->types)).get(name));
if (((maybe_type).has_value())){
return (maybe_type);
}
}
}

}
}

if (((((scope)->parent)).has_value())){
(current = ((((scope)->parent)).value()));
}
else {
break;
}

}
return (JaktInternal::OptionalNone());
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_function(const parser::ParsedFunction parsed_function,const typechecker::ScopeId parent_scope_id) {
{
if (((!(((((parsed_function).generic_parameters)).is_empty()))) && (!(((parsed_function).must_instantiate))))){
return {};
}
const Optional<typechecker::FunctionId> function_id = TRY((((*this).find_function_in_scope(parent_scope_id,((parsed_function).name)))));
if ((!(((function_id).has_value())))){
TRY((((((*this).compiler))->panic(String("Internal error: missing previously defined function")))));
}
if ((((parsed_function).name) == String("main"))){
TRY((((*this).typecheck_jakt_main(parsed_function))));
}
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function((function_id.value())));
const typechecker::ScopeId function_scope_id = ((checked_function)->function_scope_id);
const parser::FunctionLinkage function_linkage = ((checked_function)->linkage);
Array<typechecker::CheckedVariable> param_vars = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
TRY((((param_vars).push(variable))));
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope(function_scope_id,((variable).name),var_id,((variable).definition_span)))));
}

}
}

typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),function_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
if (((function_return_type_id).equals(typechecker::never_type_id()))){
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(function_scope_id))));
(((scope)->can_throw) = true);
}
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((parsed_function).block),function_scope_id,typename typechecker::SafetyMode::Safe()))));
(function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),function_scope_id,JaktInternal::OptionalNone())))));
const typechecker::TypeId UNKNOWN_TYPE_ID = typechecker::unknown_type_id();
const typechecker::TypeId VOID_TYPE_ID = typechecker::void_type_id();
typechecker::TypeId return_type_id = VOID_TYPE_ID;
if (((function_return_type_id).equals(UNKNOWN_TYPE_ID))){
(return_type_id = ((*this).infer_function_return_type(block)));
}
else {
(return_type_id = TRY((((*this).resolve_type_var(function_return_type_id,function_scope_id)))));
}

const bool external_linkage = ((function_linkage).index() == 1 /* External */);
if (((!(external_linkage)) && ((!(((return_type_id).equals(VOID_TYPE_ID)))) && (!(((((block).control_flow)).always_transfers_control())))))){
if ((((return_type_id).equals(typechecker::never_type_id())) && (!(((((block).control_flow)).never_returns()))))){
TRY((((*this).error(String("Control reaches end of never-returning function"),((parsed_function).name_span)))));
}
else if ((!(((((block).control_flow)).never_returns())))){
TRY((((*this).error(String("Control reaches end of non-void function"),((parsed_function).name_span)))));
}
}
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_inline_cpp(const parser::ParsedBlock block,const utility::Span span,const typechecker::SafetyMode safety_mode) {
{
if (((safety_mode).index() == 0 /* Safe */)){
TRY((((*this).error(String("Use of inline cpp block outside of unsafe block"),span))));
}
Array<String> strings = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> statement = (_magic_value.value());
{
if (((statement)->index() == 0 /* Expression */)){
const NonnullRefPtr<parser::ParsedExpression> expr = (statement->get<parser::ParsedStatement::Expression>()).expr;
if (((expr)->index() == 2 /* QuotedString */)){
const String val = (expr->get<parser::ParsedExpression::QuotedString>()).val;
const utility::Span span = (expr->get<parser::ParsedExpression::QuotedString>()).span;
TRY((((strings).push(val))));
}
else {
TRY((((*this).error(String("Expected block of strings"),span))));
}

}
else {
TRY((((*this).error(String("Expected block of strings"),span))));
}

}

}
}

return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::InlineCpp>(strings,span))));
}
}

ErrorOr<void> typechecker::Typechecker::check_restricted_access(const typechecker::ScopeId accessor,const String accessee_kind,const typechecker::ScopeId accessee,const String name,const Array<NonnullRefPtr<parser::ParsedType>> whitelist,const utility::Span span) {
{
if ((!(((((*this).current_struct_type_id)).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from scope {}, because {} is not in the restricted whitelist"),accessee_kind,name,((TRY((((*this).get_scope(accessor)))))->namespace_name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
return {};
}
const typechecker::TypeId own_type_id = (((*this).current_struct_type_id).value());
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(own_type_id));
if (((type)->index() == 22 /* Struct */)){
const typechecker::StructId id = (type->get<typechecker::Type::Struct>()).value;
bool was_whitelisted = false;
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((whitelist).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> whitelisted_type = (_magic_value.value());
{
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(whitelisted_type,accessee,JaktInternal::OptionalNone()))));
if (((type_id).equals(own_type_id))){
(was_whitelisted = true);
break;
}
}

}
}

if ((!(was_whitelisted))){
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from {}, because {} is not in the restricted whitelist"),accessee_kind,name,((((*this).get_struct(id))).name),((((*this).get_struct(id))).name)))),span))));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Can't access {} {} from scope {}, because it is not in the restricted whitelist"),accessee_kind,name,((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::include_prelude() {
{
const String module_name = String("__prelude__");
const NonnullRefPtr<utility::FilePath> file_name = TRY((utility::FilePath::make(module_name)));
const Array<u8> file_contents = (TRY((Array<u8>::create_with({static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(83), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(79), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(83), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(83), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(65), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(114), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(98), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(117), static_cast<u8>(109), static_cast<u8>(98), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(54), static_cast<u8>(52), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(121), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(119), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(66), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(112), static_cast<u8>(111), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(115), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(106), static_cast<u8>(115), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(66), static_cast<u8>(117), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(87), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(107), static_cast<u8>(80), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(117), static_cast<u8>(112), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(40), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(75), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(121), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(75), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(66), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(68), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(121), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(75), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(112), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(118), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(86), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(99), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(121), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(104), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(60), static_cast<u8>(65), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(73), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(60), static_cast<u8>(86), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(63), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(69), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(95), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(51), static_cast<u8>(50), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(69), static_cast<u8>(114), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(95), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(95), static_cast<u8>(119), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(117), static_cast<u8>(102), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(119), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(100), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(115), static_cast<u8>(105), static_cast<u8>(122), static_cast<u8>(101), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(108), static_cast<u8>(108), static_cast<u8>(40), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(119), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(91), static_cast<u8>(117), static_cast<u8>(56), static_cast<u8>(93), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(98), static_cast<u8>(108), static_cast<u8>(105), static_cast<u8>(99), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(105), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(115), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(83), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(111), static_cast<u8>(108), static_cast<u8>(10), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(98), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(116), static_cast<u8>(40), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(110), static_cast<u8>(101), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(115), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(117), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(115), static_cast<u8>(95), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(97), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(85), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(85), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(97), static_cast<u8>(100), static_cast<u8>(100), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(101), static_cast<u8>(99), static_cast<u8>(107), static_cast<u8>(101), static_cast<u8>(100), static_cast<u8>(95), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(108), static_cast<u8>(60), static_cast<u8>(84), static_cast<u8>(62), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(98), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(84), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(47), static_cast<u8>(47), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(88), static_cast<u8>(77), static_cast<u8>(69), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(82), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(118), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(114), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(108), static_cast<u8>(117), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(67), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(115), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(101), static_cast<u8>(32), static_cast<u8>(119), static_cast<u8>(111), static_cast<u8>(114), static_cast<u8>(107), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(103), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(103), static_cast<u8>(97), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(117), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(76), static_cast<u8>(69), static_cast<u8>(32), static_cast<u8>(123), static_cast<u8>(125), static_cast<u8>(10), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(111), static_cast<u8>(112), static_cast<u8>(101), static_cast<u8>(110), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(114), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(44), static_cast<u8>(32), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(111), static_cast<u8>(100), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(76), static_cast<u8>(69), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(103), static_cast<u8>(101), static_cast<u8>(116), static_cast<u8>(99), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(76), static_cast<u8>(69), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(99), static_cast<u8>(108), static_cast<u8>(111), static_cast<u8>(115), static_cast<u8>(101), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(76), static_cast<u8>(69), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(101), static_cast<u8>(111), static_cast<u8>(102), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(109), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(105), static_cast<u8>(108), static_cast<u8>(101), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(70), static_cast<u8>(73), static_cast<u8>(76), static_cast<u8>(69), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(112), static_cast<u8>(117), static_cast<u8>(116), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10), static_cast<u8>(101), static_cast<u8>(120), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(114), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(102), static_cast<u8>(117), static_cast<u8>(110), static_cast<u8>(99), static_cast<u8>(116), static_cast<u8>(105), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(115), static_cast<u8>(121), static_cast<u8>(115), static_cast<u8>(116), static_cast<u8>(101), static_cast<u8>(109), static_cast<u8>(40), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(111), static_cast<u8>(110), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(111), static_cast<u8>(109), static_cast<u8>(109), static_cast<u8>(97), static_cast<u8>(110), static_cast<u8>(100), static_cast<u8>(58), static_cast<u8>(32), static_cast<u8>(114), static_cast<u8>(97), static_cast<u8>(119), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(99), static_cast<u8>(104), static_cast<u8>(97), static_cast<u8>(114), static_cast<u8>(41), static_cast<u8>(32), static_cast<u8>(45), static_cast<u8>(62), static_cast<u8>(32), static_cast<u8>(99), static_cast<u8>(95), static_cast<u8>(105), static_cast<u8>(110), static_cast<u8>(116), static_cast<u8>(10)}))));
const Optional<utility::FileId> old_file_id = ((((*this).compiler))->current_file);
const Array<u8> old_file_contents = ((((*this).compiler))->current_file_contents);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{{
(((((*this).compiler))->current_file) = old_file_id);
(((((*this).compiler))->current_file_contents) = old_file_contents);
}

});
const utility::FileId file_id = TRY((((((*this).compiler))->get_file_id_or_register(file_name))));
(((((*this).compiler))->current_file) = file_id);
(((((*this).compiler))->current_file_contents) = file_contents);
const typechecker::ModuleId prelude_module_id = TRY((((*this).create_module(module_name,false))));
(((*this).current_module_id) = prelude_module_id);
TRY((((((*this).program))->set_loaded_module(module_name,typechecker::LoadedModule(prelude_module_id,file_id)))));
const typechecker::ScopeId prelude_scope_id = TRY((((*this).create_scope(JaktInternal::OptionalNone(),false,String("prelude")))));
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln(String("{:#}"),parsed_namespace);
}
((((*this).compiler))->dbg_println(TRY((String::formatted(String("before typechecking parsed prelude, modules `{}`"),((((*this).program))->modules))))));
TRY((((*this).typecheck_module(parsed_namespace,prelude_scope_id))));
}
return {};
}

ErrorOr<bool> typechecker::Typechecker::add_function_to_scope(const typechecker::ScopeId parent_scope_id,const String name,const typechecker::FunctionId function_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(parent_scope_id))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> existing_function = (_magic_value.value());
{
if ((name == ((existing_function).get<0>()))){
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((*this).get_function(((existing_function).get<1>())));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Redefinition of function {}"),name))),span,String("previous definition here"),((function_)->name_span)))));
return (false);
}
}

}
}

TRY((((((scope)->functions)).set(name,function_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_while(const NonnullRefPtr<parser::ParsedExpression> condition,const parser::ParsedBlock block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A while block is not allowed to yield values"),(((block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::While>(checked_condition,checked_block,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_expression_and_dereference_if_needed(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint,const utility::Span span) {
{
NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,type_hint))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
(checked_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,typename typechecker::CheckedUnaryOperator::Dereference(),span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
(checked_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,typename typechecker::CheckedUnaryOperator::Dereference(),span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (checked_expr);
}
}

ErrorOr<NonnullRefPtr<utility::FilePath>> typechecker::Typechecker::get_root_path() const {
{
const utility::FileId file_id = (((((((*this).program))->get_loaded_module(String("Root Module"))).value())).file_id);
return ((TRY((((((*this).compiler))->get_file_path(file_id)))).value()));
}
}

ErrorOr<bool> typechecker::Typechecker::scope_can_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee) const {
{
if (((accessor).equals(accessee))){
return (true);
}
NonnullRefPtr<typechecker::Scope> accessor_scope = TRY((((*this).get_scope(accessor))));
while (((((accessor_scope)->parent)).has_value())){
const typechecker::ScopeId parent = (((accessor_scope)->parent).value());
if (((parent).equals(accessee))){
return (true);
}
(accessor_scope = TRY((((*this).get_scope(parent)))));
}
return (false);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_fields(const parser::ParsedRecord record,const typechecker::StructId struct_id) {
{
typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
const typechecker::ScopeId checked_struct_scope_id = ((((*this).get_struct(struct_id))).scope_id);
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
const Array<parser::ParsedField> parsed_fields = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<parser::ParsedField>, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();Array<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();Array<parser::ParsedField> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(fields);
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_struct_fields cannot handle non-structs")))));
}
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<parser::ParsedField> _magic = ((parsed_fields).iterator());
for (;;){
Optional<parser::ParsedField> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedField unchecked_member = (_magic_value.value());
{
const parser::ParsedVarDecl parsed_var_decl = ((unchecked_member).var_decl);
const typechecker::TypeId checked_member_type = TRY((((*this).typecheck_typename(((parsed_var_decl).parsed_type),checked_struct_scope_id,((parsed_var_decl).name)))));
TRY((((*this).check_that_type_doesnt_contain_reference(checked_member_type,((((parsed_var_decl).parsed_type))->span())))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((parsed_var_decl).name),checked_member_type,((parsed_var_decl).is_mutable),((parsed_var_decl).span),JaktInternal::OptionalNone(),((unchecked_member).visibility))))));
TRY((((((structure).fields)).push(var_id))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_expression(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedStruct>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
String const& field = __jakt_match_value.field;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_indexed_struct(expr,field,scope_id,is_optional,safety_mode,span)))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Boolean>();bool const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Boolean>(val,span))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NumericConstant>();lexer::NumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_134; {
__jakt_var_134 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I8>();
i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I8(val),span,typechecker::builtin(BuiltinType::I8)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I16>();
i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I16(val),span,typechecker::builtin(BuiltinType::I16)))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I32>();
i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I32(val),span,typechecker::builtin(BuiltinType::I32)))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::I64>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::I64(val),span,typechecker::builtin(BuiltinType::I64)))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U8>();
u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U8(val),span,typechecker::builtin(BuiltinType::U8)))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U16>();
u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U16(val),span,typechecker::builtin(BuiltinType::U16)))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U32>();
u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U32(val),span,typechecker::builtin(BuiltinType::U32)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::U64>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::U64(val),span,typechecker::builtin(BuiltinType::U64)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::USize>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::USize(val),span,typechecker::builtin(BuiltinType::Usize)))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::F32>();
f32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F32(val),span,typechecker::builtin(BuiltinType::F32)))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename lexer::NumericConstant::F64>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(typename typechecker::CheckedNumericConstant::F64(val),span,typechecker::builtin(BuiltinType::F64)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_128;

}
__jakt_label_128:; __jakt_var_134.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::CharacterConstant>(val,span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::SingleQuotedByteString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::ByteConstant>(val,span))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::QuotedString>();String const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_135; {
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
TRY((((*this).unify_with_type(typechecker::builtin(BuiltinType::String),type_hint,span))));
__jakt_var_135 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::QuotedString>(val,span))); goto __jakt_label_129;

}
__jakt_label_129:; __jakt_var_135.release_value(); }));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Call>();parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_136; {
__jakt_var_136 = TRY((((*this).typecheck_call(call,scope_id,span,JaktInternal::OptionalNone(),JaktInternal::OptionalNone(),safety_mode,type_hint,false)))); goto __jakt_label_130;

}
__jakt_label_130:; __jakt_var_136.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::MethodCall>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedCall const& call = __jakt_match_value.call;
utility::Span const& span = __jakt_match_value.span;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_137; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId checked_expr_type_id = typechecker::expression_type(checked_expr);
bool found_optional = false;
const typechecker::StructOrEnumId parent_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(checked_expr_type_id));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(id));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(TRY((((*this).find_struct_in_prelude(String("String")))))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_138; {
__jakt_var_138 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (is_optional);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_139; {
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
Optional<typechecker::StructOrEnumId> struct_id = JaktInternal::OptionalNone();
if ((!(((id).equals(optional_struct_id))))){
TRY((((*this).error(TRY((String::formatted(String("Can't use {} as an optional type in optional chained call"),((((*this).get_struct(id))).name)))),span))));
}
else {
(found_optional = true);
(struct_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::StructOrEnumId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(((args)[static_cast<i64>(0LL)])));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(struct_id));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(struct_id));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<typechecker::StructOrEnumId> __jakt_var_140; {
TRY((((*this).error(String("Can't use non-struct type as an optional type in optional chained call"),span))));
(found_optional = false);
__jakt_var_140 = typename typechecker::StructOrEnumId::Struct(optional_struct_id); goto __jakt_label_134;

}
__jakt_label_134:; __jakt_var_140.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}

__jakt_var_139 = struct_id.value_or_lazy_evaluated([&] { return typename typechecker::StructOrEnumId::Struct(optional_struct_id); }); goto __jakt_label_133;

}
__jakt_label_133:; __jakt_var_139.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Struct(id));
}
}()))
; goto __jakt_label_132;

}
__jakt_label_132:; __jakt_var_138.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(typename typechecker::StructOrEnumId::Enum(id));
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("no methods available on value (type: {})"),TRY((((*this).type_name(checked_expr_type_id))))))),typechecker::expression_span(checked_expr)))));
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> checked_args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,typechecker::CheckedCall((TRY((Array<typechecker::ResolvedNamespace>::create_with({})))),((call).name),checked_args,(TRY((Array<typechecker::TypeId>::create_with({})))),JaktInternal::OptionalNone(),typechecker::unknown_type_id(),false),span,is_optional,typechecker::unknown_type_id()))));
}
};/*case end*/
}/*switch end*/
}()
));
if ((is_optional && (!(found_optional)))){
TRY((((*this).error(TRY((String::formatted(String("Optional chain mismatch: expected optional chain, found {}"),TRY((((*this).type_name(checked_expr_type_id))))))),typechecker::expression_span(checked_expr)))));
}
const NonnullRefPtr<typechecker::CheckedExpression> checked_call_expr = TRY((((*this).typecheck_call(call,scope_id,span,checked_expr,parent_id,safety_mode,type_hint,false))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_call_expr);
__jakt_var_137 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_call_expr;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_141; {
typechecker::TypeId result_type = ((call).return_type);
if (is_optional){
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
(result_type = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({result_type}))))))))))));
}
__jakt_var_141 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,call,span,is_optional,result_type))); goto __jakt_label_135;

}
__jakt_label_135:; __jakt_var_141.release_value(); }));
};/*case end*/
default: {
{
TRY((((((*this).compiler))->panic(String("typecheck_call should return `CheckedExpression::Call()`")))));
}
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_131;

}
__jakt_label_131:; __jakt_var_137.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Range>();NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_142; {
const Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>,typechecker::TypeId> checked_from_checked_to_type_id_ = TRY((((*this).typecheck_range(from,to,scope_id,safety_mode,span))));
const NonnullRefPtr<typechecker::CheckedExpression> checked_from = ((checked_from_checked_to_type_id_).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_to = ((checked_from_checked_to_type_id_).get<1>());
const typechecker::TypeId type_id = ((checked_from_checked_to_type_id_).get<2>());

__jakt_var_142 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Range>(checked_from,checked_to,span,type_id))); goto __jakt_label_136;

}
__jakt_label_136:; __jakt_var_142.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_143; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone())))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span)))));
};/*case end*/
}/*switch end*/
}()
));
const typechecker::CheckedUnaryOperator checked_op = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedUnaryOperator, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PreIncrement());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PostIncrement());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PreDecrement());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::PostDecrement());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Negate>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Negate());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Dereference());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::RawAddress());
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Reference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::Reference());
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::MutableReference>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::MutableReference());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::LogicalNot());
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedUnaryOperator::BitwiseNot());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::TypeCast>();
parser::TypeCast const& cast = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedUnaryOperator> __jakt_var_144; {
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((cast).parsed_type()),scope_id,JaktInternal::OptionalNone()))));
const typechecker::CheckedTypeCast checked_cast = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedTypeCast, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = cast;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Fallible>();
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedTypeCast> __jakt_var_145; {
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> optional_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({type_id})))))));
const typechecker::TypeId optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_145 = typename typechecker::CheckedTypeCast::Fallible(optional_type_id); goto __jakt_label_139;

}
__jakt_label_139:; __jakt_var_145.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::TypeCast::Infallible>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedTypeCast::Infallible(type_id));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_144 = typename typechecker::CheckedUnaryOperator::TypeCast(checked_cast); goto __jakt_label_138;

}
__jakt_label_138:; __jakt_var_144.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::UnaryOperator::Is>();
NonnullRefPtr<parser::ParsedType> const& unchecked_type = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<typechecker::CheckedUnaryOperator> __jakt_var_146; {
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(unchecked_type,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::CheckedUnaryOperator operator_is = typename typechecker::CheckedUnaryOperator::Is(type_id);
if (((type_id).equals(typechecker::unknown_type_id()))){
if (((unchecked_type)->index() == 0 /* Name */)){
const String name = (unchecked_type->get<parser::ParsedType::Name>()).name;
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
if (((((*this).get_type(expr_type_id)))->index() == 23 /* Enum */)){
const typechecker::EnumId enum_id = (((*this).get_type(expr_type_id))->get<typechecker::Type::Enum>()).value;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool exists = false;
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
(exists = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& var_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((var_name == name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
if (exists){
(operator_is = typename typechecker::CheckedUnaryOperator::IsEnumVariant(variant,(TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({})))),expr_type_id));
break;
}
}

}
}

if ((!(exists))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),name,TRY((((*this).type_name(expr_type_id))))))),span))));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),name))),span))));
}

}
else {
TRY((((*this).error(String("The right-hand side of an `is` operator must be a type name or enum variant"),span))));
}

}
__jakt_var_146 = operator_is; goto __jakt_label_140;

}
__jakt_label_140:; __jakt_var_146.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
Array<parser::EnumVariantPatternArgument> const& bindings = __jakt_match_value.bindings;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_is_enum_variant(checked_expr,inner,bindings,scope_id)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_143 = TRY((((*this).typecheck_unary_operation(checked_expr,checked_op,span,scope_id,safety_mode)))); goto __jakt_label_137;

}
__jakt_label_137:; __jakt_var_143.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_147; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_lhs = TRY((((*this).typecheck_expression_and_dereference_if_needed(lhs,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId lhs_type = typechecker::expression_type(checked_lhs);
NonnullRefPtr<typechecker::CheckedExpression> checked_rhs = TRY((((*this).typecheck_expression_and_dereference_if_needed(rhs,scope_id,safety_mode,lhs_type,span))));
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_rhs = TRY((((*this).try_to_promote_constant_expr_to_type(lhs_type,checked_rhs,span))));
if (((promoted_rhs).has_value())){
(checked_rhs = (promoted_rhs.value()));
}
const typechecker::TypeId output_type = TRY((((*this).typecheck_binary_operation(checked_lhs,op,checked_rhs,scope_id,span))));
__jakt_var_147 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::BinaryOp>(checked_lhs,op,checked_rhs,span,output_type))); goto __jakt_label_141;

}
__jakt_label_141:; __jakt_var_147.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::OptionalNone>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_148; {
__jakt_var_148 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalNone>(span,typechecker::unknown_type_id()))); goto __jakt_label_142;

}
__jakt_label_142:; __jakt_var_148.release_value(); }));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::OptionalSome>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_149; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_expr);
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> optional_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({type_id})))))));
const typechecker::TypeId optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
__jakt_var_149 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalSome>(checked_expr,span,optional_type_id))); goto __jakt_label_143;

}
__jakt_label_143:; __jakt_var_149.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
const Optional<typechecker::CheckedVariable> var = TRY((((*this).find_var_in_scope(scope_id,name))));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((var).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Var>((var.value()),span))));
}
else {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_150; {
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),name))),span))));
__jakt_var_150 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Var>(typechecker::CheckedVariable(name,((type_hint).value_or(typechecker::unknown_type_id())),false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public()),span))); goto __jakt_label_144;

}
__jakt_label_144:; __jakt_var_150.release_value(); }));
}
}()))
);
}
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::ForcedUnwrap>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_151; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(typechecker::expression_type(checked_expr)));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_152; {
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
if ((((id).equals(optional_struct_id)) || ((id).equals(weakptr_struct_id)))){
(inner_type_id = ((args)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(String("Forced unwrap only works on Optional"),span))));
}

__jakt_var_152 = inner_type_id; goto __jakt_label_146;

}
__jakt_label_146:; __jakt_var_152.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_153; {
TRY((((*this).error(String("Forced unwrap only works on Optional"),span))));
__jakt_var_153 = typechecker::unknown_type_id(); goto __jakt_label_147;

}
__jakt_label_147:; __jakt_var_153.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_151 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::ForcedUnwrap>(checked_expr,span,type_id))); goto __jakt_label_145;

}
__jakt_label_145:; __jakt_var_151.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktArray>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
Optional<NonnullRefPtr<parser::ParsedExpression>> const& fill_size = __jakt_match_value.fill_size;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_array(scope_id,values,fill_size,span,safety_mode,type_hint)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktTuple>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_154; {
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
Array<NonnullRefPtr<typechecker::CheckedExpression>> checked_values = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
Array<typechecker::TypeId> checked_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const typechecker::TypeId type_id = typechecker::expression_type(checked_value);
if (((type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Cannot create a tuple that contains a value of type void"),((value)->span())))));
}
TRY((((checked_types).push(type_id))));
TRY((((checked_values).push(checked_value))));
}

}
}

const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(tuple_struct_id,checked_types)))))));
__jakt_var_154 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktTuple>(checked_values,span,type_id))); goto __jakt_label_148;

}
__jakt_label_148:; __jakt_var_154.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& index = __jakt_match_value.index;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_155; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_base = TRY((((*this).typecheck_expression_and_dereference_if_needed(base,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const NonnullRefPtr<typechecker::CheckedExpression> checked_index = TRY((((*this).typecheck_expression_and_dereference_if_needed(index,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::StructId array_slice_struct_id = TRY((((*this).find_struct_in_prelude(String("ArraySlice")))));
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
__jakt_var_155 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_base)));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_156; {
NonnullRefPtr<typechecker::CheckedExpression> result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span)));
if ((((id).equals(array_struct_id)) || ((id).equals(array_slice_struct_id)))){
if (((*this).is_integer(typechecker::expression_type(checked_index)))){
(result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedExpression>(checked_base,checked_index,span,((args)[static_cast<i64>(0LL)])))));
}
else {
TRY((((*this).error(String("Index is not an integer"),span))));
}

}
else if (((id).equals(dictionary_struct_id))){
(result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedDictionary>(checked_base,checked_index,span,((args)[static_cast<i64>(1LL)])))));
}
__jakt_var_156 = result; goto __jakt_label_150;

}
__jakt_label_150:; __jakt_var_156.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_157; {
TRY((((*this).error(String("Index used on value that cannot be indexed"),span))));
__jakt_var_157 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span))); goto __jakt_label_151;

}
__jakt_label_151:; __jakt_var_157.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_149;

}
__jakt_label_149:; __jakt_var_155.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedRangeExpression>();NonnullRefPtr<parser::ParsedExpression> const& base = __jakt_match_value.base;
NonnullRefPtr<parser::ParsedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<parser::ParsedExpression> const& to = __jakt_match_value.to;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_158; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_base = TRY((((*this).typecheck_expression_and_dereference_if_needed(base,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>,typechecker::TypeId> checked_from_checked_to_type_id_ = TRY((((*this).typecheck_range(from,to,scope_id,safety_mode,span))));
const NonnullRefPtr<typechecker::CheckedExpression> checked_from = ((checked_from_checked_to_type_id_).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_to = ((checked_from_checked_to_type_id_).get<1>());
const typechecker::TypeId type_id = ((checked_from_checked_to_type_id_).get<2>());

const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
const typechecker::StructId array_slice_struct_id = TRY((((*this).find_struct_in_prelude(String("ArraySlice")))));
__jakt_var_158 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_base)));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_159; {
NonnullRefPtr<typechecker::CheckedExpression> result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span)));
if (((id).equals(array_struct_id))){
if ((((*this).is_integer(typechecker::expression_type(checked_from))) && ((*this).is_integer(typechecker::expression_type(checked_to))))){
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_slice_struct_id,args)))))));
(result = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedRangeExpression>(checked_base,checked_from,checked_to,span,type_id))));
}
else {
TRY((((*this).error(String("Range is not integers"),span))));
}

}
__jakt_var_159 = result; goto __jakt_label_153;

}
__jakt_label_153:; __jakt_var_159.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_160; {
TRY((((*this).error(String("Index range used on value that cannot be indexed"),span))));
__jakt_var_160 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span))); goto __jakt_label_154;

}
__jakt_label_154:; __jakt_var_160.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)); goto __jakt_label_152;

}
__jakt_label_152:; __jakt_var_158.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::IndexedTuple>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_161; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::StructId tuple_struct_id = TRY((((*this).find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
if (((((*this).get_type(typechecker::expression_type(checked_expr))))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(typechecker::expression_type(checked_expr)))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(typechecker::expression_type(checked_expr)))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(tuple_struct_id))){
if (is_optional){
TRY((((*this).error(String("Optional chaining is not allowed on a non-optional tuple type"),span))));
}
if ((index >= ((args).size()))){
TRY((((*this).error(String("Tuple index past the end of the tuple"),span))));
}
else {
(expr_type_id = ((args)[index]));
}

}
else if ((is_optional && ((id).equals(optional_struct_id)))){
const typechecker::TypeId inner_type_id = ((args)[static_cast<i64>(0LL)]);
if (((((*this).get_type(inner_type_id)))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type(inner_type_id))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type(inner_type_id))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(tuple_struct_id))){
if ((index >= ((args).size()))){
TRY((((*this).error(String("Optional-chained tuple index past the end of the tuple"),span))));
}
else {
(expr_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({((args)[index])}))))))))))));
}

}
}
else {
TRY((((*this).error(String("Optional-chained tuple index used on non-tuple value"),span))));
}

}
}
else if (is_optional){
TRY((((*this).error(String("Optional-chained tuple index used on non-tuple value"),span))));
}
else {
TRY((((*this).error(String("Tuple index used on non-tuple value"),span))));
}

__jakt_var_161 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedTuple>(checked_expr,index,span,is_optional,expr_type_id))); goto __jakt_label_155;

}
__jakt_label_155:; __jakt_var_161.release_value(); }));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedExpression::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Garbage>(span))));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::NamespacedVar>();String const& name = __jakt_match_value.name;
Array<String> const& namespace_ = __jakt_match_value.namespace_;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_namespaced_var_or_simple_enum_constructor_call(name,namespace_,scope_id,safety_mode,type_hint,span)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Match>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
Array<parser::ParsedMatchCase> const& cases = __jakt_match_value.cases;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_match(expr,cases,span,scope_id,safety_mode)))));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::EnumVariantArg>();NonnullRefPtr<parser::ParsedExpression> const& inner_expr = __jakt_match_value.expr;
parser::EnumVariantPatternArgument const& arg = __jakt_match_value.arg;
NonnullRefPtr<parser::ParsedType> const& enum_variant = __jakt_match_value.enum_variant;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_162; {
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(inner_expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
typechecker::CheckedEnumVariantBinding checked_binding = typechecker::CheckedEnumVariantBinding(String(""),String(""),typechecker::unknown_type_id(),span);
Optional<typechecker::CheckedEnumVariant> checked_enum_variant = JaktInternal::OptionalNone();
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *enum_variant;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((Array<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
const Array<typechecker::CheckedEnumVariantBinding> bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist"),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(checked_expr)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
(checked_enum_variant = variant);
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),(TRY((Array<parser::EnumVariantPatternArgument>::create_with({arg})))),span))));
const Array<typechecker::CheckedEnumVariantBinding> bindings = (checked_bindings.value());
(checked_binding = ((bindings)[static_cast<i64>(0LL)]));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist"),variant_name))),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_162 = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::EnumVariantArg>(checked_expr,checked_binding,(checked_enum_variant.value()),span))); goto __jakt_label_156;

}
__jakt_label_156:; __jakt_var_162.release_value(); }));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_dictionary(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Set>();Array<NonnullRefPtr<parser::ParsedExpression>> const& values = __jakt_match_value.values;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_set(values,span,scope_id,safety_mode,type_hint)))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Function>();Array<parser::ParsedCapture> const& captures = __jakt_match_value.captures;
Array<parser::ParsedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
NonnullRefPtr<parser::ParsedType> const& return_type = __jakt_match_value.return_type;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_lambda(captures,params,can_throw,return_type,block,span,scope_id,safety_mode)))));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Try>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
Optional<parser::ParsedBlock> const& catch_block = __jakt_match_value.catch_block;
Optional<String> const& catch_name = __jakt_match_value.catch_name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_try(expr,catch_block,catch_name,scope_id,safety_mode,span,type_hint)))));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::TryBlock>();NonnullRefPtr<parser::ParsedStatement> const& stmt = __jakt_match_value.stmt;
parser::ParsedBlock const& catch_block = __jakt_match_value.catch_block;
String const& error_name = __jakt_match_value.error_name;
utility::Span const& error_span = __jakt_match_value.error_span;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_try_block(stmt,error_name,error_span,catch_block,scope_id,safety_mode,span)))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Operator>();{
TRY((((((*this).compiler))->panic(String("idk how to handle this thing")))));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<void> typechecker::Typechecker::dump_type_hint(const typechecker::TypeId type_id,const utility::Span span) const {
{
outln(String("{{\"type\":\"hint\",\"file_id\":{},\"position\":{},\"typename\":\"{}\"}}"),((((span).file_id)).id),((span).end),TRY((((*this).type_name(type_id)))));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_imports(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
{
ArrayIterator<parser::ParsedModuleImport> _magic = ((((parsed_namespace).module_imports)).iterator());
for (;;){
Optional<parser::ParsedModuleImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedModuleImport module_import = (_magic_value.value());
{
TRY((((*this).typecheck_module_import(module_import,scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedExternImport> _magic = ((((parsed_namespace).extern_imports)).iterator());
for (;;){
Optional<parser::ParsedExternImport> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedExternImport extern_import = (_magic_value.value());
{
TRY((((*this).typecheck_extern_import(extern_import,scope_id))));
}

}
}

}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_block_statement(const parser::ParsedBlock parsed_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(parsed_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A block used as a statement cannot yield values, as the value cannot be observed in any way"),(((parsed_block).find_yield_span()).value())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Block>(checked_block,span))));
}
}

typechecker::CheckedStruct typechecker::Typechecker::get_struct(const typechecker::StructId id) const {
{
return (((((*this).program))->get_struct(id)));
}
}

ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>> typechecker::Typechecker::expand_context_for_bindings(const NonnullRefPtr<parser::ParsedExpression> condition,const Optional<NonnullRefPtr<parser::ParsedExpression>> acc,const parser::ParsedBlock then_block,const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>>>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::BinaryOp>();NonnullRefPtr<parser::ParsedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<parser::ParsedExpression> const& rhs = __jakt_match_value.rhs;
{
if (((op).index() == 18 /* LogicalAnd */)){
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> rhs_condition_rhs_then_block_rhs_else_statement_ = TRY((((*this).expand_context_for_bindings(rhs,acc,then_block,else_statement,span))));
const NonnullRefPtr<parser::ParsedExpression> rhs_condition = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<0>());
const parser::ParsedBlock rhs_then_block = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> rhs_else_statement = ((rhs_condition_rhs_then_block_rhs_else_statement_).get<2>());

NonnullRefPtr<parser::ParsedExpression> accumulated_condition = rhs_condition;
return (TRY((((*this).expand_context_for_bindings(lhs,accumulated_condition,rhs_then_block,rhs_else_statement,span)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>>>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::UnaryOperator::IsEnumVariant>();NonnullRefPtr<parser::ParsedType> const& inner = __jakt_match_value.inner;
Array<parser::EnumVariantPatternArgument> const& bindings = __jakt_match_value.bindings;
{
const NonnullRefPtr<parser::ParsedExpression> unary_op_single_condition = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(expr,typename parser::UnaryOperator::Is(inner),span)));
Array<NonnullRefPtr<parser::ParsedStatement>> outer_if_stmts = (TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
const parser::ParsedVarDecl var = parser::ParsedVarDecl(((binding).binding),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),false,JaktInternal::OptionalNone(),((binding).span));
const NonnullRefPtr<parser::ParsedExpression> enum_variant_arg = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::EnumVariantArg>(expr,binding,inner,span)));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(var,enum_variant_arg,span)))))));
}

}
}

NonnullRefPtr<parser::ParsedExpression> inner_condition = condition;
parser::ParsedBlock new_then_block = then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = else_statement;
if (((acc).has_value())){
(inner_condition = (acc.value()));
TRY((((outer_if_stmts).push(TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(inner_condition,then_block,else_statement,span)))))));
}
else {
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((then_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> stmt = (_magic_value.value());
{
TRY((((outer_if_stmts).push(stmt))));
}

}
}

}

(new_then_block = parser::ParsedBlock(outer_if_stmts));
return (TRY((((*this).expand_context_for_bindings(unary_op_single_condition,JaktInternal::OptionalNone(),new_then_block,new_else_statement,span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
NonnullRefPtr<parser::ParsedExpression> base_condition = condition;
if (((acc).has_value())){
(base_condition = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::BinaryOp>(condition,typename parser::BinaryOperator::LogicalAnd(),(acc.value()),span))));
}
return ((Tuple{base_condition, then_block, else_statement}));
}
}

ErrorOr<Optional<typechecker::TypeId>> typechecker::Typechecker::unify(const typechecker::TypeId lhs,const utility::Span lhs_span,const typechecker::TypeId rhs,const utility::Span rhs_span) {
{
if ((((lhs).id) != ((rhs).id))){
TRY((((*this).error(String("types incompatible "),rhs_span))));
return (JaktInternal::OptionalNone());
}
else {
return (lhs);
}

}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::find_type_in_prelude(const String name) const {
{
const typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
const Optional<typechecker::TypeId> type_id = TRY((((*this).find_type_in_scope(scope_id,name))));
if (((type_id).has_value())){
return (((type_id).value()));
}
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("internal error: {} builtin definition not found"),name)))))));
}
}

bool typechecker::Typechecker::is_numeric(const typechecker::TypeId type_id) const {
{
return (((((*this).program))->is_numeric(type_id)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_array(const typechecker::ScopeId scope_id,const Array<NonnullRefPtr<parser::ParsedExpression>> values,const Optional<NonnullRefPtr<parser::ParsedExpression>> fill_size,const utility::Span span,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
if ((!(((TRY((((*this).get_scope(scope_id)))))->can_throw)))){
const String message = String("Array initialization inside non-throwing scope");
if (((((*this).current_function_id)).has_value())){
const NonnullRefPtr<typechecker::CheckedFunction> current_function = ((*this).get_function((((*this).current_function_id).value())));
TRY((((*this).error_with_hint(message,span,TRY((String::formatted(String("Add `throws` keyword to function {}"),((current_function)->name)))),((current_function)->name_span)))));
}
else {
TRY((((*this).error(message,span))));
}

}
Optional<NonnullRefPtr<typechecker::CheckedExpression>> repeat = JaktInternal::OptionalNone();
if (((fill_size).has_value())){
const NonnullRefPtr<parser::ParsedExpression> fill_size_value = ((fill_size).value());
const NonnullRefPtr<typechecker::CheckedExpression> fill_size_checked = TRY((((*this).typecheck_expression_and_dereference_if_needed(fill_size_value,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId fill_size_type = typechecker::expression_type(fill_size_checked);
if ((!(((*this).is_integer(fill_size_type))))){
TRY((((*this).error(TRY((String::formatted(String("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions."),TRY((((*this).type_name(fill_size_type))))))),((fill_size_value)->span())))));
}
(repeat = fill_size_checked);
}
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
typechecker::TypeId inner_type_id = typechecker::unknown_type_id();
Optional<utility::Span> inferred_type_span = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> inner_hint = JaktInternal::OptionalNone();
if (((type_hint).has_value())){
if (((((*this).get_type((type_hint.value()))))->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(array_struct_id))){
(inner_hint = (((args)[static_cast<i64>(0LL)])));
}
}
}
Array<NonnullRefPtr<typechecker::CheckedExpression>> vals = (TRY((Array<NonnullRefPtr<typechecker::CheckedExpression>>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedExpression>> _magic = ((values).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedExpression> value = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,inner_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_expr);
if (((current_value_type_id).equals(typechecker::void_type_id()))){
TRY((((*this).error(String("Cannot create an array with values of type void\n"),span))));
}
if (((inner_type_id).equals(typechecker::unknown_type_id()))){
(inner_type_id = current_value_type_id);
(inferred_type_span = ((value)->span()));
}
else if ((!(((inner_type_id).equals(current_value_type_id))))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in array"),TRY((((*this).type_name(current_value_type_id)))),TRY((((*this).type_name(inner_type_id))))))),((value)->span()),TRY((String::formatted(String("Array was inferred to store type '{}' here"),TRY((((*this).type_name(inner_type_id))))))),(inferred_type_span.value())))));
}
TRY((((vals).push(checked_expr))));
}

}
}

if (((inner_type_id).equals(typechecker::unknown_type_id()))){
if (((inner_hint).has_value())){
(inner_type_id = (inner_hint.value()));
}
else if ((((type_hint).has_value()) && (((type_hint.value())).equals(typechecker::unknown_type_id())))){
TRY((((*this).error(String("Cannot infer generic type for Array<T>"),span))));
}
}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(array_struct_id,(TRY((Array<typechecker::TypeId>::create_with({inner_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktArray>(vals,repeat,span,type_id,inner_type_id))));
}
}

ErrorOr<bool> typechecker::Typechecker::add_var_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::VarId var_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
{
DictionaryIterator<String,typechecker::VarId> _magic = ((((scope)->vars)).iterator());
for (;;){
Optional<Tuple<String,typechecker::VarId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::VarId> existing_var = (_magic_value.value());
{
if ((name == ((existing_var).get<0>()))){
const typechecker::CheckedVariable variable_ = ((*this).get_variable(((existing_var).get<1>())));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Redefinition of variable {}"),name))),span,String("previous definition here"),((variable_).definition_span)))));
}
}

}
}

TRY((((((scope)->vars)).set(name,var_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::Scope>> typechecker::Typechecker::get_scope(const typechecker::ScopeId id) const {
{
return (TRY((((((*this).program))->get_scope(id)))));
}
}

ErrorOr<bool> typechecker::Typechecker::check_types_for_compat(const typechecker::TypeId lhs_type_id,const typechecker::TypeId rhs_type_id,Dictionary<String,String>& generic_inferences,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
const String lhs_type_id_string = TRY((((lhs_type_id).to_string())));
const String rhs_type_id_string = TRY((((rhs_type_id).to_string())));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const typechecker::StructId weakptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::StructId array_struct_id = TRY((((*this).find_struct_in_prelude(String("Array")))));
if ((((lhs_type_id).equals(typechecker::unknown_type_id())) || ((rhs_type_id).equals(typechecker::unknown_type_id())))){
return (true);
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *lhs_type;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((((generic_inferences))).get(lhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != rhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value())))))))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
else {
TRY((((((generic_inferences))).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& lhs_enum_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if (((((*this).get_type(rhs_type_id)))->index() == 20 /* GenericEnumInstance */)){
const typechecker::EnumId rhs_enum_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (((*this).get_type(rhs_type_id))->get<typechecker::Type::GenericEnumInstance>()).args;
if (((lhs_enum_id).equals(rhs_enum_id))){
const typechecker::CheckedEnum lhs_enum = ((*this).get_enum(lhs_enum_id));
if ((((lhs_args).size()) == ((rhs_args).size()))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span))))))){
return (false);
}
(++(idx));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_enum).name)))),span))));
return (false);
}

}
}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::StructId lhs_struct_id = id;
const Array<typechecker::TypeId> lhs_args = args;
if ((((lhs_struct_id).equals(optional_struct_id)) || ((lhs_struct_id).equals(weakptr_struct_id)))){
if ((((lhs_args).size()) > static_cast<size_t>(0ULL))){
if (((((lhs_args)[static_cast<i64>(0LL)])).equals(rhs_type_id))){
return (true);
}
}
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
if (((rhs_type)->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (rhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (rhs_type->get<typechecker::Type::GenericInstance>()).args;
const typechecker::StructId rhs_struct_id = id;
if (((lhs_struct_id).equals(rhs_struct_id))){
const Array<typechecker::TypeId> rhs_args = args;
const typechecker::CheckedStruct lhs_struct = ((*this).get_struct(lhs_struct_id));
if ((((lhs_args).size()) == ((rhs_args).size()))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((lhs_args)[idx]),((rhs_args)[idx]),generic_inferences,span))))))){
return (false);
}
(++(idx));
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_struct).name)))),span))));
return (false);
}

}
else if (((lhs_struct_id).equals(array_struct_id))){
const typechecker::TypeId array_value_type_id = ((args)[static_cast<i64>(0LL)]);
if (((array_value_type_id).equals(typechecker::unknown_type_id()))){
return (true);
}
}
else {
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}

}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
if (((lhs_type_id).equals(rhs_type_id))){
return (true);
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.index()) {
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
if (((enum_id).equals(id))){
const typechecker::CheckedEnum lhs_enum = ((*this).get_enum(enum_id));
if ((((args).size()) != ((((lhs_enum).generic_parameters)).size()))){
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_enum).name)))),span))));
return (false);
}
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((((lhs_enum).generic_parameters))[idx]),((args)[idx]),generic_inferences,span))))))){
return (false);
}
(++(idx));
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((((generic_inferences))).get(rhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != lhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value()))))))))))),span))));
return (false);
}
}
else {
TRY((((((generic_inferences))).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& lhs_struct_id = __jakt_match_value.value;
{
if (((lhs_type_id).equals(rhs_type_id))){
return (true);
}
const NonnullRefPtr<typechecker::Type> rhs_type = ((*this).get_type(rhs_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *rhs_type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
if ((!(((lhs_struct_id).equals(id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
const typechecker::CheckedStruct lhs_struct = ((*this).get_struct(lhs_struct_id));
if ((((args).size()) != ((((lhs_struct).generic_parameters)).size()))){
TRY((((*this).error(TRY((String::formatted(String("mismatched number of generic parameters for {}"),((lhs_struct).name)))),span))));
return (false);
}
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((args).size()))){
if ((!(TRY((((*this).check_types_for_compat(((((lhs_struct).generic_parameters))[idx]),((args)[idx]),generic_inferences,span))))))){
return (false);
}
(++(idx));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> seen_type_id_string = ((((generic_inferences))).get(rhs_type_id_string));
if (((seen_type_id_string).has_value())){
if ((((seen_type_id_string).value()) != lhs_type_id_string)){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(TRY((typechecker::TypeId::from_string(((seen_type_id_string).value())))))))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
else {
TRY((((((generic_inferences))).set(lhs_type_id_string,rhs_type_id_string))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& lhs_rawptr_type_id = __jakt_match_value.value;
{
if (((lhs_rawptr_type_id).equals(rhs_type_id))){
return (true);
}
if (((((*this).get_type(rhs_type_id)))->index() == 24 /* RawPtr */)){
const typechecker::TypeId rhs_rawptr_type_id = (((*this).get_type(rhs_type_id))->get<typechecker::Type::RawPtr>()).value;
if ((!(TRY((((*this).check_types_for_compat(lhs_rawptr_type_id,rhs_rawptr_type_id,generic_inferences,span))))))){
return (false);
}
}
else {
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
if ((!(((rhs_type_id).equals(lhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),span))));
return (false);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (true);
}
}

ErrorOr<Optional<typechecker::CheckedVariable>> typechecker::Typechecker::find_var_in_scope(const typechecker::ScopeId scope_id,const String var) const {
{
return (TRY((((((*this).program))->find_var_in_scope(scope_id,var)))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_generic_arguments_method_call(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr,const parser::ParsedCall call,const typechecker::ScopeId scope_id,const utility::Span span,const bool is_optional,const typechecker::SafetyMode safety_mode) {
{
Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> checked_args = (TRY((Array<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
TRY((((checked_args).ensure_capacity(((((call).args)).size())))));
{
ArrayIterator<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> call_arg = (_magic_value.value());
{
const String name = ((call_arg).get<0>());
const NonnullRefPtr<parser::ParsedExpression> expr = ((call_arg).get<2>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_arg_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,JaktInternal::OptionalNone()))));
const Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> checked_arg = (Tuple{name, checked_arg_expr});
TRY((((checked_args).push(checked_arg))));
}

}
}

Array<typechecker::TypeId> checked_type_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<parser::ParsedType>> _magic = ((((call).type_args)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedType>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedType> type_arg = (_magic_value.value());
{
TRY((((checked_type_args).push(TRY((((*this).typecheck_typename(type_arg,scope_id,JaktInternal::OptionalNone()))))))));
}

}
}

return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::MethodCall>(checked_expr,typechecker::CheckedCall((TRY((Array<typechecker::ResolvedNamespace>::create_with({})))),((call).name),checked_args,checked_type_args,JaktInternal::OptionalNone(),typechecker::unknown_type_id(),false),span,is_optional,typechecker::unknown_type_id()))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_lambda(const Array<parser::ParsedCapture> captures,const Array<parser::ParsedParameter> params,const bool can_throw,const NonnullRefPtr<parser::ParsedType> return_type,const parser::ParsedBlock block,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const typechecker::ScopeId lambda_scope_id = TRY((((*this).create_scope(scope_id,can_throw,String("lambda")))));
Array<typechecker::CheckedCapture> checked_captures = (TRY((Array<typechecker::CheckedCapture>::create_with({}))));
{
ArrayIterator<parser::ParsedCapture> _magic = ((captures).iterator());
for (;;){
Optional<parser::ParsedCapture> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedCapture capture = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((TRY((((*this).find_var_in_scope(scope_id,((capture).name())))))).has_value()));
if (__jakt_enum_value == true) {
{
TRY((((checked_captures).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedCapture, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = capture;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByValue>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByValue(name,span));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByReference>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByReference(name,span));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(typename typechecker::CheckedCapture::ByMutableReference(name,span));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Variable '{}' not found"),((capture).name())))),span))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
Array<typechecker::CheckedParameter> checked_params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
bool first = true;
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
const typechecker::CheckedParameter checked_param = TRY((((*this).typecheck_parameter(param,scope_id,first,JaktInternal::OptionalNone(),JaktInternal::OptionalNone()))));
TRY((((checked_params).push(checked_param))));
const typechecker::VarId var_id = TRY((((module)->add_variable(((checked_param).variable)))));
TRY((((*this).add_var_to_scope(lambda_scope_id,((((checked_param).variable)).name),var_id,((((checked_param).variable)).definition_span)))));
(first = false);
}

}
}

const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(block,lambda_scope_id,safety_mode))));
Array<typechecker::TypeId> param_type_ids = (TRY((Array<typechecker::TypeId>::create_with({}))));
{
ArrayIterator<parser::ParsedParameter> _magic = ((params).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
TRY((((param_type_ids).push(TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),scope_id,((((param).variable)).name)))))))));
}

}
}

const typechecker::TypeId return_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *return_type;
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
return JaktInternal::ExplicitValue(((*this).infer_function_return_type(checked_block)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_typename(return_type,scope_id,JaktInternal::OptionalNone())))));
};/*case end*/
}/*switch end*/
}()
));
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Function>(param_type_ids,can_throw,return_type_id)))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Function>(checked_captures,checked_params,can_throw,return_type_id,checked_block,span,type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_try(const NonnullRefPtr<parser::ParsedExpression> expr,const Optional<parser::ParsedBlock> catch_block,const Optional<String> catch_name,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span,const Optional<typechecker::TypeId> type_hint) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,type_hint))));
const typechecker::StructId error_struct_id = TRY((((*this).find_struct_in_prelude(String("Error")))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
Optional<typechecker::CheckedBlock> checked_catch_block = JaktInternal::OptionalNone();
const typechecker::TypeId expression_type_id = typechecker::expression_type(checked_expr);
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> optional_type = TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({expression_type_id})))))));
const typechecker::TypeId optional_type_id = TRY((((*this).find_or_add_type_id(optional_type))));
typechecker::TypeId type_id = optional_type_id;
if (((catch_block).has_value())){
const typechecker::ScopeId catch_scope_id = TRY((((*this).create_scope(scope_id,true,String("catch")))));
if (((catch_name).has_value())){
const typechecker::StructId error_struct_id = TRY((((*this).find_struct_in_prelude(String("Error")))));
const typechecker::CheckedVariable error_decl = typechecker::CheckedVariable((catch_name.value()),((((*this).get_struct(error_struct_id))).type_id),false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public());
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId error_id = TRY((((module)->add_variable(error_decl))));
TRY((((*this).add_var_to_scope(catch_scope_id,(catch_name.value()),error_id,span))));
}
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block((catch_block.value()),catch_scope_id,safety_mode))));
if ((((((block).control_flow)).always_transfers_control()) || ((((block).yielded_type)).has_value()))){
if ((!(((((block).yielded_type).value_or_lazy_evaluated([&] { return expression_type_id; })).equals(expression_type_id))))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("Expected a value of type {}, but got {}"),TRY((((*this).type_name(expression_type_id)))),TRY((((*this).type_name((((block).yielded_type).value())))))))),span,TRY((String::formatted(String("Expression 'catch' block must either yield the same type as the expression it is catching, or yield nothing")))),span))));
}
else {
(type_id = ((block).yielded_type).value_or_lazy_evaluated([&] { return expression_type_id; }));
}

}
(checked_catch_block = block);
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Try>(checked_expr,checked_catch_block,catch_name,span,type_id,expression_type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_return(const Optional<NonnullRefPtr<parser::ParsedExpression>> expr,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
if (((*this).inside_defer)){
TRY((((*this).error(String("return is not allowed inside defer"),span))));
}
if ((!(((expr).has_value())))){
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Return>(JaktInternal::OptionalNone(),span))));
}
if ((((expr.value()))->index() == 26 /* Function */)){
TRY((((*this).error(String("Returning a function is not currently supported"),span))));
}
Optional<typechecker::TypeId> type_hint = JaktInternal::OptionalNone();
if (((((*this).current_function_id)).has_value())){
(type_hint = (((((*this).get_function((((*this).current_function_id).value()))))->return_type_id)));
}
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression((expr.value()),scope_id,safety_mode,type_hint))));
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Return>(checked_expr,span))));
}
}

ErrorOr<void> typechecker::Typechecker::check_that_type_doesnt_contain_reference(const typechecker::TypeId type_id,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(type_id));
const bool contains_reference = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
if (contains_reference){
TRY((((*this).error(TRY((String::formatted(String("Reference type {} not usable in this context"),TRY((((*this).type_name(type_id))))))),span))));
}
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_fields(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_fields(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
if ((((((record).record_type)).index() == 0 /* Struct */) || ((((record).record_type)).index() == 1 /* Class */))){
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find previously added struct")))));
}
TRY((((*this).typecheck_struct_fields(record,(struct_id.value())))));
}
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_and_specialize_generic_function(const typechecker::FunctionId function_id,const Array<typechecker::TypeId> generic_arguments,const typechecker::ScopeId parent_scope_id,const Optional<typechecker::TypeId> this_type_id,const Dictionary<String,String> generic_substitutions) {
{
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function(function_id));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::FunctionId function_id = ((module)->next_function_id());
if ((!(((((checked_function)->parsed_function)).has_value())))){
return {};
}
parser::ParsedFunction parsed_function = ((checked_function)->to_parsed_function());
const typechecker::ScopeId scope_id = TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),TRY((String::formatted(String("function-specialization({})"),((parsed_function).name))))))));
if ((((((parsed_function).generic_parameters)).size()) != ((generic_arguments).size()))){
TRY((((*this).error(TRY((String::formatted(String("Generic function {} expects {} generic arguments, but {} were given"),((parsed_function).name),((((parsed_function).generic_parameters)).size()),((generic_arguments).size())))),((parsed_function).name_span)))));
}
const utility::Span span = ((parsed_function).name_span);
{
DictionaryIterator<String,String> _magic = ((generic_substitutions).iterator());
for (;;){
Optional<Tuple<String,String>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,String> substitution = (_magic_value.value());
{
if (((((*this).get_type(TRY((typechecker::TypeId::from_string(((substitution).get<0>())))))))->index() == 18 /* TypeVariable */)){
const String type_name = (((*this).get_type(TRY((typechecker::TypeId::from_string(((substitution).get<0>()))))))->get<typechecker::Type::TypeVariable>()).value;
TRY((((*this).add_type_to_scope(scope_id,type_name,TRY((typechecker::TypeId::from_string(((substitution).get<1>())))),span))));
}
}

}
}

(((parsed_function).must_instantiate) = true);
(((*this).current_function_id) = (function_id));
TRY((((*this).typecheck_function_predecl(parsed_function,scope_id,this_type_id))));
TRY((((*this).typecheck_function(parsed_function,scope_id))));
(((*this).current_function_id) = JaktInternal::OptionalNone());
(((checked_function)->is_instantiated) = true);
(((checked_function)->function_scope_id) = scope_id);
}
return {};
}

ErrorOr<Optional<parser::ParsedNamespace>> typechecker::Typechecker::lex_and_parse_file_contents(const utility::FileId file_id) {
{
const utility::FileId old_file_id = (((((*this).compiler))->current_file).value());
if ((!(((((*this).compiler))->set_current_file(file_id))))){
return (JaktInternal::OptionalNone());
}

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{((((*this).compiler))->set_current_file(old_file_id));
});
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(((*this).compiler))));
if (((((*this).compiler))->dump_lexer)){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(((*this).compiler),tokens)));
if (((((*this).compiler))->dump_parser)){
outln(String("{:#}"),parsed_namespace);
}
return (parsed_namespace);
}
}

ErrorOr<Optional<NonnullRefPtr<typechecker::CheckedExpression>>> typechecker::Typechecker::try_to_promote_constant_expr_to_type(const typechecker::TypeId lhs_type,const NonnullRefPtr<typechecker::CheckedExpression> checked_rhs,const utility::Span span) {
{
if ((!(((*this).is_integer(lhs_type))))){
return (JaktInternal::OptionalNone());
}
const Optional<typechecker::NumberConstant> rhs_constant_opt = ((checked_rhs)->to_number_constant(((*this).program)));
if ((!(((rhs_constant_opt).has_value())))){
return (JaktInternal::OptionalNone());
}
const typechecker::NumberConstant rhs_constant = (rhs_constant_opt.value());
const Optional<typechecker::CheckedNumericConstant> result = typechecker::promote(rhs_constant,lhs_type,((*this).program));
if ((!(((result).has_value())))){
const NonnullRefPtr<typechecker::Type> type = ((*this).get_type(lhs_type));
TRY((((*this).error_with_hint(String("Integer promotion failed"),span,TRY((String::formatted(String("Cannot fit value into range [{}, {}] of type {}."),((type)->min()),((type)->max()),TRY((((*this).type_name(lhs_type))))))),span))));
return (JaktInternal::OptionalNone());
}
const typechecker::CheckedNumericConstant new_constant = (result.value());
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(new_constant,span,lhs_type))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_unary_operation(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr,const typechecker::CheckedUnaryOperator checked_op,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> expr_type = ((*this).get_type(expr_type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = checked_op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreIncrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!(((*this).expression_is_mutable(checked_expr))))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostIncrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!(((*this).expression_is_mutable(checked_expr))))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreDecrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!(((*this).expression_is_mutable(checked_expr))))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostDecrement>();
{
if (((*this).is_integer(expr_type_id))){
if ((!(((*this).expression_is_mutable(checked_expr))))){
TRY((((*this).error(String("Increment/decrement of immutable variable"),span))));
}
}
else {
TRY((((*this).error(String("Increment/decrement of non-numeric value"),span))));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::BitwiseNot>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,((cast).type_id())))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Negate>();
{
return (TRY((((*this).typecheck_unary_negate(checked_expr,span,expr_type_id)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,typechecker::builtin(BuiltinType::Bool)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedUnaryOperator::IsEnumVariant>();{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,typechecker::builtin(BuiltinType::Bool)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::RawAddress>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Reference>();
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Reference>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::MutableReference>();
{
if ((!(((*this).expression_is_mutable(checked_expr))))){
TRY((((*this).error(String("Cannot make mutable reference to immutable value"),span))));
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::MutableReference>(expr_type_id)))))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr_type;
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
if (((safety_mode).index() == 0 /* Safe */)){
TRY((((*this).error(String("Dereference of raw pointer outside of unsafe block"),span))));
}
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,type_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Dereference of a non-pointer value"),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(checked_expr,checked_op,span,expr_type_id))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::resolve_type_var(const typechecker::TypeId type_var_type_id,const typechecker::ScopeId scope_id) const {
{
typechecker::TypeId current_type_id = type_var_type_id;
for (;;){
const NonnullRefPtr<typechecker::Type> type_var_type = ((*this).get_type(current_type_id));
if (((type_var_type)->index() == 18 /* TypeVariable */)){
const String type_name = (type_var_type->get<typechecker::Type::TypeVariable>()).value;
const Optional<typechecker::TypeId> maybe_found_type_id = TRY((((*this).find_type_in_scope(scope_id,type_name))));
if (((maybe_found_type_id).has_value())){
const typechecker::TypeId found_type_id = ((maybe_found_type_id).value());
if (((found_type_id).equals(current_type_id))){
return (current_type_id);
}
(current_type_id = found_type_id);
}
else {
return (current_type_id);
}

}
else {
return (current_type_id);
}

}
return (current_type_id);
}
}

NonnullRefPtr<typechecker::CheckedFunction> typechecker::Typechecker::get_function(const typechecker::FunctionId id) const {
{
return (((((*this).program))->get_function(id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl(const parser::ParsedRecord parsed_record,const typechecker::StructId struct_id,const typechecker::ScopeId scope_id) {
{
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
const typechecker::ScopeId struct_scope_id = TRY((((*this).create_scope(scope_id,false,TRY((String::formatted(String("struct({})"),((parsed_record).name))))))));
TRY((((*this).add_struct_to_scope(scope_id,((parsed_record).name),struct_id,((parsed_record).name_span)))));
const bool is_extern = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).definition_linkage);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::External>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::DefinitionLinkage::Internal>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
(((((module)->structures))[((struct_id).id)]) = typechecker::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::VarId>::create_with({})))),struct_scope_id,((parsed_record).definition_linkage),((parsed_record).record_type),struct_type_id));
Array<typechecker::TypeId> generic_parameters = ((((((module)->structures))[((struct_id).id)])).generic_parameters);
TRY((((generic_parameters).ensure_capacity(((((parsed_record).generic_parameters)).size())))));
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_record).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId parameter_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((generic_parameters).push(parameter_type_id))));
TRY((((*this).add_type_to_scope(struct_scope_id,((gen_parameter).name),parameter_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedMethod> _magic = ((((parsed_record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
const parser::ParsedFunction func = ((method).parsed_function);
const typechecker::ScopeId method_scope_id = TRY((((*this).create_scope(struct_scope_id,((func).can_throw),TRY((String::formatted(String("method({}::{})"),((parsed_record).name),((func).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-block({}::{})"),((parsed_record).name),((func).name))))))));
const bool is_generic = ((!(((((parsed_record).generic_parameters)).is_empty()))) || (!(((((func).generic_parameters)).is_empty()))));
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((func).name),((func).name_span),((method).visibility),typechecker::unknown_type_id(),((func).return_type_span),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((func).can_throw),((func).type),((func).linkage),method_scope_id,((!(is_generic)) || is_extern),((method).parsed_function),((((method).parsed_function)).is_comptime))));
TRY((((((module)->functions)).push(checked_function))));
const typechecker::FunctionId function_id = typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL))));
const Optional<typechecker::FunctionId> previous_index = ((*this).current_function_id);
(((*this).current_function_id) = function_id);
Optional<typechecker::ScopeId> check_scope = JaktInternal::OptionalNone();
if (is_generic){
(check_scope = TRY((((*this).create_scope(method_scope_id,((func).can_throw),TRY((String::formatted(String("method-checking({}::{})"),((parsed_record).name),((func).name)))))))));
}
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((func).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter gen_parameter = (_magic_value.value());
{
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((gen_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((((checked_function)->generic_params)).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
TRY((((*this).add_type_to_scope(method_scope_id,((gen_parameter).name),type_var_type_id,((gen_parameter).span)))));
}

}
}

{
ArrayIterator<parser::ParsedParameter> _magic = ((((func).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter param = (_magic_value.value());
{
if ((((((param).variable)).name) == String("this"))){
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),struct_type_id,((((param).variable)).is_mutable),((((param).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable,JaktInternal::OptionalNone())))));
if (((check_scope).has_value())){
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((param).variable)).name),var_id,((((param).variable)).span)))));
}
}
else {
const typechecker::TypeId param_type = TRY((((*this).typecheck_typename(((((param).variable)).parsed_type),method_scope_id,((((param).variable)).name)))));
const typechecker::CheckedVariable checked_variable = typechecker::CheckedVariable(((((param).variable)).name),param_type,((((param).variable)).is_mutable),((((param).variable)).span),((((((param).variable)).parsed_type))->span()),typename parser::Visibility::Public());
Optional<NonnullRefPtr<typechecker::CheckedExpression>> checked_default_value = JaktInternal::OptionalNone();
if (((((param).default_argument)).has_value())){
NonnullRefPtr<typechecker::CheckedExpression> checked_default_value_expr = TRY((((*this).typecheck_expression((((param).default_argument).value()),scope_id,typename typechecker::SafetyMode::Safe(),param_type))));
if (((checked_default_value_expr)->index() == 23 /* OptionalNone */)){
const utility::Span expr_span = (checked_default_value_expr->get<typechecker::CheckedExpression::OptionalNone>()).span;
(checked_default_value_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalNone>(expr_span,param_type))));
}
const typechecker::TypeId default_value_type_id = typechecker::expression_type(checked_default_value_expr);
(checked_default_value = checked_default_value_expr);
if ((!(((default_value_type_id).equals(param_type))))){
(checked_default_value = JaktInternal::OptionalNone());
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(param_type)))),TRY((((*this).type_name(default_value_type_id))))))),((param).span)))));
}
}
TRY((((((checked_function)->params)).push(typechecker::CheckedParameter(((param).requires_label),checked_variable,checked_default_value)))));
if (((check_scope).has_value())){
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((param).variable)).name),var_id,((((param).variable)).span)))));
}
}

}

}
}

TRY((((*this).add_function_to_scope(struct_scope_id,((func).name),typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL)))),((parsed_record).name_span)))));
const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),method_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
if (is_generic){
if ((!(((check_scope).has_value())))){
TRY((((((*this).compiler))->panic(String("Generic method with generic parameters must have a check scope")))));
}
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((func).block),(check_scope.value()),typename typechecker::SafetyMode::Safe()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::TypeId return_type_id = typechecker::builtin(BuiltinType::Void);
if (((function_return_type_id).equals(typechecker::unknown_type_id()))){
if ((!(((((block).statements)).is_empty())))){
if ((((((((block).statements)).last()).value()))->index() == 8 /* Return */)){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = ((((((block).statements)).last()).value())->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
(return_type_id = TRY((((*this).resolve_type_var(typechecker::expression_type((val.value())),method_scope_id)))));
}
}
}
}
else {
(return_type_id = TRY((((*this).resolve_type_var(function_return_type_id,scope_id)))));
}

(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
(((((module)->functions))[((function_id).id)]) = checked_function);
(((*this).current_function_id) = previous_index);
}

}
}

(((((((module)->structures))[((struct_id).id)])).generic_parameters) = generic_parameters);
(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_predecl_initial(const parser::ParsedRecord parsed_record,const size_t enum_index,const size_t module_enum_len,const typechecker::ScopeId scope_id) {
{
const typechecker::ModuleId module_id = ((*this).current_module_id);
const typechecker::EnumId enum_id = typechecker::EnumId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(enum_index,module_enum_len)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id)))))));
const typechecker::TypeId enum_type_id = typechecker::TypeId(module_id,(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),enum_type_id,((parsed_record).name_span)))));
const bool is_boxed = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = ((parsed_record).record_type);
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
return JaktInternal::ExplicitValue(is_boxed);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
));
TRY((((((module)->enums)).push(typechecker::CheckedEnum(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::CheckedEnumVariant>::create_with({})))),((*this).prelude_scope_id()),((parsed_record).definition_linkage),((parsed_record).record_type),enum_type_id,enum_type_id,is_boxed)))));
}
return {};
}

NonnullRefPtr<typechecker::Type> typechecker::Typechecker::get_type(const typechecker::TypeId id) const {
{
return (((((*this).program))->get_type(id)));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_guard(const NonnullRefPtr<parser::ParsedExpression> expr,const parser::ParsedBlock else_block,const parser::ParsedBlock remaining_code,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
bool seen_scope_exit = false;
{
ArrayIterator<NonnullRefPtr<parser::ParsedStatement>> _magic = ((((else_block).stmts)).iterator());
for (;;){
Optional<NonnullRefPtr<parser::ParsedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<parser::ParsedStatement> statement = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();{
(seen_scope_exit = true);
return JaktInternal::LoopBreak{};
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

const typechecker::CheckedBlock checked_else_block = TRY((((*this).typecheck_block(else_block,scope_id,safety_mode))));
if (((!(seen_scope_exit)) && ((((checked_else_block).control_flow)).may_return()))){
TRY((((*this).error(String("Else block of guard must either `return`, `break`, `continue`, or `throw`"),span))));
}
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(expr,JaktInternal::OptionalNone(),remaining_code,TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(else_block,span))),span))));
const NonnullRefPtr<parser::ParsedExpression> new_condition = ((new_condition_new_then_block_new_else_statement_).get<0>());
const parser::ParsedBlock new_then_block = ((new_condition_new_then_block_new_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = ((new_condition_new_then_block_new_else_statement_).get<2>());

const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((new_condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(new_then_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("A 'guard' block is not allowed to yield values"),(((new_then_block).find_yield_span()).value())))));
}
Optional<NonnullRefPtr<typechecker::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode)))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::If>(checked_condition,checked_block,checked_else,span))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_extern_import(const parser::ParsedExternImport import_,const typechecker::ScopeId scope_id) {
{
{
ArrayIterator<parser::ParsedFunction> _magic = ((((((import_).assigned_namespace)).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction f = (_magic_value.value());
{
if ((!(((((f).linkage)).index() == 1 /* External */)))){
TRY((((*this).error(String("Expected all functions in an `import extern` to be be external"),((f).name_span)))));
}
if ((((import_).is_c) && (!(((((f).generic_parameters)).is_empty()))))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("imported function '{}' is declared to have C linkage, but is generic"),((f).name)))),((f).name_span),String("this function may not be generic"),((f).name_span)))));
}
if ((!(((((((f).block)).stmts)).is_empty())))){
TRY((((*this).error(String("imported extern function is not allowed to have a body"),((f).name_span)))));
}
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((((import_).assigned_namespace)).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
if ((!(((((record).definition_linkage)).index() == 1 /* External */)))){
TRY((((*this).error(String("Expected all records in an `import extern` to be external"),((record).name_span)))));
}
if ((((import_).is_c) && (!(((((record).generic_parameters)).is_empty()))))){
TRY((((*this).error_with_hint(TRY((String::formatted(String("imported {} '{}' is declared to have C linkage, but is generic"),((((record).record_type)).record_type_name()),((record).name)))),((record).name_span),TRY((String::formatted(String("this {} may not be generic"),((((record).record_type)).record_type_name())))),((record).name_span)))));
}
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::check_member_access(const typechecker::ScopeId accessor,const typechecker::ScopeId accessee,const typechecker::CheckedVariable member,const utility::Span span) {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((member).visibility);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
{
if ((!(TRY((((*this).scope_can_access(accessor,accessee))))))){
TRY((((*this).error(TRY((String::formatted(String("Can't access variable {} from scope {}, because it is marked private"),((member).name),((TRY((((*this).get_scope(accessor)))))->namespace_name)))),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();Array<NonnullRefPtr<parser::ParsedType>> const& whitelist = __jakt_match_value.whitelist;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((*this).check_restricted_access(accessor,String("variable"),accessee,((member).name),whitelist,span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_method(const parser::ParsedFunction func,const typechecker::StructOrEnumId parent_id) {
{
Array<typechecker::TypeId> parent_generic_parameters = (TRY((Array<typechecker::TypeId>::create_with({}))));
typechecker::ScopeId scope_id = ((*this).prelude_scope_id());
parser::DefinitionLinkage definition_linkage = typename parser::DefinitionLinkage::Internal();
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = parent_id;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
(parent_generic_parameters = ((structure).generic_parameters));
(scope_id = ((structure).scope_id));
(definition_linkage = ((structure).definition_linkage));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StructOrEnumId::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
(definition_linkage = ((enum_).definition_linkage));
(scope_id = ((enum_).scope_id));
(parent_generic_parameters = ((enum_).generic_parameters));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((!(((((func).generic_parameters)).is_empty()))) || (!(((parent_generic_parameters).is_empty())))) && (!(((func).must_instantiate))))){
return {};
}
const typechecker::ScopeId structure_scope_id = scope_id;
const parser::DefinitionLinkage structure_linkage = definition_linkage;
const Optional<typechecker::FunctionId> method_id = TRY((((*this).find_function_in_scope(structure_scope_id,((func).name)))));
if ((!(((method_id).has_value())))){
TRY((((((*this).compiler))->panic(String("we just pushed the checked function, but it's not present")))));
}
NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((*this).get_function((method_id.value())));
const typechecker::ScopeId function_scope_id = ((checked_function)->function_scope_id);
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope(function_scope_id,((variable).name),var_id,((variable).definition_span)))));
}

}
}

(((*this).current_function_id) = method_id);
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((func).block),function_scope_id,typename typechecker::SafetyMode::Safe()))));
const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((func).return_type),function_scope_id,JaktInternal::OptionalNone()))));
typechecker::TypeId return_type_id = function_return_type_id;
if ((((function_return_type_id).equals(typechecker::unknown_type_id())) && (!(((((block).statements)).is_empty()))))){
if (((((((block).statements))[static_cast<i64>(0LL)]))->index() == 8 /* Return */)){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = (((((block).statements))[static_cast<i64>(0LL)])->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
(return_type_id = typechecker::expression_type((val.value())));
}
else {
(return_type_id = VOID_TYPE_ID);
}

}
else {
(return_type_id = VOID_TYPE_ID);
}

}
else if (((function_return_type_id).equals(typechecker::unknown_type_id()))){
(return_type_id = VOID_TYPE_ID);
}
if (((!(((structure_linkage).index() == 1 /* External */))) && ((!(((return_type_id).equals(VOID_TYPE_ID)))) && (!(((((block).control_flow)).always_transfers_control())))))){
if ((((return_type_id).equals(typechecker::never_type_id())) && (!(((((block).control_flow)).never_returns()))))){
TRY((((*this).error(String("Control reaches end of never-returning function"),((func).name_span)))));
}
else if ((!(((((block).control_flow)).never_returns())))){
TRY((((*this).error(String("Control reaches end of non-void function"),((func).name_span)))));
}
}
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
return {};
}

bool typechecker::Typechecker::expression_is_mutable(const NonnullRefPtr<typechecker::CheckedExpression> expr) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).is_mutable));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *((*this).get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((*this).expression_is_mutable(expr)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<bool> typechecker::Typechecker::add_struct_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::StructId struct_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::StructId> maybe_scope_id = ((((scope)->structs)).get(name));
if (((maybe_scope_id).has_value())){
const typechecker::StructId existing_struct_id = (maybe_scope_id.value());
const utility::Span definition_span = ((((*this).get_struct(existing_struct_id))).name_span);
TRY((((*this).error_with_hint(TRY((String::formatted(String("redefinition of struct/class {}"),name))),span,TRY((String::formatted(String("struct/class {} was first defined here"),name))),definition_span))));
return (false);
}
TRY((((((scope)->structs)).set(name,struct_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_unary_negate(const NonnullRefPtr<typechecker::CheckedExpression> expr,const utility::Span span,const typechecker::TypeId type_id) {
{
if (((!(((((*this).program))->is_integer(type_id)))) || ((((*this).program))->is_signed(type_id)))){
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
const typechecker::TypeId flipped_sign_type = TRY((typechecker::flip_signedness(((*this).get_type(type_id)))));
const typechecker::CheckedNumericConstant constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(val);
};/*case end*/
default: {
{
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
};/*case end*/
}/*switch end*/
}()
));
const typechecker::NumberConstant number = (((constant).number_constant()).value());
const size_t raw_number = ((number).to_usize());
const size_t max_signed = (infallible_integer_cast<size_t>((((TRY((typechecker::Type::template create<typename typechecker::Type::I64>())))->max()))));
i64 negated_number = static_cast<i64>(0LL);
if ((raw_number == (JaktInternal::checked_add<size_t>(max_signed,static_cast<size_t>(1ULL))))){
(negated_number = ((TRY((typechecker::Type::template create<typename typechecker::Type::I64>())))->min()));
}
if ((raw_number <= max_signed)){
(negated_number = (JaktInternal::checked_sub<i64>(static_cast<i64>(0LL),(infallible_integer_cast<i64>((raw_number))))));
}
const typechecker::NumberConstant negated_number_constant = typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>((negated_number))));
if (((raw_number > (JaktInternal::checked_add<size_t>(max_signed,static_cast<size_t>(1ULL)))) || (!(((negated_number_constant).can_fit_number(flipped_sign_type,((*this).program))))))){
TRY((((*this).error(TRY((String::formatted(String("Negative literal -{} too small for type {}"),raw_number,TRY((((*this).type_name(flipped_sign_type))))))),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(expr,typename typechecker::CheckedUnaryOperator::Negate(),span,type_id))));
}
const typechecker::CheckedNumericConstant new_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::CheckedNumericConstant, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(flipped_sign_type));
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I8((infallible_integer_cast<i8>((negated_number)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I16((infallible_integer_cast<i16>((negated_number)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I32((infallible_integer_cast<i32>((negated_number)))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(typename typechecker::CheckedNumericConstant::I64((infallible_integer_cast<i64>((negated_number)))));
};/*case end*/
default: {
{
utility::panic(String("Unreachable"));
}
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::UnaryOp>(TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::NumericConstant>(new_constant,span,type_id))),typename typechecker::CheckedUnaryOperator::Negate(),span,flipped_sign_type))));
}
}

ErrorOr<Optional<typechecker::FunctionId>> typechecker::Typechecker::resolve_call(const parser::ParsedCall call,Array<typechecker::ResolvedNamespace> namespaces,const utility::Span span,const typechecker::ScopeId scope_id,const bool must_be_enum_constructor) {
{
Optional<typechecker::FunctionId> callee = JaktInternal::OptionalNone();
typechecker::ScopeId current_scope_id = scope_id;
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).namespace_)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t namespace_index = (_magic_value.value());
{
const String scope_name = ((((call).namespace_))[namespace_index]);
const Optional<Tuple<typechecker::ScopeId,bool>> maybe_ns_scope = TRY((((*this).find_namespace_in_scope(current_scope_id,scope_name))));
if (((maybe_ns_scope).has_value())){
const typechecker::ScopeId scope_id = (((maybe_ns_scope.value())).get<0>());
const bool is_import = (((maybe_ns_scope.value())).get<1>());
if (is_import){
(((((namespaces)[namespace_index])).name) = ((((((((*this).program))->modules))[((((scope_id).module_id)).id)]))->name));
}
(current_scope_id = scope_id);
continue;
}
const Optional<typechecker::StructId> maybe_struct_scope = TRY((((*this).find_struct_in_scope(current_scope_id,scope_name))));
if (((maybe_struct_scope).has_value())){
const typechecker::CheckedStruct structure = ((*this).get_struct((maybe_struct_scope.value())));
(current_scope_id = ((structure).scope_id));
continue;
}
const Optional<typechecker::EnumId> maybe_enum_scope = TRY((((((*this).program))->find_enum_in_scope(current_scope_id,scope_name))));
if (((maybe_enum_scope).has_value())){
const typechecker::CheckedEnum enum_ = ((*this).get_enum((maybe_enum_scope.value())));
(current_scope_id = ((enum_).scope_id));
continue;
}
TRY((((*this).error(TRY((String::formatted(String("Not a namespace, enum, class, or struct: {}"),utility::join(((call).namespace_),String("::"))))),span))));
}

}
}

const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(current_scope_id,((call).name)))));
if (((maybe_function_id).has_value())){
const typechecker::FunctionId function_id = (maybe_function_id.value());
if (((!(must_be_enum_constructor)) || ((((((*this).get_function(function_id)))->type)).index() == 2 /* ImplicitEnumConstructor */))){
return (function_id);
}
}
if (must_be_enum_constructor){
TRY((((*this).error(TRY((String::formatted(String("No such enum constructor {}"),((call).name)))),span))));
return (callee);
}
const Optional<typechecker::StructId> maybe_struct_id = TRY((((*this).find_struct_in_scope(current_scope_id,((call).name)))));
if (((maybe_struct_id).has_value())){
const typechecker::StructId struct_id = (maybe_struct_id.value());
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
const Optional<typechecker::FunctionId> maybe_function_id = TRY((((*this).find_function_in_scope(((structure).scope_id),((call).name)))));
if (((maybe_function_id).has_value())){
return ((maybe_function_id.value()));
}
return (callee);
}
TRY((((*this).error(TRY((String::formatted(String("Call to unknown function: {}"),((call).name)))),span))));
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedProgram>> typechecker::Typechecker::typecheck(NonnullRefPtr<compiler::Compiler> compiler,const parser::ParsedNamespace parsed_namespace) {
{
const Optional<utility::FileId> input_file = ((compiler)->current_file);
if ((!(((input_file).has_value())))){
TRY((((compiler)->panic(String("trying to typecheck a non-existant file")))));
}
const typechecker::ModuleId placeholder_module_id = typechecker::ModuleId(static_cast<size_t>(0ULL));
typechecker::Typechecker typechecker = typechecker::Typechecker(compiler,TRY((typechecker::CheckedProgram::create(compiler,(TRY((Array<NonnullRefPtr<typechecker::Module>>::create_with({})))),(TRY((Dictionary<String, typechecker::LoadedModule>::create_with_entries({}))))))),placeholder_module_id,typechecker::TypeId::none(),JaktInternal::OptionalNone(),false,static_cast<size_t>(0ULL),false,((compiler)->dump_type_hints),((compiler)->dump_try_hints),static_cast<u64>(0ULL));
TRY((((typechecker).include_prelude())));
const String root_module_name = String("Root Module");
const typechecker::ModuleId root_module_id = TRY((((typechecker).create_module(root_module_name,true))));
(((typechecker).current_module_id) = root_module_id);
((compiler)->set_current_file((input_file.value())));
TRY((((((typechecker).program))->set_loaded_module(root_module_name,typechecker::LoadedModule(root_module_id,(input_file.value()))))));
const typechecker::ScopeId PRELUDE_SCOPE_ID = ((typechecker).prelude_scope_id());
const typechecker::ScopeId root_scope_id = TRY((((typechecker).create_scope(PRELUDE_SCOPE_ID,false,String("root")))));
TRY((((typechecker).typecheck_module(parsed_namespace,root_scope_id))));
return (((typechecker).program));
}
}

ErrorOr<bool> typechecker::Typechecker::add_enum_to_scope(const typechecker::ScopeId scope_id,const String name,const typechecker::EnumId enum_id,const utility::Span span) {
{
NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
const Optional<typechecker::EnumId> maybe_enum_id = ((((scope)->enums)).get(name));
if (((maybe_enum_id).has_value())){
const typechecker::EnumId existing_enum_id = (maybe_enum_id.value());
const utility::Span definition_span = ((((*this).get_enum(existing_enum_id))).name_span);
TRY((((*this).error_with_hint(TRY((String::formatted(String("redefinition of enum {}"),name))),span,TRY((String::formatted(String("enum {} was first defined here"),name))),definition_span))));
return (false);
}
TRY((((((scope)->enums)).set(name,enum_id))));
return (true);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_dictionary(const Array<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> values,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const Optional<typechecker::TypeId> type_hint) {
{
if (((*this).dump_try_hints)){
TRY((((*this).dump_try_hint(span))));
}
const typechecker::StructId dictionary_struct_id = TRY((((*this).find_struct_in_prelude(String("Dictionary")))));
Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> checked_kv_pairs = (TRY((Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
typechecker::TypeId key_type_id = typechecker::unknown_type_id();
Optional<utility::Span> key_type_span = JaktInternal::OptionalNone();
typechecker::TypeId value_type_id = typechecker::unknown_type_id();
Optional<utility::Span> value_type_span = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> key_hint = JaktInternal::OptionalNone();
Optional<typechecker::TypeId> value_hint = JaktInternal::OptionalNone();
if ((((type_hint).has_value()) && ((((*this).get_type((type_hint.value()))))->index() == 19 /* GenericInstance */))){
const typechecker::StructId id = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (((*this).get_type((type_hint.value())))->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(dictionary_struct_id))){
(key_hint = ((args)[static_cast<i64>(0LL)]));
(value_hint = ((args)[static_cast<i64>(1LL)]));
}
}
{
ArrayIterator<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> _magic = ((values).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<NonnullRefPtr<parser::ParsedExpression>,NonnullRefPtr<parser::ParsedExpression>> kv_pair = (_magic_value.value());
{
const NonnullRefPtr<parser::ParsedExpression> key = ((kv_pair).get<0>());
const NonnullRefPtr<parser::ParsedExpression> value = ((kv_pair).get<1>());
const NonnullRefPtr<typechecker::CheckedExpression> checked_key = TRY((((*this).typecheck_expression(key,scope_id,safety_mode,key_hint))));
const typechecker::TypeId current_key_type_id = typechecker::expression_type(checked_key);
const NonnullRefPtr<typechecker::CheckedExpression> checked_value = TRY((((*this).typecheck_expression(value,scope_id,safety_mode,value_hint))));
const typechecker::TypeId current_value_type_id = typechecker::expression_type(checked_value);
const typechecker::TypeId VOID_TYPE_ID = typechecker::builtin(BuiltinType::Void);
if ((((key_type_id).equals(typechecker::unknown_type_id())) && ((value_type_id).equals(typechecker::unknown_type_id())))){
if (((current_key_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Can't create a dictionary with keys of type void"),((key)->span())))));
}
if (((current_value_type_id).equals(VOID_TYPE_ID))){
TRY((((*this).error(String("Can't create a dictionary with values of type void"),((value)->span())))));
}
(key_type_id = current_key_type_id);
(key_type_span = (((key)->span())));
(value_type_id = current_value_type_id);
(value_type_span = (((value)->span())));
}
else {
if ((!(((key_type_id).equals(current_key_type_id))))){
const String key_type_name = TRY((((*this).type_name(key_type_id))));
const String current_key_type_name = TRY((((*this).type_name(current_key_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous keys in dictionary"),current_key_type_name,key_type_name))),((key)->span()),TRY((String::formatted(String("Dictionary was inferred to store keys of type '{}' here"),key_type_name))),(key_type_span.value())))));
}
if ((!(((value_type_id).equals(current_value_type_id))))){
const String value_type_name = TRY((((*this).type_name(value_type_id))));
const String current_value_type_name = TRY((((*this).type_name(current_value_type_id))));
TRY((((*this).error_with_hint(TRY((String::formatted(String("Type '{}' does not match type '{}' of previous values in dictionary"),current_value_type_name,value_type_name))),((value)->span()),TRY((String::formatted(String("Dictionary was inferred to store values of type '{}' here"),value_type_name))),(value_type_span.value())))));
}
}

TRY((((checked_kv_pairs).push((Tuple{checked_key, checked_value})))));
}

}
}

if (((key_type_id).equals(typechecker::unknown_type_id()))){
if (((key_hint).has_value())){
(key_type_id = (key_hint.value()));
}
else {
TRY((((*this).error(String("Cannot infer key type for Dictionary<K, V>"),span))));
}

}
if (((value_type_id).equals(typechecker::unknown_type_id()))){
if (((value_hint).has_value())){
(value_type_id = (value_hint.value()));
}
else {
TRY((((*this).error(String("Cannot infer value type for Dictionary"),span))));
}

}
const typechecker::TypeId type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(dictionary_struct_id,(TRY((Array<typechecker::TypeId>::create_with({key_type_id, value_type_id})))))))))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::JaktDictionary>(checked_kv_pairs,span,type_id,key_type_id,value_type_id))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_if(const NonnullRefPtr<parser::ParsedExpression> condition,const parser::ParsedBlock then_block,const Optional<NonnullRefPtr<parser::ParsedStatement>> else_statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const Tuple<NonnullRefPtr<parser::ParsedExpression>,parser::ParsedBlock,Optional<NonnullRefPtr<parser::ParsedStatement>>> new_condition_new_then_block_new_else_statement_ = TRY((((*this).expand_context_for_bindings(condition,JaktInternal::OptionalNone(),then_block,else_statement,span))));
const NonnullRefPtr<parser::ParsedExpression> new_condition = ((new_condition_new_then_block_new_else_statement_).get<0>());
const parser::ParsedBlock new_then_block = ((new_condition_new_then_block_new_else_statement_).get<1>());
const Optional<NonnullRefPtr<parser::ParsedStatement>> new_else_statement = ((new_condition_new_then_block_new_else_statement_).get<2>());

const NonnullRefPtr<typechecker::CheckedExpression> checked_condition = TRY((((*this).typecheck_expression_and_dereference_if_needed(new_condition,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
if ((!(((typechecker::expression_type(checked_condition)).equals(typechecker::builtin(BuiltinType::Bool)))))){
TRY((((*this).error(String("Condition must be a boolean expression"),((new_condition)->span())))));
}
const typechecker::CheckedBlock checked_block = TRY((((*this).typecheck_block(new_then_block,scope_id,safety_mode))));
if (((((checked_block).yielded_type)).has_value())){
TRY((((*this).error(String("An 'if' block is not allowed to yield values"),(((new_then_block).find_yield_span()).value())))));
}
Optional<NonnullRefPtr<typechecker::CheckedStatement>> checked_else = JaktInternal::OptionalNone();
if (((new_else_statement).has_value())){
(checked_else = TRY((((*this).typecheck_statement((new_else_statement.value()),scope_id,safety_mode)))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::If>(checked_condition,checked_block,checked_else,span))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::unify_with_type(const typechecker::TypeId found_type,const Optional<typechecker::TypeId> expected_type,const utility::Span span) {
{
if ((!(((expected_type).has_value())))){
return (found_type);
}
if ((((expected_type.value())).equals(typechecker::unknown_type_id()))){
return (found_type);
}
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
if (TRY((((*this).check_types_for_compat((expected_type.value()),found_type,((generic_inferences)),span))))){
return (found_type);
}
return (TRY((((*this).substitute_typevars_in_type(found_type,generic_inferences)))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_throw(const NonnullRefPtr<parser::ParsedExpression> expr,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId error_type_id = TRY((((*this).find_type_in_prelude(String("Error")))));
if ((!(((typechecker::expression_type(checked_expr)).equals(error_type_id))))){
TRY((((*this).error(String("throw expression does not produce an error"),((expr)->span())))));
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((*this).get_scope(scope_id))));
if ((!(((scope)->can_throw)))){
TRY((((*this).error(String("Throw statement needs to be in a try statement or a function marked as throws"),((expr)->span())))));
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Throw>(checked_expr,span))));
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_destructuring_assignment(const Array<parser::ParsedVarDecl> vars,const NonnullRefPtr<parser::ParsedStatement> var_decl,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
Array<NonnullRefPtr<typechecker::CheckedStatement>> var_decls = (TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({}))));
const NonnullRefPtr<typechecker::CheckedStatement> checked_tuple_var_decl = TRY((((*this).typecheck_statement(var_decl,scope_id,safety_mode))));
typechecker::TypeId expr_type_id = typechecker::unknown_type_id();
typechecker::VarId tuple_var_id = typechecker::VarId(typechecker::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL));
if (((checked_tuple_var_decl)->index() == 3 /* VarDecl */)){
const typechecker::VarId var_id = (checked_tuple_var_decl->get<typechecker::CheckedStatement::VarDecl>()).var_id;
const NonnullRefPtr<typechecker::CheckedExpression> init = (checked_tuple_var_decl->get<typechecker::CheckedStatement::VarDecl>()).init;
(expr_type_id = typechecker::expression_type(init));
(tuple_var_id = var_id);
}
else {
TRY((((*this).error(String("Destructuting assignment should be a variable declaration"),span))));
}

Array<typechecker::TypeId> inner_types = (TRY((Array<typechecker::TypeId>::create_with({}))));
const NonnullRefPtr<typechecker::Type> tuple_type = ((*this).get_type(expr_type_id));
if (((tuple_type)->index() == 19 /* GenericInstance */)){
const Array<typechecker::TypeId> args = (tuple_type->get<typechecker::Type::GenericInstance>()).args;
(inner_types = args);
}
else {
TRY((((*this).error(String("Tuple Type should be Generic Instance"),span))));
}

const typechecker::CheckedVariable tuple_variable = ((((*this).program))->get_variable(tuple_var_id));
if ((((vars).size()) == ((inner_types).size()))){
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vars).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
parser::ParsedVarDecl new_var = ((vars)[i]);
(((new_var).parsed_type) = TRY((parser::ParsedType::template create<typename parser::ParsedType::Name>(TRY((((*this).type_name(((inner_types)[i]))))),span))));
const NonnullRefPtr<parser::ParsedExpression> init = TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::IndexedTuple>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(((tuple_variable).name),span))),i,false,span)));
TRY((((var_decls).push(TRY((((*this).typecheck_var_decl(((vars)[i]),init,scope_id,safety_mode,span))))))));
}

}
}

}
else {
TRY((((*this).error(String("Tuple inner types sould have same size as tuple members"),span))));
}

return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::DestructuringAssignment>(var_decls,checked_tuple_var_decl,span))));
}
}

typechecker::ScopeId typechecker::Typechecker::prelude_scope_id() const {
{
return (((((*this).program))->prelude_scope_id()));
}
}

typechecker::BlockControlFlow typechecker::Typechecker::statement_control_flow(const NonnullRefPtr<typechecker::CheckedStatement> statement) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(true));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(false));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((typechecker::checked_expression_control_flow(expr)).updated(typename typechecker::BlockControlFlow::AlwaysTransfersControl(false))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *condition;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((then_block).control_flow));
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).statement_control_flow((else_statement.value()))));
}
else {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
}()))
);
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((then_block).control_flow);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow)));
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).maybe_statement_control_flow(else_statement,((then_block).control_flow))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(((block).control_flow));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((((block).control_flow)).may_break()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = ((block).control_flow);
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}()))
);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(typechecker::checked_expression_control_flow(expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<typechecker::ScopeId> typechecker::Typechecker::create_scope(const Optional<typechecker::ScopeId> parent_scope_id,const bool can_throw,const String debug_name) {
{
if (((parent_scope_id).has_value())){
if (((((((parent_scope_id.value())).module_id)).id) >= ((((((*this).program))->modules)).size()))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("create_scope: parent_scope_id.module is invalid! No module with id {}."),(((((parent_scope_id.value())).module_id)).id))))))));
}
if (((((parent_scope_id.value())).id) >= ((((((((((*this).program))->modules))[(((((parent_scope_id.value())).module_id)).id)]))->scopes)).size()))){
TRY((((((*this).compiler))->panic(TRY((String::formatted(String("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}."),(((((parent_scope_id.value())).module_id)).id),(((parent_scope_id.value())).id))))))));
}
}
const Optional<String> none_string = JaktInternal::OptionalNone();
const NonnullRefPtr<typechecker::Scope> scope = TRY((typechecker::Scope::create(none_string,(TRY((Dictionary<String, typechecker::VarId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::StructId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::FunctionId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::EnumId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::TypeId>::create_with_entries({})))),(TRY((Dictionary<String, typechecker::ModuleId>::create_with_entries({})))),parent_scope_id,(TRY((Array<typechecker::ScopeId>::create_with({})))),can_throw,JaktInternal::OptionalNone(),debug_name)));
TRY((((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->scopes)).push(scope))));
return (typechecker::ScopeId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((((((*this).program))->modules))[((((*this).current_module_id)).id)]))->scopes)).size()),static_cast<size_t>(1ULL)))));
}
}

ErrorOr<bool> typechecker::Typechecker::validate_argument_label(const typechecker::CheckedParameter param,const String label,const utility::Span span,const NonnullRefPtr<parser::ParsedExpression> expr,const Optional<NonnullRefPtr<typechecker::CheckedExpression>> default_value) {
{
if ((label == ((((param).variable)).name))){
return (true);
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<bool>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::Var>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((name == ((((param).variable)).name))){
return (true);
}
if ((!(((default_value).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got '{}', expected '{}')"),name,((((param).variable)).name)))),span))));
}
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedExpression::UnaryOp>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::UnaryOperator const& op = __jakt_match_value.op;
{
if ((((op).index() == 7 /* Reference */) || ((op).index() == 8 /* MutableReference */))){
if (((expr)->index() == 9 /* Var */)){
const String name = (expr->get<parser::ParsedExpression::Var>()).name;
const utility::Span span = (expr->get<parser::ParsedExpression::Var>()).span;
if ((name == ((((param).variable)).name))){
return (true);
}
if ((!(((default_value).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got {}, expected {})"),name,((((param).variable)).name)))),span))));
}
return (false);
}
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if ((!(((default_value).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Wrong parameter name in argument label (got '{}', expected '{}')"),label,((((param).variable)).name)))),span))));
}
return (false);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_indexed_struct(const NonnullRefPtr<parser::ParsedExpression> expr,const String field,const typechecker::ScopeId scope_id,const bool is_optional,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId checked_expr_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> checked_expr_type = ((*this).get_type(checked_expr_type_id));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *checked_expr_type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
typechecker::TypeId type_id = checked_expr_type_id;
if (is_optional){
if ((!(((id).equals(optional_struct_id))))){
TRY((((*this).error(String("Optional chaining is only allowed on optional types"),span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,typechecker::unknown_type_id()))));
}
(type_id = ((args)[static_cast<i64>(0LL)]));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *((*this).get_type(type_id));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
{
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
if (is_optional){
(resolved_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(optional_struct_id,(TRY((Array<typechecker::TypeId>::create_with({resolved_type_id}))))))))))));
}
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((String::formatted(String("Member field access on value of non-struct type {}"),TRY((((*this).type_name(checked_expr_type_id))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
if (is_optional){
TRY((((*this).error(String("Optional chaining is not allowed on non-optional types"),span))));
}
const typechecker::CheckedStruct structure = ((*this).get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId member_id = (_magic_value.value());
{
const typechecker::CheckedVariable member = ((*this).get_variable(member_id));
if ((((member).name) == field)){
const typechecker::TypeId resolved_type_id = TRY((((*this).resolve_type_var(((member).type_id),scope_id))));
TRY((((*this).check_member_access(scope_id,((structure).scope_id),member,span))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,resolved_type_id))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("unknown member of struct: {}.{}"),((structure).name),field))),span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
return (TRY((((*this).error(TRY((String::formatted(String("Member field access on value of non-struct type {}"),TRY((((*this).type_name(checked_expr_type_id))))))),span))))), JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::IndexedStruct>(checked_expr,field,span,is_optional,typechecker::unknown_type_id()))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_function_predecl(const parser::ParsedFunction parsed_function,const typechecker::ScopeId parent_scope_id,const Optional<typechecker::TypeId> this_arg_type_id) {
{
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),TRY((String::formatted(String("function({})"),((parsed_function).name))))))));
const String scope_debug_name = TRY((String::formatted(String("function-block({})"),((parsed_function).name))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,((parsed_function).can_throw),scope_debug_name))));
const size_t module_id = ((((*this).current_module_id)).id);
const bool is_generic_function = (!(((((parsed_function).generic_parameters)).is_empty())));
const bool is_generic = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool,ErrorOr<void>>{
auto __jakt_enum_value = (((this_arg_type_id).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<void>>{
auto&& __jakt_match_variant = *((*this).get_type((this_arg_type_id.value())));
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(is_generic_function);
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(is_generic_function);
}
}()))
;
NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((parsed_function).name),((parsed_function).name_span),((parsed_function).visibility),typechecker::unknown_type_id(),((parsed_function).return_type_span),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),((parsed_function).can_throw),typename parser::FunctionType::Normal(),((parsed_function).linkage),function_scope_id,(!(is_generic)),parsed_function,((parsed_function).is_comptime))));
NonnullRefPtr<typechecker::Module> current_module = ((*this).current_module());
const typechecker::FunctionId function_id = TRY((((current_module)->add_function(checked_function))));
const typechecker::ScopeId checked_function_scope_id = ((checked_function)->function_scope_id);
const bool external_linkage = ((((parsed_function).linkage)).index() == 1 /* External */);
{
ArrayIterator<parser::ParsedGenericParameter> _magic = ((((parsed_function).generic_parameters)).iterator());
for (;;){
Optional<parser::ParsedGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedGenericParameter generic_parameter = (_magic_value.value());
{
TRY((((((current_module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::TypeVariable>(((generic_parameter).name))))))));
const typechecker::TypeId type_var_type_id = typechecker::TypeId(((current_module)->id),(JaktInternal::checked_sub<size_t>(((((current_module)->types)).size()),static_cast<size_t>(1ULL))));
TRY((((((checked_function)->generic_params)).push(typename typechecker::FunctionGenericParameter::Parameter(type_var_type_id)))));
if (((!(((parsed_function).must_instantiate))) || external_linkage)){
TRY((((*this).add_type_to_scope(checked_function_scope_id,((generic_parameter).name),type_var_type_id,((generic_parameter).span)))));
}
}

}
}

const Optional<typechecker::ScopeId> check_scope = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::ScopeId>,ErrorOr<void>>{
auto __jakt_enum_value = (is_generic);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((TRY((((*this).create_scope(parent_scope_id,((parsed_function).can_throw),scope_debug_name))))));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}()))
;
bool first = true;
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::ParsedParameter> _magic = ((((parsed_function).params)).iterator());
for (;;){
Optional<parser::ParsedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedParameter parameter = (_magic_value.value());
{
TRY((((((checked_function)->params)).push(TRY((((*this).typecheck_parameter(parameter,checked_function_scope_id,first,this_arg_type_id,check_scope))))))));
(first = false);
}

}
}

const typechecker::TypeId function_return_type_id = TRY((((*this).typecheck_typename(((parsed_function).return_type),checked_function_scope_id,JaktInternal::OptionalNone()))));
(((checked_function)->return_type_id) = function_return_type_id);
TRY((((*this).check_that_type_doesnt_contain_reference(function_return_type_id,((parsed_function).return_type_span)))));
if ((!(((((parsed_function).generic_parameters)).is_empty())))){
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::CheckedBlock block = TRY((((*this).typecheck_block(((parsed_function).block),(check_scope.value()),typename typechecker::SafetyMode::Safe()))));
(((*this).ignore_errors) = old_ignore_errors);
const typechecker::TypeId return_type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((function_return_type_id).equals(typechecker::unknown_type_id())));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<typechecker::TypeId> __jakt_var_163; {
const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement = ((((block).statements)).last());
__jakt_var_163 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<void>>{
auto&& __jakt_match_variant = *(statement.value());
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId,ErrorOr<void>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typechecker::expression_type((val.value())));
}
else {
return JaktInternal::ExplicitValue(typechecker::void_type_id());
}
}()))
);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typechecker::void_type_id());
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return JaktInternal::ExplicitValue(typechecker::unknown_type_id());
}
}()))
; goto __jakt_label_157;

}
__jakt_label_157:; __jakt_var_163.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).resolve_type_var(function_return_type_id,parent_scope_id)))));
}
}()))
;
(((checked_function)->block) = block);
(((checked_function)->return_type_id) = return_type_id);
}
TRY((((*this).add_function_to_scope(parent_scope_id,((parsed_function).name),function_id,((parsed_function).name_span)))));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_try_block(const NonnullRefPtr<parser::ParsedStatement> stmt,const String error_name,const utility::Span error_span,const parser::ParsedBlock catch_block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const typechecker::ScopeId try_scope_id = TRY((((*this).create_scope(scope_id,true,String("try")))));
const NonnullRefPtr<typechecker::CheckedStatement> checked_stmt = TRY((((*this).typecheck_statement(stmt,try_scope_id,safety_mode))));
const typechecker::StructId error_struct_id = TRY((((*this).find_struct_in_prelude(String("Error")))));
const typechecker::CheckedVariable error_decl = typechecker::CheckedVariable(error_name,((((*this).get_struct(error_struct_id))).type_id),false,error_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public());
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId error_id = TRY((((module)->add_variable(error_decl))));
const typechecker::ScopeId catch_scope_id = TRY((((*this).create_scope(scope_id,true,String("catch")))));
TRY((((*this).add_var_to_scope(catch_scope_id,error_name,error_id,error_span))));
const typechecker::CheckedBlock checked_catch_block = TRY((((*this).typecheck_block(catch_block,catch_scope_id,safety_mode))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::TryBlock>(checked_stmt,checked_catch_block,error_name,error_span,span,typechecker::void_type_id()))));
}
}

ErrorOr<typechecker::CheckedUnaryOperator> typechecker::Typechecker::typecheck_is_enum_variant(const NonnullRefPtr<typechecker::CheckedExpression> checked_expr,const NonnullRefPtr<parser::ParsedType> inner,const Array<parser::EnumVariantPatternArgument> bindings,const typechecker::ScopeId scope_id) {
{
const bool old_ignore_errors = ((*this).ignore_errors);
(((*this).ignore_errors) = true);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(inner,scope_id,JaktInternal::OptionalNone()))));
(((*this).ignore_errors) = old_ignore_errors);
typechecker::CheckedUnaryOperator checked_op = typename typechecker::CheckedUnaryOperator::Is(type_id);
const typechecker::TypeId expr_type_id = typechecker::expression_type(checked_expr);
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::CheckedUnaryOperator>>{
auto&& __jakt_match_variant = *inner;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::NamespacedName>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if (((((*this).get_type(expr_type_id)))->index() == 23 /* Enum */)){
const typechecker::EnumId enum_id = (((*this).get_type(expr_type_id))->get<typechecker::Type::Enum>()).value;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = typename typechecker::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),variant_name,TRY((((*this).type_name(type_id))))))),span))));
return (checked_op);
}

}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
return (checked_op);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& variant_name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if (((((*this).get_type(expr_type_id)))->index() == 23 /* Enum */)){
const typechecker::EnumId enum_id = (((*this).get_type(expr_type_id))->get<typechecker::Type::Enum>()).value;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
const Optional<typechecker::CheckedEnumVariant> variant = TRY((((*this).get_enum_variant(enum_,variant_name))));
if (((variant).has_value())){
const Optional<Array<typechecker::CheckedEnumVariantBinding>> checked_enum_variant_bindings = TRY((((*this).typecheck_enum_variant_bindings((variant.value()),bindings,span))));
(checked_op = typename typechecker::CheckedUnaryOperator::IsEnumVariant((variant.value()),(checked_enum_variant_bindings.value()),expr_type_id));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} does not exist on {}"),variant_name,TRY((((*this).type_name(type_id))))))),span))));
return (checked_op);
}

}
else {
TRY((((*this).error(TRY((String::formatted(String("Unknown type or invalid type name: {}"),variant_name))),span))));
return (checked_op);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (checked_op);
}
}

typechecker::CheckedVariable typechecker::Typechecker::get_variable(const typechecker::VarId id) const {
{
return (((((*this).program))->get_variable(id)));
}
}

ErrorOr<typechecker::ModuleId> typechecker::Typechecker::create_module(const String name,const bool is_root) {
{
const size_t new_id = ((((((*this).program))->modules)).size());
const typechecker::ModuleId module_id = typechecker::ModuleId(new_id);
const NonnullRefPtr<typechecker::Module> module = TRY((typechecker::Module::create(module_id,name,(TRY((Array<NonnullRefPtr<typechecker::CheckedFunction>>::create_with({})))),(TRY((Array<typechecker::CheckedStruct>::create_with({})))),(TRY((Array<typechecker::CheckedEnum>::create_with({})))),(TRY((Array<NonnullRefPtr<typechecker::Scope>>::create_with({})))),(TRY((Array<NonnullRefPtr<typechecker::Type>>::create_with({TRY((typechecker::Type::template create<typename typechecker::Type::Void>())), TRY((typechecker::Type::template create<typename typechecker::Type::Bool>())), TRY((typechecker::Type::template create<typename typechecker::Type::U8>())), TRY((typechecker::Type::template create<typename typechecker::Type::U16>())), TRY((typechecker::Type::template create<typename typechecker::Type::U32>())), TRY((typechecker::Type::template create<typename typechecker::Type::U64>())), TRY((typechecker::Type::template create<typename typechecker::Type::I8>())), TRY((typechecker::Type::template create<typename typechecker::Type::I16>())), TRY((typechecker::Type::template create<typename typechecker::Type::I32>())), TRY((typechecker::Type::template create<typename typechecker::Type::I64>())), TRY((typechecker::Type::template create<typename typechecker::Type::F32>())), TRY((typechecker::Type::template create<typename typechecker::Type::F64>())), TRY((typechecker::Type::template create<typename typechecker::Type::Usize>())), TRY((typechecker::Type::template create<typename typechecker::Type::JaktString>())), TRY((typechecker::Type::template create<typename typechecker::Type::CChar>())), TRY((typechecker::Type::template create<typename typechecker::Type::CInt>())), TRY((typechecker::Type::template create<typename typechecker::Type::Unknown>())), TRY((typechecker::Type::template create<typename typechecker::Type::Never>()))})))),(TRY((Array<typechecker::CheckedVariable>::create_with({})))),(TRY((Array<typechecker::ModuleId>::create_with({})))),is_root)));
TRY((((((((*this).program))->modules)).push(module))));
return (module_id);
}
}

typechecker::TypeId typechecker::Typechecker::infer_function_return_type(const typechecker::CheckedBlock block) const {
{
if (((((block).statements)).is_empty())){
return (typechecker::void_type_id());
}
if ((((((((block).statements)).last()).value()))->index() == 8 /* Return */)){
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> val = ((((((block).statements)).last()).value())->get<typechecker::CheckedStatement::Return>()).val;
if (((val).has_value())){
return (typechecker::expression_type((val.value())));
}
}
return (typechecker::void_type_id());
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::substitute_typevars_in_type_helper(const typechecker::TypeId type_id,const Dictionary<String,String> generic_inferences) {
{
const NonnullRefPtr<typechecker::Type> type_ = ((*this).get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<typechecker::TypeId>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
const Optional<String> replacment_type_id_string = ((generic_inferences).get(TRY((((type_id).to_string())))));
if (((replacment_type_id_string).has_value())){
return (TRY((typechecker::TypeId::from_string(((replacment_type_id_string).value())))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((args).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(id,new_args))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((args).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>(id,new_args))))))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(struct_id));
if ((!(((((struct_).generic_parameters)).is_empty())))){
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((((struct_).generic_parameters)).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>(struct_id,new_args))))))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
if ((!(((((enum_).generic_parameters)).is_empty())))){
Array<typechecker::TypeId> new_args = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((new_args).ensure_capacity(((((enum_).generic_parameters)).size())))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
TRY((((new_args).push(TRY((((*this).substitute_typevars_in_type(arg,generic_inferences))))))));
}

}
}

return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>(enum_id,new_args))))))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& rawptr_type_id = __jakt_match_value.value;
{
const NonnullRefPtr<typechecker::Type> rawptr_type = TRY((typechecker::Type::template create<typename typechecker::Type::RawPtr>(TRY((((*this).substitute_typevars_in_type(rawptr_type_id,generic_inferences)))))));
return (TRY((((*this).find_or_add_type_id(rawptr_type)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& ref_type_id = __jakt_match_value.value;
{
const NonnullRefPtr<typechecker::Type> ref_type = TRY((typechecker::Type::template create<typename typechecker::Type::Reference>(TRY((((*this).substitute_typevars_in_type(ref_type_id,generic_inferences)))))));
return (TRY((((*this).find_or_add_type_id(ref_type)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& ref_type_id = __jakt_match_value.value;
{
const NonnullRefPtr<typechecker::Type> ref_type = TRY((typechecker::Type::template create<typename typechecker::Type::MutableReference>(TRY((((*this).substitute_typevars_in_type(ref_type_id,generic_inferences)))))));
return (TRY((((*this).find_or_add_type_id(ref_type)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return (type_id);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (type_id);
}
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_statement(const NonnullRefPtr<parser::ParsedStatement> statement,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedStatement>, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Expression>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Expression>(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,typechecker::TypeId::none())))),span))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::UnsafeBlock>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Block>(TRY((((*this).typecheck_block(block,scope_id,typename typechecker::SafetyMode::Unsafe())))),span))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Yield>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Yield>(TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,typechecker::TypeId::none())))),span))));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Return>();Optional<NonnullRefPtr<parser::ParsedExpression>> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_return(expr,span,scope_id,safety_mode)))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Block>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_block_statement(block,scope_id,safety_mode,span)))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::InlineCpp>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_inline_cpp(block,span,safety_mode)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Defer>();NonnullRefPtr<parser::ParsedStatement> const& statement = __jakt_match_value.statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_defer(statement,scope_id,safety_mode,span)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Loop>();parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_loop(block,scope_id,safety_mode,span)))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Throw>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_throw(expr,scope_id,safety_mode,span)))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::While>();NonnullRefPtr<parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_while(condition,block,scope_id,safety_mode,span)))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Continue>(span))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Break>(span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::VarDecl>();parser::ParsedVarDecl const& var = __jakt_match_value.var;
NonnullRefPtr<parser::ParsedExpression> const& init = __jakt_match_value.init;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_var_decl(var,init,scope_id,safety_mode,span)))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::DestructuringAssignment>();Array<parser::ParsedVarDecl> const& vars = __jakt_match_value.vars;
NonnullRefPtr<parser::ParsedStatement> const& var_decl = __jakt_match_value.var_decl;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_destructuring_assignment(vars,var_decl,scope_id,safety_mode,span)))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::If>();NonnullRefPtr<parser::ParsedExpression> const& condition = __jakt_match_value.condition;
parser::ParsedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<parser::ParsedStatement>> const& else_statement = __jakt_match_value.else_statement;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_if(condition,then_block,else_statement,scope_id,safety_mode,span)))));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Garbage>(span))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::For>();String const& iterator_name = __jakt_match_value.iterator_name;
utility::Span const& name_span = __jakt_match_value.name_span;
NonnullRefPtr<parser::ParsedExpression> const& range = __jakt_match_value.range;
parser::ParsedBlock const& block = __jakt_match_value.block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_for(iterator_name,name_span,range,block,scope_id,safety_mode,span)))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedStatement::Guard>();NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.expr;
parser::ParsedBlock const& else_block = __jakt_match_value.else_block;
parser::ParsedBlock const& remaining_code = __jakt_match_value.remaining_code;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(TRY((((*this).typecheck_guard(expr,else_block,remaining_code,scope_id,safety_mode,span)))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

ErrorOr<Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>>> typechecker::Typechecker::resolve_default_params(const Array<typechecker::CheckedParameter> params,const Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>> args,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const size_t arg_offset,const utility::Span span) {
{
size_t params_with_default_value = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((params).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if (((((param).default_value)).has_value())){
((params_with_default_value++));
}
}

}
}

if (((((args).size()) >= (JaktInternal::checked_sub<size_t>((JaktInternal::checked_sub<size_t>(((params).size()),arg_offset)),params_with_default_value))) && (((args).size()) <= (JaktInternal::checked_sub<size_t>(((params).size()),arg_offset))))){
size_t consumed_arg = static_cast<size_t>(0ULL);
Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>> resolved_args = (TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(arg_offset),static_cast<size_t>(((params).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const typechecker::CheckedParameter param = ((params)[i]);
Optional<NonnullRefPtr<typechecker::CheckedExpression>> maybe_checked_expr = JaktInternal::OptionalNone();
if ((!(((param).requires_label)))){
if ((((args).size()) > consumed_arg)){
const Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> name_span_expr_ = ((args)[consumed_arg]);
const String name = ((name_span_expr_).get<0>());
const utility::Span span = ((name_span_expr_).get<1>());
const NonnullRefPtr<parser::ParsedExpression> expr = ((name_span_expr_).get<2>());

(maybe_checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,((((param).variable)).type_id))))));
((consumed_arg++));
}
else {
TRY((((*this).error(TRY((String::formatted(String("Missing argument for function parameter {}"),((((param).variable)).name)))),span))));
continue;
}

}
else {
(maybe_checked_expr = ((param).default_value));
if ((((args).size()) > consumed_arg)){
const Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>> name_span_expr_ = ((args)[consumed_arg]);
const String name = ((name_span_expr_).get<0>());
const utility::Span span = ((name_span_expr_).get<1>());
const NonnullRefPtr<parser::ParsedExpression> expr = ((name_span_expr_).get<2>());

if (TRY((((*this).validate_argument_label(param,name,span,expr,maybe_checked_expr))))){
(maybe_checked_expr = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,((((param).variable)).type_id))))));
((consumed_arg++));
}
}
}

if (((maybe_checked_expr).has_value())){
NonnullRefPtr<typechecker::CheckedExpression> checked_arg = (maybe_checked_expr.value());
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_arg = TRY((((*this).try_to_promote_constant_expr_to_type(((((param).variable)).type_id),checked_arg,span))));
(checked_arg = promoted_arg.value_or_lazy_evaluated([&] { return checked_arg; }));
TRY((((resolved_args).push((Tuple{((((param).variable)).name), span, checked_arg})))));
}
}

}
}

return (resolved_args);
}
else {
TRY((((*this).error(String("Wrong number of arguments"),span))));
return ((TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<typechecker::CheckedExpression>>>::create_with({})))));
}

}
}

typechecker::CheckedEnum typechecker::Typechecker::get_enum(const typechecker::EnumId id) const {
{
return (((((*this).program))->get_enum(id)));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_function_predecl(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_function_predecl(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedFunction> _magic = ((((parsed_namespace).functions)).iterator());
for (;;){
Optional<parser::ParsedFunction> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedFunction fun = (_magic_value.value());
{
TRY((((*this).typecheck_function_predecl(fun,scope_id,JaktInternal::OptionalNone()))));
}

}
}

}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum_constructor(const parser::ParsedRecord record,const typechecker::EnumId enum_id,const typechecker::ScopeId parent_scope_id) {
{
u64 next_constant_value = static_cast<u64>(0ULL);
Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();NonnullRefPtr<parser::ParsedType> const& underlying_type = __jakt_match_value.underlying_type;
Array<parser::ValueEnumVariant> const& variants = __jakt_match_value.variants;
{
const typechecker::TypeId underlying_type_id = TRY((((*this).typecheck_typename(underlying_type,parent_scope_id,JaktInternal::OptionalNone()))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::ValueEnumVariant> _magic = ((variants).iterator());
for (;;){
Optional<parser::ValueEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ValueEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' is defined more than once"),((variant).name)))),((variant).span)))));
}
else {
TRY((((seen_names).add(((variant).name)))));
const NonnullRefPtr<typechecker::CheckedExpression> expr = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::CheckedExpression>,ErrorOr<void>>{
auto __jakt_enum_value = (((((variant).value)).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::CheckedExpression>> __jakt_var_164; {
const NonnullRefPtr<typechecker::CheckedExpression> value_expression = TRY((((*this).cast_to_underlying((((variant).value).value()),parent_scope_id,underlying_type))));
const Optional<typechecker::NumberConstant> number_constant = ((value_expression)->to_number_constant(((*this).program)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<void>>{
auto __jakt_enum_value = (((number_constant).has_value()));
if (__jakt_enum_value == true) {
{
(next_constant_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u64, ErrorOr<void>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<u64>(((JaktInternal::checked_add<i64>(val,static_cast<i64>(1LL)))))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue((JaktInternal::checked_add<u64>(val,static_cast<u64>(1ULL))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<u64> __jakt_var_165; {
utility::todo(String("Implement floats"));
__jakt_var_165 = static_cast<u64>(0ULL); goto __jakt_label_159;

}
__jakt_label_159:; __jakt_var_165.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' in enum '{}' has a non-constant value: {}"),((variant).name),((enum_).name),value_expression))),((variant).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
__jakt_var_164 = value_expression; goto __jakt_label_158;

}
__jakt_label_158:; __jakt_var_164.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).cast_to_underlying(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::NumericConstant>(typename lexer::NumericConstant::U64(((next_constant_value++))),((variant).span)))),parent_scope_id,underlying_type)))));
}
}()))
;
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::WithValue(enum_id,((variant).name),expr,((variant).span))))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant).name),((enum_).type_id),false,((variant).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(((enum_).scope_id),((variant).name),var_id,((variant).span)))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();bool const& is_boxed = __jakt_match_value.is_boxed;
Array<parser::SumEnumVariant> const& variants = __jakt_match_value.variants;
{
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
{
ArrayIterator<parser::SumEnumVariant> _magic = ((variants).iterator());
for (;;){
Optional<parser::SumEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::SumEnumVariant variant = (_magic_value.value());
{
if (((seen_names).contains(((variant).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' is defined more than once"),((variant).name)))),((variant).span)))));
continue;
}
TRY((((seen_names).add(((variant).name)))));
const bool is_structlike = ((((((variant).params)).has_value()) && ((((((variant).params).value())).size()) > static_cast<size_t>(0ULL))) && ((((((((variant).params).value()))[static_cast<i64>(0LL)])).name) != String("")));
const bool is_typed = ((((((variant).params)).has_value()) && ((((((variant).params).value())).size()) == static_cast<size_t>(1ULL))) && ((((((((variant).params).value()))[static_cast<i64>(0LL)])).name) == String("")));
if (is_structlike){
Set<String> seen_fields = (TRY((Set<String>::create_with_values({}))));
Array<typechecker::VarId> fields = (TRY((Array<typechecker::VarId>::create_with({}))));
Array<typechecker::CheckedParameter> params = (TRY((Array<typechecker::CheckedParameter>::create_with({}))));
{
ArrayIterator<parser::ParsedVarDecl> _magic = (((((variant).params).value())).iterator());
for (;;){
Optional<parser::ParsedVarDecl> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedVarDecl param = (_magic_value.value());
{
if (((seen_fields).contains(((param).name)))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant '{}' has a member named '{}' more than once"),((variant).name),((param).name)))),((param).span)))));
continue;
}
TRY((((seen_fields).add(((param).name)))));
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
const typechecker::CheckedVariable checked_var = typechecker::CheckedVariable(((param).name),type_id,((param).is_mutable),((param).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
TRY((((params).push(typechecker::CheckedParameter(true,checked_var,JaktInternal::OptionalNone())))));
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint(type_id,((param).span)))));
}
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_var))));
TRY((((fields).push(var_id))));
}

}
}

TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::StructLike(enum_id,((variant).name),fields,((variant).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone(),false)));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}
else if (is_typed){
const parser::ParsedVarDecl param = (((((variant).params).value()))[static_cast<i64>(0LL)]);
const typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((param).parsed_type),((enum_).scope_id),((param).name)))));
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::Typed(enum_id,((variant).name),type_id,((variant).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::CheckedVariable variable = typechecker::CheckedVariable(String("value"),type_id,false,((param).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({typechecker::CheckedParameter(false,variable,JaktInternal::OptionalNone())})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::AlwaysReturns(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone(),false)));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}
else {
TRY((((((enum_).variants)).push(typename typechecker::CheckedEnumVariant::Untyped(enum_id,((variant).name),((variant).span))))));
const Optional<typechecker::FunctionId> maybe_enum_variant_constructor = TRY((((*this).find_function_in_scope(((enum_).scope_id),((variant).name)))));
if ((!(((maybe_enum_variant_constructor).has_value())))){
const bool can_function_throw = is_boxed;
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(parent_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor({}::{})"),((enum_).name),((variant).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,can_function_throw,TRY((String::formatted(String("enum-variant-constructor-block({}::{})"),((enum_).name),((variant).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((variant).name),((variant).span),typename parser::Visibility::Public(),TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Enum>(enum_id))))))),JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::AlwaysReturns(),typechecker::TypeId::none()),can_function_throw,typename parser::FunctionType::ImplicitEnumConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone(),false)));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(((enum_).scope_id),((variant).name),function_id,((variant).span)))));
}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_constructor(const parser::ParsedRecord parsed_record,const typechecker::StructId struct_id,const typechecker::ScopeId scope_id) {
{
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
const typechecker::CheckedStruct struct_ = ((*this).get_struct(struct_id));
const Optional<typechecker::FunctionId> constructor_id = TRY((((*this).find_function_in_scope(((struct_).scope_id),((parsed_record).name)))));
if (((constructor_id).has_value())){
if ((((((parsed_record).record_type)).index() == 1 /* Class */) && ((((parsed_record).definition_linkage)).index() == 1 /* External */))){
NonnullRefPtr<typechecker::CheckedFunction> func = ((*this).get_function((constructor_id.value())));
(((func)->linkage) = typename parser::FunctionLinkage::External());
}
}
else if ((!(((((parsed_record).definition_linkage)).index() == 1 /* External */)))){
const bool constructor_can_throw = ((((parsed_record).record_type)).index() == 1 /* Class */);
const typechecker::ScopeId function_scope_id = TRY((((*this).create_scope(((struct_).scope_id),constructor_can_throw,TRY((String::formatted(String("generated-constructor({})"),((parsed_record).name))))))));
const typechecker::ScopeId block_scope_id = TRY((((*this).create_scope(function_scope_id,constructor_can_throw,TRY((String::formatted(String("generated-constructor-block({})"),((parsed_record).name))))))));
const NonnullRefPtr<typechecker::CheckedFunction> checked_constructor = TRY((typechecker::CheckedFunction::create(((parsed_record).name),((parsed_record).name_span),typename parser::Visibility::Public(),struct_type_id,JaktInternal::OptionalNone(),(TRY((Array<typechecker::CheckedParameter>::create_with({})))),(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),typechecker::CheckedBlock((TRY((Array<NonnullRefPtr<typechecker::CheckedStatement>>::create_with({})))),block_scope_id,typename typechecker::BlockControlFlow::MayReturn(),typechecker::TypeId::none()),constructor_can_throw,typename parser::FunctionType::ImplicitConstructor(),typename parser::FunctionLinkage::Internal(),function_scope_id,true,JaktInternal::OptionalNone(),false)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->functions)).push(checked_constructor))));
NonnullRefPtr<typechecker::CheckedFunction> func = (((((module)->functions)).last()).value());
{
ArrayIterator<typechecker::VarId> _magic = ((((((*this).get_struct(struct_id))).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
const typechecker::CheckedVariable field = ((*this).get_variable(field_id));
TRY((((((func)->params)).push(typechecker::CheckedParameter(true,field,JaktInternal::OptionalNone())))));
}

}
}

TRY((((*this).add_function_to_scope(((struct_).scope_id),((parsed_record).name),typechecker::FunctionId(((*this).current_module_id),(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->functions)).size()),static_cast<size_t>(1ULL)))),((parsed_record).name_span)))));
}
(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_var_decl(const parser::ParsedVarDecl var,const NonnullRefPtr<parser::ParsedExpression> init,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
typechecker::TypeId lhs_type_id = TRY((((*this).typecheck_typename(((var).parsed_type),scope_id,((var).name)))));
NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression(init,scope_id,safety_mode,lhs_type_id))));
const typechecker::TypeId rhs_type_id = typechecker::expression_type(checked_expr);
if ((((lhs_type_id).equals(typechecker::unknown_type_id())) && (!(((rhs_type_id).equals(typechecker::unknown_type_id())))))){
(lhs_type_id = rhs_type_id);
}
const Optional<NonnullRefPtr<typechecker::CheckedExpression>> promoted_rhs = TRY((((*this).try_to_promote_constant_expr_to_type(lhs_type_id,checked_expr,((init)->span())))));
if (((promoted_rhs).has_value())){
(checked_expr = (promoted_rhs.value()));
}
const typechecker::StructId weak_ptr_struct_id = TRY((((*this).find_struct_in_prelude(String("WeakPtr")))));
const typechecker::StructId optional_struct_id = TRY((((*this).find_struct_in_prelude(String("Optional")))));
const NonnullRefPtr<typechecker::Type> lhs_type = ((*this).get_type(lhs_type_id));
TRY((((*this).check_that_type_doesnt_contain_reference(lhs_type_id,span))));
if (((lhs_type)->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (lhs_type->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> args = (lhs_type->get<typechecker::Type::GenericInstance>()).args;
if (((id).equals(weak_ptr_struct_id))){
if ((!(((var).is_mutable)))){
TRY((((*this).error(String("Weak reference must be mutable"),((var).span)))));
}
if (((!(((lhs_type_id).equals(rhs_type_id)))) && ((!(((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id)))) && (!(((rhs_type_id).equals(typechecker::unknown_type_id()))))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),typechecker::expression_span(checked_expr)))));
}
}
else if (((id).equals(optional_struct_id))){
if (((!(((lhs_type_id).equals(rhs_type_id)))) && ((!(((((args)[static_cast<i64>(0LL)])).equals(rhs_type_id)))) && (!(((rhs_type_id).equals(typechecker::unknown_type_id()))))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),typechecker::expression_span(checked_expr)))));
}
}
else {
if (((!(((lhs_type_id).equals(rhs_type_id)))) && (!(((rhs_type_id).equals(typechecker::unknown_type_id())))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),typechecker::expression_span(checked_expr)))));
}
}

}
else if (((lhs_type)->is_builtin())){
const Optional<typechecker::NumberConstant> number_constant = ((checked_expr)->to_number_constant(((*this).program)));
bool is_rhs_zero = false;
if (((number_constant).has_value())){
(is_rhs_zero = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<i64>(0LL)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<u64>(0ULL)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((value == static_cast<f64>(0)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
if (((!((((*this).is_numeric(lhs_type_id)) && is_rhs_zero))) && (((*this).is_integer(lhs_type_id)) ^ ((*this).is_integer(rhs_type_id))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),typechecker::expression_span(checked_expr)))));
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::Garbage>(span))));
}
}
else {
if (((!(((lhs_type_id).equals(rhs_type_id)))) && (!(((rhs_type_id).equals(typechecker::unknown_type_id())))))){
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(lhs_type_id)))),TRY((((*this).type_name(rhs_type_id))))))),typechecker::expression_span(checked_expr)))));
}
}

const typechecker::CheckedVariable checked_var = typechecker::CheckedVariable(((var).name),lhs_type_id,((var).is_mutable),((var).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
if ((((*this).dump_type_hints) && ((((var).inlay_span)).has_value()))){
TRY((((*this).dump_type_hint(lhs_type_id,(((var).inlay_span).value())))));
}
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(checked_var))));
TRY((((*this).add_var_to_scope(scope_id,((var).name),var_id,((checked_var).definition_span)))));
if (((checked_expr)->index() == 27 /* Function */)){
const Array<typechecker::CheckedParameter> params = (checked_expr->get<typechecker::CheckedExpression::Function>()).params;
const bool can_throw = (checked_expr->get<typechecker::CheckedExpression::Function>()).can_throw;
const typechecker::TypeId return_type_id = (checked_expr->get<typechecker::CheckedExpression::Function>()).return_type_id;
const typechecker::CheckedBlock block = (checked_expr->get<typechecker::CheckedExpression::Function>()).block;
const utility::Span span = (checked_expr->get<typechecker::CheckedExpression::Function>()).span;
const typechecker::TypeId type_id = (checked_expr->get<typechecker::CheckedExpression::Function>()).type_id;
if ((!(((TRY((((*this).find_function_in_scope(scope_id,((var).name)))))).has_value())))){
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = TRY((typechecker::CheckedFunction::create(((var).name),((var).span),typename parser::Visibility::Public(),return_type_id,JaktInternal::OptionalNone(),params,(TRY((Array<typechecker::FunctionGenericParameter>::create_with({})))),block,can_throw,typename parser::FunctionType::Normal(),typename parser::FunctionLinkage::Internal(),scope_id,false,JaktInternal::OptionalNone(),false)));
const typechecker::FunctionId function_id = TRY((((module)->add_function(checked_function))));
TRY((((*this).add_function_to_scope(scope_id,((var).name),function_id,span))));
}
}
return (TRY((typechecker::CheckedStatement::template create<typename typechecker::CheckedStatement::VarDecl>(var_id,checked_expr,span))));
}
}

ErrorOr<Optional<Array<typechecker::CheckedEnumVariantBinding>>> typechecker::Typechecker::typecheck_enum_variant_bindings(const typechecker::CheckedEnumVariant variant,const Array<parser::EnumVariantPatternArgument> bindings,const utility::Span span) {
{
if (((variant).index() == 1 /* Typed */)){
const typechecker::TypeId type_id = (variant.get<typechecker::CheckedEnumVariant::Typed>()).type_id;
if ((((bindings).size()) != static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((String::formatted(String("Enum variant {} must have exactly one argument"),((variant).name())))),span))));
return (JaktInternal::OptionalNone());
}
return ((TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({typechecker::CheckedEnumVariantBinding(JaktInternal::OptionalNone(),((((bindings)[static_cast<i64>(0LL)])).binding),type_id,span)})))));
}
if (((variant).index() == 3 /* StructLike */)){
const Array<typechecker::VarId> fields = (variant.get<typechecker::CheckedEnumVariant::StructLike>()).fields;
Array<typechecker::CheckedVariable> checked_vars = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
Array<typechecker::CheckedEnumVariantBinding> checked_enum_variant_bindings = (TRY((Array<typechecker::CheckedEnumVariantBinding>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
TRY((((checked_vars).push(((*this).get_variable(field))))));
}

}
}

{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((bindings).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument binding = (_magic_value.value());
{
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((checked_vars).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
const String binding_name = ((binding).name).value_or_lazy_evaluated([&] { return ((binding).binding); });
const typechecker::TypeId type_id = ((var).type_id);
if ((binding_name == ((var).name))){
TRY((((checked_enum_variant_bindings).push(typechecker::CheckedEnumVariantBinding(((binding).name),((binding).binding),type_id,span)))));
break;
}
}

}
}

}

}
}

if ((((checked_enum_variant_bindings).size()) > static_cast<size_t>(0ULL))){
return (checked_enum_variant_bindings);
}
return (JaktInternal::OptionalNone());
}
else {
return (JaktInternal::OptionalNone());
}

}
}

ErrorOr<void> typechecker::Typechecker::typecheck_enum(const parser::ParsedRecord record,const typechecker::EnumId enum_id,const typechecker::ScopeId parent_scope_id) {
{
{
ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_method(((method).parsed_function),typename typechecker::StructOrEnumId::Enum(enum_id)))));
}

}
}

}
return {};
}

ErrorOr<typechecker::CheckedParameter> typechecker::Typechecker::typecheck_parameter(const parser::ParsedParameter parameter,const typechecker::ScopeId scope_id,const bool first,const Optional<typechecker::TypeId> this_arg_type_id,const Optional<typechecker::ScopeId> check_scope) {
{
typechecker::TypeId type_id = TRY((((*this).typecheck_typename(((((parameter).variable)).parsed_type),scope_id,((((parameter).variable)).name)))));
if ((first && (((((parameter).variable)).name) == String("this")))){
if (((this_arg_type_id).has_value())){
(type_id = (this_arg_type_id.value()));
}
}
const typechecker::CheckedVariable variable = typechecker::CheckedVariable(((((parameter).variable)).name),type_id,((((parameter).variable)).is_mutable),((((parameter).variable)).span),JaktInternal::OptionalNone(),typename parser::Visibility::Public());
Optional<NonnullRefPtr<typechecker::CheckedExpression>> checked_default_value = JaktInternal::OptionalNone();
if (((((parameter).default_argument)).has_value())){
NonnullRefPtr<typechecker::CheckedExpression> checked_default_value_expr = TRY((((*this).typecheck_expression((((parameter).default_argument).value()),scope_id,typename typechecker::SafetyMode::Safe(),type_id))));
if (((checked_default_value_expr)->index() == 23 /* OptionalNone */)){
const utility::Span expr_span = (checked_default_value_expr->get<typechecker::CheckedExpression::OptionalNone>()).span;
(checked_default_value_expr = TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::OptionalNone>(expr_span,type_id))));
}
const typechecker::TypeId default_value_type_id = typechecker::expression_type(checked_default_value_expr);
(checked_default_value = checked_default_value_expr);
if ((!(((default_value_type_id).equals(type_id))))){
(checked_default_value = JaktInternal::OptionalNone());
TRY((((*this).error(TRY((String::formatted(String("Type mismatch: expected {}, but got {}"),TRY((((*this).type_name(type_id)))),TRY((((*this).type_name(default_value_type_id))))))),((parameter).span)))));
}
}
const typechecker::CheckedParameter checked_parameter = typechecker::CheckedParameter(((parameter).requires_label),variable,checked_default_value);
if (((check_scope).has_value())){
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
const typechecker::VarId var_id = TRY((((module)->add_variable(variable))));
TRY((((*this).add_var_to_scope((check_scope.value()),((((parameter).variable)).name),var_id,((((parameter).variable)).span)))));
}
return (checked_parameter);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct(const parser::ParsedRecord record,const typechecker::StructId struct_id,const typechecker::ScopeId parent_scope_id) {
{
const typechecker::TypeId struct_type_id = TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
(((*this).current_struct_type_id) = struct_type_id);
{
ArrayIterator<parser::ParsedMethod> _magic = ((((record).methods)).iterator());
for (;;){
Optional<parser::ParsedMethod> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMethod method = (_magic_value.value());
{
TRY((((*this).typecheck_method(((method).parsed_function),typename typechecker::StructOrEnumId::Struct(struct_id)))));
}

}
}

(((*this).current_struct_type_id) = JaktInternal::OptionalNone());
}
return {};
}

ErrorOr<void> typechecker::Typechecker::typecheck_struct_predecl_initial(const parser::ParsedRecord parsed_record,const size_t struct_index,const size_t module_struct_len,const typechecker::ScopeId scope_id) {
{
const typechecker::ModuleId module_id = ((*this).current_module_id);
const typechecker::StructId struct_id = typechecker::StructId(((*this).current_module_id),(JaktInternal::checked_add<size_t>(struct_index,module_struct_len)));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
TRY((((((module)->types)).push(TRY((typechecker::Type::template create<typename typechecker::Type::Struct>(struct_id)))))));
const typechecker::TypeId struct_type_id = typechecker::TypeId(module_id,(JaktInternal::checked_sub<size_t>(((((((*this).current_module()))->types)).size()),static_cast<size_t>(1ULL))));
TRY((((*this).add_type_to_scope(scope_id,((parsed_record).name),struct_type_id,((parsed_record).name_span)))));
TRY((((((module)->structures)).push(typechecker::CheckedStruct(((parsed_record).name),((parsed_record).name_span),(TRY((Array<typechecker::TypeId>::create_with({})))),(TRY((Array<typechecker::VarId>::create_with({})))),((*this).prelude_scope_id()),((parsed_record).definition_linkage),((parsed_record).record_type),struct_type_id)))));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>> typechecker::Typechecker::typecheck_match(const NonnullRefPtr<parser::ParsedExpression> expr,const Array<parser::ParsedMatchCase> cases,const utility::Span span,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode) {
{
const NonnullRefPtr<typechecker::CheckedExpression> checked_expr = TRY((((*this).typecheck_expression_and_dereference_if_needed(expr,scope_id,safety_mode,JaktInternal::OptionalNone(),span))));
const typechecker::TypeId subject_type_id = typechecker::expression_type(checked_expr);
const NonnullRefPtr<typechecker::Type> type_to_match_on = ((*this).get_type(subject_type_id));
Array<typechecker::CheckedMatchCase> checked_cases = (TRY((Array<typechecker::CheckedMatchCase>::create_with({}))));
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
Optional<typechecker::TypeId> final_result_type = JaktInternal::OptionalNone();
if (((type_to_match_on)->index() == 20 /* GenericEnumInstance */)){
const typechecker::EnumId id = (type_to_match_on->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> args = (type_to_match_on->get<typechecker::Type::GenericEnumInstance>()).args;
const typechecker::CheckedEnum enum_ = ((*this).get_enum(id));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((enum_).generic_parameters)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const String generic = TRY((((((((enum_).generic_parameters))[i])).to_string())));
const String argument_type = TRY((((((args)[i])).to_string())));
TRY((((generic_inferences).set(generic,argument_type))));
}

}
}

}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = *type_to_match_on;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
Set<String> covered_variants = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if ((((variant_names).size()) == static_cast<size_t>(1ULL))){
const Tuple<String,utility::Span> temp = ((variant_names)[static_cast<i64>(0LL)]);
(variant_names = (TRY((Array<Tuple<String,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names)[static_cast<i64>(0LL)])).get<1>())}), temp})))));
}
if (((variant_names).is_empty())){
return JaktInternal::LoopContinue{};
}
if ((((((variant_names)[static_cast<i64>(0LL)])).get<0>()) != ((enum_).name))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' does not match enum '{}'"),((((variant_names)[static_cast<i64>(0LL)])).get<0>()),((enum_).name)))),((((variant_names)[static_cast<i64>(0LL)])).get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
Optional<typechecker::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant v = (_magic_value.value());
{
if ((((v).name()) == ((((variant_names)[static_cast<i64>(1LL)])).get<0>()))){
(matched_variant = v);
(variant_index = i);
}
((i++));
}

}
}

if ((!(((matched_variant).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Enum '{}' does not contain a variant named '{}'"),((enum_).name),((((variant_names)[static_cast<i64>(1LL)])).get<0>())))),((case_).marker_span)))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,(TRY((Array<typechecker::CheckedMatchCase>::create_with({})))),span,typechecker::unknown_type_id(),false))));
}
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (matched_variant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
TRY((((covered_variants).add(name))));
if ((!(((variant_arguments).is_empty())))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' cannot have arguments"),name))),arguments_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((covered_variants).add(name))));
if ((!(((variant_arguments).is_empty())))){
if ((((variant_arguments).size()) != static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((String::formatted(String("Match case {} must have exactly one argument"),name))),span))));
}
else {
const parser::EnumVariantPatternArgument variant_argument = ((variant_arguments)[static_cast<i64>(0LL)]);
const typechecker::TypeId variable_type_id = TRY((((*this).substitute_typevars_in_type(type_id,generic_inferences))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant_argument).binding),variable_type_id,false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((variant_argument).binding),var_id,span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
TRY((((covered_variants).add(name))));
Array<typechecker::CheckedVariable> field_variables = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId var_id = (_magic_value.value());
{
TRY((((field_variables).push(((((*this).program))->get_variable(var_id))))));
}

}
}

Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((variant_arguments).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
if ((!(((((arg).name)).has_value())))){
bool found_field_name = false;
Array<String> field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
TRY((((field_names).push(((var).name)))));
if ((((var).name) == ((arg).binding))){
(found_field_name = true);
}
}

}
}

if ((!(found_field_name))){
Array<String> unused_field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((field_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String field_name = (_magic_value.value());
{
if (((seen_names).contains(field_name))){
continue;
}
TRY((((unused_field_names).push(field_name))));
}

}
}

TRY((((*this).error_with_hint(TRY((String::formatted(String("Match case argument '{}' for struct-like enum variant cannot be anon"),((arg).binding)))),((arg).span),TRY((String::formatted(String("Available arguments are: {}\n"),utility::join(unused_field_names,String(", "))))),((arg).span)))));
continue;
}
}
const String arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); });
if (((seen_names).contains(arg_name))){
TRY((((*this).error(TRY((String::formatted(String("match case argument '{}' is already defined"),arg_name))),((arg).span)))));
continue;
}
TRY((((seen_names).add(arg_name))));
Optional<typechecker::CheckedVariable> matched_field_variable = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
if ((((var).name) == arg_name)){
(matched_field_variable = var);
}
}

}
}

JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((matched_field_variable).has_value()));
if (__jakt_enum_value == true) {
{
const typechecker::TypeId substituted_type_id = TRY((((*this).substitute_typevars_in_type((((matched_field_variable.value())).type_id),(TRY((Dictionary<String, String>::create_with_entries({}))))))));
const utility::Span matched_span = (((matched_field_variable.value())).definition_span);
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint((((matched_field_variable.value())).type_id),((arg).span)))));
}
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((arg).binding),substituted_type_id,false,matched_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((arg).binding),var_id,span))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Match case argument '{}' does not exist in struct-like enum variant '{}'"),arg_name,name))),((arg).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("implement {} match case for matched variant"),matched_variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant(((((variant_names)[static_cast<i64>(1LL)])).get<0>()),variant_arguments,subject_type_id,(variant_index.value()),new_scope_id,checked_body,(((matched_variant.value())).span()));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Multiple catch-all cases in match are not allowed"),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_span = ((case_).marker_span));
}

const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

}

}
}

Array<String> enum_variant_names = (TRY((Array<String>::create_with({}))));
Array<String> missing_variants = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
ArrayIterator<String> _magic = ((enum_variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(variant))))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ((((missing_variants).size()) > static_cast<size_t>(0ULL))){
if ((!(seen_catch_all))){
StringBuilder str_missing_values = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((missing_variants).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((str_missing_values).append_c_string(((((missing_variants)[i])).c_string())))));
if ((i < (JaktInternal::checked_sub<size_t>(((missing_variants).size()),static_cast<size_t>(1ULL))))){
TRY((((str_missing_values).append_c_string(((String(", ")).c_string())))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("match expression is not exhaustive, missing variants are: {}"),TRY((((str_missing_values).to_string())))))),span))));
}
}
else {
if (seen_catch_all){
TRY((((*this).error(String("all variants are covered, but an irrefutable pattern is also present"),span))));
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& enum_id = __jakt_match_value.id;
{
const typechecker::CheckedEnum enum_ = ((*this).get_enum(enum_id));
bool seen_catch_all = false;
Optional<utility::Span> catch_all_span = JaktInternal::OptionalNone();
Set<String> covered_variants = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if ((((variant_names).size()) == static_cast<size_t>(1ULL))){
const Tuple<String,utility::Span> temp = ((variant_names)[static_cast<i64>(0LL)]);
(variant_names = (TRY((Array<Tuple<String,utility::Span>>::create_with({(Tuple{((enum_).name), ((((variant_names)[static_cast<i64>(0LL)])).get<1>())}), temp})))));
}
if (((variant_names).is_empty())){
return JaktInternal::LoopContinue{};
}
if ((((((variant_names)[static_cast<i64>(0LL)])).get<0>()) != ((enum_).name))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' does not match enum '{}'"),((((variant_names)[static_cast<i64>(0LL)])).get<0>()),((enum_).name)))),((((variant_names)[static_cast<i64>(0LL)])).get<1>())))));
return JaktInternal::LoopContinue{};
}
size_t i = static_cast<size_t>(0ULL);
Optional<typechecker::CheckedEnumVariant> matched_variant = JaktInternal::OptionalNone();
Optional<size_t> variant_index = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant v = (_magic_value.value());
{
if ((((v).name()) == ((((variant_names)[static_cast<i64>(1LL)])).get<0>()))){
(matched_variant = v);
(variant_index = i);
}
((i++));
}

}
}

if ((!(((matched_variant).has_value())))){
TRY((((*this).error(TRY((String::formatted(String("Enum '{}' does not contain a variant named '{}'"),((enum_).name),((((variant_names)[static_cast<i64>(1LL)])).get<0>())))),((case_).marker_span)))));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,(TRY((Array<typechecker::CheckedMatchCase>::create_with({})))),span,typechecker::unknown_type_id(),false))));
}
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
NonnullRefPtr<typechecker::Module> module = ((*this).current_module());
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = (matched_variant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
TRY((((covered_variants).add(name))));
if ((!(((variant_arguments).is_empty())))){
TRY((((*this).error(TRY((String::formatted(String("Match case '{}' cannot have arguments"),name))),arguments_span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
utility::Span const& span = __jakt_match_value.span;
{
TRY((((covered_variants).add(name))));
if ((!(((variant_arguments).is_empty())))){
if ((((variant_arguments).size()) != static_cast<size_t>(1ULL))){
TRY((((*this).error(TRY((String::formatted(String("Match case {} must have exactly one argument"),name))),span))));
}
else {
const parser::EnumVariantPatternArgument variant_argument = ((variant_arguments)[static_cast<i64>(0LL)]);
const typechecker::TypeId variable_type_id = TRY((((*this).substitute_typevars_in_type(type_id,generic_inferences))));
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((variant_argument).binding),variable_type_id,false,span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((variant_argument).binding),var_id,span))));
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
TRY((((covered_variants).add(name))));
Array<typechecker::CheckedVariable> field_variables = (TRY((Array<typechecker::CheckedVariable>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId var_id = (_magic_value.value());
{
TRY((((field_variables).push(((((*this).program))->get_variable(var_id))))));
}

}
}

Set<String> seen_names = (TRY((Set<String>::create_with_values({}))));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((variant_arguments).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
if ((!(((((arg).name)).has_value())))){
bool found_field_name = false;
Array<String> field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
TRY((((field_names).push(((var).name)))));
if ((((var).name) == ((arg).binding))){
(found_field_name = true);
}
}

}
}

if ((!(found_field_name))){
Array<String> unused_field_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((field_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String field_name = (_magic_value.value());
{
if (((seen_names).contains(field_name))){
continue;
}
TRY((((unused_field_names).push(field_name))));
}

}
}

TRY((((*this).error_with_hint(TRY((String::formatted(String("Match case argument '{}' for struct-like enum variant cannot be anon"),((arg).binding)))),((arg).span),TRY((String::formatted(String("Available arguments are: {}\n"),utility::join(unused_field_names,String(", "))))),((arg).span)))));
continue;
}
}
const String arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); });
if (((seen_names).contains(arg_name))){
TRY((((*this).error(TRY((String::formatted(String("match case argument '{}' is already defined"),arg_name))),((arg).span)))));
continue;
}
TRY((((seen_names).add(arg_name))));
Optional<typechecker::CheckedVariable> matched_field_variable = JaktInternal::OptionalNone();
{
ArrayIterator<typechecker::CheckedVariable> _magic = ((field_variables).iterator());
for (;;){
Optional<typechecker::CheckedVariable> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedVariable var = (_magic_value.value());
{
if ((((var).name) == arg_name)){
(matched_field_variable = var);
}
}

}
}

JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto __jakt_enum_value = (((matched_field_variable).has_value()));
if (__jakt_enum_value == true) {
{
const typechecker::TypeId substituted_type_id = TRY((((*this).substitute_typevars_in_type((((matched_field_variable.value())).type_id),(TRY((Dictionary<String, String>::create_with_entries({}))))))));
const utility::Span matched_span = (((matched_field_variable.value())).definition_span);
if (((*this).dump_type_hints)){
TRY((((*this).dump_type_hint((((matched_field_variable.value())).type_id),((arg).span)))));
}
const typechecker::VarId var_id = TRY((((module)->add_variable(typechecker::CheckedVariable(((arg).binding),substituted_type_id,false,matched_span,JaktInternal::OptionalNone(),typename parser::Visibility::Public())))));
TRY((((*this).add_var_to_scope(new_scope_id,((arg).binding),var_id,span))));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
TRY((((*this).error(TRY((String::formatted(String("Match case argument '{}' does not exist in struct-like enum variant '{}'"),arg_name,name))),((arg).span)))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("implement {} match case for matched variant"),matched_variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant(((((variant_names)[static_cast<i64>(1LL)])).get<0>()),variant_arguments,subject_type_id,(variant_index.value()),new_scope_id,checked_body,(((matched_variant.value())).span()));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Multiple catch-all cases in match are not allowed"),((case_).marker_span)))));
}
else {
(seen_catch_all = true);
(catch_all_span = ((case_).marker_span));
}

const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

}

}
}

Array<String> enum_variant_names = (TRY((Array<String>::create_with({}))));
Array<String> missing_variants = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((enum_variant_names).push(((variant).name())))));
}

}
}

{
ArrayIterator<String> _magic = ((enum_variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String variant = (_magic_value.value());
{
if ((!(((covered_variants).contains(variant))))){
TRY((((missing_variants).push(variant))));
}
}

}
}

if ((((missing_variants).size()) > static_cast<size_t>(0ULL))){
if ((!(seen_catch_all))){
StringBuilder str_missing_values = TRY((StringBuilder::create()));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((missing_variants).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((str_missing_values).append_c_string(((((missing_variants)[i])).c_string())))));
if ((i < (JaktInternal::checked_sub<size_t>(((missing_variants).size()),static_cast<size_t>(1ULL))))){
TRY((((str_missing_values).append_c_string(((String(", ")).c_string())))));
}
}

}
}

TRY((((*this).error(TRY((String::formatted(String("match expression is not exhaustive, missing variants are: {}"),TRY((((str_missing_values).to_string())))))),span))));
}
}
else {
if (seen_catch_all){
TRY((((*this).error(String("all variants are covered, but an irrefutable pattern is also present"),span))));
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
{
TRY((((*this).error(String("Can't match on 'void' type"),typechecker::expression_span(checked_expr)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
bool is_enum_match = false;
bool is_value_match = false;
bool seen_catch_all = false;
bool all_variants_constant = true;
{
ArrayIterator<parser::ParsedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<parser::ParsedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchCase case_ = (_magic_value.value());
{
{
ArrayIterator<parser::ParsedMatchPattern> _magic = ((((case_).patterns)).iterator());
for (;;){
Optional<parser::ParsedMatchPattern> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedMatchPattern pattern = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedExpression>>>{
auto&& __jakt_match_variant = pattern;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedMatchPattern::EnumVariant>();Array<Tuple<String,utility::Span>> const& variant_name = __jakt_match_value.variant_name;
Array<parser::EnumVariantPatternArgument> const& variant_arguments = __jakt_match_value.variant_arguments;
utility::Span const& arguments_span = __jakt_match_value.arguments_span;
{
Array<Tuple<String,utility::Span>> variant_names = variant_name;
if (is_value_match){
TRY((((*this).error(String("Cannot have an enum match case in a match expression containing value matches"),((case_).marker_span)))));
}
if ((((variant_names).size()) == static_cast<size_t>(0ULL))){
TRY((((((*this).compiler))->panic(String("typecheck_match - else - EnumVariant - variant_names.size() == 0")))));
}
(is_enum_match = true);
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-enum-variant({})"),variant_names)))))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::EnumVariant((((((variant_names).last()).value())).get<0>()),variant_arguments,subject_type_id,static_cast<size_t>(0ULL),new_scope_id,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::CatchAll>();
{
if (seen_catch_all){
TRY((((*this).error(String("Cannot have multiple catch-all match cases"),((case_).marker_span)))));
}
(seen_catch_all = true);
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),String("catch-all")))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::CatchAll(checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedMatchPattern::Expression>();
NonnullRefPtr<parser::ParsedExpression> const& expr = __jakt_match_value.value;
{
if (is_enum_match){
TRY((((*this).error(String("Cannot have a value match case in a match expression containing enum matches"),((case_).marker_span)))));
}
(is_value_match = true);
const NonnullRefPtr<typechecker::CheckedExpression> checked_expression = TRY((((*this).typecheck_expression(expr,scope_id,safety_mode,(subject_type_id)))));
if ((!(((((checked_expression)->to_number_constant(((*this).program)))).has_value())))){
(all_variants_constant = false);
}
Dictionary<String,String> generic_inferences = (TRY((Dictionary<String, String>::create_with_entries({}))));
TRY((((*this).check_types_for_compat(typechecker::expression_type(checked_expression),subject_type_id,((generic_inferences)),((case_).marker_span)))));
const typechecker::ScopeId new_scope_id = TRY((((*this).create_scope(scope_id,((TRY((((*this).get_scope(scope_id)))))->can_throw),TRY((String::formatted(String("catch-expression({})"),expr)))))));
const Tuple<typechecker::CheckedMatchBody,Optional<typechecker::TypeId>> checked_tuple = TRY((((*this).typecheck_match_body(((case_).body),new_scope_id,safety_mode,((generic_inferences)),final_result_type,((case_).marker_span)))));
const typechecker::CheckedMatchBody checked_body = ((checked_tuple).get<0>());
(final_result_type = ((checked_tuple).get<1>()));
const typechecker::CheckedMatchCase checked_match_case = typename typechecker::CheckedMatchCase::Expression(checked_expression,checked_body,((case_).marker_span));
TRY((((checked_cases).push(checked_match_case))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

}

}
}

if ((is_value_match && (!(seen_catch_all)))){
TRY((((*this).error(String("match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"),span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (TRY((typechecker::CheckedExpression::template create<typename typechecker::CheckedExpression::Match>(checked_expr,checked_cases,span,final_result_type.value_or_lazy_evaluated([&] { return typechecker::void_type_id(); }),true))));
}
}

ErrorOr<typechecker::TypeId> typechecker::Typechecker::typecheck_generic_resolved_type(const String name,const Array<typechecker::TypeId> checked_inner_types,const typechecker::ScopeId scope_id,const utility::Span span) {
{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,name))));
if (((struct_id).has_value())){
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericInstance>((struct_id.value()),checked_inner_types))))))));
}
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,name))));
if (((enum_id).has_value())){
return (TRY((((*this).find_or_add_type_id(TRY((typechecker::Type::template create<typename typechecker::Type::GenericEnumInstance>((enum_id.value()),checked_inner_types))))))));
}
TRY((((*this).error(TRY((String::formatted(String("could not find {}"),name))),span))));
return (typechecker::unknown_type_id());
}
}

typechecker::BlockControlFlow typechecker::Typechecker::maybe_statement_control_flow(const Optional<NonnullRefPtr<typechecker::CheckedStatement>> statement,const typechecker::BlockControlFlow other_branch) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow,typechecker::BlockControlFlow>{
auto __jakt_enum_value = (((statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((*this).statement_control_flow((statement.value()))));
}
else {
return JaktInternal::ExplicitValue(((other_branch).partial()));
}
}()))
);
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_jakt_main(const parser::ParsedFunction parsed_function) {
{
const String param_type_error = String("Main function must take a single array of strings as its parameter");
if ((((((parsed_function).params)).size()) > static_cast<size_t>(1ULL))){
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}
if ((!(((((parsed_function).params)).is_empty())))){
if (((((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type))->index() == 3 /* JaktArray */)){
const NonnullRefPtr<parser::ParsedType> inner = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type)->get<parser::ParsedType::JaktArray>()).inner;
const utility::Span span = (((((((((parsed_function).params))[static_cast<i64>(0LL)])).variable)).parsed_type)->get<parser::ParsedType::JaktArray>()).span;
if (((inner)->index() == 0 /* Name */)){
const String name = (inner->get<parser::ParsedType::Name>()).name;
const utility::Span span = (inner->get<parser::ParsedType::Name>()).span;
if ((name != String("String"))){
TRY((((*this).error(param_type_error,span))));
}
}
else {
TRY((((*this).error(param_type_error,span))));
}

}
else {
TRY((((*this).error(param_type_error,((parsed_function).name_span)))));
}

}
const String return_type_error = String("Main function must return c_int");
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = *((parsed_function).return_type);
switch(__jakt_match_variant.index()) {
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::ParsedType::Empty>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::ParsedType::Name>();String const& name = __jakt_match_value.name;
utility::Span const& span = __jakt_match_value.span;
{
if ((name != String("c_int"))){
TRY((((*this).error(return_type_error,span))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(return_type_error,((parsed_function).return_type_span)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return {};
}

ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::Typechecker::typecheck_for(const String iterator_name,const utility::Span name_span,const NonnullRefPtr<parser::ParsedExpression> range,const parser::ParsedBlock block,const typechecker::ScopeId scope_id,const typechecker::SafetyMode safety_mode,const utility::Span span) {
{
const Optional<utility::Span> maybe_span = ((block).find_yield_span());
if (((maybe_span).has_value())){
TRY((((*this).error(String("a 'for' loop block is not allowed to yield values"),(maybe_span.value())))));
}
const NonnullRefPtr<typechecker::CheckedExpression> iterable_expr = TRY((((*this).typecheck_expression(range,scope_id,safety_mode,JaktInternal::OptionalNone()))));
bool iterable_should_be_mutable = false;
const NonnullRefPtr<typechecker::Type> iterable_type = ((((*this).program))->get_type(typechecker::expression_type(iterable_expr)));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>>>{
auto&& __jakt_match_variant = *iterable_type;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
{
(iterable_should_be_mutable = true);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(id));
const Optional<typechecker::FunctionId> next_method_function_id = TRY((((*this).find_function_in_scope(((struct_).scope_id),String("next")))));
if ((!(((next_method_function_id).has_value())))){
TRY((((*this).error(String("Iterator must have a .next() method"),((range)->span())))));
}
else {
const NonnullRefPtr<typechecker::CheckedFunction> next_method_function = ((*this).get_function((next_method_function_id.value())));
if (((next_method_function)->is_mutating())){
(iterable_should_be_mutable = true);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((*this).get_struct(id));
const Optional<typechecker::FunctionId> next_method_function_id = TRY((((*this).find_function_in_scope(((struct_).scope_id),String("next")))));
if ((!(((next_method_function_id).has_value())))){
TRY((((*this).error(String("Iterator must have a .next() method"),((range)->span())))));
}
else {
const NonnullRefPtr<typechecker::CheckedFunction> next_method_function = ((*this).get_function((next_method_function_id.value())));
if (((next_method_function)->is_mutating())){
(iterable_should_be_mutable = true);
}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
TRY((((*this).error(String("Iterator must have a .next() method"),name_span))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
const NonnullRefPtr<parser::ParsedStatement> rewritten_statement = TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(String("_magic"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,JaktInternal::OptionalNone(),name_span),range,span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Loop>(parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(String("_magic_value"),TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,JaktInternal::OptionalNone(),name_span),TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic"),name_span))),parser::ParsedCall((TRY((Array<String>::create_with({})))),String("next"),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))))),false,name_span))),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::If>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::UnaryOp>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::MethodCall>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic_value"),name_span))),parser::ParsedCall((TRY((Array<String>::create_with({})))),String("has_value"),(TRY((Array<Tuple<String,utility::Span,NonnullRefPtr<parser::ParsedExpression>>>::create_with({})))),(TRY((Array<NonnullRefPtr<parser::ParsedType>>::create_with({}))))),false,name_span))),typename parser::UnaryOperator::LogicalNot(),name_span))),parser::ParsedBlock((TRY((Array<NonnullRefPtr<parser::ParsedStatement>>::create_with({TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Break>(span)))}))))),JaktInternal::OptionalNone(),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::VarDecl>(parser::ParsedVarDecl(iterator_name,TRY((parser::ParsedType::template create<typename parser::ParsedType::Empty>())),iterable_should_be_mutable,name_span,name_span),TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::ForcedUnwrap>(TRY((parser::ParsedExpression::template create<typename parser::ParsedExpression::Var>(String("_magic_value"),name_span))),name_span))),span))), TRY((parser::ParsedStatement::template create<typename parser::ParsedStatement::Block>(block,span)))}))))),span)))}))))),span)));
return (TRY((((*this).typecheck_statement(rewritten_statement,scope_id,safety_mode)))));
}
}

ErrorOr<void> typechecker::Typechecker::typecheck_namespace_constructors(const parser::ParsedNamespace parsed_namespace,const typechecker::ScopeId scope_id) {
{
const Array<typechecker::ScopeId> children = ((TRY((((*this).get_scope(scope_id)))))->children);
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((parsed_namespace).namespaces)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const parser::ParsedNamespace child_namespace = ((((parsed_namespace).namespaces))[i]);
const typechecker::ScopeId child_namespace_scope_id = ((children)[i]);
TRY((((*this).typecheck_namespace_constructors(child_namespace,child_namespace_scope_id))));
}

}
}

{
ArrayIterator<parser::ParsedRecord> _magic = ((((parsed_namespace).records)).iterator());
for (;;){
Optional<parser::ParsedRecord> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::ParsedRecord record = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find previously added struct")))));
}
TRY((((*this).typecheck_struct_constructor(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
const Optional<typechecker::StructId> struct_id = TRY((((*this).find_struct_in_scope(scope_id,((record).name)))));
if ((!(((struct_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find previously added struct")))));
}
TRY((((*this).typecheck_struct_constructor(record,(struct_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find previously added enum")))));
}
TRY((((*this).typecheck_enum_constructor(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
const Optional<typechecker::EnumId> enum_id = TRY((((((*this).program))->find_enum_in_scope(scope_id,((record).name)))));
if ((!(((enum_id).has_value())))){
TRY((((((*this).compiler))->panic(String("can't find previously added enum")))));
}
TRY((((*this).typecheck_enum_constructor(record,(enum_id.value()),scope_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

}
return {};
}

ErrorOr<String> typechecker::TypeId::to_string() const {
{
return (TRY((String::formatted(String("{}_{}"),((((*this).module)).id),((*this).id)))));
}
}

Optional<typechecker::TypeId> typechecker::TypeId::none() {
{
return (JaktInternal::OptionalNone());
}
}

bool typechecker::TypeId::equals(const typechecker::TypeId rhs) const {
{
return (((((((*this).module)).id) == ((((rhs).module)).id)) && (((*this).id) == ((rhs).id))));
}
}

ErrorOr<typechecker::TypeId> typechecker::TypeId::from_string(const String type_id_string) {
{
const Array<String> parts = TRY((((type_id_string).split('_'))));
if ((!((((parts).size()) == static_cast<size_t>(2ULL))))){
utility::panic(TRY((String::formatted(String("Failed to convert string `{}` to a TypeId: Wrong number of parts. (Wanted 2, got {})"),type_id_string,((parts).size())))));
}
const Optional<u32> module_id = ((((parts)[static_cast<i64>(0LL)])).to_uint());
const Optional<u32> type_id = ((((parts)[static_cast<i64>(1LL)])).to_uint());
if (((!(((module_id).has_value()))) || (!(((type_id).has_value()))))){
utility::panic(TRY((String::formatted(String("Failed to convert string `{}` to a TypeId. (module_id = {} ({}), type_id = {} ({}))"),type_id_string,module_id,((parts)[static_cast<i64>(0LL)]),type_id,((parts)[static_cast<i64>(1LL)])))));
}
return (typechecker::TypeId(typechecker::ModuleId((infallible_integer_cast<size_t>((((module_id).value()))))),(infallible_integer_cast<size_t>((((type_id).value()))))));
}
}

ErrorOr<typechecker::Value> typechecker::InterpreterScope::must_get(const String name) const {
{
if (((((*this).bindings)).contains(name))){
return (((((*this).bindings))[name]));
}
Optional<NonnullRefPtr<typechecker::InterpreterScope>> scope = ((*this).parent);
while (((scope).has_value())){
if ((((((scope.value()))->bindings)).contains(name))){
return ((((((scope.value()))->bindings))[name]));
}
(scope = (((scope.value()))->parent));
}
utility::panic(TRY((String::formatted(String("Could not find binding for {}"),name))));
}
}

bool typechecker::ModuleId::equals(const typechecker::ModuleId rhs) const {
{
return ((((*this).id) == ((rhs).id)));
}
}

u64 typechecker::Type::max() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<u64, u64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(static_cast<u64>(127ULL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(static_cast<u64>(2147483647ULL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(static_cast<u64>(127ULL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(static_cast<u64>(32767ULL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(static_cast<u64>(2147483647ULL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(static_cast<u64>(9223372036854775807ULL));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<u64>(255ULL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<u64>(65535ULL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<u64>(4294967295ULL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<u64>(18446744073709551615ULL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<u64>(18446744073709551615ULL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<u64>(0ULL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::equals(const NonnullRefPtr<typechecker::Type> rhs) const {
{
if ((((*this).index() == 0 /* Void */) && ((rhs)->index() == 0 /* Void */))){
return (true);
}
else if ((((*this).index() == 1 /* Bool */) && ((rhs)->index() == 1 /* Bool */))){
return (true);
}
else if ((((*this).index() == 2 /* U8 */) && ((rhs)->index() == 2 /* U8 */))){
return (true);
}
else if ((((*this).index() == 3 /* U16 */) && ((rhs)->index() == 3 /* U16 */))){
return (true);
}
else if ((((*this).index() == 4 /* U32 */) && ((rhs)->index() == 4 /* U32 */))){
return (true);
}
else if ((((*this).index() == 5 /* U64 */) && ((rhs)->index() == 5 /* U64 */))){
return (true);
}
else if ((((*this).index() == 6 /* I8 */) && ((rhs)->index() == 6 /* I8 */))){
return (true);
}
else if ((((*this).index() == 7 /* I16 */) && ((rhs)->index() == 7 /* I16 */))){
return (true);
}
else if ((((*this).index() == 8 /* I32 */) && ((rhs)->index() == 8 /* I32 */))){
return (true);
}
else if ((((*this).index() == 9 /* I64 */) && ((rhs)->index() == 9 /* I64 */))){
return (true);
}
else if ((((*this).index() == 10 /* F32 */) && ((rhs)->index() == 10 /* F32 */))){
return (true);
}
else if ((((*this).index() == 11 /* F64 */) && ((rhs)->index() == 11 /* F64 */))){
return (true);
}
else if ((((*this).index() == 12 /* Usize */) && ((rhs)->index() == 12 /* Usize */))){
return (true);
}
else if ((((*this).index() == 13 /* JaktString */) && ((rhs)->index() == 13 /* JaktString */))){
return (true);
}
else if ((((*this).index() == 14 /* CChar */) && ((rhs)->index() == 14 /* CChar */))){
return (true);
}
else if ((((*this).index() == 15 /* CInt */) && ((rhs)->index() == 15 /* CInt */))){
return (true);
}
else {
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& lhs_name = __jakt_match_value.value;
{
if (((rhs)->index() == 18 /* TypeVariable */)){
const String rhs_name = (rhs->get<typechecker::Type::TypeVariable>()).value;
return ((lhs_name == rhs_name));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& lhs_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if (((rhs)->index() == 19 /* GenericInstance */)){
const typechecker::StructId rhs_id = (rhs->get<typechecker::Type::GenericInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (rhs->get<typechecker::Type::GenericInstance>()).args;
if ((((lhs_id).equals(rhs_id)) && (((lhs_args).size()) == ((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!(((((lhs_args)[idx])).equals(((rhs_args)[idx])))))){
return (false);
}
((idx++));
}
return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& lhs_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& lhs_args = __jakt_match_value.args;
{
if (((rhs)->index() == 20 /* GenericEnumInstance */)){
const typechecker::EnumId rhs_id = (rhs->get<typechecker::Type::GenericEnumInstance>()).id;
const Array<typechecker::TypeId> rhs_args = (rhs->get<typechecker::Type::GenericEnumInstance>()).args;
if ((((lhs_id).equals(rhs_id)) && (((lhs_args).size()) == ((rhs_args).size())))){
size_t idx = static_cast<size_t>(0ULL);
while ((idx < ((lhs_args).size()))){
if ((!(((((lhs_args)[idx])).equals(((rhs_args)[idx])))))){
return (false);
}
((idx++));
}
return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& lhs_id = __jakt_match_value.value;
{
if (((rhs)->index() == 22 /* Struct */)){
const typechecker::StructId rhs_id = (rhs->get<typechecker::Type::Struct>()).value;
return (((lhs_id).equals(rhs_id)));
}
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& lhs_id = __jakt_match_value.value;
{
if (((rhs)->index() == 23 /* Enum */)){
const typechecker::EnumId rhs_id = (rhs->get<typechecker::Type::Enum>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if (((rhs)->index() == 24 /* RawPtr */)){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::RawPtr>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if (((rhs)->index() == 25 /* Reference */)){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::Reference>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& lhs_id = __jakt_match_value.value;
{
if (((rhs)->index() == 26 /* MutableReference */)){
const typechecker::TypeId rhs_id = (rhs->get<typechecker::Type::MutableReference>()).value;
return (((lhs_id).equals(rhs_id)));
}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
{
if (((rhs)->index() == 27 /* Function */)){
const Array<typechecker::TypeId> rhs_params = (rhs->get<typechecker::Type::Function>()).params;
const bool rhs_can_throw = (rhs->get<typechecker::Type::Function>()).can_throw;
const typechecker::TypeId rhs_return_type_id = (rhs->get<typechecker::Type::Function>()).return_type_id;
if (((((params).size()) == ((rhs_params).size())) && (((return_type_id).equals(rhs_return_type_id)) && (can_throw == rhs_can_throw)))){
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((params).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((!(((((params)[i])).equals(((rhs_params)[i])))))){
return (false);
}
}

}
}

return (true);
}
else {
return (false);
}

}
else {
return (false);
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
return (false);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (false);
}

}
}

i64 typechecker::Type::get_bits() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(static_cast<i64>(8LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<i64>(16LL));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(static_cast<i64>(16LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(static_cast<i64>(32LL));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(static_cast<i64>(64LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::is_builtin() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

i64 typechecker::Type::min() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<i64, i64>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue((-(static_cast<i64>(128LL))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue((-(static_cast<i64>(2147483648LL))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue((-(static_cast<i64>(128LL))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue((-(static_cast<i64>(32768LL))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue((-(static_cast<i64>(2147483648LL))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue((JaktInternal::checked_sub<i64>((-(static_cast<i64>(9223372036854775807LL))),static_cast<i64>(1LL))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(static_cast<i64>(0LL));
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::Type::is_signed() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

Optional<NonnullRefPtr<typechecker::CheckedStatement>> typechecker::CheckedStatement::none() {
{
return (JaktInternal::OptionalNone());
}
}

Optional<utility::Span> typechecker::CheckedStatement::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<utility::Span>, Optional<utility::Span>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue((span));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<utility::Span> const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
utility::Span const& span = __jakt_match_value.value;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::always_transfers_control() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::partial() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(false));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(false));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::always_returns() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::updated(const typechecker::BlockControlFlow second) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(second);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(((*this).unify_with(second)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::may_break() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(might_break);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::is_reachable() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(false);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();return JaktInternal::ExplicitValue(false);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(true);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::never_returns() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

bool typechecker::BlockControlFlow::may_return() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();return JaktInternal::ExplicitValue(true);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

typechecker::BlockControlFlow typechecker::BlockControlFlow::unify_with(const typechecker::BlockControlFlow second) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(second);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(might_break));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
default: {
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::MayReturn());
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(might_break));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(might_break));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(might_break));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns((lhs || might_break)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysReturns());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysReturns(lhs));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl(lhs));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& lhs = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::BlockControlFlow, typechecker::BlockControlFlow>{
auto&& __jakt_match_variant = second;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialNeverReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns((lhs || might_break)));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::PartialAlwaysReturns>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialAlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::AlwaysReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl(lhs));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::BlockControlFlow::AlwaysTransfersControl>();bool const& might_break = __jakt_match_value.might_break;
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::AlwaysTransfersControl((lhs || might_break)));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::MayReturn>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::PartialNeverReturns(lhs));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::BlockControlFlow::NeverReturns>();
return JaktInternal::ExplicitValue(typename typechecker::BlockControlFlow::NeverReturns());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::EnumId typechecker::CheckedEnumVariant::enum_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, typechecker::EnumId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String typechecker::CheckedEnumVariant::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::CheckedEnumVariant::equals(const typechecker::CheckedEnumVariant other) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& this_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = other;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& other_name = __jakt_match_value.name;
return JaktInternal::ExplicitValue((this_name == other_name));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
}
}

utility::Span typechecker::CheckedEnumVariant::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::TypeId typechecker::FunctionGenericParameter::type_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

typechecker::TypeId typechecker::CheckedTypeCast::type_id() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, typechecker::TypeId>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Fallible>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Infallible>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

size_t typechecker::NumberConstant::to_usize() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<size_t, size_t>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((value))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((infallible_integer_cast<size_t>((value))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
{
utility::panic(String("to_usize on a floating point constant"));
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

bool typechecker::NumberConstant::can_fit_number(const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedProgram> program) const {
{
const NonnullRefPtr<typechecker::Type> type_ = ((program)->get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue((value >= static_cast<i64>(0LL)));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue((value >= static_cast<i64>(0LL)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(((((program)->is_integer(type_id)) && (value >= ((type_)->min()))) && (value <= (infallible_integer_cast<i64>((((type_)->max())))))));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue((((program)->is_integer(type_id)) && (value <= ((type_)->max()))));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<bool, bool>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(({ Optional<bool> __jakt_var_166; {
utility::todo(String("Implement casting f32 to f64"));
__jakt_var_166 = false; goto __jakt_label_160;

}
__jakt_label_160:; __jakt_var_166.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(true);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(false);
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

String typechecker::CheckedCapture::name() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();String const& name = __jakt_match_value.name;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

utility::Span typechecker::CheckedCapture::span() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, utility::Span>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

Optional<typechecker::NumberConstant> typechecker::CheckedExpression::to_number_constant(const NonnullRefPtr<typechecker::CheckedProgram> program) const {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
return (((val).number_constant()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
{
if ((!(((cast).index() == 1 /* Infallible */)))){
return (JaktInternal::OptionalNone());
}
if (((!(((program)->is_integer(type_id)))) && (!(((program)->is_floating(type_id)))))){
return (JaktInternal::OptionalNone());
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
utility::Span const& span_ = __jakt_match_value.span;
typechecker::TypeId const& type_id_ = __jakt_match_value.type_id;
{
return (((val).number_constant()));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (JaktInternal::OptionalNone());
}
}

ErrorOr<NonnullRefPtr<typechecker::ValueImpl>> typechecker::ValueImpl::copy() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<NonnullRefPtr<typechecker::ValueImpl>, ErrorOr<NonnullRefPtr<typechecker::ValueImpl>>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Void>();
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Void>())));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Bool>();
bool const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Bool>(x))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U8>();
u8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U8>(x))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U16>();
u16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U16>(x))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U32>();
u32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U32>(x))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::U64>();
u64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::U64>(x))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I8>();
i8 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I8>(x))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I16>();
i16 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I16>(x))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I32>();
i32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I32>(x))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::I64>(x))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F32>();
f32 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F32>(x))));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::F64>();
f64 const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::F64>(x))));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::USize>();
size_t const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::USize>(x))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::JaktString>();
String const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(x))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CChar>();
char const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::CChar>(x))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& x = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::CInt>(x))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Struct>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
Optional<typechecker::FunctionId> const& constructor = __jakt_match_value.constructor;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::ValueImpl>> __jakt_var_167; {
Array<typechecker::Value> fields_copy = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value field = (_magic_value.value());
{
TRY((((fields_copy).push(TRY((((field).copy())))))));
}

}
}

__jakt_var_167 = TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Struct>(fields_copy,struct_id,constructor))); goto __jakt_label_161;

}
__jakt_label_161:; __jakt_var_167.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Class>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::StructId const& struct_id = __jakt_match_value.struct_id;
Optional<typechecker::FunctionId> const& constructor = __jakt_match_value.constructor;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Class>(fields,struct_id,constructor))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::Enum>();Array<typechecker::Value> const& fields = __jakt_match_value.fields;
typechecker::EnumId const& enum_id = __jakt_match_value.enum_id;
typechecker::FunctionId const& constructor = __jakt_match_value.constructor;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::ValueImpl>> __jakt_var_168; {
Array<typechecker::Value> fields_copy = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value field = (_magic_value.value());
{
TRY((((fields_copy).push(TRY((((field).copy())))))));
}

}
}

__jakt_var_168 = TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::Enum>(fields_copy,enum_id,constructor))); goto __jakt_label_162;

}
__jakt_label_162:; __jakt_var_168.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::JaktArray>();Array<typechecker::Value> const& values = __jakt_match_value.values;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<NonnullRefPtr<typechecker::ValueImpl>> __jakt_var_169; {
Array<typechecker::Value> values_copy = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<typechecker::Value> _magic = ((values).iterator());
for (;;){
Optional<typechecker::Value> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::Value value = (_magic_value.value());
{
TRY((((values_copy).push(TRY((((value).copy())))))));
}

}
}

__jakt_var_169 = TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktArray>(values_copy,type_id))); goto __jakt_label_163;

}
__jakt_label_163:; __jakt_var_169.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::RawPtr>();
NonnullRefPtr<typechecker::ValueImpl> const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::RawPtr>(value))));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::ValueImpl::OptionalSome>();typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::OptionalSome>(TRY((((value).copy())))))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::OptionalNone>();
return JaktInternal::ExplicitValue(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::OptionalNone>())));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

Optional<typechecker::NumberConstant> typechecker::CheckedNumericConstant::number_constant() const {
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, Optional<typechecker::NumberConstant>>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Signed((infallible_integer_cast<i64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Unsigned((infallible_integer_cast<u64>((value)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& value = __jakt_match_value.value;
{
return (typename typechecker::NumberConstant::Floating(value));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (JaktInternal::OptionalNone());
}
}

}
namespace codegen {
namespace AllowedControlExits_Details {
struct Nothing {};
struct JustReturn {};
struct AtLoop {};
}
struct AllowedControlExits : public Variant<AllowedControlExits_Details::Nothing, AllowedControlExits_Details::JustReturn, AllowedControlExits_Details::AtLoop> {
using Variant<AllowedControlExits_Details::Nothing, AllowedControlExits_Details::JustReturn, AllowedControlExits_Details::AtLoop>::Variant;
    using Nothing = AllowedControlExits_Details::Nothing;
    using JustReturn = AllowedControlExits_Details::JustReturn;
    using AtLoop = AllowedControlExits_Details::AtLoop;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Nothing */: {
[[maybe_unused]] auto const& that = this->template get<AllowedControlExits::Nothing>();
TRY(builder.append("AllowedControlExits::Nothing"));
break;}
case 1 /* JustReturn */: {
[[maybe_unused]] auto const& that = this->template get<AllowedControlExits::JustReturn>();
TRY(builder.append("AllowedControlExits::JustReturn"));
break;}
case 2 /* AtLoop */: {
[[maybe_unused]] auto const& that = this->template get<AllowedControlExits::AtLoop>();
TRY(builder.append("AllowedControlExits::AtLoop"));
break;}
}
return builder.to_string();
}codegen::AllowedControlExits allow_return() const;
};
struct ControlFlowState {
  public:
codegen::AllowedControlExits allowed_exits;bool passes_through_match;bool passes_through_try;size_t match_nest_level;codegen::ControlFlowState enter_function() const;
codegen::ControlFlowState enter_loop() const;
static codegen::ControlFlowState no_control_flow();
bool is_match_nested() const;
String choose_control_flow_macro() const;
codegen::ControlFlowState enter_match() const;
ControlFlowState(codegen::AllowedControlExits a_allowed_exits, bool a_passes_through_match, bool a_passes_through_try, size_t a_match_nest_level) :allowed_exits(a_allowed_exits), passes_through_match(a_passes_through_match), passes_through_try(a_passes_through_try), match_nest_level(a_match_nest_level){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("ControlFlowState("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("allowed_exits: "));TRY(builder.appendff("{}, ", allowed_exits));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("passes_through_match: "));TRY(builder.appendff("{}, ", passes_through_match));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("passes_through_try: "));TRY(builder.appendff("{}, ", passes_through_try));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("match_nest_level: "));TRY(builder.appendff("{}", match_nest_level));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CodegenDebugInfo {
  public:
NonnullRefPtr<compiler::Compiler> compiler;Dictionary<size_t,Array<codegen::LineSpan>> line_spans;bool statement_span_comments;ErrorOr<void> gather_line_spans();
ErrorOr<String> span_to_source_location(const utility::Span span);
CodegenDebugInfo(NonnullRefPtr<compiler::Compiler> a_compiler, Dictionary<size_t,Array<codegen::LineSpan>> a_line_spans, bool a_statement_span_comments) :compiler(a_compiler), line_spans(a_line_spans), statement_span_comments(a_statement_span_comments){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CodegenDebugInfo("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("line_spans: "));TRY(builder.appendff("{}, ", line_spans));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("statement_span_comments: "));TRY(builder.appendff("{}", statement_span_comments));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct LineSpan {
  public:
size_t start;size_t end;LineSpan(size_t a_start, size_t a_end) :start(a_start), end(a_end){}

ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("LineSpan("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("start: "));TRY(builder.appendff("{}, ", start));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("end: "));TRY(builder.appendff("{}", end));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};struct CodeGenerator {
  public:
NonnullRefPtr<compiler::Compiler> compiler;NonnullRefPtr<typechecker::CheckedProgram> program;codegen::ControlFlowState control_flow_state;Array<Tuple<String,String>> entered_yieldable_blocks;String deferred_output;Optional<NonnullRefPtr<typechecker::CheckedFunction>> current_function;codegen::CodegenDebugInfo debug_info;Array<String> namespace_stack;size_t fresh_var_counter;size_t fresh_label_counter;ErrorOr<String> codegen_function(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_generic_type_instance(const typechecker::StructId id, const Array<typechecker::TypeId> args, const bool as_namespace) const;
ErrorOr<Array<typechecker::ModuleId>> topologically_sort_modules() const;
ErrorOr<String> codegen_debug_description_getter(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_namespace(const NonnullRefPtr<typechecker::Scope> scope, const NonnullRefPtr<typechecker::Module> current_module);
ErrorOr<Dictionary<String,Array<String>>> produce_codegen_dependency_graph(const NonnullRefPtr<typechecker::Scope> scope) const;
ErrorOr<String> codegen_struct_predecl(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement);
ErrorOr<String> codegen_enum(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_struct_type(const typechecker::StructId id, const bool as_namespace) const;
ErrorOr<String> codegen_generic_match(const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> cases, const typechecker::TypeId return_type_id, const bool all_variants_constant);
ErrorOr<String> codegen_checked_binary_op(const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op, const typechecker::TypeId type_id);
ErrorOr<Array<String>> extract_dependencies_from_enum(const typechecker::EnumId enum_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level) const;
ErrorOr<String> codegen_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression);
ErrorOr<Array<String>> extract_dependencies_from_struct(const typechecker::StructId struct_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level, const Array<typechecker::TypeId> args) const;
ErrorOr<String> codegen_function_in_namespace(const NonnullRefPtr<typechecker::CheckedFunction> function_, const Optional<typechecker::TypeId> containing_struct);
ErrorOr<String> codegen_method_call(const NonnullRefPtr<typechecker::CheckedExpression> expr, const typechecker::CheckedCall call, const bool is_optional);
CodeGenerator(NonnullRefPtr<compiler::Compiler> a_compiler, NonnullRefPtr<typechecker::CheckedProgram> a_program, codegen::ControlFlowState a_control_flow_state, Array<Tuple<String,String>> a_entered_yieldable_blocks, String a_deferred_output, Optional<NonnullRefPtr<typechecker::CheckedFunction>> a_current_function, codegen::CodegenDebugInfo a_debug_info, Array<String> a_namespace_stack, size_t a_fresh_var_counter, size_t a_fresh_label_counter) :compiler(a_compiler), program(a_program), control_flow_state(a_control_flow_state), entered_yieldable_blocks(a_entered_yieldable_blocks), deferred_output(a_deferred_output), current_function(a_current_function), debug_info(a_debug_info), namespace_stack(a_namespace_stack), fresh_var_counter(a_fresh_var_counter), fresh_label_counter(a_fresh_label_counter){}

ErrorOr<String> codegen_struct(const typechecker::CheckedStruct struct_);
ErrorOr<String> codegen_enum_predecl(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_binary_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression, const typechecker::TypeId type_id, const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op);
ErrorOr<String> codegen_namespace_predecl(const NonnullRefPtr<typechecker::Scope> scope, const NonnullRefPtr<typechecker::Module> current_module);
ErrorOr<String> current_error_handler() const;
ErrorOr<String> codegen_namespace_qualifier(const typechecker::ScopeId scope_id) const;
ErrorOr<String> codegen_namespace_path(const typechecker::CheckedCall call) const;
ErrorOr<String> codegen_type_possibly_as_namespace(const typechecker::TypeId type_id, const bool as_namespace) const;
ErrorOr<Array<String>> extract_dependencies_from(const typechecker::TypeId type_id, const Dictionary<String,Array<String>> dependency_graph, const bool top_level) const;
ErrorOr<String> codegen_match_body(const typechecker::CheckedMatchBody body, const typechecker::TypeId return_type_id);
ErrorOr<String> codegen_function_predecl(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> fresh_var();
ErrorOr<String> codegen_block(const typechecker::CheckedBlock block);
ErrorOr<String> codegen_checked_binary_op_assignment(const NonnullRefPtr<typechecker::CheckedExpression> lhs, const NonnullRefPtr<typechecker::CheckedExpression> rhs, const parser::BinaryOperator op, const typechecker::TypeId type_id);
ErrorOr<String> codegen_enum_type(const typechecker::EnumId id, const bool as_namespace) const;
ErrorOr<String> codegen_constructor(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_enum_debug_description_getter(const typechecker::CheckedEnum enum_);
ErrorOr<String> codegen_enum_match(const typechecker::CheckedEnum enum_, const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> match_cases, const typechecker::TypeId type_id, const bool all_variants_constant);
ErrorOr<String> codegen_match(const NonnullRefPtr<typechecker::CheckedExpression> expr, const Array<typechecker::CheckedMatchCase> match_cases, const typechecker::TypeId type_id, const bool all_variants_constant);
ErrorOr<String> codegen_function_return_type(const NonnullRefPtr<typechecker::CheckedFunction> function_);
static ErrorOr<String> generate(const NonnullRefPtr<compiler::Compiler> compiler, const NonnullRefPtr<typechecker::CheckedProgram> program, const bool debug_info);
ErrorOr<String> codegen_call(const typechecker::CheckedCall call);
ErrorOr<String> codegen_generic_enum_instance(const typechecker::EnumId id, const Array<typechecker::TypeId> args, const bool as_namespace) const;
ErrorOr<String> codegen_function_generic_parameters(const NonnullRefPtr<typechecker::CheckedFunction> function_);
ErrorOr<String> codegen_ak_formatter(const String name, const Array<String> generic_parameter_names);
ErrorOr<String> codegen_type(const typechecker::TypeId type_id) const;
ErrorOr<void> postorder_traversal(const String encoded_type_id, Set<String> visited, const Dictionary<String,Array<String>> encoded_dependency_graph, Array<typechecker::TypeId> output) const;
ErrorOr<String> fresh_label();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("CodeGenerator("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("program: "));TRY(builder.appendff("{}, ", *program));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("control_flow_state: "));TRY(builder.appendff("{}, ", control_flow_state));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("entered_yieldable_blocks: "));TRY(builder.appendff("{}, ", entered_yieldable_blocks));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("deferred_output: "));TRY(builder.appendff("\"{}\", ", deferred_output));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("current_function: "));TRY(builder.appendff("{}, ", current_function));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("debug_info: "));TRY(builder.appendff("{}, ", debug_info));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("namespace_stack: "));TRY(builder.appendff("{}, ", namespace_stack));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fresh_var_counter: "));TRY(builder.appendff("{}, ", fresh_var_counter));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("fresh_label_counter: "));TRY(builder.appendff("{}", fresh_label_counter));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static bool are_loop_exits_allowed(const codegen::AllowedControlExits allowed_control_exits) {
{
return (((allowed_control_exits).index() == 2 /* AtLoop */));
}
}

static bool is_return_allowed(const codegen::AllowedControlExits allowed_control_exits) {
{
return ((!(((allowed_control_exits).index() == 0 /* Nothing */))));
}
}

ErrorOr<void> codegen::CodegenDebugInfo::gather_line_spans() {
{
{
DictionaryIterator<String,utility::FileId> _magic = ((((((*this).compiler))->file_ids)).iterator());
for (;;){
Optional<Tuple<String,utility::FileId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,utility::FileId> file = (_magic_value.value());
{
if ((((file).get<0>()) == String("__prelude__"))){
continue;
}
((((*this).compiler))->set_current_file(((file).get<1>())));
const size_t file_idx = ((((file).get<1>())).id);
const Array<codegen::LineSpan> empty_array = (TRY((Array<codegen::LineSpan>::create_with({}))));
TRY((((((*this).line_spans)).set(file_idx,empty_array))));
size_t idx = static_cast<size_t>(0ULL);
size_t start = idx;
while ((idx < ((((((*this).compiler))->current_file_contents)).size()))){
if ((((((((*this).compiler))->current_file_contents))[idx]) == '\n')){
TRY((((((((*this).line_spans))[file_idx])).push(codegen::LineSpan(start,idx)))));
(start = (JaktInternal::checked_add<size_t>(idx,static_cast<size_t>(1ULL))));
}
({auto& _jakt_ref = idx;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
if ((start < idx)){
TRY((((((((*this).line_spans))[file_idx])).push(codegen::LineSpan(start,idx)))));
}
}

}
}

}
return {};
}

ErrorOr<String> codegen::CodegenDebugInfo::span_to_source_location(const utility::Span span) {
{
if (((((*this).line_spans)).is_empty())){
TRY((((*this).gather_line_spans())));
}
const size_t file_idx = ((((span).file_id)).id);
if ((!(((((*this).line_spans)).contains(file_idx))))){
return (String(""));
}
size_t line_index = static_cast<size_t>(0ULL);
while ((line_index < ((((((*this).line_spans))[file_idx])).size()))){
if (((((span).start) >= ((((((((*this).line_spans))[file_idx]))[line_index])).start)) && (((span).start) <= ((((((((*this).line_spans))[file_idx]))[line_index])).end)))){
const size_t column_index = (JaktInternal::checked_sub<size_t>(((span).start),((((((((*this).line_spans))[file_idx]))[line_index])).start)));
return (TRY((String::formatted(String("{}:{}:{}"),(((TRY((((((*this).compiler))->get_file_path(((span).file_id))))).value()))->path),(JaktInternal::checked_add<size_t>(line_index,static_cast<size_t>(1ULL))),(JaktInternal::checked_add<size_t>(column_index,static_cast<size_t>(1ULL)))))));
}
({auto& _jakt_ref = line_index;_jakt_ref = JaktInternal::checked_add<size_t>(_jakt_ref, static_cast<size_t>(1ULL));});
}
utility::panic(String("Reached end of file and could not find index"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
if (((function_)->is_comptime)){
return (String(""));
}
return (TRY((((*this).codegen_function_in_namespace(function_,JaktInternal::OptionalNone())))));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_type_instance(const typechecker::StructId id,const Array<typechecker::TypeId> args,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
if ((!((((type_module)->is_root) || (((((type_module)->id)).id) == static_cast<size_t>(0ULL)))))){
(output += ((type_module)->name));
(output += String("::"));
}
const Optional<typechecker::StructId> inner_weak_ptr_struct_id = TRY((((((*this).program))->check_and_extract_weak_ptr(id,args))));
if (((inner_weak_ptr_struct_id).has_value())){
(output += String("WeakPtr<"));
const typechecker::StructId inner_struct_id = ((inner_weak_ptr_struct_id).value());
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(inner_struct_id));
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String(">"));
}
else {
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
const bool acquired_by_ref = ((!(as_namespace)) && ((((struct_).record_type)).index() == 1 /* Class */));
if (acquired_by_ref){
(output += String("NonnullRefPtr<"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
if ((!(first))){
(output += String(","));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">"));
if (acquired_by_ref){
(output += String(">"));
}
}

return (output);
}
}

ErrorOr<Array<typechecker::ModuleId>> codegen::CodeGenerator::topologically_sort_modules() const {
{
Dictionary<size_t,i64> in_degrees = (TRY((Dictionary<size_t, i64>::create_with_entries({}))));
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
ArrayIterator<typechecker::ModuleId> _magic = ((((module)->imports)).iterator());
for (;;){
Optional<typechecker::ModuleId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ModuleId imported_module = (_magic_value.value());
{
const i64 existing = ((in_degrees).get(((imported_module).id))).value_or_lazy_evaluated([&] { return static_cast<i64>(0LL); });
TRY((((in_degrees).set(((imported_module).id),(JaktInternal::checked_add<i64>(existing,static_cast<i64>(1LL)))))));
}

}
}

if ((!(((in_degrees).contains(((((module)->id)).id)))))){
TRY((((in_degrees).set(((((module)->id)).id),static_cast<i64>(0LL)))));
}
}

}
}

Array<typechecker::ModuleId> stack = (TRY((Array<typechecker::ModuleId>::create_with({}))));
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((((*this).program))->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
if ((((in_degrees)[((((module)->id)).id)]) == static_cast<i64>(0LL))){
TRY((((stack).push(((module)->id)))));
}
}

}
}

Array<typechecker::ModuleId> sorted_modules = (TRY((Array<typechecker::ModuleId>::create_with({}))));
while ((!(((stack).is_empty())))){
const typechecker::ModuleId id = (((stack).pop()).value());
TRY((((sorted_modules).push(id))));
{
ArrayIterator<typechecker::ModuleId> _magic = ((((((((((*this).program))->modules))[((id).id)]))->imports)).iterator());
for (;;){
Optional<typechecker::ModuleId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ModuleId imported_module = (_magic_value.value());
{
const i64 module_in_degrees = ((in_degrees)[((imported_module).id)]);
TRY((((in_degrees).set(((imported_module).id),(JaktInternal::checked_sub<i64>(module_in_degrees,static_cast<i64>(1LL)))))));
if ((module_in_degrees == static_cast<i64>(1LL))){
TRY((((stack).push(typechecker::ModuleId(((imported_module).id))))));
}
}

}
}

}
if ((((sorted_modules).size()) == ((((((*this).program))->modules)).size()))){
return (sorted_modules);
}
utility::panic(String("Cyclic module imports"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_debug_description_getter(const typechecker::CheckedStruct struct_) {
{
String output = String("ErrorOr<String> debug_description() const { ");
(output += String("auto builder = MUST(StringBuilder::create());"));
(output += TRY((String::formatted(String("TRY(builder.append(\"{}(\"));"),((struct_).name)))));
(output += String("JaktInternal::_pretty_print_level++;\n"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((((*this).program))->get_variable(field));
(output += String("TRY(JaktInternal::_output_pretty_indent(builder));"));
(output += TRY((String::formatted(String("TRY(builder.append(\"{}: \"));"),((field_var).name)))));
(output += String("TRY(builder.appendff(\""));
if (((((*this).program))->is_string(((field_var).type_id)))){
(output += String("\\\"{}\\\""));
}
else {
(output += String("{}"));
}

if ((i != (JaktInternal::checked_sub<size_t>(((((struct_).fields)).size()),static_cast<size_t>(1ULL))))){
(output += String(", "));
}
(output += String("\", "));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(((field_var).type_id)));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((((((*this).program))->get_struct(struct_id))).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("*"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += (((field_var).name) + String("));\n")));
((i++));
}

}
}

(output += String("JaktInternal::_pretty_print_level--;\n"));
(output += String("TRY(builder.append(\")\"));"));
(output += String("return builder.to_string();"));
(output += String(" }"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace(const NonnullRefPtr<typechecker::Scope> scope,const NonnullRefPtr<typechecker::Module> current_module) {
{
if (((((scope)->import_path_if_extern)).has_value())){
return (String(""));
}
String output = String("");
const Dictionary<String,Array<String>> encoded_dependency_graph = TRY((((*this).produce_codegen_dependency_graph(scope))));
Set<String> seen_types = (TRY((Set<String>::create_with_values({}))));
{
DictionaryIterator<String,Array<String>> _magic = ((encoded_dependency_graph).iterator());
for (;;){
Optional<Tuple<String,Array<String>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,Array<String>> entry = (_magic_value.value());
{
const Array<typechecker::TypeId> traversal = (TRY((Array<typechecker::TypeId>::create_with({}))));
TRY((((*this).postorder_traversal(((entry).get<0>()),seen_types,encoded_dependency_graph,traversal))));
{
ArrayIterator<typechecker::TypeId> _magic = ((traversal).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
if ((!(((((enum_id).module)).equals(((current_module)->id)))))){
return JaktInternal::LoopContinue{};
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
const String enum_output = TRY((((*this).codegen_enum(enum_))));
if ((!(((enum_output).is_empty())))){
(output += enum_output);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
if ((!(((((struct_id).module)).equals(((current_module)->id)))))){
return JaktInternal::LoopContinue{};
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
const String struct_output = TRY((((*this).codegen_struct(struct_))));
if ((!(((struct_output).is_empty())))){
(output += struct_output);
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Unexpected type in dependency graph: {}"),type_))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
TRY((((seen_types).add(TRY((((type_id).to_string())))))));
}

}
}

}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!(((((struct_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if (((seen_types).contains(TRY((((((struct_).type_id)).to_string())))))){
continue;
}
(output += TRY((((*this).codegen_struct(struct_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!(((((enum_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if (((seen_types).contains(TRY((((((enum_).type_id)).to_string())))))){
continue;
}
(output += TRY((((*this).codegen_enum(enum_)))));
(output += String("\n"));
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_scope_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> child_scope = TRY((((((*this).program))->get_scope(child_scope_id))));
if (((((child_scope)->namespace_name)).has_value())){
const String name = (((child_scope)->namespace_name).value());
TRY((((((*this).namespace_stack)).push(name))));
(output += String("namespace "));
(output += name);
(output += String(" {\n"));
(output += TRY((((*this).codegen_namespace(child_scope,current_module)))));
(output += String("}\n"));
const Optional<String> dummy = ((((*this).namespace_stack)).pop());
}
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
if ((!(((((function_id).module)).equals(((current_module)->id)))))){
continue;
}
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if (((((((function_)->linkage)).index() == 1 /* External */) || ((((function_)->type)).index() == 1 /* ImplicitConstructor */)) || ((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */))){
continue;
}
(output += TRY((((*this).codegen_function(function_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!(((((struct_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if (((((struct_).definition_linkage)).index() == 1 /* External */)){
continue;
}
if ((!(((((struct_).generic_parameters)).is_empty())))){
continue;
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((struct_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if (((!(((((function_)->type)).index() == 1 /* ImplicitConstructor */))) && ((!(((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */))) && (!(((function_)->is_comptime)))))){
(output += TRY((((*this).codegen_function_in_namespace(function_,((struct_).type_id))))));
(output += String("\n"));
}
}

}
}

}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!(((((enum_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if (((((enum_).definition_linkage)).index() == 1 /* External */)){
continue;
}
if ((!(((((enum_).generic_parameters)).is_empty())))){
continue;
}
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((enum_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function = ((*this).current_function);
(((*this).current_function) = function_);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{(((*this).current_function) = previous_function);
});
if (((!(((((function_)->type)).index() == 1 /* ImplicitConstructor */))) && ((!(((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */))) && (!(((function_)->is_comptime)))))){
(output += TRY((((*this).codegen_function_in_namespace(function_,((enum_).type_id))))));
(output += String("\n"));
}
}

}
}

}

}
}

return (output);
}
}

ErrorOr<Dictionary<String,Array<String>>> codegen::CodeGenerator::produce_codegen_dependency_graph(const NonnullRefPtr<typechecker::Scope> scope) const {
{
Dictionary<String,Array<String>> dependency_graph = (TRY((Dictionary<String, Array<String>>::create_with_entries({}))));
{
DictionaryIterator<String,typechecker::TypeId> _magic = ((((scope)->types)).iterator());
for (;;){
Optional<Tuple<String,typechecker::TypeId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::TypeId> type_ = (_magic_value.value());
{
TRY((((dependency_graph).set(TRY((((((type_).get<1>())).to_string()))),TRY((((*this).extract_dependencies_from(((type_).get<1>()),dependency_graph,true))))))));
}

}
}

return (dependency_graph);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct_predecl(const typechecker::CheckedStruct struct_) {
{
if (((((struct_).definition_linkage)).index() == 1 /* External */)){
return (String(""));
}
String output = String("");
if ((!(((((struct_).generic_parameters)).is_empty())))){
(output += String("template <"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += String("typename "));
(output += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

(output += String(">"));
}
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += ((struct_).name));
(output += String(";"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_statement(const NonnullRefPtr<typechecker::CheckedStatement> statement) {
{
bool add_newline = true;
String output = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((String("return ") + TRY((((*this).codegen_expression(expr))))) + String(";")));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((*this).control_flow_state)).passes_through_match));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return JaktInternal::LoopContinue{};"));
}
else {
return JaktInternal::ExplicitValue(String("continue;"));
}
}()))
);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((*this).control_flow_state)).passes_through_match));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return JaktInternal::LoopBreak{};"));
}
else {
return JaktInternal::ExplicitValue(String("break;"));
}
}()))
);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_expression(expr)))) + String(";")));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();NonnullRefPtr<typechecker::CheckedStatement> const& statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_170; {
String output = String("");
(output += String("\n#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__\n"));
(output += String("ScopeGuard __SCOPE_GUARD_NAME ([&] \n"));
(output += String("#undef __SCOPE_GUARD_NAME\n{"));
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((((*this).control_flow_state)).passes_through_match) = false);
(output += TRY((((*this).codegen_statement(statement)))));
(output += String("});"));
(((*this).control_flow_state) = last_control_flow);
}

__jakt_var_170 = output; goto __jakt_label_164;

}
__jakt_label_164:; __jakt_var_170.release_value(); }));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(((String("return (") + TRY((((*this).codegen_expression((val.value())))))) + String(");")));
}
else {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_171; {
__jakt_var_171 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = ((((((*this).current_function).value()))->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("return {};"));
}
else {
return JaktInternal::ExplicitValue(String("return;"));
}
}()))
; goto __jakt_label_165;

}
__jakt_label_165:; __jakt_var_171.release_value(); }));
}
}()))
);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_172; {
String output = String("");
(output += String("for (;;)"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
(add_newline = false);
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_loop()));
const String block_str = TRY((((*this).codegen_block(block))));
(((*this).control_flow_state) = last_control_flow);
(output += block_str);
__jakt_var_172 = output; goto __jakt_label_166;

}
__jakt_label_166:; __jakt_var_172.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_173; {
String output = String("");
(output += String("while ("));
(output += TRY((((*this).codegen_expression(condition)))));
(output += String(")"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_loop()));
const String code = TRY((((*this).codegen_block(block))));
(((*this).control_flow_state) = last_control_flow);
(output += code);
}

(add_newline = false);
__jakt_var_173 = output; goto __jakt_label_167;

}
__jakt_label_167:; __jakt_var_173.release_value(); }));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_block(block)))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
{
utility::panic(String("Garbage statement in codegen"));
}
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();Array<NonnullRefPtr<typechecker::CheckedStatement>> const& vars = __jakt_match_value.vars;
NonnullRefPtr<typechecker::CheckedStatement> const& var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_174; {
String output = String("");
(output += TRY((((*this).codegen_statement(var_decl)))));
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((vars).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> v = (_magic_value.value());
{
(output += TRY((((*this).codegen_statement(v)))));
}

}
}

__jakt_var_174 = output; goto __jakt_label_168;

}
__jakt_label_168:; __jakt_var_174.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();typechecker::VarId const& var_id = __jakt_match_value.var_id;
NonnullRefPtr<typechecker::CheckedExpression> const& init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_175; {
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(var_id));
String output = String("");
const NonnullRefPtr<typechecker::Type> var_type = ((((*this).program))->get_type(((var).type_id)));
if (((!(((var).is_mutable))) && (!((((var_type)->index() == 25 /* Reference */) || ((var_type)->index() == 26 /* MutableReference */)))))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((var).type_id))))));
(output += String(" "));
(output += ((var).name));
(output += String(" = "));
(output += TRY((((*this).codegen_expression(init)))));
(output += String(";"));
__jakt_var_175 = output; goto __jakt_label_169;

}
__jakt_label_169:; __jakt_var_175.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();Array<String> const& lines = __jakt_match_value.lines;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_176; {
String output = String("");
{
ArrayIterator<String> _magic = ((lines).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String line = (_magic_value.value());
{
String escaped_line = line;
(escaped_line = TRY((((escaped_line).replace(String("\\\""),String("\""))))));
(escaped_line = TRY((((escaped_line).replace(String("\\\\"),String("\\"))))));
(output += escaped_line);
}

}
}

__jakt_var_176 = output; goto __jakt_label_170;

}
__jakt_label_170:; __jakt_var_176.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_177; {
String output = String("if (");
(output += TRY((((*this).codegen_expression(condition)))));
(output += String(")"));
if ((((((*this).debug_info)).statement_span_comments) && ((((statement)->span())).has_value()))){
(output += TRY((String::formatted(String(" /* {} */ "),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
(output += TRY((((*this).codegen_block(then_block)))));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((else_statement).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue((String("else ") + TRY((((*this).codegen_statement((else_statement.value())))))));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
);
(add_newline = false);
__jakt_var_177 = output; goto __jakt_label_171;

}
__jakt_label_171:; __jakt_var_177.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_178; {
String output = String("");
if ((((((*this).entered_yieldable_blocks)).size()) == static_cast<size_t>(0ULL))){
utility::panic(String("Must be in a block to yield"));
}
const Tuple<String,String> block_tuple = (((((*this).entered_yieldable_blocks)).last()).value());
const String block_var_name = ((block_tuple).get<0>());
const String block_end_label = ((block_tuple).get<1>());
(output += block_var_name);
(output += String(" = "));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String("; goto "));
(output += block_end_label);
(output += String(";\n"));
__jakt_var_178 = output; goto __jakt_label_172;

}
__jakt_label_172:; __jakt_var_178.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if ((((((*this).debug_info)).statement_span_comments) && (((((statement)->span())).has_value()) && add_newline))){
(output += TRY((String::formatted(String(" /* {} */"),TRY((((((*this).debug_info)).span_to_source_location((((statement)->span()).value())))))))));
}
if (add_newline){
(output += String("\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum(const typechecker::CheckedEnum enum_) {
{
String output = String("");
if ((!(((((enum_).underlying_type_id)).equals(typechecker::void_type_id()))))){
if (((((*this).program))->is_integer(((enum_).underlying_type_id)))){
(output += ((((String("enum class ") + ((enum_).name)) + String(": ")) + TRY((((*this).codegen_type(((enum_).underlying_type_id)))))) + String(" {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue((((name + String(" = ")) + TRY((((*this).codegen_expression(expr))))) + String(",\n")));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_179; {
utility::todo(TRY((String::formatted(String("codegen_enum can't generate variant: {}"),variant))));
__jakt_var_179 = String(""); goto __jakt_label_173;

}
__jakt_label_173:; __jakt_var_179.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}

}
}

return ((output + String("};\n")));
}
else {
utility::todo(String("Enums with a non-integer underlying type"));
}

}
const bool is_generic = (!(((((enum_).generic_parameters)).is_empty())));
Array<String> generic_parameter_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if (((((((*this).program))->get_type(generic_parameter)))->index() == 18 /* TypeVariable */)){
const String name = (((((*this).program))->get_type(generic_parameter))->get<typechecker::Type::TypeVariable>()).value;
TRY((((generic_parameter_names).push(name))));
}
}

}
}

String template_args = utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "));
(output += ((String("namespace ") + ((enum_).name)) + String("_Details {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String(" {};\n")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String(" {\n")));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(field));
(output += TRY((String::formatted(String("{} {};\n"),TRY((((*this).codegen_type(((var).type_id))))),((var).name)))));
}

}
}

(output += String("template<"));
Array<String> generic_typenames = (TRY((Array<String>::create_with({}))));
Array<String> generic_argument_types = (TRY((Array<String>::create_with({}))));
Array<String> initializers = (TRY((Array<String>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((fields).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((generic_typenames).push(TRY((String::formatted(String("typename _MemberT{}"),i)))))));
TRY((((generic_argument_types).push(TRY((String::formatted(String("_MemberT{}&& member_{}"),i,i)))))));
String initializer = (((((((*this).program))->get_variable(((fields)[i])))).name) + String("{ forward<_MemberT"));
(initializer += (TRY((String::formatted(String("{}>(member_{}"),i,i))) + String(")}")));
TRY((((initializers).push(initializer))));
}

}
}

(output += utility::join(generic_typenames,String(", ")));
(output += String(">\n"));
(output += (((name + String("(")) + utility::join(generic_argument_types,String(", "))) + String("):\n")));
(output += (utility::join(initializers,String(",\n")) + String("\n{}\n")));
(output += String("};\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
(output += ((String("struct ") + name) + String("{\n")));
(output += (TRY((((*this).codegen_type(type_id)))) + String(" value;\n")));
(output += String("template<typename... Args>\n"));
(output += (name + String("(Args&&... args): value { forward<Args>(args)... } {}\n")));
(output += String("};\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("codegen enum variant: {}"),variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

(output += String("}\n"));
if (is_generic){
(output += ((String("template<") + template_args) + String(">\n")));
}
Array<String> variant_names = (TRY((Array<String>::create_with({}))));
Array<String> variant_arguments_array = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
String argument = ((((enum_).name) + String("_Details::")) + ((variant).name()));
if (is_generic){
(argument += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
TRY((((variant_arguments_array).push(argument))));
TRY((((variant_names).push(((variant).name())))));
}

}
}

const String variant_args = utility::join(variant_arguments_array,String(", "));
(output += TRY((String::formatted(String("struct {} : public Variant<{}>"),((enum_).name),variant_args))));
if (((enum_).is_boxed)){
(output += TRY((String::formatted(String(", public RefCounted<{}"),((enum_).name)))));
if (is_generic){
(output += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
(output += String(">"));
}
(output += String(" {\n"));
(output += ((String("using Variant<") + variant_args) + String(">::Variant;\n")));
{
ArrayIterator<String> _magic = ((variant_names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
(output += (((((String("    using ") + name) + String(" = ")) + ((enum_).name)) + String("_Details::")) + name));
if (is_generic){
(output += String("<"));
(output += utility::join(generic_parameter_names,String(", ")));
(output += String(">"));
}
(output += String(";\n"));
}

}
}

if (((enum_).is_boxed)){
String fully_instantiated_name = ((enum_).name);
if (is_generic){
(fully_instantiated_name += TRY((String::formatted(String("<{}>"),utility::join(generic_parameter_names,String(", "))))));
}
(output += String("template<typename V, typename... Args> static auto create(Args&&... args) {\n"));
(output += TRY((String::formatted(String("return adopt_nonnull_ref_or_enomem(new (nothrow) {}(V(forward<Args>(args)...)));\n"),fully_instantiated_name))));
(output += String("}\n"));
}
(output += TRY((((*this).codegen_enum_debug_description_getter(enum_)))));
const NonnullRefPtr<typechecker::Scope> enum_scope = TRY((((((*this).program))->get_scope(((enum_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((enum_scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> function_item = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(((function_item).get<1>())));
if ((!(((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */)))){
if (((((enum_).generic_parameters)).is_empty())){
(output += TRY((((*this).codegen_function_predecl(function_)))));
}
else {
(output += TRY((((*this).codegen_function(function_)))));
}

}
}

}
}

(output += String("};\n"));
(((*this).deferred_output) += TRY((((*this).codegen_ak_formatter(((enum_).name),generic_parameter_names)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct_type(const typechecker::StructId id,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
const typechecker::CheckedStruct checked_struct = ((((*this).program))->get_struct(id));
if (((!(as_namespace)) && ((((checked_struct).record_type)).index() == 1 /* Class */))){
(output += String("NonnullRefPtr<"));
if (((!(((type_module)->is_root))) && (!(((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL)))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((checked_struct).scope_id))))));
(output += ((checked_struct).name));
(output += String(">"));
}
else {
if ((!(((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL))))) || ((((checked_struct).definition_linkage)).index() == 1 /* External */))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_qualifier(((checked_struct).scope_id))))));
(output += ((checked_struct).name));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_match(const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> cases,const typechecker::TypeId return_type_id,const bool all_variants_constant) {
{
String output = String("");
bool is_generic_enum = false;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
if (((case_).index() == 0 /* EnumVariant */)){
(is_generic_enum = true);
break;
}
}

}
}

const bool match_values_all_constant = (all_variants_constant && (!(is_generic_enum)));
(output += ((((*this).control_flow_state)).choose_control_flow_macro()));
(output += (TRY((String::formatted(String("(([&]() -> JaktInternal::ExplicitValueOrControlFlow<{},{}>"),TRY((((*this).codegen_type(return_type_id)))),TRY((((*this).codegen_function_return_type((((*this).current_function).value())))))))) + String("{\n")));
if (is_generic_enum){
(output += String("auto&& __jakt_enum_value = JaktInternal::deref_if_ref_pointer("));
}
else {
(output += String("auto __jakt_enum_value = ("));
}

(output += TRY((((*this).codegen_expression(expr)))));
(output += String(");\n"));
bool has_default = false;
bool first = true;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase case_ = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = case_;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(subject_type_id));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Unexpected type in IsEnumVariant: {}"),((((*this).program))->get_type(subject_type_id))))));
}
};/*case end*/
}/*switch end*/
}()
))));
i64 variant_index = static_cast<i64>(0LL);
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == name)){
break;
}
((variant_index++));
}

}
}

(output += TRY((String::formatted(String("if (__jakt_enum_value.index() == {} /* {} */) {{\n"),variant_index,name))));
String variant_type_name = String("");
const String qualifier = TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true))));
if ((!(((qualifier).is_empty())))){
(variant_type_name += String("typename JaktInternal::RemoveRefPtr<"));
(variant_type_name += qualifier);
(variant_type_name += String(">::"));
}
(variant_type_name += name);
(output += String("auto& __jakt_match_value = __jakt_enum_value.template get<"));
(output += variant_type_name);
(output += String(">();\n"));
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((args).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
(output += String("auto& "));
(output += ((arg).binding));
(output += String(" = __jakt_match_value."));
(output += ((arg).name).value_or_lazy_evaluated([&] { return String("value"); }));
(output += String(";\n"));
}

}
}

(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
{
(has_default = true);
if (first){
(output += String("{"));
}
else {
(output += String("else {\n"));
}

(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expression = __jakt_match_value.expression;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
{
if ((!(first))){
(output += String("else "));
}
(output += String("if (__jakt_enum_value == "));
(output += TRY((((*this).codegen_expression(expression)))));
(output += String(") {\n"));
(output += TRY((((*this).codegen_match_body(body,return_type_id)))));
(output += String("}\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(first = false);
}

}
}

if ((((return_type_id).equals(typechecker::void_type_id())) || ((return_type_id).equals(typechecker::unknown_type_id())))){
(output += String("return JaktInternal::ExplicitValue<void>();\n"));
}
else if ((!(has_default))){
(output += String("VERIFY_NOT_REACHED();\n"));
}
(output += String("}()))\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_checked_binary_op(const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op,const typechecker::TypeId type_id) {
{
String output = String("");
(output += String("JaktInternal::"));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(String("checked_add"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(String("checked_sub"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(String("checked_mul"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(String("checked_div"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(String("checked_mod"));
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Checked binary operation codegen is not supported for BinaryOperator::{}"),op))));
}
};/*case end*/
}/*switch end*/
}()
)));
(output += String("<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(","));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from_enum(const typechecker::EnumId enum_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
if (((((enum_).definition_linkage)).index() == 1 /* External */)){
return (dependencies);
}
if ((((enum_).is_boxed) && (!(top_level)))){
return (dependencies);
}
TRY((((dependencies).push(TRY((((((enum_).type_id)).to_string())))))));
if ((!(((((enum_).underlying_type_id)).equals(typechecker::unknown_type_id()))))){
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(((enum_).underlying_type_id),dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::TypeId type_id = ((((((*this).program))->get_variable(field))).type_id);
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *expression;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();NonnullRefPtr<typechecker::CheckedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<typechecker::CheckedExpression> const& to = __jakt_match_value.to;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_180; {
String output = String("");
const NonnullRefPtr<typechecker::Type> type = ((((*this).program))->get_type(type_id));
const typechecker::TypeId index_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
default: {
{
utility::panic(String("Internal error: range expression doesn't have Range type"));
}
};/*case end*/
}/*switch end*/
}()
));
(output += String("("));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String("{"));
(output += String("static_cast<"));
(output += TRY((((*this).codegen_type(index_type)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(from)))));
(output += String("),static_cast<"));
(output += TRY((((*this).codegen_type(index_type)))));
(output += String(">("));
(output += TRY((((*this).codegen_expression(to)))));
(output += String(")})"));
__jakt_var_180 = output; goto __jakt_label_174;

}
__jakt_label_174:; __jakt_var_180.release_value(); }));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();return JaktInternal::ExplicitValue(String("JaktInternal::OptionalNone()"));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(((String("(") + TRY((((*this).codegen_expression(expr))))) + String(")")));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(((String("(") + TRY((((*this).codegen_expression(expr))))) + String(".value())")));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_181; {
const String escaped_value = TRY((((val).replace(String("\n"),String("\\n")))));
__jakt_var_181 = ((String("String(\"") + escaped_value) + String("\")")); goto __jakt_label_175;

}
__jakt_label_175:; __jakt_var_181.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(((String("'") + val) + String("'")));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(((String("'") + val) + String("'")));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((var).name));
if (__jakt_enum_value == String("this")) {
return JaktInternal::ExplicitValue(String("*this"));
}
else {
return JaktInternal::ExplicitValue(((var).name));
}
}()))
);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(((((String("((") + TRY((((*this).codegen_expression(expr))))) + String(")[")) + TRY((((*this).codegen_expression(index))))) + String("])")));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedRangeExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<typechecker::CheckedExpression> const& to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_182; {
__jakt_var_182 = TRY((String::formatted(String("(({}).slice_range({}, {}))"),TRY((((*this).codegen_expression(expr)))),TRY((((*this).codegen_expression(from)))),TRY((((*this).codegen_expression(to))))))); goto __jakt_label_176;

}
__jakt_label_176:; __jakt_var_182.release_value(); }));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(((((String("((") + TRY((((*this).codegen_expression(expr))))) + String(")[")) + TRY((((*this).codegen_expression(index))))) + String("])")));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_optional);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("(({}).map([](auto& _value) {{ return _value.template get<{}>(); }}))"),TRY((((*this).codegen_expression(expr)))),index))));
}
else {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("(({}).get<{}>())"),TRY((((*this).codegen_expression(expr)))),index))));
}
}()))
);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_183; {
String output = String("");
const String object = TRY((((*this).codegen_expression(expr))));
(output += String("(("));
(output += object);
(output += String(")"));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
{
(output += String("->"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((((*this).program))->get_struct(struct_id));
if ((((((structure).record_type)).index() == 1 /* Class */) && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
(output += String("."));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if (is_optional){
(output += String("map([](auto& _value) { return _value."));
(output += index);
(output += String("; })"));
}
else {
(output += index);
}

(output += String(")"));
__jakt_var_183 = output; goto __jakt_label_177;

}
__jakt_label_177:; __jakt_var_183.release_value(); }));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_block(block)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_call(call)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedCall const& call = __jakt_match_value.call;
bool const& is_optional = __jakt_match_value.is_optional;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_method_call(expr,call,is_optional)))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (val);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("true"));
}
else {
return JaktInternal::ExplicitValue(String("false"));
}
}()))
);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_184; {
String output = String("(");
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue(String("++"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue(String("--"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Negate>();
return JaktInternal::ExplicitValue(String("-"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
return JaktInternal::ExplicitValue(String("*"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue(String("&"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue(String("!"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue(String("~"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_185; {
const String is_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_186; {
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
__jakt_var_186 = ((((((*this).program))->get_struct(id))).name); goto __jakt_label_180;

}
__jakt_label_180:; __jakt_var_186.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(type_id)))));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_185 = ((String("is<") + is_type) + String(">(")); goto __jakt_label_179;

}
__jakt_label_179:; __jakt_var_185.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
typechecker::CheckedTypeCast const& cast = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_187; {
typechecker::TypeId final_type_id = ((cast).type_id());
const String cast_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = cast;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Fallible>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_188; {
const NonnullRefPtr<typechecker::Type> ty = ((((*this).program))->get_type(((cast).type_id())));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = *ty;
switch(__jakt_match_variant.index()) {
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(((args)[static_cast<i64>(0LL)]));
};/*case end*/
default: {
{
utility::panic(String("Fallible type cast must have Optional result."));
}
};/*case end*/
}/*switch end*/
}()
));
String cast_type = String("dynamic_cast");
if (((((*this).program))->is_integer(type_id))){
(final_type_id = type_id);
(cast_type = String("fallible_integer_cast"));
}
__jakt_var_188 = cast_type; goto __jakt_label_182;

}
__jakt_label_182:; __jakt_var_188.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedTypeCast::Infallible>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_189; {
String cast_type = String("verify_cast");
if (((((*this).program))->is_integer(type_id))){
(cast_type = String("infallible_integer_cast"));
}
__jakt_var_189 = cast_type; goto __jakt_label_183;

}
__jakt_label_183:; __jakt_var_189.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
__jakt_var_187 = (((cast_type + String("<")) + TRY((((*this).codegen_type(final_type_id))))) + String(">(")); goto __jakt_label_181;

}
__jakt_label_181:; __jakt_var_187.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
(output += String("("));
const String object = TRY((((*this).codegen_expression(expr))));
(output += object);
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue(String("++)"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue(String("--)"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::TypeCast>();
return JaktInternal::ExplicitValue(String("))"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Is>();
return JaktInternal::ExplicitValue(String("))"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedUnaryOperator::IsEnumVariant>();typechecker::CheckedEnumVariant const& enum_variant = __jakt_match_value.enum_variant;
typechecker::TypeId const& enum_type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_190; {
const String name = ((enum_variant).name());
String suffix = String(")");
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(enum_type_id));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(enum_id);
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Unexpected type in IsEnumVariant: {}"),((((*this).program))->get_type(enum_type_id))))));
}
};/*case end*/
}/*switch end*/
}()
))));
const bool is_boxed = ((enum_).is_boxed);
if ((is_boxed && (object != String("*this")))){
(suffix += String("->"));
}
else {
(suffix += String("."));
}

i64 variant_index = static_cast<i64>(0LL);
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == name)){
break;
}
((variant_index++));
}

}
}

(suffix += TRY((String::formatted(String("index() == {} /* {} */"),variant_index,name))));
__jakt_var_190 = suffix; goto __jakt_label_184;

}
__jakt_label_184:; __jakt_var_190.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(")"));
};/*case end*/
}/*switch end*/
}()
)));
(output += String(")"));
__jakt_var_184 = output; goto __jakt_label_178;

}
__jakt_label_178:; __jakt_var_184.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& lhs = __jakt_match_value.lhs;
NonnullRefPtr<typechecker::CheckedExpression> const& rhs = __jakt_match_value.rhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_binary_expression(expression,type_id,lhs,rhs,op)))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_191; {
const String suffix = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
return JaktInternal::ExplicitValue(String("LL"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
return JaktInternal::ExplicitValue(String("ULL"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
return JaktInternal::ExplicitValue(String("ULL"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
return JaktInternal::ExplicitValue(String("size_t"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(type_id)))));
};/*case end*/
}/*switch end*/
}()
));
__jakt_var_191 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F32>();
f32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& val = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("static_cast<{}>({}{})"),type_name,val,suffix))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_185;

}
__jakt_label_185:; __jakt_var_191.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();Array<typechecker::CheckedNamespace> const& namespaces = __jakt_match_value.namespaces;
typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_192; {
String output = String("");
{
ArrayIterator<typechecker::CheckedNamespace> _magic = ((namespaces).iterator());
for (;;){
Optional<typechecker::CheckedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedNamespace ns = (_magic_value.value());
{
(output += (((ns).name) + String("::")));
}

}
}

__jakt_var_192 = (output + ((var).name)); goto __jakt_label_186;

}
__jakt_label_186:; __jakt_var_192.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
bool const& all_variants_constant = __jakt_match_value.all_variants_constant;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_match(expr,match_cases,type_id,all_variants_constant)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::EnumVariantArg>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedEnumVariantBinding const& arg = __jakt_match_value.arg;
typechecker::CheckedEnumVariant const& enum_variant = __jakt_match_value.enum_variant;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_193; {
const String var_name = TRY((((*this).codegen_expression(expr))));
const String enum_type = TRY((((*this).codegen_type_possibly_as_namespace(typechecker::expression_type(expr),true))));
const String variant_name = ((enum_variant).name());
String arg_name = String("value");
if (((enum_variant).index() == 3 /* StructLike */)){
(arg_name = ((arg).name).value_or_lazy_evaluated([&] { return ((arg).binding); }));
}
const String cpp_deref_operator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((((*this).program))->get_enum(((enum_variant).enum_id())))).is_boxed));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("->"));
}
else {
return JaktInternal::ExplicitValue(String("."));
}
}()))
;
__jakt_var_193 = TRY((String::formatted(String("({}{}get<{}::{}>()).{}"),var_name,cpp_deref_operator,enum_type,variant_name,arg_name))); goto __jakt_label_187;

}
__jakt_label_187:; __jakt_var_193.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& repeat = __jakt_match_value.repeat;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& inner_type_id = __jakt_match_value.inner_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_194; {
String output = String("");
if (((repeat).has_value())){
const NonnullRefPtr<typechecker::CheckedExpression> repeat_val = ((repeat).value());
(output += String("("));
(output += TRY((((*this).current_error_handler()))));
(output += String("((Array<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String(">::filled("));
(output += TRY((((*this).codegen_expression(repeat_val)))));
(output += String(", "));
(output += TRY((((*this).codegen_expression(((vals)[static_cast<i64>(0LL)]))))));
(output += String("))))"));
}
else {
(output += String("("));
(output += TRY((((*this).current_error_handler()))));
(output += String("((Array<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String(">::create_with({"));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(val)))));
}

}
}

(output += String("}))))"));
}

__jakt_var_194 = output; goto __jakt_label_188;

}
__jakt_label_188:; __jakt_var_194.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& key_type_id = __jakt_match_value.key_type_id;
typechecker::TypeId const& value_type_id = __jakt_match_value.value_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_195; {
String output = TRY((String::formatted(String("({}((Dictionary<{}, {}>::create_with_entries({{"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_type(key_type_id)))),TRY((((*this).codegen_type(value_type_id)))))));
bool first = true;
{
ArrayIterator<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((vals).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>> val = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> key = ((val).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> value = ((val).get<1>());
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += String("{"));
(output += TRY((((*this).codegen_expression(key)))));
(output += String(", "));
(output += TRY((((*this).codegen_expression(value)))));
(output += String("}"));
}

}
}

(output += String("}))))"));
__jakt_var_195 = output; goto __jakt_label_189;

}
__jakt_label_189:; __jakt_var_195.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& inner_type_id = __jakt_match_value.inner_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_196; {
String output = String("");
(output += TRY((String::formatted(String("({}((Set<{}>::create_with_values({{"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_type(inner_type_id))))))));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> value = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(value)))));
}

}
}

(output += String("}))))"));
__jakt_var_196 = output; goto __jakt_label_190;

}
__jakt_label_190:; __jakt_var_196.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_197; {
String output = String("");
(output += String("(Tuple{"));
bool first = true;
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_expression(val)))));
}

}
}

(output += String("})"));
__jakt_var_197 = output; goto __jakt_label_191;

}
__jakt_label_191:; __jakt_var_197.release_value(); }));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Function>();Array<typechecker::CheckedCapture> const& captures = __jakt_match_value.captures;
Array<typechecker::CheckedParameter> const& params = __jakt_match_value.params;
bool const& can_throw = __jakt_match_value.can_throw;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_198; {
Array<String> generated_captures = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedCapture> _magic = ((captures).iterator());
for (;;){
Optional<typechecker::CheckedCapture> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedCapture capture = (_magic_value.value());
{
TRY((((generated_captures).push(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = capture;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByValue>();return JaktInternal::ExplicitValue(((capture).name()));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByReference>();return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),((capture).name())))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedCapture::ByMutableReference>();return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),((capture).name())))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
))))));
}

}
}

Array<String> generated_params = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((params).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
TRY((((generated_params).push(TRY((String::formatted(String("{} {}"),TRY((((*this).codegen_type(((((param).variable)).type_id))))),((((param).variable)).name))))))));
}

}
}

const String return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (can_throw);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),TRY((((*this).codegen_type(return_type_id))))))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(return_type_id)))));
}
}()))
;
__jakt_var_198 = TRY((String::formatted(String("[{}]({}) -> {} {}"),utility::join(generated_captures,String(", ")),utility::join(generated_params,String(", ")),return_type,TRY((((*this).codegen_block(block))))))); goto __jakt_label_192;

}
__jakt_label_192:; __jakt_var_198.release_value(); }));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::TryBlock>();NonnullRefPtr<typechecker::CheckedStatement> const& stmt = __jakt_match_value.stmt;
String const& error_name = __jakt_match_value.error_name;
typechecker::CheckedBlock const& catch_block = __jakt_match_value.catch_block;
utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_199; {
String output = String("");
const String try_var = TRY((((*this).fresh_var())));
(output += String("auto "));
(output += try_var);
(output += String(" = [&]() -> ErrorOr<void> {"));
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((((*this).control_flow_state)).passes_through_match) = false);
(((((*this).control_flow_state)).passes_through_try) = true);
(output += TRY((((*this).codegen_statement(stmt)))));
(output += String(";"));
(output += String("return {};"));
(output += String("}();\n"));
(output += String("if ("));
(output += try_var);
(output += String(".is_error()) {"));
if ((!(((error_name).is_empty())))){
(output += String("auto "));
(output += error_name);
(output += String(" = "));
(output += try_var);
(output += String(".release_error();"));
}
(output += TRY((((*this).codegen_block(catch_block)))));
(((*this).control_flow_state) = last_control_flow);
(output += String("}"));
__jakt_var_199 = output; goto __jakt_label_193;

}
__jakt_label_193:; __jakt_var_199.release_value(); }));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Try>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Optional<typechecker::CheckedBlock> const& catch_block = __jakt_match_value.catch_block;
Optional<String> const& catch_name = __jakt_match_value.catch_name;
utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
typechecker::TypeId const& inner_type_id = __jakt_match_value.inner_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_200; {
String output = String("");
const String fresh_var = TRY((((*this).fresh_var())));
const String fresh_label = TRY((((*this).fresh_label())));
const bool is_void = ((inner_type_id).equals(typechecker::void_type_id()));
const String try_var = TRY((((*this).fresh_var())));
TRY((((((*this).entered_yieldable_blocks)).push((Tuple{fresh_var, fresh_label})))));
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((((*this).control_flow_state)).passes_through_match) = false);
(((((*this).control_flow_state)).passes_through_try) = true);

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{{
(((*this).control_flow_state) = last_control_flow);
}

});
if ((!(is_void))){
(output += String("({ Optional<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String("> "));
(output += fresh_var);
(output += String(";\n"));
}
(output += String("auto "));
(output += try_var);
(output += String(" = [&]() -> ErrorOr<"));
(output += TRY((((*this).codegen_type(inner_type_id)))));
(output += String("> { return "));
(output += TRY((((*this).codegen_expression(expr)))));
if (is_void){
(output += String(", ErrorOr<void>{}"));
}
(output += String("; }();\n"));
if (((catch_block).has_value())){
(output += String("if ("));
(output += try_var);
(output += String(".is_error()) {"));
if (((catch_name).has_value())){
(output += String("auto "));
(output += (catch_name.value()));
(output += String(" = "));
(output += try_var);
(output += String(".release_error();\n"));
}
(output += TRY((((*this).codegen_block((catch_block.value()))))));
if ((!(is_void))){
(output += String("} else {"));
(output += fresh_var);
(output += String(" = "));
(output += try_var);
(output += String(".release_value();\n"));
}
(output += String("}\n"));
}
else if ((!(is_void))){
(output += String("if (!"));
(output += try_var);
(output += String(".is_error()) "));
(output += fresh_var);
(output += String(" = "));
(output += try_var);
(output += String(".release_value();\n"));
}
if ((!(is_void))){
(output += fresh_var);
if (((catch_block).has_value())){
(output += String(".release_value()"));
}
(output += String("; })"));
}
__jakt_var_200 = output; goto __jakt_label_194;

}
__jakt_label_194:; __jakt_var_200.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_201; {
utility::todo(TRY((String::formatted(String("codegen_expression else: {}"),expression))));
__jakt_var_201 = String(""); goto __jakt_label_195;

}
__jakt_label_195:; __jakt_var_201.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from_struct(const typechecker::StructId struct_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level,const Array<typechecker::TypeId> args) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if ((((((struct_).definition_linkage)).index() == 1 /* External */) && (((struct_).name) != String("Optional")))){
return (dependencies);
}
if ((((((struct_).record_type)).index() == 1 /* Class */) && (!(top_level)))){
return (dependencies);
}
if ((!(((args).is_empty())))){
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId inner_type = (_magic_value.value());
{
const Array<String> inner_dependencies = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(inner_type));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from(inner_type,dependency_graph,false)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from(inner_type,dependency_graph,false)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

}
TRY((((dependencies).push(TRY((((((struct_).type_id)).to_string())))))));
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::TypeId type_id = ((((((*this).program))->get_variable(field))).type_id);
const Array<String> inner_dependencies = TRY((((*this).extract_dependencies_from(type_id,dependency_graph,false))));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_in_namespace(const NonnullRefPtr<typechecker::CheckedFunction> function_,const Optional<typechecker::TypeId> containing_struct) {
{
if ((!(((((function_)->generic_params)).is_empty())))){
if (((((function_)->linkage)).index() == 1 /* External */)){
return (String(""));
}
}
String output = String("");
(output += TRY((((*this).codegen_function_generic_parameters(function_)))));
const bool is_main = ((((function_)->name) == String("main")) && (!(((containing_struct).has_value()))));
if (((((function_)->return_type_id)).equals(typechecker::never_type_id()))){
(output += String("[[noreturn]] "));
}
if (is_main){
(output += String("ErrorOr<int>"));
}
else {
if ((((function_)->is_static()) && (!(((containing_struct).has_value()))))){
(output += String("static "));
}
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((function_)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),TRY((((*this).codegen_type(((function_)->return_type_id)))))))));
}
else {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type(((function_)->return_type_id))))));
}
}()))
);
}

(output += String(" "));
if (is_main){
(output += String("main"));
}
else {
const String qualifier = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((containing_struct).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((((*this).codegen_type_possibly_as_namespace((containing_struct.value()),true)))));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
if ((!(((qualifier).is_empty())))){
(output += qualifier);
(output += String("::"));
}
(output += ((function_)->name));
}

(output += String("("));
if ((is_main && ((((function_)->params)).is_empty()))){
(output += String("Array<String>"));
}
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((param).variable);
if ((((variable).name) == String("this"))){
continue;
}
if ((!(first))){
(output += String(","));
}
else {
(first = false);
}

const NonnullRefPtr<typechecker::Type> variable_type = ((((*this).program))->get_type(((variable).type_id)));
if (((!(((variable).is_mutable))) && (!((((variable_type)->index() == 25 /* Reference */) || ((variable_type)->index() == 26 /* MutableReference */)))))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((variable).type_id))))));
(output += String(" "));
(output += ((variable).name));
}

}
}

(output += String(")"));
if (((!(((function_)->is_static()))) && (!(((function_)->is_mutating()))))){
(output += String(" const"));
}
(output += String(" {\n"));
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((last_control_flow).enter_function()));
const String block = TRY((((*this).codegen_block(((function_)->block)))));
(((*this).control_flow_state) = last_control_flow);
(output += block);
if (is_main){
(output += String("return 0;\n"));
}
else {
if ((((function_)->can_throw) && (((((function_)->return_type_id)).id) == static_cast<size_t>(0ULL)))){
(output += String("return {};\n"));
}
}

(output += String("}\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_method_call(const NonnullRefPtr<typechecker::CheckedExpression> expr,const typechecker::CheckedCall call,const bool is_optional) {
{
String output = String("");
if (((call).callee_throws)){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
const String object = TRY((((*this).codegen_expression(expr))));
(output += String("(("));
(output += object);
(output += String(")"));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(typechecker::expression_type(expr)));
switch(__jakt_match_variant.index()) {
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
{
(output += String("->"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
if ((((((struct_).record_type)).index() == 1 /* Class */) && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(id));
if ((((enum_).is_boxed) && (object != String("*this")))){
(output += String("->"));
}
else {
(output += String("."));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
(output += String("."));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
if (is_optional){
(output += String("map([&](auto& _value) { return _value."));
}
(output += ((call).name));
(output += String("("));
bool first = true;
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> name_and_expr = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += TRY((((*this).codegen_expression(((name_and_expr).get<1>()))))));
}

}
}

(output += String(")"));
if (is_optional){
(output += String("; })"));
}
(output += String(")"));
if (((call).callee_throws)){
(output += String("))"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_struct(const typechecker::CheckedStruct struct_) {
{
String output = String("");
if (((((struct_).definition_linkage)).index() == 1 /* External */)){
return (String(""));
}
Array<String> generic_parameter_names = (TRY((Array<String>::create_with({}))));
if ((!(((((struct_).generic_parameters)).is_empty())))){
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
TRY((((generic_parameter_names).push(TRY((((*this).codegen_type(generic_parameter))))))));
}

}
}

(output += TRY((String::formatted(String("template <{}>"),utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "))))));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();{
String class_name_with_generics = String("");
(class_name_with_generics += ((struct_).name));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((((struct_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((!(first))){
(class_name_with_generics += String(", "));
}
else {
(class_name_with_generics += String("<"));
(first = false);
}

(class_name_with_generics += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

if ((!(((((struct_).generic_parameters)).is_empty())))){
(class_name_with_generics += String(">"));
}
(output += TRY((String::formatted(String("class {} : public RefCounted<{}>, public Weakable<{}> {{\n"),((struct_).name),class_name_with_generics,class_name_with_generics))));
(output += String("  public:\n"));
(output += TRY((String::formatted(String("virtual ~{}() = default;\n"),((struct_).name)))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();{
(output += TRY((String::formatted(String("struct {}"),((struct_).name)))));
(output += String(" {\n"));
(output += String("  public:\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
utility::todo(String("codegen_struct SumEnum"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
utility::todo(String("codegen_struct ValueEnum"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field_id = (_magic_value.value());
{
const typechecker::CheckedVariable field = ((((*this).program))->get_variable(field_id));
(output += TRY((((*this).codegen_type(((field).type_id))))));
(output += String(" "));
(output += ((field).name));
(output += String(";"));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope(((struct_).scope_id)))));
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> fn = (_magic_value.value());
{
const Optional<NonnullRefPtr<typechecker::CheckedFunction>> previous_function_id = ((*this).current_function);
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(((fn).get<1>())));
(((*this).current_function) = (function_));
if (((((function_)->type)).index() == 1 /* ImplicitConstructor */)){
const String function_output = TRY((((*this).codegen_constructor(function_))));
(output += function_output);
(output += String("\n"));
}
else {
if (((((struct_).generic_parameters)).is_empty())){
(output += TRY((((*this).codegen_function_predecl(function_)))));
}
else {
(output += TRY((((*this).codegen_function(function_)))));
}

}

(((*this).current_function) = previous_function_id);
}

}
}

(output += TRY((((*this).codegen_debug_description_getter(struct_)))));
(output += String("};"));
(((*this).deferred_output) += TRY((((*this).codegen_ak_formatter(((struct_).name),generic_parameter_names)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_predecl(const typechecker::CheckedEnum enum_) {
{
String output = String("");
if ((!(((((enum_).underlying_type_id)).equals(typechecker::void_type_id()))))){
if (((((*this).program))->is_integer(((enum_).underlying_type_id)))){
return (TRY((String::formatted(String("enum class {}: {};"),((enum_).name),TRY((((*this).codegen_type(((enum_).underlying_type_id)))))))));
}
else {
utility::todo(String("Enums with a non-integer underlying type"));
}

}
const bool is_generic = (!(((((enum_).generic_parameters)).is_empty())));
Array<String> template_args_array = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((((enum_).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if (((((((*this).program))->get_type(generic_parameter)))->index() == 18 /* TypeVariable */)){
const String name = (((((*this).program))->get_type(generic_parameter))->get<typechecker::Type::TypeVariable>()).value;
TRY((((template_args_array).push((String("typename ") + name)))));
}
}

}
}

String template_args = utility::join(template_args_array,String(", "));
(output += (TRY((String::formatted(String("namespace {}_Details"),((enum_).name)))) + String(" {\n")));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
{
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

(output += String("}\n"));
if (is_generic){
(output += TRY((String::formatted(String("template<{}>\n"),template_args))));
}
(output += TRY((String::formatted(String("struct {};\n"),((enum_).name)))));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_binary_expression(const NonnullRefPtr<typechecker::CheckedExpression> expression,const typechecker::TypeId type_id,const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op) {
{
if (((op).index() == 20 /* NoneCoalescing */)){
const typechecker::TypeId rhs_type_id = typechecker::expression_type(rhs);
const NonnullRefPtr<typechecker::Type> rhs_type = ((((*this).program))->get_type(rhs_type_id));
const bool rhs_can_throw = typechecker::expression_can_throw(rhs);
String output = String("");
if (rhs_can_throw){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
(output += TRY((((*this).codegen_expression(lhs)))));
if (((rhs_type)->index() == 19 /* GenericInstance */)){
const typechecker::StructId id = (rhs_type->get<typechecker::Type::GenericInstance>()).id;
if ((((((((*this).program))->get_struct(id))).name) == String("Optional"))){
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated_optional"));
}
else {
(output += String(".value_or_lazy_evaluated_optional"));
}

}
else {
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated"));
}
else {
(output += String(".value_or_lazy_evaluated"));
}

}

}
else {
if (rhs_can_throw){
(output += String(".try_value_or_lazy_evaluated"));
}
else {
(output += String(".value_or_lazy_evaluated"));
}

}

if (rhs_can_throw){
(output += String("([&]() -> ErrorOr<"));
(output += TRY((((*this).codegen_type(rhs_type_id)))));
(output += String("> { return "));
}
else {
(output += String("([&] { return "));
}

(output += TRY((((*this).codegen_expression(rhs)))));
(output += String("; })"));
if (rhs_can_throw){
(output += String("))"));
}
return (output);
}
if (((op).index() == 32 /* NoneCoalescingAssign */)){
String output = TRY((((*this).codegen_expression(lhs))));
(output += String(".lazy_emplace([&] { return "));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String("; })"));
return (output);
}
if (((op).index() == 17 /* ArithmeticRightShift */)){
String output = String("JaktInternal::arithmetic_shift_right(");
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(","));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
if ((((op).index() == 21 /* Assign */) && ((lhs)->index() == 14 /* IndexedDictionary */))){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *lhs;
switch(__jakt_match_variant.index()) {
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}({}.set({}, {}))"),TRY((((*this).current_error_handler()))),TRY((((*this).codegen_expression(expr)))),TRY((((*this).codegen_expression(index)))),TRY((((*this).codegen_expression(rhs))))))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
)));
}
if (((((*this).program))->is_integer(type_id))){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
{
return (((String("(") + TRY((((*this).codegen_checked_binary_op_assignment(lhs,rhs,op,type_id))))) + String(")")));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
String output = String("(");
(output += TRY((((*this).codegen_expression(lhs)))));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Add>();
return JaktInternal::ExplicitValue(String(" + "));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Subtract>();
return JaktInternal::ExplicitValue(String(" - "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Multiply>();
return JaktInternal::ExplicitValue(String(" * "));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Modulo>();
return JaktInternal::ExplicitValue(String(" % "));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Divide>();
return JaktInternal::ExplicitValue(String(" / "));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Assign>();
return JaktInternal::ExplicitValue(String(" = "));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(String(" += "));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(String(" -= "));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(String(" *= "));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(String(" %= "));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(String(" /= "));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAndAssign>();
return JaktInternal::ExplicitValue(String(" &= "));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOrAssign>();
return JaktInternal::ExplicitValue(String(" |= "));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXorAssign>();
return JaktInternal::ExplicitValue(String(" ^= "));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShiftAssign>();
return JaktInternal::ExplicitValue(String(" <<= "));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShiftAssign>();
return JaktInternal::ExplicitValue(String(" >>= "));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::Equal>();
return JaktInternal::ExplicitValue(String(" == "));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::NotEqual>();
return JaktInternal::ExplicitValue(String(" != "));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThan>();
return JaktInternal::ExplicitValue(String(" < "));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LessThanOrEqual>();
return JaktInternal::ExplicitValue(String(" <= "));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThan>();
return JaktInternal::ExplicitValue(String(" > "));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::GreaterThanOrEqual>();
return JaktInternal::ExplicitValue(String(" >= "));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalAnd>();
return JaktInternal::ExplicitValue(String(" && "));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::LogicalOr>();
return JaktInternal::ExplicitValue(String(" || "));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseAnd>();
return JaktInternal::ExplicitValue(String(" & "));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseOr>();
return JaktInternal::ExplicitValue(String(" | "));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseXor>();
return JaktInternal::ExplicitValue(String(" ^ "));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ArithmeticLeftShift>();
return JaktInternal::ExplicitValue(String(" << "));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseLeftShift>();
return JaktInternal::ExplicitValue(String(" << "));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::BitwiseRightShift>();
return JaktInternal::ExplicitValue(String(" >> "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_202; {
utility::todo(TRY((String::formatted(String("codegen_binary_expression {}"),op))));
__jakt_var_202 = String(""); goto __jakt_label_196;

}
__jakt_label_196:; __jakt_var_202.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(")"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_predecl(const NonnullRefPtr<typechecker::Scope> scope,const NonnullRefPtr<typechecker::Module> current_module) {
{
if (((((scope)->import_path_if_extern)).has_value())){
return (String(""));
}
String output = String("");
if (((((scope)->namespace_name)).has_value())){
(output += String("namespace "));
(output += (((scope)->namespace_name).value()));
(output += String(" {\n"));
}
{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::StructId> name_and_struct_id = (_magic_value.value());
{
const typechecker::StructId struct_id = ((name_and_struct_id).get<1>());
if ((!(((((struct_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
(output += TRY((((*this).codegen_struct_predecl(struct_)))));
(output += String("\n"));
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::EnumId> name_and_enum_id = (_magic_value.value());
{
const typechecker::EnumId enum_id = ((name_and_enum_id).get<1>());
if ((!(((((enum_id).module)).equals(((current_module)->id)))))){
continue;
}
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
(output += TRY((((*this).codegen_enum_predecl(enum_)))));
(output += String("\n"));
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
(output += TRY((((*this).codegen_namespace_predecl(TRY((((((*this).program))->get_scope(child)))),current_module)))));
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> name_and_function_id = (_magic_value.value());
{
const typechecker::FunctionId function_id = ((name_and_function_id).get<1>());
if ((!(((((function_id).module)).equals(((current_module)->id)))))){
continue;
}
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
if (((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */)){
continue;
}
const String function_output = TRY((((*this).codegen_function_predecl(function_))));
if (((!(((((function_)->type)).index() == 1 /* ImplicitConstructor */))) && (((function_)->name) != String("main")))){
(output += function_output);
(output += String("\n"));
}
}

}
}

if (((((scope)->namespace_name)).has_value())){
(output += String("}\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::current_error_handler() const {
{
if ((((((*this).current_function)).has_value()) && ((((((((*this).current_function).value()))->return_type_id)).equals(typechecker::never_type_id())) && (!(((((*this).control_flow_state)).passes_through_try)))))){
return (String("MUST"));
}
return (String("TRY"));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_qualifier(const typechecker::ScopeId scope_id) const {
{
String output = String("");
Optional<typechecker::ScopeId> current_scope_id = ((TRY((((((*this).program))->get_scope(scope_id)))))->parent);
while (((current_scope_id).has_value())){
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((*this).program))->get_scope((current_scope_id.value())))));
if (((((scope)->namespace_name)).has_value())){
const String namespace_name = (((scope)->namespace_name).value());
(output = TRY((String::formatted(String("{}::{}"),namespace_name,output))));
}
(current_scope_id = ((scope)->parent));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_namespace_path(const typechecker::CheckedCall call) const {
{
String output = String("");
size_t index = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::ResolvedNamespace> _magic = ((((call).namespace_)).iterator());
for (;;){
Optional<typechecker::ResolvedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ResolvedNamespace namespace_ = (_magic_value.value());
{
if (((index == (JaktInternal::checked_sub<size_t>(((((call).namespace_)).size()),static_cast<size_t>(1ULL)))) && (((namespace_).name) == ((call).name)))){
break;
}
(output += ((namespace_).name));
if (((((namespace_).generic_parameters)).has_value())){
(output += String("<"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::TypeId> _magic = (((((namespace_).generic_parameters).value())).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId param = (_magic_value.value());
{
(output += TRY((((*this).codegen_type(param)))));
if ((i != (JaktInternal::checked_sub<size_t>((((((namespace_).generic_parameters).value())).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
(++(i));
}

}
}

(output += String(">"));
}
(output += String("::"));
(++(index));
}

}
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_type_possibly_as_namespace(const typechecker::TypeId type_id,const bool as_namespace) const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("size_t"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("char"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("int"));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String("*")));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String(" const&")));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((TRY((((*this).codegen_type(type_id)))) + String("&")));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_type_instance(id,args,as_namespace)))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_type_instance(id,args,as_namespace)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_struct_type(id,as_namespace)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_enum_type(id,as_namespace)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).codegen_generic_enum_instance(id,args,as_namespace)))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_203; {
__jakt_var_203 = String("auto"); goto __jakt_label_197;

}
__jakt_label_197:; __jakt_var_203.release_value(); }));
};/*case end*/
}/*switch end*/
}()
)));
}
}

ErrorOr<Array<String>> codegen::CodeGenerator::extract_dependencies_from(const typechecker::TypeId type_id,const Dictionary<String,Array<String>> dependency_graph,const bool top_level) const {
{
Array<String> dependencies = (TRY((Array<String>::create_with({}))));
if (((dependency_graph).contains(TRY((((type_id).to_string())))))){
{
ArrayIterator<String> _magic = (((((dependency_graph).get(TRY((((type_id).to_string()))))).value())).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

return (dependencies);
}
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
const Array<String> inner_dependencies = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *type_;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_enum(enum_id,dependency_graph,top_level)))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_enum(id,dependency_graph,top_level)))));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_struct(id,dependency_graph,top_level,(TRY((Array<typechecker::TypeId>::create_with({})))))))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(TRY((((*this).extract_dependencies_from_struct(id,dependency_graph,top_level,args)))));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
));
{
ArrayIterator<String> _magic = ((inner_dependencies).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((dependencies).push(dependency))));
}

}
}

return (dependencies);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_match_body(const typechecker::CheckedMatchBody body,const typechecker::TypeId return_type_id) {
{
String output = String("");
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
{
(output += TRY((((*this).codegen_block(block)))));
if ((((return_type_id).equals(typechecker::void_type_id())) || ((return_type_id).equals(typechecker::unknown_type_id())))){
(output += String("return JaktInternal::ExplicitValue<void>();\n"));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
{
if ((((typechecker::expression_type(expr)).equals(typechecker::void_type_id())) || (((typechecker::expression_type(expr)).equals(typechecker::unknown_type_id())) && (!(((expr)->index() == 23 /* OptionalNone */)))))){
(output += String("return ("));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String("), JaktInternal::ExplicitValue<void>();\n"));
}
else {
(output += String("return JaktInternal::ExplicitValue("));
(output += TRY((((*this).codegen_expression(expr)))));
(output += String(");\n"));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_predecl(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
String output = String("");
if (((!(((((function_)->generic_params)).is_empty()))) && ((((function_)->linkage)).index() == 1 /* External */))){
return (String(""));
}
if (((((function_)->type)).index() == 1 /* ImplicitConstructor */)){
return (String(""));
}
if (((((function_)->linkage)).index() == 1 /* External */)){
(output += String("extern "));
}
(output += TRY((((*this).codegen_function_generic_parameters(function_)))));
if (((((function_)->return_type_id)).equals(typechecker::never_type_id()))){
(output += String("[[noreturn]] "));
}
if ((((function_)->name) == String("main"))){
(output += String("ErrorOr<int>"));
}
else {
if ((((function_)->is_static()) && (!(((((function_)->linkage)).index() == 1 /* External */))))){
(output += String("static "));
}
const String naked_return_type = TRY((((*this).codegen_type(((function_)->return_type_id)))));
const String return_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((function_)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((String::formatted(String("ErrorOr<{}>"),naked_return_type))));
}
else {
return JaktInternal::ExplicitValue(naked_return_type);
}
}()))
;
(output += return_type);
}

(output += String(" "));
(output += ((function_)->name));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((first && (((((param).variable)).name) == String("this")))){
continue;
}
if (first){
(first = false);
}
else {
(output += String(", "));
}

const NonnullRefPtr<typechecker::Type> param_type = ((((*this).program))->get_type(((((param).variable)).type_id)));
if (((!(((((param).variable)).is_mutable))) && (!((((param_type)->index() == 25 /* Reference */) || ((param_type)->index() == 26 /* MutableReference */)))))){
(output += String("const "));
}
(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" "));
(output += ((((param).variable)).name));
}

}
}

(output += String(")"));
if (((!(((function_)->is_static()))) && (!(((function_)->is_mutating()))))){
(output += String(" const;"));
}
else {
(output += String(";"));
}

(output += String("\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::fresh_var() {
{
return (TRY((String::formatted(String("__jakt_var_{}"),((((*this).fresh_var_counter)++))))));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_block(const typechecker::CheckedBlock block) {
{
String output = String("");
if (((((block).yielded_type)).has_value())){
const typechecker::TypeId yielded_type = (((block).yielded_type).value());
const String type_output = TRY((((*this).codegen_type(yielded_type))));
const String fresh_var = TRY((((*this).fresh_var())));
const String fresh_label = TRY((((*this).fresh_label())));
TRY((((((*this).entered_yieldable_blocks)).push((Tuple{fresh_var, fresh_label})))));
(output += String("({ Optional<"));
(output += type_output);
(output += String("> "));
(output += fresh_var);
(output += String("; "));
}
(output += String("{\n"));
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
(output += TRY((((*this).codegen_statement(statement)))));
}

}
}

(output += String("}\n"));
if (((((block).yielded_type)).has_value())){
const Tuple<String,String> block_tuple = (((((*this).entered_yieldable_blocks)).pop()).value());
const String block_var = ((block_tuple).get<0>());
const String block_label = ((block_tuple).get<1>());
(output += block_label);
(output += String(":; "));
(output += block_var);
(output += String(".release_value(); })"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_checked_binary_op_assignment(const NonnullRefPtr<typechecker::CheckedExpression> lhs,const NonnullRefPtr<typechecker::CheckedExpression> rhs,const parser::BinaryOperator op,const typechecker::TypeId type_id) {
{
String output = String("");
(output += String("{"));
(output += String("auto& _jakt_ref = "));
(output += TRY((((*this).codegen_expression(lhs)))));
(output += String(";"));
(output += String("_jakt_ref = JaktInternal::"));
(output += JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::AddAssign>();
return JaktInternal::ExplicitValue(String("checked_add"));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::SubtractAssign>();
return JaktInternal::ExplicitValue(String("checked_sub"));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::MultiplyAssign>();
return JaktInternal::ExplicitValue(String("checked_mul"));
};/*case end*/
case 31: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::DivideAssign>();
return JaktInternal::ExplicitValue(String("checked_div"));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::BinaryOperator::ModuloAssign>();
return JaktInternal::ExplicitValue(String("checked_mod"));
};/*case end*/
default: {
{
utility::panic(TRY((String::formatted(String("Checked binary operation assignment codegen is not supported for BinaryOperator::{}"),op))));
}
};/*case end*/
}/*switch end*/
}()
)));
(output += String("<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(">(_jakt_ref, "));
(output += TRY((((*this).codegen_expression(rhs)))));
(output += String(");"));
(output += String("}"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_type(const typechecker::EnumId id,const bool as_namespace) const {
{
String output = String("");
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((id).module)));
const typechecker::CheckedEnum checked_enum = ((((*this).program))->get_enum(id));
if (((!(as_namespace)) && ((checked_enum).is_boxed))){
(output += String("NonnullRefPtr<"));
if ((!((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL)))))))){
(output += ((type_module)->name));
(output += String("::"));
}
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((checked_enum).scope_id)))));
if ((!(((qualifier).is_empty())))){
(output += String("typename "));
(output += qualifier);
}
(output += ((checked_enum).name));
(output += String(">"));
}
else {
if ((!((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL)))))))){
(output += ((type_module)->name));
(output += String("::"));
}
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((checked_enum).scope_id)))));
if ((!(((qualifier).is_empty())))){
(output += qualifier);
}
(output += ((checked_enum).name));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_constructor(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
const typechecker::TypeId type_id = ((function_)->return_type_id);
const NonnullRefPtr<typechecker::Type> type_ = ((((*this).program))->get_type(type_id));
if (((type_)->index() == 22 /* Struct */)){
const typechecker::StructId struct_id = (type_->get<typechecker::Type::Struct>()).value;
const typechecker::CheckedStruct structure = ((((*this).program))->get_struct(struct_id));
if (((((structure).record_type)).index() == 1 /* Class */)){
String output = String("");
(output += String("private:\n"));
(output += TRY((String::formatted(String("explicit {}("),((function_)->name)))));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

const typechecker::TypeId param_type_id = ((((param).variable)).type_id);
(output += TRY((((*this).codegen_type(param_type_id)))));
(output += String("&& a_"));
(output += ((((param).variable)).name));
}

}
}

(output += String(")"));
if ((!(((((function_)->params)).is_empty())))){
(output += String(": "));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += ((((param).variable)).name));
(output += String("(move(a_"));
(output += ((((param).variable)).name));
(output += String("))"));
}

}
}

}
(output += String("{}\n"));
String class_name_with_generics = String("");
(class_name_with_generics += ((structure).name));
(first = true);
{
ArrayIterator<typechecker::TypeId> _magic = ((((structure).generic_parameters)).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId generic_parameter = (_magic_value.value());
{
if ((!(first))){
(class_name_with_generics += String(", "));
}
else {
(class_name_with_generics += String("<"));
(first = false);
}

(class_name_with_generics += TRY((((*this).codegen_type(generic_parameter)))));
}

}
}

if ((!(((((structure).generic_parameters)).is_empty())))){
(class_name_with_generics += String(">"));
}
(output += String("public:\n"));
(output += TRY((String::formatted(String("static ErrorOr<NonnullRefPtr<{}>> create"),class_name_with_generics))));
(output += String("("));
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" "));
(output += ((((param).variable)).name));
}

}
}

(output += TRY((String::formatted(String(") {{ auto o = {}(adopt_nonnull_ref_or_enomem(new (nothrow) {} ("),TRY((((*this).current_error_handler()))),class_name_with_generics))));
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += String("move("));
(output += ((((param).variable)).name));
(output += String(")"));
}

}
}

(output += String("))); return o; }"));
return (output);
}
else {
String output = String("");
(output += ((function_)->name));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(((((param).variable)).type_id))))));
(output += String(" a_"));
(output += ((((param).variable)).name));
}

}
}

(output += String(") "));
if ((!(((((function_)->params)).is_empty())))){
(output += String(":"));
}
(first = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((function_)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += ((((param).variable)).name));
(output += String("(a_"));
(output += ((((param).variable)).name));
(output += String(")"));
}

}
}

(output += String("{}\n"));
return (output);
}

return (String(""));
}
else {
utility::panic(String("internal error: call to a constructor, but not a struct/class type"));
}

}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_debug_description_getter(const typechecker::CheckedEnum enum_) {
{
String output = String("");
(output += String("ErrorOr<String> debug_description() const {\n"));
(output += String("auto builder = TRY(StringBuilder::create());\n"));
(output += String("switch (this->index()) {"));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((enum_).variants)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const typechecker::CheckedEnumVariant variant = ((((enum_).variants))[i]);
const String name = ((variant).name());
(output += TRY((String::formatted(String("case {} /* {} */: {{\n"),i,name))));
(output += TRY((String::formatted(String("[[maybe_unused]] auto const& that = this->template get<{}::{}>();\n"),((enum_).name),name))));
(output += TRY((String::formatted(String("TRY(builder.append(\"{}::{}\"));\n"),((enum_).name),name))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
(output += String("TRY(builder.append(\"(\"));\n"));
(output += String("JaktInternal::_pretty_print_level++;\n"));
size_t i = static_cast<size_t>(0ULL);
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
(output += String("TRY(JaktInternal::_output_pretty_indent(builder));\n"));
const typechecker::CheckedVariable var = ((((*this).program))->get_variable(field));
if (((((*this).program))->is_string(((var).type_id)))){
(output += TRY((String::formatted(String("TRY(builder.appendff(\"{}: \\\"{{}}\\\"\", that.{}));\n"),((var).name),((var).name)))));
}
else {
(output += TRY((String::formatted(String("TRY(builder.appendff(\"{}: {{}}\", that.{}));\n"),((var).name),((var).name)))));
}

if ((i != (JaktInternal::checked_sub<size_t>(((fields).size()),static_cast<size_t>(1ULL))))){
(output += String("TRY(builder.append(\", \"));\n"));
}
((i++));
}

}
}

(output += String("JaktInternal::_pretty_print_level--;\n"));
(output += String("TRY(builder.append(\")\"));\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
if (((((*this).program))->is_string(type_id))){
(output += String("TRY(builder.appendff(\"(\\\"{}\\\")\", that.value));\n"));
}
else {
(output += String("TRY(builder.appendff(\"({})\", that.value));\n"));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
(output += String("break;}\n"));
}

}
}

(output += String("}\nreturn builder.to_string();\n}"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_enum_match(const typechecker::CheckedEnum enum_,const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> match_cases,const typechecker::TypeId type_id,const bool all_variants_constant) {
{
String output = String("");
(output += ((((*this).control_flow_state)).choose_control_flow_macro()));
const String subject = TRY((((*this).codegen_expression(expr))));
const bool needs_deref = (((enum_).is_boxed) && (subject != String("*this")));
if (((((enum_).underlying_type_id)).equals(typechecker::void_type_id()))){
(output += String("(([&]() -> JaktInternal::ExplicitValueOrControlFlow<"));
(output += TRY((((*this).codegen_type(type_id)))));
(output += String(", "));
(output += TRY((((*this).codegen_function_return_type((((*this).current_function).value()))))));
(output += String(">{\n"));
(output += String("auto&& __jakt_match_variant = "));
if (needs_deref){
(output += String("*"));
}
(output += (TRY((((*this).codegen_expression(expr)))) + String(";\n")));
(output += String("switch(__jakt_match_variant.index()) {\n"));
bool has_default = false;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase match_case = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = match_case;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
size_t const& index = __jakt_match_value.index;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
const NonnullRefPtr<typechecker::Type> enum_type = ((((*this).program))->get_type(subject_type_id));
const typechecker::EnumId enum_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::EnumId, ErrorOr<String>>{
auto&& __jakt_match_variant = *enum_type;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(id);
};/*case end*/
default: {
{
utility::panic(String("Expected enum type"));
}
};/*case end*/
}/*switch end*/
}()
));
const typechecker::CheckedEnum match_case_enum = ((((*this).program))->get_enum(enum_id));
const typechecker::CheckedEnumVariant variant = ((((match_case_enum).variants))[index]);
(output += (TRY((String::formatted(String("case {}: "),index))) + String("{\n")));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
if ((!(((args).is_empty())))){
const parser::EnumVariantPatternArgument arg = ((args)[static_cast<i64>(0LL)]);
const typechecker::CheckedVariable var = (TRY((((((*this).program))->find_var_in_scope(scope_id,((arg).binding))))).value());
(output += TRY((String::formatted(String("{} const& {} = __jakt_match_value.value;\n"),TRY((((*this).codegen_type(((var).type_id))))),((arg).binding)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
{
(output += TRY((String::formatted(String("auto&& __jakt_match_value = __jakt_match_variant.template get<{}::{}>();"),TRY((((*this).codegen_type_possibly_as_namespace(subject_type_id,true)))),name))));
if ((!(((args).is_empty())))){
{
ArrayIterator<parser::EnumVariantPatternArgument> _magic = ((args).iterator());
for (;;){
Optional<parser::EnumVariantPatternArgument> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
parser::EnumVariantPatternArgument arg = (_magic_value.value());
{
const typechecker::CheckedVariable var = (TRY((((((*this).program))->find_var_in_scope(scope_id,((arg).binding))))).value());
(output += TRY((((*this).codegen_type(((var).type_id))))));
(output += String(" const& "));
(output += ((arg).binding));
(output += String(" = __jakt_match_value."));
(output += ((((arg).name)).value_or(((arg).binding))));
(output += String(";\n"));
}

}
}

}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::todo(TRY((String::formatted(String("codegen_enum_match match variant else: {}"),variant))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
(output += TRY((((*this).codegen_match_body(body,type_id)))));
(output += String("};/*case end*/\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
{
(has_default = true);
(output += String("default: {\n"));
(output += TRY((((*this).codegen_match_body(body,type_id)))));
(output += String("};/*case end*/\n"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("Matching enum subject with non-enum value"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}

}
}

if ((!(has_default))){
if ((((((enum_).variants)).size()) != ((match_cases).size()))){
utility::panic(String("Inexhaustive match statement"));
}
(output += String("default: VERIFY_NOT_REACHED();"));
}
(output += String("}/*switch end*/\n"));
(output += String("}()\n))"));
}
else {
utility::todo(String("underlying type enum match"));
}

return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_match(const NonnullRefPtr<typechecker::CheckedExpression> expr,const Array<typechecker::CheckedMatchCase> match_cases,const typechecker::TypeId type_id,const bool all_variants_constant) {
{
const codegen::ControlFlowState last_control_flow = ((*this).control_flow_state);
(((*this).control_flow_state) = ((((*this).control_flow_state)).enter_match()));
String output = String("");
const NonnullRefPtr<typechecker::Type> expr_type = ((((*this).program))->get_type(typechecker::expression_type(expr)));
if (((expr_type)->index() == 23 /* Enum */)){
const typechecker::EnumId enum_id = (expr_type->get<typechecker::Type::Enum>()).value;
(output += TRY((((*this).codegen_enum_match(((((*this).program))->get_enum(enum_id)),expr,match_cases,type_id,all_variants_constant)))));
}
else {
(output += TRY((((*this).codegen_generic_match(expr,match_cases,type_id,all_variants_constant)))));
}

(((*this).control_flow_state) = last_control_flow);
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_return_type(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
if ((((function_)->is_static()) && (((function_)->name) == String("main")))){
return (String("ErrorOr<int>"));
}
const String type_name = TRY((((*this).codegen_type(((function_)->return_type_id)))));
if (((function_)->can_throw)){
return (TRY((String::formatted(String("ErrorOr<{}>"),type_name))));
}
return (type_name);
}
}

ErrorOr<String> codegen::CodeGenerator::generate(const NonnullRefPtr<compiler::Compiler> compiler,const NonnullRefPtr<typechecker::CheckedProgram> program,const bool debug_info) {
{
codegen::CodeGenerator generator = codegen::CodeGenerator(compiler,program,codegen::ControlFlowState(typename codegen::AllowedControlExits::Nothing(),false,false,static_cast<size_t>(0ULL)),(TRY((Array<Tuple<String,String>>::create_with({})))),String(""),JaktInternal::OptionalNone(),codegen::CodegenDebugInfo(compiler,(TRY((Dictionary<size_t, Array<codegen::LineSpan>>::create_with_entries({})))),debug_info),(TRY((Array<String>::create_with({})))),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL));
String output = String("");
(output += String("#include <lib.h>\n"));
const Array<typechecker::ModuleId> sorted_modules = TRY((((generator).topologically_sort_modules())));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child_scope = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(child_scope))));
if (((((scope)->import_path_if_extern)).has_value())){
const bool has_name = ((((scope)->namespace_name)).has_value());
if (has_name){
(output += TRY((String::formatted(String("namespace {} {{\n"),(((scope)->namespace_name).value())))));
}
(output += TRY((String::formatted(String("#include <{}>\n"),(((scope)->import_path_if_extern).value())))));
if (has_name){
(output += ((String(" } // namespace ") + (((scope)->namespace_name).value())) + String("\n")));
}
}
}

}
}

}

}
}

(output += String("namespace Jakt {\n"));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
((((generator).compiler))->dbg_println(TRY((String::formatted(String("generate: module idx: {}, module.name {}"),i,((module)->name))))));
if ((!(((module)->is_root)))){
(output += String("namespace "));
(output += ((module)->name));
(output += String(" {\n"));
}
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
(output += TRY((((generator).codegen_namespace_predecl(scope,module)))));
if ((!(((module)->is_root)))){
(output += String("}\n"));
}
}

}
}

{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(((sorted_modules).size())),static_cast<size_t>(static_cast<size_t>(0ULL))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t idx = (_magic_value.value());
{
const size_t i = ((((sorted_modules)[(JaktInternal::checked_sub<size_t>(idx,static_cast<size_t>(1ULL)))])).id);
if ((i == static_cast<size_t>(0ULL))){
continue;
}
const NonnullRefPtr<typechecker::Module> module = ((((((generator).program))->modules))[i]);
((((generator).compiler))->dbg_println(TRY((String::formatted(String("generate: module idx: {}, module.name {}"),i,((module)->name))))));
const typechecker::ScopeId scope_id = typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((((generator).program))->get_scope(scope_id))));
if ((!(((module)->is_root)))){
(output += String("namespace "));
(output += ((module)->name));
(output += String(" {\n"));
TRY((((((generator).namespace_stack)).push(((module)->name)))));
}
(output += TRY((((generator).codegen_namespace(scope,module)))));
if ((!(((module)->is_root)))){
const Optional<String> dummy = ((((generator).namespace_stack)).pop());
}
if ((!(((module)->is_root)))){
(output += String("}\n"));
}
}

}
}

(output += ((generator).deferred_output));
(output += String("} // namespace Jakt\n"));
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_call(const typechecker::CheckedCall call) {
{
String output = String("");
if (((call).callee_throws)){
(output += TRY((((*this).current_error_handler()))));
(output += String("(("));
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("println")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprintln")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("eprint")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else if (__jakt_enum_value == String("format")) {
{
const String helper = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((call).name));
if (__jakt_enum_value == String("print")) {
return JaktInternal::ExplicitValue(String("out"));
}
else if (__jakt_enum_value == String("println")) {
return JaktInternal::ExplicitValue(String("outln"));
}
else if (__jakt_enum_value == String("eprint")) {
return JaktInternal::ExplicitValue(String("warn"));
}
else if (__jakt_enum_value == String("eprintln")) {
return JaktInternal::ExplicitValue(String("warnln"));
}
else if (__jakt_enum_value == String("format")) {
return JaktInternal::ExplicitValue(String("String::formatted"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
(output += helper);
(output += String("("));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> expr = ((((((call).args))[i])).get<1>());
(output += TRY((((*this).codegen_expression(expr)))));
if ((i != (JaktInternal::checked_sub<size_t>(((((call).args)).size()),static_cast<size_t>(1ULL))))){
(output += String(","));
}
}

}
}

(output += String(")"));
}
return JaktInternal::ExplicitValue<void>();
}
else {
{
if (((((call).function_id)).has_value())){
const typechecker::FunctionId function_id = (((call).function_id).value());
const NonnullRefPtr<typechecker::CheckedFunction> function_ = ((((*this).program))->get_function(function_id));
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if ((((((function_)->type)).index() == 1 /* ImplicitConstructor */) || ((((function_)->type)).index() == 3 /* ExternalClassConstructor */))){
const typechecker::TypeId type_id = ((call).return_type);
const NonnullRefPtr<typechecker::Type> type = ((((*this).program))->get_type(type_id));
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if ((!((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL)))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(struct_id));
if (((((struct_).record_type)).index() == 1 /* Class */)){
(output += ((call).name));
(output += String("::"));
(output += String("create"));
}
else {
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
{
const typechecker::CheckedStruct struct_ = ((((*this).program))->get_struct(id));
if (((((struct_).record_type)).index() == 1 /* Class */)){
(output += TRY((((*this).codegen_namespace_qualifier(((struct_).scope_id))))));
(output += ((struct_).name));
(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId arg = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(arg)))));
}

}
}

(output += String(">::create"));
}
else {
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("Should be unreachable"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
else if (((((function_)->type)).index() == 2 /* ImplicitEnumConstructor */)){
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = *((((*this).program))->get_type(((function_)->return_type_id)));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(enum_id));
const NonnullRefPtr<typechecker::Module> enum_type_module = ((((*this).program))->get_module(((enum_id).module)));
if (((enum_).is_boxed)){
const NonnullRefPtr<typechecker::Module> type_module = ((((*this).program))->get_module(((function_id).module)));
if ((!((((type_module)->is_root) || ((((type_module)->id)).equals(typechecker::ModuleId(static_cast<size_t>(0ULL)))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += String("template create<typename "));
(output += TRY((((*this).codegen_type_possibly_as_namespace(((call).return_type),true)))));
(output += ((String("::") + ((call).name)) + String(">")));
}
else {
(output += String("typename "));
(output += TRY((((*this).codegen_type(((call).return_type))))));
(output += String("::"));
(output += ((call).name));
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
{
utility::todo(String("codegen generic enum instance"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
utility::panic(String("constructor expected enum type"));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
}
else {
if ((!((((((type_module)->is_root) || (((((type_module)->id)).id) == static_cast<size_t>(0ULL))) || ((((function_)->linkage)).index() == 1 /* External */)) || ((!(((((call).namespace_)).is_empty()))) && (((((((call).namespace_))[static_cast<i64>(0LL)])).name) == ((type_module)->name))))))){
(output += ((type_module)->name));
(output += String("::"));
}
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += ((call).name));
}

}
else {
(output += TRY((((*this).codegen_namespace_path(call)))));
(output += ((call).name));
}

const Array<typechecker::TypeId> generic_parameters = ((call).type_args);
if ((!(((generic_parameters).is_empty())))){
Array<String> types = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((generic_parameters).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId gen_param = (_magic_value.value());
{
TRY((((types).push(TRY((((*this).codegen_type_possibly_as_namespace(gen_param,false))))))));
}

}
}

(output += TRY((String::formatted(String("<{}>"),utility::join(types,String(", "))))));
}
Array<String> arguments = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
TRY((((arguments).push(TRY((((*this).codegen_expression(((arg).get<1>())))))))));
}

}
}

(output += TRY((String::formatted(String("({})"),utility::join(arguments,String(","))))));
}
return JaktInternal::ExplicitValue<void>();
}
return JaktInternal::ExplicitValue<void>();
}()))
;
if (((call).callee_throws)){
(output += String("))"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_generic_enum_instance(const typechecker::EnumId id,const Array<typechecker::TypeId> args,const bool as_namespace) const {
{
String output = String("");
bool close_tag = false;
const typechecker::CheckedEnum enum_ = ((((*this).program))->get_enum(id));
if (((!(as_namespace)) && ((enum_).is_boxed))){
(output += String("NonnullRefPtr<"));
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((enum_).scope_id)))));
if ((!(((qualifier).is_empty())))){
(output += String("typename "));
(output += qualifier);
}
(output += ((enum_).name));
(close_tag = true);
}
else {
const String qualifier = TRY((((*this).codegen_namespace_qualifier(((enum_).scope_id)))));
if ((!(((qualifier).is_empty())))){
(output += String("typename "));
(output += qualifier);
}
(output += ((enum_).name));
}

(output += String("<"));
bool first = true;
{
ArrayIterator<typechecker::TypeId> _magic = ((args).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId type_id = (_magic_value.value());
{
if ((!(first))){
(output += String(", "));
}
else {
(first = false);
}

(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">"));
if (close_tag){
(output += String(">"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_function_generic_parameters(const NonnullRefPtr<typechecker::CheckedFunction> function_) {
{
String output = String("");
if ((!(((((function_)->generic_params)).is_empty())))){
(output += String("template <"));
bool first = true;
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((function_)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::FunctionGenericParameter generic_parameter = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(","));
}

(output += String("typename "));
const typechecker::TypeId type_id = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<typechecker::TypeId, ErrorOr<String>>{
auto&& __jakt_match_variant = generic_parameter;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(type_id);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(output += TRY((((*this).codegen_type(type_id)))));
}

}
}

(output += String(">\n"));
}
return (output);
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_ak_formatter(const String name,const Array<String> generic_parameter_names) {
{
String output = String("");
const String template_args = utility::join(TRY((utility::prepend_to_each(generic_parameter_names,String("typename ")))),String(", "));
const String generic_type_args = utility::join(generic_parameter_names,String(", "));
String qualified_name = String("");
{
ArrayIterator<String> _magic = ((((*this).namespace_stack)).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String namespace_ = (_magic_value.value());
{
(qualified_name += TRY((String::formatted(String("{}::"),namespace_))));
}

}
}

(qualified_name += name);
if ((!(((generic_parameter_names).is_empty())))){
(qualified_name += TRY((String::formatted(String("<{}>\n"),generic_type_args))));
}
(output += TRY((String::formatted(String("template<{}>"),template_args))));
(output += TRY((String::formatted(String("struct Formatter<{}> : Formatter<StringView>"),qualified_name))));
(output += String("{\n"));
(output += TRY((String::formatted(String("ErrorOr<void> format(FormatBuilder& builder, {} const& value)\n"),qualified_name))));
(output += String("{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }"));
(output += String("return Formatter<StringView>::format(builder, MUST(value.debug_description())); }"));
return ((output + String("};\n")));
}
}

ErrorOr<String> codegen::CodeGenerator::codegen_type(const typechecker::TypeId type_id) const {
{
return (TRY((((*this).codegen_type_possibly_as_namespace(type_id,false)))));
}
}

ErrorOr<void> codegen::CodeGenerator::postorder_traversal(const String encoded_type_id,Set<String> visited,const Dictionary<String,Array<String>> encoded_dependency_graph,Array<typechecker::TypeId> output) const {
{
const typechecker::TypeId type_id = TRY((typechecker::TypeId::from_string(encoded_type_id)));
if (((visited).contains(TRY((((type_id).to_string())))))){
return {};
}
TRY((((visited).add(TRY((((type_id).to_string())))))));
if (((encoded_dependency_graph).contains(encoded_type_id))){
{
ArrayIterator<String> _magic = (((((encoded_dependency_graph).get(encoded_type_id)).value())).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String dependency = (_magic_value.value());
{
TRY((((*this).postorder_traversal(dependency,visited,encoded_dependency_graph,output))));
}

}
}

}
TRY((((output).push(type_id))));
}
return {};
}

ErrorOr<String> codegen::CodeGenerator::fresh_label() {
{
return (TRY((String::formatted(String("__jakt_label_{}"),((((*this).fresh_label_counter)++))))));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_function() const {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::JustReturn(),false,false,((*this).match_nest_level)));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_loop() const {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::AtLoop(),false,((*this).passes_through_try),static_cast<size_t>(0ULL)));
}
}

codegen::ControlFlowState codegen::ControlFlowState::no_control_flow() {
{
return (codegen::ControlFlowState(typename codegen::AllowedControlExits::Nothing(),false,false,static_cast<size_t>(0ULL)));
}
}

bool codegen::ControlFlowState::is_match_nested() const {
{
return ((((*this).match_nest_level) != static_cast<size_t>(0ULL)));
}
}

String codegen::ControlFlowState::choose_control_flow_macro() const {
{
if (codegen::are_loop_exits_allowed(((*this).allowed_exits))){
if (((*this).is_match_nested())){
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH"));
}
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP"));
}
return (String("JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY"));
}
}

codegen::ControlFlowState codegen::ControlFlowState::enter_match() const {
{
size_t level = ((*this).match_nest_level);
if (((*this).passes_through_match)){
(level = (JaktInternal::checked_add<size_t>(((*this).match_nest_level),static_cast<size_t>(1ULL))));
}
return (codegen::ControlFlowState(((((*this).allowed_exits)).allow_return()),true,((*this).passes_through_try),level));
}
}

codegen::AllowedControlExits codegen::AllowedControlExits::allow_return() const {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<codegen::AllowedControlExits, codegen::AllowedControlExits>{
auto&& __jakt_match_variant = *this;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::Nothing>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::JustReturn());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::JustReturn>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::JustReturn());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename codegen::AllowedControlExits::AtLoop>();
return JaktInternal::ExplicitValue(typename codegen::AllowedControlExits::AtLoop());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

}
namespace repl {
struct Editor {
  public:
FILE* standard_input_file;char* line_pointer;String prompt;static ErrorOr<repl::Editor> create(const String prompt);
void destroy();
Editor(FILE* a_standard_input_file, char* a_line_pointer, String a_prompt) :standard_input_file(a_standard_input_file), line_pointer(a_line_pointer), prompt(a_prompt){}

ErrorOr<repl::LineResult> get_line();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("Editor("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("standard_input_file: "));TRY(builder.appendff("{}, ", standard_input_file));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("line_pointer: "));TRY(builder.appendff("{}, ", line_pointer));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("prompt: "));TRY(builder.appendff("\"{}\"", prompt));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};namespace LineResult_Details {
struct Line{
String value;
template<typename... Args>
Line(Args&&... args): value { forward<Args>(args)... } {}
};
struct Eof {};
}
struct LineResult : public Variant<LineResult_Details::Line, LineResult_Details::Eof> {
using Variant<LineResult_Details::Line, LineResult_Details::Eof>::Variant;
    using Line = LineResult_Details::Line;
    using Eof = LineResult_Details::Eof;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Line */: {
[[maybe_unused]] auto const& that = this->template get<LineResult::Line>();
TRY(builder.append("LineResult::Line"));
TRY(builder.appendff("(\"{}\")", that.value));
break;}
case 1 /* Eof */: {
[[maybe_unused]] auto const& that = this->template get<LineResult::Eof>();
TRY(builder.append("LineResult::Eof"));
break;}
}
return builder.to_string();
}};
struct REPL {
  public:
NonnullRefPtr<compiler::Compiler> compiler;typechecker::Typechecker typechecker;typechecker::ScopeId root_scope_id;NonnullRefPtr<typechecker::InterpreterScope> root_interpreter_scope;utility::FileId file_id;static ErrorOr<repl::REPL> create();
ErrorOr<void> run();
REPL(NonnullRefPtr<compiler::Compiler> a_compiler, typechecker::Typechecker a_typechecker, typechecker::ScopeId a_root_scope_id, NonnullRefPtr<typechecker::InterpreterScope> a_root_interpreter_scope, utility::FileId a_file_id) :compiler(a_compiler), typechecker(a_typechecker), root_scope_id(a_root_scope_id), root_interpreter_scope(a_root_interpreter_scope), file_id(a_file_id){}

ErrorOr<bool> handle_possible_error();
ErrorOr<String> debug_description() const { auto builder = MUST(StringBuilder::create());TRY(builder.append("REPL("));JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("compiler: "));TRY(builder.appendff("{}, ", *compiler));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("typechecker: "));TRY(builder.appendff("{}, ", typechecker));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("root_scope_id: "));TRY(builder.appendff("{}, ", root_scope_id));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("root_interpreter_scope: "));TRY(builder.appendff("{}, ", *root_interpreter_scope));
TRY(JaktInternal::_output_pretty_indent(builder));TRY(builder.append("file_id: "));TRY(builder.appendff("{}", file_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));return builder.to_string(); }};static ErrorOr<String> serialize_ast_node(const NonnullRefPtr<typechecker::CheckedExpression> node) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *node;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Boolean>();bool const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}"),val))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NumericConstant>();typechecker::CheckedNumericConstant const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = val;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I8>();
i8 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}i8"),value))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I16>();
i16 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}i16"),value))));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I32>();
i32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}i32"),value))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::I64>();
i64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}i64"),value))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U8>();
u8 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}u8"),value))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U16>();
u16 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}u16"),value))));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U32>();
u32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}u32"),value))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::U64>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}u64"),value))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F32>();
f32 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}f32"),value))));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::F64>();
f64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}f64"),value))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedNumericConstant::USize>();
u64 const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}uz"),value))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::QuotedString>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("\"{}\""),val))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ByteConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("b'{}'"),val))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::CharacterConstant>();String const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("'{}'"),val))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedUnaryOperator const& op = __jakt_match_value.op;
return JaktInternal::ExplicitValue(repl::serialize_unary_operation(op,TRY((repl::serialize_ast_node(expr)))));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktTuple>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_204; {
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(String("(")))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vals).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((i != static_cast<size_t>(0ULL))){
TRY((((builder).append_string(String(", ")))));
}
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((vals)[i]))))))));
}

}
}

TRY((((builder).append_string(String(")")))));
__jakt_var_204 = TRY((((builder).to_string()))); goto __jakt_label_198;

}
__jakt_label_198:; __jakt_var_204.release_value(); }));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Range>();NonnullRefPtr<typechecker::CheckedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<typechecker::CheckedExpression> const& to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}..{}"),TRY((repl::serialize_ast_node(from))),TRY((repl::serialize_ast_node(to)))))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_205; {
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(String("[")))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vals).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((i != static_cast<size_t>(0ULL))){
TRY((((builder).append_string(String(", ")))));
}
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((vals)[i]))))))));
}

}
}

TRY((((builder).append_string(String("]")))));
__jakt_var_205 = TRY((((builder).to_string()))); goto __jakt_label_199;

}
__jakt_label_199:; __jakt_var_205.release_value(); }));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktSet>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_206; {
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(String("{")))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vals).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((i != static_cast<size_t>(0ULL))){
TRY((((builder).append_string(String(", ")))));
}
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((vals)[i]))))))));
}

}
}

TRY((((builder).append_string(String("}")))));
__jakt_var_206 = TRY((((builder).to_string()))); goto __jakt_label_200;

}
__jakt_label_200:; __jakt_var_206.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_207; {
StringBuilder builder = TRY((StringBuilder::create()));
TRY((((builder).append_string(String("[")))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((vals).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((i != static_cast<size_t>(0ULL))){
TRY((((builder).append_string(String(", ")))));
}
const Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>> val = ((vals)[i]);
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((val).get<0>()))))))));
TRY((((builder).append_string(String(": ")))));
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((val).get<1>()))))))));
}

}
}

TRY((((builder).append_string(String("]")))));
__jakt_var_207 = TRY((((builder).to_string()))); goto __jakt_label_201;

}
__jakt_label_201:; __jakt_var_207.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}[{}]"),TRY((repl::serialize_ast_node(expr))),TRY((repl::serialize_ast_node(index)))))));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedRangeExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& from = __jakt_match_value.from;
NonnullRefPtr<typechecker::CheckedExpression> const& to = __jakt_match_value.to;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}[{}..{}]"),TRY((repl::serialize_ast_node(expr))),TRY((repl::serialize_ast_node(from))),TRY((repl::serialize_ast_node(to)))))));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}[{}]"),TRY((repl::serialize_ast_node(expr))),TRY((repl::serialize_ast_node(index)))))));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedTuple>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
size_t const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}.{}"),TRY((repl::serialize_ast_node(expr))),index))));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}.{}"),TRY((repl::serialize_ast_node(expr))),index))));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();Array<typechecker::CheckedNamespace> const& namespaces = __jakt_match_value.namespaces;
typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_208; {
StringBuilder builder = TRY((StringBuilder::create()));
{
ArrayIterator<typechecker::CheckedNamespace> _magic = ((namespaces).iterator());
for (;;){
Optional<typechecker::CheckedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedNamespace namespace_ = (_magic_value.value());
{
TRY((((builder).append_string(((namespace_).name)))));
TRY((((builder).append_string(String("::")))));
}

}
}

TRY((((builder).append_string(((var).name)))));
__jakt_var_208 = TRY((((builder).to_string()))); goto __jakt_label_202;

}
__jakt_label_202:; __jakt_var_208.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
return JaktInternal::ExplicitValue(((var).name));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalNone>();return JaktInternal::ExplicitValue(String("None"));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::OptionalSome>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("Some({})"),TRY((repl::serialize_ast_node(expr)))))));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("{}!"),TRY((repl::serialize_ast_node(expr)))))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_209; {
StringBuilder builder = TRY((StringBuilder::create()));
{
ArrayIterator<typechecker::ResolvedNamespace> _magic = ((((call).namespace_)).iterator());
for (;;){
Optional<typechecker::ResolvedNamespace> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ResolvedNamespace namespace_ = (_magic_value.value());
{
TRY((((builder).append_string(((namespace_).name)))));
TRY((((builder).append_string(String("::")))));
}

}
}

TRY((((builder).append_string(((call).name)))));
TRY((((builder).append_string(String("(")))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((((call).args)).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
if ((i != static_cast<size_t>(0ULL))){
TRY((((builder).append_string(String(", ")))));
}
const Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = ((((call).args))[i]);
if ((!(((((arg).get<0>())).is_empty())))){
TRY((((builder).append_string(((arg).get<0>())))));
TRY((((builder).append_string(String(": ")))));
}
TRY((((builder).append_string(TRY((repl::serialize_ast_node(((arg).get<1>()))))))));
}

}
}

TRY((((builder).append_string(String(")")))));
__jakt_var_209 = TRY((((builder).to_string()))); goto __jakt_label_203;

}
__jakt_label_203:; __jakt_var_209.release_value(); }));
};/*case end*/
case 30: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedExpression::Garbage>();
return JaktInternal::ExplicitValue(String("<Garbage>"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String("<Unimplemented>"));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static String serialize_unary_operation(const typechecker::CheckedUnaryOperator op,const String expr) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, String>{
auto&& __jakt_match_variant = op;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreIncrement>();
return JaktInternal::ExplicitValue((String("++") + expr));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostIncrement>();
return JaktInternal::ExplicitValue((expr + String("++")));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PreDecrement>();
return JaktInternal::ExplicitValue((String("--") + expr));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::PostDecrement>();
return JaktInternal::ExplicitValue((expr + String("--")));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Negate>();
return JaktInternal::ExplicitValue((String("-") + expr));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Dereference>();
return JaktInternal::ExplicitValue((String("*") + expr));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::RawAddress>();
return JaktInternal::ExplicitValue((String("&raw ") + expr));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::Reference>();
return JaktInternal::ExplicitValue((String("&") + expr));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::MutableReference>();
return JaktInternal::ExplicitValue((String("&mut ") + expr));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::LogicalNot>();
return JaktInternal::ExplicitValue((String("not ") + expr));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedUnaryOperator::BitwiseNot>();
return JaktInternal::ExplicitValue((String("~") + expr));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(((String("(<Unimplemented unary operator> ") + expr) + String(")")));
};/*case end*/
}/*switch end*/
}()
)));
}
}

template <typename T>
static T* allocate(const size_t count) {
{
{
return static_cast<T*>(malloc(count * sizeof(T)));
}

abort();
}
}

template <typename T>
static T* null() {
{
{
return nullptr;
}

abort();
}
}

ErrorOr<repl::Editor> repl::Editor::create(const String prompt) {
{
FILE* std_in = fopen(((String("/dev/stdin")).c_string()),((String("r")).c_string()));
if ((std_in == repl::null<FILE>())){
warnln(String("Could not open /dev/stdin for reading"));
return Error::from_errno(static_cast<i32>(42));
}
const repl::Editor editor = repl::Editor(std_in,repl::allocate<char>(static_cast<size_t>(4096ULL)),prompt);
return (editor);
}
}

void repl::Editor::destroy() {
{
fclose(((*this).standard_input_file));
{
free(line_pointer);
}

}
}

ErrorOr<repl::LineResult> repl::Editor::get_line() {
{
warn(String("{}"),((*this).prompt));
StringBuilder builder = TRY((StringBuilder::create()));
{
const char* c_string = fgets(((*this).line_pointer),static_cast<size_t>(4096ULL),((*this).standard_input_file));
if ((c_string == repl::null<char>())){
return (typename repl::LineResult::Eof());
}
TRY((((builder).append_c_string(c_string))));
}

return (typename repl::LineResult::Line(TRY((((builder).to_string())))));
}
}

ErrorOr<repl::REPL> repl::REPL::create() {
{
NonnullRefPtr<compiler::Compiler> compiler = TRY((compiler::Compiler::create((TRY((Array<NonnullRefPtr<utility::FilePath>>::create_with({})))),(TRY((Dictionary<String, utility::FileId>::create_with_entries({})))),(TRY((Array<error::JaktError>::create_with({})))),JaktInternal::OptionalNone(),(TRY((Array<u8>::create_with({})))),false,false,false,false,(TRY((Array<String>::create_with({})))),false,false,false)));
TRY((((compiler)->load_prelude())));
const utility::FileId file_id = TRY((((compiler)->get_file_id_or_register(TRY((utility::FilePath::make(String("<repl>"))))))));
const typechecker::ModuleId placeholder_module_id = typechecker::ModuleId(static_cast<size_t>(0ULL));
typechecker::Typechecker typechecker = typechecker::Typechecker(compiler,TRY((typechecker::CheckedProgram::create(compiler,(TRY((Array<NonnullRefPtr<typechecker::Module>>::create_with({})))),(TRY((Dictionary<String, typechecker::LoadedModule>::create_with_entries({}))))))),placeholder_module_id,typechecker::TypeId::none(),JaktInternal::OptionalNone(),false,static_cast<size_t>(0ULL),false,((compiler)->dump_type_hints),((compiler)->dump_try_hints),static_cast<u64>(0ULL));
(((compiler)->current_file) = file_id);
TRY((((typechecker).include_prelude())));
const String root_module_name = String("<repl>");
const typechecker::ModuleId root_module_id = TRY((((typechecker).create_module(root_module_name,true))));
(((typechecker).current_module_id) = root_module_id);
TRY((((((typechecker).program))->set_loaded_module(root_module_name,typechecker::LoadedModule(root_module_id,file_id)))));
const typechecker::ScopeId PRELUDE_SCOPE_ID = ((typechecker).prelude_scope_id());
const typechecker::ScopeId root_scope_id = TRY((((typechecker).create_scope(PRELUDE_SCOPE_ID,true,String("root")))));
const NonnullRefPtr<typechecker::InterpreterScope> root_interpreter_scope = TRY((typechecker::InterpreterScope::create((TRY((Dictionary<String, typechecker::Value>::create_with_entries({})))),JaktInternal::OptionalNone())));
return (repl::REPL(compiler,typechecker,root_scope_id,root_interpreter_scope,file_id));
}
}

ErrorOr<void> repl::REPL::run() {
{
repl::Editor editor = TRY((repl::Editor::create(String("> "))));

#define __SCOPE_GUARD_NAME __scope_guard_ ## __COUNTER__
ScopeGuard __SCOPE_GUARD_NAME ([&] 
#undef __SCOPE_GUARD_NAME
{((editor).destroy());
});
for (;;){
if ((!(((((((*this).compiler))->errors)).is_empty())))){
TRY((((((*this).compiler))->print_errors())));
const Array<error::JaktError> arr = (TRY((Array<error::JaktError>::create_with({}))));
(((((*this).compiler))->errors) = arr);
}
const repl::LineResult line_result = ({ Optional<repl::LineResult> __jakt_var_210;
auto __jakt_var_211 = [&]() -> ErrorOr<repl::LineResult> { return TRY((((editor).get_line()))); }();
if (__jakt_var_211.is_error()) {auto error = __jakt_var_211.release_error();
{
return {};
}
} else {__jakt_var_210 = __jakt_var_211.release_value();
}
__jakt_var_210.release_value(); });
if (((line_result).index() == 0 /* Line */)){
const String line = (line_result.get<repl::LineResult::Line>()).value;
if ((line == String(".exit\n"))){
break;
}
size_t pos = static_cast<size_t>(0ULL);
Array<u8> bytes_ = (TRY((Array<u8>::create_with({}))));
TRY((((bytes_).ensure_capacity(((line).length())))));
while ((pos < ((line).length()))){
TRY((((bytes_).push(((line).byte_at(pos))))));
(++(pos));
}
(((((*this).compiler))->current_file) = ((*this).file_id));
(((((*this).compiler))->current_file_contents) = bytes_);
const Array<lexer::Token> tokens = ({ Optional<Array<lexer::Token>> __jakt_var_212;
auto __jakt_var_213 = [&]() -> ErrorOr<Array<lexer::Token>> { return TRY((lexer::Lexer::lex(((*this).compiler)))); }();
if (__jakt_var_213.is_error()) {{
continue;
}
} else {__jakt_var_212 = __jakt_var_213.release_value();
}
__jakt_var_212.release_value(); });
if (((tokens).is_empty())){
continue;
}
parser::Parser parser = parser::Parser(static_cast<size_t>(0ULL),tokens,((*this).compiler));
const lexer::Token first_token = (((tokens).first()).value());
if (((((((((first_token).index() == 73 /* Function */) || ((first_token).index() == 74 /* Comptime */)) || ((first_token).index() == 91 /* Struct */)) || ((first_token).index() == 64 /* Class */)) || ((first_token).index() == 69 /* Enum */)) || ((first_token).index() == 61 /* Boxed */)) || ((first_token).index() == 83 /* Namespace */))){
const parser::ParsedNamespace parsed_namespace = ({ Optional<parser::ParsedNamespace> __jakt_var_214;
auto __jakt_var_215 = [&]() -> ErrorOr<parser::ParsedNamespace> { return TRY((((parser).parse_namespace()))); }();
if (__jakt_var_215.is_error()) {{
TRY((((*this).handle_possible_error())));
continue;
}
} else {__jakt_var_214 = __jakt_var_215.release_value();
}
__jakt_var_214.release_value(); });
if (TRY((((*this).handle_possible_error())))){
continue;
}
auto __jakt_var_217 = [&]() -> ErrorOr<void> { return TRY((((((*this).typechecker)).typecheck_module(parsed_namespace,((*this).root_scope_id))))), ErrorOr<void>{}; }();
if (__jakt_var_217.is_error()) {{
TRY((((*this).handle_possible_error())));
continue;
}
}
;
TRY((((*this).handle_possible_error())));
continue;
}
const NonnullRefPtr<parser::ParsedStatement> parsed_statement = ({ Optional<NonnullRefPtr<parser::ParsedStatement>> __jakt_var_218;
auto __jakt_var_219 = [&]() -> ErrorOr<NonnullRefPtr<parser::ParsedStatement>> { return TRY((((parser).parse_statement(true)))); }();
if (__jakt_var_219.is_error()) {{
TRY((((*this).handle_possible_error())));
continue;
}
} else {__jakt_var_218 = __jakt_var_219.release_value();
}
__jakt_var_218.release_value(); });
if (TRY((((*this).handle_possible_error())))){
continue;
}
const NonnullRefPtr<typechecker::CheckedStatement> checked_statement = ({ Optional<NonnullRefPtr<typechecker::CheckedStatement>> __jakt_var_220;
auto __jakt_var_221 = [&]() -> ErrorOr<NonnullRefPtr<typechecker::CheckedStatement>> { return TRY((((((*this).typechecker)).typecheck_statement(parsed_statement,((*this).root_scope_id),typename typechecker::SafetyMode::Safe())))); }();
if (__jakt_var_221.is_error()) {{
TRY((((*this).handle_possible_error())));
continue;
}
} else {__jakt_var_220 = __jakt_var_221.release_value();
}
__jakt_var_220.release_value(); });
if (TRY((((*this).handle_possible_error())))){
continue;
}
typechecker::Interpreter interpreter = typechecker::Interpreter(((*this).compiler),((((*this).typechecker)).program),(TRY((Array<utility::Span>::create_with({})))));
const typechecker::StatementResult result = ({ Optional<typechecker::StatementResult> __jakt_var_222;
auto __jakt_var_223 = [&]() -> ErrorOr<typechecker::StatementResult> { return TRY((((interpreter).execute_statement(checked_statement,((*this).root_interpreter_scope),utility::Span(((*this).file_id),static_cast<size_t>(0ULL),((line).length())))))); }();
if (__jakt_var_223.is_error()) {{
TRY((((*this).handle_possible_error())));
continue;
}
} else {__jakt_var_222 = __jakt_var_223.release_value();
}
__jakt_var_222.release_value(); });
if (TRY((((*this).handle_possible_error())))){
continue;
}
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<void>>{
auto&& __jakt_match_variant = result;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
{
if (((((value).impl))->index() == 0 /* Void */)){
return JaktInternal::LoopContinue{};
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
{
if (((((value).impl))->index() == 0 /* Void */)){
return JaktInternal::LoopContinue{};
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
{
if (((((value).impl))->index() == 0 /* Void */)){
return JaktInternal::LoopContinue{};
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const String output = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<void>>{
auto&& __jakt_match_variant = result;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Return>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((repl::serialize_ast_node(TRY((((value).to_checked_expression(interpreter))))))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::JustValue>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((repl::serialize_ast_node(TRY((((value).to_checked_expression(interpreter))))))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Throw>();
typechecker::Value const& value = __jakt_match_value.value;
return JaktInternal::ExplicitValue((String("throw ") + TRY((repl::serialize_ast_node(TRY((((value).to_checked_expression(interpreter)))))))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Break>();
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::StatementResult::Continue>();
{
return JaktInternal::LoopContinue{};
}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
outln(String("= {}"),output);
}
else {
break;
}

}
}
return {};
}

ErrorOr<bool> repl::REPL::handle_possible_error() {
{
TRY((((((*this).compiler))->print_errors())));
const bool has_error = (((((((*this).compiler))->errors)).size()) > static_cast<size_t>(0ULL));
const Array<error::JaktError> arr = (TRY((Array<error::JaktError>::create_with({}))));
(((((*this).compiler))->errors) = arr);
return (has_error);
}
}

}
namespace ide {
namespace Mutability_Details {
struct DoesNotApply {};
struct Immutable {};
struct Mutable {};
}
struct Mutability : public Variant<Mutability_Details::DoesNotApply, Mutability_Details::Immutable, Mutability_Details::Mutable> {
using Variant<Mutability_Details::DoesNotApply, Mutability_Details::Immutable, Mutability_Details::Mutable>::Variant;
    using DoesNotApply = Mutability_Details::DoesNotApply;
    using Immutable = Mutability_Details::Immutable;
    using Mutable = Mutability_Details::Mutable;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* DoesNotApply */: {
[[maybe_unused]] auto const& that = this->template get<Mutability::DoesNotApply>();
TRY(builder.append("Mutability::DoesNotApply"));
break;}
case 1 /* Immutable */: {
[[maybe_unused]] auto const& that = this->template get<Mutability::Immutable>();
TRY(builder.append("Mutability::Immutable"));
break;}
case 2 /* Mutable */: {
[[maybe_unused]] auto const& that = this->template get<Mutability::Mutable>();
TRY(builder.append("Mutability::Mutable"));
break;}
}
return builder.to_string();
}};
namespace VarType_Details {
struct Variable {};
struct Field {};
}
struct VarType : public Variant<VarType_Details::Variable, VarType_Details::Field> {
using Variant<VarType_Details::Variable, VarType_Details::Field>::Variant;
    using Variable = VarType_Details::Variable;
    using Field = VarType_Details::Field;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Variable */: {
[[maybe_unused]] auto const& that = this->template get<VarType::Variable>();
TRY(builder.append("VarType::Variable"));
break;}
case 1 /* Field */: {
[[maybe_unused]] auto const& that = this->template get<VarType::Field>();
TRY(builder.append("VarType::Field"));
break;}
}
return builder.to_string();
}};
namespace VarVisibility_Details {
struct DoesNotApply {};
struct Public {};
struct Private {};
struct Restricted {};
}
struct VarVisibility : public Variant<VarVisibility_Details::DoesNotApply, VarVisibility_Details::Public, VarVisibility_Details::Private, VarVisibility_Details::Restricted> {
using Variant<VarVisibility_Details::DoesNotApply, VarVisibility_Details::Public, VarVisibility_Details::Private, VarVisibility_Details::Restricted>::Variant;
    using DoesNotApply = VarVisibility_Details::DoesNotApply;
    using Public = VarVisibility_Details::Public;
    using Private = VarVisibility_Details::Private;
    using Restricted = VarVisibility_Details::Restricted;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* DoesNotApply */: {
[[maybe_unused]] auto const& that = this->template get<VarVisibility::DoesNotApply>();
TRY(builder.append("VarVisibility::DoesNotApply"));
break;}
case 1 /* Public */: {
[[maybe_unused]] auto const& that = this->template get<VarVisibility::Public>();
TRY(builder.append("VarVisibility::Public"));
break;}
case 2 /* Private */: {
[[maybe_unused]] auto const& that = this->template get<VarVisibility::Private>();
TRY(builder.append("VarVisibility::Private"));
break;}
case 3 /* Restricted */: {
[[maybe_unused]] auto const& that = this->template get<VarVisibility::Restricted>();
TRY(builder.append("VarVisibility::Restricted"));
break;}
}
return builder.to_string();
}};
namespace Usage_Details {
struct Variable {
utility::Span span;
String name;
typechecker::TypeId type_id;
ide::Mutability mutability;
ide::VarType var_type;
ide::VarVisibility visibility;
Optional<typechecker::TypeId> struct_type_id;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4, typename _MemberT5, typename _MemberT6>
Variable(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4, _MemberT5&& member_5, _MemberT6&& member_6):
span{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
mutability{ forward<_MemberT3>(member_3)},
var_type{ forward<_MemberT4>(member_4)},
visibility{ forward<_MemberT5>(member_5)},
struct_type_id{ forward<_MemberT6>(member_6)}
{}
};
struct Call{
typechecker::FunctionId value;
template<typename... Args>
Call(Args&&... args): value { forward<Args>(args)... } {}
};
struct Typename{
typechecker::TypeId value;
template<typename... Args>
Typename(Args&&... args): value { forward<Args>(args)... } {}
};
struct NameSet{
Array<String> value;
template<typename... Args>
NameSet(Args&&... args): value { forward<Args>(args)... } {}
};
struct EnumVariant {
utility::Span span;
String name;
typechecker::TypeId type_id;
Array<Tuple<Optional<String>,typechecker::TypeId>> variants;
Optional<typechecker::NumberConstant> number_constant;
template<typename _MemberT0, typename _MemberT1, typename _MemberT2, typename _MemberT3, typename _MemberT4>
EnumVariant(_MemberT0&& member_0, _MemberT1&& member_1, _MemberT2&& member_2, _MemberT3&& member_3, _MemberT4&& member_4):
span{ forward<_MemberT0>(member_0)},
name{ forward<_MemberT1>(member_1)},
type_id{ forward<_MemberT2>(member_2)},
variants{ forward<_MemberT3>(member_3)},
number_constant{ forward<_MemberT4>(member_4)}
{}
};
}
struct Usage : public Variant<Usage_Details::Variable, Usage_Details::Call, Usage_Details::Typename, Usage_Details::NameSet, Usage_Details::EnumVariant> {
using Variant<Usage_Details::Variable, Usage_Details::Call, Usage_Details::Typename, Usage_Details::NameSet, Usage_Details::EnumVariant>::Variant;
    using Variable = Usage_Details::Variable;
    using Call = Usage_Details::Call;
    using Typename = Usage_Details::Typename;
    using NameSet = Usage_Details::NameSet;
    using EnumVariant = Usage_Details::EnumVariant;
ErrorOr<String> debug_description() const {
auto builder = TRY(StringBuilder::create());
switch (this->index()) {case 0 /* Variable */: {
[[maybe_unused]] auto const& that = this->template get<Usage::Variable>();
TRY(builder.append("Usage::Variable"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("mutability: {}", that.mutability));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("var_type: {}", that.var_type));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("visibility: {}", that.visibility));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("struct_type_id: {}", that.struct_type_id));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
case 1 /* Call */: {
[[maybe_unused]] auto const& that = this->template get<Usage::Call>();
TRY(builder.append("Usage::Call"));
TRY(builder.appendff("({})", that.value));
break;}
case 2 /* Typename */: {
[[maybe_unused]] auto const& that = this->template get<Usage::Typename>();
TRY(builder.append("Usage::Typename"));
TRY(builder.appendff("({})", that.value));
break;}
case 3 /* NameSet */: {
[[maybe_unused]] auto const& that = this->template get<Usage::NameSet>();
TRY(builder.append("Usage::NameSet"));
TRY(builder.appendff("({})", that.value));
break;}
case 4 /* EnumVariant */: {
[[maybe_unused]] auto const& that = this->template get<Usage::EnumVariant>();
TRY(builder.append("Usage::EnumVariant"));
TRY(builder.append("("));
JaktInternal::_pretty_print_level++;
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("span: {}", that.span));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("name: \"{}\"", that.name));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("type_id: {}", that.type_id));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("variants: {}", that.variants));
TRY(builder.append(", "));
TRY(JaktInternal::_output_pretty_indent(builder));
TRY(builder.appendff("number_constant: {}", that.number_constant));
JaktInternal::_pretty_print_level--;
TRY(builder.append(")"));
break;}
}
return builder.to_string();
}};
static ErrorOr<ide::Usage> get_enum_variant_usage_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const String name) {
{
{
ArrayIterator<typechecker::CheckedEnum> _magic = ((((((program)->get_module(((type_id).module))))->enums)).iterator());
for (;;){
Optional<typechecker::CheckedEnum> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnum enum_ = (_magic_value.value());
{
if ((!(((((enum_).type_id)).equals(type_id))))){
continue;
}
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
if ((((variant).name()) == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> variants = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> number_constant = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::NumberConstant>, ErrorOr<ide::Usage>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(((expr)->to_number_constant(program)));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
};/*case end*/
}/*switch end*/
}()
));
const utility::Span span = ((variant).span());
return (typename ide::Usage::EnumVariant(span,name,type_id,variants,number_constant));
}
}

}
}

utility::panic(String("unreachable: should have found variant"));
}

}
}

utility::panic(String("unreachable: should have found enum"));
}
}

static ErrorOr<Array<String>> completions_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id) {
{
Array<String> output = (TRY((Array<String>::create_with({}))));
const NonnullRefPtr<typechecker::Type> ty = ((program)->get_type(type_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = *ty;
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
{
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((enum_).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
{
const typechecker::CheckedStruct structure = ((program)->get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((program)->get_variable(field));
TRY((((output).push(((field_var).name)))));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((structure).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
{
const typechecker::CheckedStruct structure = ((program)->get_struct(struct_id));
{
ArrayIterator<typechecker::VarId> _magic = ((((structure).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable field_var = ((program)->get_variable(field));
TRY((((output).push(((field_var).name)))));
}

}
}

const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((structure).scope_id)))));
{
ArrayIterator<String> _magic = ((TRY((((((scope)->functions)).keys())))).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String function_name = (_magic_value.value());
{
const typechecker::FunctionId function_id = (((((scope)->functions)).get(function_name)).value());
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
if (((((((checked_function)->params)).first())).has_value())){
const typechecker::CheckedParameter param = (((((checked_function)->params)).first()).value());
if ((((((param).variable)).name) == String("this"))){
String full_call = ((checked_function)->name);
bool first = true;
(full_call += String("("));
ArrayIterator<typechecker::CheckedParameter> iter = ((((checked_function)->params)).iterator());
const Optional<typechecker::CheckedParameter> dummy = ((iter).next());
{
ArrayIterator<typechecker::CheckedParameter> _magic = iter;
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if ((!(first))){
(full_call += String(", "));
}
else {
(first = false);
}

(full_call += ((((param).variable)).name));
}

}
}

(full_call += String(")"));
TRY((((output).push(full_call))));
}
}
else {
TRY((((output).push(TRY((String::formatted(String("{}()"),((checked_function)->name))))))));
}

}

}
}

}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
return (output);
}
}

static ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>> enum_variant_fields(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedEnumVariant checked_enum_variant) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<Tuple<Optional<String>,typechecker::TypeId>>, ErrorOr<Array<Tuple<Optional<String>,typechecker::TypeId>>>>{
auto&& __jakt_match_variant = checked_enum_variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
return JaktInternal::ExplicitValue(({ Optional<Array<Tuple<Optional<String>,typechecker::TypeId>>> __jakt_var_224; {
Array<Tuple<Optional<String>,typechecker::TypeId>> output = (TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({}))));
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((program)->get_variable(field));
const Optional<String> var_name = (((variable).name));
const Tuple<Optional<String>,typechecker::TypeId> o = (Tuple{var_name, ((variable).type_id)});
TRY((((output).push(o))));
}

}
}

__jakt_var_224 = output; goto __jakt_label_211;

}
__jakt_label_211:; __jakt_var_224.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Array<Tuple<Optional<String>,typechecker::TypeId>>> __jakt_var_225; {
const Optional<String> string_none = JaktInternal::OptionalNone();
__jakt_var_225 = (TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({(Tuple{string_none, type_id})})))); goto __jakt_label_212;

}
__jakt_label_212:; __jakt_var_225.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
)));
}
}

static ErrorOr<String> get_enum_variant_signature_from_type_id_and_name(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const String name) {
{
const NonnullRefPtr<typechecker::Module> mod = ((((program)->modules))[((((type_id).module)).id)]);
{
ArrayIterator<typechecker::CheckedEnum> _magic = ((((mod)->enums)).iterator());
for (;;){
Optional<typechecker::CheckedEnum> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnum enum_ = (_magic_value.value());
{
if (((((enum_).type_id)).equals(type_id))){
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<typechecker::NumberConstant>, ErrorOr<String>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(({ Optional<Optional<typechecker::NumberConstant>> __jakt_var_226; {
__jakt_var_226 = ((expr)->to_number_constant(program)); goto __jakt_label_213;

}
__jakt_label_213:; __jakt_var_226.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Optional<typechecker::NumberConstant>> __jakt_var_227; {
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
__jakt_var_227 = none; goto __jakt_label_214;

}
__jakt_label_214:; __jakt_var_227.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,value))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& v_name = __jakt_match_value.name;
{
if ((v_name == name)){
const Array<Tuple<Optional<String>,typechecker::TypeId>> params = TRY((ide::enum_variant_fields(program,variant)));
const Optional<typechecker::NumberConstant> none = JaktInternal::OptionalNone();
return (TRY((ide::get_enum_variant_signature(program,name,type_id,params,none))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

}
}

}
}

return (String(""));
}
}

static ErrorOr<String> get_type_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id) {
{
const typechecker::StructId array_struct_id = TRY((((program)->find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((program)->find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((program)->find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((program)->find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((program)->find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((program)->find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((program)->find_struct_in_prelude(String("WeakPtr")))));
const NonnullRefPtr<typechecker::Type> type = ((program)->get_type(type_id));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = *type;
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(String("never"));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(String("void"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(String("bool"));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(String("u8"));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(String("u16"));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(String("u32"));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(String("u64"));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(String("i8"));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(String("i16"));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(String("i32"));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(String("i64"));
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(String("f32"));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(String("f64"));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(String("usize"));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(String("String"));
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(String("c_int"));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(String("c_char"));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
String const& name = __jakt_match_value.value;
return JaktInternal::ExplicitValue(name);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();Array<typechecker::TypeId> const& params = __jakt_match_value.params;
typechecker::TypeId const& return_type_id = __jakt_match_value.return_type_id;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_228; {
Array<String> param_names = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<typechecker::TypeId> _magic = ((params).iterator());
for (;;){
Optional<typechecker::TypeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::TypeId x = (_magic_value.value());
{
TRY((((param_names).push(TRY((((program)->type_name(x))))))));
}

}
}

const String return_type = TRY((((program)->type_name(return_type_id))));
__jakt_var_228 = TRY((String::formatted(String("function({}) -> {}"),utility::join(param_names,String(", ")),return_type))); goto __jakt_label_215;

}
__jakt_label_215:; __jakt_var_228.release_value(); }));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue((String("raw ") + TRY((ide::get_type_signature(program,type_id)))));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_229; {
const typechecker::CheckedEnum enum_ = ((program)->get_enum(id));
__jakt_var_229 = ((JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((enum_).is_boxed));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("boxed "));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
 + String("enum ")) + ((enum_).name)); goto __jakt_label_216;

}
__jakt_label_216:; __jakt_var_229.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_230; {
const typechecker::CheckedStruct struct_ = ((program)->get_struct(id));
__jakt_var_230 = (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((struct_).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
default: {
{
utility::panic(String("unreachable: should've been struct"));
}
};/*case end*/
}/*switch end*/
}()
)) + ((struct_).name)); goto __jakt_label_217;

}
__jakt_label_217:; __jakt_var_230.release_value(); }));
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_231; {
const typechecker::CheckedStruct record = ((program)->get_struct(id));
String output = ((record).name);
(output += String("<"));
if ((!(((args).is_empty())))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_231 = (output + String(">")); goto __jakt_label_218;

}
__jakt_label_218:; __jakt_var_231.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_232; {
const typechecker::CheckedEnum enum_ = ((program)->get_enum(id));
String output = String("");
if (((enum_).is_boxed)){
(output += String("boxed "));
}
(output += String("enum "));
(output += ((enum_).name));
(output += String("<"));
if ((!(((args).is_empty())))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_232 = (output + String(">")); goto __jakt_label_219;

}
__jakt_label_219:; __jakt_var_232.release_value(); }));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_233; {
if (((id).equals(array_struct_id))){
if (((args).is_empty())){
return (String("[]"));
}
return (TRY((String::formatted(String("[{}]"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(dictionary_struct_id))){
if ((((args).size()) < static_cast<size_t>(2ULL))){
return (String("[:]"));
}
return (TRY((String::formatted(String("[{}: {}]"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(1LL)]))))))));
}
if (((id).equals(optional_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{}?"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(range_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{}..{}"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))),TRY((((program)->type_name(((args)[static_cast<i64>(0LL)])))))))));
}
if (((id).equals(set_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("{{{}}}"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
if (((id).equals(tuple_struct_id))){
String output = String("(");
if ((!(((args).is_empty())))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
return ((output + String(")")));
}
if (((id).equals(weak_ptr_struct_id))){
if (((args).is_empty())){
return (String(""));
}
return (TRY((String::formatted(String("weak {}?"),TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)]))))))));
}
const typechecker::CheckedStruct record = ((program)->get_struct(id));
String output = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = ((record).record_type);
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Class>();return JaktInternal::ExplicitValue(String("class "));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::Struct>();return JaktInternal::ExplicitValue(String("struct "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::ValueEnum>();{
utility::panic(String("unreachable: can't be an enum"));
}
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::RecordType::SumEnum>();{
utility::panic(String("unreachable: can't be an enum"));
}
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::RecordType::Garbage>();
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
(output += ((record).name));
(output += String("<"));
if ((!(((args).is_empty())))){
(output += TRY((ide::get_type_signature(program,((args)[static_cast<i64>(0LL)])))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(1ULL)),static_cast<size_t>(((args).size()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
(output += String(", "));
(output += TRY((ide::get_type_signature(program,((args)[i])))));
}

}
}

}
__jakt_var_233 = (output + String(">")); goto __jakt_label_220;

}
__jakt_label_220:; __jakt_var_233.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&{}"),TRY((((program)->type_name(type_id))))))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((String::formatted(String("&mut {}"),TRY((((program)->type_name(type_id))))))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_scope(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::Scope> scope,const utility::Span span) {
{
{
DictionaryIterator<String,typechecker::VarId> _magic = ((((scope)->vars)).iterator());
for (;;){
Optional<Tuple<String,typechecker::VarId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::VarId> scope_var = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(((scope_var).get<1>())));
if (((((var).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((var).type_id))));
}
}

}
}

{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> function_id = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(((function_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_function(program,checked_function,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
DictionaryIterator<String,typechecker::StructId> _magic = ((((scope)->structs)).iterator());
for (;;){
Optional<Tuple<String,typechecker::StructId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::StructId> struct_id = (_magic_value.value());
{
const typechecker::CheckedStruct checked_struct = ((program)->get_struct(((struct_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_struct(program,checked_struct,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
DictionaryIterator<String,typechecker::EnumId> _magic = ((((scope)->enums)).iterator());
for (;;){
Optional<Tuple<String,typechecker::EnumId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::EnumId> enum_id = (_magic_value.value());
{
const typechecker::CheckedEnum checked_enum = ((program)->get_enum(((enum_id).get<1>())));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_enum(program,checked_enum,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

{
ArrayIterator<typechecker::ScopeId> _magic = ((((scope)->children)).iterator());
for (;;){
Optional<typechecker::ScopeId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::ScopeId child = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(child))));
const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
if (((usage).has_value())){
return ((usage.value()));
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<String> get_constructor_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::FunctionId function_id) {
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
const typechecker::TypeId type_id = ((checked_function)->return_type_id);
const NonnullRefPtr<typechecker::Module> mod = ((((program)->modules))[((((type_id).module)).id)]);
{
ArrayIterator<typechecker::CheckedStruct> _magic = ((((mod)->structures)).iterator());
for (;;){
Optional<typechecker::CheckedStruct> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedStruct struct_ = (_magic_value.value());
{
if (((((struct_).type_id)).equals(type_id))){
String output = TRY((ide::get_type_signature(program,type_id)));
(output += String("("));
bool first = true;
{
ArrayIterator<typechecker::VarId> _magic = ((((struct_).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(", "));
}

const typechecker::CheckedVariable variable = ((program)->get_variable(field));
if (((variable).is_mutable)){
(output += String("mut "));
}
(output += TRY((String::formatted(String("{}: {}"),((variable).name),TRY((((program)->type_name(((variable).type_id)))))))));
}

}
}

(output += String(")"));
return (output);
}
}

}
}

return (String(""));
}
}

static ErrorOr<Array<String>> find_dot_completions(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<String>, ErrorOr<Array<String>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Array<String>> __jakt_var_234; {
__jakt_var_234 = TRY((ide::completions_for_type_id(program,type_id))); goto __jakt_label_221;

}
__jakt_label_221:; __jakt_var_234.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Array<String>> __jakt_var_235; {
const typechecker::TypeId result_type_id = ((((program)->get_function(function_id)))->return_type_id);
__jakt_var_235 = TRY((ide::completions_for_type_id(program,result_type_id))); goto __jakt_label_222;

}
__jakt_label_222:; __jakt_var_235.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue((TRY((Array<String>::create_with({})))));
};/*case end*/
}/*switch end*/
}()
)));
}
else {
return ((TRY((Array<String>::create_with({})))));
}

}
}

static ErrorOr<utility::Span> find_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_function(function_id)))->name_span));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (span);
}

}
}

static ErrorOr<String> get_var_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const String name,const typechecker::TypeId var_type_id,const ide::Mutability mutability,const ide::VarType var_type,const ide::VarVisibility visibility,const Optional<typechecker::TypeId> struct_type_id) {
{
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = var_type;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarType::Variable>();
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_236; {
const String mut_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = mutability;
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Mutability::Mutable>();
return JaktInternal::ExplicitValue(String("mut"));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Mutability::Immutable>();
return JaktInternal::ExplicitValue(String("let"));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = TRY((ide::get_type_signature(program,var_type_id)));
__jakt_var_236 = TRY((String::formatted(String("{} {}: {}"),mut_string,name,type_name))); goto __jakt_label_223;

}
__jakt_label_223:; __jakt_var_236.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarType::Field>();
{
String record_string = String("");
if (((struct_type_id).has_value())){
(record_string = TRY((ide::get_type_signature(program,(struct_type_id.value())))));
}
const String visibility_string = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = visibility;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarVisibility::Public>();
return JaktInternal::ExplicitValue(String("public "));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::VarVisibility::Private>();
return JaktInternal::ExplicitValue(String("private "));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(String(""));
};/*case end*/
}/*switch end*/
}()
));
const String type_name = TRY((ide::get_type_signature(program,var_type_id)));
if ((record_string != String(""))){
return (TRY((String::formatted(String("{}\\n\\t{}{}: {}"),record_string,visibility_string,name,type_name))));
}
else {
return (TRY((String::formatted(String("{}{}: {}"),visibility_string,name,type_name))));
}

}
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_expression(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedExpression> expr,const utility::Span span) {
{
const Optional<ide::Usage> none = JaktInternal::OptionalNone();
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *expr;
switch(__jakt_match_variant.index()) {
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::BinaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& lhs = __jakt_match_value.lhs;
parser::BinaryOperator const& op = __jakt_match_value.op;
NonnullRefPtr<typechecker::CheckedExpression> const& rhs = __jakt_match_value.rhs;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_237; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,lhs,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_237 = TRY((ide::find_span_in_expression(program,rhs,span))); goto __jakt_label_224;

}
__jakt_label_224:; __jakt_var_237.release_value(); }));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktArray>();Array<NonnullRefPtr<typechecker::CheckedExpression>> const& vals = __jakt_match_value.vals;
Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& repeat = __jakt_match_value.repeat;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_238; {
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedExpression>> _magic = ((vals).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedExpression>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedExpression> val = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,val,span)));
if (((found).has_value())){
return (found);
}
}

}
}

if (((repeat).has_value())){
return (TRY((ide::find_span_in_expression(program,(repeat.value()),span))));
}
__jakt_var_238 = none; goto __jakt_label_225;

}
__jakt_label_225:; __jakt_var_238.release_value(); }));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Call>();typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& call_span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_239; {
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,((arg).get<1>()),span)));
if (((found).has_value())){
return (found);
}
}

}
}

if ((((((call).function_id)).has_value()) && ((call_span).contains(span)))){
return ((typename ide::Usage::Call((((call).function_id).value()))));
}
__jakt_var_239 = none; goto __jakt_label_226;

}
__jakt_label_226:; __jakt_var_239.release_value(); }));
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::JaktDictionary>();Array<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> const& vals = __jakt_match_value.vals;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_240; {
{
ArrayIterator<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((vals).iterator());
for (;;){
Optional<Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<NonnullRefPtr<typechecker::CheckedExpression>,NonnullRefPtr<typechecker::CheckedExpression>> item = (_magic_value.value());
{
const NonnullRefPtr<typechecker::CheckedExpression> key = ((item).get<0>());
const NonnullRefPtr<typechecker::CheckedExpression> value = ((item).get<1>());
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,key,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_expression(program,value,span))));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_240 = none; goto __jakt_label_227;

}
__jakt_label_227:; __jakt_var_240.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedExpression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_241; {
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_expression(program,index,span))));
if (((found).has_value())){
return (found);
}
__jakt_var_241 = none; goto __jakt_label_228;

}
__jakt_label_228:; __jakt_var_241.release_value(); }));
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedStruct>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
String const& index = __jakt_match_value.index;
utility::Span const& index_span = __jakt_match_value.span;
typechecker::TypeId const& known_type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_242; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
if (((index_span).contains(span))){
const typechecker::TypeId type_id = typechecker::expression_type(expr);
Optional<typechecker::TypeId> result_type = JaktInternal::OptionalNone();
if ((!(((known_type_id).equals(typechecker::unknown_type_id()))))){
(result_type = (known_type_id));
}
if (((((program)->get_type(type_id)))->index() == 22 /* Struct */)){
const typechecker::StructId struct_id = (((program)->get_type(type_id))->get<typechecker::Type::Struct>()).value;
{
ArrayIterator<typechecker::VarId> _magic = ((((((program)->get_struct(struct_id))).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(field));
if ((index != ((var).name))){
continue;
}
return (typename ide::Usage::Variable(((var).definition_span),index,result_type.value_or_lazy_evaluated([&] { return ((var).type_id); }),typename ide::Mutability::DoesNotApply(),typename ide::VarType::Field(),JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::VarVisibility, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = ((var).visibility);
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Public>();
return JaktInternal::ExplicitValue(typename ide::VarVisibility::Public());
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::Visibility::Private>();
return JaktInternal::ExplicitValue(typename ide::VarVisibility::Private());
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<parser::Visibility::Restricted>();return JaktInternal::ExplicitValue(typename ide::VarVisibility::Restricted());
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)),type_id));
}

}
}

}
}
__jakt_var_242 = none; goto __jakt_label_229;

}
__jakt_label_229:; __jakt_var_242.release_value(); }));
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::IndexedDictionary>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
NonnullRefPtr<typechecker::CheckedExpression> const& index = __jakt_match_value.index;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_243; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_243 = TRY((ide::find_span_in_expression(program,index,span))); goto __jakt_label_230;

}
__jakt_label_230:; __jakt_var_243.release_value(); }));
};/*case end*/
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Match>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Array<typechecker::CheckedMatchCase> const& match_cases = __jakt_match_value.match_cases;
utility::Span const& match_span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_244; {
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase match_case = (_magic_value.value());
{
const Optional<ide::Usage> found = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = match_case;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::EnumVariant>();String const& name = __jakt_match_value.name;
Array<parser::EnumVariantPatternArgument> const& args = __jakt_match_value.args;
typechecker::TypeId const& subject_type_id = __jakt_match_value.subject_type_id;
size_t const& index = __jakt_match_value.index;
typechecker::ScopeId const& scope_id = __jakt_match_value.scope_id;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_245; {
if (((marker_span).contains(span))){
return ((TRY((ide::get_enum_variant_usage_from_type_id_and_name(program,subject_type_id,name)))));
}
__jakt_var_245 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_232;

}
__jakt_label_232:; __jakt_var_245.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expression;
typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_246; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_246 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)); goto __jakt_label_233;

}
__jakt_label_233:; __jakt_var_246.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedMatchCase::CatchAll>();typechecker::CheckedMatchBody const& body = __jakt_match_value.body;
utility::Span const& marker_span = __jakt_match_value.marker_span;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((marker_span).contains(span)));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_247; {
const Set<String> all_cases = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Set<String>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *((program)->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& enum_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_248; {
Set<String> names = (TRY((Set<String>::create_with_values({}))));
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((names).add(((variant).name())))));
}

}
}

__jakt_var_248 = names; goto __jakt_label_235;

}
__jakt_label_235:; __jakt_var_248.release_value(); }));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& enum_id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_249; {
Set<String> names = (TRY((Set<String>::create_with_values({}))));
const typechecker::CheckedEnum enum_ = ((program)->get_enum(enum_id));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((enum_).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
TRY((((names).add(((variant).name())))));
}

}
}

__jakt_var_249 = names; goto __jakt_label_236;

}
__jakt_label_236:; __jakt_var_249.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(({ Optional<Set<String>> __jakt_var_250; {
__jakt_var_250 = (TRY((Set<String>::create_with_values({String("else (expression)")})))); goto __jakt_label_237;

}
__jakt_label_237:; __jakt_var_250.release_value(); }));
};/*case end*/
}/*switch end*/
}()
));
Set<String> remaining_cases = all_cases;
{
ArrayIterator<typechecker::CheckedMatchCase> _magic = ((match_cases).iterator());
for (;;){
Optional<typechecker::CheckedMatchCase> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedMatchCase other_case = (_magic_value.value());
{
if (((other_case).index() == 0 /* EnumVariant */)){
const String name = (other_case.get<typechecker::CheckedMatchCase::EnumVariant>()).name;
((remaining_cases).remove(name));
}
}

}
}

__jakt_var_247 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((remaining_cases).is_empty()));
if (__jakt_enum_value == false) {
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_251; {
Array<String> cases_array = (TRY((Array<String>::create_with({}))));
TRY((((cases_array).ensure_capacity(((remaining_cases).size())))));
{
SetIterator<String> _magic = ((remaining_cases).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
TRY((((cases_array).push(name))));
}

}
}

__jakt_var_251 = (typename ide::Usage::NameSet(cases_array)); goto __jakt_label_238;

}
__jakt_label_238:; __jakt_var_251.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(JaktInternal::OptionalNone());
}
}()))
; goto __jakt_label_234;

}
__jakt_label_234:; __jakt_var_247.release_value(); }));
}
else {
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = body;
switch(__jakt_match_variant.index()) {
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Block>();
typechecker::CheckedBlock const& block = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedMatchBody::Expression>();
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}()))
);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_244 = TRY((ide::find_span_in_expression(program,expr,span))); goto __jakt_label_231;

}
__jakt_label_231:; __jakt_var_244.release_value(); }));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::ForcedUnwrap>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::UnaryOp>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::MethodCall>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
typechecker::CheckedCall const& call = __jakt_match_value.call;
utility::Span const& method_span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
{
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
{
ArrayIterator<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic = ((((call).args)).iterator());
for (;;){
Optional<Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,NonnullRefPtr<typechecker::CheckedExpression>> arg = (_magic_value.value());
{
(found = TRY((ide::find_span_in_expression(program,((arg).get<1>()),span))));
if (((found).has_value())){
return (found);
}
}

}
}

if ((((((call).function_id)).has_value()) && ((method_span).contains(span)))){
return ((typename ide::Usage::Call((((call).function_id).value()))));
}
return (none);
}
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Var>();typechecker::CheckedVariable const& var = __jakt_match_value.var;
utility::Span const& var_span = __jakt_match_value.span;
{
const Optional<typechecker::TypeId> none_type_id = JaktInternal::OptionalNone();
if (((var_span).contains(span))){
const ide::Mutability mutability = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::Mutability,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((var).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename ide::Mutability::Mutable());
}
else {
return JaktInternal::ExplicitValue(typename ide::Mutability::Immutable());
}
}()))
;
return ((typename ide::Usage::Variable(((var).definition_span),((var).name),((var).type_id),mutability,typename ide::VarType::Variable(),typename ide::VarVisibility::DoesNotApply(),none_type_id)));
}
return (none);
}
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::NamespacedVar>();Array<typechecker::CheckedNamespace> const& namespaces = __jakt_match_value.namespaces;
typechecker::CheckedVariable const& var = __jakt_match_value.var;
utility::Span const& var_span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_252; {
if ((((var_span).contains(span)) && (!(((namespaces).is_empty()))))){
const typechecker::CheckedNamespace last_ns = (((namespaces).last()).value());
if (((((TRY((((program)->get_scope(((last_ns).scope))))))->namespace_name)).has_value())){
const Optional<typechecker::EnumId> enum_id = TRY((((program)->find_enum_in_scope(((last_ns).scope),((last_ns).name)))));
if (((enum_id).has_value())){
const typechecker::CheckedEnum enum_ = ((program)->get_enum((enum_id.value())));
return ((TRY((ide::get_enum_variant_usage_from_type_id_and_name(program,((enum_).type_id),((var).name))))));
}
}
}
__jakt_var_252 = none; goto __jakt_label_239;

}
__jakt_label_239:; __jakt_var_252.release_value(); }));
};/*case end*/
case 29: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::TryBlock>();NonnullRefPtr<typechecker::CheckedStatement> const& stmt = __jakt_match_value.stmt;
String const& error_name = __jakt_match_value.error_name;
typechecker::CheckedBlock const& catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_253; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,stmt,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_253 = TRY((ide::find_span_in_block(program,catch_block,span))); goto __jakt_label_240;

}
__jakt_label_240:; __jakt_var_253.release_value(); }));
};/*case end*/
case 28: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedExpression::Try>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
Optional<typechecker::CheckedBlock> const& catch_block = __jakt_match_value.catch_block;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_254; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,expr,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_254 = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((catch_block).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,(catch_block.value()),span))));
}
else {
return JaktInternal::ExplicitValue(none);
}
}()))
; goto __jakt_label_241;

}
__jakt_label_241:; __jakt_var_254.release_value(); }));
};/*case end*/
default: {
return JaktInternal::ExplicitValue(none);
};/*case end*/
}/*switch end*/
}()
)));
}
}

static ErrorOr<utility::Span> find_type_definition_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();utility::Span const& span = __jakt_match_value.span;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_255; {
__jakt_var_255 = TRY((ide::find_type_definition_for_type_id(program,type_id,span))); goto __jakt_label_242;

}
__jakt_label_242:; __jakt_var_255.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_256; {
__jakt_var_256 = ((((program)->get_function(function_id)))->name_span); goto __jakt_label_243;

}
__jakt_label_243:; __jakt_var_256.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_257; {
__jakt_var_257 = TRY((ide::find_type_definition_for_type_id(program,type_id,span))); goto __jakt_label_244;

}
__jakt_label_244:; __jakt_var_257.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();utility::Span const& span = __jakt_match_value.span;
return JaktInternal::ExplicitValue(span);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (span);
}

}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_block(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedBlock block,const utility::Span span) {
{
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((((block).statements)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> statement = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,statement,span)));
if (((found).has_value())){
return (found);
}
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> iterator = ((((program)->modules)).iterator());
const Optional<NonnullRefPtr<typechecker::Module>> dummy = ((iterator).next());
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = iterator;
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(typechecker::ScopeId(((module)->id),static_cast<size_t>(0ULL))))));
return (TRY((ide::find_span_in_scope(program,scope,span))));
}

}
}

return (JaktInternal::OptionalNone());
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_function(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedFunction> checked_function,const utility::Span span) {
{
if (((((checked_function)->return_type_span)).has_value())){
if ((((((checked_function)->return_type_span).value())).contains(span))){
return ((typename ide::Usage::Typename(((checked_function)->return_type_id))));
}
}
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
if (((((((param).variable)).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((((param).variable)).type_id))));
}
}

}
}

return (TRY((ide::find_span_in_block(program,((checked_function)->block),span))));
}
}

static ErrorOr<Optional<String>> find_typename_in_program(const NonnullRefPtr<typechecker::CheckedProgram> program,const utility::Span span) {
{
const Optional<ide::Usage> result = TRY((ide::find_span_in_program(program,span)));
if (((result).has_value())){
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<String>, ErrorOr<Optional<String>>>{
auto&& __jakt_match_variant = (result.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::Variable>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
ide::Mutability const& mutability = __jakt_match_value.mutability;
ide::VarType const& var_type = __jakt_match_value.var_type;
ide::VarVisibility const& visibility = __jakt_match_value.visibility;
Optional<typechecker::TypeId> const& struct_type_id = __jakt_match_value.struct_type_id;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_258; {
const String result = TRY((ide::get_var_signature(program,name,type_id,mutability,var_type,visibility,struct_type_id)));
__jakt_var_258 = (result); goto __jakt_label_245;

}
__jakt_label_245:; __jakt_var_258.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Call>();
typechecker::FunctionId const& function_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_259; {
const String result = TRY((ide::get_function_signature(program,function_id)));
__jakt_var_259 = (result); goto __jakt_label_246;

}
__jakt_label_246:; __jakt_var_259.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::Typename>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_260; {
const String result = TRY((ide::get_type_signature(program,type_id)));
__jakt_var_260 = (result); goto __jakt_label_247;

}
__jakt_label_247:; __jakt_var_260.release_value(); }));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename ide::Usage::NameSet>();
Array<String> const& names = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_261; {
String output = String("");
bool first = true;
{
ArrayIterator<String> _magic = ((names).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String name = (_magic_value.value());
{
if ((!(first))){
(output += String(" | "));
}
else {
(first = false);
}

(output += name);
}

}
}

__jakt_var_261 = (output); goto __jakt_label_248;

}
__jakt_label_248:; __jakt_var_261.release_value(); }));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<ide::Usage::EnumVariant>();String const& name = __jakt_match_value.name;
typechecker::TypeId const& type_id = __jakt_match_value.type_id;
Array<Tuple<Optional<String>,typechecker::TypeId>> const& variants = __jakt_match_value.variants;
Optional<typechecker::NumberConstant> const& number_constant = __jakt_match_value.number_constant;
return JaktInternal::ExplicitValue(({ Optional<Optional<String>> __jakt_var_262; {
const String result = TRY((ide::get_enum_variant_signature(program,name,type_id,variants,number_constant)));
__jakt_var_262 = (result); goto __jakt_label_249;

}
__jakt_label_249:; __jakt_var_262.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
else {
return (JaktInternal::OptionalNone());
}

}
}

static ErrorOr<utility::Span> find_type_definition_for_type_id(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::TypeId type_id,const utility::Span span) {
{
const typechecker::StructId array_struct_id = TRY((((program)->find_struct_in_prelude(String("Array")))));
const typechecker::StructId dictionary_struct_id = TRY((((program)->find_struct_in_prelude(String("Dictionary")))));
const typechecker::StructId optional_struct_id = TRY((((program)->find_struct_in_prelude(String("Optional")))));
const typechecker::StructId range_struct_id = TRY((((program)->find_struct_in_prelude(String("Range")))));
const typechecker::StructId set_struct_id = TRY((((program)->find_struct_in_prelude(String("Set")))));
const typechecker::StructId tuple_struct_id = TRY((((program)->find_struct_in_prelude(String("Tuple")))));
const typechecker::StructId weak_ptr_struct_id = TRY((((program)->find_struct_in_prelude(String("WeakPtr")))));
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<utility::Span, ErrorOr<utility::Span>>{
auto&& __jakt_match_variant = *((program)->get_type(type_id));
switch(__jakt_match_variant.index()) {
case 17: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Never>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::F64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I8>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I16>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::I64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U8>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U16>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U32>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::U64>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Usize>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CChar>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::CInt>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Bool>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Void>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 16: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Unknown>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::JaktString>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 27: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::Function>();return JaktInternal::ExplicitValue(span);
};/*case end*/
case 19: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericInstance>();typechecker::StructId const& struct_id = __jakt_match_value.id;
Array<typechecker::TypeId> const& args = __jakt_match_value.args;
return JaktInternal::ExplicitValue(({ Optional<utility::Span> __jakt_var_263; {
utility::Span output = span;
if ((((((((struct_id).equals(array_struct_id)) || ((struct_id).equals(optional_struct_id))) || ((struct_id).equals(range_struct_id))) || ((struct_id).equals(set_struct_id))) || ((struct_id).equals(tuple_struct_id))) || ((struct_id).equals(weak_ptr_struct_id)))){
(output = TRY((ide::find_type_definition_for_type_id(program,((args)[static_cast<i64>(0LL)]),span))));
}
else if (((struct_id).equals(dictionary_struct_id))){
(output = TRY((ide::find_type_definition_for_type_id(program,((args)[static_cast<i64>(1LL)]),span))));
}
else {
(output = ((((program)->get_struct(struct_id))).name_span));
}

__jakt_var_263 = output; goto __jakt_label_250;

}
__jakt_label_250:; __jakt_var_263.release_value(); }));
};/*case end*/
case 22: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Struct>();
typechecker::StructId const& struct_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_struct(struct_id))).name_span));
};/*case end*/
case 20: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericEnumInstance>();typechecker::EnumId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((program)->get_enum(id))).name_span));
};/*case end*/
case 23: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Enum>();
typechecker::EnumId const& id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(((((program)->get_enum(id))).name_span));
};/*case end*/
case 24: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::RawPtr>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 18: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::TypeVariable>();
return JaktInternal::ExplicitValue(span);
};/*case end*/
case 21: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::Type::GenericResolvedType>();typechecker::StructId const& id = __jakt_match_value.id;
return JaktInternal::ExplicitValue(((((program)->get_struct(id))).name_span));
};/*case end*/
case 25: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::Reference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
case 26: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::Type::MutableReference>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(TRY((ide::find_type_definition_for_type_id(program,type_id,span))));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<String> get_enum_variant_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const String name,const typechecker::TypeId type_id,const Array<Tuple<Optional<String>,typechecker::TypeId>> variants,const Optional<typechecker::NumberConstant> number_constant) {
{
String output = TRY((ide::get_type_signature(program,type_id)));
(output += String("::"));
(output += name);
if ((!(((variants).is_empty())))){
(output += String("("));
bool first = true;
{
ArrayIterator<Tuple<Optional<String>,typechecker::TypeId>> _magic = ((variants).iterator());
for (;;){
Optional<Tuple<Optional<String>,typechecker::TypeId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<Optional<String>,typechecker::TypeId> variant = (_magic_value.value());
{
if (first){
(first = false);
}
else {
(output += String(", "));
}

if (((((variant).get<0>())).has_value())){
(output += (((variant).get<0>()).value()));
(output += String(": "));
}
(output += TRY((((program)->type_name(((variant).get<1>()))))));
}

}
}

(output += String(")"));
}
if (((number_constant).has_value())){
(output += String(" = "));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = (number_constant.value());
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Signed>();
i64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Unsigned>();
u64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::NumberConstant::Floating>();
f64 const& value = __jakt_match_value.value;
{
(output += TRY((String::formatted(String("{}"),value))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
return (output);
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_enum(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedEnum checked_enum,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((checked_enum).scope_id)))));
{
ArrayIterator<typechecker::CheckedEnumVariant> _magic = ((((checked_enum).variants)).iterator());
for (;;){
Optional<typechecker::CheckedEnumVariant> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedEnumVariant variant = (_magic_value.value());
{
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = variant;
switch(__jakt_match_variant.index()) {
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::StructLike>();String const& name = __jakt_match_value.name;
Array<typechecker::VarId> const& fields = __jakt_match_value.fields;
utility::Span const& variant_span = __jakt_match_value.span;
{
{
ArrayIterator<typechecker::VarId> _magic = ((fields).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable var = ((program)->get_variable(field));
if (((((var).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((var).type_id))));
}
}

}
}

if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(span,name,((checked_enum).type_id),(TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))),JaktInternal::OptionalNone())));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Typed>();String const& name = __jakt_match_value.name;
utility::Span const& variant_span = __jakt_match_value.span;
{
if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),TRY((ide::enum_variant_fields(program,variant))),JaktInternal::OptionalNone())));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::Untyped>();String const& name = __jakt_match_value.name;
utility::Span const& variant_span = __jakt_match_value.span;
{
if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),(TRY((Array<Tuple<Optional<String>,typechecker::TypeId>>::create_with({})))),JaktInternal::OptionalNone())));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedEnumVariant::WithValue>();String const& name = __jakt_match_value.name;
NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
utility::Span const& variant_span = __jakt_match_value.span;
{
if (((variant_span).contains(span))){
return ((typename ide::Usage::EnumVariant(variant_span,name,((checked_enum).type_id),TRY((ide::enum_variant_fields(program,variant))),((expr)->to_number_constant(program)))));
}
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}

}
}

const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
return (usage);
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_statement(const NonnullRefPtr<typechecker::CheckedProgram> program,const NonnullRefPtr<typechecker::CheckedStatement> statement,const utility::Span span) {
{
const Optional<ide::Usage> none = JaktInternal::OptionalNone();
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>, ErrorOr<Optional<ide::Usage>>>{
auto&& __jakt_match_variant = *statement;
switch(__jakt_match_variant.index()) {
case 5: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Block>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Defer>();NonnullRefPtr<typechecker::CheckedStatement> const& statement = __jakt_match_value.statement;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_statement(program,statement,span))));
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Expression>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 4: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::If>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& then_block = __jakt_match_value.then_block;
Optional<NonnullRefPtr<typechecker::CheckedStatement>> const& else_statement = __jakt_match_value.else_statement;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_264; {
Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,condition,span)));
if (((found).has_value())){
return (found);
}
(found = TRY((ide::find_span_in_block(program,then_block,span))));
if (((found).has_value())){
return (found);
}
if (((else_statement).has_value())){
return (TRY((ide::find_span_in_statement(program,(else_statement.value()),span))));
}
__jakt_var_264 = none; goto __jakt_label_251;

}
__jakt_label_251:; __jakt_var_264.release_value(); }));
};/*case end*/
case 13: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::InlineCpp>();return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_265; {
const Optional<ide::Usage> output = JaktInternal::OptionalNone();
__jakt_var_265 = output; goto __jakt_label_252;

}
__jakt_label_252:; __jakt_var_265.release_value(); }));
};/*case end*/
case 6: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Loop>();typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_block(program,block,span))));
};/*case end*/
case 8: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Return>();Optional<NonnullRefPtr<typechecker::CheckedExpression>> const& val = __jakt_match_value.val;
return JaktInternal::ExplicitValue(JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Optional<ide::Usage>,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((val).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,(val.value()),span))));
}
else {
return JaktInternal::ExplicitValue(none);
}
}()))
);
};/*case end*/
case 11: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Throw>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 3: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::VarDecl>();typechecker::VarId const& var_id = __jakt_match_value.var_id;
NonnullRefPtr<typechecker::CheckedExpression> const& init = __jakt_match_value.init;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_266; {
const typechecker::CheckedVariable checked_var = ((program)->get_variable(var_id));
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,init,span)));
if (((found).has_value())){
return (found);
}
if (((((checked_var).type_span)).has_value())){
const utility::Span type_span = (((checked_var).type_span).value());
if (((type_span).contains(span))){
return ((typename ide::Usage::Typename(((checked_var).type_id))));
}
}
if (((((checked_var).definition_span)).contains(span))){
const ide::Mutability mutability = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<ide::Mutability,ErrorOr<Optional<ide::Usage>>>{
auto __jakt_enum_value = (((checked_var).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(typename ide::Mutability::Mutable());
}
else {
return JaktInternal::ExplicitValue(typename ide::Mutability::Immutable());
}
}()))
;
return ((typename ide::Usage::Variable(((checked_var).definition_span),((checked_var).name),((checked_var).type_id),mutability,typename ide::VarType::Variable(),typename ide::VarVisibility::DoesNotApply(),JaktInternal::OptionalNone())));
}
__jakt_var_266 = none; goto __jakt_label_253;

}
__jakt_label_253:; __jakt_var_266.release_value(); }));
};/*case end*/
case 7: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::While>();NonnullRefPtr<typechecker::CheckedExpression> const& condition = __jakt_match_value.condition;
typechecker::CheckedBlock const& block = __jakt_match_value.block;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_267; {
const Optional<ide::Usage> found = TRY((ide::find_span_in_expression(program,condition,span)));
if (((found).has_value())){
return (found);
}
__jakt_var_267 = TRY((ide::find_span_in_block(program,block,span))); goto __jakt_label_254;

}
__jakt_label_254:; __jakt_var_267.release_value(); }));
};/*case end*/
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::DestructuringAssignment>();Array<NonnullRefPtr<typechecker::CheckedStatement>> const& vars = __jakt_match_value.vars;
NonnullRefPtr<typechecker::CheckedStatement> const& var_decl = __jakt_match_value.var_decl;
return JaktInternal::ExplicitValue(({ Optional<Optional<ide::Usage>> __jakt_var_268; {
{
ArrayIterator<NonnullRefPtr<typechecker::CheckedStatement>> _magic = ((vars).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::CheckedStatement>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::CheckedStatement> var = (_magic_value.value());
{
const Optional<ide::Usage> found = TRY((ide::find_span_in_statement(program,var,span)));
if (((found).has_value())){
return (found);
}
}

}
}

__jakt_var_268 = TRY((ide::find_span_in_statement(program,var_decl,span))); goto __jakt_label_255;

}
__jakt_label_255:; __jakt_var_268.release_value(); }));
};/*case end*/
case 12: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typechecker::CheckedStatement::Yield>();NonnullRefPtr<typechecker::CheckedExpression> const& expr = __jakt_match_value.expr;
return JaktInternal::ExplicitValue(TRY((ide::find_span_in_expression(program,expr,span))));
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Break>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
case 10: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Continue>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
case 14: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::CheckedStatement::Garbage>();
return JaktInternal::ExplicitValue(none);
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
)));
}
}

static ErrorOr<Optional<ide::Usage>> find_span_in_struct(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::CheckedStruct checked_struct,const utility::Span span) {
{
const NonnullRefPtr<typechecker::Scope> scope = TRY((((program)->get_scope(((checked_struct).scope_id)))));
{
ArrayIterator<typechecker::VarId> _magic = ((((checked_struct).fields)).iterator());
for (;;){
Optional<typechecker::VarId> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::VarId field = (_magic_value.value());
{
const typechecker::CheckedVariable variable = ((program)->get_variable(field));
if (((((variable).definition_span)).contains(span))){
return ((typename ide::Usage::Typename(((variable).type_id))));
}
}

}
}

const Optional<ide::Usage> usage = TRY((ide::find_span_in_scope(program,scope,span)));
return (usage);
}
}

static ErrorOr<String> get_function_signature(const NonnullRefPtr<typechecker::CheckedProgram> program,const typechecker::FunctionId function_id) {
{
const NonnullRefPtr<typechecker::CheckedFunction> checked_function = ((program)->get_function(function_id));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<String>>{
auto&& __jakt_match_variant = ((checked_function)->type);
switch(__jakt_match_variant.index()) {
case 2: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::ImplicitEnumConstructor>();
{
const typechecker::TypeId type_id = ((checked_function)->return_type_id);
const String name = ((checked_function)->name);
return (TRY((ide::get_enum_variant_signature_from_type_id_and_name(program,type_id,name))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename parser::FunctionType::ImplicitConstructor>();
{
return (TRY((ide::get_constructor_signature(program,function_id))));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
));
String generic_parameters = String("");
bool is_first_param = true;
if ((!(((((checked_function)->generic_params)).is_empty())))){
(generic_parameters += String("<"));
{
ArrayIterator<typechecker::FunctionGenericParameter> _magic = ((((checked_function)->generic_params)).iterator());
for (;;){
Optional<typechecker::FunctionGenericParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::FunctionGenericParameter parameter = (_magic_value.value());
{
const String generic_type = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String, ErrorOr<String>>{
auto&& __jakt_match_variant = parameter;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::InferenceGuide>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_269; {
__jakt_var_269 = TRY((((program)->type_name(type_id)))); goto __jakt_label_256;

}
__jakt_label_256:; __jakt_var_269.release_value(); }));
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::FunctionGenericParameter::Parameter>();
typechecker::TypeId const& type_id = __jakt_match_value.value;
return JaktInternal::ExplicitValue(({ Optional<String> __jakt_var_270; {
__jakt_var_270 = TRY((((program)->type_name(type_id)))); goto __jakt_label_257;

}
__jakt_label_257:; __jakt_var_270.release_value(); }));
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
const String separator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_first_param);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String(", "));
}
}()))
;
(generic_parameters += TRY((String::formatted(String("{}{}"),separator,generic_type))));
(is_first_param = false);
}

}
}

(generic_parameters += String(">"));
}
String parameters = String("");
(is_first_param = true);
{
ArrayIterator<typechecker::CheckedParameter> _magic = ((((checked_function)->params)).iterator());
for (;;){
Optional<typechecker::CheckedParameter> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
typechecker::CheckedParameter param = (_magic_value.value());
{
const String anon_value = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((param).requires_label));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String("anon "));
}
}()))
;
const String is_mutable = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((((param).variable)).is_mutable));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String("mut "));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
String variable_type = TRY((((program)->type_name(((((param).variable)).type_id)))));
if ((variable_type != String("void"))){
(variable_type = (String(": ") + variable_type));
}
else {
(variable_type = String(""));
}

const String separator = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (is_first_param);
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(""));
}
else {
return JaktInternal::ExplicitValue(String(", "));
}
}()))
;
(parameters += TRY((String::formatted(String("{}{}{}{}{}"),separator,anon_value,is_mutable,((((param).variable)).name),variable_type))));
(is_first_param = false);
}

}
}

const String throws_str = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<String,ErrorOr<String>>{
auto __jakt_enum_value = (((checked_function)->can_throw));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(String(" throws"));
}
else {
return JaktInternal::ExplicitValue(String(""));
}
}()))
;
String returns = TRY((((program)->type_name(((checked_function)->return_type_id)))));
if ((returns != String("void"))){
(returns = (String(" -> ") + returns));
}
else {
(returns = String(""));
}

return (TRY((String::formatted(String("function {}{}({}){}{}"),((checked_function)->name),generic_parameters,parameters,throws_str,returns))));
}
}

}
static ErrorOr<void> write_to_file(const String data,const String output_filename) {
{
NonnullRefPtr<File> outfile = TRY((File::open_for_writing(output_filename)));
Array<u8> bytes = (TRY((Array<u8>::create_with({}))));
{
Range<size_t> _magic = (Range<size_t>{static_cast<size_t>(static_cast<size_t>(0ULL)),static_cast<size_t>(((data).length()))});
for (;;){
Optional<size_t> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
size_t i = (_magic_value.value());
{
TRY((((bytes).push(((data).byte_at(i))))));
}

}
}

TRY((((outfile)->write(bytes))));
}
return {};
}

ErrorOr<int> main(const Array<String> args) {
{
if ((((args).size()) <= static_cast<size_t>(1ULL))){
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
utility::ArgsParser args_parser = TRY((utility::ArgsParser::from_args(args)));
if (TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-h"), String("--help")}))))))))){
outln(String("{}\n"),usage());
outln(String("{}"),help());
return (static_cast<i64>(0LL));
}
if (TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-v"), String("--version")}))))))))){
outln(String("unreleased"));
return (static_cast<i64>(0LL));
}
const bool optimize = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-O")}))))))));
const bool lexer_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dl")}))))))));
const bool parser_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dp")}))))))));
const bool typechecker_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-dt")}))))))));
const bool build_executable = (!(TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-S")}))))))))));
const bool run_executable = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-cr"), String("--compile-run")}))))))));
const bool codegen_debug = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-d")}))))))));
const bool debug_print = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--debug-print")}))))))));
const bool prettify_cpp_source = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--prettify-cpp-source")}))))))));
const bool json_errors = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-j"), String("--json-errors")}))))))));
const bool dump_type_hints = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-H"), String("--type-hints")}))))))));
const bool dump_try_hints = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--try-hints")}))))))));
const bool check_only = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-c"), String("--check-only")}))))))));
const bool write_source_to_file = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-S"), String("--emit-cpp-source-only")}))))))));
const String clang_format_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-F"), String("--clang-format-path")})))))))).value_or_lazy_evaluated([&] { return String("clang-format"); });
const String runtime_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-R"), String("--runtime-path")})))))))).value_or_lazy_evaluated([&] { return String("runtime"); });
const String binary_dir = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-B"), String("--binary-dir")})))))))).value_or_lazy_evaluated([&] { return String("build"); });
const Optional<String> dot_clang_format_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-D"), String("--dot-clang-format-path")}))))))));
const String cxx_compiler_path = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-C"), String("--cxx-compiler-path")})))))))).value_or_lazy_evaluated([&] { return String("clang++"); });
const Array<String> extra_include_paths = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-I")}))))))));
const Array<String> extra_lib_paths = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-L")}))))))));
const Array<String> extra_link_libs = TRY((((args_parser).option_multiple((TRY((Array<String>::create_with({String("-l")}))))))));
const Optional<String> set_output_filename = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-o"), String("--output-filename")}))))))));
const Optional<String> goto_def = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-g"), String("--goto-def")}))))))));
const Optional<String> goto_type_def = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-t"), String("--goto-type-def")}))))))));
const Optional<String> hover = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-e"), String("--hover")}))))))));
const Optional<String> completions = TRY((((args_parser).option((TRY((Array<String>::create_with({String("-m"), String("--completions")}))))))));
const bool interpret_run = TRY((((args_parser).flag((TRY((Array<String>::create_with({String("-r"), String("--run")}))))))));
if (TRY((((args_parser).flag((TRY((Array<String>::create_with({String("--repl")}))))))))){
repl::REPL repl = TRY((repl::REPL::create()));
TRY((((repl).run())));
return (static_cast<i64>(0LL));
}
const Array<String> positional_arguments = TRY((((args_parser).remaining_arguments())));
Optional<String> file_name = JaktInternal::OptionalNone();
bool first_arg = true;
Array<String> interpreted_main_arguments = (TRY((Array<String>::create_with({}))));
{
ArrayIterator<String> _magic = ((positional_arguments).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String arg = (_magic_value.value());
{
if (first_arg){
(first_arg = false);
continue;
}
if ((!(((file_name).has_value())))){
(file_name = arg);
continue;
}
if ((!(interpret_run))){
warnln(String("you can only pass one source file"));
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
TRY((((interpreted_main_arguments).push(arg))));
}

}
}

if ((!(((file_name).has_value())))){
warnln(String("you must pass a source file"));
warnln(String("{}"),usage());
return (static_cast<i64>(1LL));
}
const NonnullRefPtr<utility::FilePath> file_path = TRY((utility::FilePath::make((file_name.value()))));
Array<error::JaktError> errors = (TRY((Array<error::JaktError>::create_with({}))));
NonnullRefPtr<compiler::Compiler> compiler = TRY((compiler::Compiler::create((TRY((Array<NonnullRefPtr<utility::FilePath>>::create_with({})))),(TRY((Dictionary<String, utility::FileId>::create_with_entries({})))),(TRY((Array<error::JaktError>::create_with({})))),JaktInternal::OptionalNone(),(TRY((Array<u8>::create_with({})))),lexer_debug,parser_debug,false,debug_print,extra_include_paths,json_errors,dump_type_hints,dump_try_hints)));
TRY((((compiler)->load_prelude())));
const utility::FileId main_file_id = TRY((((compiler)->get_file_id_or_register(file_path))));
const bool file_is_set = ((compiler)->set_current_file(main_file_id));
if ((!(file_is_set))){
return (static_cast<i64>(1LL));
}
const Array<lexer::Token> tokens = TRY((lexer::Lexer::lex(compiler)));
if (lexer_debug){
{
ArrayIterator<lexer::Token> _magic = ((tokens).iterator());
for (;;){
Optional<lexer::Token> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
lexer::Token token = (_magic_value.value());
{
outln(String("token: {}"),token);
}

}
}

}
const parser::ParsedNamespace parsed_namespace = TRY((parser::Parser::parse(compiler,tokens)));
if (parser_debug){
outln(String("{:#}"),parsed_namespace);
}
const NonnullRefPtr<typechecker::CheckedProgram> checked_program = TRY((typechecker::Typechecker::typecheck(compiler,parsed_namespace)));
if (interpret_run){
typechecker::Interpreter interpreter = typechecker::Interpreter(compiler,checked_program,(TRY((Array<utility::Span>::create_with({})))));
const typechecker::ScopeId prelude_scope_id = typechecker::ScopeId(typechecker::ModuleId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL));
Optional<typechecker::FunctionId> main_function_id = JaktInternal::OptionalNone();
{
ArrayIterator<NonnullRefPtr<typechecker::Module>> _magic = ((((checked_program)->modules)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Module>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Module> module = (_magic_value.value());
{
{
ArrayIterator<NonnullRefPtr<typechecker::Scope>> _magic = ((((module)->scopes)).iterator());
for (;;){
Optional<NonnullRefPtr<typechecker::Scope>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
NonnullRefPtr<typechecker::Scope> scope = (_magic_value.value());
{
if ((!(((((scope)->parent)).map([&](auto& _value) { return _value.equals(prelude_scope_id); })).value_or_lazy_evaluated([&] { return false; })))){
continue;
}
{
DictionaryIterator<String,typechecker::FunctionId> _magic = ((((scope)->functions)).iterator());
for (;;){
Optional<Tuple<String,typechecker::FunctionId>> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
Tuple<String,typechecker::FunctionId> function_ = (_magic_value.value());
{
if ((((function_).get<0>()) == String("main"))){
(main_function_id = ((function_).get<1>()));
break;
}
}

}
}

if (((main_function_id).has_value())){
break;
}
}

}
}

if (((main_function_id).has_value())){
break;
}
}

}
}

if ((!(((main_function_id).has_value())))){
warnln(String("Error: No main function found in program"));
return (static_cast<i64>(1LL));
}
const Array<typechecker::ResolvedNamespace> namespace_ = (TRY((Array<typechecker::ResolvedNamespace>::create_with({}))));
const utility::Span call_span = utility::Span(utility::FileId(static_cast<size_t>(0ULL)),static_cast<size_t>(0ULL),static_cast<size_t>(0ULL));
const Optional<typechecker::CheckedParameter> first_main_param = ((((((checked_program)->get_function((main_function_id.value()))))->params)).first());
const Array<typechecker::Value> arguments = JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<Array<typechecker::Value>,ErrorOr<int>>{
auto __jakt_enum_value = (((first_main_param).has_value()));
if (__jakt_enum_value == true) {
return JaktInternal::ExplicitValue(({ Optional<Array<typechecker::Value>> __jakt_var_271; {
Array<typechecker::Value> passed_arguments = (TRY((Array<typechecker::Value>::create_with({}))));
{
ArrayIterator<String> _magic = ((interpreted_main_arguments).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String argument = (_magic_value.value());
{
TRY((((passed_arguments).push(typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktString>(argument))),call_span)))));
}

}
}

__jakt_var_271 = (TRY((Array<typechecker::Value>::create_with({typechecker::Value(TRY((typechecker::ValueImpl::template create<typename typechecker::ValueImpl::JaktArray>(passed_arguments,(((((first_main_param.value())).variable)).type_id)))),call_span)})))); goto __jakt_label_258;

}
__jakt_label_258:; __jakt_var_271.release_value(); }));
}
else {
return JaktInternal::ExplicitValue((TRY((Array<typechecker::Value>::create_with({})))));
}
}()))
;
const typechecker::ExecutionResult main_result = TRY((((interpreter).execute((main_function_id.value()),namespace_,JaktInternal::OptionalNone(),arguments,call_span))));
JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<int>>{
auto&& __jakt_match_variant = main_result;
switch(__jakt_match_variant.index()) {
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Return>();
typechecker::Value const& x = __jakt_match_value.value;
return (JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY(([&]() -> JaktInternal::ExplicitValueOrControlFlow<void, ErrorOr<int>>{
auto&& __jakt_match_variant = *((x).impl);
switch(__jakt_match_variant.index()) {
case 15: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::CInt>();
int const& ret_val = __jakt_match_value.value;
{
return (ret_val);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 9: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::I64>();
i64 const& ret_val = __jakt_match_value.value;
{
return (ret_val);
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
case 0: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ValueImpl::Void>();
{
return (static_cast<i64>(0LL));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: {
{
warnln(String("Error: Main function must return an integer"));
return (static_cast<i64>(1LL));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
}/*switch end*/
}()
))), JaktInternal::ExplicitValue<void>();
};/*case end*/
case 1: {
auto&& __jakt_match_value = __jakt_match_variant.template get<typename typechecker::ExecutionResult::Throw>();
typechecker::Value const& x = __jakt_match_value.value;
{
warnln(String("Error: Main function threw: {}"),TRY((repl::serialize_ast_node(TRY((((x).to_checked_expression(interpreter))))))));
return (static_cast<i64>(1LL));
}
return JaktInternal::ExplicitValue<void>();
};/*case end*/
default: VERIFY_NOT_REACHED();}/*switch end*/
}()
));
}
if (((goto_def).has_value())){
const size_t index = (infallible_integer_cast<size_t>((((((goto_def.value())).to_uint()).value()))));
const utility::Span result = TRY((ide::find_definition_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if ((((((result).file_id)).id) == static_cast<size_t>(1ULL))){
outln(String("{{\"start\": {}, \"end\": {}}}"),((result).start),((result).end));
}
else {
const Optional<NonnullRefPtr<utility::FilePath>> file_path = TRY((((compiler)->get_file_path(((result).file_id)))));
outln(String("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}"),((result).start),((result).end),(((file_path.value()))->path));
}

return (static_cast<i64>(0LL));
}
if (((goto_type_def).has_value())){
const size_t index = (infallible_integer_cast<size_t>((((((goto_type_def.value())).to_uint()).value()))));
const utility::Span result = TRY((ide::find_type_definition_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if ((((((result).file_id)).id) == static_cast<size_t>(1ULL))){
outln(String("{{\"start\": {}, \"end\": {}}}"),((result).start),((result).end));
}
else {
const Optional<NonnullRefPtr<utility::FilePath>> file_path = TRY((((compiler)->get_file_path(((result).file_id)))));
outln(String("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}"),((result).start),((result).end),(((file_path.value()))->path));
}

return (static_cast<i64>(0LL));
}
if (((hover).has_value())){
const size_t index = (infallible_integer_cast<size_t>((((((hover.value())).to_uint()).value()))));
const Optional<String> result = TRY((ide::find_typename_in_program(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
if (((result).has_value())){
outln(String("{{\"hover\": \"{}\"}}"),(result.value()));
}
return (static_cast<i64>(0LL));
}
if (((completions).has_value())){
const size_t index = (infallible_integer_cast<size_t>((((((completions.value())).to_uint()).value()))));
const Array<String> result = TRY((ide::find_dot_completions(checked_program,utility::Span(utility::FileId(static_cast<size_t>(1ULL)),index,index))));
out(String("{{\"completions\": ["));
bool first = true;
{
ArrayIterator<String> _magic = ((result).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String completion = (_magic_value.value());
{
if ((!(first))){
out(String(", "));
}
else {
(first = false);
}

out(String("\"{}\""),completion);
}

}
}

outln(String("]}}"));
return (static_cast<i64>(0LL));
}
if (typechecker_debug){
outln(String("{:#}"),checked_program);
}
TRY((((compiler)->print_errors())));
if ((!(((((compiler)->errors)).is_empty())))){
return (static_cast<i64>(1LL));
}
if (check_only){
return (static_cast<i64>(0LL));
}
const String output = TRY((codegen::CodeGenerator::generate(compiler,checked_program,codegen_debug)));
String cpp_filename = String("");
String output_filename = String("");
if (((write_source_to_file || build_executable) || run_executable)){
if (((set_output_filename).has_value())){
(cpp_filename = (((binary_dir + String("/")) + (set_output_filename.value())) + String(".cpp")));
(output_filename = ((binary_dir + String("/")) + (set_output_filename.value())));
}
else {
const String basename_without_extension = TRY((((TRY((((file_path)->basename())))).substring(static_cast<size_t>(0ULL),(JaktInternal::checked_sub<size_t>(((TRY((((file_path)->basename())))).length()),static_cast<size_t>(5ULL)))))));
(cpp_filename = (((binary_dir + String("/")) + basename_without_extension) + String(".cpp")));
(output_filename = ((binary_dir + String("/")) + basename_without_extension));
}

auto __jakt_var_272 = [&]() -> ErrorOr<void> {{
TRY((write_to_file(output,cpp_filename)));
}

;return {};}();
if (__jakt_var_272.is_error()) {auto error = __jakt_var_272.release_error();{
warnln(String("Could not write file: {} ({})"),cpp_filename,error);
return (((error).code()));
}
};
if (prettify_cpp_source){
String command = ((clang_format_path + String(" -i ")) + cpp_filename);
if (((dot_clang_format_path).has_value())){
(command += (String(" --style=file:") + (dot_clang_format_path.value())));
}
system(((command).c_string()));
}
}
else {
outln(String("{}"),output);
}

if ((build_executable || run_executable)){
const int compiler_status = TRY((run_compiler(cxx_compiler_path,cpp_filename,output_filename,runtime_path,extra_include_paths,extra_lib_paths,extra_link_libs,optimize)));
if ((run_executable && (compiler_status == static_cast<int>(0)))){
system(((output_filename).c_string()));
}
}
}
return 0;
}

static ErrorOr<int> run_compiler(const String cxx_compiler_path,const String cpp_filename,const String output_filename,const String runtime_path,const Array<String> extra_include_paths,const Array<String> extra_lib_paths,const Array<String> extra_link_libs,const bool optimize) {
{
NonnullRefPtr<utility::FilePath> file_path = TRY((utility::FilePath::create(cxx_compiler_path)));
String color_flag = String("-fcolor-diagnostics");
Array<String> extra_flags = (TRY((Array<String>::create_with({}))));
if ((TRY((((file_path)->basename()))) == String("g++"))){
(color_flag = String("-fdiagnostics-color=always"));
TRY((((extra_flags).push(String("-Wno-literal-suffix")))));
}
Array<String> compile_args = (TRY((Array<String>::create_with({cxx_compiler_path, color_flag, String("-std=c++20"), String("-fno-exceptions"), String("-Wno-unknown-warning-option"), String("-Wno-trigraphs"), String("-Wno-parentheses-equality"), String("-Wno-unqualified-std-cast-call"), String("-Wno-user-defined-literals"), String("-Wno-deprecated-declarations")}))));
if (optimize){
TRY((((compile_args).push(String("-O3")))));
}
if ((!(((extra_flags).is_empty())))){
{
ArrayIterator<String> _magic = ((extra_flags).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String flag = (_magic_value.value());
{
TRY((((compile_args).push(flag))));
}

}
}

}
TRY((((compile_args).push(String("-I")))));
TRY((((compile_args).push(runtime_path))));
TRY((((compile_args).push(String("-o")))));
TRY((((compile_args).push(output_filename))));
TRY((((compile_args).push(cpp_filename))));
if ((!(((extra_include_paths).is_empty())))){
TRY((((compile_args).add_capacity((JaktInternal::checked_mul<size_t>(((extra_include_paths).size()),static_cast<size_t>(2ULL)))))));
{
ArrayIterator<String> _magic = ((extra_include_paths).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push(String("-I")))));
TRY((((compile_args).push(path))));
}

}
}

}
if ((!(((extra_lib_paths).is_empty())))){
TRY((((compile_args).add_capacity((JaktInternal::checked_mul<size_t>(((extra_lib_paths).size()),static_cast<size_t>(2ULL)))))));
{
ArrayIterator<String> _magic = ((extra_lib_paths).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push(String("-L")))));
TRY((((compile_args).push(path))));
}

}
}

}
if ((!(((extra_link_libs).is_empty())))){
TRY((((compile_args).add_capacity(((extra_link_libs).size())))));
{
ArrayIterator<String> _magic = ((extra_link_libs).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String path = (_magic_value.value());
{
TRY((((compile_args).push((String("-l") + path)))));
}

}
}

}
String command = String("");
{
ArrayIterator<String> _magic = ((compile_args).iterator());
for (;;){
Optional<String> _magic_value = ((_magic).next());
if ((!(((_magic_value).has_value())))){
break;
}
String compile_arg = (_magic_value.value());
{
(command += compile_arg);
(command += String(" "));
}

}
}

return (system(((command).c_string())));
}
}

static String usage() {
{
return (String("usage: jakt [-h] [OPTIONS] <filename>"));
}
}

static String help() {
{
String output = String("Flags:\n");
(output += String("  -h,--help\t\tPrint this help and exit.\n"));
(output += String("  -O\t\tBuild an optimized executable.\n"));
(output += String("  -dl\t\tPrint debug info for the lexer.\n"));
(output += String("  -dp\t\tPrint debug info for the parser.\n"));
(output += String("  -dt\t\tPrint debug info for the typechecker.\n"));
(output += String("  -S\t\tOnly output source (do not build).\n"));
(output += String("  -cr, --compile-run\t\tBuild and run an executable file.\n"));
(output += String("  -r, --run\t\tRun the given file without compiling it (all positional arguments after the file name will be passed to main).\n"));
(output += String("  -d\t\tInsert debug statement spans in generated C++ code.\n"));
(output += String("  --debug-print\t\tOutput debug print.\n"));
(output += String("  --prettify-cpp-source\t\tRun emitted C++ source through clang-format.\n"));
(output += String("  -S,--emit-cpp-source-only\t\tWrite the C++ source to file, even when not building/\n"));
(output += String("  -c,--check-only\t\tOnly check the code for errors.\n"));
(output += String("  -j,--json-errors\t\tEmit machine-readable (JSON) errors.\n"));
(output += String("  -H,--type-hints\t\tEmit machine-readable type hints (for IDE integration).\n"));
(output += String("  --try-hints\t\tEmit machine-readable try hints (for IDE integration).\n"));
(output += String("  --repl\t\tStart a Read-Eval-Print loop session.\n"));
(output += String("\nOptions:\n"));
(output += String("  -F,--clang-format-path PATH\t\tPath to clang-format executable.\n\t\tDefaults to clang-format\n"));
(output += String("  -D,--dot-clang-format-path PATH\t\tPath to the .clang-format file to use.\n\t\tDefaults to none, invoking clangs default .clang-format file handling.\n"));
(output += String("  -R,--runtime-path PATH\t\tPath of the Jakt runtime headers.\n\t\tDefaults to $PWD/runtime.\n"));
(output += String("  -B,--binary-dir PATH\t\tOutput directory for compiled files.\n\t\tDefaults to $PWD/build.\n"));
(output += String("  -C,--cxx-compiler-path PATH\t\tPath of the C++ compiler to use when compiling the generated sources.\n\t\tDefaults to clang++.\n"));
(output += String("  -I PATH\t\tAdd PATH to compiler's include list. Can be specified multiple times.\n"));
(output += String("  -L PATH\t\tAdd PATH to linker's search list. Can be specified multiple times.\n"));
(output += String("  -l,--link-with LIB\t\tLink executable with LIB. Can be specified multiple times.\n"));
(output += String("  -o,--output-filename FILE\t\tName of the output C++ file and binary.\n\t\tDefaults to the input-filename.\n"));
(output += String("  -g,--goto-def INDEX\t\tReturn the span for the definition at index.\n"));
(output += String("  -t,--goto-type-def INDEX\t\tReturn the span for the type definition at index.\n"));
(output += String("  -e,--hover INDEX                  Return the type of element at index.\n"));
(output += String("  -m,--completions INDEX            Return dot completions at index.\n"));
return (output);
}
}

template<>struct Formatter<utility::FileId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::FileId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::ArgsParser> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::ArgsParser const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::Span> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::Span const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<utility::FilePath> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, utility::FilePath const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<error::MessageSeverity> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, error::MessageSeverity const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<error::JaktError> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, error::JaktError const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<compiler::Compiler> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, compiler::Compiler const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::Lexer> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::Lexer const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::NumericConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::NumericConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::Token> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::Token const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<lexer::LiteralSuffix> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, lexer::LiteralSuffix const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::Visibility> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::Visibility const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedBlock> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedBlock const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::FunctionType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::FunctionType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::FunctionLinkage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::FunctionLinkage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedFunction> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedFunction const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedExternImport> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedExternImport const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedVarDecl> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedVarDecl const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedField> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedField const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::TypeCast> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::TypeCast const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::UnaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::UnaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedCall> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedCall const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::BinaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::BinaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::EnumVariantPatternArgument> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::EnumVariantPatternArgument const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedExpression> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedExpression const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ValueEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ValueEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMethod> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMethod const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::DefinitionLinkage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::DefinitionLinkage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ImportName> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ImportName const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedCapture> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedCapture const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedVariable> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedVariable const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::RecordType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::RecordType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedGenericParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedGenericParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::Parser> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::Parser const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchBody> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchBody const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchCase> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchCase const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedStatement> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedStatement const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedModuleImport> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedModuleImport const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedRecord> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedRecord const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::SumEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::SumEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<parser::ParsedMatchPattern> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, parser::ParsedMatchPattern const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ModuleId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ModuleId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ScopeId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ScopeId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::TypeId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::TypeId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnum> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnum const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnumVariantBinding> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnumVariantBinding const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::VarId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::VarId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::BlockControlFlow> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::BlockControlFlow const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedBlock> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedBlock const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedStatement> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedStatement const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::LoadedModule> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::LoadedModule const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::StructId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::StructId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::FunctionId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::FunctionId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::EnumId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::EnumId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Value> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Value const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ValueImpl> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ValueImpl const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedTypeCast> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedTypeCast const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedEnumVariant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedEnumVariant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedUnaryOperator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedUnaryOperator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ResolvedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ResolvedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::StructOrEnumId> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::StructOrEnumId const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedNamespace> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedNamespace const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedNumericConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedNumericConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedFunction> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedFunction const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::FunctionGenericParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::FunctionGenericParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::SafetyMode> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::SafetyMode const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedVarDecl> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedVarDecl const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedMatchBody> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedMatchBody const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedCapture> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedCapture const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::StatementResult> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::StatementResult const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedStruct> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedStruct const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedVariable> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedVariable const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::NumberConstant> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::NumberConstant const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedCall> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedCall const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedExpression> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedExpression const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedProgram> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedProgram const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Interpreter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Interpreter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Scope> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Scope const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Typechecker> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Typechecker const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Type> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Type const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::ExecutionResult> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::ExecutionResult const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedMatchCase> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedMatchCase const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::InterpreterScope> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::InterpreterScope const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::CheckedParameter> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::CheckedParameter const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<typechecker::Module> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, typechecker::Module const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::AllowedControlExits> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::AllowedControlExits const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::ControlFlowState> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::ControlFlowState const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::CodegenDebugInfo> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::CodegenDebugInfo const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::LineSpan> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::LineSpan const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<codegen::CodeGenerator> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, codegen::CodeGenerator const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<repl::Editor> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, repl::Editor const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<repl::LineResult> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, repl::LineResult const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<repl::REPL> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, repl::REPL const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::Mutability> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::Mutability const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::VarType> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::VarType const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::VarVisibility> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::VarVisibility const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
template<>struct Formatter<ide::Usage> : Formatter<StringView>{
ErrorOr<void> format(FormatBuilder& builder, ide::Usage const& value)
{ if (m_alternative_form) { JaktInternal::_pretty_print_enabled = true; }return Formatter<StringView>::format(builder, MUST(value.debug_description())); }};
} // namespace Jakt
