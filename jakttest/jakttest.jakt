import error { JaktError, print_error }
import lexer { Lexer }
import parser { Parser }

function usage() => "usage: jakttest [-h] [OPTIONS] <path>"

function compare_test(bytes: [u8], expected: String) throws -> bool {
    // first, build up the content to compare to
    mut builder = StringBuilder::create()
    for b in bytes.iterator() {
        builder.append(b)
    }

    let builder_output = builder.to_string()

    if builder_output != expected {
        eprintln("expected: {}", expected)
        eprintln("found:    {}", builder_output)
        return false
    }
    return true
}

function compare_error(bytes: [u8], expected: String) throws -> bool {
    // first, build up the content to compare to
    mut builder = StringBuilder::create()

    for b in bytes.iterator() {
        if b == 0xd {
            // skip
        } else if b == 0xa {
            builder.append(b'\\')
            builder.append(b'n')
        } else {
            builder.append(b)
        }
    }

    let builder_output = builder.to_string()
    let stripped_expected = strip_line_breaks(expected)

    if not builder_output.contains(stripped_expected) {
        eprintln("expected: {}", stripped_expected)
        eprintln("found:    {}", builder_output)
        return false
    }
    return true
}

function strip_line_breaks(anon input: String) throws -> String {
    mut builder = StringBuilder::create();
    for i in 0..input.length() {
        let b = input.byte_at(i)
        if b == b'\n' or b == b'\r' {
            continue
        }
        builder.append(b)
    }
    return builder.to_string()
}

function main(args: [String]) {
    if args.size() <= 1 {
        eprintln("{}", usage())
        return 1
    }

    let file_name = args[1];

    mut file = File::open_for_reading(file_name)
    let file_contents = file.read_all()

    mut errors: [JaktError] = []

    let tokens = Lexer::lex(input: file_contents, errors)

    let parsed_test = Parser::parse(tokens, errors);

    // Windows
    // system("del runtest.out runtest.err".c_string())

    // Unix
    system("rm -f runtest.out runtest.err".c_string())

    match parsed_test {
        SuccessTest(expected) => {

            build_and_run(file_name)

            mut build_and_run_output_file = File::open_for_reading("runtest.out")
            let build_and_run_output = build_and_run_output_file.read_all()

            let test_passes_output = compare_test(bytes: build_and_run_output, expected)

            if not (test_passes_output) {
                eprintln("Test failed: {}", file_name)
                return 1
            } else {
                println("Test passed: {}", file_name)
                return 0
            }
        }
        FailureTest(expected) => {

            build_and_run(file_name)

            mut build_and_run_error_file = File::open_for_reading("runtest.err")
            let build_and_run_output = build_and_run_error_file.read_all()

            let test_passes = compare_error(bytes: build_and_run_output, expected)

            if not test_passes {
                eprintln("Test failed: {}", file_name)
                return 1
            } else {
                println("Test passed: {}", file_name)
                return 0
            }

        }
        SkipTest => {
            println("Expected output/error not found. Test skipped")

            // Can't understand test, so we skip it
            return 2
        }
    }
}

function build_and_run(anon jakt_source_file: String) throws {
    mut compile_args = [
        "build/main"
        "-r"
    ]
    compile_args.push(jakt_source_file)
    compile_args.push(">")
    compile_args.push("runtest.out")
    compile_args.push("2>")
    compile_args.push("runtest.err")

    mut command = ""
    for compile_arg in compile_args.iterator() {
        command += compile_arg
        command += " "
    }
    
    system(command.c_string())
}

function write_to_file(file_contents: [u8], output_filename: String) throws {
    mut outfile = File::open_for_writing(output_filename)
    outfile.write(file_contents)
}
