import error { JaktError, print_error }
import lexer { Lexer }
import parser { Parser }

function usage() => "usage: jakttest [-h] [--selfhost-executable <path>] [OPTIONS] <path>"

function compare_test(bytes: [u8], expected: String) throws -> bool {
    // first, build up the content to compare to
    mut builder = StringBuilder::create()
    for b in bytes.iterator() {
        builder.append(b)
    }

    let builder_output = builder.to_string()

    if builder_output != expected {
        eprintln("expected: {}", expected)
        eprintln("found:    {}", builder_output)
        return false
    }
    return true
}

function compare_error(bytes: [u8], expected: String) throws -> bool {
    // first, build up the content to compare to
    mut builder = StringBuilder::create()

    for b in bytes.iterator() {
        if b == 0xd {
            // skip
        } else if b == 0xa {
            builder.append(b'\\')
            builder.append(b'n')
        } else {
            builder.append(b)
        }
    }

    let builder_output = builder.to_string()
    let stripped_expected = strip_line_breaks(expected)

    if not builder_output.contains(stripped_expected) {
        eprintln("expected: {}", stripped_expected)
        eprintln("found:    {}", builder_output)
        return false
    }
    return true
}

function strip_line_breaks(anon input: String) throws -> String {
    mut builder = StringBuilder::create();
    for i in 0..input.length() {
        let b = input.byte_at(i)
        if b == b'\n' or b == b'\r' {
            continue
        }
        builder.append(b)
    }
    return builder.to_string()
}

struct Options {
    file_name: String
    selfhost_executable: String
    errors: [String]
}



function parse_args(args: [String]) throws -> Options {
    let errors: [String] = []
    mut options = Options(file_name: "", selfhost_executable: "selfhost/build/main", errors)
    mut index = 1uz
    while index != args.size() {
        if args[index] == "--selfhost-executable" {
            index++
            if index == args.size() {
                options.errors.push("--selfhost-executable was given without a path")
            }
            options.selfhost_executable = args[index]
        } else {
            options.file_name = args[index]
        }
        index++
    }
    if options.file_name == "" {
        options.errors.push("No file was given")
    }
    return options
}

function main(args: [String]) {

    let options = parse_args(args)

    if not options.errors.is_empty() {
        for error in options.errors.iterator() {
            eprintln("Error: {}", error)
        }
        eprintln("{}", usage())
    }

    let file_name = options.file_name;
    let selfhost_executable = options.selfhost_executable;

    mut file = File::open_for_reading(file_name)
    let file_contents = file.read_all()

    mut errors: [JaktError] = []

    let tokens = Lexer::lex(input: file_contents, errors)

    let parsed_test = Parser::parse(tokens, errors);

    // Windows
    // system("del runtest.out runtest.err".c_string())

    // Unix
    system("rm -f runtest.out runtest.err".c_string())

    match parsed_test {
        SuccessTest(expected) => {

            build_and_run(file_name, selfhost_executable)

            mut build_and_run_output_file = File::open_for_reading("runtest.out")
            let build_and_run_output = build_and_run_output_file.read_all()

            let test_passes_output = compare_test(bytes: build_and_run_output, expected)

            if not (test_passes_output) {
                eprintln("Test failed: {}", file_name)
                return 1
            } else {
                println("Test passed: {}", file_name)
                return 0
            }
        }
        FailureTest(expected) => {

            build_and_run(file_name, selfhost_executable)

            mut build_and_run_error_file = File::open_for_reading("runtest.err")
            let build_and_run_output = build_and_run_error_file.read_all()

            let test_passes = compare_error(bytes: build_and_run_output, expected)

            if not test_passes {
                eprintln("Test failed: {}", file_name)
                return 1
            } else {
                println("Test passed: {}", file_name)
                return 0
            }

        }
        SkipTest => {
            println("Expected output/error not found. Test skipped")

            // Can't understand test, so we skip it
            return 2
        }
    }
}

function build_and_run(anon jakt_source_file: String, selfhost_executable: String) throws {
    mut compile_args = [
        selfhost_executable
        "-r"
    ]
    compile_args.push(jakt_source_file)
    compile_args.push(">")
    compile_args.push("runtest.out")
    compile_args.push("2>")
    compile_args.push("runtest.err")

    mut command = ""
    for compile_arg in compile_args.iterator() {
        command += compile_arg
        command += " "
    }
    
    system(command.c_string())
}

function write_to_file(file_contents: [u8], output_filename: String) throws {
    mut outfile = File::open_for_writing(output_filename)
    outfile.write(file_contents)
}
