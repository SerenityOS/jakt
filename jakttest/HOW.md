# How Jakttest works

Jakttest receives a temporary directory and a list of files.
It then parses each file to get what kind of output is expected from it, 
and starts running all jobs through a scheduler.

The scheduler has a set of directories that it will be using for
each job, and it will make sure that each running process has its own
temporary directory. 

Once a directory is free, it will launch `run-one.sh`, which will take the
directory for the job and the file to compile and run, and make sure that all
intermediate files used by compilers are put inside that directory.

Once a job finishes, Jakttest will check the exit code and stderr/stdout files
generated by the job and will compare them using the expectations that it parsed
previously. If enabled through the `--show-reasons` flag, it will also collect
data about why the test failed.

When everything finishes, Jakttest will print a summary to standard output with
the passed/failed/skipped counts. If enabled through the `--show-reasons` flag,
it will print out, for every test that failed, why did it mark it as such.

Take note that any output that has ANSI coloring in it is printed to standard error,
so that standard output is left to be used by other tools cleanly. For example:

```shell
./jakttest/build/jakttest | xsel -bi
```

This command runs all the tests and then uses `xsel` to copy the tests summary to
the clipboard.

## Why is Jakttest parallel?

Jakttest now works with a scheduler so it can interleave more test runs at
the same time, but why?

Well, Jakt compiles to C++. This means that Jakt's output is then processed
by a C++ compiler that has to take in all of the `runtime/` headers and all
the generated code, which slows down compilation by a bunch. So the real
bottleneck is not that Jakt is slow, or that the test program that runs is
slow. The bottleneck is running `clang++` to get our executable.
