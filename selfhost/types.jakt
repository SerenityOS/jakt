import parser {
    ArgumentStoreLevel, BinaryOperator, DefinitionLinkage, EnumVariantPatternArgument, ExternalName, FunctionLinkage
    FunctionType, IncludeAction, InlineState, ParsedBlock, ParsedCall, ParsedCapture, ParsedExpression
    ParsedExternImport, ParsedField, ParsedFunction, ParsedMatchBody, ParsedMatchCase, ParsedModuleImport
    ParsedNamespace, ParsedParameter, ParsedRecord, ParsedStatement, ParsedType, ParsedVarDecl, ParsedName, Parser, RecordType
    TypeCast, UnaryOperator, CheckedQualifiers
}
import utility { FileId, IterationDecision, Queue, Span, join, panic, todo }
import compiler { Compiler }
import ids { EnumId, FunctionId, ModuleId, ScopeId, StructId, TraitId, TypeId, VarId }

enum StructOrEnumId {
    Struct(StructId)
    Enum(EnumId)
}

enum StructLikeId {
    generic_arguments: [TypeId]? = None

    Struct(StructId)
    Enum(EnumId)
    Trait(TraitId)

    fn generic_parameters(this, anon program: &CheckedProgram) -> [TypeId] {
        let parameters = match this {
            Struct(id) => program.get_struct(id).generic_parameters
            Enum(id) => program.get_enum(id).generic_parameters
            Trait(id) => program.get_trait(id).generic_parameters
        }
        mut result: [TypeId] = []
        for parameter in parameters {
            result.push(parameter.type_id)
        }
        return result
    }

    fn generic_parameters_as_checked(this, anon program: &CheckedProgram) -> [CheckedGenericParameter] => match this {
        Struct(id) => program.get_struct(id).generic_parameters
        Enum(id) => program.get_enum(id).generic_parameters
        Trait(id) => program.get_trait(id).generic_parameters
    }

    fn scope_id(this, anon program: &CheckedProgram) -> ScopeId => match this {
        Struct(id) => program.get_struct(id).scope_id
        Enum(id) => program.get_enum(id).scope_id
        Trait(id) => program.get_trait(id).scope_id
    }

    fn specialized_by(
        this
        anon arguments: [TypeId]
        anon program: &mut CheckedProgram
        module_id: ModuleId
        qualifiers: CheckedQualifiers = CheckedQualifiers()
    ) -> TypeId => match this {
        Struct(id) => program.find_or_add_type_id(Type::GenericInstance(qualifiers, id, args: arguments), module_id)
        Enum(id) => program.find_or_add_type_id(Type::GenericEnumInstance(qualifiers, id, args: arguments), module_id)
        Trait(id) => program.find_or_add_type_id(Type::GenericTraitInstance(qualifiers, id, args: arguments), module_id)
    }

    fn from_type_id(anon type_id: TypeId, anon program: &CheckedProgram) -> StructLikeId? {
        return match program.get_type(type_id) {
            GenericInstance(id: struct_id, args) | Struct(struct_id) default(args: [TypeId] = [])
                => StructLikeId::Struct(generic_arguments: args, struct_id)
            GenericEnumInstance(id: enum_id, args) | Enum(enum_id) default(args: [TypeId] = [])
                => StructLikeId::Enum(generic_arguments: args, enum_id)
            GenericTraitInstance(id: trait_id, args) | Trait(trait_id) default(args: [TypeId] = [])
                => StructLikeId::Trait(generic_arguments: args, trait_id)
            else => None
        }
    }

    fn associated_scope_id(this, anon program: &CheckedProgram) -> ScopeId => match this {
        Struct(id) => program.get_struct(id).scope_id
        Enum(id) => program.get_enum(id).scope_id
        Trait(id) => program.get_trait(id).scope_id
    }
}

struct GenericInferences {
    values: [TypeId:TypeId] = [:]

    fn set(mut this, anon key: TypeId, anon value: TypeId) {
        if key == value {
            return
        }

        let mapped_value = .map(value)
        if key == mapped_value {
            return
        }

        .values[key] = mapped_value
    }

    fn set_all(mut this, keys: [CheckedGenericParameter], values: [TypeId]) {
        for i in 0..(keys.size()) {
            let key = keys[i].type_id
            let value = values[i]
            .set(key, value)
        }
    }

    fn get(this, anon key: TypeId) -> TypeId? {
        return .values.get(key)
    }

    fn map(this, anon type: TypeId) -> TypeId {
        mut mapped = .values.get(type)
        mut final_mapped_result = mapped
        while mapped.has_value() {
            final_mapped_result = mapped
            mapped = .values.get(mapped!)
        }
        return final_mapped_result ?? type
    }

    fn find_and_map(this, anon name: String, anon program: &CheckedProgram) -> TypeId? {
        for (type_id, v) in .values {
            if program.get_type(type_id) is TypeVariable(name: var_name) and var_name == name {
                return .map(v)
            }
        }

        return None
    }

    fn iterator(this) -> [TypeId:TypeId] => .values

    fn perform_checkpoint(mut this, reset: bool = true) -> [TypeId:TypeId] {
        let result = .values
        .values = [:]

        if not reset {
            for (key, value) in result {
                .values[key] = value
            }
        }

        return result
    }

    fn restore(mut this, anon checkpoint: [TypeId:TypeId]) {
        .values = checkpoint
    }

    fn set_from(mut this, anon checkpoint: [TypeId:TypeId]) {
        for (key, value) in checkpoint {
            .set(key, value)
        }
    }

    fn debug_description(this, anon program: &CheckedProgram) throws {
        eprintln("Generic inferences:")
        for (key, value) in .values {
            eprintln(
                "  {} => {}"
                program.type_name(key, debug_mode: true)
                program.type_name(value, debug_mode: true)
            )
        }
    }
}

enum SafetyMode {
    Safe
    Unsafe
}

enum BuiltinType {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never

    fn id(this) -> usize => match this {
        Void => 0uz
        Bool => 1uz
        U8 => 2uz
        U16 => 3uz
        U32 => 4uz
        U64 => 5uz
        I8 => 6uz
        I16 => 7uz
        I32 => 8uz
        I64 => 9uz
        F32 => 10uz
        F64 => 11uz
        Usize => 12uz
        JaktString => 13uz
        CChar => 14uz
        CInt => 15uz
        Unknown => 16uz
        Never => 17uz
    }

    fn constructor_name(this) -> String => match this {
        Void => "Void"
        Bool => "Bool"
        U8 => "U8"
        U16 => "U16"
        U32 => "U32"
        U64 => "U64"
        I8 => "I8"
        I16 => "I16"
        I32 => "I32"
        I64 => "I64"
        F32 => "F32"
        F64 => "F64"
        Usize => "Usize"
        JaktString => "JaktString"
        CChar => "CChar"
        CInt => "CInt"
        Unknown => "Unknown"
        Never => "Never"
    }
}

boxed enum Type {
    qualifiers: CheckedQualifiers = CheckedQualifiers()

    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never
    TypeVariable(name: String, trait_implementations: [TypeId], is_value: bool = false)
    Dependent(namespace_type: TypeId, name: String)
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    GenericTraitInstance(id: TraitId, args: [TypeId])
    GenericResolvedType(id: StructId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    RawPtr(TypeId)
    Trait(TraitId)
    Reference(TypeId)
    MutableReference(TypeId)
    Function(params: [TypeId], can_throw: bool, return_type_id: TypeId, pseudo_function_id: FunctionId)
    Self
    Const(Value)

    fn generic_parameters(this, program: CheckedProgram) -> [CheckedGenericParameter]? => match this {
        Struct(id) | GenericInstance(id) | GenericResolvedType(id) => Some(program.get_struct(id).generic_parameters)
        Enum(id) | GenericEnumInstance(id) => Some(program.get_enum(id).generic_parameters)
        Trait(id) | GenericTraitInstance(id) => Some(program.get_trait(id).generic_parameters)
        else => None
    }

    fn is_boxed(this, program: CheckedProgram) -> bool => match this {
        Struct(struct_id) | GenericInstance(id: struct_id) => program.get_struct(struct_id).record_type is Class
        Enum(enum_id) | GenericEnumInstance(id: enum_id) => program.get_enum(enum_id).is_boxed
        else => false
    }

    fn is_concrete(this) -> bool => match this {
        TypeVariable | Self | Dependent | Unknown => false
        else => true
    }

    fn specificity(this, program: CheckedProgram, base_specificity: i64 = 1<<31) -> i64 => match this {
        TypeVariable => 0
        Dependent => 0
        Const => base_specificity
        GenericInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericEnumInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericResolvedType(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        Function(params) => {
            mut specificity = base_specificity / 2
            for subtype_id in params.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        else => base_specificity
    }

    fn constructor_name(this) -> String => match this {
        Void => "Void"
        Bool => "Bool"
        U8 => "U8"
        U16 => "U16"
        U32 => "U32"
        U64 => "U64"
        I8 => "I8"
        I16 => "I16"
        I32 => "I32"
        I64 => "I64"
        F32 => "F32"
        F64 => "F64"
        Usize => "Usize"
        JaktString => "JaktString"
        CChar => "CChar"
        CInt => "CInt"
        Unknown => "Unknown"
        Never => "Never"
        TypeVariable => "TypeVariable"
        Dependent => "Dependent"
        GenericInstance => "GenericInstance"
        GenericEnumInstance => "GenericEnumInstance"
        GenericTraitInstance => "GenericTraitInstance"
        GenericResolvedType => "GenericResolvedType"
        Struct => "Struct"
        Enum => "Enum"
        RawPtr => "RawPtr"
        Trait => "Trait"
        Reference => "Reference"
        MutableReference => "MutableReference"
        Function => "Function"
        Self => "Self"
        Const => "Const"
    }

    fn equals(this, anon rhs: Type) -> bool => rhs.qualifiers == .qualifiers and match this {
        Void => rhs is Void
        Bool => rhs is Bool
        U8 => rhs is U8
        U16 => rhs is U16
        U32 => rhs is U32
        U64 => rhs is U64
        I8 => rhs is I8
        I16 => rhs is I16
        I32 => rhs is I32
        I64 => rhs is I64
        F32 => rhs is F32
        F64 => rhs is F64
        Usize => rhs is Usize
        JaktString => rhs is JaktString
        CChar => rhs is CChar
        CInt => rhs is CInt
        Self => rhs is Self
        Unknown => rhs is Unknown
        Never => rhs is Never
        // FIXME: Check implemented traits for equality.
        TypeVariable(name: lhs_name) => {
            if rhs is TypeVariable(name: rhs_name) {
                return lhs_name == rhs_name
            }
            yield false
        }
        Dependent(namespace_type, name) => {
            if rhs is Dependent(namespace_type: rhs_namespace_type, name: rhs_name) {
                return namespace_type.equals(rhs_namespace_type) and name == rhs_name
            }
            yield false
        }
        Const(lhs_value) => match rhs {
            Const(rhs_value) => lhs_value.impl.equals(rhs_value.impl)
            else => false
        }
        GenericResolvedType(id: lhs_id, args: lhs_args)
        | GenericInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        GenericTraitInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericTraitInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        GenericEnumInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericEnumInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        Struct(lhs_id) => {
            if rhs is Struct(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Enum(lhs_id) => {
            if rhs is Enum(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        RawPtr(lhs_id) => {
            if rhs is RawPtr(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Reference(lhs_id) => {
            if rhs is Reference(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        MutableReference(lhs_id) => {
            if rhs is MutableReference(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Trait(lhs_id) => {
            if rhs is Trait(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Function(params, can_throw, return_type_id) => {
            guard rhs is Function(params: rhs_params, can_throw: rhs_can_throw, return_type_id: rhs_return_type_id)
                and params.size() == rhs_params.size()
                and return_type_id.equals(rhs_return_type_id)
                and can_throw == rhs_can_throw else {

                return false
            }
            for i in 0..params.size() {
                if not params[i].equals(rhs_params[i]) {
                    return false
                }
            }

            return true
        }
    }

    fn is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt => true
        else => false
    }

    fn as_builtin_type(this) -> BuiltinType => match this {
        Void => BuiltinType::Void
        Bool => BuiltinType::Bool
        U8 => BuiltinType::U8
        U16 => BuiltinType::U16
        U32 => BuiltinType::U32
        U64 => BuiltinType::U64
        I8 => BuiltinType::I8
        I16 => BuiltinType::I16
        I32 => BuiltinType::I32
        I64 => BuiltinType::I64
        F32 => BuiltinType::F32
        F64 => BuiltinType::F64
        Usize => BuiltinType::Usize
        JaktString => BuiltinType::JaktString
        CChar => BuiltinType::CChar
        CInt => BuiltinType::CInt
        else => {
            eprintln("Type.as_builtin_type: Not a builtin type: {}", this)
            abort()
        }
    }

    fn get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    fn is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    fn min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    fn max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }

    fn flip_signedness(this) -> TypeId => match this {
        I8 => builtin(BuiltinType::U8)
        I16 => builtin(BuiltinType::U16)
        I32 => builtin(BuiltinType::U32)
        I64 => builtin(BuiltinType::U64)
        U8 => builtin(BuiltinType::I8)
        U16 => builtin(BuiltinType::I16)
        U32 => builtin(BuiltinType::I32)
        U64 => builtin(BuiltinType::I64)
        else => builtin(BuiltinType::Unknown)
    }
}

struct SpecializedType {
    base_type_id: TypeId
    arguments: [TypeId]
    type_id: TypeId
}

struct ResolutionMixin {
    scope_id: ScopeId
    mixin_vars: bool = true
    mixin_bindings: bool = true
    mixin_structs: bool = true
    mixin_functions: bool = true
    mixin_enums: bool = true
    mixin_types: bool = true
    mixin_traits: bool = true
    mixin_imports: bool = true
    mixin_aliases: bool = true
}

class Scope {
    public parent: ScopeId?
    public can_throw: bool
    public debug_name: String
    public is_block_scope: bool
    public is_from_generated_code: bool

    public namespace_name: String? = None
    public module_namespace_name: String? = None
    public external_name: ExternalName? = None

    public vars: [String: VarId] = [:]
    public comptime_bindings: [String: Value] = [:]
    public structs: [String: StructId] = [:]
    public functions: [String: [FunctionId]] = [:]
    public enums: [String: EnumId] = [:]
    public types: [String: TypeId] = [:]
    public traits: [String: TraitId] = [:]
    public imports: [String: ModuleId] = [:] // FIXME: Span
    public aliases: [String: ScopeId] = [:]

    public alias_scope: ScopeId? = None
    public children: [ScopeId] = []
    public import_path_if_extern: String? = None
    public alias_path: [ResolvedNamespace]? = None
    public after_extern_include: [IncludeAction] = []
    public before_extern_include: [IncludeAction] = []
    public resolution_mixins: [ResolutionMixin] = []

    // Set if this scope corresponds to a type, as opposed to a block or a namespace.
    public relevant_type_id: TypeId? = None

    public resolved_forall_chunks: [ResolvedForallChunk]? = None
    public explicitly_specialized_types: [String:SpecializedType] = [:]

    public fn namespace_name_for_codegen(this) -> ExternalName? {
        if .external_name.has_value() { return .external_name }
        if .namespace_name.has_value() {
            return ExternalName::Plain(.namespace_name!)
        }
        if .module_namespace_name.has_value() {
            return ExternalName::Plain(.module_namespace_name!)
        }
        return None
    }
}

struct ResolvedForallChunk {
    public parameters: [String:[(Span, TypeId)]]
    public parsed_namespace: ParsedNamespace
    public generated_scopes: [ScopeId]
}

class Module {
    public id: ModuleId
    public name: String
    public types: [Type]
    public resolved_import_path: String
    public is_root: bool

    public functions: [CheckedFunction] = []
    public structures: [CheckedStruct] = []
    public enums: [CheckedEnum] = []
    public scopes: [Scope] = []
    public traits: [CheckedTrait] = []
    public variables: [CheckedVariable] = []
    public imports: [ModuleId] = []
    public builtin_implementation_structs: [usize:StructId] = [:]

    public fn is_prelude(this) -> bool => .id.id == 0

    public fn new_type_variable(mut this, implemented_traits: [TypeId]? = None) -> TypeId {
        let new_id = .types.size()

        let empty_implementation: [TypeId] = []
        let trait_implementations = implemented_traits ?? empty_implementation
        .types.push(Type::TypeVariable(name: format("T{}", new_id), trait_implementations))

        return TypeId(module: .id, id: new_id)
    }

    public fn next_function_id(this) -> FunctionId {
        return FunctionId(module: .id, id: .functions.size())
    }

    public fn add_function(mut this, checked_function: CheckedFunction) -> FunctionId {
        let new_id = .next_function_id()

        .functions.push(checked_function)

        return new_id
    }

    public fn add_variable(mut this, anon checked_variable: CheckedVariable) -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

enum CheckedTraitRequirements {
    Nothing
    Methods([String:FunctionId])
    ComptimeExpression(CheckedExpression)
}

class CheckedTrait {
    public name: String
    public name_span: Span
    public requirements: CheckedTraitRequirements
    public generic_parameters: [CheckedGenericParameter]
    public scope_id: ScopeId
}

struct LoadedModule {
    module_id: ModuleId
    file_id: FileId
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

boxed enum MaybeResolvedScope {
    Resolved(ScopeId)
    Unresolved(
        parent_scope: MaybeResolvedScope
        relative_name: String
    )

    fn try_resolve(this, program: CheckedProgram) throws -> MaybeResolvedScope {
        return match this {
            Resolved(id) => MaybeResolvedScope::Resolved(id)
            Unresolved(parent_scope, relative_name) => {
                mut parent = parent_scope.try_resolve(program)
                if parent is Resolved(parent_scope_id) {
                    let scope = parent_scope_id
                    mut scope_id: ScopeId? = None
                    if not scope_id.has_value() {
                        let struct_ = program.find_struct_in_scope(scope_id: scope, name: relative_name)
                        if struct_.has_value() {
                            scope_id = program.get_struct(struct_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let enum_ = program.find_enum_in_scope(scope_id: scope, name: relative_name)
                        if enum_.has_value() {
                            scope_id = program.get_enum(enum_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let ns = program.find_namespace_in_scope(scope_id: scope, name: relative_name)
                        if ns.has_value() {
                            scope_id = ns!.0
                        }
                    }

                    if not scope_id.has_value() {
                        let ids = program.find_functions_with_name_in_scope(parent_scope_id: scope, function_name: relative_name)
                        if ids.has_value() {
                            scope_id = program.get_function(ids![0]).function_scope_id
                        }
                    }
                    if (scope_id.has_value()) {
                        return MaybeResolvedScope::Resolved(scope_id!)
                    }
                }

                yield MaybeResolvedScope::Unresolved(parent_scope: parent, relative_name)
            }
        }
    }
}

enum CheckedVisibility {
    Public
    Private
    Restricted(scopes: [MaybeResolvedScope], span: Span)
}

class CheckedFunction {
    public name: String
    public name_span: Span
    public visibility: CheckedVisibility
    public return_type_id: TypeId
    public return_type_span: Span?
    public params: [CheckedParameter]
    public generics: FunctionGenerics
    public block: CheckedBlock
    public can_throw: bool
    public type: FunctionType
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId
    public struct_id: StructId?
    public is_instantiated: bool
    public parsed_function: ParsedFunction?
    public is_comptime: bool
    public is_virtual: bool
    public is_override: bool
    public is_unsafe: bool
    public has_varargs: bool = false
    public specialization_index: usize? = None

    public owner_scope: ScopeId? = None
    public owner_scope_generics: [TypeId:TypeId]? = None
    public is_fully_checked: bool = false

    public external_name: ExternalName? = None
    public deprecated_message: String? = None
    public stores_arguments: [(usize, ArgumentStoreLevel)]? = None
    public force_inline: InlineState = InlineState::Default

    public fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)

    public fn map_types(mut this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws {
        .return_type_id = map(.return_type_id)
        mut changed_params: [CheckedParameter] = []
        for param in .params {
            changed_params.push(param.map_types(map))
        }
        .params = changed_params
    }

    public fn copy(this) -> CheckedFunction => CheckedFunction(
        name: .name
        name_span: .name_span
        visibility: .visibility
        return_type_id: .return_type_id
        return_type_span: .return_type_span
        params: .params
        generics: .generics
        block: .block
        can_throw: .can_throw
        type: .type
        linkage: .linkage
        function_scope_id: .function_scope_id
        struct_id: .struct_id
        is_instantiated: .is_instantiated
        parsed_function: .parsed_function
        is_comptime: .is_comptime
        is_virtual: .is_virtual
        is_override: .is_override
        is_unsafe: .is_unsafe
        has_varargs: .has_varargs
        specialization_index: .specialization_index
        owner_scope: .owner_scope
        owner_scope_generics: .owner_scope_generics
        is_fully_checked: .is_fully_checked
        external_name: .external_name
        deprecated_message: .deprecated_message
        stores_arguments: .stores_arguments
    )

    public fn signature_matches(this, anon other: CheckedFunction, ignore_this: bool = false) -> bool {
        if this.name != other.name or
            this.can_throw != other.can_throw or
            this.is_comptime != other.is_comptime or
            this.has_varargs != other.has_varargs {

            return false
        }

        if this.params.size() != other.params.size() {
            return false
        }

        if this.generics.params.size() != other.generics.params.size() {
            return false
        }

        mut lhs_generic_type_ids: {TypeId} = {}
        mut rhs_generic_type_ids: {TypeId} = {}
        for param in this.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            lhs_generic_type_ids.add(type_id)
        }
        for param in other.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            rhs_generic_type_ids.add(type_id)
        }

        for param_index in 0..this.params.size() {
            let lhs_param = this.params[param_index]
            let rhs_param = other.params[param_index]

            let lhs_param_id = lhs_param.variable.type_id
            let rhs_param_id = rhs_param.variable.type_id

            if not lhs_param.variable.type_id.equals(rhs_param.variable.type_id)
                and not (lhs_generic_type_ids.contains(lhs_param_id) and rhs_generic_type_ids.contains(rhs_param_id))
            {
                return false
            }
        }


        return true
    }

    public fn is_static(this) -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public fn is_mutating(this) -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }

    public fn add_param(mut this, anon checked_param: CheckedParameter) {
        .params.push(checked_param)
        .generics.base_params.push(checked_param)
    }

    public fn set_params(mut this, anon checked_params: [CheckedParameter]) {
        .params = checked_params
        .generics.base_params = checked_params
    }

    public fn is_specialized_for_types(this, types: [TypeId]) -> bool {
        return .generics.is_specialized_for_types(types)
    }

    public fn to_parsed_function(this) -> ParsedFunction {
        if not .parsed_function.has_value() {
            panic("to_parsed_function() called on a synthetic function")
        }
        return .parsed_function!
    }
}

class FunctionGenerics {
    public base_scope_id: ScopeId
    public base_params: [CheckedParameter] = []
    public params: [FunctionGenericParameter] = []
    public specializations: [[TypeId]] = []

    public fn is_specialized_for_types(this, types: [TypeId]) -> bool {
        if types.size() == 0 {
            return true
        }

        for specialization in .specializations {
            mut matched = true

            if types.size() == specialization.size() {
                for i in ..types.size() {
                    if not types[i].equals(specialization[i]) {
                        matched = false
                        break
                    }
                }
            }

            if matched {
                return true
            }
        }

        return false
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
    default_value_expression: (ParsedExpression, ScopeId)?

    public fn map_types(this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws -> CheckedParameter {
        return CheckedParameter(
            requires_label: .requires_label
            variable: .variable.map_types(map)
            default_value_expression: .default_value_expression
        )
    }
}

enum CheckedCapture {
    name: String
    span: Span

    ByValue
    ByReference
    ByMutableReference
    ByComptimeDependency
    AllByReference
}

enum FunctionGenericParameterKind {
    InferenceGuide
    Parameter
}


struct FunctionGenericParameter {
    kind: FunctionGenericParameterKind
    checked_parameter: CheckedGenericParameter

    fn type_id(this) -> TypeId => .checked_parameter.type_id

    fn parameter(
        anon type_id: TypeId
        span: Span
    ) -> FunctionGenericParameter => FunctionGenericParameter(
        kind: FunctionGenericParameterKind::Parameter
        checked_parameter: CheckedGenericParameter::make(type_id, span)
    )
}

class CheckedVariable {
    public name: String
    public type_id: TypeId
    public is_mutable: bool
    public definition_span: Span
    public type_span: Span?
    public visibility: CheckedVisibility
    public owner_scope: ScopeId? = None
    public owner_scope_generics: [TypeId:TypeId]? = None
    public external_name: ExternalName? = None

    public fn map_types(this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws -> CheckedVariable {
        return CheckedVariable(
            name: .name
            type_id: map(.type_id)
            is_mutable: .is_mutable
            definition_span: .definition_span
            type_span: .type_span
            visibility: .visibility
            owner_scope: .owner_scope
            owner_scope_generics: .owner_scope_generics
            external_name: .external_name
        )
    }

    public fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

enum BlockControlFlow {
    AlwaysReturns
    AlwaysTransfersControl(might_break: bool)
    NeverReturns
    MayReturn
    // If expressions without 'else' branches may produce these.
    PartialAlwaysReturns(might_break: bool)
    PartialAlwaysTransfersControl(might_break: bool)
    PartialNeverReturns(might_break: bool)

    fn unify_with(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => second
        AlwaysReturns => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            MayReturn => BlockControlFlow::MayReturn
            PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        }
        AlwaysTransfersControl(might_break: lhs) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            else => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
        }
        MayReturn => match second {
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            else => BlockControlFlow::MayReturn
        }
        PartialAlwaysReturns(might_break: lhs) => match second {
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::MayReturn
        }
        PartialAlwaysTransfersControl(might_break: lhs) => match second {
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns | NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs)
        }
        PartialNeverReturns(might_break: lhs) => match second {
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialNeverReturns(might_break: lhs)
            NeverReturns => BlockControlFlow::NeverReturns
        }
    }

    public fn branch_unify_with(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => second
        AlwaysReturns => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
            MayReturn => BlockControlFlow::MayReturn
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        }
        MayReturn => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::MayReturn
            MayReturn => BlockControlFlow::MayReturn
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        }
        PartialNeverReturns(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialNeverReturns(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialNeverReturns(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        PartialAlwaysReturns(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialAlwaysReturns(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysReturns(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        PartialAlwaysTransfersControl(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        AlwaysTransfersControl(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
    }

    fn updated(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => second
        PartialAlwaysTransfersControl | PartialAlwaysReturns | PartialNeverReturns => .unify_with(second)
    }

    fn partial(this) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::PartialNeverReturns(might_break: false)
        AlwaysReturns => BlockControlFlow::PartialAlwaysReturns(might_break: false)
        MayReturn => BlockControlFlow::MayReturn
        AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
        PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
    }

    fn definitive(this) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => BlockControlFlow::MayReturn
        else => BlockControlFlow::MayReturn
    }

    fn always_transfers_control(this) -> bool => match this {
        AlwaysReturns | AlwaysTransfersControl => true
        else => false
    }

    fn never_returns(this) -> bool => match this {
        NeverReturns => true
        else => false
    }

    fn always_returns(this) -> bool => match this {
        AlwaysReturns => true
        else => false
    }

    fn may_return(this) -> bool => match this {
        MayReturn | PartialAlwaysReturns | PartialAlwaysTransfersControl | PartialNeverReturns => true
        else => false
    }

    fn may_break(this) -> bool => match this {
        PartialAlwaysReturns(might_break)
        | PartialAlwaysTransfersControl(might_break)
        | PartialNeverReturns(might_break)
        | AlwaysTransfersControl(might_break)
        => might_break
        else => false
    }

    fn is_reachable(this) -> bool => match this {
        NeverReturns | AlwaysReturns | AlwaysTransfersControl => false
        else => true
    }
}

struct CheckedBlock {
    statements: [CheckedStatement] = []
    scope_id: ScopeId
    control_flow: BlockControlFlow
    yielded_type: TypeId? = None
    yielded_none: bool = false
}

struct FieldRecord {
    struct_id: StructId
    field_id: VarId
}

struct CheckedField {
    variable_id: VarId
    default_value_expression: (ParsedExpression, ScopeId)?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter] = []
    generic_parameter_defaults: [TypeId?]? = None
    fields: [CheckedField] = []
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:[(TraitId, [TypeId])]] = [:]
    record_type: RecordType
    type_id: TypeId
    super_struct_id: StructId? = None

    external_name: ExternalName? = None
    implements_type: TypeId? = None
    create_function_name: String? = None

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter] = []
    variants: [CheckedEnumVariant] = []
    fields: [CheckedField] = []
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:[(TraitId, [TypeId])]] = [:]
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
    is_boxed: bool
}

struct CheckedGenericParameter {
    type_id: TypeId
    constraints: [TraitId]
    span: Span

    fn make(
        anon type_id: TypeId
        span: Span
    ) -> CheckedGenericParameter => CheckedGenericParameter(type_id, constraints: [], span)
}

enum CheckedEnumVariant {
    Untyped(enum_id: EnumId, name: String, span: Span)
    Typed(enum_id: EnumId, name: String, type_id: TypeId, span: Span)
    WithValue(enum_id: EnumId, name: String, expr: CheckedExpression, span: Span)
    // NOTE: The parent enum's `CheckedEnum.fields` are duplicated at the start of
    // the `fields` array. This invariant is used to skip over them when not needed.
    StructLike(enum_id: EnumId, name: String, fields: [VarId], span: Span)

    fn equals(this, anon other: CheckedEnumVariant) -> bool {
        return match this {
            Untyped(name: this_name) => match other {
                Untyped(name: other_name) => this_name == other_name
                else => false
            }
            else => false
        }
    }

    fn enum_id(this) -> EnumId => match this {
        Untyped(enum_id)
        | Typed(enum_id)
        | WithValue(enum_id)
        | StructLike(enum_id) => enum_id
    }

    fn span(this) -> Span => match this {
        Untyped(span) => span
        Typed(span) => span
        WithValue(span) => span
        StructLike(span) => span
    }

    fn name(this) -> String => match this {
        Untyped(name) => name
        Typed(name) => name
        WithValue(name) => name
        StructLike(name)  => name
    }
}

struct CheckedEnumVariantBinding {
    name: String?
    binding: String
    type_id: TypeId
    span: Span
}

boxed enum CheckedStatement {
    Expression(expr: CheckedExpression, span: Span)
    Defer(statement: CheckedStatement, span: Span)
    DestructuringAssignment(vars: [CheckedStatement], var_decl: CheckedStatement, span: Span)
    VarDecl(var_id: VarId, init: CheckedExpression, span: Span)
    If(condition: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?, span: Span)
    Block(block: CheckedBlock, span: Span)
    Loop(block: CheckedBlock, span: Span)
    While(condition: CheckedExpression, block: CheckedBlock, span: Span)
    Return(val: CheckedExpression?, span: Span?)
    Break(Span)
    Continue(Span)
    Throw(expr: CheckedExpression, span: Span)
    Yield(expr: CheckedExpression?, span: Span)
    InlineCpp(lines: [String], span: Span)
    Garbage(Span)

    fn span(this) -> Span? => match this {
        Expression(span) => Some(span)
        else(span) => span
    }

    fn none() -> CheckedStatement? => None

    fn maybe_control_flow(anon statement: CheckedStatement?, anon other_branch: BlockControlFlow) -> BlockControlFlow => match statement.has_value() {
        true => statement!.control_flow()
        false => other_branch.partial()
    }

    fn control_flow(this) -> BlockControlFlow => match this {
        Return => BlockControlFlow::AlwaysReturns
        Throw => BlockControlFlow::AlwaysReturns
        Break => BlockControlFlow::AlwaysTransfersControl(might_break: true)
        Continue => BlockControlFlow::AlwaysTransfersControl(might_break: false)
        Yield(expr) => match expr.has_value() {
            true => expr!.control_flow().updated(BlockControlFlow::AlwaysTransfersControl(might_break: false))
            false => BlockControlFlow::AlwaysTransfersControl(might_break: false)
        }
        If(condition, then_block, else_statement) => match condition {
            Boolean(val) => match val {
                true => then_block.control_flow
                false => match else_statement.has_value() {
                    true => else_statement!.control_flow()
                    false => BlockControlFlow::MayReturn
                }
            }
            // Note that a missing 'else' branch produces a partial result.
            else => then_block.control_flow.branch_unify_with(maybe_control_flow(else_statement, then_block.control_flow))
        }
        Block(block) => block.control_flow
        // Note that 'while' blocks, which conditions are not always true,
        // similarly to 'if's with a missing 'else' branch, produce a partial result.
        // But also: every 'break' and 'continue' inside of it, does not apply to the outer blocks,
        // and without a need for that info, Partials can just get degraded to the MayReturn.
        While(condition, block) => match condition {
            Boolean(val) => match val {
                true => match block.control_flow {
                    AlwaysReturns => BlockControlFlow::AlwaysReturns
                    NeverReturns => BlockControlFlow::NeverReturns
                    else => BlockControlFlow::MayReturn
                }
                else => BlockControlFlow::MayReturn
            }
            else => BlockControlFlow::MayReturn
        }
        Loop(block) => match block.control_flow {
            AlwaysTransfersControl(might_break) => match might_break {
                false => BlockControlFlow::AlwaysTransfersControl(might_break)
                true => BlockControlFlow::MayReturn
            }
            NeverReturns => BlockControlFlow::NeverReturns
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            MayReturn => BlockControlFlow::MayReturn
            else => match block.control_flow.may_break() {
                true => BlockControlFlow::MayReturn
                // Loop will always continue, so upgrade partial results to full ones
                false => match block.control_flow {
                    PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
                    PartialNeverReturns => BlockControlFlow::NeverReturns
                    PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
                    else => BlockControlFlow::MayReturn // unreachable, logically.
                }
            }
        }
        Expression(expr) => expr.control_flow()
        else => BlockControlFlow::MayReturn
    }
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    fn can_fit_number(this, type_id: TypeId, program: CheckedProgram) -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                }
                F64 => true
                else => false
            }
        }
    }

    fn to_usize(this) -> usize => match this {
        Signed(value) => value as! usize
        Unsigned(value) => value as! usize
        Floating(value) => {
            panic("to_usize on a floating point constant")
        }
    }
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    fn number_constant(this) -> NumberConstant? => match this {
        I8(value) =>  NumberConstant::Signed(value as! i64)
        I16(value) =>  NumberConstant::Signed(value as! i64)
        I32(value) =>  NumberConstant::Signed(value as! i64)
        I64(value) =>  NumberConstant::Signed(value as! i64)
        U8(value) =>  NumberConstant::Unsigned(value as! u64)
        U16(value) =>  NumberConstant::Unsigned(value as! u64)
        U32(value) =>  NumberConstant::Unsigned(value as! u64)
        U64(value) =>  NumberConstant::Unsigned(value as! u64)
        USize(value) =>  NumberConstant::Unsigned(value as! u64)

        // FIXME: add a case for F32 once we can cast f32 to f64

        F64(value) =>  NumberConstant::Floating(value)
        else => None
    }
}

enum StringLiteral {
    Static(String)

    fn to_string(this) -> String => match this {
        Static(value) => value
    }
}

struct CheckedStringLiteral {
    value: StringLiteral
    type_id: TypeId
    may_throw: bool

    fn to_string(this) -> String => .value.to_string()
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)
    Identity(TypeId)

    fn type_id(this) -> TypeId => match this {
        else(type_id) => type_id
    }
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    Reference
    MutableReference
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(enum_variant: CheckedEnumVariant, bindings: [CheckedEnumVariantBinding], type_id: TypeId)
    IsSome
    IsNone
    Sizeof(TypeId)
}

enum CheckedMatchBody {
    Expression(CheckedExpression)
    Block(CheckedBlock)
}

struct ClassInstanceRebind {
    name: String
    name_span: Span
    is_mutable: bool
    is_reference: bool
}

enum CheckedMatchCase {
    defaults: [CheckedStatement]

    EnumVariant(name: String, args: [EnumVariantPatternArgument], subject_type_id: TypeId, index: usize, scope_id: ScopeId, body: CheckedMatchBody, marker_span: Span)
    Expression(expression: CheckedExpression, body: CheckedMatchBody, marker_span: Span)
    ClassInstance(type: TypeId, body: CheckedMatchBody, rebind_name: ClassInstanceRebind?, marker_span: Span)
    CatchAll(has_arguments: bool, body: CheckedMatchBody, marker_span: Span)
}

struct OperatorTraitImplementation {
    trait_id: TraitId
    trait_generic_arguments: [TypeId]
    call_expression: CheckedCall
}

struct CheckedBinaryOperator {
    op: BinaryOperator
    // FIXME: This is Optional<> because we haven't converted all operators to traits yet, do that.
    trait_implementation: OperatorTraitImplementation?
}

boxed enum CheckedExpression {
    generic_inferences: [TypeId:TypeId]? = None

    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: CheckedStringLiteral, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    CCharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: CheckedBinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression?, to: CheckedExpression?, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId, key_type_id: TypeId, value_type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, is_optional: bool, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, name: String, index: VarId?, span: Span, is_optional: bool, type_id: TypeId)
    IndexedCommonEnumMember(expr: CheckedExpression, index: String, span: Span, is_optional: bool, type_id: TypeId)
    ComptimeIndex(expr: CheckedExpression, index: CheckedExpression, is_optional: bool, span: Span)
    Match(expr: CheckedExpression, match_cases: [CheckedMatchCase], span: Span, type_id: TypeId, all_variants_constant: bool)
    EnumVariantArg(expr: CheckedExpression, arg: CheckedEnumVariantBinding, enum_variant: CheckedEnumVariant, span: Span)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, is_optional: bool, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Function(
        captures: [CheckedCapture]
        params: [CheckedParameter]
        can_throw: bool
        return_type_id: TypeId
        block: CheckedBlock
        span: Span
        type_id: TypeId
        pseudo_function_id: FunctionId?
        scope_id: ScopeId
    )
    DependentFunction(
        captures: [CheckedCapture]
        params: [CheckedParameter]
        can_throw: bool
        return_type_id: TypeId
        block: ParsedBlock
        span: Span
        type_id: TypeId
        pseudo_function_id: FunctionId?
        scope_id: ScopeId
    )
    Must(expr: CheckedExpression, span: Span, type_id: TypeId)
    Try(
        expr: CheckedExpression
        catch_block: CheckedBlock?
        catch_span: Span?
        catch_name: String?
        span: Span
        type_id: TypeId
        inner_type_id: TypeId
    )
    TryBlock(stmt: CheckedStatement, catch_block: CheckedBlock, error_name: String, error_span: Span, span: Span, type_id: TypeId)
    Reflect(type: TypeId, span: Span, type_id: TypeId)
    Garbage(span: Span, type_id: TypeId)

    fn to_number_constant(this, program: CheckedProgram) -> NumberConstant? => match this {
        NumericConstant(val, span, type_id) => val.number_constant()
        UnaryOp(expr, op, span, type_id) => {
            mut result: NumberConstant? = None
            guard op is TypeCast(cast) else {
                return None
            }
            if not cast is Infallible {
                result = None
            }
            if not program.is_integer(type_id) and not program.is_floating(type_id) {
                result = None
            }
            if expr is NumericConstant(val) {
                result = val.number_constant()
            }
            yield result
        }
        else => None
    }

    fn span(this) -> Span => match this {
        else(span) => span
    }

    fn is_mutable(this, program: CheckedProgram) -> bool => match this {
        Boolean
        | NumericConstant
        | QuotedString
        | ByteConstant
        | CharacterConstant
        | CCharacterConstant
        => true
        Var(var) => var.is_mutable
        IndexedStruct(expr)
        | IndexedExpression(expr)
        | ComptimeIndex(expr)
        | IndexedTuple(expr)
        | IndexedDictionary(expr)
        | ForcedUnwrap(expr)
        => expr.is_mutable(program)
        JaktArray(vals)
        | JaktSet(vals)
        => {
            mut result = false
            for val in vals {
                if val.is_mutable(program) {
                    result = true
                    break
                }
            }

            yield result
        }
        JaktDictionary(vals) => {
            mut result = false
            for (_, val) in vals {
                if val.is_mutable(program) {
                    result = true
                    break
                }
            }

            yield result
        }
        UnaryOp(expr, op) => match op {
            Dereference => match program.get_type(expr.type()) {
                MutableReference => true
                RawPtr => expr.is_mutable(program)
                else => false
            }
            else => false
        }
        MethodCall(expr) => expr.is_mutable(program)
        else => false
    }

    fn can_throw(this) -> bool => match this {
        Call(call) | MethodCall(call) => call.callee_throws
        QuotedString(val) => val.may_throw
        else => false
    }

    fn type(this) -> TypeId => match this {
        Boolean => builtin(BuiltinType::Bool)
        QuotedString(val) => val.type_id
        ByteConstant => builtin(BuiltinType::U8)
        CCharacterConstant => builtin(BuiltinType::CChar)
        CharacterConstant => builtin(BuiltinType::U32)
        EnumVariantArg(arg) => arg.type_id
        NamespacedVar(var) => var.type_id
        Var(var) => var.type_id
        ComptimeIndex => builtin(BuiltinType::Unknown) // FIXME
        else(type_id) => type_id
    }

    fn control_flow(this)-> BlockControlFlow => match this {
        Match(expr, match_cases, span, type_id, all_variants_constant) => {
            mut control_flow: BlockControlFlow? = None
            for case_ in match_cases {
                let case_control_flow = match case_ {
                    else(body) => match body {
                        Block(block) => block.control_flow
                        Expression(expr) => expr.control_flow()
                    }
                }
                if control_flow.has_value() {
                    control_flow = control_flow!.branch_unify_with(case_control_flow)
                } else {
                    control_flow = case_control_flow
                }
            }
            yield control_flow ?? BlockControlFlow::MayReturn
        }
        MethodCall(type_id) | Call(type_id) => match type_id.equals(never_type_id()) {
            true => BlockControlFlow::NeverReturns
            false => BlockControlFlow::MayReturn
        }
        TryBlock(stmt, catch_block) => {
            guard stmt is Block(block) else {
                panic("Try block doesn't have a block")
            }

            yield block.control_flow.branch_unify_with(catch_block.control_flow)
        }
        else => BlockControlFlow::MayReturn
    }
}

struct ResolvedNamespace {
    name: String
    external_name: ExternalName? = None
    generic_parameters: [TypeId]?

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedCall {
    namespace_: [ResolvedNamespace] = []
    name: String,
    args: [(String, CheckedExpression)]
    type_args: [TypeId] = []
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool

    external_name: ExternalName? = None
    force_inline: InlineState = InlineState::Default

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

fn unknown_type_id() -> TypeId => builtin(BuiltinType::Unknown)
fn void_type_id() -> TypeId => builtin(BuiltinType::Void)
fn never_type_id() -> TypeId => builtin(BuiltinType::Never)

fn builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin.id())
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    public compiler: Compiler
    public modules: [Module] = []
    // exports by filename: each type saves how the type is resolved in terms of namespace names, which will be how it is seen from the C++:
    // ```
    // namespace [ParsedName] {
    //   using {type_name} = {qualifier for type name}
    // }
    // ```
    // This makes the code generator export each type in the namespace dictated by the list of parsed names.
    public exports: [String:[TypeId:[ParsedName]]] = [:]
    public loaded_modules: [String: LoadedModule] = [:]

    public fn create_module(mut this, name: String, is_root: bool, path: String? = None) -> ModuleId {
        let new_id = .modules.size()
        let module_id = ModuleId(id: new_id)
        let module = Module(
            id: module_id,
            name: name,
            types: [ // FIXME: use general builtin types array
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
                Type::Unknown,
                Type::Never
            ],
            resolved_import_path: path ?? .compiler.current_file_path()!.to_string(),
            is_root: is_root,
        )
        .modules.push(module)

        return module_id
    }

    public fn debug_description_of(this, anon scope_id: ScopeId) -> String {
        mut ss: [String] = []
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            let d = format("{} (named {})", scope.debug_name, scope.namespace_name)
            ss.insert(before_index: 0, value: d)
            if scope.parent.has_value() {
                current_scope_id = scope.parent!
            } else {
                break
            }
        }

        return join(ss, separator: " -> ")
    }

    public fn create_scope(
        mut this
        parent_scope_id: ScopeId?
        can_throw: bool
        debug_name: String
        module_id: ModuleId
        for_block: bool = true
    ) -> ScopeId {
        mut is_from_generated_code = false
        // Check that parent_scope_id is a valid ScopeId
        if parent_scope_id.has_value() {
            // Check that the ModuleId is valid
            if parent_scope_id!.module_id.id >= .modules.size() {
                .compiler.panic(format("create_scope: parent_scope_id.module is invalid! No module with id {}.", parent_scope_id!.module_id.id))
            }

            // Check that ScopeId.id is valid in the module
            if parent_scope_id!.id >= .modules[parent_scope_id!.module_id.id].scopes.size() {
                .compiler.panic(format("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}.", parent_scope_id!.module_id.id, parent_scope_id!.id))
            }

            let scope = .get_scope(parent_scope_id!)
            is_from_generated_code = scope.is_from_generated_code
        }

        let scope = Scope(
            parent: parent_scope_id
            can_throw
            debug_name
            is_block_scope: for_block
            is_from_generated_code
        )

        .modules[module_id.id].scopes.push(scope)

        return ScopeId(module_id, id: .modules[module_id.id].scopes.size() - 1)
    }

    public fn apply_qualifiers_to_type(
        mut this
        qualifiers: CheckedQualifiers
        anon type_id: TypeId
    ) -> TypeId {
        let type = .get_type(type_id)

        guard qualifiers != type.qualifiers else {
            return type_id
        }

        return .find_or_add_type_id(match type {
            Void => Type::Void(qualifiers)
            Bool => Type::Bool(qualifiers)
            U8 => Type::U8(qualifiers)
            U16 => Type::U16(qualifiers)
            U32 => Type::U32(qualifiers)
            U64 => Type::U64(qualifiers)
            I8 => Type::I8(qualifiers)
            I16 => Type::I16(qualifiers)
            I32 => Type::I32(qualifiers)
            I64 => Type::I64(qualifiers)
            F32 => Type::F32(qualifiers)
            F64 => Type::F64(qualifiers)
            Usize => Type::Usize(qualifiers)
            JaktString => Type::JaktString(qualifiers)
            CChar => Type::CChar(qualifiers)
            CInt => Type::CInt(qualifiers)
            Unknown => Type::Unknown
            Never => Type::Never
            TypeVariable(name, trait_implementations, is_value) => Type::TypeVariable(qualifiers, name, trait_implementations, is_value)
            Dependent(namespace_type, name) => Type::Dependent(qualifiers, namespace_type, name)
            GenericInstance(id, args) => Type::GenericInstance(qualifiers, id, args)
            GenericEnumInstance(id, args) => Type::GenericEnumInstance(qualifiers, id, args)
            GenericTraitInstance(id, args) => Type::GenericTraitInstance(qualifiers, id, args)
            GenericResolvedType(id, args) => Type::GenericResolvedType(qualifiers, id, args)
            Struct(id) => Type::Struct(qualifiers, id)
            Enum(id) => Type::Enum(qualifiers, id)
            RawPtr(id) => Type::RawPtr(qualifiers, id)
            Trait(id) => Type::Trait(qualifiers, id)
            Reference(id) => Type::Reference(qualifiers, id)
            MutableReference(id) => Type::MutableReference(qualifiers, id)
            Function(params, can_throw, return_type_id, pseudo_function_id) => Type::Function(
                qualifiers
                params
                can_throw
                return_type_id
                pseudo_function_id
            )
            Self => Type::Self(qualifiers)
            Const(value) => Type::Const(qualifiers, value)
        }
        module_id: type_id.module
        only_in_current_module: true)
    }

    public fn builtin_implementation_struct(mut this, builtin: BuiltinType, for_module: ModuleId) -> StructId {
        let id = builtin.id()
        mut module = .modules[for_module.id]
        if module.builtin_implementation_structs.contains(id) {
            return module.builtin_implementation_structs[id]
        }

        let scope_id = .create_scope(
            parent_scope_id: None
            can_throw: false
            debug_name: format("builtin({})", builtin.constructor_name())
            module_id: for_module
            for_block: false
        )

        let trait_implementations: [String:[(TraitId, [TypeId])]] = [:]
        let name_span = Span(
            file_id: FileId(id: 0)
            start: 0
            end: 0
        )

        let struct_id = StructId(
            module: for_module
            id: module.structures.size()
        )
        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id), module_id: for_module)

        let struct_ = CheckedStruct(
            name: format("Builtin_{}", builtin.constructor_name())
            name_span
            scope_id
            definition_linkage: DefinitionLinkage::External
            trait_implementations
            record_type: RecordType::Struct(fields: [], super_type: None)
            type_id: struct_type_id
            super_struct_id: None
            implements_type: builtin(builtin)
        )

        module.structures.push(struct_)
        module.builtin_implementation_structs[id] = struct_id

        return struct_id
    }

    public fn get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public fn get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public fn get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public fn get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public fn get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public fn get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public fn get_scope(this, anon id: ScopeId) -> Scope => .modules[id.module_id.id].scopes[id.id]
    public fn get_trait(this, anon id: TraitId) -> CheckedTrait => .modules[id.module.id].traits[id.id]

    public fn prelude_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 0), id: 0)
    public fn prelude_module_id(this) -> ModuleId => ModuleId(id: 0)

    public fn set_loaded_module(mut this, module_name: String, loaded_module: LoadedModule) {
        .loaded_modules.set(
            key: module_name
            value: loaded_module
        )
    }
    public fn get_loaded_module(this, anon module_name: String) -> LoadedModule? {
        return .loaded_modules.get(module_name)
    }

    public fn set_owner_scope_if_needed(mut this, parent_scope_id: ScopeId, overload_set: [FunctionId], span: Span) {
        for overload in overload_set {
            mut function = .get_function(overload)
            if not function.owner_scope.has_value() {
                function.owner_scope = parent_scope_id
                // If the owner scope is generic, record the relevant inferences.
                let scope = .get_scope(parent_scope_id)

                if scope.relevant_type_id is Some(type_id) {
                    let no_defaults: [TypeId?]? = None
                    let no_args: [TypeId] = []

                    let maybe_generics = match .get_type(type_id) {
                        GenericInstance(id, args) | GenericResolvedType(id, args) => {
                            let struct_ = .get_struct(id)
                            yield Some((struct_.generic_parameters, struct_.generic_parameter_defaults, args))
                        }
                        Struct(id) => {
                            let struct_ = .get_struct(id)
                            yield Some((struct_.generic_parameters, struct_.generic_parameter_defaults, no_args))
                        }
                        GenericEnumInstance(id, args) => Some((.get_enum(id).generic_parameters, no_defaults, args))
                        Enum(id) => Some((.get_enum(id).generic_parameters, no_defaults, no_args))
                        GenericTraitInstance(id, args) => Some((.get_trait(id).generic_parameters, no_defaults, args))
                        Trait(id) => Some((.get_trait(id).generic_parameters, no_defaults, no_args))
                        else => None
                    }
                    guard maybe_generics is Some(generics) else {
                        return
                    }

                    mut inferences: [TypeId:TypeId] = [:]
                    let (parameters, declared_defaults, args) = generics

                    let no_type_id: TypeId? = None
                    let empty_defaults = [no_type_id; parameters.size()]
                    let defaults = declared_defaults ?? empty_defaults

                    for i in 0..parameters.size() {
                        let parameter = &parameters[i]
                        let arg = match i < args.size() {
                            true => Some(args[i])
                            false => defaults[i]
                        } ?? parameter.type_id

                        inferences.set(parameter.type_id, arg)
                    }
                    function.owner_scope_generics = inferences
                }
            }
        }
    }

    public fn set_owner_scope_if_needed(mut this, parent_scope_id: ScopeId, var_id: VarId) {
        mut variable = .get_variable(var_id)
        if not variable.owner_scope.has_value() {
            variable.owner_scope = parent_scope_id
        }
    }

    public fn find_var_in_scope(
        this
        scope_id: ScopeId
        var: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> CheckedVariable? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[var, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<CheckedVariable> {
                if not mixin.mixin_vars {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_var = scope.vars.get(var)
                if maybe_var.has_value() {
                    return IterationDecision::Break(value: .get_variable(maybe_var!))
                }
                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_comptime_binding_in_scope(
        this
        scope_id: ScopeId
        anon name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> Value? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<Value> {
                if not mixin.mixin_bindings {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_binding = scope.comptime_bindings.get(name)
                if maybe_binding.has_value() {
                    return IterationDecision::Break(value: maybe_binding!)
                }
                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_type_scope(
        this
        scope_id: ScopeId
        name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> (TypeId, ScopeId)? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<(TypeId, ScopeId)> {
                if not mixin.mixin_types {
                    return IterationDecision::Continue
                }

                let maybe_type = .get_scope(mixin.scope_id).types.get(name)
                if maybe_type.has_value() {
                    return IterationDecision::Break(value: (maybe_type!, mixin.scope_id))
                }
                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_type_in_scope(
        this
        scope_id: ScopeId
        name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> TypeId? {
        return .find_type_scope(scope_id, name, ignore_mixin_scopes, root_scope)?.0
    }

    public fn find_enum_in_scope(
        this
        scope_id: ScopeId
        name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> EnumId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<EnumId> {
                if not mixin.mixin_enums {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_enum = scope.enums.get(name)
                if maybe_enum.has_value() {
                    return IterationDecision::Break(value: maybe_enum!)
                }
                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_trait_in_scope(
        this
        scope_id: ScopeId
        name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> TraitId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<TraitId> {
                if not mixin.mixin_traits {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_trait = scope.traits.get(name)
                if maybe_trait.has_value() {
                    return IterationDecision::Break(value: maybe_trait!)
                }
                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public fn is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public fn is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public fn is_string(this, anon type_id: TypeId) throws -> bool => match .get_type(type_id) {
        JaktString => true
        Struct(struct_id) => .find_struct_in_prelude("String").equals(struct_id)
        else => false
    }

    public fn get_bits(this, anon type_id: TypeId) -> i64 => .get_type(type_id).get_bits()

    public fn is_signed(this, anon type_id: TypeId) -> bool => .get_type(type_id).is_signed()

    private fn for_each_scope_accessible_unqualified_from_scope_direct_chain(
        this
        scope_id: ScopeId
        anon callback: &fn(mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<bool>
        root_scope: ScopeId?
    ) throws -> bool? {
        // Only scan the direct chain of scopes, not the entire tree

        mut scopes_to_check = Queue<ResolutionMixin>()
        mut seen: {ScopeId} = {}

        scopes_to_check.enqueue(ResolutionMixin(scope_id))
        for child in .get_scope(scope_id).children {
            scopes_to_check.enqueue(ResolutionMixin(scope_id: child))
        }

        while not scopes_to_check.is_empty() {
            let mixin = scopes_to_check.dequeue()
            let scope_id = mixin.scope_id

            if seen.contains(scope_id) {
                continue
            }

            seen.add(scope_id)

            let res = callback(mixin, name_override: None, is_alias: false)
            match res {
                Break(value) => {
                    return Some(value)
                }
                else => {}
            }

            let scope = .get_scope(scope_id)

            if not (root_scope.has_value() and scope_id == root_scope!) and scope.parent.has_value() {
                scopes_to_check.enqueue(ResolutionMixin(scope_id: scope.parent!))
            }

            if scope.namespace_name.has_value() {
                continue
            }

            for child in scope.children {
                scopes_to_check.enqueue(ResolutionMixin(scope_id: child))
            }
        }

        return None
    }

    private fn for_each_scope_accessible_unqualified_from_scope_impl(
        this
        scope_id: ScopeId
        anon callback: &fn(mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<bool>
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> bool? {
        if ignore_mixin_scopes {
            return .for_each_scope_accessible_unqualified_from_scope_direct_chain(scope_id, callback, root_scope)
        }

        // Effect:
        // - (1) Visit the current scope, and all its immediate children unconditionally
        // - (2) Visit the immediate children of any anonymous scope that has already been visited
        // - (3) Visit the parent of any scope that has already been visited
        // - (4) Visit all mixin scopes of any scope that has already been visited, and all their children
        // - (5) Visit all aliases in any scope that has already been visited
        //
        // Example:
        //  A (ns=None) {
        //      B (ns=None) {
        //          D
        //          use H as X
        //      }
        //      F (ns=F) {
        //          G
        //      }
        //      H (ns=H) {
        //          I
        //      }
        //      C (ns=C) {
        //          E
        //      }
        //  }
        // Scanning from C:
        // - (1) Visit C, E
        // - (3) Visit A
        // - (2) Visit B, F, H
        // - (2) Visit D
        // - (5) Visit X (alias for H)
        // - Done
        //
        // Algorithm:
        // - Add the current scope and all its children to a queue
        // - While the queue is not empty:
        // - - Pop the first scope from the queue -> scope
        // - - If the scope has already been visited, skip it
        // - - Visit the scope
        // - - Add the scope's parent to the queue
        // - - If the scope is anonymous, add its children to the queue
        // - - Add the scope's mixins to the queue
        // - - Visit the scope's aliases

        mut scopes_to_check = Queue<ResolutionMixin>()
        mut seen: {ScopeId} = {}

        scopes_to_check.enqueue(ResolutionMixin(scope_id))
        for child in .get_scope(scope_id).children {
            scopes_to_check.enqueue(ResolutionMixin(scope_id: child))
        }

        while not scopes_to_check.is_empty() {
            let mixin = scopes_to_check.dequeue()
            let scope_id = mixin.scope_id

            if seen.contains(scope_id) {
                continue
            }

            seen.add(scope_id)

            let res = callback(mixin, name_override: None, is_alias: false)
            match res {
                Break(value) => {
                    return Some(value)
                }
                else => {}
            }

            let scope = .get_scope(scope_id)

            if not (root_scope.has_value() and scope_id == root_scope!) and scope.parent.has_value() {
                scopes_to_check.enqueue(ResolutionMixin(scope_id: scope.parent!))
            }

            for child in scope.children {
                if not .get_scope(child).namespace_name.has_value() {
                    scopes_to_check.enqueue(ResolutionMixin(scope_id: child))
                }
            }

            for entry in scope.resolution_mixins {
                scopes_to_check.enqueue(entry)
            }

            for (name, alias) in scope.aliases {
                let res = callback(mixin: ResolutionMixin(scope_id: alias), name_override: name, is_alias: true)
                match res {
                    Break(value) => {
                        return Some(value)
                    }
                    else => {}
                }
            }
        }

        // if we do not find it then check imports
        mut search_scope_id: ScopeId? = scope_id
        while search_scope_id.has_value() {
            let search_scope = .get_scope(search_scope_id!)
            for (name, module) in search_scope.imports {
                let import_scope_id = ScopeId(module_id: module, id: 0)
                let res = callback(mixin: ResolutionMixin(scope_id: import_scope_id), name_override: name, is_alias: false)
                match res {
                    Break(value) => {
                        return Some(value)
                    }
                    else => {}
                }
            }
            search_scope_id = search_scope.parent
        }

        return None

    }

    public fn for_each_scope_accessible_unqualified_from_scope<T>(
        this
        scope_id: ScopeId
        anon callback: &fn(mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<T>
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> T? {
        mut result: T? = None
        .for_each_scope_accessible_unqualified_from_scope_impl(
            scope_id
            &fn[&mut callback, &mut result](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<bool> {
                match callback(mixin, name_override, is_alias) {
                    Break(value) => {
                        result = value
                        return IterationDecision::Break(value: true)
                    }
                    Continue => {
                        return IterationDecision::Continue
                    }
                }
            }
            ignore_mixin_scopes
            root_scope
        )

        return result
    }

    public fn find_struct_in_scope(
        this
        scope_id: ScopeId
        name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> StructId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<StructId> {
                if not mixin.mixin_structs {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_struct = scope.structs.get(name)
                if maybe_struct.has_value() {
                    return IterationDecision::Break(value: maybe_struct!)
                }

                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let struct_id = .find_struct_in_scope(scope_id, name, ignore_mixin_scopes: true)
        if struct_id.has_value() {
            return struct_id.value()
        }

        .compiler.panic(format("internal error: {} builtin definition not found", name))
    }

    public fn is_scope_directly_accessible_from(this, check_scope_id: ScopeId, scope_id: ScopeId, ignore_mixin_scopes: bool = false) throws -> bool {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[check_scope_id](mixin: ResolutionMixin, name_override: String?, is_alias: bool) throws -> IterationDecision<bool> {
                if check_scope_id.equals(mixin.scope_id) {
                    return IterationDecision::Break(value: true)
                }

                return IterationDecision::Continue
            }
            ignore_mixin_scopes
        ) ?? false
    }

    public fn find_reflected_primitive(this, anon primitive: String) throws -> StructOrEnumId {
        let scope_id = .prelude_scope_id()
        let maybe_namespace = .find_namespace_in_scope(scope_id, "Reflect", ignore_mixin_scopes: true)
        if not maybe_namespace.has_value() {
            .compiler.panic(format("internal error: builtin namespace 'Reflect' not found"))
        }

        let reflect_namespace_scope_id = maybe_namespace!.0
        let enum_id = .find_enum_in_scope(scope_id: reflect_namespace_scope_id, name: primitive)
        if enum_id.has_value() {
            return StructOrEnumId::Enum(enum_id!)
        }

        let struct_id = .find_struct_in_scope(scope_id: reflect_namespace_scope_id, name: primitive)
        if struct_id.has_value() {
            return StructOrEnumId::Struct(struct_id!)
        }

        .compiler.panic(format("internal error: definition for reflect builtin '{}' not found", primitive))
    }

    public fn find_type_scope_id(mut this, anon type_id: TypeId) -> ScopeId {
        let type = .get_type(type_id)
        return match type {
            Struct(struct_id) | GenericInstance(id: struct_id) => .get_struct(struct_id).scope_id
            Enum(enum_id) | GenericEnumInstance(id: enum_id) => .get_enum(enum_id).scope_id
            Trait(trait_id) | GenericTraitInstance(id: trait_id) => .get_trait(trait_id).scope_id
            else => match type.is_builtin() {
                true => .get_struct(.builtin_implementation_struct(builtin: type.as_builtin_type(), for_module: .prelude_module_id())).scope_id
                false => .prelude_scope_id()
            }
        }
    }

    public fn find_namespace_in_immediate_children_of_scope(
        this
        scope_id: ScopeId
        anon name: String
        treat_aliases_as_imports: bool = false
    ) -> ScopeId? {
        let scope = .get_scope(scope_id)
        for child in scope.children {
            let child_scope = .get_scope(child)
            if child_scope.namespace_name.has_value() and child_scope.namespace_name! == name {
                return child
            }
        }
        if treat_aliases_as_imports {
            if scope.aliases.contains(name) {
                return scope.aliases.get(name)
            }
        }
        return None
    }

    public fn find_namespace_in_scope(
        this
        scope_id: ScopeId
        anon name: String
        treat_aliases_as_imports: bool = false
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> (ScopeId, bool)? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, treat_aliases_as_imports, this](
                mixin: ResolutionMixin
                name_override: String?
                is_alias: bool
            ) throws -> IterationDecision<(ScopeId, bool)> {
                let scope = .get_scope(mixin.scope_id)
                let effective_name = name_override ?? scope.namespace_name
                let is_import = name_override.has_value() and not is_alias
                if effective_name.has_value() and effective_name! == name {
                    return IterationDecision::Break(value: (mixin.scope_id, is_import or (is_alias and treat_aliases_as_imports)))
                }

                for child in scope.children {
                    let child_scope = .get_scope(child)
                    let effective_name = name_override ?? child_scope.namespace_name
                    if effective_name.has_value() and effective_name! == name {
                        return IterationDecision::Break(value: (child, false))
                    }
                }

                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )
    }

    public fn find_function_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        root_scope: ScopeId? = None
    ) throws -> FunctionId? {
        let results = .find_functions_with_name_in_scope(parent_scope_id, function_name, root_scope)
        if not results.has_value() {
            return None
        }

        let functions = results.value()
        if functions.size() != 1 {
            .compiler.panic(format("internal error: found {} functions with name '{}', but expected 1", functions.size(), function_name))
        }

        return functions[0]
    }

    public fn find_default_constructors_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        root_scope: ScopeId? = None
    ) throws -> FunctionId? {
        let results = .find_functions_with_name_in_scope(parent_scope_id, function_name, root_scope)
        if not results.has_value() {
            return None
        }

        for id in results.value() {
            let function = .get_function(id)
            if function.type is ImplicitConstructor {
                return id
            }
        }

        return None
    }

    public fn find_functions_with_name_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> [FunctionId]? {
        return .find_scoped_functions_with_name_in_scope(parent_scope_id, function_name, ignore_mixin_scopes, root_scope)?.0
    }

    public fn find_scoped_functions_with_name_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        ignore_mixin_scopes: bool = false
        root_scope: ScopeId? = None
    ) throws -> ([FunctionId], ScopeId)? {
        mut result_ids: [FunctionId] = []
        mut result_scope: ScopeId? = None
        .for_each_scope_accessible_unqualified_from_scope(
            scope_id: parent_scope_id
            &fn[function_name, &mut result_ids, &mut result_scope, this](
                mixin: ResolutionMixin
                name_override: String?
                is_alias: bool
            ) throws -> IterationDecision<([FunctionId], ScopeId)> {
                if not mixin.mixin_functions {
                    return IterationDecision::Continue
                }

                let scope = .get_scope(mixin.scope_id)
                let maybe_functions = scope.functions.get(function_name)
                if maybe_functions.has_value() {
                    result_ids.push_values(&maybe_functions!)
                    if not result_scope.has_value() {
                        result_scope = mixin.scope_id
                    }
                }

                return IterationDecision::Continue
            }
            ignore_mixin_scopes
            root_scope
        )

        if result_scope is None {
            return None
        }

        return (result_ids, result_scope!)
    }

    // Checks given struct id is weak ptr and
    //  validates args are compatible with weak ptr type
    // Returns the inner struct id if given struct is weak ptr
    public fn check_and_extract_weak_ptr(this, struct_id: StructId, args: [TypeId]) throws -> StructId? {
        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

        if struct_id.equals(weak_ptr_struct_id) {
            if (args.size() != 1) {
                .compiler.panic(
                    format(
                        "Internal error: Generic type is WeakPtr but there are not exactly 1 type parameter. There are {} parameters.",
                        args.size()
                    )
                )
            }

            let inner_type_id = args[0]
            let inner_type = .get_type(inner_type_id)

            if inner_type is Struct(inner_struct_id) {
                return inner_struct_id
            }
            panic(
                format(
                    "Internal error: Inner type of WeakPtr is not a struct. It is {}.",
                    inner_type
                )
            )
        } else {
            return None
        }
    }

    public fn type_name(this, anon type_id: TypeId, debug_mode: bool = false) throws -> String {
        let type = .get_type(type_id)

        return match type.qualifiers.is_immutable {
            true => "const "
            false => ""
        } + match debug_mode {
            true => format("({}@{}) ", type_id.id, type_id.module.id) + match type {
                TypeVariable => "var "
                else => ""
            }
            else => ""
        } + match type {
            Never => "never"
            F32 => "f32"
            F64 => "f64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            Void => "void"
            Unknown => "unknown"
            JaktString => "builtin(String)"
            Dependent(namespace_type, name) => format(
                "{}::{}"
                .type_name(namespace_type, debug_mode)
                name
            )
            Trait(id) => .get_trait(id).name
            Self => "Self"
            Function(params, return_type_id) => {
                mut param_names: [String] = []
                for x in params {
                    param_names.push(.type_name(x, debug_mode))
                }

                let return_type = .type_name(return_type_id, debug_mode)

                yield format("fn({}) -> {}", join(param_names, separator: ", "), return_type)
            }
            Enum(id) => .get_enum(id).name
            Struct(id) => .get_struct(id).name
            GenericEnumInstance(id, args) => {
                mut output = format("enum {}", .get_enum(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg, debug_mode)
                }

                output += ">"

                yield output
            }
            GenericTraitInstance(id, args) => {
                mut output = format("trait {}", .get_trait(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg, debug_mode)
                }

                output += ">"

                yield output
            }
            GenericInstance(id, args) => {

                let array_struct_id = .find_struct_in_prelude("Array")
                let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
                let optional_struct_id = .find_struct_in_prelude("Optional")
                let range_struct_id = .find_struct_in_prelude("Range")
                let set_struct_id = .find_struct_in_prelude("Set")
                let tuple_struct_id = .find_struct_in_prelude("Tuple")
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                mut output = ""

                if id.equals(array_struct_id) {
                    output = format("[{}]", .type_name(args[0], debug_mode))
                } else if id.equals(dictionary_struct_id) {
                    output = format("[{}:{}]", .type_name(args[0], debug_mode), .type_name(args[1], debug_mode))
                } else if id.equals(optional_struct_id) {
                    output = format("{}?", .type_name(args[0], debug_mode))
                } else if id.equals(range_struct_id) {
                    output = format("{}..{}", .type_name(args[0], debug_mode), .type_name(args[0], debug_mode))
                } else if id.equals(set_struct_id) {
                    output = format("{{{}}}", .type_name(args[0], debug_mode))
                } else if id.equals(tuple_struct_id) {
                    output = "("
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg, debug_mode)
                    }
                    output += ")"
                } else if id.equals(weak_ptr_struct_id) {
                    output = format("weak {}", .type_name(args[0], debug_mode))
                } else {
                    let structure = .get_struct(id)
                    output = structure.name
                    output += "<"
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg, debug_mode)
                    }
                    output += ">"
                }

                yield output
            }
            GenericResolvedType(id, args) => {
                mut output = .get_struct(id).name
                mut first = true
                output += "<"
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }
                    output += .type_name(type_id, debug_mode)
                }
                output += ">"

                yield output
            }
            TypeVariable(name) => name
            RawPtr(type_id) => format("raw {}", .type_name(type_id, debug_mode))
            Reference(type_id) => format("&{}", .type_name(type_id, debug_mode))
            MutableReference(type_id) => format("&mut {}", .type_name(type_id, debug_mode))
            Const(value) => comptime_format_impl(format_string: "comptime {}", arguments: [value][..], program: &this)
        }
    }

    public fn find_or_add_type_id(mut this, anon type: Type, module_id: ModuleId, only_in_current_module: bool = false) -> TypeId {
        if only_in_current_module {
            let types = &.get_module(module_id).types
            for id in 0..types.size() {
                if types[id].equals(type) {
                    return TypeId(module: module_id, id)
                }
            }
        } else {
            for module in .modules {
                for id in 0..module.types.size() {
                    if module.types[id].equals(type) {
                        return TypeId(module: module.id, id)
                    }
                }
            }
        }

        .modules[module_id.id].types.push(type)

        return TypeId(module: module_id, id: .modules[module_id.id].types.size() - 1)
    }

    public fn substitute_typevars_in_type(
        mut this
        type_id: TypeId
        generic_inferences: GenericInferences
        module_id: ModuleId
    ) throws -> TypeId {
        mut result = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

        loop {
            let fixed_point = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

            if fixed_point.equals(result) {
                break
            } else {
                result = fixed_point
            }
        }

        return result
    }

    fn substitute_typevars_in_type_helper(
        mut this
        type_id: TypeId
        generic_inferences: GenericInferences
        module_id: ModuleId
    ) throws -> TypeId {
        let type_ = .get_type(type_id)

        match type_ {
            TypeVariable => {
                let replacement_type_id = generic_inferences.get(type_id)
                if replacement_type_id.has_value() {
                    return replacement_type_id!
                }
            }
            Dependent(namespace_type, name) => {
                let mapped_type_id = .substitute_typevars_in_type(type_id: namespace_type, generic_inferences, module_id)
                let type = .get_type(mapped_type_id)
                if type is TypeVariable {
                    return .find_or_add_type_id(
                        type: Type::Dependent(namespace_type: mapped_type_id, name)
                        module_id
                    )
                }

                let struct_like_id = StructLikeId::from_type_id(mapped_type_id, &this)
                guard struct_like_id.has_value() else {
                    return type_id
                }

                let scope_id = struct_like_id!.associated_scope_id(&this)
                let found_type = .find_type_in_scope(scope_id, name)
                if found_type.has_value() {
                    mut copied_inferences = generic_inferences
                    if struct_like_id!.generic_arguments.has_value() {
                        copied_inferences.set_all(
                            keys: struct_like_id!.generic_parameters_as_checked(&this)
                            values: struct_like_id!.generic_arguments!
                        )
                    }

                    return .substitute_typevars_in_type(
                        type_id: found_type!
                        generic_inferences: copied_inferences
                        module_id
                    )
                }

                return type_id
            }
            GenericTraitInstance(id, args) => {
                mut new_args: [TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericTraitInstance(id, args: new_args), module_id)
            }
            GenericInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericInstance(id, args: new_args), module_id)
            }
            GenericEnumInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }
                return .find_or_add_type_id(Type::GenericEnumInstance(id, args: new_args), module_id)
            }
            Struct(struct_id) => {
                let struct_ = .get_struct(struct_id)
                if not struct_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(struct_.generic_parameters.size())
                    for arg in struct_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericInstance(id: struct_id, args: new_args), module_id)
                }
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                if not enum_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(enum_.generic_parameters.size())
                    for arg in enum_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id, args: new_args), module_id)
                }
            }
            RawPtr(rawptr_type_id) => {
                let rawptr_type = Type::RawPtr(
                    .substitute_typevars_in_type(type_id: rawptr_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(rawptr_type, module_id)
            }
            Reference(ref_type_id) => {
                let ref_type = Type::Reference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            MutableReference(ref_type_id) => {
                let ref_type = Type::MutableReference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            Function(params, can_throw, return_type_id, pseudo_function_id) => {
                mut new_params:[TypeId] = []
                new_params.ensure_capacity(params.size())
                mut is_different = false
                for param in params {
                    let new_param = .substitute_typevars_in_type(type_id: param, generic_inferences, module_id)
                    is_different = is_different or not new_param.equals(param)
                    new_params.push(new_param)
                }

                let return_type_substitute = .substitute_typevars_in_type(type_id: return_type_id, generic_inferences, module_id)
                is_different = is_different or not return_type_substitute.equals(return_type_id)

                if not is_different {
                    return type_id
                }

                let previous_function = .get_function(pseudo_function_id)

                mut replacement_params: [CheckedParameter] = []
                for i in 0uz..previous_function.params.size() {
                    let param = previous_function.params[i]
                    let new_param = CheckedParameter(
                        requires_label: param.requires_label
                        variable: CheckedVariable(
                            name: param.variable.name
                            type_id: new_params[i]
                            is_mutable: param.variable.is_mutable
                            definition_span: param.variable.definition_span
                            type_span: param.variable.type_span
                            visibility: param.variable.visibility
                        )
                        default_value_expression: param.default_value_expression
                    )
                    replacement_params.push(new_param)
                }

                let new_function = CheckedFunction(
                    name: previous_function.name
                    name_span: previous_function.name_span
                    visibility: previous_function.visibility
                    return_type_id: return_type_substitute
                    return_type_span: previous_function.return_type_span
                    params: replacement_params
                    generics: previous_function.generics
                    block: previous_function.block
                    can_throw
                    type: previous_function.type
                    linkage: previous_function.linkage
                    function_scope_id: previous_function.function_scope_id
                    struct_id: previous_function.struct_id
                    is_instantiated: previous_function.is_instantiated
                    parsed_function: previous_function.parsed_function
                    is_comptime: previous_function.is_comptime
                    is_virtual: previous_function.is_virtual
                    is_override: previous_function.is_override
                    is_unsafe: previous_function.is_unsafe
                )

                let new_function_id = .modules[module_id.id].add_function(checked_function: new_function)

                return .find_or_add_type_id(Type::Function(params: new_params, can_throw, return_type_id: return_type_substitute, pseudo_function_id: new_function_id), module_id)
            }
            else => {
                return type_id
            }
        }
        return type_id
    }
}

boxed enum ValueImpl {
    Void
    Bool(bool)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    F32(f32)
    F64(f64)
    USize(usize)
    JaktString(String)
    StringView(String)
    CChar(c_char)
    CInt(c_int)
    Struct(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Class(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Enum(fields: [Value], enum_id: EnumId, constructor: FunctionId)
    JaktArray(values: [Value], type_id: TypeId)
    JaktDictionary(keys: [Value], values: [Value], type_id: TypeId)
    JaktSet(values: [Value], type_id: TypeId)
    RawPtr(ValueImpl)
    OptionalSome(value: Value)
    OptionalNone
    JaktTuple(fields: [Value], type_id: TypeId)
    Function(
        captures: [String: Value]
        params: [String: (TypeId, (ParsedExpression, ScopeId)?)]
        return_type_id: TypeId
        type_id: TypeId
        block: CheckedBlock
        can_throw: bool
        checked_params: [CheckedParameter]
        scope_id: ScopeId
        pseudo_function_id: FunctionId?
    )

    fn type_id(this, anon program: &mut CheckedProgram) throws -> TypeId => match this {
        Void => void_type_id()
        Bool => builtin(BuiltinType::Bool)
        U8 => builtin(BuiltinType::U8)
        U16 => builtin(BuiltinType::U16)
        U32 => builtin(BuiltinType::U32)
        U64 => builtin(BuiltinType::U64)
        I8 => builtin(BuiltinType::I8)
        I16 => builtin(BuiltinType::I16)
        I32 => builtin(BuiltinType::I32)
        I64 => builtin(BuiltinType::I64)
        F32 => builtin(BuiltinType::F32)
        F64 => builtin(BuiltinType::F64)
        USize => builtin(BuiltinType::Usize)
        JaktString => program.find_type_in_scope(scope_id: program.prelude_scope_id(), name: "String")!
        StringView => builtin(BuiltinType::JaktString)
        CChar => builtin(BuiltinType::CChar)
        CInt => builtin(BuiltinType::CInt)
        Struct(struct_id) => program.find_or_add_type_id(Type::Struct(struct_id), module_id: struct_id.module)
        Class(struct_id) => program.find_or_add_type_id(Type::Struct(struct_id), module_id: struct_id.module)
        Enum(enum_id) => program.find_or_add_type_id(Type::Enum(enum_id), module_id: enum_id.module)
        else => {
            panic("Reflected value type not implemented")
        }
    }

    fn copy(this) -> ValueImpl => match this {
        Void => ValueImpl::Void
        Bool(x) => ValueImpl::Bool(x)
        U8(x) => ValueImpl::U8(x)
        U16(x) => ValueImpl::U16(x)
        U32(x) => ValueImpl::U32(x)
        U64(x) => ValueImpl::U64(x)
        I8(x) => ValueImpl::I8(x)
        I16(x) => ValueImpl::I16(x)
        I32(x) => ValueImpl::I32(x)
        I64(x) => ValueImpl::I64(x)
        F32(x) => ValueImpl::F32(x)
        F64(x) => ValueImpl::F64(x)
        USize(x) => ValueImpl::USize(x)
        JaktString(x) => ValueImpl::JaktString(x)
        StringView(x) => ValueImpl::StringView(x)
        CChar(x) => ValueImpl::CChar(x)
        CInt(x) => ValueImpl::CInt(x)
        Struct(fields, struct_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Struct(fields: fields_copy, struct_id, constructor)
        }
        Class(fields, struct_id, constructor) => ValueImpl::Class(fields, struct_id, constructor)
        Enum(fields, enum_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Enum(fields: fields_copy, enum_id, constructor)
        }
        JaktArray(values, type_id) => {
            mut values_copy: [Value] = [];
            for value in values {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktArray(values: values_copy, type_id)
        }
        JaktDictionary(keys, values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            mut keys_copy: [Value] = []
            for key in keys {
                keys_copy.push(key.copy())
            }
            yield ValueImpl::JaktDictionary(keys: keys_copy, values: values_copy, type_id)
        }
        JaktSet(values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            yield ValueImpl::JaktSet(values: values_copy, type_id)
        }
        RawPtr(value) => ValueImpl::RawPtr(value)
        OptionalSome(value) => ValueImpl::OptionalSome(value: value.copy())
        OptionalNone => ValueImpl::OptionalNone
        JaktTuple(fields, type_id) => {
            mut values_copy: [Value] = [];
            for value in fields {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktTuple(fields: values_copy, type_id)
        }
        Function(
            captures
            params
            can_throw
            return_type_id
            type_id
            block
            checked_params
            scope_id
            pseudo_function_id
        ) => ValueImpl::Function(
            captures
            params
            return_type_id
            type_id
            block
            can_throw
            checked_params
            scope_id
            pseudo_function_id
        )
    }

    fn equals(this, anon other: ValueImpl) -> bool => match this {
        Void => other is Void
        Bool(x) => match other { Bool(y) => x == y else => false }
        U8(x) => match other { U8(y) => x == y else => false }
        U16(x) => match other { U16(y) => y == x else => false }
        U32(x) => match other { U32(y) => y == x else => false }
        U64(x) => match other { U64(y) => y == x else => false }
        I8(x) => match other { I8(y) => y == x else => false }
        I16(x) => match other { I16(y) => y == x else => false }
        I32(x) => match other { I32(y) => y == x else => false }
        I64(x) => match other { I64(y) => y == x else => false }
        F32(x) => match other { F32(y) => y == x else => false }
        F64(x) => match other { F64(y) => y == x else => false }
        USize(x) => match other { USize(y) => y == x else => false }
        JaktString(x) => match other { JaktString(y) => y == x else => false }
        StringView(x) => match other { StringView(y) => y == x else => false }
        CChar(x) => match other { CChar(y) => y == x else => false }
        CInt(x) => match other { CInt(y) => y == x else => false }
        else => false
    }
}

struct Value {
    impl: ValueImpl
    span: Span

    fn copy(this) -> Value => Value(impl: .impl.copy(), span: .span)
    fn type_name(this) -> String => match .impl {
        Void => "void"
        Bool => "bool"
        U8 => "u8"
        U16 => "u16"
        U32 => "u32"
        U64 => "u64"
        I8 => "i18"
        I16 => "i16"
        I32 => "i32"
        I64 => "i64"
        F32 => "f32"
        F64 => "f64"
        USize => "usize"
        JaktString => "String"
        StringView => "StringView"
        CChar => "c_char"
        CInt => "c_int"
        Struct => "struct <T>"
        Class => "class <T>"
        Enum => "enum <T>"
        JaktArray => "Array"
        JaktDictionary => "Dictionary"
        JaktSet => "Set"
        RawPtr => "raw <T>"
        OptionalSome => "Some"
        OptionalNone => "None"
        JaktTuple => "Tuple"
        Function => "Function"
    }

    fn cast(this, anon expected: Value, span: Span) -> Value => match .impl {
        U8(value) => match expected.impl {
            U16 => Value(impl: ValueImpl::U16(value as! u16), span: span)
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U16(value) => match expected.impl {
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U32(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        I8(value) => match expected.impl {
            I16 => Value(impl: ValueImpl::I16(value as! i16), span: span)
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I16(value) => match expected.impl {
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I32(value) => match expected.impl {
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span) // yuck
            else => this
        }
        USize(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            // No idea why this is allowed.
            CInt => Value(impl: ValueImpl::CInt(value as! c_int), span: span)
            else => this
        }
        OptionalSome => this
        else => match expected.impl {
            OptionalSome | OptionalNone => Value(impl: ValueImpl::OptionalSome(value: this), span: span)
            else => this
        }
    }
}

enum NumericOrStringValue {
    StringValue(String)
    SignedNumericValue(i64)
    UnsignedNumericValue(u64)
}

class TypecheckFunctions {
    public block: fn(
        parsed_block: ParsedBlock
        parent_scope_id: ScopeId
        safety_mode: SafetyMode
        yield_type_hint: TypeId? = None
        containing_function_id: FunctionId? = None
    ) throws -> CheckedBlock

    public register_function: fn(
        checked_function: CheckedFunction
    ) throws -> FunctionId
}

fn format_value_impl(anon format_string: String, anon value: Value, program: &CheckedProgram) throws -> String => match value.impl {
    Bool(v)
    | U8(v)
    | U16(v)
    | U32(v)
    | U64(v)
    | USize(v)
    | I8(v)
    | I16(v)
    | I32(v)
    | I64(v)
    | F32(v)
    | F64(v)
    | CChar(v)
    | CInt(v)
    | JaktString(v)
    | StringView(v)
    => format(format_string, v)

    Void => format(format_string, "(void)")

    Struct(fields, struct_id, constructor)
    | Class(fields, struct_id, constructor)
    => {
        let structure = program.get_struct(struct_id)
        mut builder = StringBuilder::create()
        mut field_names: [String] = []

        builder.append(structure.name)
        if constructor.has_value() {
            let function = program.get_function(constructor!)
            builder.append("::")
            builder.append(function.name)
            for parameter in function.params {
                field_names.push(parameter.variable.name)
            }
        } else {
            for field in structure.fields {
                field_names.push(program.get_variable(field.variable_id).name)
            }
        }
        builder.append('(')
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(field_names[index])
            builder.append(": ")
            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(')')
        yield builder.to_string()
    }

    Enum(fields, enum_id, constructor) => {
        let enum_ = program.get_enum(enum_id)
        let function = program.get_function(constructor)
        mut builder = StringBuilder::create()
        mut field_names: [String] = []

        builder.append(enum_.name)
        builder.append("::")
        builder.append(function.name)
        for parameter in function.params {
            field_names.push(parameter.variable.name)
        }

        builder.append('(')
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(field_names[index])
            builder.append(": ")
            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(')')
        yield builder.to_string()
    }

    OptionalSome(value) => format_value_impl(
        format_string: format("Some({})", format_string)
        value
        program
    )
    OptionalNone => format(format_string, "None")

    JaktTuple(fields)
    | JaktArray(values: fields)
    | JaktSet(values: fields) => {
        mut builder = StringBuilder::create()
        let surrounding = match value.impl {
            JaktTuple => ('(', ')')
            JaktArray => ('[', ']')
            JaktSet => ('{', '}')
            else => {
                abort()
            }
        }
        builder.append(surrounding.0)
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(surrounding.1)
        yield builder.to_string()
    }

    JaktDictionary(keys, values) => {
        mut builder = StringBuilder::create()
        builder.append('[')
        mut index = 0uz
        for key in keys {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(format_value_impl(format_string, key, program))
            builder.append(": ")
            builder.append(format_value_impl(format_string, values[index], program))

            index += 1
        }

        builder.append(']')
        yield builder.to_string()
    }

    else => {
        eprintln("Cannot format value {}", value.impl)
        throw Error::from_string_literal("Cannot format value of this type")
    }
}

fn comptime_format_impl(format_string: String, arguments: ArraySlice<Value>, program: &CheckedProgram) throws -> String {
    mut builder = StringBuilder::create()
    mut current_argument_index = 0uz
    mut format_field_builder = StringBuilder::create()
    mut index_in_field: usize? = None
    mut expect_close_brace = false

    let argument_and_index = fn(anon str: String) -> (usize?, String) {
        mut slice_end = 0uz
        mut has_index = false
        for code_point in str.code_points() {
            guard code_point >= '0' and code_point <= '9' else {
                break
            }
            slice_end += 1
            has_index = true
        }

        if has_index {
            let index_str = str.substring(start: 0, length: slice_end)
            let index = index_str.to_number<u32>()
            if index.has_value() {
                return (index! as! usize, str.substring(start: slice_end, length: str.length() - slice_end))
            }
        }

        return (None, str)
    }

    for code_point in format_string.code_points() {
        match code_point {
            '{' => {
                if index_in_field.has_value() and index_in_field! == 0 {
                    builder.append('{')
                    index_in_field = None
                } else if index_in_field.has_value() {
                    format_field_builder.append('{')
                    index_in_field = index_in_field! + 1
                } else {
                    index_in_field = 0
                }
            }
            '}' => {
                if expect_close_brace {
                    builder.append('}')
                    expect_close_brace = false
                } else if not index_in_field.has_value() {
                    expect_close_brace = true
                } else {
                    index_in_field = None
                    let fmt_string = format_field_builder.to_string()
                    format_field_builder.clear()
                    let (index, format_string) = argument_and_index(fmt_string)
                    let effective_index = index ?? current_argument_index++
                    if effective_index >= arguments.size() {
                        throw Error::from_string_literal("Not enough arguments for format string")
                    }

                    let effective_format_string = format("{{{}}}", format_string)

                    builder.append(format_value_impl(effective_format_string, arguments[effective_index], program))
                }
            }
            else => {
                if index_in_field.has_value() {
                    format_field_builder.append(code_point)
                } else {
                    builder.append(code_point)
                }
            }
        }
    }

    return builder.to_string()
}
