import parser {
    ArgumentStoreLevel, BinaryOperator, DefinitionLinkage, EnumVariantPatternArgument, ExternalName, FunctionLinkage
    FunctionType, IncludeAction, InlineState, ParsedBlock, ParsedCall, ParsedCapture, ParsedExpression
    ParsedExternImport, ParsedField, ParsedFunction, ParsedMatchBody, ParsedMatchCase, ParsedModuleImport
    ParsedNamespace, ParsedParameter, ParsedRecord, ParsedStatement, ParsedType, ParsedVarDecl, Parser, RecordType
    TypeCast, UnaryOperator
}
import utility { FileId, IterationDecision, Queue, Span, join, panic, todo }
import compiler { Compiler }
import ids { EnumId, FunctionId, ModuleId, ScopeId, StructId, TraitId, TypeId, VarId }

enum StructOrEnumId {
    Struct(StructId)
    Enum(EnumId)
}

enum StructLikeId {
    generic_arguments: [TypeId]? = None

    Struct(StructId)
    Enum(EnumId)
    Trait(TraitId)

    fn generic_parameters(this, anon program: &CheckedProgram) throws -> [TypeId] {
        let parameters = match this {
            Struct(id) => program.get_struct(id).generic_parameters
            Enum(id) => program.get_enum(id).generic_parameters
            Trait(id) => program.get_trait(id).generic_parameters
        }
        mut result: [TypeId] = []
        for parameter in parameters {
            result.push(parameter.type_id)
        }
        return result
    }

    fn scope_id(this, anon program: &CheckedProgram) throws -> ScopeId => match this {
        Struct(id) => program.get_struct(id).scope_id
        Enum(id) => program.get_enum(id).scope_id
        Trait(id) => program.get_trait(id).scope_id
    }
}

struct GenericInferences {
    values: [TypeId:TypeId]

    fn set(mut this, anon key: TypeId, anon value: TypeId) throws {
        if key == value {
            println("Warning: Generic parameter {} is being bound to itself", key)
            abort()
        }

        let mapped_value = .map(value)
        if key == mapped_value {
            return
        }

        .values[key] = mapped_value
    }

    fn set_all(mut this, keys: [CheckedGenericParameter], values: [TypeId]) throws {
        for i in 0..(keys.size()) {
            let key = keys[i].type_id
            let value = values[i]
            .set(key, value)
        }
    }

    fn get(this, anon key: TypeId) -> TypeId? {
        return .values.get(key)
    }

    fn map(this, anon type: TypeId) -> TypeId {
        mut mapped = .values.get(type)
        mut final_mapped_result = mapped
        while mapped.has_value() {
            final_mapped_result = mapped
            mapped = .values.get(mapped!)
        }
        return final_mapped_result ?? type
    }

    fn find_and_map(this, anon name: String, anon program: &CheckedProgram) throws -> TypeId? {
        for (type_id, v) in .values {
            if program.get_type(type_id) is TypeVariable(name: var_name) and var_name == name {
                return .map(v)
            }
        }

        return None
    }

    fn iterator(this) -> [TypeId:TypeId] => .values

    fn perform_checkpoint(mut this, reset: bool = true) throws -> [TypeId:TypeId] {
        let result = .values
        .values = [:]

        if not reset {
            for (key, value) in result {
                .values[key] = value
            }
        }

        return result
    }

    fn restore(mut this, anon checkpoint: [TypeId:TypeId]) {
        .values = checkpoint
    }

    fn set_from(mut this, anon checkpoint: [TypeId:TypeId]) throws {
        for (key, value) in checkpoint {
            .set(key, value)
        }
    }

    fn debug_description(this, anon program: &CheckedProgram) throws {
        eprintln("Generic inferences:")
        for (key, value) in .values {
            eprintln(
                "  {} => {}"
                program.type_name(key, debug_mode: true)
                program.type_name(value, debug_mode: true)
            )
        }
    }
}

enum SafetyMode {
    Safe
    Unsafe
}

enum BuiltinType {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never

    fn id(this) -> usize => match this {
        Void => 0uz
        Bool => 1uz
        U8 => 2uz
        U16 => 3uz
        U32 => 4uz
        U64 => 5uz
        I8 => 6uz
        I16 => 7uz
        I32 => 8uz
        I64 => 9uz
        F32 => 10uz
        F64 => 11uz
        Usize => 12uz
        JaktString => 13uz
        CChar => 14uz
        CInt => 15uz
        Unknown => 16uz
        Never => 17uz
    }

    fn constructor_name(this) throws -> String => match this {
        Void => "Void"
        Bool => "Bool"
        U8 => "U8"
        U16 => "U16"
        U32 => "U32"
        U64 => "U64"
        I8 => "I8"
        I16 => "I16"
        I32 => "I32"
        I64 => "I64"
        F32 => "F32"
        F64 => "F64"
        Usize => "Usize"
        JaktString => "JaktString"
        CChar => "CChar"
        CInt => "CInt"
        Unknown => "Unknown"
        Never => "Never"
    }
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never
    TypeVariable(name: String, trait_implementations: [TypeId])
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    GenericTraitInstance(id: TraitId, args: [TypeId])
    GenericResolvedType(id: StructId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    RawPtr(TypeId)
    Trait(TraitId)
    Reference(TypeId)
    MutableReference(TypeId)
    Function(params: [TypeId], can_throw: bool, return_type_id: TypeId, pseudo_function_id: FunctionId)
    Self


    fn is_boxed(this, program: CheckedProgram) -> bool => match this {
        Struct(struct_id) | GenericInstance(id: struct_id) => program.get_struct(struct_id).record_type is Class
        Enum(enum_id) | GenericEnumInstance(id: enum_id) => program.get_enum(enum_id).is_boxed
        else => false
    }

    fn is_concrete(this) -> bool => match this {
        TypeVariable | Self | Unknown => false
        else => true
    }

    fn specificity(this, program: CheckedProgram, base_specificity: i64 = 1<<31) -> i64 => match this {
        TypeVariable => 0
        GenericInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericEnumInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericResolvedType(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        Function(params) => {
            mut specificity = base_specificity / 2
            for subtype_id in params.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        else => base_specificity
    }

    fn constructor_name(this) throws -> String => match this {
        Void => "Void"
        Bool => "Bool"
        U8 => "U8"
        U16 => "U16"
        U32 => "U32"
        U64 => "U64"
        I8 => "I8"
        I16 => "I16"
        I32 => "I32"
        I64 => "I64"
        F32 => "F32"
        F64 => "F64"
        Usize => "Usize"
        JaktString => "JaktString"
        CChar => "CChar"
        CInt => "CInt"
        Unknown => "Unknown"
        Never => "Never"
        TypeVariable => "TypeVariable"
        GenericInstance => "GenericInstance"
        GenericEnumInstance => "GenericEnumInstance"
        GenericTraitInstance => "GenericTraitInstance"
        GenericResolvedType => "GenericResolvedType"
        Struct => "Struct"
        Enum => "Enum"
        RawPtr => "RawPtr"
        Trait => "Trait"
        Reference => "Reference"
        MutableReference => "MutableReference"
        Function => "Function"
        Self => "Self"
    }

    fn equals(this, anon rhs: Type) -> bool => match this {
        Void => rhs is Void
        Bool => rhs is Bool
        U8 => rhs is U8
        U16 => rhs is U16
        U32 => rhs is U32
        U64 => rhs is U64
        I8 => rhs is I8
        I16 => rhs is I16
        I32 => rhs is I32
        I64 => rhs is I64
        F32 => rhs is F32
        F64 => rhs is F64
        Usize => rhs is Usize
        JaktString => rhs is JaktString
        CChar => rhs is CChar
        CInt => rhs is CInt
        Self => rhs is Self
        Unknown => rhs is Unknown
        Never => rhs is Never
        // FIXME: Check implemented traits for equality.
        TypeVariable(name: lhs_name) => {
            if rhs is TypeVariable(name: rhs_name) {
                return lhs_name == rhs_name
            }
            yield false
        }
        GenericResolvedType(id: lhs_id, args: lhs_args)
        | GenericInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        GenericTraitInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericTraitInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        GenericEnumInstance(id: lhs_id, args: lhs_args) => {
            guard rhs is GenericEnumInstance(id: rhs_id, args: rhs_args)
                and lhs_id.equals(rhs_id)
                and lhs_args.size() == rhs_args.size() else {

                return false
            }
            mut idx = 0uz
            while idx < lhs_args.size() {
                if not lhs_args[idx].equals(rhs_args[idx]) {
                    return false
                }
                idx++
            }

            return true
        }
        Struct(lhs_id) => {
            if rhs is Struct(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Enum(lhs_id) => {
            if rhs is Enum(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        RawPtr(lhs_id) => {
            if rhs is RawPtr(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Reference(lhs_id) => {
            if rhs is Reference(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        MutableReference(lhs_id) => {
            if rhs is MutableReference(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Trait(lhs_id) => {
            if rhs is Trait(rhs_id) {
                return lhs_id.equals(rhs_id)
            }

            return false
        }
        Function(params, can_throw, return_type_id) => {
            guard rhs is Function(params: rhs_params, can_throw: rhs_can_throw, return_type_id: rhs_return_type_id)
                and params.size() == rhs_params.size()
                and return_type_id.equals(rhs_return_type_id)
                and can_throw == rhs_can_throw else {

                return false
            }
            for i in 0..params.size() {
                if not params[i].equals(rhs_params[i]) {
                    return false
                }
            }

            return true
        }
    }

    fn is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt => true
        else => false
    }

    fn as_builtin_type(this) -> BuiltinType => match this {
        Void => BuiltinType::Void
        Bool => BuiltinType::Bool
        U8 => BuiltinType::U8
        U16 => BuiltinType::U16
        U32 => BuiltinType::U32
        U64 => BuiltinType::U64
        I8 => BuiltinType::I8
        I16 => BuiltinType::I16
        I32 => BuiltinType::I32
        I64 => BuiltinType::I64
        F32 => BuiltinType::F32
        F64 => BuiltinType::F64
        Usize => BuiltinType::Usize
        JaktString => BuiltinType::JaktString
        CChar => BuiltinType::CChar
        CInt => BuiltinType::CInt
        else => {
            eprintln("Type.as_builtin_type: Not a builtin type: {}", this)
            abort()
        }
    }

    fn get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    fn is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    fn min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    fn max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }

    fn flip_signedness(this) throws -> TypeId => match this {
        I8 => builtin(BuiltinType::U8)
        I16 => builtin(BuiltinType::U16)
        I32 => builtin(BuiltinType::U32)
        I64 => builtin(BuiltinType::U64)
        U8 => builtin(BuiltinType::I8)
        U16 => builtin(BuiltinType::I16)
        U32 => builtin(BuiltinType::I32)
        U64 => builtin(BuiltinType::I64)
        else => builtin(BuiltinType::Unknown)
    }
}

class Scope {
    public namespace_name: String?
    public external_name: ExternalName?

    public vars: [String: VarId]
    public comptime_bindings: [String: Value]
    public structs: [String: StructId]
    public functions: [String: [FunctionId]]
    public enums: [String: EnumId]
    public types: [String: TypeId]
    public traits: [String: TraitId]
    public imports: [String: ModuleId] // FIXME: Span
    public aliases: [String: ScopeId]
    public parent: ScopeId?
    public alias_scope: ScopeId? = None
    public children: [ScopeId]
    public can_throw: bool
    public import_path_if_extern: String?
    public alias_path: [ResolvedNamespace]? = None
    public after_extern_include: [IncludeAction]
    public before_extern_include: [IncludeAction]

    public debug_name: String
    public resolution_mixins: [ScopeId]

    public is_block_scope: bool = true

    public resolved_forall_chunks: [ResolvedForallChunk]? = None

    public fn namespace_name_for_codegen(this) -> ExternalName? {
        if .external_name.has_value() { return .external_name }
        if .namespace_name.has_value() {
            return ExternalName::Plain(.namespace_name!)
        }
        return None
    }
}

struct ResolvedForallChunk {
    public parameters: [String:[(Span, TypeId)]]
    public parsed_namespace: ParsedNamespace
    public generated_scopes: [ScopeId]
}

class Module {
    public id: ModuleId
    public name: String
    public functions: [CheckedFunction]
    public structures: [CheckedStruct]
    public enums: [CheckedEnum]
    public scopes: [Scope]
    public types: [Type]
    public traits: [CheckedTrait]
    public variables: [CheckedVariable]
    public imports: [ModuleId]
    public resolved_import_path: String
    public builtin_implementation_structs: [usize:StructId]

    public is_root: bool
    public fn is_prelude(this) -> bool => .id.id == 0

    public fn new_type_variable(mut this, implemented_traits: [TypeId]? = None) throws -> TypeId {
        let new_id = .types.size()

        let empty_implementation: [TypeId] = []
        let trait_implementations = implemented_traits ?? empty_implementation
        .types.push(Type::TypeVariable(name: format("T{}", new_id), trait_implementations))

        return TypeId(module: .id, id: new_id)
    }

    public fn next_function_id(this) -> FunctionId {
        return FunctionId(module: .id, id: .functions.size())
    }

    public fn add_function(mut this, checked_function: CheckedFunction) throws -> FunctionId {
        let new_id = .next_function_id()

        .functions.push(checked_function)

        return new_id
    }

    public fn add_variable(mut this, anon checked_variable: CheckedVariable) throws -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

enum CheckedTraitRequirements {
    Nothing
    Methods([String:FunctionId])
    ComptimeExpression(CheckedExpression)
}

class CheckedTrait {
    public name: String
    public name_span: Span
    public requirements: CheckedTraitRequirements
    public generic_parameters: [CheckedGenericParameter]
    public scope_id: ScopeId
}

struct LoadedModule {
    module_id: ModuleId
    file_id: FileId
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

boxed enum MaybeResolvedScope {
    Resolved(ScopeId)
    Unresolved(
        parent_scope: MaybeResolvedScope
        relative_name: String
    )

    fn try_resolve(this, program: CheckedProgram) throws -> MaybeResolvedScope {
        return match this {
            Resolved(id) => MaybeResolvedScope::Resolved(id)
            Unresolved(parent_scope, relative_name) => {
                mut parent = parent_scope.try_resolve(program)
                if parent is Resolved(parent_scope_id) {
                    let scope = parent_scope_id
                    mut scope_id: ScopeId? = None
                    if not scope_id.has_value() {
                        let struct_ = program.find_struct_in_scope(scope_id: scope, name: relative_name)
                        if struct_.has_value() {
                            scope_id = program.get_struct(struct_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let enum_ = program.find_enum_in_scope(scope_id: scope, name: relative_name)
                        if enum_.has_value() {
                            scope_id = program.get_enum(enum_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let ns = program.find_namespace_in_scope(scope_id: scope, name: relative_name)
                        if ns.has_value() {
                            scope_id = ns!.0
                        }
                    }

                    if not scope_id.has_value() {
                        let ids = program.find_functions_with_name_in_scope(parent_scope_id: scope, function_name: relative_name)
                        if ids.has_value() {
                            scope_id = program.get_function(ids![0]).function_scope_id
                        }
                    }
                    if (scope_id.has_value()) {
                        return MaybeResolvedScope::Resolved(scope_id!)
                    }
                }

                yield MaybeResolvedScope::Unresolved(parent_scope: parent, relative_name)
            }
        }
    }
}

enum CheckedVisibility {
    Public
    Private
    Restricted(scopes: [MaybeResolvedScope], span: Span)
}

class CheckedFunction {
    public name: String
    public name_span: Span
    public visibility: CheckedVisibility
    public return_type_id: TypeId
    public return_type_span: Span?
    public params: [CheckedParameter]
    public generics: FunctionGenerics
    public block: CheckedBlock
    public can_throw: bool
    public type: FunctionType
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId
    public struct_id: StructId?
    public is_instantiated: bool
    public parsed_function: ParsedFunction?
    public is_comptime: bool
    public is_virtual: bool
    public is_override: bool
    public is_unsafe: bool
    public specialization_index: usize? = None

    public owner_scope: ScopeId? = None
    public is_fully_checked: bool = false

    public external_name: ExternalName? = None
    public deprecated_message: String? = None
    public stores_arguments: [(usize, ArgumentStoreLevel)]? = None
    public force_inline: InlineState = InlineState::Default

    public fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)

    public fn map_types(mut this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws {
        .return_type_id = map(.return_type_id)
        mut changed_params: [CheckedParameter] = []
        for param in .params {
            changed_params.push(param.map_types(map))
        }
        .params = changed_params
    }

    public fn copy(this) throws -> CheckedFunction => CheckedFunction(
        name: .name
        name_span: .name_span
        visibility: .visibility
        return_type_id: .return_type_id
        return_type_span: .return_type_span
        params: .params
        generics: .generics
        block: .block
        can_throw: .can_throw
        type: .type
        linkage: .linkage
        function_scope_id: .function_scope_id
        struct_id: .struct_id
        is_instantiated: .is_instantiated
        parsed_function: .parsed_function
        is_comptime: .is_comptime
        is_virtual: .is_virtual
        is_override: .is_override
        is_unsafe: .is_unsafe
        specialization_index: .specialization_index
        owner_scope: .owner_scope
        is_fully_checked: .is_fully_checked
        external_name: .external_name
        deprecated_message: .deprecated_message
        stores_arguments: .stores_arguments
    )

    public fn signature_matches(this, anon other: CheckedFunction, ignore_this: bool = false) throws -> bool {
        if this.name != other.name or
        this.can_throw != other.can_throw or
        this.is_comptime != other.is_comptime {
            return false
        }

        if this.params.size() != other.params.size() {
            return false
        }

        if this.generics.params.size() != other.generics.params.size() {
            return false
        }

        mut lhs_generic_type_ids: {TypeId} = {}
        mut rhs_generic_type_ids: {TypeId} = {}
        for param in this.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            lhs_generic_type_ids.add(type_id)
        }
        for param in other.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            rhs_generic_type_ids.add(type_id)
        }

        for param_index in 0..this.params.size() {
            let lhs_param = this.params[param_index]
            let rhs_param = other.params[param_index]

            let lhs_param_id = lhs_param.variable.type_id
            let rhs_param_id = rhs_param.variable.type_id

            if not lhs_param.variable.type_id.equals(rhs_param.variable.type_id)
                and not (lhs_generic_type_ids.contains(lhs_param_id) and rhs_generic_type_ids.contains(rhs_param_id))
            {
                return false
            }
        }


        return true
    }

    public fn is_static(this) throws -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public fn is_mutating(this) throws -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }

    public fn set_param_default_value(
        mut this
        param_index: usize
        default_value: CheckedExpression
    ) {
        .params[param_index].default_value = default_value
        .generics.base_params[param_index].default_value = default_value
    }

    public fn add_param(mut this, anon checked_param: CheckedParameter) throws {
        .params.push(checked_param)
        .generics.base_params.push(checked_param)
    }

    public fn set_params(mut this, anon checked_params: [CheckedParameter]) throws {
        .params = checked_params
        .generics.base_params = checked_params
    }

    public fn is_specialized_for_types(this, types: [TypeId]) -> bool {
        return .generics.is_specialized_for_types(types)
    }

    public fn to_parsed_function(this) throws -> ParsedFunction {
        if not .parsed_function.has_value() {
            panic("to_parsed_function() called on a synthetic function")
        }
        return .parsed_function!
    }
}

class FunctionGenerics {
    public base_scope_id: ScopeId
    public base_params: [CheckedParameter]
    public params: [FunctionGenericParameter]
    public specializations: [[TypeId]]

    public fn is_specialized_for_types(this, types: [TypeId]) -> bool {
        if types.size() == 0 {
            return true
        }

        for specialization in .specializations {
            mut matched = true

            if types.size() == specialization.size() {
                for i in ..types.size() {
                    if not types[i].equals(specialization[i]) {
                        matched = false
                        break
                    }
                }
            }

            if matched {
                return true
            }
        }

        return false
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
    default_value: CheckedExpression?

    public fn map_types(this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws -> CheckedParameter {
        return CheckedParameter(
            requires_label: .requires_label
            variable: .variable.map_types(map)
            default_value: .default_value
        )
    }
}

enum CheckedCapture {
    name: String
    span: Span

    ByValue
    ByReference
    ByMutableReference
    ByComptimeDependency
    AllByReference
}

enum FunctionGenericParameterKind {
    InferenceGuide
    Parameter
}


struct FunctionGenericParameter {
    kind: FunctionGenericParameterKind
    checked_parameter: CheckedGenericParameter

    fn type_id(this) -> TypeId => .checked_parameter.type_id

    fn parameter(
        anon type_id: TypeId
        span: Span
    ) throws -> FunctionGenericParameter => FunctionGenericParameter(
        kind: FunctionGenericParameterKind::Parameter
        checked_parameter: CheckedGenericParameter::make(type_id, span)
    )
}

class CheckedVariable {
    public name: String
    public type_id: TypeId
    public is_mutable: bool
    public definition_span: Span
    public type_span: Span?
    public visibility: CheckedVisibility
    public owner_scope: ScopeId? = None
    public external_name: ExternalName? = None

    public fn map_types(this, anon map: &fn(anon type_id: TypeId) throws -> TypeId) throws -> CheckedVariable {
        return CheckedVariable(
            name: .name
            type_id: map(.type_id)
            is_mutable: .is_mutable
            definition_span: .definition_span
            type_span: .type_span
            visibility: .visibility
            owner_scope: .owner_scope
            external_name: .external_name
        )
    }

    public fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

enum BlockControlFlow {
    AlwaysReturns
    AlwaysTransfersControl(might_break: bool)
    NeverReturns
    MayReturn
    // If expressions without 'else' branches may produce these.
    PartialAlwaysReturns(might_break: bool)
    PartialAlwaysTransfersControl(might_break: bool)
    PartialNeverReturns(might_break: bool)

    fn unify_with(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => second
        AlwaysReturns => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            MayReturn => BlockControlFlow::MayReturn
            PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        }
        AlwaysTransfersControl(might_break: lhs) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            else => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
        }
        MayReturn => match second {
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            else => BlockControlFlow::MayReturn
        }
        PartialAlwaysReturns(might_break: lhs) => match second {
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::MayReturn
        }
        PartialAlwaysTransfersControl(might_break: lhs) => match second {
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns | NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs)
        }
        PartialNeverReturns(might_break: lhs) => match second {
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialNeverReturns(might_break: lhs)
            NeverReturns => BlockControlFlow::NeverReturns
        }
    }

    public fn branch_unify_with(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => second
        AlwaysReturns => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
            MayReturn => BlockControlFlow::MayReturn
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        }
        MayReturn => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::MayReturn
            MayReturn => BlockControlFlow::MayReturn
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        }
        PartialNeverReturns(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialNeverReturns(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialNeverReturns(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        PartialAlwaysReturns(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialAlwaysReturns(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysReturns(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        PartialAlwaysTransfersControl(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
        AlwaysTransfersControl(might_break: this_might_break) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: this_might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: this_might_break)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: might_break or this_might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: might_break or this_might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: might_break or this_might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: might_break or this_might_break)
        }
    }

    fn updated(this, anon second: BlockControlFlow) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => second
        PartialAlwaysTransfersControl | PartialAlwaysReturns | PartialNeverReturns => .unify_with(second)
    }

    fn partial(this) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::PartialNeverReturns(might_break: false)
        AlwaysReturns => BlockControlFlow::PartialAlwaysReturns(might_break: false)
        MayReturn => BlockControlFlow::MayReturn
        AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
        PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
    }

    fn definitive(this) -> BlockControlFlow => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => BlockControlFlow::MayReturn
        else => BlockControlFlow::MayReturn
    }

    fn always_transfers_control(this) -> bool => match this {
        AlwaysReturns | AlwaysTransfersControl => true
        else => false
    }

    fn never_returns(this) -> bool => match this {
        NeverReturns => true
        else => false
    }

    fn always_returns(this) -> bool => match this {
        AlwaysReturns => true
        else => false
    }

    fn may_return(this) -> bool => match this {
        MayReturn | PartialAlwaysReturns | PartialAlwaysTransfersControl | PartialNeverReturns => true
        else => false
    }

    fn may_break(this) -> bool => match this {
        PartialAlwaysReturns(might_break)
        | PartialAlwaysTransfersControl(might_break)
        | PartialNeverReturns(might_break)
        | AlwaysTransfersControl(might_break)
        => might_break
        else => false
    }

    fn is_reachable(this) -> bool => match this {
        NeverReturns | AlwaysReturns | AlwaysTransfersControl => false
        else => true
    }
}

struct CheckedBlock {
    statements: [CheckedStatement]
    scope_id: ScopeId
    control_flow: BlockControlFlow
    yielded_type: TypeId?
    yielded_none: bool
}

struct FieldRecord {
    struct_id: StructId
    field_id: VarId
}

struct CheckedField {
    variable_id: VarId
    default_value: CheckedExpression?
    default_value_expression: ParsedExpression?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter]
    generic_parameter_defaults: [TypeId?]? = None
    fields: [CheckedField]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:[(TraitId, [TypeId])]]
    record_type: RecordType
    type_id: TypeId
    super_struct_id: StructId?

    external_name: ExternalName? = None
    implements_type: TypeId? = None

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter]
    variants: [CheckedEnumVariant]
    fields: [CheckedField]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:[(TraitId, [TypeId])]]
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
    is_boxed: bool
}

struct CheckedGenericParameter {
    type_id: TypeId
    constraints: [TraitId]
    span: Span

    fn make(
        anon type_id: TypeId
        span: Span
    ) throws -> CheckedGenericParameter => CheckedGenericParameter(type_id, constraints: [], span)
}

enum CheckedEnumVariant {
    Untyped(enum_id: EnumId, name: String, span: Span)
    Typed(enum_id: EnumId, name: String, type_id: TypeId, span: Span)
    WithValue(enum_id: EnumId, name: String, expr: CheckedExpression, span: Span)
    StructLike(enum_id: EnumId, name: String, fields: [VarId], span: Span)

    fn equals(this, anon other: CheckedEnumVariant) -> bool {
        return match this {
            Untyped(name: this_name) => match other {
                Untyped(name: other_name) => this_name == other_name
                else => false
            }
            else => false
        }
    }

    fn enum_id(this) -> EnumId => match this {
        Untyped(enum_id)
        | Typed(enum_id)
        | WithValue(enum_id)
        | StructLike(enum_id) => enum_id
    }

    fn span(this) -> Span => match this {
        Untyped(span) => span
        Typed(span) => span
        WithValue(span) => span
        StructLike(span) => span
    }

    fn name(this) -> String => match this {
        Untyped(name) => name
        Typed(name) => name
        WithValue(name) => name
        StructLike(name)  => name
    }
}

struct CheckedEnumVariantBinding {
    name: String?
    binding: String
    type_id: TypeId
    span: Span
}

boxed enum CheckedStatement {
    Expression(expr: CheckedExpression, span: Span)
    Defer(statement: CheckedStatement, span: Span)
    DestructuringAssignment(vars: [CheckedStatement], var_decl: CheckedStatement, span: Span)
    VarDecl(var_id: VarId, init: CheckedExpression, span: Span)
    If(condition: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?, span: Span)
    Block(block: CheckedBlock, span: Span)
    Loop(block: CheckedBlock, span: Span)
    While(condition: CheckedExpression, block: CheckedBlock, span: Span)
    Return(val: CheckedExpression?, span: Span?)
    Break(Span)
    Continue(Span)
    Throw(expr: CheckedExpression, span: Span)
    Yield(expr: CheckedExpression, span: Span)
    InlineCpp(lines: [String], span: Span)
    Garbage(Span)

    fn span(this) -> Span? => match this {
        Expression(span) => Some(span)
        else(span) => span
    }

    fn none() -> CheckedStatement? => None
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    fn can_fit_number(this, type_id: TypeId, program: CheckedProgram) throws -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                }
                F64 => true
                else => false
            }
        }
    }

    fn to_usize(this) throws -> usize => match this {
        Signed(value) => value as! usize
        Unsigned(value) => value as! usize
        Floating(value) => {
            panic("to_usize on a floating point constant")
        }
    }
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    fn number_constant(this) -> NumberConstant? => match this {
        I8(value) =>  NumberConstant::Signed(value as! i64)
        I16(value) =>  NumberConstant::Signed(value as! i64)
        I32(value) =>  NumberConstant::Signed(value as! i64)
        I64(value) =>  NumberConstant::Signed(value as! i64)
        U8(value) =>  NumberConstant::Unsigned(value as! u64)
        U16(value) =>  NumberConstant::Unsigned(value as! u64)
        U32(value) =>  NumberConstant::Unsigned(value as! u64)
        U64(value) =>  NumberConstant::Unsigned(value as! u64)
        USize(value) =>  NumberConstant::Unsigned(value as! u64)

        // FIXME: add a case for F32 once we can cast f32 to f64

        F64(value) =>  NumberConstant::Floating(value)
        else => None
    }
}

enum StringLiteral {
    Static(String)

    fn to_string(this) -> String => match this {
        Static(value) => value
    }
}

struct CheckedStringLiteral {
    value: StringLiteral
    type_id: TypeId
    may_throw: bool

    fn to_string(this) -> String => .value.to_string()
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)

    fn type_id(this) -> TypeId => match this {
        Fallible(type_id) => type_id
        Infallible(type_id) => type_id
    }
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    Reference
    MutableReference
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(enum_variant: CheckedEnumVariant, bindings: [CheckedEnumVariantBinding], type_id: TypeId)
    IsSome
    IsNone
    Sizeof(TypeId)
}

enum CheckedMatchBody {
    Expression(CheckedExpression)
    Block(CheckedBlock)
}

struct ClassInstanceRebind {
    name: String
    name_span: Span
    is_mutable: bool
    is_reference: bool
}

enum CheckedMatchCase {
    defaults: [CheckedStatement]

    EnumVariant(name: String, args: [EnumVariantPatternArgument], subject_type_id: TypeId, index: usize, scope_id: ScopeId, body: CheckedMatchBody, marker_span: Span)
    Expression(expression: CheckedExpression, body: CheckedMatchBody, marker_span: Span)
    ClassInstance(type: TypeId, body: CheckedMatchBody, rebind_name: ClassInstanceRebind?, marker_span: Span)
    CatchAll(has_arguments: bool, body: CheckedMatchBody, marker_span: Span)
}

struct OperatorTraitImplementation {
    trait_id: TraitId
    trait_generic_arguments: [TypeId]
    call_expression: CheckedCall
}

struct CheckedBinaryOperator {
    op: BinaryOperator
    // FIXME: This is Optional<> because we haven't converted all operators to traits yet, do that.
    trait_implementation: OperatorTraitImplementation?
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: CheckedStringLiteral, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    CCharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: CheckedBinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression?, to: CheckedExpression?, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId, key_type_id: TypeId, value_type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, is_optional: bool, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, name: String, index: VarId?, span: Span, is_optional: bool, type_id: TypeId)
    IndexedCommonEnumMember(expr: CheckedExpression, index: String, span: Span, is_optional: bool, type_id: TypeId)
    ComptimeIndex(expr: CheckedExpression, index: CheckedExpression, is_optional: bool, span: Span)
    Match(expr: CheckedExpression, match_cases: [CheckedMatchCase], span: Span, type_id: TypeId, all_variants_constant: bool)
    EnumVariantArg(expr: CheckedExpression, arg: CheckedEnumVariantBinding, enum_variant: CheckedEnumVariant, span: Span)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, is_optional: bool, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Function(
        captures: [CheckedCapture]
        params: [CheckedParameter]
        can_throw: bool
        return_type_id: TypeId
        block: CheckedBlock
        span: Span
        type_id: TypeId
        pseudo_function_id: FunctionId?
        scope_id: ScopeId
    )
    DependentFunction(
        captures: [CheckedCapture]
        params: [CheckedParameter]
        can_throw: bool
        return_type_id: TypeId
        block: ParsedBlock
        span: Span
        type_id: TypeId
        pseudo_function_id: FunctionId?
        scope_id: ScopeId
    )
    Try(
        expr: CheckedExpression
        catch_block: CheckedBlock?
        catch_span: Span?
        catch_name: String?
        span: Span
        type_id: TypeId
        inner_type_id: TypeId
    )
    TryBlock(stmt: CheckedStatement, catch_block: CheckedBlock, error_name: String, error_span: Span, span: Span, type_id: TypeId)
    Reflect(type: TypeId, span: Span, type_id: TypeId)
    Garbage(span: Span, type_id: TypeId)

    fn to_number_constant(this, program: CheckedProgram) -> NumberConstant? => match this {
        NumericConstant(val, span, type_id) => val.number_constant()
        UnaryOp(expr, op, span, type_id) => {
            mut result: NumberConstant? = None
            guard op is TypeCast(cast) else {
                return None
            }
            if not cast is Infallible {
                result = None
            }
            if not program.is_integer(type_id) and not program.is_floating(type_id) {
                result = None
            }
            if expr is NumericConstant(val) {
                result = val.number_constant()
            }
            yield result
        }
        else => None
    }

    fn span(this) -> Span => match this {
        else(span) => span
    }

    fn is_mutable(this, program: CheckedProgram) -> bool => match this {
        Boolean
        | NumericConstant
        | QuotedString
        | ByteConstant
        | CharacterConstant
        | CCharacterConstant
        => true
        Var(var) => var.is_mutable
        IndexedStruct(expr)
        | IndexedExpression(expr)
        | ComptimeIndex(expr)
        | IndexedTuple(expr)
        | IndexedDictionary(expr)
        | ForcedUnwrap(expr)
        => expr.is_mutable(program)
        JaktArray(vals)
        | JaktSet(vals)
        => {
            mut result = false
            for val in vals {
                if val.is_mutable(program) {
                    result = true
                    break
                }
            }

            yield result
        }
        JaktDictionary(vals) => {
            mut result = false
            for (_, val) in vals {
                if val.is_mutable(program) {
                    result = true
                    break
                }
            }

            yield result
        }
        UnaryOp(expr, op) => match op {
            Dereference => match program.get_type(expr.type()) {
                MutableReference => true
                RawPtr => expr.is_mutable(program)
                else => false
            }
            else => false
        }
        MethodCall(expr) => expr.is_mutable(program)
        else => false
    }

    fn can_throw(this) -> bool => match this {
        Call(call) | MethodCall(call) => call.callee_throws
        // FIXME: This could be a 'StringView' or something that implements FromStringLiteral, which does not throw.
        //        For now, we have to assume the worst.
        QuotedString => true
        else => false
    }

    fn type(this) -> TypeId => match this {
        Boolean => builtin(BuiltinType::Bool)
        QuotedString(val) => val.type_id
        ByteConstant => builtin(BuiltinType::U8)
        CCharacterConstant => builtin(BuiltinType::CChar)
        CharacterConstant => builtin(BuiltinType::U32)
        EnumVariantArg(arg) => arg.type_id
        NamespacedVar(var) => var.type_id
        Var(var) => var.type_id
        ComptimeIndex => builtin(BuiltinType::Unknown) // FIXME
        else(type_id) => type_id
    }

    fn control_flow(this) throws -> BlockControlFlow => match this {
        Match(expr, match_cases, span, type_id, all_variants_constant) => {
            mut control_flow: BlockControlFlow? = None
            for case_ in match_cases {
                let case_control_flow = match case_ {
                    else(body) => match body {
                        Block(block) => block.control_flow
                        Expression(expr) => expr.control_flow()
                    }
                }
                if control_flow.has_value() {
                    control_flow = control_flow!.branch_unify_with(case_control_flow)
                } else {
                    control_flow = case_control_flow
                }
            }
            yield control_flow ?? BlockControlFlow::MayReturn
        }
        MethodCall(type_id) | Call(type_id) => match type_id.equals(never_type_id()) {
            true => BlockControlFlow::NeverReturns
            false => BlockControlFlow::MayReturn
        }
        TryBlock(stmt, catch_block) => {
            guard stmt is Block(block) else {
                panic("Try block doesn't have a block")
            }

            yield block.control_flow.branch_unify_with(catch_block.control_flow)
        }
        else => BlockControlFlow::MayReturn
    }
}

struct ResolvedNamespace {
    name: String
    external_name: ExternalName? = None
    generic_parameters: [TypeId]?

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

struct CheckedCall {
    namespace_: [ResolvedNamespace]
    name: String,
    args: [(String, CheckedExpression)]
    type_args: [TypeId]
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool

    external_name: ExternalName?
    force_inline: InlineState = InlineState::Default

    fn name_for_codegen(this) -> ExternalName => .external_name ?? ExternalName::Plain(.name)
}

fn unknown_type_id() -> TypeId => builtin(BuiltinType::Unknown)
fn void_type_id() -> TypeId => builtin(BuiltinType::Void)
fn never_type_id() -> TypeId => builtin(BuiltinType::Never)

fn builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin.id())
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    public compiler: Compiler
    public modules: [Module]
    public loaded_modules: [String: LoadedModule]

    public fn create_module(mut this, name: String, is_root: bool, path: String? = None) throws -> ModuleId {
        let new_id = .modules.size()
        let module_id = ModuleId(id: new_id)
        let module = Module(
            id: module_id,
            name: name,
            functions: [],
            structures: [],
            enums: [],
            scopes: [],
            types: [ // FIXME: use general builtin types array
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
                Type::Unknown,
                Type::Never
            ],
            traits: [],
            variables: [],
            imports: [],
            resolved_import_path: path ?? .compiler.current_file_path()!.to_string(),
            builtin_implementation_structs: [:]
            is_root: is_root,
        )
        .modules.push(module)

        return module_id
    }

    public fn create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool, debug_name: String, module_id: ModuleId, for_block: bool = true) throws -> ScopeId {
        // Check that parent_scope_id is a valid ScopeId
        if parent_scope_id.has_value() {
            // Check that the ModuleId is valid
            if parent_scope_id!.module_id.id >= .modules.size() {
                .compiler.panic(format("create_scope: parent_scope_id.module is invalid! No module with id {}.", parent_scope_id!.module_id.id))
            }

            // Check that ScopeId.id is valid in the module
            if parent_scope_id!.id >= .modules[parent_scope_id!.module_id.id].scopes.size() {
                .compiler.panic(format("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}.", parent_scope_id!.module_id.id, parent_scope_id!.id))
            }
        }

        let none_string: String? = None

        let scope = Scope(
            namespace_name: none_string
            external_name: None
            vars: [:]
            comptime_bindings: [:]
            structs: [:]
            functions: [:]
            enums: [:]
            types: [:]
            traits: [:]
            imports: [:]
            aliases: [:]
            parent: parent_scope_id
            children: []
            can_throw
            import_path_if_extern: None
            after_extern_include: []
            before_extern_include: []
            debug_name
            resolution_mixins: []
            is_block_scope: for_block
        )

        .modules[module_id.id].scopes.push(scope)

        return ScopeId(module_id, id: .modules[module_id.id].scopes.size() - 1)
    }

    public fn builtin_implementation_struct(mut this, builtin: BuiltinType, for_module: ModuleId) throws -> StructId {
        let id = builtin.id()
        mut module = .modules[for_module.id]
        if module.builtin_implementation_structs.contains(id) {
            return module.builtin_implementation_structs[id]
        }

        let scope_id = .create_scope(
            parent_scope_id: None
            can_throw: false
            debug_name: format("builtin({})", builtin.constructor_name())
            module_id: for_module
            for_block: false
        )

        let trait_implementations: [String:[(TraitId, [TypeId])]] = [:]
        let name_span = Span(
            file_id: FileId(id: 0)
            start: 0
            end: 0
        )

        let struct_id = StructId(
            module: for_module
            id: module.structures.size()
        )
        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id), module_id: for_module)

        let struct_ = CheckedStruct(
            name: format("Builtin_{}", builtin.constructor_name())
            name_span
            generic_parameters: []
            fields: []
            scope_id
            definition_linkage: DefinitionLinkage::External
            trait_implementations
            record_type: RecordType::Struct(fields: [], super_type: None)
            type_id: struct_type_id
            super_struct_id: None
            implements_type: builtin(builtin)
        )

        module.structures.push(struct_)
        module.builtin_implementation_structs[id] = struct_id

        return struct_id
    }

    public fn get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public fn get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public fn get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public fn get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public fn get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public fn get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public fn get_scope(this, anon id: ScopeId) throws -> Scope {
        let max_scope = .modules[id.module_id.id].scopes.size() - 1
        if id.id > max_scope {
            .compiler.panic(format("scope_id {} does not exist in module", id))
        }

        return .modules[id.module_id.id].scopes[id.id]
    }

    public fn get_trait(this, anon id: TraitId) -> CheckedTrait => .modules[id.module.id].traits[id.id]

    public fn prelude_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 0), id: 0)
    public fn prelude_module_id(this) -> ModuleId => ModuleId(id: 0)

    public fn set_loaded_module(mut this, module_name: String, loaded_module: LoadedModule) throws {
        .loaded_modules.set(
            key: module_name
            value: loaded_module
        )
    }
    public fn get_loaded_module(this, anon module_name: String) -> LoadedModule? {
        return .loaded_modules.get(module_name)
    }

    public fn find_var_in_scope(this, scope_id: ScopeId, var: String) throws -> CheckedVariable? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[var, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<CheckedVariable> {
                let scope = .get_scope(scope_id)
                let maybe_var = scope.vars.get(var)
                if maybe_var.has_value() {
                    return IterationDecision::Break(value: .get_variable(maybe_var!))
                }
                return IterationDecision::Continue
            }
        )
    }

    public fn find_comptime_binding_in_scope(this, scope_id: ScopeId, anon name: String) throws -> Value? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<Value> {
                let scope = .get_scope(scope_id)
                let maybe_binding = scope.comptime_bindings.get(name)
                if maybe_binding.has_value() {
                    return IterationDecision::Break(value: maybe_binding!)
                }
                return IterationDecision::Continue
            }
        )
    }

    public fn find_type_scope(this, scope_id: ScopeId, name: String) throws -> (TypeId, ScopeId)? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<(TypeId, ScopeId)> {
                let maybe_type = .get_scope(scope_id).types.get(name)
                if maybe_type.has_value() {
                    return IterationDecision::Break(value: (maybe_type!, scope_id))
                }
                return IterationDecision::Continue
            }
        )
    }

    public fn find_type_in_scope(this, scope_id: ScopeId, name: String) throws -> TypeId? {
        return .find_type_scope(scope_id, name)?.0
    }

    public fn find_enum_in_scope(this, scope_id: ScopeId, name: String) throws -> EnumId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<EnumId> {
                let scope = .get_scope(scope_id)
                let maybe_enum = scope.enums.get(name)
                if maybe_enum.has_value() {
                    return IterationDecision::Break(value: maybe_enum!)
                }
                return IterationDecision::Continue
            }
        )
    }

    public fn find_trait_in_scope(this, scope_id: ScopeId, name: String) throws -> TraitId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<TraitId> {
                let scope = .get_scope(scope_id)
                let maybe_trait = scope.traits.get(name)
                if maybe_trait.has_value() {
                    return IterationDecision::Break(value: maybe_trait!)
                }
                return IterationDecision::Continue
            }
        )
    }

    public fn is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public fn is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public fn is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public fn is_string(this, anon type_id: TypeId) throws -> bool => match .get_type(type_id) {
        JaktString => true
        Struct(struct_id) => .find_struct_in_prelude("String").equals(struct_id)
        else => false
    }

    public fn get_bits(this, anon type_id: TypeId) -> i64 => .get_type(type_id).get_bits()

    public fn is_signed(this, anon type_id: TypeId) -> bool => .get_type(type_id).is_signed()

    private fn for_each_scope_accessible_unqualified_from_scope_impl(
        this
        scope_id: ScopeId
        anon callback: &fn(scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<bool>
    ) throws -> bool? {
        mut scopes_to_check = Queue<ScopeId>()
        mut seen: {ScopeId} = {}

        scopes_to_check.enqueue(scope_id)

        for child in .get_scope(scope_id).children {
            scopes_to_check.enqueue(child)
        }

        while not scopes_to_check.is_empty() {
            let scope_id = scopes_to_check.dequeue()
            if seen.contains(scope_id) {
                continue
            }

            seen.add(scope_id)

            let res = callback(scope_id, name_override: None, is_alias: false)
            match res {
                Break(value) => {
                    return Some(value)
                }
                else => {}
            }

            let scope = .get_scope(scope_id)

            for (name, alias) in scope.aliases {
                let res = callback(scope_id: alias, name_override: name, is_alias: true)
                match res {
                    Break(value) => {
                        return Some(value)
                    }
                    else => {}
                }
            }

            for entry in scope.resolution_mixins {
                scopes_to_check.enqueue(entry)
                for child in .get_scope(entry).children {
                    scopes_to_check.enqueue(child)
                }
            }

            if scope.parent.has_value() {
                scopes_to_check.enqueue(scope.parent!)
                for child in .get_scope(scope.parent!).children {
                    scopes_to_check.enqueue(child)
                }
            }

            if scope.namespace_name.has_value() {
                continue
            }

            for child in scope.children {
                scopes_to_check.enqueue(child)
            }
        }

        // if we do not find it then check imports
        let module_id = scope_id.module_id

        let search_scope_id = ScopeId(module_id: module_id, id: 0)
        let search_scope = .get_scope(search_scope_id)
        for (name, module) in search_scope.imports {
            let import_scope_id = ScopeId(module_id: module, id: 0)
            let res = callback(scope_id: import_scope_id, name_override: name, is_alias: false)
            match res {
                Break(value) => {
                    return Some(value)
                }
                else => {}
            }
        }

        return None

    }

    public fn for_each_scope_accessible_unqualified_from_scope<T>(
        this
        scope_id: ScopeId
        anon callback: &fn(scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<T>
    ) throws -> T? {
        mut result: T? = None
        .for_each_scope_accessible_unqualified_from_scope_impl(
            scope_id
            &fn[&mut callback, &mut result](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<bool> {
                match callback(scope_id, name_override, is_alias) {
                    Break(value) => {
                        result = value
                        return IterationDecision::Break(value: true)
                    }
                    Continue => {
                        return IterationDecision::Continue
                    }
                }
            }
        )

        return result
    }

    public fn find_struct_in_scope(this, scope_id: ScopeId, name: String) throws -> StructId? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, this](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<StructId> {
                let scope = .get_scope(scope_id)
                let maybe_struct = scope.structs.get(name)
                if maybe_struct.has_value() {
                    return IterationDecision::Break(value: maybe_struct!)
                }

                return IterationDecision::Continue
            }
        )
    }

    public fn find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return struct_id.value()
        }

        .compiler.panic(format("internal error: {} builtin definition not found", name))
    }

    public fn is_scope_directly_accessible_from(this, check_scope_id: ScopeId, scope_id: ScopeId) throws -> bool {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[check_scope_id](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<bool> {
                if check_scope_id.equals(scope_id) {
                    return IterationDecision::Break(value: true)
                }

                return IterationDecision::Continue
            }
        ) ?? false
    }

    public fn find_reflected_primitive(this, anon primitive: String) throws -> StructOrEnumId {
        let scope_id = .prelude_scope_id()
        let maybe_namespace = .find_namespace_in_scope(scope_id, "Reflect")
        if not maybe_namespace.has_value() {
            .compiler.panic(format("internal error: builtin namespace 'Reflect' not found"))
        }

        let reflect_namespace_scope_id = maybe_namespace!.0
        let enum_id = .find_enum_in_scope(scope_id: reflect_namespace_scope_id, name: primitive)
        if enum_id.has_value() {
            return StructOrEnumId::Enum(enum_id!)
        }

        let struct_id = .find_struct_in_scope(scope_id: reflect_namespace_scope_id, name: primitive)
        if struct_id.has_value() {
            return StructOrEnumId::Struct(struct_id!)
        }

        .compiler.panic(format("internal error: definition for reflect builtin '{}' not found", primitive))
    }

    public fn find_type_scope_id(mut this, anon type_id: TypeId) throws -> ScopeId {
        let type = .get_type(type_id)
        return match type {
            Struct(struct_id) | GenericInstance(id: struct_id) => .get_struct(struct_id).scope_id
            Enum(enum_id) | GenericEnumInstance(id: enum_id) => .get_enum(enum_id).scope_id
            Trait(trait_id) | GenericTraitInstance(id: trait_id) => .get_trait(trait_id).scope_id
            else => match type.is_builtin() {
                true => .get_struct(.builtin_implementation_struct(builtin: type.as_builtin_type(), for_module: .prelude_module_id())).scope_id
                false => .prelude_scope_id()
            }
        }
    }

    public fn find_namespace_in_immediate_children_of_scope(
        this
        scope_id: ScopeId
        anon name: String
        treat_aliases_as_imports: bool = false
    ) throws -> ScopeId? {
        let scope = .get_scope(scope_id)
        for child in scope.children {
            let child_scope = .get_scope(child)
            if child_scope.namespace_name.has_value() and child_scope.namespace_name! == name {
                return child
            }
        }
        if treat_aliases_as_imports {
            if scope.aliases.contains(name) {
                return scope.aliases.get(name)
            }
        }
        return None
    }

    public fn find_namespace_in_scope(
        this
        scope_id: ScopeId
        anon name: String
        treat_aliases_as_imports: bool = false
    ) throws -> (ScopeId, bool)? {
        return .for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[name, treat_aliases_as_imports, this](
                scope_id: ScopeId
                name_override: String?
                is_alias: bool
            ) throws -> IterationDecision<(ScopeId, bool)> {
                let scope = .get_scope(scope_id)
                let effective_name = name_override ?? scope.namespace_name
                let is_import = name_override.has_value() and not is_alias
                if effective_name.has_value() and effective_name! == name {
                    return IterationDecision::Break(value: (scope_id, is_import or (is_alias and treat_aliases_as_imports)))
                }

                return IterationDecision::Continue
            }
        )
    }

    public fn find_function_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> FunctionId? {
        let results = .find_functions_with_name_in_scope(parent_scope_id, function_name)
        if not results.has_value() {
            return None
        }

        let functions = results.value()
        if functions.size() != 1 {
            .compiler.panic(format("internal error: found {} functions with name '{}', but expected 1", functions.size(), function_name))
        }

        return functions[0]
    }

    public fn find_default_constructors_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> FunctionId? {
        let results = .find_functions_with_name_in_scope(parent_scope_id, function_name)
        if not results.has_value() {
            return None
        }

        for id in results.value() {
            let function = .get_function(id)
            if function.type is ImplicitConstructor {
                return id
            }
        }

        return None
    }

    public fn find_functions_with_name_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> [FunctionId]? {
        return .find_scoped_functions_with_name_in_scope(parent_scope_id, function_name)?.0
    }

    public fn find_scoped_functions_with_name_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> ([FunctionId], ScopeId)? {
        mut result_ids: [FunctionId] = []
        mut result_scope: ScopeId? = None
        .for_each_scope_accessible_unqualified_from_scope(
            scope_id: parent_scope_id
            &fn[function_name, &mut result_ids, &mut result_scope, this](
                scope_id: ScopeId
                name_override: String?
                is_alias: bool
            ) throws -> IterationDecision<([FunctionId], ScopeId)> {
                let scope = .get_scope(scope_id)
                let maybe_functions = scope.functions.get(function_name)
                if maybe_functions.has_value() {
                    result_ids.push_values(&maybe_functions!)
                    if not result_scope.has_value() {
                        result_scope = scope_id
                    }
                }

                return IterationDecision::Continue
            }
        )

        if result_scope is None {
            return None
        }

        return (result_ids, result_scope!)
    }

    // Checks given struct id is weak ptr and
    //  validates args are compatible with weak ptr type
    // Returns the inner struct id if given struct is weak ptr
    public fn check_and_extract_weak_ptr(this, struct_id: StructId, args: [TypeId]) throws -> StructId? {
        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

        if struct_id.equals(weak_ptr_struct_id) {
            if (args.size() != 1) {
                .compiler.panic(
                    format(
                        "Internal error: Generic type is WeakPtr but there are not exactly 1 type parameter. There are {} parameters.",
                        args.size()
                    )
                )
            }

            let inner_type_id = args[0]
            let inner_type = .get_type(inner_type_id)

            if inner_type is Struct(inner_struct_id) {
                return inner_struct_id
            }
            panic(
                format(
                    "Internal error: Inner type of WeakPtr is not a struct. It is {}.",
                    inner_type
                )
            )
        } else {
            return None
        }
    }

    public fn type_name(this, anon type_id: TypeId, debug_mode: bool = false) throws -> String {
        let type = .get_type(type_id)

        return match debug_mode {
            true => format("({}@{}) ", type_id.id, type_id.module.id) + match type {
                TypeVariable => "var "
                else => ""
            }
            else => ""
        } + match type {
            Never => "never"
            F32 => "f32"
            F64 => "f64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            Void => "void"
            Unknown => "unknown"
            JaktString => "builtin(String)"
            Trait(id) => .get_trait(id).name
            Self => "Self"
            Function(params, return_type_id) => {
                mut param_names: [String] = []
                for x in params {
                    param_names.push(.type_name(x, debug_mode))
                }

                let return_type = .type_name(return_type_id, debug_mode)

                yield format("fn({}) -> {}", join(param_names, separator: ", "), return_type)
            }
            Enum(id) => .get_enum(id).name
            Struct(id) => .get_struct(id).name
            GenericEnumInstance(id, args) => {
                mut output = format("enum {}", .get_enum(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg, debug_mode)
                }

                output += ">"

                yield output
            }
            GenericTraitInstance(id, args) => {
                mut output = format("trait {}", .get_trait(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg, debug_mode)
                }

                output += ">"

                yield output
            }
            GenericInstance(id, args) => {

                let array_struct_id = .find_struct_in_prelude("Array")
                let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
                let optional_struct_id = .find_struct_in_prelude("Optional")
                let range_struct_id = .find_struct_in_prelude("Range")
                let set_struct_id = .find_struct_in_prelude("Set")
                let tuple_struct_id = .find_struct_in_prelude("Tuple")
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                mut output = ""

                if id.equals(array_struct_id) {
                    output = format("[{}]", .type_name(args[0], debug_mode))
                } else if id.equals(dictionary_struct_id) {
                    output = format("[{}:{}]", .type_name(args[0], debug_mode), .type_name(args[1], debug_mode))
                } else if id.equals(optional_struct_id) {
                    output = format("{}?", .type_name(args[0], debug_mode))
                } else if id.equals(range_struct_id) {
                    output = format("{}..{}", .type_name(args[0], debug_mode), .type_name(args[0], debug_mode))
                } else if id.equals(set_struct_id) {
                    output = format("{{{}}}", .type_name(args[0], debug_mode))
                } else if id.equals(tuple_struct_id) {
                    output = "("
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg, debug_mode)
                    }
                    output += ")"
                } else if id.equals(weak_ptr_struct_id) {
                    output = format("weak {}", .type_name(args[0], debug_mode))
                } else {
                    let structure = .get_struct(id)
                    output = structure.name
                    output += "<"
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg, debug_mode)
                    }
                    output += ">"
                }

                yield output
            }
            GenericResolvedType(id, args) => {
                mut output = .get_struct(id).name
                mut first = true
                output += "<"
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }
                    output += .type_name(type_id, debug_mode)
                }
                output += ">"

                yield output
            }
            TypeVariable(name) => name
            RawPtr(type_id) => format("raw {}", .type_name(type_id, debug_mode))
            Reference(type_id) => format("&{}", .type_name(type_id, debug_mode))
            MutableReference(type_id) => format("&mut {}", .type_name(type_id, debug_mode))
        }
    }

    public fn find_or_add_type_id(mut this, anon type: Type, module_id: ModuleId) throws -> TypeId {
        for module in .modules {
            for id in 0..module.types.size() {
                if module.types[id].equals(type) {
                    return TypeId(module: module.id, id)
                }
            }
        }

        .modules[module_id.id].types.push(type)

        return TypeId(module: module_id, id: .modules[module_id.id].types.size() - 1)
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    public fn substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: GenericInferences, module_id: ModuleId) throws -> TypeId {
        mut result = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

        loop {
            let fixed_point = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

            if fixed_point.equals(result) {
                break
            } else {
                result = fixed_point
            }
        }

        return result
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    fn substitute_typevars_in_type_helper(mut this, type_id: TypeId , generic_inferences: GenericInferences, module_id: ModuleId) throws -> TypeId {
        let type_ = .get_type(type_id)

        match type_ {
            TypeVariable => {
                let replacement_type_id = generic_inferences.get(type_id)
                if replacement_type_id.has_value() {
                    return replacement_type_id!
                }
            }
            GenericTraitInstance(id, args) => {
                mut new_args: [TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericTraitInstance(id, args: new_args), module_id)
            }
            GenericInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericInstance(id, args: new_args), module_id)
            }
            GenericEnumInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }
                return .find_or_add_type_id(Type::GenericEnumInstance(id, args: new_args), module_id)
            }
            Struct(struct_id) => {
                let struct_ = .get_struct(struct_id)
                if not struct_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(struct_.generic_parameters.size())
                    for arg in struct_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericInstance(id: struct_id, args: new_args), module_id)
                }
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                if not enum_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(enum_.generic_parameters.size())
                    for arg in enum_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id, args: new_args), module_id)
                }
            }
            RawPtr(rawptr_type_id) => {
                let rawptr_type = Type::RawPtr(
                    .substitute_typevars_in_type(type_id: rawptr_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(rawptr_type, module_id)
            }
            Reference(ref_type_id) => {
                let ref_type = Type::Reference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            MutableReference(ref_type_id) => {
                let ref_type = Type::MutableReference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            Function(params, can_throw, return_type_id, pseudo_function_id) => {
                mut new_params:[TypeId] = []
                new_params.ensure_capacity(params.size())
                mut is_different = false
                for param in params {
                    let new_param = .substitute_typevars_in_type(type_id: param, generic_inferences, module_id)
                    is_different = is_different or not new_param.equals(param)
                    new_params.push(new_param)
                }

                let return_type_substitute = .substitute_typevars_in_type(type_id: return_type_id, generic_inferences, module_id)
                is_different = is_different or not return_type_substitute.equals(return_type_id)

                if not is_different {
                    return type_id
                }

                let previous_function = .get_function(pseudo_function_id)

                mut replacement_params: [CheckedParameter] = []
                for i in 0uz..previous_function.params.size() {
                    let param = previous_function.params[i]
                    let new_param = CheckedParameter(
                        requires_label: param.requires_label
                        variable: CheckedVariable(
                            name: param.variable.name
                            type_id: new_params[i]
                            is_mutable: param.variable.is_mutable
                            definition_span: param.variable.definition_span
                            type_span: param.variable.type_span
                            visibility: param.variable.visibility
                        )
                        default_value: param.default_value
                    )
                    replacement_params.push(new_param)
                }

                let new_function = CheckedFunction(
                    name: previous_function.name
                    name_span: previous_function.name_span
                    visibility: previous_function.visibility
                    return_type_id: return_type_substitute
                    return_type_span: previous_function.return_type_span
                    params: replacement_params
                    generics: previous_function.generics
                    block: previous_function.block
                    can_throw
                    type: previous_function.type
                    linkage: previous_function.linkage
                    function_scope_id: previous_function.function_scope_id
                    struct_id: previous_function.struct_id
                    is_instantiated: previous_function.is_instantiated
                    parsed_function: previous_function.parsed_function
                    is_comptime: previous_function.is_comptime
                    is_virtual: previous_function.is_virtual
                    is_override: previous_function.is_override
                    is_unsafe: previous_function.is_unsafe
                )

                let new_function_id = .modules[module_id.id].add_function(checked_function: new_function)

                return .find_or_add_type_id(Type::Function(params: new_params, can_throw, return_type_id: return_type_substitute, pseudo_function_id: new_function_id), module_id)
            }
            else => {
                return type_id
            }
        }
        return type_id
    }
}

boxed enum ValueImpl {
    Void
    Bool(bool)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    F32(f32)
    F64(f64)
    USize(usize)
    JaktString(String)
    StringView(String)
    CChar(c_char)
    CInt(c_int)
    Struct(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Class(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Enum(fields: [Value], enum_id: EnumId, constructor: FunctionId)
    JaktArray(values: [Value], type_id: TypeId)
    JaktDictionary(keys: [Value], values: [Value], type_id: TypeId)
    JaktSet(values: [Value], type_id: TypeId)
    RawPtr(ValueImpl)
    OptionalSome(value: Value)
    OptionalNone
    JaktTuple(fields: [Value], type_id: TypeId)
    Function(
        captures: [String: Value]
        params: [String: (TypeId, CheckedExpression?)]
        return_type_id: TypeId
        type_id: TypeId
        block: CheckedBlock
        can_throw: bool
        checked_params: [CheckedParameter]
        scope_id: ScopeId
        pseudo_function_id: FunctionId?
    )

    fn copy(this) throws -> ValueImpl => match this {
        Void => ValueImpl::Void
        Bool(x) => ValueImpl::Bool(x)
        U8(x) => ValueImpl::U8(x)
        U16(x) => ValueImpl::U16(x)
        U32(x) => ValueImpl::U32(x)
        U64(x) => ValueImpl::U64(x)
        I8(x) => ValueImpl::I8(x)
        I16(x) => ValueImpl::I16(x)
        I32(x) => ValueImpl::I32(x)
        I64(x) => ValueImpl::I64(x)
        F32(x) => ValueImpl::F32(x)
        F64(x) => ValueImpl::F64(x)
        USize(x) => ValueImpl::USize(x)
        JaktString(x) => ValueImpl::JaktString(x)
        StringView(x) => ValueImpl::StringView(x)
        CChar(x) => ValueImpl::CChar(x)
        CInt(x) => ValueImpl::CInt(x)
        Struct(fields, struct_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Struct(fields: fields_copy, struct_id, constructor)
        }
        Class(fields, struct_id, constructor) => ValueImpl::Class(fields, struct_id, constructor)
        Enum(fields, enum_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Enum(fields: fields_copy, enum_id, constructor)
        }
        JaktArray(values, type_id) => {
            mut values_copy: [Value] = [];
            for value in values {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktArray(values: values_copy, type_id)
        }
        JaktDictionary(keys, values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            mut keys_copy: [Value] = []
            for key in keys {
                keys_copy.push(key.copy())
            }
            yield ValueImpl::JaktDictionary(keys: keys_copy, values: values_copy, type_id)
        }
        JaktSet(values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            yield ValueImpl::JaktSet(values: values_copy, type_id)
        }
        RawPtr(value) => ValueImpl::RawPtr(value)
        OptionalSome(value) => ValueImpl::OptionalSome(value: value.copy())
        OptionalNone => ValueImpl::OptionalNone
        JaktTuple(fields, type_id) => {
            mut values_copy: [Value] = [];
            for value in fields {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktTuple(fields: values_copy, type_id)
        }
        Function(
            captures
            params
            can_throw
            return_type_id
            type_id
            block
            checked_params
            scope_id
            pseudo_function_id
        ) => ValueImpl::Function(
            captures
            params
            return_type_id
            type_id
            block
            can_throw
            checked_params
            scope_id
            pseudo_function_id
        )
    }

    fn equals(this, anon other: ValueImpl) -> bool => match this {
        Void => other is Void
        Bool(x) => match other { Bool(y) => x == y else => false }
        U8(x) => match other { U8(y) => x == y else => false }
        U16(x) => match other { U16(y) => y == x else => false }
        U32(x) => match other { U32(y) => y == x else => false }
        U64(x) => match other { U64(y) => y == x else => false }
        I8(x) => match other { I8(y) => y == x else => false }
        I16(x) => match other { I16(y) => y == x else => false }
        I32(x) => match other { I32(y) => y == x else => false }
        I64(x) => match other { I64(y) => y == x else => false }
        F32(x) => match other { F32(y) => y == x else => false }
        F64(x) => match other { F64(y) => y == x else => false }
        USize(x) => match other { USize(y) => y == x else => false }
        JaktString(x) => match other { JaktString(y) => y == x else => false }
        StringView(x) => match other { StringView(y) => y == x else => false }
        CChar(x) => match other { CChar(y) => y == x else => false }
        CInt(x) => match other { CInt(y) => y == x else => false }
        else => false
    }
}

struct Value {
    impl: ValueImpl
    span: Span

    fn copy(this) throws -> Value => Value(impl: .impl.copy(), span: .span)
    fn type_name(this) throws -> String => match .impl {
        Void => "void"
        Bool => "bool"
        U8 => "u8"
        U16 => "u16"
        U32 => "u32"
        U64 => "u64"
        I8 => "i18"
        I16 => "i16"
        I32 => "i32"
        I64 => "i64"
        F32 => "f32"
        F64 => "f64"
        USize => "usize"
        JaktString => "String"
        StringView => "StringView"
        CChar => "c_char"
        CInt => "c_int"
        Struct => "struct <T>"
        Class => "class <T>"
        Enum => "enum <T>"
        JaktArray => "Array"
        JaktDictionary => "Dictionary"
        JaktSet => "Set"
        RawPtr => "raw <T>"
        OptionalSome => "Some"
        OptionalNone => "None"
        JaktTuple => "Tuple"
        Function => "Function"
    }

    fn cast(this, anon expected: Value, span: Span) throws -> Value => match .impl {
        U8(value) => match expected.impl {
            U16 => Value(impl: ValueImpl::U16(value as! u16), span: span)
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U16(value) => match expected.impl {
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U32(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        I8(value) => match expected.impl {
            I16 => Value(impl: ValueImpl::I16(value as! i16), span: span)
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I16(value) => match expected.impl {
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I32(value) => match expected.impl {
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span) // yuck
            else => this
        }
        USize(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            // No idea why this is allowed.
            CInt => Value(impl: ValueImpl::CInt(value as! c_int), span: span)
            else => this
        }
        OptionalSome => this
        else => match expected.impl {
            OptionalSome | OptionalNone => Value(impl: ValueImpl::OptionalSome(value: this), span: span)
            else => this
        }
    }
}

enum NumericOrStringValue {
    StringValue(String)
    SignedNumericValue(i64)
    UnsignedNumericValue(u64)
}

class TypecheckFunctions {
    public block: fn(
        parsed_block: ParsedBlock
        parent_scope_id: ScopeId
        safety_mode: SafetyMode
        yield_type_hint: TypeId? = None
    ) throws -> CheckedBlock

    public register_function: fn(
        checked_function: CheckedFunction
    ) throws -> FunctionId
}

fn format_value_impl(anon format_string: String, anon value: Value, program: &CheckedProgram) throws -> String => match value.impl {
    Bool(v)
    | U8(v)
    | U16(v)
    | U32(v)
    | U64(v)
    | USize(v)
    | I8(v)
    | I16(v)
    | I32(v)
    | I64(v)
    | F32(v)
    | F64(v)
    | CChar(v)
    | CInt(v)
    | JaktString(v)
    | StringView(v)
    => format(format_string, v)

    Void => format(format_string, "(void)")

    Struct(fields, struct_id, constructor)
    | Class(fields, struct_id, constructor)
    => {
        let structure = program.get_struct(struct_id)
        mut builder = StringBuilder::create()
        mut field_names: [String] = []

        builder.append(structure.name)
        if constructor.has_value() {
            let function = program.get_function(constructor!)
            builder.append("::")
            builder.append(function.name)
            for parameter in function.params {
                field_names.push(parameter.variable.name)
            }
        } else {
            for field in structure.fields {
                field_names.push(program.get_variable(field.variable_id).name)
            }
        }
        builder.append('(')
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(field_names[index])
            builder.append(": ")
            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(')')
        yield builder.to_string()
    }

    Enum(fields, enum_id, constructor) => {
        let enum_ = program.get_enum(enum_id)
        let function = program.get_function(constructor)
        mut builder = StringBuilder::create()
        mut field_names: [String] = []

        builder.append(enum_.name)
        builder.append("::")
        builder.append(function.name)
        for parameter in function.params {
            field_names.push(parameter.variable.name)
        }

        builder.append('(')
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(field_names[index])
            builder.append(": ")
            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(')')
        yield builder.to_string()
    }

    OptionalSome(value) => format_value_impl(
        format_string: format("Some({})", format_string)
        value
        program
    )
    OptionalNone => format(format_string, "None")

    JaktTuple(fields)
    | JaktArray(values: fields)
    | JaktSet(values: fields) => {
        mut builder = StringBuilder::create()
        let surrounding = match value.impl {
            JaktTuple => ('(', ')')
            JaktArray => ('[', ']')
            JaktSet => ('{', '}')
            else => {
                abort()
            }
        }
        builder.append(surrounding.0)
        mut index = 0uz
        for field in fields {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(format_value_impl(format_string, field, program))
            index += 1
        }

        builder.append(surrounding.1)
        yield builder.to_string()
    }

    JaktDictionary(keys, values) => {
        mut builder = StringBuilder::create()
        builder.append('[')
        mut index = 0uz
        for key in keys {
            if index > 0 {
                builder.append(", ")
            }

            builder.append(format_value_impl(format_string, key, program))
            builder.append(": ")
            builder.append(format_value_impl(format_string, values[index], program))

            index += 1
        }

        builder.append(']')
        yield builder.to_string()
    }

    else => {
        eprintln("Cannot format value {}", value.impl)
        throw Error::from_string_literal("Cannot format value of this type")
    }
}

fn comptime_format_impl(format_string: String, arguments: ArraySlice<Value>, program: &CheckedProgram) throws -> String {
    mut builder = StringBuilder::create()
    mut current_argument_index = 0uz
    mut format_field_builder = StringBuilder::create()
    mut index_in_field: usize? = None
    mut expect_close_brace = false

    let argument_and_index = fn(anon str: String) -> (usize?, String) {
        mut slice_end = 0uz
        mut has_index = false
        for code_point in str.code_points() {
            guard code_point >= '0' and code_point <= '9' else {
                break
            }
            slice_end += 1
            has_index = true
        }

        if has_index {
            let index_str = str.substring(start: 0, length: slice_end)
            let index = index_str.to_uint()
            if index.has_value() {
                return (index! as! usize, str.substring(start: slice_end, length: str.length() - slice_end))
            }
        }

        return (None, str)
    }

    for code_point in format_string.code_points() {
        match code_point {
            '{' => {
                if index_in_field.has_value() and index_in_field! == 0 {
                    builder.append('{')
                    index_in_field = None
                } else if index_in_field.has_value() {
                    format_field_builder.append('{')
                    index_in_field = index_in_field! + 1
                } else {
                    index_in_field = 0
                }
            }
            '}' => {
                if expect_close_brace {
                    builder.append('}')
                    expect_close_brace = false
                } else if not index_in_field.has_value() {
                    expect_close_brace = true
                } else {
                    index_in_field = None
                    let fmt_string = format_field_builder.to_string()
                    format_field_builder.clear()
                    let (index, format_string) = argument_and_index(fmt_string)
                    let effective_index = index ?? current_argument_index++
                    if effective_index >= arguments.size() {
                        throw Error::from_string_literal("Not enough arguments for format string")
                    }

                    let effective_format_string = format("{{{}}}", format_string)

                    builder.append(format_value_impl(effective_format_string, arguments[effective_index], program))
                }
            }
            else => {
                if index_in_field.has_value() {
                    format_field_builder.append(code_point)
                } else {
                    builder.append(code_point)
                }
            }
        }
    }

    return builder.to_string()
}
