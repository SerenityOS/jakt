import parser { Parser, BinaryOperator, DefinitionLinkage, UnaryOperator,
                FunctionLinkage, FunctionType, ParsedBlock, ParsedCall,
                ParsedExpression, ParsedFunction, ParsedNamespace, ParsedModuleImport,
                ParsedExternImport, ParsedType, ParsedStatement, ParsedVarDecl, RecordType,
                ParsedRecord, ParsedField, TypeCast, EnumVariantPatternArgument,
                ParsedMatchBody, ParsedMatchCase, ParsedParameter, ParsedCapture, IncludeAction }
import utility { panic, todo, join, FileId, Span }
import compiler { Compiler }

struct GenericInferences {
    values: [String:String]

    function set(mut this, anon key: String, anon value: String) throws {
        if key == value {
            println("Warning: Generic parameter {} is being bound to itself", key)
            abort()
        }

        let mapped_value = .map_name(value)
        if key == mapped_value {
            return
        }

        .values[key] = mapped_value
    }

    function set_all(mut this, keys: [CheckedGenericParameter], values: [TypeId]) throws {
        for i in 0..(keys.size()) {
            let key = keys[i].type_id.to_string()
            let value = values[i].to_string()
            .set(key, value)
        }
    }

    function get(this, anon key: String) -> String? {
        return .values.get(key)
    }

    function map_name(this, anon type: String) -> String {
        mut mapped = .values.get(type)
        mut final_mapped_result = mapped
        while mapped.has_value() {
            final_mapped_result = mapped
            mapped = .values.get(mapped!)
        }
        return final_mapped_result ?? type
    }

    function map(this, anon type_id: TypeId) throws -> TypeId {
        return TypeId::from_string(.map_name(type_id.to_string()))
    }

    function iterator(this) => .values

    function perform_checkpoint(mut this, reset: bool = true) throws -> [String:String] {
        let result = .values
        .values = [:]

        if not reset {
            for (key, value) in result {
                .values[key] = value
            }
        }

        return result
    }

    function restore(mut this, anon checkpoint: [String:String]) {
        .values = checkpoint
    }
}

enum SafetyMode {
    Safe
    Unsafe
}

struct ModuleId {
    id: usize

    function equals(this, anon rhs: ModuleId) -> bool {
        return this.id == rhs.id
    }
}

struct VarId {
    module: ModuleId
    id: usize
}

struct FunctionId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: FunctionId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct StructId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: StructId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct EnumId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: EnumId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

enum StructOrEnumId {
    Struct(StructId)
    Enum(EnumId)
}

struct TypeId {
    module: ModuleId
    id: usize

    function none() -> TypeId? => None

    function equals(this, anon rhs: TypeId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function to_string(this) throws -> String {
        return format("{}_{}", .module.id, .id)
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function from_string(anon type_id_string: String) throws -> TypeId {
        let parts = type_id_string.split('_')
        if not (parts.size() == 2) {
            panic(format("Failed to convert string ‘{}’ to a TypeId: Wrong number of parts. (Wanted 2, got {})", type_id_string, parts.size()))
        }

        let module_id = parts[0].to_uint()
        let type_id = parts[1].to_uint()
        if not module_id.has_value() or not type_id.has_value() {
            panic(format("Failed to convert string ‘{}’ to a TypeId. (module_id = {} ({}), type_id = {} ({}))", type_id_string, module_id, parts[0], type_id, parts[1]))
        }

        return TypeId(module: ModuleId(id: module_id.value() as! usize), id: type_id.value() as! usize)
    }
}

struct TraitId {
    module: ModuleId
    id: usize

    function equals(this, anon other: TraitId) -> bool {
        return this.module.id == other.module.id and this.id == other.id
    }
}

struct ScopeId {
    module_id: ModuleId
    id: usize

    function equals(this, anon other: ScopeId) -> bool {
        return this.module_id.id == other.module_id.id and this.id == other.id
    }
}

enum BuiltinType {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never

    function id(this) => match this {
        Void => 0uz
        Bool => 1uz
        U8 => 2uz
        U16 => 3uz
        U32 => 4uz
        U64 => 5uz
        I8 => 6uz
        I16 => 7uz
        I32 => 8uz
        I64 => 9uz
        F32 => 10uz
        F64 => 11uz
        Usize => 12uz
        JaktString => 13uz
        CChar => 14uz
        CInt => 15uz
        Unknown => 16uz
        Never => 17uz
    }
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    Unknown
    Never
    TypeVariable(String)
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    GenericTraitInstance(id: TraitId, args: [TypeId])
    GenericResolvedType(id: StructId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    RawPtr(TypeId)
    Trait(TraitId)
    Reference(TypeId)
    MutableReference(TypeId)
    Function(params: [TypeId], can_throw: bool, return_type_id: TypeId, pseudo_function_id: FunctionId)

    function specificity(this, program: CheckedProgram, base_specificity: i64 = 1<<31) => match this {
        TypeVariable => 0
        GenericInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericEnumInstance(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        GenericResolvedType(args) => {
            mut specificity = base_specificity / 2
            for subtype_id in args.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        Function(params) => {
            mut specificity = base_specificity / 2
            for subtype_id in params.iterator() {
                let subtype = program.get_type(subtype_id)
                specificity += subtype.specificity(program, base_specificity: base_specificity/4)
            }
            yield specificity
        }
        else => base_specificity
    }

    function constructor_name(this) => match this {
        Void => "Void"
        Bool => "Bool"
        U8 => "U8"
        U16 => "U16"
        U32 => "U32"
        U64 => "U64"
        I8 => "I8"
        I16 => "I16"
        I32 => "I32"
        I64 => "I64"
        F32 => "F32"
        F64 => "F64"
        Usize => "Usize"
        JaktString => "JaktString"
        CChar => "CChar"
        CInt => "CInt"
        Unknown => "Unknown"
        Never => "Never"
        TypeVariable => "TypeVariable"
        GenericInstance => "GenericInstance"
        GenericEnumInstance => "GenericEnumInstance"
        GenericTraitInstance => "GenericTraitInstance"
        GenericResolvedType => "GenericResolvedType"
        Struct => "Struct"
        Enum => "Enum"
        RawPtr => "RawPtr"
        Trait => "Trait"
        Reference => "Reference"
        MutableReference => "MutableReference"
        Function => "Function"
    }

    function equals(this, anon rhs: Type) -> bool {
        if this is Void and rhs is Void {
            return true
        } else if this is Bool and rhs is Bool {
            return true
        } else if this is U8 and rhs is U8 {
            return true
        } else if this is U16 and rhs is U16 {
            return true
        } else if this is U32 and rhs is U32 {
            return true
        } else if this is U64 and rhs is U64 {
            return true
        } else if this is I8 and rhs is I8 {
            return true
        } else if this is I16 and rhs is I16 {
            return true
        } else if this is I32 and rhs is I32 {
            return true
        } else if this is I64 and rhs is I64 {
            return true
        } else if this is F32 and rhs is F32 {
            return true
        } else if this is F64 and rhs is F64 {
            return true
        } else if this is Usize and rhs is Usize {
            return true
        } else if this is JaktString and rhs is JaktString {
            return true
        } else if this is CChar and rhs is CChar {
            return true
        } else if this is CInt and rhs is CInt {
            return true
        }
        
        match this {
            TypeVariable(lhs_name) => {
                if rhs is TypeVariable(rhs_name) {
                    return lhs_name == rhs_name
                } else {
                    return false
                }
            }
            GenericInstance(id: lhs_id, args: lhs_args) => {
                guard rhs is GenericInstance(id: rhs_id, args: rhs_args) 
                    and lhs_id.equals(rhs_id)
                    and lhs_args.size() == rhs_args.size() else {
                    return false
                }
                mut idx = 0uz
                while idx < lhs_args.size() {
                    if not lhs_args[idx].equals(rhs_args[idx]) {
                        return false
                    }
                    idx++
                }
                return true
            }
            GenericTraitInstance(id: lhs_id, args: lhs_args) => {
                guard rhs is GenericTraitInstance(id: rhs_id, args: rhs_args)
                    and lhs_id.equals(rhs_id)
                    and lhs_args.size() == rhs_args.size() else {
                    return false
                }
                mut idx = 0uz
                while idx < lhs_args.size() {
                    if not lhs_args[idx].equals(rhs_args[idx]) {
                        return false
                    }
                    idx++
                }
                return true
            }
            GenericEnumInstance(id: lhs_id, args: lhs_args) => {
                guard rhs is GenericEnumInstance(id: rhs_id, args: rhs_args)
                    and lhs_id.equals(rhs_id)
                    and lhs_args.size() == rhs_args.size() else {
                    return false
                }
                mut idx = 0uz
                while idx < lhs_args.size() {
                    if not lhs_args[idx].equals(rhs_args[idx]) {
                        return false
                    }
                    idx++
                }
                return true
            }
            Struct(lhs_id) => {
                if rhs is Struct(rhs_id) {
                    return lhs_id.equals(rhs_id)
                }
                return false
            }
            Enum(lhs_id) => {
                if rhs is Enum(rhs_id) {
                    return lhs_id.equals(rhs_id)
                } else {
                    return false
                }
            }
            RawPtr(lhs_id) => {
                if rhs is RawPtr(rhs_id) {
                    return lhs_id.equals(rhs_id)
                } else {
                    return false
                }
            }
            Reference(lhs_id) => {
                if rhs is Reference(rhs_id) {
                    return lhs_id.equals(rhs_id)
                } else {
                    return false
                }
            }
            MutableReference(lhs_id) => {
                if rhs is MutableReference(rhs_id) {
                    return lhs_id.equals(rhs_id)
                } else {
                    return false
                }
            }
            Trait(lhs_id) => {
                if rhs is Trait(rhs_id) {
                    return lhs_id.equals(rhs_id)
                } else {
                    return false
                }
            }
            Function(params, can_throw, return_type_id) => {
                guard rhs is Function(params: rhs_params, can_throw: rhs_can_throw, return_type_id: rhs_return_type_id)
                    and params.size() == rhs_params.size()
                    and return_type_id.equals(rhs_return_type_id)
                    and can_throw == rhs_can_throw else {
                    return false
                }
                for i in 0..params.size() {
                    if not params[i].equals(rhs_params[i]) {
                        return false
                    }
                }
                return true
            }
            else => {}
        }

        return false
    }

    function is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt => true
        else => false
    }

    function get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    function is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    function min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    function max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }

    function flip_signedness(this) throws -> TypeId => match this {
        I8 => builtin(BuiltinType::U8)
        I16 => builtin(BuiltinType::U16)
        I32 => builtin(BuiltinType::U32)
        I64 => builtin(BuiltinType::U64)
        U8 => builtin(BuiltinType::I8)
        U16 => builtin(BuiltinType::I16)
        U32 => builtin(BuiltinType::I32)
        U64 => builtin(BuiltinType::I64)
        else => builtin(BuiltinType::Unknown)
    }
}

class Scope {
    public namespace_name: String?
    public vars: [String: VarId]
    public comptime_bindings: [String: Value]
    public structs: [String: StructId]
    public functions: [String: [FunctionId]]
    public enums: [String: EnumId]
    public types: [String: TypeId]
    public traits: [String: TraitId]
    public imports: [String: ModuleId] // FIXME: Span
    public parent: ScopeId?
    public children: [ScopeId]
    public can_throw: bool
    public import_path_if_extern: String?
    public after_extern_include: [IncludeAction]
    public before_extern_include: [IncludeAction]

    public debug_name: String
}

class Module {
    public id: ModuleId
    public name: String
    public functions: [CheckedFunction]
    public structures: [CheckedStruct]
    public enums: [CheckedEnum]
    public scopes: [Scope]
    public types: [Type]
    public traits: [CheckedTrait]
    public variables: [CheckedVariable]
    public imports: [ModuleId]
    public resolved_import_path: String

    public is_root: bool
    public function is_prelude(this) -> bool => .id.id == 0

    public function new_type_variable(mut this) throws -> TypeId {
        let new_id = .types.size()

        .types.push(Type::TypeVariable(format("T{}", new_id)))

        return TypeId(module: .id, id: new_id)
    }

    public function next_function_id(this) -> FunctionId {
        return FunctionId(module: .id, id: .functions.size())
    }

    public function add_function(mut this, checked_function: CheckedFunction) throws -> FunctionId {
        let new_id = .next_function_id()

        .functions.push(checked_function)

        return new_id
    }

    public function add_variable(mut this, anon checked_variable: CheckedVariable) throws -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

class CheckedTrait {
    public name: String
    public name_span: Span
    public methods: [String: FunctionId]
    public generic_parameters: [CheckedGenericParameter]
    public scope_id: ScopeId
}

struct LoadedModule {
    module_id: ModuleId
    file_id: FileId
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

boxed enum MaybeResolvedScope {
    Resolved(ScopeId)
    Unresolved(
        parent_scope: MaybeResolvedScope
        relative_name: String
    )

    function try_resolve(this, program: CheckedProgram) throws -> MaybeResolvedScope {
        return match this {
            Resolved(id) => MaybeResolvedScope::Resolved(id)
            Unresolved(parent_scope, relative_name) => {
                mut parent = parent_scope.try_resolve(program)
                if parent is Resolved(parent_scope_id) {
                    let scope = parent_scope_id
                    mut scope_id: ScopeId? = None
                    if not scope_id.has_value() {
                        let struct_ = program.find_struct_in_scope(scope_id: scope, name: relative_name)
                        if struct_.has_value() {
                            scope_id = program.get_struct(struct_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let enum_ = program.find_enum_in_scope(scope_id: scope, name: relative_name)
                        if enum_.has_value() {
                            scope_id = program.get_enum(enum_!).scope_id
                        }
                    }

                    if not scope_id.has_value() {
                        let ns = program.find_namespace_in_scope(scope_id: scope, name: relative_name)
                        if ns.has_value() {
                            scope_id = ns!.0
                        }
                    }

                    if not scope_id.has_value() {
                        let ids = program.find_functions_with_name_in_scope(parent_scope_id: scope, function_name: relative_name)
                        if ids.has_value() {
                            scope_id = program.get_function(ids![0]).function_scope_id
                        }
                    }
                    if (scope_id.has_value()) {
                        return MaybeResolvedScope::Resolved(scope_id!)
                    }
                }

                yield MaybeResolvedScope::Unresolved(parent_scope: parent, relative_name)
            }
        }
    }
}

enum CheckedVisibility {
    Public
    Private
    Restricted(scopes: [MaybeResolvedScope], span: Span)
}

class CheckedFunction {
    public name: String
    public name_span: Span
    public visibility: CheckedVisibility
    public return_type_id: TypeId
    public return_type_span: Span?
    public params: [CheckedParameter]
    public generics: FunctionGenerics
    public block: CheckedBlock
    public can_throw: bool
    public type: FunctionType
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId
    public struct_id: StructId?
    public is_instantiated: bool
    public parsed_function: ParsedFunction?
    public is_comptime: bool
    public is_virtual: bool
    public is_override: bool

    public function signature_matches(this, anon other: CheckedFunction) throws -> bool {
        if this.name != other.name or
        this.can_throw != other.can_throw or
        this.is_comptime != other.is_comptime {
            return false
        }

        if this.params.size() != other.params.size() {
            return false
        }

        if this.generics.params.size() != other.generics.params.size() {
            return false
        }

        mut lhs_generic_type_ids: {String} = {}
        mut rhs_generic_type_ids: {String} = {}
        for param in this.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            lhs_generic_type_ids.add(type_id.to_string())
        }
        for param in other.generics.params.iterator() {
            let type_id: TypeId = param.type_id()
            rhs_generic_type_ids.add(type_id.to_string())
        }

        for param_index in 0..this.params.size() {
            let lhs_param = this.params[param_index]
            let rhs_param = other.params[param_index]

            let lhs_param_id = lhs_param.variable.type_id.to_string()
            let rhs_param_id = rhs_param.variable.type_id.to_string()

            if not lhs_param.variable.type_id.equals(rhs_param.variable.type_id)
                and not (lhs_generic_type_ids.contains(lhs_param_id) and rhs_generic_type_ids.contains(rhs_param_id))
            {
                return false
            }
        }


        return true
    }

    public function is_static(this) -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public function is_mutating(this) -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }

    public function add_param(mut this, anon checked_param: CheckedParameter) throws {
        .params.push(checked_param)
        .generics.base_params.push(checked_param)
    }

    public function set_params(mut this, anon checked_params: [CheckedParameter]) throws {
        .params = checked_params
        .generics.base_params = checked_params
    }

    public function is_specialized_for_types(this, types: [TypeId]) -> bool {
        return .generics.is_specialized_for_types(types)
    }

    public function to_parsed_function(this) -> ParsedFunction {
        if not .parsed_function.has_value() {
            panic("to_parsed_function() called on a synthetic function")
        }
        return .parsed_function!
    }
}

class FunctionGenerics {
    public base_scope_id: ScopeId
    public base_params: [CheckedParameter]
    public params: [FunctionGenericParameter]
    public specializations: [[TypeId]]

    public function is_specialized_for_types(this, types: [TypeId]) -> bool {
        if types.size() == 0 {
            return true
        }

        for specialization in .specializations {
            mut matched = true

            if types.size() == specialization.size() {
                for i in ..types.size() {
                    if not types[i].equals(specialization[i]) {
                        matched = false
                        break
                    }
                }
            }

            if matched {
                return true
            }
        }

        return false
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
    default_value: CheckedExpression?
}

enum CheckedCapture {
    ByValue(name: String, span: Span)
    ByReference(name: String, span: Span)
    ByMutableReference(name: String, span: Span)

    function name(this) => match this {
        ByValue(name) => name
        ByReference(name) => name
        ByMutableReference(name) => name
    }

    function span(this) => match this {
        ByValue(span) => span
        ByReference(span) => span
        ByMutableReference(span) => span
    }
}

enum FunctionGenericParameterKind {
    InferenceGuide
    Parameter
}


struct FunctionGenericParameter {
    kind: FunctionGenericParameterKind
    checked_parameter: CheckedGenericParameter

    function type_id(this) => .checked_parameter.type_id

    function parameter(
        anon type_id: TypeId
        span: Span
    ) throws => FunctionGenericParameter(
        kind: FunctionGenericParameterKind::Parameter
        checked_parameter: CheckedGenericParameter::make(type_id, span)
    )
}

struct CheckedVariable {
    name: String
    type_id: TypeId
    is_mutable: bool
    definition_span: Span
    type_span: Span?
    visibility: CheckedVisibility
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

enum BlockControlFlow {
    AlwaysReturns
    AlwaysTransfersControl(might_break: bool)
    NeverReturns
    MayReturn
    // If expressions without 'else' branches may produce these.
    PartialAlwaysReturns(might_break: bool)
    PartialAlwaysTransfersControl(might_break: bool)
    PartialNeverReturns(might_break: bool)

    function unify_with(this, anon second: BlockControlFlow) => match this {
        NeverReturns => second
        AlwaysReturns => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            MayReturn => BlockControlFlow::MayReturn
            PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        }
        AlwaysTransfersControl(might_break: lhs) => match second {
            NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            else => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
        }
        MayReturn => match second {
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
            PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
            else => BlockControlFlow::MayReturn
        }
        PartialAlwaysReturns(might_break: lhs) => match second {
            PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::MayReturn
        }
        PartialAlwaysTransfersControl(might_break: lhs) => match second {
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) | PartialNeverReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns | NeverReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs)
        }
        PartialNeverReturns(might_break: lhs) => match second {
            PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break: lhs or might_break)
            PartialAlwaysTransfersControl(might_break) | PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break: lhs or might_break)
            AlwaysReturns => BlockControlFlow::AlwaysTransfersControl(might_break: lhs)
            AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break: lhs or might_break)
            MayReturn => BlockControlFlow::PartialNeverReturns(might_break: lhs)
            NeverReturns => BlockControlFlow::NeverReturns
        }
    }

    function updated(this, anon second: BlockControlFlow) => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => second
        PartialAlwaysTransfersControl | PartialAlwaysReturns | PartialNeverReturns => .unify_with(second)
    }

    function partial(this) => match this {
        NeverReturns => BlockControlFlow::PartialNeverReturns(might_break: false)
        AlwaysReturns => BlockControlFlow::PartialAlwaysReturns(might_break: false)
        MayReturn => BlockControlFlow::MayReturn
        AlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
        PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
        PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
    }

    function definitive(this) => match this {
        NeverReturns => BlockControlFlow::NeverReturns
        AlwaysReturns => BlockControlFlow::AlwaysReturns
        AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
        MayReturn => BlockControlFlow::MayReturn
        else => BlockControlFlow::MayReturn
    }

    function always_transfers_control(this) => match this {
        AlwaysReturns | AlwaysTransfersControl => true
        else => false
    }

    function never_returns(this) => match this {
        NeverReturns => true
        else => false
    }

    function always_returns(this) => match this {
        AlwaysReturns => true
        else => false
    }

    function may_return(this) => match this {
        MayReturn | PartialAlwaysReturns | PartialAlwaysTransfersControl | PartialNeverReturns => true
        else => false
    }

    function may_break(this) => match this {
        PartialAlwaysReturns(might_break) | PartialAlwaysTransfersControl(might_break) | PartialNeverReturns(might_break) | AlwaysTransfersControl(might_break) => might_break
        else => false
    }

    function is_reachable(this) => match this {
        NeverReturns | AlwaysReturns | AlwaysTransfersControl => false
        else => true
    }
}

struct CheckedBlock {
    statements: [CheckedStatement]
    scope_id: ScopeId
    control_flow: BlockControlFlow
    yielded_type: TypeId?
    yielded_none: bool
}

struct FieldRecord {
    struct_id: StructId
    field_id: VarId
}

struct CheckedField {
    variable_id: VarId
    default_value: CheckedExpression?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter]
    fields: [CheckedField]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:(TraitId, [TypeId])]
    record_type: RecordType
    type_id: TypeId
    super_struct_id: StructId?
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [CheckedGenericParameter]
    variants: [CheckedEnumVariant]
    fields: [CheckedField]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    trait_implementations: [String:(TraitId, [TypeId])]
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
    is_boxed: bool
}

struct CheckedGenericParameter {
    type_id: TypeId
    constraints: [TraitId]
    span: Span

    function make(anon type_id: TypeId, span: Span) throws => CheckedGenericParameter(type_id, constraints: [], span)
}

enum CheckedEnumVariant {
    Untyped(enum_id: EnumId, name: String, span: Span)
    Typed(enum_id: EnumId, name: String, type_id: TypeId, span: Span)
    WithValue(enum_id: EnumId, name: String, expr: CheckedExpression, span: Span)
    StructLike(enum_id: EnumId, name: String, fields: [VarId], span: Span)

    function equals(this, anon other: CheckedEnumVariant) -> bool {
        return match this {
            Untyped(name: this_name) => match other {
                Untyped(name: other_name) => this_name == other_name
                else => false
            }
            else => false
        }
    }

    function enum_id(this) -> EnumId => match this {
        Untyped(enum_id)
        | Typed(enum_id)
        | WithValue(enum_id)
        | StructLike(enum_id) => enum_id
    }

    function span(this) -> Span => match this {
        Untyped(span) => span
        Typed(span) => span
        WithValue(span) => span
        StructLike(span)  => span
    }

    function name(this) -> String => match this {
        Untyped(name) => name
        Typed(name) => name
        WithValue(name) => name
        StructLike(name)  => name
    }
}

struct CheckedEnumVariantBinding {
    name: String?
    binding: String
    type_id: TypeId
    span: Span
}

boxed enum CheckedStatement {
    Expression(expr: CheckedExpression, span: Span)
    Defer(statement: CheckedStatement, span: Span)
    DestructuringAssignment(vars: [CheckedStatement], var_decl: CheckedStatement, span: Span)
    VarDecl(var_id: VarId, init: CheckedExpression, span: Span)
    If(condition: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?, span: Span)
    Block(block: CheckedBlock, span: Span)
    Loop(block: CheckedBlock, span: Span)
    While(condition: CheckedExpression, block: CheckedBlock, span: Span)
    Return(val: CheckedExpression?, span: Span?)
    Break(Span)
    Continue(Span)
    Throw(expr: CheckedExpression, span: Span)
    Yield(expr: CheckedExpression, span: Span)
    InlineCpp(lines: [String], span: Span)
    Garbage(Span)

    function span(this) => match this {
        Expression(span) => Some(span)
        else(span) => span
    }

    function none() -> CheckedStatement? => None
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    function can_fit_number(this, type_id: TypeId, program: CheckedProgram) -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                    yield false
                }
                F64 => true
                else => false
            }
        }
    }

    function to_usize(this) -> usize => match this {
        Signed(value) => value as! usize
        Unsigned(value) => value as! usize
        Floating(value) => {
            panic("to_usize on a floating point constant")
        }
    }
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    function number_constant(this) -> NumberConstant? => match this {
        I8(value) =>  NumberConstant::Signed(value as! i64)
        I16(value) =>  NumberConstant::Signed(value as! i64)
        I32(value) =>  NumberConstant::Signed(value as! i64)
        I64(value) =>  NumberConstant::Signed(value as! i64)
        U8(value) =>  NumberConstant::Unsigned(value as! u64)
        U16(value) =>  NumberConstant::Unsigned(value as! u64)
        U32(value) =>  NumberConstant::Unsigned(value as! u64)
        U64(value) =>  NumberConstant::Unsigned(value as! u64)
        USize(value) =>  NumberConstant::Unsigned(value as! u64)

        // FIXME: add a case for F32 once we can cast f32 to f64

        F64(value) =>  NumberConstant::Floating(value)
        else => None
    }
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)

    function type_id(this) -> TypeId => match this {
        Fallible(type_id) => type_id
        Infallible(type_id) => type_id
    }
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    Reference
    MutableReference
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(enum_variant: CheckedEnumVariant, bindings: [CheckedEnumVariantBinding], type_id: TypeId)
}

enum CheckedMatchBody {
    Expression(CheckedExpression)
    Block(CheckedBlock)
}

enum CheckedMatchCase {
    defaults: [CheckedStatement]

    EnumVariant(name: String, args: [EnumVariantPatternArgument], subject_type_id: TypeId, index: usize, scope_id: ScopeId, body: CheckedMatchBody, marker_span: Span)
    Expression(expression: CheckedExpression, body: CheckedMatchBody, marker_span: Span)
    CatchAll(has_arguments: bool, body: CheckedMatchBody, marker_span: Span)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: String, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression?, to: CheckedExpression?, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId, key_type_id: TypeId, value_type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, is_optional: bool, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: Span, is_optional: bool, type_id: TypeId)
    IndexedCommonEnumMember(expr: CheckedExpression, index: String, span: Span, is_optional: bool, type_id: TypeId)
    Match(expr: CheckedExpression, match_cases: [CheckedMatchCase], span: Span, type_id: TypeId, all_variants_constant: bool)
    EnumVariantArg(expr: CheckedExpression, arg: CheckedEnumVariantBinding, enum_variant: CheckedEnumVariant, span: Span)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, is_optional: bool, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Function(captures: [CheckedCapture], params: [CheckedParameter], can_throw: bool, return_type_id: TypeId, block: CheckedBlock, span: Span, type_id: TypeId, pseudo_function_id: FunctionId?)
    Try(expr: CheckedExpression, catch_block: CheckedBlock?, catch_name: String?, span: Span, type_id: TypeId, inner_type_id: TypeId)
    TryBlock(stmt: CheckedStatement, catch_block: CheckedBlock, error_name: String, error_span: Span, span: Span, type_id: TypeId)
    Garbage(Span)

    function to_number_constant(this, program: CheckedProgram) -> NumberConstant? => match this {
        NumericConstant(val, span, type_id) => val.number_constant()
        UnaryOp(expr, op, span, type_id) => {
            mut result: NumberConstant? = None
            guard op is TypeCast(cast) else {
                return None
            }
            if not cast is Infallible {
                result = None
            }
            if not program.is_integer(type_id) and not program.is_floating(type_id) {
                result = None
            }
            if expr is NumericConstant(val) {
                result = val.number_constant()
            }
            yield result
        }
        else => None
    }

    function span(this) -> Span => match this {
        else(span) => span
    }

    function is_mutable(this, program: CheckedProgram) -> bool => match this {
        Var(var) => var.is_mutable
        IndexedStruct(expr) => expr.is_mutable(program)
        IndexedExpression(expr) => expr.is_mutable(program)
        IndexedTuple(expr) => expr.is_mutable(program)
        IndexedDictionary(expr) => expr.is_mutable(program)
        ForcedUnwrap(expr) => expr.is_mutable(program)
        UnaryOp(expr, op) => match op {
            Dereference => match program.get_type(expr.type()) {
                MutableReference => true
                RawPtr => expr.is_mutable(program)
                else => false
            }
            else => false
        }
        MethodCall(expr) => expr.is_mutable(program)
        else => false
    }

    function can_throw(this) -> bool => match this {
        Call(call) | MethodCall(call) => call.callee_throws

        else => false
    }

    function type(this) -> TypeId => match this {
        Boolean => builtin(BuiltinType::Bool)
        QuotedString => builtin(BuiltinType::JaktString)
        ByteConstant => builtin(BuiltinType::U8)
        CharacterConstant => builtin(BuiltinType::CChar)
        EnumVariantArg(arg) => arg.type_id
        NamespacedVar(var) => var.type_id
        Var(var) => var.type_id
        Garbage => builtin(BuiltinType::Void)
        else(type_id) => type_id
    }

    function control_flow(this) -> BlockControlFlow => match this {
        Match(expr, match_cases, span, type_id, all_variants_constant) => {
            mut control_flow: BlockControlFlow? = None
            for case_ in match_cases {
                let case_control_flow = match case_ {
                    EnumVariant(body) | Expression(body) | CatchAll(body) => match body {
                        Block(block) => block.control_flow
                        Expression(expr) => expr.control_flow()
                    }
                }
                if control_flow.has_value() {
                    control_flow = control_flow!.unify_with(case_control_flow.definitive())
                } else {
                    control_flow = case_control_flow.definitive()
                }
            }
            yield control_flow ?? BlockControlFlow::MayReturn
        }
        MethodCall(type_id) | Call(type_id) => match type_id.equals(never_type_id()) {
            true => BlockControlFlow::NeverReturns
            else => BlockControlFlow::MayReturn
        }
        else => BlockControlFlow::MayReturn
    }
}

struct ResolvedNamespace {
    name: String
    generic_parameters: [TypeId]?
}

struct CheckedCall {
    namespace_: [ResolvedNamespace]
    name: String,
    args: [(String, CheckedExpression)]
    type_args: [TypeId]
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool
}

function unknown_type_id() -> TypeId => builtin(BuiltinType::Unknown)
function void_type_id() -> TypeId => builtin(BuiltinType::Void)
function never_type_id() -> TypeId => builtin(BuiltinType::Never)

function builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin.id())
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    public compiler: Compiler
    public modules: [Module]
    public loaded_modules: [String: LoadedModule]

    public function create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool, debug_name: String, module_id: ModuleId) throws -> ScopeId {
        // Check that parent_scope_id is a valid ScopeId
        if parent_scope_id.has_value() {
            // Check that the ModuleId is valid
            if parent_scope_id!.module_id.id >= .modules.size() {
                .compiler.panic(format("create_scope: parent_scope_id.module is invalid! No module with id {}.", parent_scope_id!.module_id.id))
            }

            // Check that ScopeId.id is valid in the module
            if parent_scope_id!.id >= .modules[parent_scope_id!.module_id.id].scopes.size() {
                .compiler.panic(format("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}.", parent_scope_id!.module_id.id, parent_scope_id!.id))
            }
        }

        let none_string: String? = None

        let scope = Scope(
            namespace_name: none_string
            vars: [:]
            comptime_bindings: [:]
            structs: [:]
            functions: [:]
            enums: [:]
            types: [:]
            traits: [:]
            imports: [:]
            parent: parent_scope_id
            children: []
            can_throw
            import_path_if_extern: None
            after_extern_include: []
            before_extern_include: []
            debug_name
        )

        .modules[module_id.id].scopes.push(scope)

        return ScopeId(module_id, id: .modules[module_id.id].scopes.size() - 1)
    }

    public function get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public function get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public function get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public function get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public function get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public function get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public function get_scope(this, anon id: ScopeId) throws -> Scope {
        let max_scope = .modules[id.module_id.id].scopes.size() - 1
        if id.id > max_scope {
            .compiler.panic(format("scope_id {} does not exist in module", id))
        }

        return .modules[id.module_id.id].scopes[id.id]
    }

    public function get_trait(this, anon id: TraitId) -> CheckedTrait => .modules[id.module.id].traits[id.id]

    public function prelude_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 0), id: 0)

    public function set_loaded_module(mut this, module_name: String, loaded_module: LoadedModule) throws {
        .loaded_modules.set(
            key: module_name
            value: loaded_module
        )
    }
    public function get_loaded_module(this, anon module_name: String) -> LoadedModule? {
        return .loaded_modules.get(module_name)
    }

    public function find_var_in_scope(this, scope_id: ScopeId, var: String) throws -> CheckedVariable? {
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            let maybe_var = scope.vars.get(var)
            if maybe_var.has_value() {
                return .get_variable(maybe_var!)
            }
            if not scope.parent.has_value() {
                break
            }
            current_scope_id = scope.parent!
        }
        return None
    }

    public function find_comptime_binding_in_scope(this, scope_id: ScopeId, anon name: String) throws -> Value? {
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            let maybe_var = scope.comptime_bindings.get(name)
            if maybe_var.has_value() {
                return maybe_var
            }
            if not scope.parent.has_value() {
                break
            }
            current_scope_id = scope.parent!
        }
        return None
    }

    public function find_enum_in_scope(this, scope_id: ScopeId, name: String) throws -> EnumId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_enum = scope.enums.get(name)
            if maybe_enum.has_value() {
                return maybe_enum
            }
            for child_id in scope.children {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    let maybe_enum = child_scope.enums.get(name)
                    if maybe_enum.has_value() {
                        return maybe_enum
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    public function find_trait_in_scope(this, scope_id: ScopeId, name: String) throws -> TraitId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_trait = scope.traits.get(name)
            if maybe_trait.has_value() {
                return maybe_trait
            }
            for child_id in scope.children {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    let maybe_trait = child_scope.traits.get(name)
                    if maybe_trait.has_value() {
                        return maybe_trait
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    public function is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public function is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public function is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public function is_string(this, anon type_id: TypeId) -> bool => .get_type(type_id) is JaktString

    public function get_bits(this, anon type_id: TypeId) => .get_type(type_id).get_bits()

    public function is_signed(this, anon type_id: TypeId) => .get_type(type_id).is_signed()

    public function find_struct_in_scope(this, scope_id: ScopeId, name: String) throws -> StructId? {
        mut current_scope_id = Some(scope_id)
        while current_scope_id.has_value() {
            let scope = .get_scope(id: current_scope_id!)
            let maybe_scope = scope.structs.get(name)
            if maybe_scope.has_value() {
                return maybe_scope
            }
            for child_id in scope.children {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    let maybe_scope = child_scope.structs.get(name)
                    if maybe_scope.has_value() {
                        return maybe_scope
                    }
                }
            }
            current_scope_id = scope.parent
        }
        return None
    }

    public function find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return struct_id.value()
        }

        .compiler.panic(format("internal error: {} builtin definition not found", name))
    }

    public function find_namespace_in_scope(this, scope_id: ScopeId, anon name: String) throws -> (ScopeId, bool)? {
        mut current = scope_id;

        loop {
            let scope = .get_scope(current)

            for child in scope.children {
                let child_scope = .get_scope(child)
                if child_scope.namespace_name.has_value() {
                    if name == child_scope.namespace_name.value() {
                        return (child, false)
                    }
                }
            }

            for child_id in scope.children {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    for scope in .get_scope(child_id).children {
                        let descendant_scope = .get_scope(scope)
                        if descendant_scope.namespace_name.has_value() {
                            if name == descendant_scope.namespace_name.value() {
                                return (scope, false)
                            }
                        }
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        // if we do not find it then check imports
        let module_id = scope_id.module_id

        let search_scope_id = ScopeId(module_id: module_id, id: 0)
        let search_scope = .get_scope(search_scope_id)
        let search_imports = search_scope.imports
        let maybe_import: ModuleId? = search_imports.get(name)
        if maybe_import.has_value() {
            let import_module_id: ModuleId = maybe_import!
            let import_scope_id = ScopeId(module_id: import_module_id, id: 0)
            return (import_scope_id, true)
        }

        return None
    }

    public function find_functions_with_name_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> [FunctionId]? {
        mut visited: [ScopeId] = []
        mut queue: [ScopeId] = [parent_scope_id]
        mut scope_id = Some(parent_scope_id)
        while not queue.is_empty() {
            let scope_id = queue.pop()!
            {
                mut was_visited = false
                for visited_id in visited {
                    if visited_id.equals(scope_id) {
                        was_visited = true
                        break
                    }
                }
                if was_visited {
                    continue
                }
            }
            visited.push(scope_id)
            let scope = .get_scope(id: scope_id)
            let maybe_function = scope.functions.get(function_name)
            if maybe_function.has_value() {
                return maybe_function
            }
            // search inside inline namespaces
            for child_scope_id in scope.children {
                let scope = .get_scope(id: child_scope_id)
                if not scope.namespace_name.has_value() {
                    queue.push(child_scope_id)
                }
            }
            if scope.parent.has_value() {
                let parent = scope.parent!
                if parent.equals(scope_id) {
                    .compiler.panic(format("Scope {} is its own parent!", scope_id))
                }
                queue.push(parent)
            }
        }
        return None
    }

    // Checks given struct id is weak ptr and
    //  validates args are compatible with weak ptr type
    // Returns the inner struct id if given struct is weak ptr
    public function check_and_extract_weak_ptr(this, struct_id: StructId, args: [TypeId]) throws -> StructId? {
        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

        if struct_id.equals(weak_ptr_struct_id) {
            if (args.size() != 1) {
                .compiler.panic(
                    format(
                        "Internal error: Generic type is WeakPtr but there are not exactly 1 type parameter. There are {} parameters.",
                        args.size()
                    )
                )
            }

            let inner_type_id = args[0]
            let inner_type = .get_type(inner_type_id)

            if inner_type is Struct(inner_struct_id) {
                return inner_struct_id
            }
            panic(
                format(
                    "Internal error: Inner type of WeakPtr is not a struct. It is {}.",
                    inner_type
                )
            )
        } else {
            return None
        }
    }

    public function type_name(this, anon type_id: TypeId) throws -> String {
        let type = .get_type(type_id)

        return match type {
            Never => "never"
            F32 => "f32"
            F64 => "f64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            Void => "void"
            Unknown => "unknown"
            JaktString => "String"
            Trait(id) => .get_trait(id).name
            Function(params, return_type_id) => {
                mut param_names: [String] = []
                for x in params {
                    param_names.push(.type_name(x))
                }

                let return_type = .type_name(return_type_id)

                yield format("function({}) -> {}", join(param_names, separator: ", "), return_type)
            }
            Enum(id) => .get_enum(id).name
            Struct(id) => .get_struct(id).name
            GenericEnumInstance(id, args) => {
                mut output = format("enum {}", .get_enum(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg)
                }

                output += ">"

                yield output
            }
            GenericTraitInstance(id, args) => {
                mut output = format("trait {}", .get_trait(id).name)

                output += "<"
                mut first = true
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg)
                }

                output += ">"

                yield output
            }
            GenericInstance(id, args) => {

                let array_struct_id = .find_struct_in_prelude("Array")
                let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
                let optional_struct_id = .find_struct_in_prelude("Optional")
                let range_struct_id = .find_struct_in_prelude("Range")
                let set_struct_id = .find_struct_in_prelude("Set")
                let tuple_struct_id = .find_struct_in_prelude("Tuple")
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                mut output = ""

                if id.equals(array_struct_id) {
                    output = format("[{}]", .type_name(args[0]))
                } else if id.equals(dictionary_struct_id) {
                    output = format("[{}:{}]", .type_name(args[0]), .type_name(args[1]))
                } else if id.equals(optional_struct_id) {
                    output = format("{}?", .type_name(args[0]))
                } else if id.equals(range_struct_id) {
                    output = format("{}..{}", .type_name(args[0]), .type_name(args[0]))
                } else if id.equals(set_struct_id) {
                    output = format("{{{}}}", .type_name(args[0]))
                } else if id.equals(tuple_struct_id) {
                    output = "("
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg)
                    }
                    output += ")"
                } else if id.equals(weak_ptr_struct_id) {
                    output = format("weak {}?", .type_name(args[0]))
                } else {
                    let structure = .get_struct(id)
                    output = structure.name
                    output += "<"
                    mut first = true
                    for arg in args {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(arg)
                    }
                    output += ">"
                }

                yield output
            }
            GenericResolvedType(id, args) => {
                mut output = .get_struct(id).name
                mut first = true
                output += "<"
                for arg in args {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }
                    output += .type_name(type_id)
                }
                output += ">"

                yield output
            }
            TypeVariable(name) => name
            RawPtr(type_id) => format("raw {}", .type_name(type_id))
            Reference(type_id) => format("&{}", .type_name(type_id))
            MutableReference(type_id) => format("&mut {}", .type_name(type_id))
        }
    }

    public function find_or_add_type_id(mut this, anon type: Type, module_id: ModuleId) throws -> TypeId {
        for module in .modules {
            for id in 0..module.types.size() {
                if module.types[id].equals(type) {
                    return TypeId(module: module.id, id)
                }
            }
        }

        .modules[module_id.id].types.push(type)

        return TypeId(module: module_id, id: .modules[module_id.id].types.size() - 1)
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    public function substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: GenericInferences, module_id: ModuleId) throws -> TypeId {
        mut result = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

        loop {
            let fixed_point = .substitute_typevars_in_type_helper(type_id, generic_inferences, module_id)

            if fixed_point.equals(result) {
                break
            } else {
                result = fixed_point
            }
        }
        return result
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function substitute_typevars_in_type_helper(mut this, type_id: TypeId , generic_inferences: GenericInferences, module_id: ModuleId) throws -> TypeId {
        let type_ = .get_type(type_id)

        match type_ {
            TypeVariable() => {
                let replacment_type_id_string = generic_inferences.get(type_id.to_string())
                if replacment_type_id_string.has_value() {
                    return TypeId::from_string(replacment_type_id_string.value())
                }
            }
            GenericTraitInstance(id, args) => {
                mut new_args: [TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericTraitInstance(id, args: new_args), module_id)
            }
            GenericInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }

                return .find_or_add_type_id(Type::GenericInstance(id, args: new_args), module_id)
            }
            GenericEnumInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences, module_id))
                }
                return .find_or_add_type_id(Type::GenericEnumInstance(id, args: new_args), module_id)
            }
            Struct(struct_id) => {
                let struct_ = .get_struct(struct_id)
                if not struct_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(struct_.generic_parameters.size())
                    for arg in struct_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericInstance(id: struct_id, args: new_args), module_id)
                }
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                if not enum_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(enum_.generic_parameters.size())
                    for arg in enum_.generic_parameters {
                        new_args.push(.substitute_typevars_in_type(type_id: arg.type_id, generic_inferences, module_id))
                    }
                    return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id, args: new_args), module_id)
                }
            }
            RawPtr(rawptr_type_id) => {
                let rawptr_type = Type::RawPtr(
                    .substitute_typevars_in_type(type_id: rawptr_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(rawptr_type, module_id)
            }
            Reference(ref_type_id) => {
                let ref_type = Type::Reference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            MutableReference(ref_type_id) => {
                let ref_type = Type::MutableReference(
                    .substitute_typevars_in_type(type_id: ref_type_id, generic_inferences, module_id)
                )
                return .find_or_add_type_id(ref_type, module_id)
            }
            Function(params, can_throw, return_type_id, pseudo_function_id) => {
                mut new_params:[TypeId] = []
                new_params.ensure_capacity(params.size())
                mut is_different = false
                for param in params {
                    let new_param = .substitute_typevars_in_type(type_id: param, generic_inferences, module_id)
                    is_different = is_different or not new_param.equals(param)
                    new_params.push(new_param)
                }

                let return_type_substitute = .substitute_typevars_in_type(type_id: return_type_id, generic_inferences, module_id)
                is_different = is_different or not return_type_substitute.equals(return_type_id)

                if not is_different {
                    return type_id
                }

                let previous_function = .get_function(pseudo_function_id)

                mut replacement_params: [CheckedParameter] = []
                for i in 0uz..previous_function.params.size() {
                    let param = previous_function.params[i]
                    let new_param = CheckedParameter(
                        requires_label: param.requires_label
                        variable: CheckedVariable(
                            name: param.variable.name
                            type_id: new_params[i]
                            is_mutable: param.variable.is_mutable
                            definition_span: param.variable.definition_span
                            type_span: param.variable.type_span
                            visibility: param.variable.visibility
                        )
                        default_value: param.default_value
                    )
                    replacement_params.push(new_param)
                }
                
                let new_function = CheckedFunction(
                    name: previous_function.name
                    name_span: previous_function.name_span
                    visibility: previous_function.visibility
                    return_type_id: return_type_substitute
                    return_type_span: previous_function.return_type_span
                    params: replacement_params
                    generics: previous_function.generics
                    block: previous_function.block
                    can_throw
                    type: previous_function.type
                    linkage: previous_function.linkage
                    function_scope_id: previous_function.function_scope_id
                    struct_id: previous_function.struct_id
                    is_instantiated: previous_function.is_instantiated
                    parsed_function: previous_function.parsed_function
                    is_comptime: previous_function.is_comptime
                    is_virtual: previous_function.is_virtual
                    is_override: previous_function.is_override
                )

                let new_function_id = .modules[module_id.id].add_function(checked_function: new_function)

                return .find_or_add_type_id(Type::Function(params: new_params, can_throw, return_type_id: return_type_substitute, pseudo_function_id: new_function_id), module_id)
            }
            else => {
                return type_id
            }
        }
        return type_id
    }
}

boxed enum ValueImpl {
    Void
    Bool(bool)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    F32(f32)
    F64(f64)
    USize(usize)
    JaktString(String)
    CChar(c_char)
    CInt(c_int)
    Struct(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Class(fields: [Value], struct_id: StructId, constructor: FunctionId?)
    Enum(fields: [Value], enum_id: EnumId, constructor: FunctionId)
    JaktArray(values: [Value], type_id: TypeId)
    JaktDictionary(keys: [Value], values: [Value], type_id: TypeId)
    JaktSet(values: [Value], type_id: TypeId)
    RawPtr(ValueImpl)
    OptionalSome(value: Value)
    OptionalNone
    JaktTuple(fields: [Value], type_id: TypeId)
    Function(captures: [String:Value], params: [String:(TypeId, CheckedExpression?)], return_type_id: TypeId, type_id: TypeId, block: CheckedBlock, can_throw: bool, checked_params: [CheckedParameter])

    function copy(this) throws => match this {
        Void => ValueImpl::Void
        Bool(x) => ValueImpl::Bool(x)
        U8(x) => ValueImpl::U8(x)
        U16(x) => ValueImpl::U16(x)
        U32(x) => ValueImpl::U32(x)
        U64(x) => ValueImpl::U64(x)
        I8(x) => ValueImpl::I8(x)
        I16(x) => ValueImpl::I16(x)
        I32(x) => ValueImpl::I32(x)
        I64(x) => ValueImpl::I64(x)
        F32(x) => ValueImpl::F32(x)
        F64(x) => ValueImpl::F64(x)
        USize(x) => ValueImpl::USize(x)
        JaktString(x) => ValueImpl::JaktString(x)
        CChar(x) => ValueImpl::CChar(x)
        CInt(x) => ValueImpl::CInt(x)
        Struct(fields, struct_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Struct(fields: fields_copy, struct_id, constructor)
        }
        Class(fields, struct_id, constructor) => ValueImpl::Class(fields, struct_id, constructor)
        Enum(fields, enum_id, constructor) => {
            mut fields_copy: [Value] = [];
            for field in fields {
                fields_copy.push(field.copy());
            }
            yield ValueImpl::Enum(fields: fields_copy, enum_id, constructor)
        }
        JaktArray(values, type_id) => {
            mut values_copy: [Value] = [];
            for value in values {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktArray(values: values_copy, type_id)
        }
        JaktDictionary(keys, values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            mut keys_copy: [Value] = []
            for key in keys {
                keys_copy.push(key.copy())
            }
            yield ValueImpl::JaktDictionary(keys: keys_copy, values: values_copy, type_id)
        }
        JaktSet(values, type_id) => {
            mut values_copy: [Value] = []
            for value in values {
                values_copy.push(value.copy())
            }
            yield ValueImpl::JaktSet(values: values_copy, type_id)
        }
        RawPtr(value) => ValueImpl::RawPtr(value)
        OptionalSome(value) => ValueImpl::OptionalSome(value: value.copy())
        OptionalNone => ValueImpl::OptionalNone
        JaktTuple(fields, type_id) => {
            mut values_copy: [Value] = [];
            for value in fields {
                values_copy.push(value.copy());
            }
            yield ValueImpl::JaktTuple(fields: values_copy, type_id)
        }
        Function(captures, params, can_throw, return_type_id, type_id, block, checked_params) => ValueImpl::Function(captures, params, return_type_id, type_id, block, can_throw, checked_params)
    }

    function equals(this, anon other: ValueImpl) => match this {
        Void => other is Void
        Bool(x) => match other { Bool(y) => x == y else => false }
        U8(x) => match other { U8(y) => x == y else => false }
        U16(x) => match other { U16(y) => y == x else => false }
        U32(x) => match other { U32(y) => y == x else => false }
        U64(x) => match other { U64(y) => y == x else => false }
        I8(x) => match other { I8(y) => y == x else => false }
        I16(x) => match other { I16(y) => y == x else => false }
        I32(x) => match other { I32(y) => y == x else => false }
        I64(x) => match other { I64(y) => y == x else => false }
        F32(x) => match other { F32(y) => y == x else => false }
        F64(x) => match other { F64(y) => y == x else => false }
        USize(x) => match other { USize(y) => y == x else => false }
        JaktString(x) => match other { JaktString(y) => y == x else => false }
        CChar(x) => match other { CChar(y) => y == x else => false }
        CInt(x) => match other { CInt(y) => y == x else => false }
        else => false
    }
}

struct Value {
    impl: ValueImpl
    span: Span

    function copy(this) throws => Value(impl: .impl.copy(), span: .span)
    function type_name(this) => match .impl {
        Void => "void"
        Bool => "bool"
        U8 => "u8"
        U16 => "u16"
        U32 => "u32"
        U64 => "u64"
        I8 => "i18"
        I16 => "i16"
        I32 => "i32"
        I64 => "i64"
        F32 => "f32"
        F64 => "f64"
        USize => "usize"
        JaktString => "String"
        CChar => "c_char"
        CInt => "c_int"
        Struct => "struct <T>"
        Class => "class <T>"
        Enum => "enum <T>"
        JaktArray => "Array"
        JaktDictionary => "Dictionary"
        JaktSet => "Set"
        RawPtr => "raw <T>"
        OptionalSome => "Some"
        OptionalNone => "None"
        JaktTuple => "Tuple"
        Function => "Function"
    }
    function cast(this, anon expected: Value, span: Span) throws -> Value => match .impl {
        U8(value) => match expected.impl {
            U16 => Value(impl: ValueImpl::U16(value as! u16), span: span)
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U16(value) => match expected.impl {
            U32 => Value(impl: ValueImpl::U32(value as! u32), span: span)
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this 
        }
        U32(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        U64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span)
            else => this
        }
        I8(value) => match expected.impl {
            I16 => Value(impl: ValueImpl::I16(value as! i16), span: span)
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I16(value) => match expected.impl {
            I32 => Value(impl: ValueImpl::I32(value as! i32), span: span)
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I32(value) => match expected.impl {
            I64 => Value(impl: ValueImpl::I64(value as! i64), span: span)
            else => this
        }
        I64(value) => match expected.impl {
            USize => Value(impl: ValueImpl::USize(value as! usize), span: span) // yuck
            else => this
        }
        USize(value) => match expected.impl {
            U64 => Value(impl: ValueImpl::U64(value as! u64), span: span)
            // No idea why this is allowed.
            CInt => Value(impl: ValueImpl::CInt(value as! c_int), span: span)
            else => this
        }
        OptionalSome => this
        else => match expected.impl {
            OptionalSome | OptionalNone => Value(impl: ValueImpl::OptionalSome(value: this), span: span)
            else => this
        }
    }
}
