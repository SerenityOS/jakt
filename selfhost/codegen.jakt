// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause

import parser { BinaryOperator, FunctionLinkage, ParsedBlock }
import typechecker {
    BuiltinType, CheckedBinaryOperator, CheckedBlock, CheckedCall, CheckedEnum, CheckedExpression, CheckedFunction
    CheckedMatchBody, CheckedMatchCase, CheckedProgram, CheckedStatement, CheckedStruct, CheckedVariable
    CheckedVisibility, EnumId, FunctionId, Module, ModuleId, Scope, ScopeId, StructId, Type, TypeId, VarId, builtin
    never_type_id, unknown_type_id, void_type_id
}
import types { CheckedGenericParameter, CheckedParameter, FunctionGenericParameter, SafetyMode, StructLikeId }
import utility { Queue, Span, escape_for_quotes, interpret_escapes, join, panic, prepend_to_each, todo }
import compiler { Compiler }
import jakt::path { Path }
import interpreter { Interpreter, TypecheckFunctions, value_to_checked_expression }
import jakt::platform { platform_fs }
import platform_fs() { make_directory }

enum AllowedControlExits {
    /// No control exit statements allowed
    Nothing
    /// Only `return` allowed
    JustReturn
    /// `continue`/`break` allowed: `return` is also allowed in this context
    AtLoop

    fn allow_return(this) -> AllowedControlExits => match this {
        Nothing | JustReturn => AllowedControlExits::JustReturn
        AtLoop => AllowedControlExits::AtLoop
    }
}

fn are_loop_exits_allowed(anon allowed_control_exits: AllowedControlExits) -> bool => allowed_control_exits is AtLoop
fn is_return_allowed(anon allowed_control_exits: AllowedControlExits) -> bool => not allowed_control_exits is Nothing

struct ControlFlowState {
    allowed_exits: AllowedControlExits
    passes_through_try: bool
    // whether the current scope is a match IIFE
    directly_inside_match: bool = false
    // whether any outer scope is a match IIFE
    indirectly_inside_match: bool = false
    // whether any outer scope is try block
    indirectly_inside_try_block: bool = false

    fn no_control_flow() -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::Nothing
            passes_through_try: false
            directly_inside_match: false
            indirectly_inside_match: false
        )
    }
    fn enter_function(this) -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::JustReturn
            passes_through_try: false
            directly_inside_match: false
            indirectly_inside_match: false
        )
    }
    fn enter_loop(this) -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::AtLoop
            passes_through_try: .passes_through_try
            directly_inside_match: false
            indirectly_inside_match: .indirectly_inside_match
        )
    }
    fn enter_match(this) -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: .allowed_exits.allow_return()
            passes_through_try: .passes_through_try
            directly_inside_match: true
            indirectly_inside_match: true
        )
    }

    // apply control flow macro to a match, from outside its scope
    fn apply_control_flow_macro(this, anon x: String, func_return_type: TypeId, func_can_throw: bool) throws -> String {
        let handle_loop_controls = match are_loop_exits_allowed(.allowed_exits) {
            // Not inside a loop, so the inner match better not yield those
            // values, since there's no one that can catch them.
            // In practice it's impossible because break/continue is guaranteed
            // by the typechecker to only appear within loop contexts.
            false => ""
            // there's a loop somewhere up there.
            true => {
                let (break_stmt, continue_stmt) = match .directly_inside_match {
                    // This match has to forward the loop break/continues
                    true => ("return JaktInternal::LoopBreak {}", "return JaktInternal::LoopContinue {}")
                    // This is the loop that the inner match wants to modify the control flow of.
                    false => ("break", "continue")

                }
                yield format("if (_jakt_value.is_loop_break())
        {};
    if (_jakt_value.is_loop_continue())
        {};
    ", break_stmt, continue_stmt)
            }
        }

        let cpp_func_returns_void = not func_can_throw and (
            func_return_type == void_type_id() or
            func_return_type == unknown_type_id() or
            func_return_type == never_type_id())

        // Make sure we don't return 'void' when forwarding a return inside a match IIFE.
        // We'll have to use {} like in the codegen for return, to construct an
        // `ExplicitValueOrControlFlow` that signals that we want to return from
        // the top-level function.
        let substitute_naked_return = .indirectly_inside_match and cpp_func_returns_void
        let forward_return_expr = match substitute_naked_return {
            true => "{}"
            false => "_jakt_value.release_return()"
        }

        return format("({{
    auto&& _jakt_value = {0};
    if (_jakt_value.is_return())
        return {1};
    {2}_jakt_value.release_value();
}})",
            x, forward_return_expr, handle_loop_controls
        )


    }
}

struct LineSpan {
    start: usize
    end: usize
}

struct CodegenDebugInfo {
    // FIXME: Add support for multiple source files
    compiler: Compiler
    line_spans: [usize: [LineSpan]]
    statement_span_comments: bool

    fn span_to_source_location(mut this, anon span: Span) throws -> String {
        if .line_spans.is_empty() {
            .gather_line_spans()
        }

        let file_idx = span.file_id.id

        if not .line_spans.contains(file_idx) {
            return ""
        }

        mut line_index = 0uz
        while line_index < .line_spans[file_idx].size() {
            if span.start >= .line_spans[file_idx][line_index].start and span.start <= .line_spans[file_idx][line_index].end {
                let column_index = span.start - .line_spans[file_idx][line_index].start
                return format("{} \"{}\"", line_index+1, .compiler.get_file_path(span.file_id)!.to_string())
            }
            line_index += 1
        }

        panic("Reached end of file and could not find index")
    }

    fn gather_line_spans(mut this) throws {
        for file in .compiler.file_ids {

            if file.0 == "__prelude__" {
                continue
            }

            .compiler.set_current_file(file.1)

            let file_idx = file.1.id

            // FIXME: remove when we can infer the type
            let empty_array: [LineSpan] = []
            .line_spans.set(file_idx, empty_array)

            mut idx = 0uz
            mut start = idx
            while idx < .compiler.current_file_contents.size() {
                if .compiler.current_file_contents[idx] == b'\n' {
                    .line_spans[file_idx].push(LineSpan(start, end: idx))
                    start = idx + 1
                }
                idx += 1
            }
            if start < idx {
                .line_spans[file_idx].push(LineSpan(start, end: idx))
            }
        }
    }
}


enum YieldMethod {
    // return ExplicitValue from match.
    // the template is for JaktInternal::Explicit
    ReturnExplicitValue(ctor: String)
    AssignAndGoto(name: String, label: String)
}


struct CodeGenerator {

    compiler: Compiler
    program: CheckedProgram

    control_flow_state: ControlFlowState
    entered_yieldable_blocks: [(String, String)] // label, variable name
    deferred_output: StringBuilder = StringBuilder::create()
    current_function: CheckedFunction?
    inside_defer: bool
    debug_info: CodegenDebugInfo
    namespace_stack: [String]
    fresh_var_counter: usize
    fresh_label_counter: usize
    this_replacement: String? = None
    generic_inferences: [TypeId:TypeId]? = None
    // Modules that this generation depends on, detected from type definitions
    used_modules: {ModuleId} = {}
    yield_method: YieldMethod? = None

    // `forward_error_with_try` controls whether errors are handled through the TRY() macro or through an external mechanism put by the caller.
    // noreturn functions may not throw, so let them crash instead.
    fn current_error_handler(this, forward_error_with_try: bool = true) -> String {
        if .inside_defer or (
            .current_function.has_value() and
            .current_function!.return_type_id == never_type_id() and
            not .control_flow_state.passes_through_try
        ) {

            return "MUST"
        }

        if forward_error_with_try {
            if .control_flow_state.indirectly_inside_try_block {
                // We can't use TRY() as that would return errors instead of forwarding them to the corresponding catch block.
                return "TRY_EXPLICIT"
            } else {
                return "TRY"
            }
        } else {
            return ""
        }
    }

    fn fresh_var(mut this) -> String => format("__jakt_var_{}", .fresh_var_counter++)

    fn fresh_label(mut this) -> String => format("__jakt_label_{}", .fresh_label_counter++)

    fn topologically_sort_modules(this) -> [ModuleId] {
        mut in_degrees: [usize:i64] = [:]

        for module in .program.modules {
            for imported_module in module.imports {
                let existing = in_degrees.get(imported_module.id) ?? 0
                in_degrees.set(imported_module.id, existing + 1)
            }

            if not in_degrees.contains(module.id.id) {
                in_degrees.set(module.id.id, 0)
            }
        }

        mut stack: [ModuleId] = []
        for module in .program.modules {
            if in_degrees[module.id.id] == 0 {
                stack.push(module.id)
            }
        }

        mut sorted_modules: [ModuleId] = []
        while not stack.is_empty() {
            let id = stack.pop()!
            sorted_modules.push(id)
            for imported_module in .program.modules[id.id].imports {
                let module_in_degrees = in_degrees[imported_module.id]
                in_degrees.set(imported_module.id, module_in_degrees - 1)
                if module_in_degrees == 1 {
                    stack.push(ModuleId(id: imported_module.id))
                }
            }
        }

        if sorted_modules.size() == .program.modules.size() {
            return sorted_modules
        }

        panic("Cyclic module imports")
    }

    fn generate(compiler: Compiler, anon program: CheckedProgram, debug_info: bool, exported_files: &mut [String:String]) throws -> [String:(String, String)] {
        mut generator = CodeGenerator(
            compiler
            program
            control_flow_state: ControlFlowState::no_control_flow()
            entered_yieldable_blocks: []
            current_function: None
            inside_defer: false
            //TODO: use program.loaded_modules
            debug_info: CodegenDebugInfo(
                compiler
                line_spans: [:]
                statement_span_comments: debug_info
            )
            namespace_stack: []
            fresh_var_counter: 0
            fresh_label_counter: 0
        )

        mut result: [String:(String, String)] = [:]

        // Share the output builder between stages so that any module
        // generation that gets cleared maintains the reserved memory.
        mut output = StringBuilder::create()

        let sorted_modules = generator.topologically_sort_modules()

        mut modules_in_header: [usize:{ModuleId}] = [:]

        for idx in sorted_modules.size()..0 {
            // Module forward declarations header
            let i = sorted_modules[idx - 1].id
            if i == 0 {
                // Skip 0 because it's the prelude
                continue
            }

            let module = generator.program.modules[i]
            generator.compiler.dbg_println(format("generate: module idx: {}, module.name {} - forward: {}", i, module.name, true))

            let header_name = format("{}.h", module.name)

            output.clear()
            output.append("#pragma once\n")
            output.append("#include <lib.h>\n")

            let main_id = match module.id.id {
                1 => 1uz
                else => 0uz
            }
            let scope_id = ScopeId(module_id: module.id, id: main_id)
            let scope = generator.program.get_scope(scope_id)

            for child_scope_id in scope.children {
                let scope = generator.program.get_scope(child_scope_id)
                if scope.import_path_if_extern.has_value() {
                    let name = scope.namespace_name_for_codegen()?.as_name_for_definition()
                    if name.has_value() {
                        output.appendff("namespace {} {{\n", name!)
                    }
                    for action in scope.before_extern_include {
                        match action {
                            Define(name, value) => {
                                output.appendff("#ifdef {}\n", name)
                                output.appendff("#undef {}\n", name)
                                output.append("#endif\n")
                                output.appendff("#define {} {}\n", name, value)
                            }
                            Undefine(name) => {
                                output.appendff("#ifdef {}\n", name)
                                output.appendff("#undef {}\n", name)
                                output.append("#endif\n")
                            }
                        }
                    }
                    output.appendff("#include <{}>\n", scope.import_path_if_extern!)
                    for action in scope.after_extern_include {
                        match action {
                            Define(name, value) => {
                                output.appendff("#ifdef {}\n", name)
                                output.appendff("#undef {}\n", name)
                                output.append("#endif\n")
                                output.appendff("#define {} {}\n", name, value)
                            }
                            Undefine(name) => {
                                output.appendff("#ifdef {}\n", name)
                                output.appendff("#undef {}\n", name)
                                output.append("#endif\n")
                            }
                        }
                    }
                    if name.has_value() {
                        output.append(" } // namespace ")
                        output.append(name!)
                        output.append("\n")
                    }
                }
            }


            // We must reserve `output` so that we can add the imported headers later.
            mut after_headers = StringBuilder::create()
            after_headers.append("namespace Jakt {\n")

            if not module.is_root {
                generator.namespace_stack.push(module.name)
            }


            let required_imports = generator.capturing_modules(module, &fn[scope](anon generator: &mut CodeGenerator, module: Module, output: &mut StringBuilder) throws {
                generator.codegen_namespace_predecl(scope, current_module: module, &mut output)
                generator.codegen_namespace_forward(scope, current_module: module, &mut output)
            }, output: &mut after_headers)


            let ordered_imports = CodeGenerator::get_topologically_sorted_modules(all_sorted_modules: &sorted_modules, dependencies: &required_imports)

            modules_in_header.set(i, required_imports)

            if not module.is_root {
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = generator.namespace_stack.pop()
            }

            for id in ordered_imports {
                guard id.id != 0 and id.id != module.id.id else {
                    continue
                }
                let module = generator.program.modules[id.id]
                output.appendff("#include \"{}.h\"\n", module.name)
            }


            output.append(after_headers.to_string())
            output.append("} // namespace Jakt\n")


            result.set(header_name, (output.to_string(), module.resolved_import_path))
        }



        for idx in sorted_modules.size()..0 {
            // Module implementation
            // NOTE: this and the next loop are pretty much identical; only the
            // inner part of `capturing modules` differs since we have to
            // output specializations instead. As such, it is probable that any
            // changes to generation in this loop could apply to the
            // specialization loop as well.
            let i = sorted_modules[idx - 1].id
            if i == 0 {
                // Skip 0 because it's the prelude
                continue
            }

            let module = generator.program.modules[i]
            generator.compiler.dbg_println(format("generate: module idx: {}, module.name {} - forward: {}", i, module.name, false))

            let header_name = format("{}.h", module.name)
            let impl_name = format("{}.cpp", module.name)

            output.clear()
            // Make sure we have `SetConsoleOutputCP` defined. Note that there
            // may be multiple `main` functions from separate modules, and currently
            // all of them are generated as if they were the entrypoint.
            output.append("#ifdef _WIN32\n")
            output.append("extern \"C\" __cdecl int SetConsoleOutputCP(unsigned int code_page);\n")
            output.append("#endif\n")

            let main_id = match module.id.id {
                1 => 1uz
                else => 0uz
            }
            let scope_id = ScopeId(module_id: module.id, id: main_id)
            let scope = generator.program.get_scope(scope_id)


            if not module.is_root {
                generator.namespace_stack.push(module.name)
            }

            mut inside_namespace = StringBuilder::create()
            mut required_imports = generator.capturing_modules(module,
                &fn[scope](anon gen: &mut CodeGenerator, module: Module, output: &mut StringBuilder) throws {
                gen.codegen_namespace(scope, current_module: module, output)
            }, output: &mut inside_namespace)

            // Do not include things that were included already by the module header.
            // Issue #1450 still applies here; this code relies on Dictionary::get being
            // idempotent.
            if modules_in_header.get(i) is Some(already_included) {
                for imported_by_header in already_included {
                    required_imports.remove(imported_by_header)
                }
            }

            let ordered_imports = CodeGenerator::get_topologically_sorted_modules(all_sorted_modules: &sorted_modules, dependencies: &required_imports)

            if not module.is_root {
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = generator.namespace_stack.pop()
            }

            if not inside_namespace.is_empty() {
                if i != 0 {
                    output.appendff("#include \"{}\"\n", header_name)
                }

                for id in ordered_imports {
                    // prelude, already imported by lib as well
                    if id.id == 0 { continue }
                    let module = generator.program.modules[id.id]
                    output.appendff("#include \"{}.h\"\n", module.name)
                }

                output.append("namespace Jakt {\n")
                output.append(inside_namespace.to_string())
                output.append("} // namespace Jakt\n")
            } else {
                // Nothing is implemented -> nothing is needed
                // NOTE: CMake's add_jakt_executable expects one
                // <module>.cpp per module, so we'll just emit
                // an empty one with no includes, to be more predictable.
                // FIXME: remove the empty file from the result once CMake
                // doesn't rely on the above.
                output.clear()
            }


            result.set(impl_name, (output.to_string(), module.resolved_import_path))
        }

        for idx in sorted_modules.size()..0 {
            let i = sorted_modules[idx - 1].id

            let module = generator.program.modules[i]

            let header_name = format("{}.h", module.name)
            let impl_name = format("{}_specializations.cpp", module.name)

            let main_id = match module.id.id {
                1 => 1uz
                else => 0uz
            }
            let scope_id = ScopeId(module_id: module.id, id: main_id)
            let scope = generator.program.get_scope(scope_id)

            // We want to know which headers we want to include before we
            // attach this to the running output.
            mut code_output = StringBuilder::create()

            if not module.is_root {
                generator.namespace_stack.push(module.name)
            }


            mut required_imports = generator.capturing_modules(module, &fn[scope](anon gen: &mut CodeGenerator, module: Module, output: &mut StringBuilder) throws {
                gen.codegen_namespace_specializations(scope, current_module: module, &mut output)
            }, output: &mut code_output)

            // Do not include things that were included already by the module header.
            // Issue #1450 still applies here; this code relies on Dictionary::get being
            // idempotent.
            if modules_in_header.get(i) is Some(already_included) {
                for imported_by_header in already_included {
                    required_imports.remove(imported_by_header)
                }
            }

            let ordered_imports = CodeGenerator::get_topologically_sorted_modules(all_sorted_modules: &sorted_modules, dependencies: &required_imports)

            if not module.is_root {
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = generator.namespace_stack.pop()
            }

            if not code_output.is_empty() {
                output = StringBuilder::create()
                if i != 0 {
                    output.appendff("#include \"{}\"\n", header_name)
                }

                for id in ordered_imports {
                    if id.id == 0 {
                        continue
                    }
                    let module = generator.program.modules[id.id]
                    output.appendff("#include \"{}.h\"\n", module.name)
                }
                output.append("namespace Jakt {\n")
                output.append(code_output.to_string())
                output.append("} // namespace Jakt\n")
            } else {
                // NOTE: CMake's add_jakt_executable expects one
                // <module>_specializations.cpp per module, so we'll just emit
                // an empty one with no includes, to be more predictable.
                // FIXME: remove the empty file from the result once CMake
                // doesn't rely on the above.
                output.clear()
            }
            result.set(impl_name, (output.to_string(), module.resolved_import_path))
        }

        let export_dir = must compiler.exports_dir.absolute()
        let binary_dir = must compiler.binary_dir.absolute()

        for (file, exported_types) in generator.program.exports {
            // Generate all the type aliases while making sure to import the correct
            // module headers.
            // I need to reserve output to find the headers
            mut used_modules: {ModuleId} = {}
            mut cpp_code = StringBuilder::create()

            // TODO: it could be nicer if the exported types were grouped
            // by the namespace they are imported in.
            for (type_id, unprefixed_name) in exported_types {
                used_modules.add(type_id.module)

                let should_be_namespaced = unprefixed_name.size() > 1
                if should_be_namespaced {
                    cpp_code.appendff("namespace {}", unprefixed_name[0].name)
                    if unprefixed_name.size() > 2 {
                        for i in 1..(unprefixed_name.size() - 1) {
                            cpp_code.append(format("::{}", unprefixed_name[i].name))
                        }
                    }
                    cpp_code.append('{')
                }

                let name = unprefixed_name.last()!.name

                let qualifier = generator.codegen_namespace_qualifier(scope_id: generator.program.find_type_scope_id(type_id), is_prelude: generator.program.get_module(type_id.module).is_prelude())
                cpp_code.appendff("using {} = {}{};", name, qualifier, name)

                if should_be_namespaced {
                    cpp_code.append('}')
                }
            }

            output.clear()
            output.append("#pragma once\n")

            let ordered_imports = get_topologically_sorted_modules(all_sorted_modules: &sorted_modules, dependencies: &used_modules)

            for id in ordered_imports {
                let module = generator.program.modules[id.id]
                let module_path = binary_dir.join(format("{}.h", module.name))
                let module_path_relative = module_path.relative_to(&export_dir)
                output.appendff("#include \"{}\"\n", module_path_relative.to_string())
            }

            output.append(cpp_code.to_string())

            exported_files.set(file, output.to_string())
        }

        return result
    }


    fn get_topologically_sorted_modules(all_sorted_modules: &[ModuleId], dependencies: &{ModuleId}) -> [ModuleId] {
        mut deps: [ModuleId] = []
        deps.ensure_capacity(dependencies.size())

        for id in all_sorted_modules {
            if dependencies.contains(id) {
                deps.push(id)
            }
        }

        return deps
    }

    // Captures required modules only from the types `gen` generates,
    // and gives back the set of modules that were used, with the
    // deferred output appended to `gen`'s output.
    fn capturing_modules(mut this, module: Module, anon gen: &fn(anon cg: &mut CodeGenerator, module: Module, output: &mut StringBuilder) throws -> void, output: &mut StringBuilder) throws -> {ModuleId} {
        .used_modules = {}
        .used_modules.ensure_capacity(module.imports.size())
        for id in module.imports {
            .used_modules.add(id)
        }
        .deferred_output.clear()
        gen(&mut this, module, &mut output)
        output.append(.deferred_output.to_string())
        .deferred_output.clear()
        return .used_modules
    }

    fn postorder_traversal(this, type_id: TypeId, mut visited: {TypeId}, dependency_graph: [TypeId: [TypeId]], mut output: [TypeId]) throws {
        if visited.contains(type_id) {
            return
        }
        visited.add(type_id)
        if dependency_graph.contains(type_id) {
            for dependency in dependency_graph.get(type_id)! {
                .postorder_traversal(type_id: dependency, visited, dependency_graph, output)
            }
        }
        output.push(type_id)
    }

    fn produce_codegen_dependency_graph(this, scope: Scope) throws -> [TypeId:[TypeId]] {
        mut dependency_graph: [TypeId:[TypeId]] = [:]

        for type_ in scope.types {
            dependency_graph.set(type_.1, .extract_dependencies_from(type_id: type_.1, dependency_graph, top_level: true))
        }

        return dependency_graph
    }

    fn extract_dependencies_from(this, type_id: TypeId, dependency_graph: [TypeId:[TypeId]], top_level: bool) -> [TypeId] {
        mut dependencies: [TypeId] = []

        let type_ = .program.get_type(type_id)
        if not type_.is_boxed(program: .program) and dependency_graph.contains(type_id) {
            for dependency in dependency_graph.get(type_id)! {
                dependencies.push(dependency)
            }
            return dependencies
        }

        let inner_dependencies = match type_ {
            Enum(enum_id) => .extract_dependencies_from_enum(enum_id, dependency_graph, top_level)
            GenericEnumInstance(id) => .extract_dependencies_from_enum(enum_id: id, dependency_graph, top_level)
            Struct(id) => .extract_dependencies_from_struct(struct_id: id, dependency_graph, top_level, args: [])
            GenericInstance(id, args) => .extract_dependencies_from_struct(struct_id: id, dependency_graph, top_level, args)
            else => []
        }

        for dependency in inner_dependencies {
            dependencies.push(dependency)
        }

        return dependencies
    }

    fn extract_dependencies_from_enum(this, enum_id: EnumId, dependency_graph: [TypeId:[TypeId]], top_level: bool) -> [TypeId] {
        mut dependencies: [TypeId] = []

        let enum_ = .program.get_enum(enum_id)
        if enum_.definition_linkage is External {
            // This type is defined somewhere else,
            // so we can skip marking it as a dependency.
            return dependencies
        }
        if enum_.is_boxed and not top_level {
            // We store and pass these as pointers, so we don't need to
            // include them in the dependency graph.
            return dependencies
        }
        dependencies.push(enum_.type_id)
        if enum_.underlying_type_id != unknown_type_id() {
            let inner_dependencies = .extract_dependencies_from(type_id: enum_.underlying_type_id, dependency_graph, top_level: false)
            for dependency in inner_dependencies {
                dependencies.push(dependency)
            }
        }
        for variant in enum_.variants {
            match variant {
                Typed(type_id) => {
                    let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
                    for dependency in inner_dependencies {
                        dependencies.push(dependency)
                    }
                }
                StructLike(fields) => {
                    for field in fields {
                        let type_id = .program.get_variable(field).type_id
                        let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
                        for dependency in inner_dependencies {
                            dependencies.push(dependency)
                        }
                    }
                }
                else => {}
            }
        }

        return dependencies
    }

    fn extract_dependencies_from_struct(
        this
        struct_id: StructId
        dependency_graph: [TypeId:[TypeId]]
        top_level: bool
        args: [TypeId]
    ) -> [TypeId] {
        mut dependencies: [TypeId] = []
        let struct_ = .program.get_struct(struct_id)

        if struct_.definition_linkage is External and struct_.name != "Optional" {
            // This type is defined somewhere else,
            // so we can skip marking it as a dependency.
            return dependencies
        }

        if struct_.record_type is Class and not top_level {
            // We store and pass these as pointers, so we don't need to
            // include them in the dependency graph.
            return dependencies
        }

        if not args.is_empty() {
            for inner_type in args {
                let inner_dependencies = match .program.get_type(inner_type) {
                    Enum | Struct => .extract_dependencies_from(type_id: inner_type, dependency_graph, top_level: false)
                    else => []
                }

                for dependency in inner_dependencies {
                    dependencies.push(dependency)
                }
            }
        }

        mut super_struct_id = struct_.super_struct_id
        while super_struct_id.has_value() {
            let super_struct = .program.get_struct(super_struct_id!)
            let super_dependencies = .extract_dependencies_from_struct(struct_id: super_struct_id!, dependency_graph, top_level: true, args: [])
            dependencies.push_values(&super_dependencies)
            super_struct_id = super_struct.super_struct_id
        }

        dependencies.push(struct_.type_id)
        // The struct's fields are also dependencies.
        for field in struct_.fields {
            let type_id = .program.get_variable(field.variable_id).type_id
            let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
            for dependency in inner_dependencies {
                dependencies.push(dependency)
            }
        }
        return dependencies
    }

    fn is_full_respecialization(this, anon type_args: [TypeId]) -> bool {
        for type_id in type_args {
            if .program.get_type(type_id) is TypeVariable {
                return false
            }
        }
        return true
    }

    fn codegen_namespace_specialization(
        mut this
        function_id: FunctionId
        containing_struct: TypeId?
        scope: Scope
        current_module: Module
        define_pass: bool = false
        output: &mut StringBuilder
    ) throws {
        let function = .program.get_function(function_id)
        if not function.function_scope_id.module_id.equals(current_module.id) {
            return
        }

        if function.is_comptime {
            return
        }

        let previous_function = .current_function
        .current_function = function
        defer .current_function = previous_function

        if function.linkage is External or
            function.type is ImplicitConstructor or
            function.type is ImplicitEnumConstructor or
            function.type is Destructor {

            return
        }

        if function.generics.params.is_empty() or not function.specialization_index.has_value() {
            return
        }

        if containing_struct.has_value() and not match .program.get_type(containing_struct!) {
            Struct(struct_id) => .program.get_struct(struct_id).generic_parameters.is_empty()
            Enum(struct_id) => .program.get_enum(struct_id).generic_parameters.is_empty()
            else => false
        } {
            return
        }

        // Generate a specialied template, and then do an explicit instantiation of it.
        // This is necessary because we don't want to put the specialization in the header file.

        let is_full_respecialization = .is_full_respecialization(
            function.generics.specializations[function.specialization_index!]
        )

        if define_pass and is_full_respecialization {
            output.append("template<")
            mut first = true
            for arg in function.generics.specializations[function.specialization_index!] {
                if .program.get_type(arg) is TypeVariable(name) {
                    if first {
                        first = false
                    } else {
                        output.append(", ")
                    }
                    output.appendff("typename {}", name)
                }
            }

            output.append(">\n")

            .codegen_function_in_namespace(
                function
                containing_struct
                skip_template: true
                explicit_generic_instantiation: function.generics.specializations[function.specialization_index!]
                &mut output
            )
        } else if is_full_respecialization {
            mut args: [String] = []
            for arg in function.generics.specializations[function.specialization_index!] {
                args.push(.codegen_type(arg))
            }

            output.appendff(
                "\n/* specialisation {} of function {}: {} */"
                function.specialization_index!
                function.name
                args
            )
            output.append("\ntemplate<> ")
            if function.return_type_id == never_type_id() {
                output.append("[[noreturn]] ")
            }

            output.append(match function.can_throw {
                true => format("ErrorOr<{}>", .codegen_type(function.return_type_id))
                false => .codegen_type(function.return_type_id)
            })

            output.append(" ")

            let qualifier = match containing_struct.has_value() {
                true => .codegen_type_possibly_as_namespace(type_id: containing_struct!, as_namespace: true)
                false => ""
            }
            if not qualifier.is_empty() {
                output.append(qualifier)
                output.append("::")
            }
            output.append(function.name_for_codegen().as_name_for_definition())

            output.append("<")
            mut first = true
            for type_id in function.generics.specializations[function.specialization_index!] {
                if first {
                    first = false
                } else {
                    output.append(", ")
                }
                output.append(.codegen_type(type_id))
            }

            output.append(">(")

            first = true
            for param in function.params {
                let variable = param.variable
                if variable.name == "this" {
                    continue
                }
                if not first {
                    output.append(",")
                } else {
                    first = false
                }
                let variable_type = .program.get_type(variable.type_id)
                output.append(.codegen_type(variable.type_id))
                output.append(" ")
                if not variable.is_mutable and not (variable_type is Reference or variable_type is MutableReference) {
                    output.append("const ")
                }
                output.append(variable.name_for_codegen().as_name_for_definition())
            }

            output.append(")")
            if not function.is_static() and not function.is_mutating() {
                output.append(" const")
            }
            output.append(";\n")
        } else {
            output.appendff("\n/* specialisation {} of function {} omitted, not fully specialized: {} */\n"
                function.specialization_index!
                function.name
                function.generics.specializations[function.specialization_index!]
            )
        }
    }

    fn codegen_namespace_specializations(
        mut this
        scope: Scope
        current_module: Module
        output: &mut StringBuilder
    ) throws {
        if scope.alias_path.has_value() or scope.import_path_if_extern.has_value() {
            return
        }
        mut seen_types: {TypeId} = {}

        for define_pass in [false, true] {
            for (_, overload_set) in scope.functions {
                for function_id in overload_set {
                    .codegen_namespace_specialization(function_id, containing_struct: None, scope, current_module, define_pass, &mut output)
                }
            }

            for (_, struct_id) in scope.structs {
                if not struct_id.module.equals(current_module.id) {
                    continue
                }
                let struct_ = .program.get_struct(struct_id)
                if seen_types.contains(struct_.type_id) {
                    continue
                }

                let scope = .program.get_scope(struct_.scope_id)
                for (_, overload_set) in scope.functions {
                    for function_id in overload_set {
                        .codegen_namespace_specialization(
                            function_id
                            containing_struct: struct_.type_id
                            scope
                            current_module
                            define_pass
                            &mut output
                        )
                    }
                }
            }

            for (_, enum_id) in scope.enums {
                if not enum_id.module.equals(current_module.id) {
                    continue
                }
                let enum_ = .program.get_enum(enum_id)
                if seen_types.contains(enum_.type_id) {
                    continue
                }

                let scope = .program.get_scope(enum_.scope_id)
                for (_, overload_set) in scope.functions {
                    for function_id in overload_set {
                        .codegen_namespace_specialization(
                            function_id
                            containing_struct: enum_.type_id
                            scope
                            current_module
                            define_pass
                            &mut output
                        )
                    }
                }
            }
        }

        for child_scope_id in scope.children {
            let child_scope = .program.get_scope(child_scope_id)
            let name = child_scope.namespace_name_for_codegen()?.as_name_for_definition()
            if name.has_value() {
                .namespace_stack.push(name!)
                .codegen_namespace_specializations(scope: child_scope, current_module, &mut output)
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = .namespace_stack.pop()
            }
        }

        let name = scope.namespace_name_for_codegen()?.as_name_for_definition()
        if name.has_value() and not output.is_empty() {
            let inside_namespace = output.to_string()
            output.clear()
            output.appendff("namespace {} {{\n", name!)
            output.append(inside_namespace)
            output.append("}\n")
        }
    }

    fn codegen_namespace_forward(
        mut this
        scope: Scope
        current_module: Module
        output: &mut StringBuilder
    ) throws {
        if scope.alias_path.has_value() or scope.import_path_if_extern.has_value() {
            return
        }

        mut inside_namespace = StringBuilder::create()

        mut seen_types: {TypeId} = {}

        let dependency_graph = .produce_codegen_dependency_graph(scope)
        for entry in dependency_graph {
            let traversal: [TypeId] = []
            .postorder_traversal(
                type_id: entry.0
                visited: seen_types
                dependency_graph
                output: traversal
            )
            for type_id in traversal {
                let type_ = .program.get_type(type_id)
                match type_ {
                    Enum(enum_id) => {
                        if not enum_id.module.equals(current_module.id) {
                            // Skip over imports from other modules
                            continue
                        }
                        let enum_ = .program.get_enum(enum_id)
                        .codegen_enum(enum_, output: &mut inside_namespace)
                    }
                    Struct(struct_id) => {
                        if not struct_id.module.equals(current_module.id) {
                            // Skip over imports from other modules
                            continue
                        }
                        .codegen_struct(struct_: .program.get_struct(struct_id), output: &mut inside_namespace)
                    }
                    Trait => { }
                    else => {
                        panic(format("Unexpected type in dependency graph: {}", type_))
                    }
                }
                seen_types.add(type_id)
            }
        }

        for (_, struct_id) in scope.structs {
            if not struct_id.module.equals(current_module.id) {
                continue
            }
            let struct_ = .program.get_struct(struct_id)
            if seen_types.contains(struct_.type_id) {
                continue
            }
            .codegen_struct(struct_, output: &mut inside_namespace)
            output.append("\n")
        }

        for (_, enum_id) in scope.enums {
            if not enum_id.module.equals(current_module.id) {
                continue
            }
            let enum_ = .program.get_enum(enum_id)
            if seen_types.contains(enum_.type_id) {
                continue
            }
            .codegen_enum(enum_, output: &mut inside_namespace)
            output.append("\n")
        }

        for (_, overload_set) in scope.functions {
            for function_id in overload_set {
                let function = .program.get_function(function_id)
                if not function.function_scope_id.module_id.equals(current_module.id) {
                    continue
                }

                if function.is_comptime {
                    continue
                }

                let previous_function = .current_function
                .current_function = function
                defer .current_function = previous_function

                if function.linkage is External or
                    function.type is ImplicitConstructor or
                    function.type is ImplicitEnumConstructor or
                    function.type is Destructor {

                    continue
                }

                if function.generics.params.is_empty() {
                    continue
                }

                if not function.specialization_index.has_value() {
                    .codegen_function_predecl(function, allow_generics: true, output: &mut inside_namespace)
                }
            }
        }

        for child_scope_id in scope.children {
            let child_scope = .program.get_scope(child_scope_id)
            let name = child_scope.namespace_name_for_codegen()?.as_name_for_definition()
            if name.has_value() {
                .namespace_stack.push(name!)
                .codegen_namespace_forward(scope: child_scope, current_module, output: &mut inside_namespace)
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = .namespace_stack.pop()
            }
        }

        if inside_namespace.length() != 0 {
            let name = scope.namespace_name_for_codegen()?.as_name_for_definition()
            if name.has_value() {
                output.append("namespace " + name! + " {\n")
            }
            output.append(inside_namespace.to_string())
            if name.has_value() {
                output.append("}\n")
            }
        }
    }

    fn codegen_namespace(
        mut this
        scope: Scope
        current_module: Module
        output: &mut StringBuilder
    ) throws {
        if scope.alias_path.has_value() or scope.import_path_if_extern.has_value() {
            return
        }

        mut inside_namespace = StringBuilder::create()

        for (_, overload_set) in scope.functions {
            for function_id in overload_set {
                let function = .program.get_function(function_id)
                if not function.function_scope_id.module_id.equals(current_module.id) {
                    continue
                }

                if function.is_comptime {
                    continue
                }

                let previous_function = .current_function
                .current_function = function
                defer .current_function = previous_function

                if function.linkage is External or
                    function.type is ImplicitConstructor or
                    function.type is ImplicitEnumConstructor or
                    function.type is Destructor {

                    continue
                }

                if function.generics.params.is_empty() {
                    .codegen_function(function, output: &mut inside_namespace)
                    inside_namespace.append("\n")
                }
            }
        }

        for (_, struct_id) in scope.structs {
            if not struct_id.module.equals(current_module.id) {
                continue
            }
            let struct_ = .program.get_struct(struct_id)

            if struct_.definition_linkage is External {
                continue
            }

            if not struct_.generic_parameters.is_empty() {
                continue
            }

            .codegen_debug_description_getter(struct_, output: &mut inside_namespace)

            let scope = .program.get_scope(struct_.scope_id)
            for (_, overload_set) in scope.functions {
                for function_id in overload_set {
                    let function = .program.get_function(function_id)
                    if function.force_inline is MakeDefinitionAvailable {
                        continue
                    }

                    let previous_function = .current_function
                    .current_function = function
                    defer .current_function = previous_function

                    if function.type is ImplicitConstructor {
                        .codegen_constructor(function, output: &mut inside_namespace)
                        inside_namespace.append("\n")
                    } else if function.type is Destructor {
                        .codegen_destructor(&struct_, &function, is_inline: false, output: &mut inside_namespace)
                        inside_namespace.append("\n")
                    } else if not function.type is ImplicitEnumConstructor and
                        not function.is_comptime and
                        function.generics.params.is_empty() {

                        .codegen_function_in_namespace(function, containing_struct: struct_.type_id, output: &mut inside_namespace)
                        inside_namespace.append("\n")
                    }
                }
            }
        }

        for (_, enum_id) in scope.enums {
            if not enum_id.module.equals(current_module.id) {
                continue
            }
            let enum_ = .program.get_enum(enum_id)

            if enum_.definition_linkage is External {
                continue
            }

            if not enum_.generic_parameters.is_empty() {
                continue
            }

            if enum_.underlying_type_id == void_type_id() {
                .codegen_enum_debug_description_getter(enum_, output: &mut inside_namespace)
                let (common_fields, variant_field_list) = .codegen_enum_field_lists(enum_)
                .codegen_enum_constructors(
                    enum_
                    is_inside_struct: false
                    generic_parameter_list: None
                    variant_field_list
                    common_fields
                    output: &mut inside_namespace
                )

                inside_namespace.appendff("{0}::~{0}()", enum_.name)

                .codegen_enum_destructor_body(enum_, output: &mut inside_namespace)

                inside_namespace.appendff("void {0}::__jakt_destroy_variant() {{\n", enum_.name)
                .codegen_enum_destroy_variant(enum_, output: &mut inside_namespace)
                inside_namespace.append("}\n")
            }

            let scope = .program.get_scope(enum_.scope_id)
            for (_, overload_set) in scope.functions {
                for function_id in overload_set {
                    let function = .program.get_function(function_id)
                    let previous_function = .current_function
                    .current_function = function
                    defer .current_function = previous_function

                    if not function.type is ImplicitConstructor and
                        not function.type is ImplicitEnumConstructor and
                        not function.type is Destructor and
                        not function.is_comptime and
                        function.generics.params.is_empty() {

                        .codegen_function_in_namespace(function, containing_struct: enum_.type_id, output: &mut inside_namespace)
                        inside_namespace.append("\n")
                    }
                }
            }
        }

        for child_scope_id in scope.children {
            let child_scope = .program.get_scope(child_scope_id)
            let name = child_scope.namespace_name_for_codegen()?.as_name_for_definition()
            if name.has_value() {
                .namespace_stack.push(name!)
                .codegen_namespace(scope: child_scope, current_module, output: &mut inside_namespace)
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = .namespace_stack.pop()
            }
        }

        if not inside_namespace.is_empty() {
            let name = scope.namespace_name_for_codegen()?.as_name_for_definition()
            if name.has_value() {
                output.appendff("namespace {} {{\n", name!)
                output.append(inside_namespace.to_string())
                output.append("}\n")
            } else {
                output.append(inside_namespace.to_string())
            }
        }
    }

    fn codegen_namespace_predecl(
        mut this
        scope: Scope
        current_module: Module
        output: &mut StringBuilder
    ) throws {
        if scope.alias_path.has_value() or scope.import_path_if_extern.has_value() {
            return
        }
        let name = scope.namespace_name_for_codegen()?.as_name_for_definition()
        if name.has_value() {
            output.append("namespace ")
            output.append(name!)
            output.append(" {\n")
        }
        for (_, struct_id) in scope.structs {
            if not struct_id.module.equals(current_module.id) {
                continue
            }
            let struct_ = .program.get_struct(struct_id)
            .codegen_struct_predecl(struct_, &mut output)
            output.append("\n")
        }

        for (_, enum_id) in scope.enums {
            if not enum_id.module.equals(current_module.id) {
                continue
            }
            let enum_ = .program.get_enum(enum_id)
            .codegen_enum_predecl(enum_, &mut output)
            output.append("\n")
        }

        for child in scope.children {
            .codegen_namespace_predecl(scope: .program.get_scope(child), current_module, &mut output)
        }

        for (_, overload_set) in scope.functions {
            for function_id in overload_set {
                if not function_id.module.equals(current_module.id) {
                    continue
                }
                let function = .program.get_function(function_id)
                if function.type is ImplicitEnumConstructor {
                    continue
                }

                let previous_function_id = .current_function
                .current_function = Some(function)
                defer .current_function = previous_function_id

                if not function.type is ImplicitConstructor and
                    not function.type is Destructor and
                    function.name_for_codegen().as_name_for_use() != "main" and
                    function.generics.params.is_empty() {

                    .codegen_function_predecl(function, &mut output)
                    output.append("\n")
                }
            }
        }

        if name.has_value() {
            output.append("}\n")
        }
    }

    fn codegen_template_parameter_names(
        mut this
        anon parameters: [FunctionGenericParameter]
        names: &mut [String]
        output: &mut StringBuilder
    ) throws {
        mut ids: [TypeId] = []
        for parameter in parameters {
            ids.push(parameter.checked_parameter.type_id)
        }
        .codegen_template_parameter_names(ids, names, output)
    }

    fn codegen_template_parameter_names(
        mut this
        anon parameters: [FunctionGenericParameter]
        output: &mut StringBuilder
    ) throws {
        mut names: [String] = []
        return .codegen_template_parameter_names(parameters, &mut names, &mut output)
    }

    fn codegen_template_parameter_names(
        mut this
        anon parameters: [CheckedGenericParameter]
        names: &mut [String]
        output: &mut StringBuilder
    ) throws {
        mut ids: [TypeId] = []
        for parameter in parameters {
            ids.push(parameter.type_id)
        }
        return .codegen_template_parameter_names(ids, names, &mut output)
    }

    fn codegen_template_parameter_names(
        mut this
        anon parameters: [CheckedGenericParameter]
        output: &mut StringBuilder
    ) throws {
        mut names: [String] = []
        return .codegen_template_parameter_names(parameters, &mut names, &mut output)
    }

    fn codegen_template_parameter_names(
        mut this
        anon parameters: [TypeId]
        names: &mut [String]
        output: &mut StringBuilder
    ) throws {
        mut first = true
        for id in parameters {
            if first {
                first = false
            } else {
                output.append(",")
            }
            if .program.get_type(id) is TypeVariable(is_value) and is_value {
                output.append("auto ")
            } else {
                output.append("typename ")
            }
            let name = .codegen_type(id)

            output.append(name)
            names.push(name)
        }
    }

    fn codegen_function_generic_parameters(
        mut this
        function: CheckedFunction
        output: &mut StringBuilder
    ) throws {
        if not function.generics.params.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(function.generics.params, &mut output)
            output .append(">\n")
        }
    }

    fn codegen_function_predecl(
        mut this
        function: CheckedFunction
        as_method: bool = false
        allow_generics: bool = false
        output: &mut StringBuilder
    ) throws {
        if (allow_generics or not function.generics.params.is_empty()) and function.linkage is External {
            return
        }

        if function.is_comptime {
            return
        }

        if function.force_inline is ForceInline {
            return
        }

        // FIXME: for now, just exit early if we're a constructor
        if function.type is ImplicitConstructor {
            return
        }

        if function.linkage is External and not as_method {
            output.append("extern ")
        }

        .codegen_function_generic_parameters(function, &mut output)

        if function.return_type_id == never_type_id() {
            output.append("[[noreturn]] ")
        }

        if function.name_for_codegen().as_name_for_definition() == "main" {
            output.append("ErrorOr<int>")
        } else {
            if as_method and function.is_static() {
                output.append("static ")
            }

            if function.is_virtual {
                output.append("virtual ")
            }

            if not function.type is Destructor and not function.type is Constructor {
                let naked_return_type = .codegen_type(function.return_type_id)
                let return_type = match function.can_throw {
                    true => format("ErrorOr<{}>", naked_return_type)
                    false => naked_return_type
                }
                output.append(return_type)
            }
        }

        output.append(" ")
        output.append(function.name_for_codegen().as_name_for_definition())
        output.append("(")

        mut first = true
        for param in function.params {
            if first and param.variable.name == "this" {
                continue
            }

            if first {
                first = false
            } else {
                output.append(", ")
            }

            let param_type = .program.get_type(param.variable.type_id)
            output.append(.codegen_type(param.variable.type_id))
            output.append(" ")
            if not param.variable.is_mutable and not (param_type is Reference or param_type is MutableReference) {
                output.append("const ")
            }
            output.append(param.variable.name_for_codegen().as_name_for_definition())
        }
        output.append(")")

        if not function.is_static() and not function.is_mutating() {
            output.append(" const")
        }
        if function.is_override {
            output.append(" override")
        }

        output.append(";\n")
    }

    fn codegen_struct_predecl(
        mut this
        struct_: CheckedStruct
        output: &mut StringBuilder
    ) throws {
        if struct_.definition_linkage is External {
            return
        }
        if not struct_.generic_parameters.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(struct_.generic_parameters, &mut output)
            output.append(">")
        }

        output.append(match struct_.record_type {
            Class => "class "
            Struct => "struct "
            else => ""
        })

        output.append(struct_.name_for_codegen().as_name_for_definition())
        output.append(";")
    }

    fn codegen_struct(
        mut this
        struct_: CheckedStruct
        output: &mut StringBuilder
    ) throws {
        if struct_.definition_linkage is External {
            return
        }

        mut struct_is_generic = false
        mut generic_parameter_names: [String] = []
        mut template_parameters_builder = StringBuilder::create()
        mut template_parameters = ""
        if not struct_.generic_parameters.is_empty() {
            struct_is_generic = true
            .codegen_template_parameter_names(
                struct_.generic_parameters
                names: &mut generic_parameter_names
                output: &mut template_parameters_builder
            )
            template_parameters = template_parameters_builder.to_string()
            output.appendff("template <{}>", template_parameters)
        }

        match struct_.record_type {
            Class => {
                mut class_name_with_generics = ""
                class_name_with_generics += struct_.name_for_codegen().as_name_for_definition()
                mut first = true
                for generic_parameter in struct_.generic_parameters {
                    if not first {
                        class_name_with_generics += ", "
                    } else {
                        class_name_with_generics += "<"
                        first = false
                    }
                    class_name_with_generics += .codegen_type(generic_parameter.type_id)
                }
                if not struct_.generic_parameters.is_empty() {
                    class_name_with_generics += ">"
                }

                output.appendff("class {} :", struct_.name_for_codegen().as_name_for_definition())
                if struct_.super_struct_id.has_value() {
                    output.appendff("public {}", .codegen_struct_type(id: struct_.super_struct_id!, as_namespace: true))
                    if not (.program.get_struct(struct_.super_struct_id!).record_type is Class) {
                        output.appendff(
                            ", public RefCounted<{}>, public Weakable<{}>"
                            class_name_with_generics
                            class_name_with_generics
                        )
                    }
                } else {
                    output.appendff(
                        "public RefCounted<{}>, public Weakable<{}> "
                        class_name_with_generics
                        class_name_with_generics
                    )
                }

                output.append("{\n")

                let scope = .program.get_scope(struct_.scope_id)
                mut has_destructor = false
                for (_, function_ids) in scope.functions {
                    for function_id in function_ids {
                        let function = .program.get_function(function_id)
                        if function.type is Destructor {
                            has_destructor = true
                        }
                    }
                }
                if not has_destructor {
                    output.append("  public:\n")
                    output.appendff("virtual ~{}() = default;\n", struct_.name_for_codegen().as_name_for_definition())
                }
            }
            Struct => {
                output.appendff("struct {}", struct_.name_for_codegen().as_name_for_definition())
                if struct_.super_struct_id.has_value() {
                    output.appendff(": public {}", .codegen_struct_type(id: struct_.super_struct_id!, as_namespace: true))
                }
                output.append(" {\n")
                output.append("  public:\n")
            }
            SumEnum => {
                todo("codegen_struct SumEnum")
            }
            ValueEnum => {
                todo("codegen_struct ValueEnum")
            }
            else => {}
        }

        let set_access_level = fn[&mut output](anon visibility: CheckedVisibility) throws -> void => match visibility {
            Restricted | Public => {
                output.append("public: ")
            }
            Private => {
                output.append("private: ")
            }
        }

        for field in struct_.fields {
            let variable = .program.get_variable(field.variable_id)
            set_access_level(variable.visibility)
            output.append(.codegen_type(variable.type_id))
            output.append(" ")
            output.append(variable.name_for_codegen().as_name_for_definition())
            output.append(";")
        }

        let scope = .program.get_scope(struct_.scope_id)
        for (_, overload_set) in scope.functions {
            for function_id in overload_set {
                let previous_function_id = .current_function

                let function = .program.get_function(function_id)
                set_access_level(function.visibility)
                .current_function = Some(function)
                defer .current_function = previous_function_id

                if function.type is Destructor {
                    if struct_.generic_parameters.is_empty() {
                        output.append(.codegen_destructor_predecl(&struct_))
                    } else {
                        .codegen_destructor(&struct_, &function, is_inline: true, &mut output)
                    }
                    output.append("\n")
                } else if function.type is ImplicitConstructor {
                    if struct_.generic_parameters.is_empty() {
                        .codegen_constructor_predecl(function, &mut output)
                    } else {
                        .codegen_constructor(function, is_inline: true, &mut output)
                    }
                    output.append("\n")
                } else if function.force_inline is MakeDefinitionAvailable {
                    .codegen_function(function, as_method: true, &mut output)
                } else if struct_is_generic {
                    if not function.specialization_index.has_value() {
                        .codegen_function(function, as_method: true, &mut output)
                    }
                } else if function.generics.params.is_empty() or not function.specialization_index.has_value() {
                    .codegen_function_predecl(function, as_method: true, &mut output)
                }
            }
        }

        set_access_level(CheckedVisibility::Public)
        if struct_.generic_parameters.is_empty() {
            output.append("ByteString debug_description() const;\n")
        } else {
            .codegen_debug_description_getter(struct_, is_inline: true, &mut output)
        }

        output.append("};")

        .codegen_ak_formatter(
            name: struct_.name_for_codegen().as_name_for_definition()
            generic_parameter_names
            template_parameters
            output: &mut .deferred_output
        )
    }

    fn codegen_enum_predecl(
        mut this
        enum_: CheckedEnum
        output: &mut StringBuilder
    ) throws {
        if enum_.underlying_type_id != void_type_id() {
            if .program.is_integer(enum_.underlying_type_id) {
                output.appendff("enum class {}: {};", enum_.name, .codegen_type(enum_.underlying_type_id))
                return
            } else {
                todo("Enums with a non-integer underlying type")
            }
        }

        let is_generic = not enum_.generic_parameters.is_empty()

        if is_generic {
            output.append("template<")
            .codegen_template_parameter_names(enum_.generic_parameters, &mut output)
            output.append(">\n")
        }
        output.appendff("struct {};\n", enum_.name)
    }

    fn codegen_enum(mut this, enum_: CheckedEnum, output: &mut StringBuilder) throws {
        if enum_.underlying_type_id != void_type_id() {
            if .program.is_integer(enum_.underlying_type_id) {
                output.appendff("enum class {} : {} {{\n", enum_.name, .codegen_type(enum_.underlying_type_id))
                for variant in enum_.variants {
                    guard variant is WithValue(name, expr) else {
                        todo(format("codegen_enum can't generate variant: {}", variant))
                    }
                    output.append(name)
                    output.append(" = ")
                    .codegen_expression(expr, &mut output)
                    output.append(",\n")
                }
                output.append("};\n")
                return
            } else {
                todo("Enums with a non-integer underlying type")
            }
        }

        let is_generic = not enum_.generic_parameters.is_empty()
        mut generic_parameter_names: [String] = []
        mut template_args_builder = StringBuilder::create()
        .codegen_template_parameter_names(enum_.generic_parameters, names: &mut generic_parameter_names, output: &mut template_args_builder)
        let template_args = template_args_builder.to_string()

        let generic_parameter_list = join(generic_parameter_names, separator: ", ")

        if is_generic {
            output.append("template<")
            output.append(template_args)
            output.append(">\n")
        }
        output.appendff("struct {}", enum_.name)
        if enum_.is_boxed {
            output.appendff(": public RefCounted<{}", enum_.name)
            if is_generic {
                output.appendff("<{}>", join(generic_parameter_names, separator: ", "))
        }
            output.append(">")
        }
        output.append(" {\n")

        // Choose the index type so that it can hold `variants.size()`. The
        // indices go from [0, variants.size() - 1], but for the move
        // constructor we need `__jakt_variant_index`es to be different if one
        // of them is uninitialized.
        // The uninit value is zero.
        // Although there is no practical need for this extra "index" (the same
        // codegen has to provide safe constructors), it is useful for further
        // development on this portion of the codegen, since it enables
        // assertions to verify that the compiler is indeed providing
        // initialized values.
        let max_index_value = enum_.variants.size()

        let index_type = match max_index_value {
            // 0..(1 << 8)
            0uz..256uz => "u8"
            // (1 << 8)..(1 << 16)
            256uz..65536uz => "u16"
            // (1 << 16)..(1 << 32)
            65536uz..4294967296uz => "u32"
            else => "size_t"
        }

        let (common_fields, variant_field_list) = .codegen_enum_field_lists(enum_)

        // Note that all fields are public; this is a struct that is defined by
        // the codegen and is to only be used by Jakt code, which this codegen
        // is the only one in charge of. Using the member directly removes any
        // need to create functions to get the appropiate values.
        // We'll use a getter for the variant index, so that the outputted C++ doesn't
        // have implicit "off-by-one" calculations.

        output.appendff("{} __jakt_variant_index = 0;\n", index_type, max_index_value)

        if not common_fields.is_empty() {
            // Another maybe-uninitialized data member for the common fields.
            // NOTE: Could have a record of which fields won't have a default constructor
            // so this doesn't output a complex union if all the fields have default constructors.
            output.append("union CommonData {\n")

            // This one has to be the first since C++ will use the first field to zero-init
            // a union. This way we guarantee that the union can be default initialized.
            output.append("u8 __jakt_uninit_common;\n")

            output.append("struct {\n")

            // Make common fields available
            for (field_name, type) in common_fields {
                output.appendff("{} {};\n", type, field_name)
            }

            output.append("} init_common;\n")

            // See comment below about the constructors of `VariantData`.
            // Make sure everything's at zero value.
            output.append("constexpr CommonData() {}\n")
            output.append("~CommonData() {}\n")

            output.append("} common;\n")
        }


        output.append("union VariantData {\n")

        // We need to have some way to initialize the union if any of the other fields is non default constructible.
        output.append("u8 __jakt_uninit_value;\n")

        for variant_index in 0..enum_.variants.size() {
            let variant = enum_.variants[variant_index]
            let fields: [(String, String)] = variant_field_list[variant_index].1

            if not fields.is_empty() {
                output.append("struct {\n")
                for (field_name, field_type) in fields.iterator() {
                    output.appendff("{} {};\n", field_type, field_name)
                }
                output.appendff("}} {};\n", variant.name())
            }
        }

        output.append("constexpr VariantData() {}\n")
        // make the union's destructor do nothing so C++ can shut up about the union
        // not having a default destructor. The safe destructor is the outer
        // struct's destructor, which has access to the variant index.
        output.append("~VariantData() {}\n")

        output.append("} as;\n")
        output.appendff("constexpr {} __jakt_init_index() const noexcept {{ return __jakt_variant_index - 1; }}", index_type)


        if enum_.generic_parameters.is_empty() {
            output.append("ByteString debug_description() const;\n")
        } else {
            .codegen_enum_debug_description_getter(enum_, is_inline: true, &mut output)
        }



        if is_generic {
            // produce constructors that initialize the correct parts of the union

            .codegen_enum_constructors(
                enum_
                is_inside_struct: true
                generic_parameter_list
                variant_field_list
                common_fields
                &mut output
            )

            output.appendff("~{}()", enum_.name)

            .codegen_enum_destructor_body(enum_, &mut output)

            output.append("private: void __jakt_destroy_variant() {\n")
            .codegen_enum_destroy_variant(enum_, &mut output)
            output.append("}\n")
            output.append("public:\n")

        } else {

            // Just make forward declarations for the constructor.
            for (variant_name, variant_fields) in variant_field_list {
                codegen_enum_constructor_decl(
                    enum_name: enum_.name
                    variant_name
                    variant_fields
                    common_fields
                    is_inline: true
                    ctor_result_type: enum_constructor_result_type(enum_)
                    &mut output
                )
                output.append(";\n")
            }


            // Forward declare destructor, move assignment and copy assignment
            // operators/constructors.
            output.appendff("~{}();\n", enum_.name)
            output.appendff("{0}& operator=({0} const &);\n", enum_.name)
            output.appendff("{0}& operator=({0} &&);\n", enum_.name)
            output.appendff("{0}({0} const&);\n", enum_.name)
            output.appendff("{0}({0} &&);\n", enum_.name)
            output.append("private: void __jakt_destroy_variant();\n")
            output.append("public:\n")
        }


        let enum_scope = .program.get_scope(enum_.scope_id)
        for (_, overload_set) in enum_scope.functions {
            for function_id in overload_set {
                let function = .program.get_function(function_id)

                let previous_function_id = .current_function
                .current_function = Some(function)
                defer .current_function = previous_function_id

                guard not function.type is ImplicitEnumConstructor else {
                    continue
                }

                if not enum_.generic_parameters.is_empty() {
                    .codegen_function(function, as_method: true, &mut output)
                } else if function.generics.params.is_empty() or not function.specialization_index.has_value() {
                    .codegen_function_predecl(function, as_method: true, &mut output)
                }
            }
        }

        // The only private thing is the default constructor, which is
        // overriden to allow the `static` functions to start with an undefined
        // value and write to it.
        output.appendff("private:\n{}() {{}};\n", enum_.name)

        output.append("};\n")

        .codegen_ak_formatter(name: enum_.name, generic_parameter_names, template_args, output: &mut .deferred_output)
    }

    fn codegen_enum_constructor_decl(
        enum_name: String
        variant_name: String
        variant_fields: [(String, String)] // field_name, .codegen_type(field_type)
        common_fields: [(String, String)] // field_name, .codegen_type(field_type)
        is_inline: bool // whether it's an inline definition (inside of the `struct`) or out-of-line one.
        ctor_result_type: String
        output: &mut StringBuilder
    ) {
        output.append("[[nodiscard]] ")
        if is_inline {
            output.appendff("static {} {}(", ctor_result_type, variant_name)
        } else {
            output.appendff("{} {}::{}(", ctor_result_type, enum_name, variant_name)
        }

        let has_common_fields = not common_fields.is_empty()

        // arguments
        if has_common_fields {
            let (first_name, first_type) = common_fields[0]
            output.appendff("{} {}", first_type, first_name)

            for i in 1..common_fields.size() {
                let (name, type) = common_fields[i]
                output.appendff(", {} {}", type, name)
            }

            for (name, type) in variant_fields {
                output.appendff(", {} {}", type, name)
            }
        } else if not variant_fields.is_empty() {
            let (first_name, first_type) = variant_fields[0]
            output.appendff("{} {}", first_type, first_name)

            for i in 1..variant_fields.size() {
                let (name, type) = variant_fields[i]
                output.appendff(", {} {}", type, name)
            }
        }

        output.append(")")
    }

    fn codegen_for_enum_variants(this, anon enum_: &CheckedEnum, anon stmt_fmt: &fn(anon accessor: String) -> String, index_expr: String, builder: &mut StringBuilder) {
        // Adding to output here in a loop was causing a 30% slowdown, so using
        // a StringBuilder to mitigate it.
        builder.appendff("switch ({}) {{\n", index_expr)

        let common_field_count = enum_.fields.size()

        for variant_index in 0..enum_.variants.size() {
            let variant = &enum_.variants[variant_index]
            let variant_name = variant.name()
            builder.appendff("case {} /* {} */:\n", variant_index, variant_name)

            match variant {
                Untyped | WithValue => {}
                Typed => {
                    builder.append(stmt_fmt(format("as.{}.value", variant_name)))
                }
                StructLike(fields) => {
                    for field in fields[common_field_count..] {
                        let variable = .program.get_variable(field)
                        let name = variable.name_for_codegen().as_name_for_use()

                        builder.append(stmt_fmt(format("as.{}.{}", variant_name, name)))
                    }
                }
            }

            builder.append("break;\n")
        }

        builder.append("}\n")
    }

    /// Generates the body for a copy/ move assignment operator/constructor.
    ///
    /// Assumes that the argument is named "rhs".
    fn codegen_enum_assignment_body(
        this
        enum_: CheckedEnum
        is_constructor: bool // whether it's a constructor. If false, it's an assignment operator.
        use_move: bool // whether to use the `move()` function from AK lib.
    ) -> String {
        mut builder = StringBuilder::create()
        builder.append("{")

        if is_constructor {
            // The assigned value must be initialized.
            // The constructed value is assumed to be uninitialized.
            builder.append("VERIFY(rhs.__jakt_variant_index != 0);\n")
        } else {
            // Both values are assumed to be initialized
            builder.append("VERIFY(this->__jakt_variant_index != 0 && rhs.__jakt_variant_index != 0);\n")
        }

        let assign = fn[use_move](accessor: String) -> String {
            let rhs = match use_move {
                true => format("move(rhs.{})", accessor)
                false => format("rhs.{}", accessor)
            }
            return format("this->{} = {};\n", accessor, rhs)
        }

        let placement_new = fn[use_move](anon accessor: String) -> String {
            let rhs = match use_move {
                true => format("move(rhs.{})", accessor)
                false => format("rhs.{}", accessor)
            }
            return format("new (&this->{0}) (decltype(this->{0}))({1});\n",
                accessor, rhs)
        }

        if is_constructor {
            for common in enum_.fields {
                let variable = .program.get_variable(common.variable_id)
                let name = variable.name_for_codegen().as_name_for_use()

                builder.append(placement_new(format("common.init_common.{}", name)))
            }
        } else {
            for common in enum_.fields {
                let variable = .program.get_variable(common.variable_id)
                let name = variable.name_for_codegen().as_name_for_use()

                builder.append(assign(format("common.init_common.{}", name)))
            }
        }


        if is_constructor {
            // In a constructor, everything needs placement new since it's uninitialized.
            .codegen_for_enum_variants(&enum_, &placement_new, index_expr: "rhs.__jakt_init_index()", &mut builder)
        } else {
            // If it's not the same thing, the only safe thing here is to call the destructor
            // and use placement_new.
            // NOTE: This method can leave performance on the table. Consider the
            // case of two distinct variants where a value of the same type exists
            // at the same offset in both of them. That value could have used an
            // assignment operator since it's already initialized to the correct
            // type.

            builder.append("if (this->__jakt_variant_index != rhs.__jakt_variant_index) {\n")
            builder.append("this->__jakt_destroy_variant();\n")

            .codegen_for_enum_variants(&enum_, &placement_new, index_expr: "rhs.__jakt_init_index()", &mut builder)

            builder.append("} else {\n")

            // Here we can use assignment for all of the fields, since we know for sure
            // they have been initialized.

            .codegen_for_enum_variants(&enum_, &assign, index_expr: "rhs.__jakt_init_index()", &mut builder)

            builder.append("}\n")
        }

        builder.append("this->__jakt_variant_index = rhs.__jakt_variant_index;\n")

        builder.append("}\n")
        return builder.to_string()
    }

    fn codegen_enum_constructors(
        this
        enum_: CheckedEnum
        is_inside_struct: bool
        generic_parameter_list: String? // Must be Some if enum is generic.
        variant_field_list: [(String, [(String, String)])] // variant_name, [(field_name, .codegen_type(field_type)]
        common_fields: [(String, String)]
        output: &mut StringBuilder
    ) {
        let is_generic = not enum_.generic_parameters.is_empty()

        let ctor_result_type = enum_constructor_result_type(enum_, generic_parameter_list)

        let ctor_type = match is_generic {
            true => format("{}<{}>", enum_.name, generic_parameter_list)
            false => enum_.name
        }

            // NOTE: these statements should compile because a default constructor is provided privately.
        let (declare_uninit, deref_uninit) = match enum_.is_boxed {
            true => (
                format("NonnullRefPtr<{0}> __jakt_uninit_enum = adopt_ref(*new {0});\n", ctor_type),
                "__jakt_uninit_enum->"
            )
            false => (
                format("{} __jakt_uninit_enum;\n", enum_.name),
                "__jakt_uninit_enum."
            )
        }

        guard (is_inside_struct or not is_generic) else {
            panic("Out of line constructor cannot be generated for generic enum")
        }

        let placement_new = fn[](target: String, name: String) -> String {
            return format("new (&{0}) (decltype({1}))(move({1}));\n", target, name)
        }


        // Variant constructors
        for variant_index in 0..variant_field_list.size() {
            let (variant_name, variant_fields) = variant_field_list[variant_index]

            codegen_enum_constructor_decl(
                enum_name: enum_.name
                variant_name
                variant_fields
                common_fields
                is_inline: is_inside_struct
                ctor_result_type
                &mut output
            )

            // Generate the body
            output .append("{\n")

            output .append(declare_uninit)

            // +1 because 0 is the uninitialized tag
            output .appendff("{}__jakt_variant_index = {};\n", deref_uninit, variant_index + 1)

            for field in common_fields {
                let name = field.0
                output .append(placement_new(
                    target: format("{}common.init_common.{}", deref_uninit, name)
                    name
                ))
            }

            for field in variant_fields {
                let name = field.0
                output.append(placement_new(
                    target: format("{}as.{}.{}", deref_uninit, variant_name, name)
                    name
                ))
            }

            output.append("return __jakt_uninit_enum;\n")

            output.append("}\n")
        }

        // Copy assignment operator
        if is_inside_struct {
            output.appendff("{0}& operator=({0} const &rhs)", enum_.name)
        } else {
            output.appendff("{0}& {0}::operator=({0} const &rhs)", enum_.name)
        }
        output.append("{\n")
        output.append(.codegen_enum_assignment_body(enum_,is_constructor: false use_move: false))
        output.append("return *this;\n")
        output.append("}\n")

        // Copy constructor
        if is_inside_struct {
            output.appendff("{0}({0} const &rhs)", enum_.name)
        } else {
            output.appendff("{0}::{0}({0} const &rhs)", enum_.name)
        }
        output.append(.codegen_enum_assignment_body(enum_, is_constructor: true, use_move: false))

        // Move assignment operator
        if is_inside_struct {
            output.appendff("{0}& operator=({0} &&rhs)", enum_.name)
        } else {
            output.appendff("{0}& {0}::operator=({0} &&rhs)", enum_.name)
        }
        output.append("{\n")
        output.append(.codegen_enum_assignment_body(enum_, is_constructor: false, use_move: true))
        output.append("return *this;\n")
        output.append("}\n")

        // Move constructor
        if is_inside_struct {
            output.appendff("{0}({0} &&rhs)", enum_.name)
        } else {
            output.appendff("{0}::{0}({0} &&rhs)", enum_.name)
        }
        output.append("{\n")
        output.append(.codegen_enum_assignment_body(enum_, is_constructor: true, use_move: true))
        output.append("}\n")
    }

    fn codegen_enum_field_lists(mut this, anon enum_: CheckedEnum) throws -> ( [(String, String)], [(String, [(String, String)])]) {
        mut common_fields: [(String, String)] = []
        mut common_field_names: {String} = {}
        for field in enum_.fields {
            let variable = .program.get_variable(field.variable_id)
            let name = variable.name_for_codegen().as_name_for_definition()
            common_fields.push((name, .codegen_type(variable.type_id)))
            common_field_names.add(name)
        }

        // "(<variant_name>, <(arg name, type) list>)". The rest of the function can be generated without looking at the variant.
        mut variant_field_list: [(String, [(String, String)])] = []
        for variant_index in 0..enum_.variants.size() {
            let variant = enum_.variants[variant_index]
            let fields: [(String, String)] = match variant {
                Untyped(name) => [] // no data to add, just the index.
                StructLike(name, fields: own_fields) => {
                    mut fields: [(String, String)] = []
                    for field in own_fields {
                        let variable = .program.get_variable(field)
                        if not common_field_names.contains(variable.name) {
                            fields.push((variable.name_for_codegen().as_name_for_definition(), .codegen_type(variable.type_id)))
                        }
                    }

                    yield fields
                }
                Typed(name, type_id) => {
                    mut fields: [(String, String)] = []
                    fields.push(("value", .codegen_type(type_id)))

                    yield fields
                }
                else => {
                    todo(format("codegen enum variant: {}", variant))
                }
            }

            variant_field_list.push((variant.name(), fields))
        }

        return (common_fields, variant_field_list)
    }

    fn destructor_name(this, anon id: TypeId) -> String? => match .program.get_type(id) {
        JaktString => "ByteString"
        GenericInstance(id) | Struct(id) => {
            let struct_ = .program.get_struct(id)
            yield match (struct_.record_type is Class) {
                true => "NonnullRefPtr"
                false => struct_.name_for_codegen().as_name_for_use()
            }
        }
        TypeVariable(name) => name
        Enum(id) | GenericEnumInstance(id) => {
            let enum_ = .program.get_enum(id)
            yield match enum_.is_boxed {
                true => "NonnullRefPtr"
                false => enum_.name
            }
        }
        else => None
    }

    fn enum_constructor_result_type(enum_: CheckedEnum, generic_parameter_list: String? = None) -> String {
        mut result = enum_.name
        if not enum_.generic_parameters.is_empty() {
            result += format("<{}>", generic_parameter_list!)
        }
        if enum_.is_boxed {
            result = format("NonnullRefPtr<{}>", result)
        }
        return result
    }

    /// Generates the body for `__jakt_destroy_variant`, which calls the correct
    /// destructors just for the varying part of the enum. Used both in the
    /// destructor to fully destruct everything, but also on copy & move
    /// assignment operators when the variant tag isn't the same.
    fn codegen_enum_destroy_variant(this
        enum_: CheckedEnum
        output: &mut StringBuilder
    ) {
        let common_field_count = enum_.fields.size()
        output.append("switch (this->__jakt_init_index()) {\n")
        for variant_index in 0..enum_.variants.size() {
            let variant = enum_.variants[variant_index]
            let variant_name = variant.name()
            output.appendff("case {} /* {} */:", variant_index, variant_name)

            match variant {
                Untyped | WithValue => {}
                Typed(type_id) => {
                    let ds_name = .destructor_name(type_id)
                    if ds_name is Some(name) {
                        output.appendff("this->as.{}.value.~{}();\n", variant_name, name)
                    }
                }
                StructLike(fields) => {
                    for field in fields[common_field_count..] {
                        let variable = .program.get_variable(field)

                        let ds: String? = .destructor_name(variable.type_id)

                        if ds is Some(name) {
                            output.appendff("this->as.{}.{}.~{}();\n",
                                variant_name
                                variable.name_for_codegen().as_name_for_use()
                                name
                            )
                        }
                    }
                }
            }

            output.append("break;\n")
        }
        output.append("}\n")
    }

    fn codegen_enum_destructor_body(
        this
        enum_: CheckedEnum
        output: &mut StringBuilder
    ) {
        output.append("{ if (this->__jakt_variant_index == 0) return;\n")

        let common_field_count = enum_.fields.size()

        for common_field in enum_.fields {
            let variable = .program.get_variable(common_field.variable_id)
            let ds: String? = .destructor_name(variable.type_id)
            if ds is Some(name) {
                output.appendff("this->common.init_common.{}.~{}();\n", variable.name_for_codegen().as_name_for_use(), name)
            }
        }

        output.append("this->__jakt_destroy_variant(); }\n")
    }

    fn codegen_debug_description_getter(
        mut this
        struct_: CheckedStruct
        is_inline: bool = false
        output: &mut StringBuilder
    ) throws {
        if not is_inline and not struct_.generic_parameters.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(struct_.generic_parameters, &mut output)
            output.append(">\n")
        }

        output.append("ByteString ")
        if not is_inline {
            output.append(.codegen_type_possibly_as_namespace(type_id: struct_.type_id, as_namespace: true))
            output.append("::")
        }
        output.append("debug_description() const { ")
        output.append("auto builder = ByteStringBuilder::create();")
        output.appendff("builder.append(\"{}(\"sv);", struct_.name_for_codegen().as_name_for_use())
        output.append("{\n")
        output.append("JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};\n")

        mut i = 0uz
        for field in struct_.fields {
            let field_var = .program.get_variable(field.variable_id)
            output.append("JaktInternal::PrettyPrint::must_output_indentation(builder);\n")
            output.appendff("builder.appendff(\"{}: ", field_var.name_for_codegen().as_name_for_use())
            if .program.is_string(field_var.type_id) {
                output.append("\\\"{}\\\"")
            } else {
                output.append("{}")
            }
            if i != struct_.fields.size() - 1 {
                output.append(", ")
            }
            output.append("\", ")

            output.append(match .program.get_type(field_var.type_id) {
                Struct(struct_id) => match .program.get_struct(struct_id).record_type {
                    Class => "*"
                    else => ""
                }
                else => ""
            })
            output.append(field_var.name_for_codegen().as_name_for_use())
            output.append(");\n")
            i++
        }

        output.append("}\n")
        output.append("builder.append(\")\"sv);")
        output.append("return builder.to_string();")
        output.append(" }\n")
    }

    fn codegen_enum_debug_description_getter(
        mut this
        enum_: CheckedEnum
        is_inline: bool = false
        output: &mut StringBuilder
    ) throws {
        if not is_inline and not enum_.generic_parameters.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(enum_.generic_parameters, &mut output)
            output.append(">\n")
        }

        output.append("ByteString ")
        if not is_inline {
            output.append(.codegen_type_possibly_as_namespace(type_id: enum_.type_id, as_namespace: true))
            output.append("::")
        }
        output.append("debug_description() const {\n")
        output.append("auto builder = ByteStringBuilder::create();\n")
        output.append("switch (this->__jakt_init_index()) {")

        let common_field_count = enum_.fields.size()

        for i in 0..enum_.variants.size() {
            let variant = enum_.variants[i]
            let name = variant.name()
            output.appendff("case {} /* {} */: {{\n", i, name)
            match variant {
                StructLike(fields) => {
                    output.appendff("builder.append(\"{}::{}\"sv);\n", enum_.name, name)
                    output.appendff("[[maybe_unused]] auto const& that = this->as.{};\n", name)
                    output.append("builder.append(\"(\"sv);\n")
                    output.append("{\n");
                    output.append("JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};\n")
                    mut i = 0uz
                    for field in fields {
                        output.append("JaktInternal::PrettyPrint::must_output_indentation(builder);\n")
                        let var = .program.get_variable(field)
                        if .program.is_string(var.type_id){
                            output.appendff("builder.appendff(\"{}: \\\"{{}}\\\"", var.name_for_codegen().as_name_for_use())
                        } else {
                            output.appendff("builder.appendff(\"{}: {{}}", var.name_for_codegen().as_name_for_use())
                        }
                        if i != fields.size() - 1 {
                            output.append(", ")
                        }
                        if i < common_field_count {
                            output.appendff("\", this->common.init_common.{});\n", var.name_for_codegen().as_name_for_use())
                        } else {
                            output.appendff("\", that.{});\n", var.name_for_codegen().as_name_for_use())
                        }
                        i++
                    }
                    output.append("}\n")
                    output.append("builder.append(\")\"sv);\n")
                }
                Typed(type_id) => {
                    output.appendff("builder.append(\"{}::{}\"sv);\n", enum_.name, name)
                    output.appendff("[[maybe_unused]] auto const& that = this->as.{};\n", name)
                    if .program.is_string(type_id){
                        output.append("builder.appendff(\"(\\\"{}\\\")\", that.value);\n")
                    } else {
                        output.append("builder.appendff(\"({})\", that.value);\n")
                    }
                }
                else => {
                    output.appendff("return ByteString(\"{}::{}\"sv);\n", enum_.name, name)
                }
            }

            output.append("break;}\n")
        }

        output.append("}\nreturn builder.to_string();\n}\n")
    }

    fn codegen_ak_formatter(
        mut this
        name: String
        generic_parameter_names: [String]
        anon template_args: String
        output: &mut StringBuilder
    ) {
        let generic_type_args = join(generic_parameter_names, separator: ", ")

        mut qualified_name = ""
        for namespace_ in .namespace_stack {
            qualified_name += format("{}::", namespace_)
        }

        qualified_name += name

        if not generic_parameter_names.is_empty() {
            qualified_name += format("<{}>\n", generic_type_args)
        }

        output.append("} // namespace Jakt\n")
        output.appendff("template<{}>", template_args)
        output.appendff("struct Jakt::Formatter<Jakt::{}> : Jakt::Formatter<Jakt::StringView>", qualified_name)
        output.append("{\n")
        output.appendff("Jakt::ErrorOr<void> format(Jakt::FormatBuilder& builder, Jakt::{} const& value) {{\n", qualified_name)
        output.append("JaktInternal::PrettyPrint::ScopedEnable pretty_print_enable { m_alternative_form };")
        output.append("Jakt::ErrorOr<void> format_error = Jakt::Formatter<Jakt::StringView>::format(builder, value.debug_description());")
        output.append("return format_error;")
        output.append("}\n")
        output.append("};\n")
        output.append("namespace Jakt {\n")
    }

    fn codegen_expression_and_deref_if_generic_and_needed(
        mut this
        anon expression: CheckedExpression
        output: &mut StringBuilder
        syntactically_self_contained: bool
    ) throws {
        if .program.get_type(expression.type()) is TypeVariable {
            output.append("(*([]<typename V>(V&& value) {{ if constexpr (IsSpecializationOf<V, NonnullRefPtr>) return &*value; else return &value; }})(")
            .codegen_expression(expression, &mut output)
            output.append("))")
            return
        }
        .codegen_expression(expression, &mut output, syntactically_self_contained: true)
    }

    // `forward_error_with_try` controls whether errors are handled through the TRY() macro or through an external mechanism put by the caller.
    // `syntactically_self_contained` will wrap the expression in parentheses if it's not by default.
    fn codegen_expression(
        mut this
        anon expression: CheckedExpression
        output: &mut StringBuilder
        forward_error_with_try: bool = true
        syntactically_self_contained: bool = false
    ) throws {
        .generic_inferences = expression.generic_inferences ?? .generic_inferences
        defer .generic_inferences = None

        match expression {
            Reflect(span) => {
                panic(format("Unexpected reflect expression at {}", span))
            }
            Range(from, to, type_id) => {
                let type = .program.get_type(type_id)
                let index_type = match type {
                    GenericInstance(id, args) => args[0]
                    else => {
                        panic("Internal error: range expression doesn't have Range type")
                    }
                }
                output.append(.codegen_type(type_id))
                output.append("{")
                output.append("static_cast<")
                output.append(.codegen_type(index_type))
                output.append(">(")
                if from.has_value() {
                    .codegen_expression(from!, &mut output)
                } else {
                    output.append("0LL")
                }
                output.append("),static_cast<")
                output.append(.codegen_type(index_type))
                output.append(">(")
                if to.has_value() {
                    .codegen_expression(to!, &mut output)
                } else {
                    output.append("9223372036854775807LL")
                }
                output.append(")}")
            }
            OptionalNone => {
                output.append("JaktInternal::OptionalNone()")
            }
            OptionalSome(expr, type_id) => {
                output.append("static_cast<")
                output.append(.codegen_type(type_id))
                output.append(">(")
                .codegen_expression(expr, &mut output)
                output.append(")")
            }
            ForcedUnwrap(expr, type_id) => {
                .codegen_expression(expr, &mut output, syntactically_self_contained: true)
                output.append(".value()")
            }
            QuotedString(val) => {
                let original_string = val.to_string()
                let escaped_value = original_string.replace(replace: "\n", with: "\\n")
                if val.type_id == builtin(BuiltinType::JaktString) {
                    output.append("Jakt::ByteString(\"")
                    output.append(escaped_value)
                    output.append("\"sv)")
                } else {
                    let ids = .program.find_functions_with_name_in_scope(
                        parent_scope_id: .program.find_type_scope_id(val.type_id)
                        function_name: "from_string_literal"
                    )
                    if not ids.has_value() or ids!.is_empty() {
                        panic("Internal error: couldn't find a 'from_string_literal' function despite passing typecheck")
                    }

                    let name = .program.get_function(ids![0]).name_for_codegen().as_name_for_use()

                    let error_handler = match val.may_throw { true => .current_error_handler(forward_error_with_try), else => "" }

                    output.append(error_handler)
                    if not error_handler.is_empty() { output.append('(') }
                    output.appendff(
                        "{}::{}(\"{}\"sv)"
                        .codegen_type_possibly_as_namespace(type_id: val.type_id, as_namespace: true)
                        name
                        escaped_value
                    )
                    if not error_handler.is_empty() { output.append(')') }
                }
            }
            ByteConstant(val) => {
                output.append("static_cast<u8>(u8'")
                output.append(val)
                output.append("')")
            }
            CCharacterConstant(val) => {
                output.append("'")
                output.append(val)
                output.append("'")
            }
            CharacterConstant(val) => {
                output.append("static_cast<u32>(U'")
                output.append(val)
                output.append("')")
            }
            Var(var) => {
                let name = var.name_for_codegen().as_name_for_use()

                if name == "this" {
                    if .this_replacement is Some(replacement) {
                        // the replacement is always a variable name, which never needs
                        // parentheses.
                        output.append(replacement)
                    } else {
                        if syntactically_self_contained {
                            output.append("(*this)")
                        } else {
                            output.append("*this")
                        }
                    }
                } else {
                    output.append(name)
                }
            }
            IndexedExpression(expr, index) => {
                .codegen_expression(expr, &mut output, syntactically_self_contained: true)
                output.append('[')
                .codegen_expression(index, &mut output)
                output.append(']')
            }
            IndexedDictionary(expr, index) => {
                .codegen_expression(expr, &mut output, syntactically_self_contained: true)
                output.append('[')
                .codegen_expression(index, &mut output)
                output.append(']')
            }
            IndexedTuple(expr, index, is_optional) => {
                .codegen_expression(expr, &mut output, syntactically_self_contained: true)
                if is_optional {
                    output.appendff(".map([](auto& _value) {{ return _value.template get<{}>(); }})", index)
                } else {
                    output.appendff(".template get<{}>()", index)
                }
            }
            IndexedStruct(expr, name, index, is_optional) => {
                .codegen_expression(expression: expr, output, syntactically_self_contained: true)

                let var_name = match index.has_value() {
                    true => .program.get_variable(index!).name_for_codegen().as_name_for_use()
                    false => name
                }

                let expression_type = .program.get_type(expr.type())
                match expression_type {
                    RawPtr => {
                        output.append("->")
                    }
                    Struct(id) | GenericInstance(id) => {

                        let structure = .program.get_struct(id)
                        if structure.record_type is Class and not .expr_codegens_to_this_pointer(expr) {
                            output.append("->")
                        } else {
                            output.append(".")
                        }
                    }
                    else => {
                        output.append(".")
                    }
                }
                if is_optional {
                    output.append("map([](auto& _value) { return _value")
                    mut access_operator = "."
                    if expression_type is GenericInstance(args) and args.size() > 0 {
                        match .program.get_type(args[0]) {
                            Struct(id) | GenericInstance(id) => {
                                if .program.get_struct(id).record_type is Class {
                                    access_operator = "->"
                                }
                            }
                            else => {}
                        }
                    }
                    output.append(access_operator)
                    output.append(var_name)
                    output.append("; })")
                } else {
                    output.append(var_name)
                }
            }
            IndexedCommonEnumMember(expr, index, is_optional) => {
                .codegen_expression(expression: expr, output, syntactically_self_contained: true)

                match .program.get_type(expr.type()) {
                    RawPtr => {
                        output.append("->")
                    }
                    Enum(id) | GenericEnumInstance(id) => {
                        let structure = .program.get_enum(id)
                        if structure.record_type is SumEnum(is_boxed) and is_boxed and not .expr_codegens_to_this_pointer(expr) {
                            output.append("->common.init_common.")
                        } else {
                            output.append(".common.init_common.")
                        }
                    }
                    else => {
                        output.append(".")
                    }
                }
                if is_optional {
                    output.append("map([](auto& _value) { return _value.")
                    output.append(index)
                    output.append("; })")
                } else {
                    output.append(index)
                }
            }
            ComptimeIndex() => {
                panic("Internal error: ComptimeIndex should have been replaced by now")
            }
            Block(block) => {
                .codegen_block(block, &mut output)
            }
            Call(call) => {
                .codegen_call(call, &mut output, forward_error_with_try)
            }
            MethodCall(expr, call, is_optional) => {
                .codegen_method_call(expr, call, is_optional, &mut output, forward_error_with_try, syntactically_self_contained)
            }
            Boolean(val) => {
                output.append(match val {
                    true => "true"
                    else => "false"
                })
            }
            UnaryOp(expr, op, type_id) => {


                match op {
                    PreIncrement    => .codegen_prefix_unary(expr, cpp_operator: "++", output, syntactically_self_contained)
                    PreDecrement    => .codegen_prefix_unary(expr, cpp_operator: "--", output, syntactically_self_contained)
                    Negate          => .codegen_prefix_unary(expr, cpp_operator: "-",  output, syntactically_self_contained)
                    LogicalNot      => .codegen_prefix_unary(expr, cpp_operator: "!",  output, syntactically_self_contained)
                    BitwiseNot      => .codegen_prefix_unary(expr, cpp_operator: "~",  output, syntactically_self_contained)

                    PostIncrement   => .codegen_postfix_unary(expr, cpp_operator: "++", output, syntactically_self_contained)
                    PostDecrement   => .codegen_postfix_unary(expr, cpp_operator: "--", output, syntactically_self_contained)

                    Dereference => match .program.get_type(expr.type()) {
                        RawPtr  => .codegen_prefix_unary(expr, cpp_operator: "*", output, syntactically_self_contained)
                        else    => .codegen_expression(expr, output, syntactically_self_contained)
                    }

                    Reference | MutableReference => .codegen_expression(expr, output, syntactically_self_contained)

                    // FIXME: Remove this once we have proper type mutability support
                    RawAddress => {
                        let is_boxed = .program.get_type(expr.type()).is_boxed(program: .program)
                        output.appendff("const_cast<{}>(&", .codegen_type_possibly_as_namespace(type_id, as_namespace: is_boxed))
                        if is_boxed {
                            output.append('*')
                        }
                        .codegen_expression(expr, output, syntactically_self_contained: true)
                        output.append(')')
                    }

                    Sizeof(type_id) => output.appendff("sizeof({})", .codegen_type(type_id))

                    Is(type_id) => {
                        let is_type = match .program.get_type(type_id) {
                            Struct(id) => {
                                let struct_ = .program.get_struct(id)
                                yield .codegen_namespace_qualifier(scope_id: struct_.scope_id, is_prelude: .program.get_module(id.module).is_prelude()) + struct_.name_for_codegen().as_name_for_use()
                            }
                            else => .codegen_type(type_id)
                        }
                        output.appendff("is<{}>(", is_type)
                        .codegen_expression(expr, output)
                        output.append(')')
                    }

                    IsNone => {
                        output.append('!')
                        .codegen_expression(expr, output, syntactically_self_contained: true)
                        output.append(".has_value()")
                    }

                    IsSome => {
                        .codegen_expression(expr, output, syntactically_self_contained: true)
                        output.append(".has_value()")
                    }

                    TypeCast(cast) => {
                        mut final_type_id = cast.type_id()
                        let type = .program.get_type(final_type_id)
                        let cast_type = match cast {
                            Fallible => {
                                let type_id = match type {
                                    GenericInstance(args) => args[0]
                                    else => {
                                        panic("Fallible type cast must have Optional result.")
                                    }
                                }
                                mut cast_type = "dynamic_cast"
                                if .program.get_type(type_id) is Struct(struct_id)
                                    and .program.get_struct(struct_id).record_type is Class {
                                        final_type_id = type_id
                                    cast_type = "fallible_class_cast"
                                } else if .program.is_integer(type_id) {
                                    final_type_id = type_id
                                    cast_type = "fallible_integer_cast"
                                } else if .program.is_floating(type_id) {
                                    final_type_id = type_id
                                    cast_type = "fallible_float_cast"
                                }

                                yield cast_type
                            }
                            Infallible => {
                                mut cast_type = "verify_cast"
                                if expr.type() == unknown_type_id() {
                                    cast_type = "assert_type"
                                } else if type.is_boxed(program: .program) {
                                    cast_type = "infallible_class_cast"
                                } else if (.program.is_integer(expr.type()) and .program.is_floating(type_id)) or
                                    (.program.is_floating(expr.type()) and .program.is_integer(type_id)) or
                                    (.program.is_floating(expr.type()) and .program.is_floating(type_id)) {

                                    cast_type = "infallible_float_cast"
                                } else if .program.is_integer(type_id) {
                                    cast_type = "infallible_integer_cast"
                                } else if type is Enum(enum_id) and .program.is_integer(.program.get_enum(enum_id).underlying_type_id) {
                                    cast_type = "infallible_enum_cast"
                                } else if type is RawPtr(inner) {
                                    cast_type = "reinterpret_cast"
                                }
                                yield cast_type
                            }
                            Identity => "static_cast"
                        }
                        output.appendff("{}<{}>(", cast_type , .codegen_type(final_type_id))
                        .codegen_expression(expr, output)
                        output.append(')')
                    }

                    IsEnumVariant(enum_variant, type_id: enum_type_id) => {

                        if syntactically_self_contained { output.append('(') }
                        defer if syntactically_self_contained { output.append(')') }

                        .codegen_expression(expr, output, syntactically_self_contained: true)

                        let name = enum_variant.name()
                        let enum_id = match .program.get_type(enum_type_id) {
                            Enum(enum_id) => enum_id
                            GenericEnumInstance(id) => id
                            else => {
                                panic(format("Unexpected type in IsEnumVariant: {}", .program.get_type(enum_type_id)))
                            }
                        }
                        let enum_ = .program.get_enum(enum_id)
                        match enum_.record_type {
                            SumEnum => {
                                let is_boxed = enum_.is_boxed

                                if is_boxed and not .expr_codegens_to_this_pointer(expr) {
                                    output.append("->")
                                } else {
                                    output.append(".")
                                }

                                // FIXME: This should be a call to find(), but we do not yet provide the needed operator== for that
                                mut variant_index = 0;
                                for variant in enum_.variants {
                                    if variant.name() == name {
                                        break
                                    }
                                    variant_index++
                                }
                                output.appendff("__jakt_init_index() == {} /* {} */", variant_index, name)
                            }
                            ValueEnum => {
                                output.appendff("== {}{}::{}", .codegen_namespace_qualifier(scope_id: enum_.scope_id, is_prelude: .program.get_module(enum_id.module).is_prelude()), enum_.name, name)
                            }
                            else => {
                                panic(format("Unexpected enum record type in IsEnumVariant: {}", enum_.record_type))
                            }
                        }
                    }

                }

            }
            BinaryOp(lhs, rhs, op, type_id) => {
                .codegen_binary_expression(expression, type_id, lhs, rhs, op, &mut output, forward_error_with_try, syntactically_self_contained)
            }
            NumericConstant(val, type_id) => {
                let suffix = match val {
                    I64 => "LL"
                    U64 | USize => "ULL"
                    else => ""
                }

                let type_name = match val {
                    USize => "size_t"
                    else => .codegen_type(type_id)
                }

                output.append(match val {
                    F32(val)
                    | F64(val)
                    | I8(val)
                    | I16(val)
                    | I32(val)
                    | I64(val)
                    | U8(val)
                    | U16(val)
                    | U32(val)
                    | U64(val)
                    | USize(val)
                    => format("static_cast<{}>({}{})", type_name, val, suffix)
                })
            }
            NamespacedVar(namespaces, var) => {
                if var.name_for_codegen().is_scopable() {
                    if var.owner_scope.has_value() {
                        output.append(.codegen_namespace_qualifier(
                            scope_id: var.owner_scope!
                            is_prelude: false
                            skip_current: false
                        ))
                    } else {
                        for ns in namespaces {
                            output.append(ns.name)
                            output.append("::")
                        }
                    }
                }
                output.append(var.name_for_codegen().as_name_for_use())
            }
            Match(expr, match_cases, type_id, all_variants_constant) => {
                .codegen_match(expr, match_cases, type_id, all_variants_constant, &mut output)
            }
            EnumVariantArg(expr, arg, enum_variant) => {
                let variant_name = enum_variant.name()

                let enum_ = .program.get_enum(enum_variant.enum_id())

                let cpp_deref_operator = match enum_.is_boxed {
                    true => "->"
                    else => "."
                }

                // use the common section if the binding uses a common field
                mut section = format("as.{}", variant_name)

                mut is_common_field = false
                mut field_name = arg.name ?? arg.binding
                for field in enum_.fields {
                    let var_name = .program.get_variable(field.variable_id).name_for_codegen().as_name_for_use()
                    if var_name == field_name {
                        section = "common.init_common"
                        is_common_field = true
                        break
                    }
                }

                if not is_common_field and not enum_variant is StructLike {
                    field_name = "value"
                }

                .codegen_expression(expr, &mut output, syntactically_self_contained: true)
                output.append(cpp_deref_operator)
                output.append(section)
                output.append(".")
                output.append(field_name)
            }
            JaktArray(vals, repeat, span, type_id, inner_type_id) => {
                if repeat.has_value() {
                    let repeat_val = repeat.value()
                    output.append("DynamicArray<")
                    output.append(.codegen_type(inner_type_id))
                    output.append(">::filled(")
                    .codegen_expression(repeat_val, &mut output)
                    output.append(", ")
                    .codegen_expression(vals[0], &mut output)
                    output.append(")")
                } else {
                    output.append("DynamicArray<")
                    output.append(.codegen_type(inner_type_id))
                    output.append(">::create_with({")
                    mut first = true
                    for val in vals {
                        if not first {
                            output.append(", ")
                        } else {
                            first = false
                        }

                        .codegen_expression(val, &mut output)
                    }
                    output.append("})")
                }
            }
            JaktDictionary(vals, span, type_id, key_type_id, value_type_id) => {
                output.appendff("Dictionary<{}, {}>::create_with_entries({{",
                    .codegen_type(key_type_id),
                    .codegen_type(value_type_id))

                mut first = true
                for (key, value) in vals {
                    if not first {
                        output.append(", ")
                    } else {
                        first = false
                    }

                    output.append("{")
                    .codegen_expression(key, &mut output)
                    output.append(", ")
                    .codegen_expression(value, &mut output)
                    output.append("}")
                }

                output.append("})")
            }
            JaktSet(vals, span, type_id, inner_type_id) => {
                output.appendff("Set<{}>::create_with_values({{", .codegen_type(inner_type_id))
                mut first = true
                for value in vals {
                    if not first {
                        output.append(", ")
                    } else {
                        first = false
                    }
                    .codegen_expression(value, &mut output)
                }
                output.append("})")
            }
            JaktTuple(vals, span, type_id) => {
                output.append("Tuple{")
                mut first = true
                for val in vals {
                    if not first {
                        output.append(", ")
                    } else {
                        first = false
                    }

                    .codegen_expression(val, &mut output)
                }
                output.append("}")
            }
            DependentFunction => {
                .compiler.panic("Dependent functions should have been resolved by now")
            }
            Function(captures, params, can_throw, block, return_type_id, pseudo_function_id) => {
                mut generated_captures: [String] = []
                for capture in captures {
                    generated_captures.push(match capture {
                        ByValue => capture.name
                        AllByReference => "&"
                        else => format("&{}", capture.name)
                    })
                }
                mut generated_params: [String] = []
                for param in params {
                    generated_params.push(format("{} {}", .codegen_type(param.variable.type_id), param.variable.name_for_codegen().as_name_for_definition()))
                }
                let return_type = match can_throw {
                    true => format("ErrorOr<{}>", .codegen_type(return_type_id))
                    false => .codegen_type(return_type_id)
                }

                let last_control_flow = .control_flow_state
                .control_flow_state = last_control_flow.enter_function()
                defer .control_flow_state = last_control_flow

                output.appendff(
                    "[{}]({}) -> {} "
                    join(generated_captures, separator: ", ")
                    join(generated_params, separator: ", ")
                    return_type)

                if pseudo_function_id.has_value() {
                    let function = .program.get_function(pseudo_function_id!)

                    let previous_function = .current_function
                    .current_function = function
                    defer .current_function = previous_function

                    .codegen_lambda_block(can_throw, block, return_type_id, &mut output)
                } else {
                    .codegen_lambda_block(can_throw, block, return_type_id, &mut output)
                }
            }
            TryBlock(stmt, error_name, catch_block, span) => {
                let try_var = .fresh_var()
                let can_affect_loop = match stmt.control_flow() {
                    MayReturn => false
                    else => true
                }

                mut builder = StringBuilder::create()
                let last_control_flow = .control_flow_state
                if can_affect_loop {
                    .control_flow_state.indirectly_inside_try_block = true
                    builder.append(format("[&]() -> JaktInternal::ExplicitValueOrControlFlow<ErrorOr<void>, {}> {{\n", .codegen_function_return_type(function: .current_function!)))
                } else {
                    builder.append("auto ")
                    builder.append(try_var)
                    builder.append(" = [&]() -> ErrorOr<void> {\n")
                    .control_flow_state.directly_inside_match = false
                    .control_flow_state.indirectly_inside_match = false
                }
                .control_flow_state.passes_through_try = true
                .codegen_statement(statement: stmt, output: &mut builder)
                builder.append(";\n")
                if can_affect_loop {
                    builder.append("return JaktInternal::ExplicitValue<ErrorOr<void>>({});")
                } else {
                    builder.append("return ErrorOr<void> {};")
                }
                builder.append("}();\n")

                if can_affect_loop {
                    output.append("auto ")
                    output.append(try_var)
                    output.append(" = ")
                    output.append(.control_flow_state.apply_control_flow_macro(
                        builder.to_string()
                        func_return_type: .current_function!.return_type_id
                        func_can_throw: .current_function!.can_throw
                    ))
                    output.append(";\n")
                } else {
                    output.append(builder.to_string())
                }

                output.append("if (")
                output.append(try_var)
                output.append(".is_error()) {")
                if not error_name.is_empty() {
                    output.append("auto ")
                    output.append(error_name)
                    output.append(" = ")
                    output.append(try_var)
                    output.append(".release_error();\n")
                }
                .codegen_block(block: catch_block, &mut output)
                .control_flow_state = last_control_flow
                output.append("}")
            }
            Try(expr, catch_block, catch_name, span, type_id, inner_type_id) => {
                let fresh_var = .fresh_var()
                let is_void = inner_type_id == void_type_id()
                let try_var = .fresh_var()

                let last_control_flow = .control_flow_state
                .control_flow_state.directly_inside_match = false
                .control_flow_state.indirectly_inside_match = false
                .control_flow_state.passes_through_try = true
                defer {
                    .control_flow_state = last_control_flow
                }

                if not is_void {
                    output.append("({ Optional<")
                    output.append(.codegen_type(inner_type_id))
                    output.append("> ")
                    output.append(fresh_var)
                    output.append(";\n")
                }

                output.append("auto ")
                output.append(try_var)
                output.append(" = [&]() -> ErrorOr<")
                output.append(.codegen_type(inner_type_id))
                output.append("> { return ")
                // Since it's a return statement, we don't have to wrap the expression with TRY.
                // Unless it's a "void expression", where we must use TRY() in order to propagate its
                // effect before returning an ErrorOr<void>{}
                .codegen_expression(expr, &mut output, forward_error_with_try: is_void)
                if is_void {
                    output.append(", ErrorOr<void>{}")
                }
                output.append("; }();\n")

                if catch_block.has_value() {
                    // At this point, we're no longer inside the try, so restore the control flow state (partially).
                    .control_flow_state.indirectly_inside_match = last_control_flow.indirectly_inside_match
                    .control_flow_state.directly_inside_match = last_control_flow.directly_inside_match

                    output.append("if (")
                    output.append(try_var)
                    output.append(".is_error()) {")
                    if catch_name.has_value() {
                        output.append("auto ")
                        output.append(catch_name!)
                        output.append(" = ")
                        output.append(try_var)
                        output.append(".release_error();\n")
                    }

                    if catch_block!.yielded_type.has_value() {
                        let label = .fresh_label()
                        let old_yield_method = .yield_method
                        .yield_method = YieldMethod::AssignAndGoto(name: fresh_var, label)
                        defer .yield_method = old_yield_method

                        .codegen_block(block: catch_block!, &mut output)

                        output.append(label)
                        output.append(":;\n")
                    } else {
                        .codegen_block(block: catch_block!, &mut output)
                    }

                    if not is_void {
                        output.append("} else {")
                        output.append(fresh_var)
                        output.append(" = ")
                        output.append(try_var)
                        output.append(".release_value();\n")
                    }
                    output.append("}\n")
                } else if not is_void {
                    output.append("if (!")
                    output.append(try_var)
                    output.append(".is_error()) ")
                    output.append(fresh_var)
                    output.append(" = ")
                    output.append(try_var)
                    output.append(".release_value();\n")
                }

                if not is_void {
                    output.append(fresh_var)
                    if catch_block.has_value() {
                        output.append(".release_value()")
                    }
                    output.append("; })")
                }
            }
            Must(expr, type_id) => {
                let last_control_flow = .control_flow_state
                .control_flow_state.directly_inside_match = false
                .control_flow_state.indirectly_inside_match = false
                .control_flow_state.passes_through_try = true
                defer {
                    .control_flow_state = last_control_flow
                }

                output.append("MUST((")
                .codegen_expression(expr, &mut output, forward_error_with_try: false)
                output.append("))")
            }
            Garbage(span) => {
                todo(format("codegen_expression of bad AST node in {} at {}..{}", this.compiler.get_file_path(span.file_id), span.start, span.end))
            }
        }
    }

    fn expr_codegens_to_this_pointer(this, anon expr: CheckedExpression) -> bool {
        guard expr is Var(var) else { return false }
        return var.name == "this" and .this_replacement is None
    }

    fn codegen_prefix_unary(mut this, expr: CheckedExpression, cpp_operator: StringView, output: &mut StringBuilder, syntactically_self_contained: bool) throws {
        if syntactically_self_contained { output.append('(') }

        output.append(cpp_operator)
        .codegen_expression(expr, output, syntactically_self_contained: true)

        if syntactically_self_contained { output.append(')') }
    }

    fn codegen_postfix_unary(mut this, expr: CheckedExpression, cpp_operator: StringView, output: &mut StringBuilder, syntactically_self_contained: bool) throws {
        if syntactically_self_contained { output.append('(') }

        .codegen_expression(expr, output, syntactically_self_contained: true)
        output.append(cpp_operator)

        if syntactically_self_contained { output.append(')') }
    }

    fn codegen_match(
        mut this
        expr: CheckedExpression
        match_cases: [CheckedMatchCase]
        type_id: TypeId
        all_variants_constant: bool
        output: &mut StringBuilder
    ) throws {
        mut builder = StringBuilder::create()
        let last_control_flow = .control_flow_state
        .control_flow_state = .control_flow_state.enter_match()

        let cpp_match_result_type = .codegen_type(type_id)
        let expr_type = .program.get_type(expr.type())

        let old_yield_method = .yield_method
        .yield_method = YieldMethod::ReturnExplicitValue(ctor: format("JaktInternal::ExplicitValue<{}>", cpp_match_result_type))
        defer .yield_method = old_yield_method

        if expr_type is Enum(enum_id) {
            .codegen_enum_match(
                enum_: .program.get_enum(enum_id)
                expr
                match_cases
                type_id
                cpp_match_result_type
                all_variants_constant
                output: &mut builder
            )
        } else {
            .codegen_generic_match(
                expr
                cases: match_cases
                return_type_id: type_id
                cpp_match_result_type
                all_variants_constant
                output: &mut builder
            )
        }
        .control_flow_state = last_control_flow
        output.append(.control_flow_state.apply_control_flow_macro(
            builder.to_string()
            func_return_type: .current_function!.return_type_id
            func_can_throw: .current_function!.can_throw
        ))
    }

    fn codegen_generic_match(
        mut this
        expr: CheckedExpression
        cases: [CheckedMatchCase]
        return_type_id: TypeId
        cpp_match_result_type: String
        all_variants_constant: bool
        output: &mut StringBuilder
    ) throws {
        mut is_generic_enum: bool = false
        for case_ in cases {
            if case_ is EnumVariant {
                is_generic_enum = true
                break
            }
        }
        let match_values_all_constant = all_variants_constant and not is_generic_enum

        let byte_string_type_id = .program.find_or_add_type_id(
            type: Type::Struct(.program.find_struct_in_prelude("String"))
            module_id: .program.prelude_module_id()
        )

        // TODO: Use switch statement if all values are constant
        output.appendff(
            "([&]() -> JaktInternal::ExplicitValueOrControlFlow<{},{}> {{\n"
            cpp_match_result_type,
            .codegen_function_return_type(function: .current_function!)
        )

        if is_generic_enum {
            output.append("auto&& __jakt_enum_value = JaktInternal::deref_if_ref_pointer(")
        } else {
            output.append("auto __jakt_enum_value = (")
        }
        .codegen_expression(expr, &mut output)
        output.append(");\n")

        mut has_default = false
        mut first = true
        for case_ in cases {
            let defaults = case_.defaults

            match case_ {
                EnumVariant(name, args, subject_type_id, scope_id, body) => {
                    let enum_ = .program.get_enum(match .program.get_type(subject_type_id) {
                        Enum(enum_id) => enum_id
                        GenericEnumInstance(id) => id
                        else => {
                            panic(format("Unexpected type in IsEnumVariant: {}", .program.get_type(subject_type_id)))
                        }
                    })
                    // FIXME: This should be a call to find(), but we do not yet provide the needed operator== for that
                    mut variant_index = 0;
                    for variant in enum_.variants {
                        if variant.name() == name {
                            break
                        }
                        variant_index++
                    }

                    output.appendff("if (__jakt_enum_value.__jakt_init_index() == {} /* {} */) {{\n", variant_index, name)

                    mut variant_type_name = ""
                    let qualifier = .codegen_type_possibly_as_namespace(type_id: subject_type_id, as_namespace: true)
                    if not qualifier.is_empty() {
                        variant_type_name += "typename JaktInternal::RemoveRefPtr<"
                        variant_type_name += qualifier
                        variant_type_name += ">::"
                    }
                    variant_type_name += name

                    if not args.is_empty() {
                        output.append("auto& __jakt_match_value = __jakt_enum_value.as.")
                        output.append(enum_.variants[variant_index].name())
                        output.append(";\n")

                        for arg in args {
                            output.append("auto& ")
                            output.append(arg.binding)

                            mut is_common_member = false
                            if arg.name is Some(name) {
                                for field in enum_.fields {
                                    let var = .program.get_variable(field.variable_id)
                                    if var.name == name {
                                        is_common_member = true
                                        break
                                    }
                                }
                            }

                            if is_common_member {
                                output.append(" = __jakt_enum_value.common.init_common.")
                                output.append(arg.name!)
                            } else {
                                output.append(" = __jakt_match_value.")
                                output.append(arg.name ?? "value")
                            }
                            output.append(";\n")
                        }
                    }

                    for default_ in defaults {
                        .codegen_statement(statement: default_, &mut output)
                    }

                    .codegen_match_body(body, return_type_id, &mut output)
                    output.append("}\n")
                }
                CatchAll(has_arguments, body, marker_span) => {
                    if has_arguments {
                        panic("Bindings should not be present in a generic else")
                    }

                    // TODO: Use default statement if all values are constant
                    has_default = true

                    if first {
                        output.append("{")
                    } else {
                        output.append("else {\n")
                    }

                    for default_ in defaults {
                        .codegen_statement(statement: default_, &mut output)
                    }

                    .codegen_match_body(body, return_type_id, &mut output)
                    output.append("}\n")
                }
                Expression(expression, body, marker_span) => {
                    // TODO: Use case statement if all values are constant
                    if not first {
                        output.append("else ")
                    }
                    if expression is Range(from, to) {
                        output.append("if (__jakt_enum_value")
                        if from.has_value() {
                            output.append(" >= ")
                            .codegen_expression(from!, &mut output, syntactically_self_contained: true)
                        }

                        if to.has_value() {
                            if from.has_value() {
                                output.append("&& __jakt_enum_value ")
                            }
                            output.append("< ")
                            .codegen_expression(to!, &mut output, syntactically_self_contained: true)
                        }
                    } else {
                        output.append("if (__jakt_enum_value == ")
                        if expression is QuotedString(val)
                            and (val.type_id == byte_string_type_id or val.type_id == builtin(BuiltinType::JaktString)) {
                            let original_string = val.to_string()
                            let escaped_value = escape_for_quotes(original_string)
                            output.append("\"")
                            output.append(escaped_value)
                            output.append("\"sv")
                        } else {
                            .codegen_expression(expression, &mut output, syntactically_self_contained: true)
                        }
                    }
                    output.append(") {\n")
                    .codegen_match_body(body, return_type_id, &mut output)
                    output.append("}\n")
                }
                ClassInstance(type, body, rebind_name, marker_span) => {
                    let type_name = .codegen_type_possibly_as_namespace(type_id: type, as_namespace: true)
                    output.appendff("if (is<{}>(__jakt_enum_value.ptr())) {{\n", type_name)
                    output.appendff(
                        "auto {} = NonnullRefPtr {{ *static_cast<RawPtr<{}>>(__jakt_enum_value.ptr()) }};\n"
                        (rebind_name?.name ?? "__jakt_match_value")
                        type_name
                    )

                    for default_ in defaults {
                        .codegen_statement(statement: default_, &mut output)
                    }

                    .codegen_match_body(body, return_type_id, &mut output)
                    output.append("}\n")
                }
            }
            first = false
        }
        if return_type_id == void_type_id() or return_type_id == unknown_type_id() {
            output.append("return JaktInternal::ExplicitValue<void>();\n")
        } else if not has_default {
            output.append("VERIFY_NOT_REACHED();\n")
        }

        output.append("}())")
    }

    fn codegen_enum_match(
        mut this
        enum_: CheckedEnum
        expr: CheckedExpression
        match_cases: [CheckedMatchCase]
        type_id: TypeId
        cpp_match_result_type: String
        all_variants_constant: bool
        output: &mut StringBuilder
    ) throws {
        mut subject_builder = StringBuilder::create()
        .codegen_expression(expr, output: &mut subject_builder)
        let subject = subject_builder.to_string()
        let needs_deref = enum_.is_boxed and subject != "*this"

        if enum_.underlying_type_id == void_type_id() {
            output.append("([&]() -> JaktInternal::ExplicitValueOrControlFlow<")
            output.append(cpp_match_result_type)
            output.append(", ")
            output.append(.codegen_function_return_type(function: .current_function!))
            output.append(">{\n")
            output.append("auto&& __jakt_match_variant = ")
            if needs_deref {
                output.append("*")
            }
            .codegen_expression(expr, &mut output)
            output.append(";\n")
            output.append("switch(__jakt_match_variant.__jakt_init_index()) {\n")

            mut has_default = false
            for match_case in match_cases {
                match match_case {
                    EnumVariant(name, args, subject_type_id, index, scope_id, body) => {
                        let enum_type = .program.get_type(subject_type_id)
                        let enum_id = match enum_type {
                            Enum(id) => id
                            else => {
                                panic("Expected enum type")
                            }
                        }
                        let match_case_enum = .program.get_enum(enum_id)
                        let variant = match_case_enum.variants[index]
                        output.appendff("case {} /* {} */: {{\n", index, variant.name())
                        match variant {
                            Untyped(name) => {
                            }
                            Typed(name, type_id) => {
                                if not args.is_empty() {
                                    output.appendff(
                                        "auto&& __jakt_match_value = __jakt_match_variant.as.{};",
                                        name
                                    )

                                    let arg = args[0]
                                    let var = .program.find_var_in_scope(scope_id, var: arg.binding)!
                                    output.append(.codegen_type(var.type_id))
                                    if not var.is_mutable {
                                        output.append(" const")
                                    }
                                    output.append("& ")
                                    output.append(arg.binding)
                                    output.append(" = __jakt_match_value.value;\n")
                                }
                            }
                            StructLike(name, fields) => {
                                if not args.is_empty() {
                                    output.appendff(
                                        "auto&& __jakt_match_value = __jakt_match_variant.as.{};",
                                        name)

                                    for arg in args {
                                        let var = .program.find_var_in_scope(scope_id, var: arg.binding)!
                                        output.append(.codegen_type(var.type_id))
                                        if not var.is_mutable {
                                            output.append(" const")
                                        }
                                        output.append("& ")
                                        output.append(arg.binding)


                                        let accessor = arg.name ?? arg.binding
                                        mut is_common_member = false
                                        for field in enum_.fields {
                                            let var = .program.get_variable(field.variable_id)
                                            if var.name == accessor {
                                                is_common_member = true
                                                break
                                            }
                                        }

                                        if is_common_member {
                                            output.append(" = __jakt_match_variant.common.init_common.")
                                            output.append(accessor)
                                        } else {
                                            output.append(" = __jakt_match_value.")
                                            output.append(accessor)
                                        }
                                        output.append(";\n")
                                    }
                                }
                            }
                            else => {
                                todo(format("codegen_enum_match match variant else: {}", variant))
                            }
                        }

                        for default_ in match_case.defaults {
                            .codegen_statement(statement: default_, &mut output)
                        }

                        .codegen_match_body(body, return_type_id: type_id, &mut output)
                        output.append("};/*case end*/\n")
                    }
                    CatchAll(body) => {
                        has_default = true

                        output.append("default: {\n")
                        for default_ in match_case.defaults {
                            .codegen_statement(statement: default_, &mut output)
                        }

                        .codegen_match_body(body, return_type_id: type_id, &mut output)
                        output.append("};/*case end*/\n")
                    }
                    else => {
                        panic("Matching enum subject with non-enum value")
                    }
                }
            }
            if not has_default {
                if enum_.variants.size() != match_cases.size() {
                    panic("Inexhaustive match statement")
                }
                output.append("default: VERIFY_NOT_REACHED();")
            }
            output.append("}/*switch end*/\n")
            output.append("}()\n)")
        } else {
            output.append("([&]() -> JaktInternal::ExplicitValueOrControlFlow<")
            output.append(cpp_match_result_type)
            output.append(", ")
            output.append(.codegen_function_return_type(function: .current_function!))
            output.append(">{\n")
            output.append("switch (")
            .codegen_expression(expr, &mut output)
            output.append(") {\n")

            for match_case in match_cases {
                match match_case {
                    EnumVariant(name, body) => {
                        output.append("case " + enum_.name + "::" + name + ": {\n")
                        .codegen_match_body(body, return_type_id: type_id, &mut output)
                        output.append("}\n")
                    }
                    CatchAll(body) => {
                        output.append("default: {\n")
                        .codegen_match_body(body, return_type_id: type_id, &mut output)
                        output.append("}\n")
                    }
                    else => {
                        todo(format("underlying type enum match, match_case: {}", match_case))
                    }
                }
            }
            output.append("}/*switch end*/\n")
            output.append("}()\n)")
        }
    }

    fn codegen_match_body(
        mut this
        body: CheckedMatchBody
        return_type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        match body {
            Block(block) => {
                .codegen_block(block, output)

                if return_type_id == void_type_id() or return_type_id == unknown_type_id() {
                    output.append("return JaktInternal::ExplicitValue<void>();\n")
                }
            }
            Expression(expr) => {

                if expr is Block(block) {
                    .codegen_block(block, output)
                    // NOTE: should not need any guarding
                    output.append("VERIFY_NOT_REACHED();\n")
                } else if expr.type() == void_type_id() or expr.type() == never_type_id() or (
                    expr.type() == unknown_type_id() and
                    not expr is OptionalNone
                ) {
                    output.append("return ({")
                    .codegen_expression(expr, &mut output)
                    output.append(";}), JaktInternal::ExplicitValue<void>();\n")
                } else {
                    output.append("return JaktInternal::ExplicitValue(")
                    .codegen_expression(expr, &mut output)
                    output.append(");\n")
                }
            }
        }
    }

    fn codegen_function_return_type(mut this, function: CheckedFunction) throws -> String {
        if function.is_static() and function.name_for_codegen().as_name_for_use() == "main" {
            return "ErrorOr<int>"
        }
        let type_name = .codegen_type(function.return_type_id)
        if function.can_throw {
            return format("ErrorOr<{}>", type_name)
        }
        return type_name
    }

    fn codegen_binary_expression(
        mut this
        expression: CheckedExpression
        type_id: TypeId
        lhs: CheckedExpression
        rhs: CheckedExpression
        op: CheckedBinaryOperator
        output: &mut StringBuilder
        forward_error_with_try: bool
        syntactically_self_contained: bool
    ) throws {
        if op.trait_implementation is Some(implementation) {
            // Since the binary op is done through a call, then TRY() forwarding
            // makes sense as the call is now the primary expression.
            .codegen_method_call(
                expr: lhs
                call: implementation.call_expression
                is_optional: false
                &mut output
                forward_error_with_try
                syntactically_self_contained
            )
            return
        }

        // NOTE: We don't propagate `forward_error_with_try` here because none of
        // the operations here have a way to syntactically replace the TRY()
        // macro.

        if op.op is NoneCoalescing {
            let rhs_type_id = rhs.type()
            let rhs_type = .program.get_type(rhs_type_id)
            let rhs_can_throw = rhs.can_throw()

            if rhs_can_throw {
                output.append(.current_error_handler())
                output.append("((")
            }

            .codegen_expression(lhs, &mut output, syntactically_self_contained: true)
            if rhs_type is GenericInstance(id) and .program.get_struct(id).name_for_codegen().as_name_for_definition() == "Optional" {
                if rhs_can_throw {
                    output.append(".try_value_or_lazy_evaluated_optional")
                } else {
                    output.append(".value_or_lazy_evaluated_optional")
                }
            } else {
                if rhs_can_throw {
                    output.append(".try_value_or_lazy_evaluated")
                } else {
                    output.append(".value_or_lazy_evaluated")
                }
            }

            if rhs_can_throw {
                output.append("([&]() -> ErrorOr<")
                output.append(.codegen_type(rhs_type_id))
                output.append("> { return ")
            } else {
                output.append("([&] { return ")
            }


            .codegen_expression(rhs, &mut output)
            output.append("; })")

            if rhs_can_throw {
                output.append("))")
            }

            return
        }

        if op.op is NoneCoalescingAssign {
            mut lhs_builder = StringBuilder::create()
            mut rhs_builder = StringBuilder::create()
            .codegen_expression(lhs, output: &mut lhs_builder)
            .codegen_expression(rhs, output: &mut rhs_builder)
            let lhs_string = lhs_builder.to_string()
            let rhs_string = rhs_builder.to_string()
            let var = .fresh_var()
            output.appendff(
                "({{ auto&& {0} = {1}; if (!{0}.has_value()) {0} = {2}; }})"
                var
                lhs_string
                rhs_string
            )
            return
        }

        if op.op is ArithmeticRightShift {
            output.append("JaktInternal::arithmetic_shift_right(")
            .codegen_expression(lhs, &mut output)
            output.append(",")
            .codegen_expression(rhs, &mut output)
            output.append(")")
            return
        }

        if op.op is Assign and lhs is IndexedDictionary(expr, index) {
            .codegen_expression(expr, &mut output, syntactically_self_contained: true)
            output.append(".set(")
            .codegen_expression(index, &mut output)
            output.append(", ")
            .codegen_expression(rhs, &mut output)
            output.append(")")
            return
        }

        if .program.is_integer(type_id) {
            // Integer arithmetic is checked by default.
            match op.op {
                Add | Subtract | Multiply | Divide | Modulo => {
                    if .compiler.optimize {
                        if syntactically_self_contained { output.append('(') }
                        .codegen_unchecked_binary_op(lhs, rhs, op.op, type_id, &mut output)
                        if syntactically_self_contained { output.append(')') }
                    } else {
                        .codegen_checked_binary_op(lhs, rhs, op.op, type_id, &mut output)
                    }
                    return
                }
                AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign => {
                    if .compiler.optimize {
                        if syntactically_self_contained { output.append('(') }
                        .codegen_unchecked_binary_op_assignment(lhs, rhs, op.op, type_id, &mut output)
                        if syntactically_self_contained { output.append(')') }
                    } else {
                        .codegen_checked_binary_op_assignment(lhs, rhs, op.op, type_id, &mut output)
                    }
                }
                else => { }
            }
        }

        if syntactically_self_contained { output.append('(') }

        .codegen_expression(lhs, &mut output, syntactically_self_contained: true)
        output.append(match op.op {
            Add => " + "
            Subtract => " - "
            Multiply => " * "
            Modulo => " % "
            Divide => " / "
            Assign => " = "
            AddAssign => " += "
            SubtractAssign => " -= "
            MultiplyAssign => " *= "
            ModuloAssign => " %= "
            DivideAssign => " /= "
            BitwiseAndAssign => " &= "
            BitwiseOrAssign => " |= "
            BitwiseXorAssign => " ^= "
            BitwiseLeftShiftAssign => " <<= "
            BitwiseRightShiftAssign => " >>= "
            Equal => " == "
            NotEqual => " != "
            LessThan => " < "
            LessThanOrEqual => " <= "
            GreaterThan => " > "
            GreaterThanOrEqual => " >= "
            LogicalAnd => " && "
            LogicalOr => " || "
            BitwiseAnd => " & "
            BitwiseOr => " | "
            BitwiseXor => " ^ "
            ArithmeticLeftShift => " << "
            BitwiseLeftShift => " << "
            BitwiseRightShift => " >> "
            else => {
                todo(format("codegen_binary_expression {}", op))
            }
        })
        .codegen_expression(rhs, &mut output, syntactically_self_contained: true)

        if syntactically_self_contained { output.append(')') }
    }

    fn codegen_unchecked_binary_op(
        mut this
        lhs: CheckedExpression
        rhs: CheckedExpression
        anon op: BinaryOperator
        type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        output.append("static_cast<")
        output.append(.codegen_type(type_id))
        output.append(">(")
        .codegen_expression(lhs, &mut output)
        output.append(match op {
            Add => " + "
            Subtract => " - "
            Multiply => " * "
            Divide => " / "
            Modulo => " % "
            else => {
                panic(format("Checked binary operation codegen is not supported for BinaryOperator::{}", op))
            }
        })
        .codegen_expression(rhs, &mut output)
        output.append(")")
    }

    fn codegen_checked_binary_op(
        mut this
        lhs: CheckedExpression
        rhs: CheckedExpression
        anon op: BinaryOperator
        type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        output.append("JaktInternal::")

        output.append(match op {
            Add => "checked_add"
            Subtract => "checked_sub"
            Multiply => "checked_mul"
            Divide => "checked_div"
            Modulo => "checked_mod"
            else => {
                panic(format("Checked binary operation codegen is not supported for BinaryOperator::{}", op))
            }
        })

        output.append("<")
        output.append(.codegen_type(type_id))
        output.append(">(")
        .codegen_expression(lhs, &mut output)
        output.append(",")
        .codegen_expression(rhs, &mut output)
        output.append(")")
    }

    fn codegen_unchecked_binary_op_assignment(
        mut this
        lhs: CheckedExpression
        rhs: CheckedExpression
        anon op: BinaryOperator
        type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        output.append("{")
        output.append("auto& _jakt_ref = ")
        .codegen_expression(lhs, &mut output)
        output.append(";")
        output.append("_jakt_ref = static_cast<")
        output.append(.codegen_type(type_id))
        output.append(">(_jakt_ref ")
        output.append(match op {
            AddAssign => " + "
            SubtractAssign => " - "
            MultiplyAssign => " * "
            DivideAssign => " / "
            ModuloAssign => " % "
            else => {
                panic(format("Checked binary operation assignment codegen is not supported for BinaryOperator::{}", op))
            }
        })
        .codegen_expression(rhs, &mut output)
        output.append(");")
        output.append("}")
    }

    fn codegen_checked_binary_op_assignment(
        mut this
        lhs: CheckedExpression
        rhs: CheckedExpression
        anon op: BinaryOperator
        type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        output.append("{")
        output.append("auto& _jakt_ref = ")
        .codegen_expression(lhs, &mut output)
        output.append(";")
        output.append("_jakt_ref = JaktInternal::")
        output.append(match op {
            AddAssign => "checked_add"
            SubtractAssign => "checked_sub"
            MultiplyAssign => "checked_mul"
            DivideAssign => "checked_div"
            ModuloAssign => "checked_mod"
            else => {
                panic(format("Checked binary operation assignment codegen is not supported for BinaryOperator::{}", op))
            }
        })
        output.append("<")
        output.append(.codegen_type(type_id))
        output.append(">(_jakt_ref, ")
        .codegen_expression(rhs, &mut output)
        output.append(");")
        output.append("}")
    }

    fn codegen_method_call(
        mut this
        expr: CheckedExpression
        call: CheckedCall
        is_optional: bool
        output: &mut StringBuilder
        forward_error_with_try: bool = true
        syntactically_self_contained: bool
    ) throws {
        let error_handler = match call.callee_throws { true => .current_error_handler(forward_error_with_try), false => "" }
        if not error_handler.is_empty() {
            output.appendff("{}((", error_handler)
        }
        .codegen_method_call_unwrapped(expr, call, is_optional, output, syntactically_self_contained: syntactically_self_contained and error_handler.is_empty())
        if not error_handler.is_empty() {
            output.append("))")
        }
    }

    fn codegen_method_call_unwrapped(
        mut this
        expr: CheckedExpression
        call: CheckedCall
        is_optional: bool
        output: &mut StringBuilder
        syntactically_self_contained: bool
    ) throws {
        let generate_object = fn[this, &expr](output: &mut StringBuilder, syntactically_self_contained: bool) throws {
            .codegen_expression_and_deref_if_generic_and_needed(expr, output, syntactically_self_contained)
        }

        if call.function_id.has_value() and (call.force_inline is ForceInline) {
            let function = .program.get_function(call.function_id!)
            let is_mutable = expr.is_mutable(program: .program) and function.params.first()!.variable.is_mutable

            let reference_type = match is_mutable {
                true => Type::MutableReference(expr.type())
                false => Type::Reference(expr.type())
            }
            let var = CheckedVariable(
                name: "self"
                type_id: .program.find_or_add_type_id(
                    reference_type
                    module_id: expr.type().module
                )
                is_mutable
                definition_span: expr.span()
                type_span: None
                visibility: CheckedVisibility::Public
            )

            mut params: [CheckedParameter] = [
                CheckedParameter(
                    requires_label: false
                    variable: var
                    default_value_expression: None
                )
            ]
            for param in function.params[1..] {
                params.push(param)
            }

            if function.block.statements.is_empty() {
                eprintln("Shit, block is empty in function ({}): {}", call.function_id!, function)
                abort()
            }

            let lambda = CheckedExpression::Function(
                captures: [],
                params,
                can_throw: function.can_throw,
                return_type_id: function.return_type_id,
                block: function.block,
                span: expr.span(),
                type_id: unknown_type_id(),
                pseudo_function_id: call.function_id,
                scope_id: function.function_scope_id,
            )

            let old_this_replacement = .this_replacement
            .this_replacement = "self"

            .codegen_expression(lambda, &mut output)

            .this_replacement = old_this_replacement

            output.append("(")
            generate_object(output, syntactically_self_contained: false)
            for (_, arg) in call.args {
                output.append(",")
                .codegen_expression(arg, &mut output)
            }
            output.append(")")
            return
        }

        let expression_type = .program.get_type(expr.type())
        let name = call.name_for_codegen()

        let object_is_this = .expr_codegens_to_this_pointer(expr)

        let field_accessor = match name {
            Operator => ""
            else => match expression_type {
                RawPtr => "->"
                Struct(id) | GenericInstance(id) => match .program.get_struct(id).record_type is Class and not object_is_this {
                    true => "->"
                    false => "."
                }
                Enum(id) => match .program.get_enum(id).is_boxed and not object_is_this {
                    true => "->"
                    false => "."
                }
                else => match expression_type.is_builtin() and not expression_type is JaktString {
                    true => ""
                    false => "."
                }
            }
        }

        let generate_method_name = fn[this, &call, &name, &output]() throws {
            let generic_parameters = call.type_args
            if not generic_parameters.is_empty() {
                output.append("template ")
            }

            output.append(name.as_name_for_use())

            if not generic_parameters.is_empty() {
                mut types: [String] = []
                for gen_param in generic_parameters {
                    types.push(.codegen_type_possibly_as_namespace(type_id: gen_param, as_namespace: false))
                }
                output.appendff("<{}>", join(types, separator: ", "))
            }
        }

        let is_called_as_method = not name.is_prefix() and (not field_accessor.is_empty() or (not is_optional and name is Operator))

        let needs_wrapping_parens = syntactically_self_contained and name is Operator and not is_optional and not call.callee_throws

        if needs_wrapping_parens { output.append('(') }
        defer if needs_wrapping_parens { output.append(')') }

        if is_called_as_method {
            generate_object(output, syntactically_self_contained: true)
            output.append(field_accessor)
        } else {
            // object.method(...) -> method(object, ...)
            generate_method_name()
            output.append("(")
            generate_object(output, syntactically_self_contained: true)
        }

        if is_optional {
            // Note: `object' cannot be a builtin here as its type is Optional<T>.
            output.append("map([&](auto& _value) { return _value")
            mut access_operator = "."
            if expression_type is GenericInstance(args) and args.size() > 0 {
                match .program.get_type(args[0]) {
                    Struct(id) | GenericInstance(id) => {
                        if .program.get_struct(id).record_type is Class {
                            access_operator = "->"
                        }
                    }
                    else => {}
                }
            }
            output.append(access_operator)
        }

        if is_called_as_method {
            generate_method_name()
            if not name is Operator {
                output.append("(")
            }
        }

        mut first = is_called_as_method
        for (_, expr) in call.args {
            if first {
                first = false
            } else {
                output.append(",")
            }
            .codegen_expression(expr, &mut output, syntactically_self_contained: first and name is Operator)
        }

        if not name is Operator {
            output.append(')')
        }

        if is_optional {
            output.append("; })")
        }
    }

    fn codegen_call(mut this, call: CheckedCall, output: &mut StringBuilder, forward_error_with_try: bool = true) throws {
        let error_handler = match call.callee_throws { true => .current_error_handler(forward_error_with_try), false => "" }
        if not error_handler.is_empty() {
            output.appendff("{}((", error_handler)
        }
        .codegen_call_unwrapped(call, output)
        if not error_handler.is_empty() {
            output.append("))")
        }
    }

    fn codegen_call_unwrapped(mut this, call: CheckedCall, output: &mut StringBuilder) throws {
        if call.function_id.has_value() and .program.get_function(call.function_id!).is_comptime {
            output.appendff(
                "fail_comptime_call<{}, \"Comptime function {} called outside Jakt compiler\">()"
                .codegen_type(call.return_type)
                call.name
            )
            return
        }

        match call.name {
            "print" | "println" | "eprintln" | "eprint" | "format" => {
                let helper = match call.name {
                    "print" => "out"
                    "println" => "outln"
                    "eprint" => "warn"
                    "eprintln" => "warnln"
                    "format" => "__jakt_format"
                    else => ""
                }
                output.append(helper)
                output.append("(")
                for i in 0..call.args.size() {
                    let (_, expr) = call.args[i]
                    .codegen_expression(expr, &mut output)
                    if i != call.args.size() - 1 {
                        output.append(",")
                    }
                }
                output.append(")")
            }
            else => {
                mut close_enum_type_wrapper = false
                if call.function_id.has_value() {
                    let function_id = call.function_id!
                    let function = .program.get_function(function_id)
                    let type_module = .program.get_module(function_id.module)
                    .used_modules.add(function_id.module)

                    if function.type is ImplicitConstructor or function.type is ExternalClassConstructor {
                        let type_id = call.return_type
                        let type = .program.get_type(type_id)
                        output.append(.codegen_namespace_path(call))

                        match type {
                            Struct(struct_id) => {
                                let struct_ = .program.get_struct(struct_id)
                                if struct_.record_type is Class {
                                    output.append(call.name_for_codegen().as_name_for_use())
                                    output.append("::")
                                    output.append(struct_.create_function_name ?? "__jakt_create")
                                } else {
                                    output.append(call.name_for_codegen().as_name_for_use())
                                }
                            }
                            GenericInstance(id, args) => {
                                let struct_ = .program.get_struct(id)
                                if struct_.record_type is Class {
                                    output.append(struct_.name_for_codegen().as_name_for_use())
                                    output.append("<")
                                    mut first = true
                                    for arg in args {
                                        if not first {
                                            output.append(", ")
                                        } else {
                                            first = false
                                        }
                                        output.append(.codegen_type(arg))
                                    }
                                    output.append(">::")
                                    output.append(struct_.create_function_name ?? "__jakt_create")
                                } else {
                                    output.append(call.name_for_codegen().as_name_for_use())
                                    output.append("<")
                                    mut first = true
                                    for arg in args {
                                        if not first {
                                            output.append(", ")
                                        } else {
                                            first = false
                                        }
                                        output.append(.codegen_type(arg))
                                    }
                                    output.append(">")
                                }
                            }
                            else => {
                                panic("Should be unreachable")
                            }
                        }
                    } else if function.type is ImplicitEnumConstructor {
                        match .program.get_type(function.return_type_id) {
                            Enum(enum_id) => {
                                let enum_ = .program.get_enum(enum_id)
                                let enum_type_module = .program.get_module(enum_id.module)

                                output.append(.codegen_type_possibly_as_namespace(type_id: call.return_type, as_namespace: true))
                                output.append("::")
                                output.append(call.name_for_codegen().as_name_for_use())
                            }
                            GenericEnumInstance(id) => {
                                todo("codegen generic enum instance")
                            }
                            else => {
                                panic("constructor expected enum type")
                            }
                        }
                    } else {
                        output.append(.codegen_namespace_path(call))
                        output.append(call.name_for_codegen().as_name_for_use())
                    }
                } else {
                    output.append(.codegen_namespace_path(call))
                    output.append(call.name_for_codegen().as_name_for_use())
                }

                let generic_parameters = call.type_args

                if not generic_parameters.is_empty() {
                    mut types: [String] = []
                    for gen_param in generic_parameters {
                        types.push(.codegen_type_possibly_as_namespace(type_id: gen_param, as_namespace: false))
                    }
                    output.appendff("<{}>", join(types, separator: ", "))
                }

                mut arguments: [String] = []
                for arg in call.args {
                    mut builder = StringBuilder::create()
                    .codegen_expression(arg.1, output: &mut builder)
                    arguments.push(builder.to_string())
                }

                output.appendff("({})", join(arguments, separator: ","))
            }
        }
    }

    fn codegen_namespace_path(mut this, call: CheckedCall) throws -> String {
        if call.function_id.has_value() {
            let func = .program.get_function(call.function_id!)
            if func.owner_scope.has_value() {
                mut is_prelude = false
                let scope = .program.get_scope(func.owner_scope!)
                if scope.relevant_type_id.has_value() {
                    match .program.get_type(scope.relevant_type_id!) {
                        Struct(id) | GenericInstance(id) => {
                            is_prelude = .program.get_module(id.module).is_prelude()
                        }
                        Enum(id) | GenericEnumInstance(id) => {
                            is_prelude = .program.get_module(id.module).is_prelude()
                        }
                        else => {}
                    }
                }

                return .codegen_namespace_qualifier(
                    scope_id: func.owner_scope!
                    is_prelude
                    skip_current: false
                    possible_constructor_name: call.name_for_codegen().as_name_for_use()
                    generic_mappings: func.owner_scope_generics
                )
            }
        }

        mut output = ""
        mut index: usize = 0

        for namespace_ in call.namespace_ {
            // hack warning: this is to get around C++'s limitation that a constructor
            // can't be called like other static methods
            if index == call.namespace_.size() - 1 and namespace_.name == call.name_for_codegen().as_name_for_use() {
                break
            }

            output += namespace_.name_for_codegen().as_name_for_use()
            if namespace_.generic_parameters.has_value() {
                output += "<"
                mut i: usize = 0
                for param in namespace_.generic_parameters! {
                    output += .codegen_type(param)
                    if i != namespace_.generic_parameters!.size() - 1 {
                        output += ","
                    }
                    ++i
                }
                output += ">"
            }
            output += "::"

            ++index
        }
        return output
    }

    fn codegen_block(mut this, block: CheckedBlock, output: &mut StringBuilder) throws {
        output.append("{\n")

        for statement in block.statements {
            .codegen_statement(statement, &mut output)
        }

        output.append("}\n")
    }

    fn codegen_statement(
        mut this
        statement: CheckedStatement
        output: &mut StringBuilder
    ) throws {
        mut add_newline = true
        if .debug_info.statement_span_comments and statement.span().has_value() and add_newline {
            output.appendff("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
        }

        match statement {
            Throw(expr) => {
                output.append("return ")
                .codegen_expression(expr, &mut output)
                output.append(";")
            }
            Continue => {
                output.append(match .control_flow_state.directly_inside_match {
                    true => "return JaktInternal::LoopContinue{};"
                    false => "continue;"
                })
            }
            Break => {
                output.append(match .control_flow_state.directly_inside_match {
                    true => "return JaktInternal::LoopBreak{};"
                    false => "break;"
                })
            }
            Expression(expr) => {
                .codegen_expression(expr, &mut output)
                output.append(";")
            }
            Defer(statement) => {
                output.append("ScopeGuard ")
                output.append(.fresh_var())
                output.append("([&] {\n")
                let last_control_flow = .control_flow_state
                let old_inside_defer = .inside_defer

                .control_flow_state.directly_inside_match = false
                .control_flow_state.indirectly_inside_match = false
                .inside_defer = true

                .codegen_statement(statement, &mut output)
                output.append("});")

                .control_flow_state = last_control_flow
                .inside_defer = old_inside_defer
            }
            Return(val) => match val.has_value() {
                true => match .current_function!.can_throw {
                    true => {
                        let type = .program.get_type(val!.type())
                        mut result = ""
                        if type is Void or type is Never {
                            .codegen_expression(val!, &mut output)
                            output.append("; return {}")
                        } else {
                            // Disable forwarding with TRY because we're returning an ErrorOr<Ret> too!
                            output.append("return ")
                            .codegen_expression(val!, &mut output, forward_error_with_try: false)
                        }

                        output.append(";")
                    }
                    false => {
                        output.append("return ")
                        .codegen_expression(val!, &mut output)
                        output.append(";")
                    }
                }
                false => {
                    output.append(match .current_function!.can_throw or .control_flow_state.indirectly_inside_match {
                        true => "return {};"
                        false => "return;"
                    })
                }
            }
            Loop(block) => {
                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output.appendff("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output.append("for (;;)")
                add_newline = false
                let last_control_flow = .control_flow_state
                .control_flow_state = last_control_flow.enter_loop()
                .codegen_block(block, &mut output)
                .control_flow_state = last_control_flow
            }
            While(condition, block) => {
                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output.appendff("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output.append("while (")
                .codegen_expression(expression: condition, &mut output)
                output.append(")")

                {
                    let last_control_flow = .control_flow_state
                    .control_flow_state = last_control_flow.enter_loop()
                    .codegen_block(block, &mut output)
                    .control_flow_state = last_control_flow
                }
                add_newline = false
            }
            Block(block) => {
                .codegen_block(block, &mut output)
            }
            Garbage => {
                panic("Garbage statement in codegen")
            }
            DestructuringAssignment(vars, var_decl) => {
                .codegen_statement(statement: var_decl, &mut output)

                for v in vars {
                    .codegen_statement(statement: v, &mut output)
                }
            }
            VarDecl(var_id, init) => {
                let var = .program.get_variable(var_id)
                let var_type = .program.get_type(var.type_id)
                output.append(.codegen_type(var.type_id))
                output.append(" ")
                if not var.is_mutable and not (var_type is Reference or var_type is MutableReference) {
                    output.append("const ")
                }
                output.append(var.name_for_codegen().as_name_for_use())
                output.append(" = ")
                .codegen_expression(init, &mut output)
                output.append(";")
            }
            InlineCpp(lines) => {
                for line in lines {
                    mut escaped_line = line
                    escaped_line = escaped_line.replace(replace: "\\\"", with: "\"")
                    escaped_line = escaped_line.replace(replace: "\\\\", with: "\\")
                    output.append(escaped_line)
                }
            }
            If(condition, then_block, else_statement) => {
                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output.appendff("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output.append("if (")
                .codegen_expression(condition, &mut output)
                output.append(")")

                .codegen_block(block: then_block, &mut output)

                if else_statement.has_value() {
                    output.append("else ")
                    .codegen_statement(statement: else_statement!, &mut output)
                }

                add_newline = false
            }
            Yield(expr, span) => {
                let is_void = expr.has_value() and expr!.type() == void_type_id()
                match .yield_method! {
                    ReturnExplicitValue(ctor) => {
                        if is_void {
                            .codegen_statement(statement: CheckedStatement::Expression(expr: expr!, span), &mut output)
                        }
                        output.append("return ")
                        output.append(ctor)
                        output.append('(')
                        if not is_void and expr is Some(value) {
                            .codegen_expression(value, &mut output)
                        }
                        output.append(");")
                    }
                    AssignAndGoto(name, label) => {
                        if not is_void and expr.has_value() {
                            output.append(name)
                            output.append(" = ")
                            .codegen_expression(expr!, &mut output)
                            output.append("; ")
                        }
                        output.append("goto ")
                        output.append(label)
                        output.append(";\n")
                    }
                }
            }
        }

        if add_newline {
            output.append("\n")
        }
    }


    fn codegen_type(mut this, anon type_id: TypeId) throws -> String {
        return .codegen_type_possibly_as_namespace(type_id, as_namespace: false)
    }

    fn codegen_type_possibly_as_namespace(mut this, type_id: TypeId, as_namespace: bool) throws -> String {

        // Since we're using this type, ensure its module header is included to
        // obtain the definition.
        .used_modules.add(type_id.module)

        mut qualifiers = ""

        if not as_namespace and .program.get_type(type_id).qualifiers.is_immutable {
            qualifiers += " const"
        }

        if .generic_inferences is Some(mappings) {
            if mappings.get(type_id) is Some(id) {
                return .codegen_type_possibly_as_namespace(type_id: id, as_namespace) + qualifiers
            }
        }

        return match .program.get_type(type_id) {
            Void => "void"
            Bool => "bool"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            F32 => "f32"
            F64 => "f64"
            Usize => "size_t"
            JaktString => "ByteString"
            CChar => "char"
            CInt => "int"
            Never => "void"
            Const(value) => {
                mut interpreter = Interpreter::create(
                    compiler: .compiler
                    program: .program
                    typecheck_functions: TypecheckFunctions(
                        block: fn(
                            parsed_block: ParsedBlock
                            parent_scope_id: ScopeId
                            safety_mode: SafetyMode
                            yield_type_hint: TypeId?
                            containing_function_id: FunctionId? = None
                        ) throws -> CheckedBlock {
                            panic("Cannot typecheck a const block")
                        }

                        register_function: fn(
                            function: CheckedFunction
                        ) throws -> FunctionId {
                            panic("Cannot typecheck a const function")
                        }
                    )
                    spans: []
                )
                let expr = value_to_checked_expression(value, interpreter)
                mut builder = StringBuilder::create()
                .codegen_expression(expr, output: &mut builder)
                yield builder.to_string()
            }
            RawPtr(type_id) => match .program.get_type(type_id).is_boxed(program: .program) {
                true => .codegen_type_possibly_as_namespace(type_id, as_namespace: true) + "*"
                false => .codegen_type(type_id) + "*"
            }
            Reference(type_id) => match .program.get_type(type_id).qualifiers.is_immutable {
                // Inner type is const, no need to add const to the reference
                true => .codegen_type(type_id) + "&"
                false => .codegen_type(type_id) + " const&"
            }
            MutableReference(type_id) => .codegen_type(type_id) + "&"
            GenericInstance(id, args) => .codegen_generic_type_instance(id, args, as_namespace)
            Struct(id) => {
                let implements_type = .program.get_struct(id).implements_type
                yield match implements_type.has_value() {
                    true => .codegen_type_possibly_as_namespace(type_id: implements_type!, as_namespace)
                    false => .codegen_struct_type(id, as_namespace)
                }
            }
            Enum(id) => .codegen_enum_type(id, as_namespace)
            GenericEnumInstance(id, args) => {
                mut builder = StringBuilder::create()
                .codegen_generic_enum_instance(id, args, as_namespace, output: &mut builder)
                yield builder.to_string()
            }
            TypeVariable(name) => name
            Function(params, can_throw, return_type_id) => {
                mut builder = StringBuilder::create()
                builder.append("Function<")
                if can_throw {
                    builder.append("ErrorOr<")
                }
                builder.append(.codegen_type(return_type_id))
                if can_throw {
                    builder.append(">")
                }
                builder.append("(")
                mut first = true
                for param in params {
                    if first {
                        first = false
                    } else {
                        builder.append(", ")
                    }
                    builder.append(.codegen_type(param))
                }
                builder.append(")>")
                yield builder.to_string()
            }
            GenericTraitInstance => {
                panic("Generic trait instance in codegen")
            }
            else => {
                // The RBC uses 'auto' here but we probably want to improve in the future
                yield "auto"
            }
        } + qualifiers
    }

    fn codegen_generic_type_instance(mut this, id: StructId, args: [TypeId], as_namespace: bool) throws -> String {
        mut output = ""
        let type_module = .program.get_module(id.module)

        mut namespace_ = ""
        // For prelude generic instances prefix with "JaktInternal::" so that there aren't naming clashes
        if type_module.is_prelude() {
            namespace_ += "JaktInternal::"
        }

        let inner_weak_ptr_struct_id = .program.check_and_extract_weak_ptr(struct_id: id, args)

        if inner_weak_ptr_struct_id.has_value() {
            output += "WeakPtr<"
            output += namespace_

            let inner_struct_id = inner_weak_ptr_struct_id.value()
            let struct_ = .program.get_struct(inner_struct_id)
            output += .codegen_namespace_qualifier(scope_id: struct_.scope_id, is_prelude: type_module.is_prelude())
            output += struct_.name_for_codegen().as_name_for_use()

            output += ">"
        } else {
            let struct_ = .program.get_struct(id)

            let acquired_by_ref = not as_namespace and struct_.record_type is Class
            if acquired_by_ref {
                output += "NonnullRefPtr<"
            }
            output += namespace_
            output += .codegen_namespace_qualifier(scope_id: struct_.scope_id, is_prelude: type_module.is_prelude())
            output += struct_.name_for_codegen().as_name_for_use()
            output += "<"
            mut first = true
            for type_id in args {
                if not first {
                    output += ","
                } else {
                    first = false
                }
                output += .codegen_type(type_id)
            }
            output += ">"
            if acquired_by_ref {
                output += ">"
            }
        }

        return output
    }

    fn codegen_generic_enum_instance(
        mut this
        id: EnumId
        args: [TypeId]
        as_namespace: bool
        output: &mut StringBuilder
    ) throws {
        mut close_tag = false
        let enum_ = .program.get_enum(id)
        if not as_namespace and enum_.is_boxed {
            output.append("NonnullRefPtr<")
            let qualifier = .codegen_namespace_qualifier(scope_id: enum_.scope_id, is_prelude: .program.get_module(id.module).is_prelude())

            if not qualifier.is_empty() {
                output.append("typename ")
                output.append(qualifier)
            }
            output.append(enum_.name)
            close_tag = true
        } else {
            let qualifier = .codegen_namespace_qualifier(scope_id: enum_.scope_id, is_prelude: .program.get_module(id.module).is_prelude())

            if not qualifier.is_empty() {
                if not as_namespace {
                    output.append("typename ")
                }
                output.append(qualifier)
            }
            output.append(enum_.name)
        }
        output.append("<")
        mut first = true
        for type_id in args {
            if not first {
                output.append(", ")
            } else {
                first = false
            }

            output.append(.codegen_type(type_id))
        }
        output.append(">")
        if close_tag {
            output.append(">")
        }
    }

    fn codegen_namespace_qualifier(
        mut this
        scope_id: ScopeId
        is_prelude: bool
        skip_current: bool = true
        possible_constructor_name: String? = None
        generic_mappings: [TypeId:TypeId]? = None
    ) throws -> String {
        mut output = ""
        mut current_scope_id = match skip_current {
            true => .program.get_scope(scope_id).parent
            false => scope_id
        }

        mut is_extern_import = false

        mut first = true
        while current_scope_id.has_value() {
            let scope = .program.get_scope(current_scope_id!)
            let name = scope.namespace_name_for_codegen()?.as_name_for_use()
            let is_constructor_call = first and possible_constructor_name == name
            is_extern_import = is_extern_import or scope.import_path_if_extern.has_value()

            defer {
                if name.has_value() {
                    first = false
                }
                current_scope_id = scope.parent
            }

            if name.has_value() {
                if is_constructor_call {
                    // Don't include the constructor name in the namespace qualifier
                    continue
                }

                let args = match scope.relevant_type_id.has_value() {
                    false => ""
                    true => {
                        .used_modules.add(scope.relevant_type_id!.module)
                        let parameters = .program.get_type(scope.relevant_type_id!).generic_parameters(program: .program)
                        mut builder = StringBuilder::create()

                        if parameters is Some(params) and generic_mappings is Some(mappings) and not params.is_empty() {
                            builder.append("<")
                            mut first = true
                            for parameter in params {
                                let mapping = mappings.get(parameter.type_id)!
                                if .program.get_type(mapping) is TypeVariable and .map_type(mapping) == mapping {
                                    // We couldn't builderolve this somehow, so just...bail.
                                    // FIXME: We should make sure this can't happen?
                                    //        Or at least error out when it does.
                                    break
                                }

                                if first {
                                    first = false
                                } else {
                                    builder.append(", ")
                                }

                                builder.append(.codegen_type(mapping))
                            }
                            builder.append(">")
                        }

                        yield builder.to_string()
                    }
                }
                output = format("{}{}::{}", name!, args, output)
            }
        }
        if is_extern_import or is_prelude {
            return output
        } else {
            return format("Jakt::{}", output)
        }
    }

    fn map_type(this, anon type_id: TypeId) -> TypeId {
        if .generic_inferences is Some(mapping) {
            return mapping.get(type_id) ?? type_id
        }
        return type_id
    }

    fn codegen_function(
        mut this
        anon function: CheckedFunction
        as_method: bool = false
        output: &mut StringBuilder
    ) throws {
        if function.is_comptime {
            return
        }

        .codegen_function_in_namespace(function, containing_struct: None, as_method, &mut output)
    }

    fn codegen_struct_type(mut this, id: StructId, as_namespace: bool) throws -> String {
        mut output = StringBuilder::create()
        let type_module = .program.get_module(id.module)
        let checked_struct = .program.get_struct(id)

        if not as_namespace and checked_struct.record_type is Class {
            output.append("NonnullRefPtr<")
            output.append(.codegen_namespace_qualifier(scope_id: checked_struct.scope_id, is_prelude: type_module.is_prelude()))
            output.append(checked_struct.name_for_codegen().as_name_for_use())
            output.append(">")
        } else {
            output.append(.codegen_namespace_qualifier(scope_id: checked_struct.scope_id, is_prelude: type_module.is_prelude()))
            output.append(checked_struct.name_for_codegen().as_name_for_use())
        }

        return output.to_string()
    }

    fn codegen_enum_type(mut this, id: EnumId, as_namespace: bool) throws -> String {
        mut output = StringBuilder::create()
        let type_module = .program.get_module(id.module)
        let checked_enum = .program.get_enum(id)

        if not as_namespace and checked_enum.is_boxed {
            output.append("NonnullRefPtr<")
            let qualifier = .codegen_namespace_qualifier(scope_id: checked_enum.scope_id, is_prelude: type_module.is_prelude())
            if not qualifier.is_empty() {
                output.append("typename ")
                output.append(qualifier)
            }
            output.append(checked_enum.name)
            output.append(">")
        } else {
            let qualifier = .codegen_namespace_qualifier(scope_id: checked_enum.scope_id, is_prelude: type_module.is_prelude())
            if not qualifier.is_empty() {
                output.append(qualifier)
            }
            output.append(checked_enum.name)
        }

        return output.to_string()
    }

    fn codegen_destructor_predecl(mut this, anon struct_: &CheckedStruct) throws -> String {
        mut output = StringBuilder::create()
        output.append("public:\n")
        output.append("    ~")
        output.append(struct_.name_for_codegen().as_name_for_definition())
        output.append("();\n")
        return output.to_string()
    }

    fn codegen_destructor(
        mut this
        anon struct_: &CheckedStruct
        anon function: &CheckedFunction
        is_inline: bool
        output: &mut StringBuilder
    ) throws {
        let qualified_name = .codegen_type_possibly_as_namespace(type_id: struct_.type_id, as_namespace: true)

        if not is_inline and not struct_.generic_parameters.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(struct_.generic_parameters, &mut output)
            output.append(">\n")
        }

        if is_inline {
            output.appendff("~{}()", struct_.name_for_codegen().as_name_for_definition())
        } else {
            output.appendff("{}::~{}()", qualified_name, struct_.name_for_codegen().as_name_for_definition())
        }

        .codegen_block(block: function.block, &mut output)
    }

    fn codegen_constructor_predecl(
        mut this
        anon function: CheckedFunction
        output: &mut StringBuilder
    ) throws {
        let type_id = function.return_type_id
        let type_ = .program.get_type(type_id)

        guard type_ is Struct(struct_id) else {
            panic("internal error: call to a constructor, but not a struct/class type")
        }

        let structure = .program.get_struct(struct_id)

        if structure.record_type is Class {
            output.append("protected:\n")

            output.appendff("explicit {}(", function.name_for_codegen().as_name_for_definition())
            mut first = true
            for param in function.params {
                if not first {
                    output.append(", ")
                } else {
                    first = false
                }

                let param_type_id = param.variable.type_id
                output.append(.codegen_type(param_type_id))
                output.append(" a_")
                output.append(param.variable.name_for_codegen().as_name_for_definition())
            }
            output.append(");\n")

            mut class_name_with_generics = ""
            class_name_with_generics += structure.name_for_codegen().as_name_for_definition()

            first = true
            for generic_parameter in structure.generic_parameters {
                if not first {
                    class_name_with_generics += ", "
                } else {
                    class_name_with_generics += "<"
                    first = false
                }

                class_name_with_generics += .codegen_type(generic_parameter.type_id)
            }
            if not structure.generic_parameters.is_empty() {
                class_name_with_generics += ">"
            }

            output.append("public:\n")
            output.appendff("static NonnullRefPtr<{}> {}", class_name_with_generics, structure.create_function_name ?? "__jakt_create")
            output.append("(")

            first = true
            for param in function.params {
                if not first {
                    output.append(", ")
                } else {
                    first = false
                }

                output.append(.codegen_type(param.variable.type_id))
                output.append(" ")
                output.append(param.variable.name_for_codegen().as_name_for_definition())
            }

            output.append(");\n")
            return
        }

        output.append(function.name_for_codegen().as_name_for_definition())
        output.append("(")

        mut first = true
        for param in function.params {
            if not first {
                output.append(", ")
            } else {
                first = false
            }

            output.append(.codegen_type(param.variable.type_id))
            output.append(" a_")
            output.append(param.variable.name_for_codegen().as_name_for_definition())
        }
        output.append(");\n")
    }

    fn codegen_constructor(
        mut this
        anon function: CheckedFunction
        is_inline: bool = false
        output: &mut StringBuilder
    ) throws {
        let type_id = function.return_type_id
        let type_ = .program.get_type(type_id)

        guard type_ is Struct(struct_id) else {
            panic("internal error: call to a constructor, but not a struct/class type")
        }

        let structure = .program.get_struct(struct_id)
        let qualified_name = .codegen_type_possibly_as_namespace(type_id, as_namespace: true)

        if not is_inline and not structure.generic_parameters.is_empty() {
            output.append("template <")
            .codegen_template_parameter_names(structure.generic_parameters, &mut output)
            output.append(">\n")
        }


        if structure.record_type is Class or structure.record_type is Struct {
            if is_inline {
                output.append(function.name_for_codegen().as_name_for_definition())
                output.append("(")
            } else {
                output.appendff("{}::{}(", qualified_name, function.name_for_codegen().as_name_for_definition())
            }

            mut first = true
            for param in function.params {
                if not first {
                    output.append(", ")
                } else {
                    first = false
                }

                let param_type_id = param.variable.type_id
                output.append(.codegen_type(param_type_id))
                output.append(" a_")
                output.append(param.variable.name_for_codegen().as_name_for_definition())
            }
            output.append(")")

            if not function.params.is_empty() {
                output.append(": ")

                mut initializers: [String] = []

                let parent_constructor_parameter_count = function.params.size() - structure.fields.size()
                if parent_constructor_parameter_count > 0 {
                    mut parent_initializer = ""
                    parent_initializer += .program.get_struct(structure.super_struct_id!).name_for_codegen().as_name_for_definition()
                    parent_initializer += "("

                    mut strings: [String] = []
                    for param in function.params[0..parent_constructor_parameter_count] {
                        strings.push("move(a_" + param.variable.name_for_codegen().as_name_for_use() + ")")
                    }
                    parent_initializer += join(strings, separator: ", ")

                    parent_initializer += ")"
                    initializers.push(parent_initializer)
                }

                for i in parent_constructor_parameter_count..function.params.size() {
                    let param = function.params[i]
                    initializers.push(param.variable.name_for_codegen().as_name_for_use() + "(move(a_" + param.variable.name_for_codegen().as_name_for_use() + "))")
                }
                output.append(join(initializers, separator: ", "))
            }

            output.append("{}\n")

            if structure.record_type is Class {

                mut class_name_with_generics = ""
                class_name_with_generics += structure.name_for_codegen().as_name_for_definition()

                first = true
                for generic_parameter in structure.generic_parameters {
                    if not first {
                        class_name_with_generics += ", "
                    } else {
                        class_name_with_generics += "<"
                        first = false
                    }

                    class_name_with_generics += .codegen_type(generic_parameter.type_id)
                }
                if not structure.generic_parameters.is_empty() {
                    class_name_with_generics += ">"
                }

                if is_inline {
                    output.append("static ")
                }

                let qualified_namespace = match is_inline {
                    true => ""
                    false => qualified_name + "::"
                }
                output.appendff("NonnullRefPtr<{}> {}{}", class_name_with_generics, qualified_namespace, structure.create_function_name ?? "__jakt_create")
                output.append("(")

                first = true
                for param in function.params {
                    if not first {
                        output.append(", ")
                    } else {
                        first = false
                    }

                    output.append(.codegen_type(param.variable.type_id))
                    output.append(" ")
                    output.append(param.variable.name_for_codegen().as_name_for_definition())
                }

                output.appendff(") {{ auto o = adopt_ref(*new {} (", class_name_with_generics)

                first = true
                for param in function.params {
                    if not first {
                        output.append(", ")
                    } else {
                        first = false
                    }

                    output.append("move(")
                    output.append(param.variable.name_for_codegen().as_name_for_use())
                    output.append(")")
                }

                output.append(")); return o; }")
            }

            return
        }

        if not is_inline {
            output.append(qualified_name)
            output.append("::")
        }
        output.append(function.name_for_codegen().as_name_for_definition())
        output.append("(")

        mut first = true
        for param in function.params {
            if not first {
                output.append(", ")
            } else {
                first = false
            }

            output.append(.codegen_type(param.variable.type_id))
            output.append(" a_")
            output.append(param.variable.name_for_codegen().as_name_for_definition())
        }
        output.append(") ")

        if not function.params.is_empty() {
            output.append(":")
        }

        first = true
        for param in function.params {
            if not first {
                output.append(", ")
            } else {
                first = false
            }

            output.append(param.variable.name_for_codegen().as_name_for_use())
            output.append("(move(a_")
            output.append(param.variable.name_for_codegen().as_name_for_use())
            output.append("))")
        }

        output.append("{}\n")
    }

    fn codegen_function_in_namespace(
        mut this
        function: CheckedFunction
        containing_struct: TypeId?
        as_method: bool = false
        skip_template: bool = false
        explicit_generic_instantiation: [TypeId]? = None
        output: &mut StringBuilder
    ) throws {
        // No need to generate code for external functions
        if function.linkage is External {
            return
        }

        if function.force_inline is ForceInline {
            return
        }

        if not skip_template {
            .codegen_function_generic_parameters(function, &mut output)
        }

        let is_main = function.name_for_codegen().as_name_for_use() == "main" and not containing_struct.has_value()

        if function.force_inline is MakeDefinitionAvailable {
            output.append("__attribute__((always_inline)) inline ")
        }

        if function.return_type_id == never_type_id() {
            output.append("[[noreturn]] ")
        }
        if is_main {
            output.append("ErrorOr<int>")
        } else {
            if as_method and function.is_static() {
                output.append("static ")
            }
            if not function.type is Destructor and not function.type is Constructor {
                output.append(match function.can_throw {
                    true => format("ErrorOr<{}>", .codegen_type(function.return_type_id))
                    false => .codegen_type(function.return_type_id)
                })
            }
        }

        output.append(" ")

        if is_main {
            output.append("main")
        } else {
            let qualifier = match containing_struct.has_value() {
                true => .codegen_type_possibly_as_namespace(type_id: containing_struct!, as_namespace: true)
                false => ""
            }
            if not qualifier.is_empty() {
                output.append(qualifier)
                output.append("::")
            }
            if function.type is Destructor {
                guard .program.get_type(containing_struct!) is Struct(struct_id) else {
                    panic("Destructor doesn't have a containing struct")
                }
                output.append("~" + .program.get_struct(struct_id).name_for_codegen().as_name_for_definition())
            } else {
                output.append(function.name_for_codegen().as_name_for_definition())
            }
        }

        if explicit_generic_instantiation.has_value() {
            output.append("<")
            mut first = true
            for type in explicit_generic_instantiation! {
                if not first {
                    output.append(", ")
                } else {
                    first = false
                }
                output.append(.codegen_type(type))
            }
            output.append(">")
        }

        output.append("(")

        if is_main and function.params.is_empty() {
            output.append("DynamicArray<ByteString>")
        }

        mut first = true
        for param in function.params {
            let variable = param.variable
            if variable.name == "this" {
                continue
            }
            if not first {
                output.append(",")
            } else {
                first = false
            }
            let variable_type = .program.get_type(variable.type_id)
            output.append(.codegen_type(variable.type_id))
            output.append(" ")
            if not variable.is_mutable and not (variable_type is Reference or variable_type is MutableReference) {
                output.append("const ")
            }
            output.append(variable.name_for_codegen().as_name_for_definition())
        }

        output.append(")")

        if not function.is_static() and not function.is_mutating() {
            output.append(" const")
        }

        if function.is_raw_constructor {
            // Raw ctor, generate member initializer list before the function body
            output.append(" : ")
            mut first = true
            // if this flag is set, `containing_struct` is guaranteed to be available.
            let struct_ = match .program.get_type(containing_struct!) {
                Struct(id) => .program.get_struct(id)
                else => {
                    .compiler.panic("Expected a struct")
                }
            }

            if struct_.super_struct_id.has_value() {
                let super_struct = .program.get_struct(struct_.super_struct_id!)
                output.append(super_struct.name_for_codegen().as_name_for_use())
                output.append("()")
                first = false
            }

            for field in struct_.fields {
                if not first {
                    output.append(",\n")
                } else {
                    first = false
                }
                let var = .program.get_variable(field.variable_id)
                output.append(var.name_for_codegen().as_name_for_use())
                output.append("(")
                .codegen_expression(field.default_value_in_definition_scope!, &mut output, forward_error_with_try: false)
                output.append(")")
            }
        }

        output.append(" {\n")
        if is_main {
            output.append("\n
            #ifdef _WIN32
            #ifndef CP_UTF8
            static constexpr unsigned int CP_UTF8 = 65001;
            #endif
            SetConsoleOutputCP(CP_UTF8);
            // Enable buffering to prevent VS from chopping up UTF-8 byte sequences
            setvbuf(stdout, nullptr, _IOFBF, 1000);
            #endif\n")
        }
        // FIXME: Panic if function type is unknown, and this isn't `main()`

        let last_control_flow = .control_flow_state
        .control_flow_state = last_control_flow.enter_function()
        .codegen_block(block: function.block, &mut output)
        .control_flow_state = last_control_flow

        if is_main {
            output.append("return 0;\n")
        } else {
            if function.can_throw and function.return_type_id == builtin(BuiltinType::Void) {
                output.append("return {};\n")
            }
        }

        output.append("}\n")
    }

    fn codegen_lambda_block(
        mut this
        can_throw: bool
        block: CheckedBlock
        return_type_id: TypeId
        output: &mut StringBuilder
    ) throws {
        output.append("{")
        .codegen_block(block, &mut output)

        if can_throw and return_type_id == builtin(BuiltinType::Void) {
            output.append("return {};\n")
        }

        output.append("}\n")
    }
}
