// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause

import parser { BinaryOperator, FunctionLinkage }
import typechecker {
    BuiltinType, CheckedBlock, CheckedCall, CheckedExpression,
    CheckedFunction, CheckedProgram, CheckedStatement, CheckedStruct,
    Module, ModuleId, Scope, ScopeId, StructId, EnumId, Type, TypeId,
    CheckedEnum, unknown_type_id, CheckedMatchCase, FunctionId, CheckedMatchBody, void_type_id, never_type_id, builtin,
    CheckedVariable, VarId }
import utility { panic, todo, join, prepend_to_each, Span }
import compiler { Compiler }

enum AllowedControlExits {
    /// No control exit statements allowed
    Nothing
    /// Only `return` allowed
    JustReturn
    /// `continue`/`break` allowed: `return` is also allowed in this context
    AtLoop

    function allow_return(this) => match this {
        Nothing | JustReturn => AllowedControlExits::JustReturn
        AtLoop => AllowedControlExits::AtLoop
    }
}

function are_loop_exits_allowed(anon allowed_control_exits: AllowedControlExits) -> bool => allowed_control_exits is AtLoop
function is_return_allowed(anon allowed_control_exits: AllowedControlExits) -> bool => not allowed_control_exits is Nothing

struct ControlFlowState {
    allowed_exits: AllowedControlExits
    /// Whether `break` and `continue` should use `return ExplicitValueOrControlFlow` instead of
    /// C++'s `break`/`continue`.
    passes_through_match: bool
    passes_through_try: bool
    match_nest_level: usize

    function no_control_flow() -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::Nothing
            passes_through_match: false
            passes_through_try: false
            match_nest_level: 0
        )
    }
    function enter_function(this) -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::JustReturn
            passes_through_match: false
            passes_through_try: false
            match_nest_level: .match_nest_level
        )
    }
    function enter_loop(this) -> ControlFlowState {
        return ControlFlowState(
            allowed_exits: AllowedControlExits::AtLoop
            passes_through_match: false
            passes_through_try: .passes_through_try
            match_nest_level: 0
        )
    }
    function enter_match(this) -> ControlFlowState {
        mut level = .match_nest_level
        if .passes_through_match {
            level = .match_nest_level + 1
        }
        return ControlFlowState(
            allowed_exits: .allowed_exits.allow_return()
            passes_through_match: true
            passes_through_try: .passes_through_try
            match_nest_level: level
        )
    }
    function is_match_nested(this) => .match_nest_level != 0
    function choose_control_flow_macro(this) -> String {
        if are_loop_exits_allowed(.allowed_exits) {
            if .is_match_nested() {
                return "JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP_NESTED_MATCH"
            }
            return "JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_AT_LOOP"
        }
        return "JAKT_RESOLVE_EXPLICIT_VALUE_OR_CONTROL_FLOW_RETURN_ONLY"
    }
}

struct LineSpan {
    start: usize
    end: usize
}

struct CodegenDebugInfo {
    // FIXME: Add support for multiple source files
    compiler: Compiler
    line_spans: [usize: [LineSpan]]
    statement_span_comments: bool

    function span_to_source_location(mut this, anon span: Span) throws -> String {
        if .line_spans.is_empty() {
            .gather_line_spans()
        }

        let file_idx = span.file_id.id

        if not .line_spans.contains(file_idx) {
            return ""
        }

        mut line_index = 0uz
        while line_index < .line_spans[file_idx].size() {
            if span.start >= .line_spans[file_idx][line_index].start and span.start <= .line_spans[file_idx][line_index].end {
                let column_index = span.start - .line_spans[file_idx][line_index].start
                return format("{} \"{}\"", line_index+1, .compiler.get_file_path(span.file_id)!.to_string())
            }
            line_index += 1
        }

        panic("Reached end of file and could not find index")
    }

    function gather_line_spans(mut this) throws {
        for file in .compiler.file_ids.iterator() {

            if file.0 == "__prelude__" {
                continue
            }

            .compiler.set_current_file(file.1)

            let file_idx = file.1.id

            // FIXME: remove when we can infer the type
            let empty_array: [LineSpan] = []
            .line_spans.set(file_idx, empty_array)

            mut idx = 0uz
            mut start = idx
            while idx < .compiler.current_file_contents.size() {
                if .compiler.current_file_contents[idx] == b'\n' {
                    .line_spans[file_idx].push(LineSpan(start, end: idx))
                    start = idx + 1
                }
                idx += 1
            }
            if start < idx {
                .line_spans[file_idx].push(LineSpan(start, end: idx))
            }
        }
    }
}

struct CodeGenerator {

    compiler: Compiler
    program: CheckedProgram

    control_flow_state: ControlFlowState
    entered_yieldable_blocks: [(String, String)] // label, variable name
    deferred_output: String
    current_function: CheckedFunction?
    inside_defer: bool
    debug_info: CodegenDebugInfo
    namespace_stack: [String]
    fresh_var_counter: usize
    fresh_label_counter: usize

    // noreturn functions may not throw, so let them crash instead.
    function current_error_handler(this) throws -> String {
        if .inside_defer or (.current_function.has_value() and .current_function!.return_type_id.equals(never_type_id()) and not .control_flow_state.passes_through_try) {
            return "MUST"
        }

        return "TRY"
    }

    function fresh_var(mut this) throws => format("__jakt_var_{}", .fresh_var_counter++)

    function fresh_label(mut this) throws => format("__jakt_label_{}", .fresh_label_counter++)

    function topologically_sort_modules(this) throws -> [ModuleId] {
        mut in_degrees: [usize:i64] = [:]

        for module in .program.modules.iterator() {
            for imported_module in module.imports.iterator() {
                let existing = in_degrees.get(imported_module.id) ?? 0
                in_degrees.set(imported_module.id, existing + 1)
            }

            if not in_degrees.contains(module.id.id) {
                in_degrees.set(module.id.id, 0)
            }
        }

        mut stack: [ModuleId] = []
        for module in .program.modules.iterator() {
            if in_degrees[module.id.id] == 0 {
                stack.push(module.id)
            }
        }

        mut sorted_modules: [ModuleId] = []
        while not stack.is_empty() {
            let id = stack.pop()!
            sorted_modules.push(id)
            for imported_module in .program.modules[id.id].imports.iterator() {
                let module_in_degrees = in_degrees[imported_module.id]
                in_degrees.set(imported_module.id, module_in_degrees - 1)
                if module_in_degrees == 1 {
                    stack.push(ModuleId(id: imported_module.id))
                }
            }
        }

        if sorted_modules.size() == .program.modules.size() {
            return sorted_modules
        }

        panic("Cyclic module imports")
    }

    function generate(compiler: Compiler, anon program: CheckedProgram, debug_info: bool) throws -> [String:(String, String)] {
        mut generator = CodeGenerator(
            compiler
            program
            control_flow_state: ControlFlowState(
                allowed_exits: AllowedControlExits::Nothing
                passes_through_match: false
                passes_through_try: false
                match_nest_level: 0
            )
            entered_yieldable_blocks: []
            deferred_output: ""
            current_function: None
            inside_defer: false
            //TODO: use program.loaded_modules
            debug_info: CodegenDebugInfo(
                compiler
                line_spans: [:]
                statement_span_comments: debug_info
            )
            namespace_stack: []
            fresh_var_counter: 0
            fresh_label_counter: 0
        )

        mut result: [String:(String, String)] = [:]

        // Unified forwarding header
        mut output = ""
        output += "#pragma once\n"
        output += "#include <lib.h>\n"
        output += "#ifdef _WIN32\n"
        output += "extern \"C\" __cdecl int SetConsoleOutputCP(unsigned int code_page);\n"
        output += "const unsigned int CP_UTF8 = 65001;\n"
        output += "#endif\n"
        let sorted_modules = generator.topologically_sort_modules()
        output += "namespace Jakt {\n"
        for idx in sorted_modules.size()..0 {
            let i = sorted_modules[idx - 1].id
            if i == 0 {
                // Skip 0 because it's the prelude
                continue
            }
            let module = generator.program.modules[i]
            generator.compiler.dbg_println(format("generate: module idx: {}, module.name {}", i, module.name))
            if not module.is_root {
                output += "namespace "
                output += module.name
                output += " {\n"
            }
            let scope_id = ScopeId(module_id: module.id, id: 0)
            let scope = generator.program.get_scope(scope_id)
            output += generator.codegen_namespace_predecl(scope, current_module: module)
            if not module.is_root {
                output += "}\n"
            }
        }

        output += "} // namespace Jakt\n"


        result.set(
            "__unified_forward.h",
            (output, compiler.current_file_path()!.to_string()),
        )


        for as_forward in [true, false].iterator() {
            for idx in sorted_modules.size()..0 {
                // Module forward declarations header (if as_forward), or module implementation (if not as_forward)
                let i = sorted_modules[idx - 1].id
                if i == 0 {
                    // Skip 0 because it's the prelude
                    continue
                }

                let module = generator.program.modules[i]
                generator.compiler.dbg_println(format("generate: module idx: {}, module.name {} - forward: {}", i, module.name, as_forward))

                let header_name = format("{}.h", module.name)
                let impl_name = format("{}.cpp", module.name)

                if as_forward {
                    output = "#pragma once\n"
                    output += "#include \"__unified_forward.h\"\n"
                } else {
                    output = format("#include \"{}\"\n", header_name)
                }

                let scope_id = ScopeId(module_id: module.id, id: 0)
                let scope = generator.program.get_scope(scope_id)

                if as_forward {
                    for child_scope in scope.children.iterator() {
                        let scope = generator.program.get_scope(scope_id: child_scope)
                        if scope.import_path_if_extern.has_value() {
                            let has_name = scope.namespace_name.has_value()
                            if has_name {
                                output += format("namespace {} {{\n", scope.namespace_name!)
                            }
                            for action in scope.before_extern_include.iterator() {
                                match action {
                                    Define(name, value) => {
                                        output += format("#ifdef {}\n", name)
                                        output += format("#undef {}\n", name)
                                        output += "#endif\n"
                                        output += format("#define {} {}\n", name, value)
                                    }
                                    Undefine(name) => {
                                        output += format("#ifdef {}\n", name)
                                        output += format("#undef {}\n", name)
                                        output += "#endif\n"
                                    }
                                }
                            }
                            output += format("#include <{}>\n", scope.import_path_if_extern!)
                            for action in scope.after_extern_include.iterator() {
                                match action {
                                    Define(name, value) => {
                                        output += format("#ifdef {}\n", name)
                                        output += format("#undef {}\n", name)
                                        output += "#endif\n"
                                        output += format("#define {} {}\n", name, value)
                                    }
                                    Undefine(name) => {
                                        output += format("#ifdef {}\n", name)
                                        output += format("#undef {}\n", name)
                                        output += "#endif\n"
                                    }
                                }
                            }
                            if has_name {
                                output += " } // namespace " + scope.namespace_name! + "\n"
                            }
                        }
                    }
                    for id in module.imports.iterator() {
                        let module = generator.program.modules[id.id]
                        output += format("#include \"{}.h\"\n", module.name)
                    }
                }

                output += "namespace Jakt {\n"

                if not module.is_root {
                    output += "namespace "
                    output += module.name
                    output += " {\n"
                    generator.namespace_stack.push(module.name)
                }

                output += generator.codegen_namespace(scope, current_module: module, as_forward)

                if not module.is_root {
                    // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                    let dummy = generator.namespace_stack.pop()
                }

                if not module.is_root {
                    output += "}\n"
                }

                output += generator.deferred_output
                generator.deferred_output = ""
                output += "} // namespace Jakt\n"

                if as_forward {
                    result.set(header_name, (output, module.resolved_import_path))
                } else {
                    result.set(impl_name, (output, module.resolved_import_path))
                }
            }
        }

        return result
    }

    function postorder_traversal(this, encoded_type_id: String, mut visited: {String}, encoded_dependency_graph: [String: [String]], mut output: [TypeId]) throws {
        let type_id = TypeId::from_string(encoded_type_id)
        if visited.contains(type_id.to_string()) {
            return
        }
        visited.add(type_id.to_string())
        if encoded_dependency_graph.contains(encoded_type_id) {
            for dependency in encoded_dependency_graph.get(encoded_type_id)!.iterator() {
                .postorder_traversal(encoded_type_id: dependency, visited, encoded_dependency_graph, output)
            }
        }
        output.push(type_id)
    }

    function produce_codegen_dependency_graph(this, scope: Scope) throws -> [String : [String]] {
        mut dependency_graph: [String : [String]] = [:]

        for type_ in scope.types.iterator() {
            dependency_graph.set(type_.1.to_string(), .extract_dependencies_from(type_id: type_.1, dependency_graph, top_level: true))
        }

        return dependency_graph
    }

    function extract_dependencies_from(this, type_id: TypeId, dependency_graph: [String : [String]], top_level: bool) throws -> [String] {
        mut dependencies: [String] = []

        if dependency_graph.contains(type_id.to_string()) {
            for dependency in dependency_graph.get(type_id.to_string())!.iterator() {
                dependencies.push(dependency)
            }
            return dependencies
        }

        let type_ = .program.get_type(type_id)
        let inner_dependencies = match type_ {
            Enum(enum_id) => .extract_dependencies_from_enum(enum_id, dependency_graph, top_level)
            GenericEnumInstance(id) => .extract_dependencies_from_enum(enum_id: id, dependency_graph, top_level)
            Struct(id) => .extract_dependencies_from_struct(struct_id: id, dependency_graph, top_level, args: [])
            GenericInstance(id, args) => .extract_dependencies_from_struct(struct_id: id, dependency_graph, top_level, args)
            else => []
        }

        for dependency in inner_dependencies.iterator() {
            dependencies.push(dependency)
        }

        return dependencies
    }

    function extract_dependencies_from_enum(this, enum_id: EnumId, dependency_graph: [String : [String]], top_level: bool) throws -> [String] {
        mut dependencies: [String] = []

        let enum_ = .program.get_enum(enum_id)
        if enum_.definition_linkage is External {
            // This type is defined somewhere else,
            // so we can skip marking it as a dependency.
            return dependencies
        }
        if enum_.is_boxed and not top_level {
            // We store and pass these as pointers, so we don't need to
            // include them in the dependency graph.
            return dependencies
        }
        dependencies.push(enum_.type_id.to_string())
        if not enum_.underlying_type_id.equals(unknown_type_id()) {
            let inner_dependencies = .extract_dependencies_from(type_id: enum_.underlying_type_id, dependency_graph, top_level: false)
            for dependency in inner_dependencies.iterator() {
                dependencies.push(dependency)
            }
        }
        for variant in enum_.variants.iterator() {
            match variant {
                Typed(type_id) => {
                    let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
                    for dependency in inner_dependencies.iterator() {
                        dependencies.push(dependency)
                    }
                }
                StructLike(fields) => {
                    for field in fields.iterator() {
                        let type_id = .program.get_variable(field).type_id
                        let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
                        for dependency in inner_dependencies.iterator() {
                            dependencies.push(dependency)
                        }
                    }
                }
                else => {}
            }
        }

        return dependencies
    }

    function extract_dependencies_from_struct(this, struct_id: StructId, dependency_graph: [String : [String]], top_level: bool, args: [TypeId]) throws -> [String] {
        mut dependencies: [String] = []
        let struct_ = .program.get_struct(struct_id)

        if struct_.definition_linkage is External and struct_.name != "Optional" {
            // This type is defined somewhere else,
            // so we can skip marking it as a dependency.
            return dependencies
        }

        if struct_.record_type is Class and not top_level {
            // We store and pass these as pointers, so we don't need to
            // include them in the dependency graph.
            return dependencies
        }

        if not args.is_empty() {
            for inner_type in args.iterator() {
                let inner_dependencies = match .program.get_type(inner_type) {
                    Enum | Struct => .extract_dependencies_from(type_id: inner_type, dependency_graph, top_level: false)
                    else => []
                }

                for dependency in inner_dependencies.iterator() {
                    dependencies.push(dependency)
                }
            }
        }

        mut super_struct_id = struct_.super_struct_id
        while super_struct_id.has_value() {
            let super_struct = .program.get_struct(super_struct_id!)
            dependencies.push(super_struct.type_id.to_string())
            super_struct_id = super_struct.super_struct_id
        }

        dependencies.push(struct_.type_id.to_string())
        // The struct's fields are also dependencies.
        for field in struct_.fields.iterator() {
            let type_id = .program.get_variable(field.variable_id).type_id
            let inner_dependencies = .extract_dependencies_from(type_id, dependency_graph, top_level: false)
            for dependency in inner_dependencies.iterator() {
                dependencies.push(dependency)
            }
        }
        return dependencies
    }

    function codegen_namespace(mut this, scope: Scope, current_module: Module, as_forward: bool) throws -> String {
        if scope.import_path_if_extern.has_value() {
            return ""
        }
        mut seen_types: {String} = {}

        if as_forward {
            mut output = ""
            let encoded_dependency_graph = .produce_codegen_dependency_graph(scope)
            for entry in encoded_dependency_graph.iterator() {
                let traversal: [TypeId] = []
                .postorder_traversal(encoded_type_id: entry.0, visited: seen_types, dependency_graph: encoded_dependency_graph, output: traversal)
                for type_id in traversal.iterator() {
                    let type_ = .program.get_type(type_id)
                    match type_ {
                        Enum(enum_id) => {
                            if not enum_id.module.equals(current_module.id) {
                                // Skip over imports from other modules
                                continue
                            }
                            let enum_ = .program.get_enum(enum_id)
                            let enum_output = .codegen_enum(enum_)
                            if not enum_output.is_empty() {
                                output += enum_output
                            }
                        }
                        Struct(struct_id) => {
                            if not struct_id.module.equals(current_module.id) {
                                // Skip over imports from other modules
                                continue
                            }

                            let struct_ = .program.get_struct(struct_id)
                            let struct_output = .codegen_struct(struct_)

                            if not struct_output.is_empty() {
                                output += struct_output
                            }
                        }
                        Trait => { }
                        else => {
                            panic(format("Unexpected type in dependency graph: {}", type_))
                        }
                    }
                    seen_types.add(type_id.to_string())
                }
            }

            for (_, struct_id) in scope.structs.iterator() {
                if not struct_id.module.equals(current_module.id) {
                    continue
                }
                let struct_ = .program.get_struct(struct_id)
                if seen_types.contains(struct_.type_id.to_string()) {
                    continue
                }
                output += .codegen_struct(struct_)
                output += "\n"
            }

            for (_, enum_id) in scope.enums.iterator() {
                if not enum_id.module.equals(current_module.id) {
                    continue
                }
                let enum_ = .program.get_enum(enum_id)
                if seen_types.contains(enum_.type_id.to_string()) {
                    continue
                }
                output += .codegen_enum(enum_)
                output += "\n"
            }

            for (_, function_id) in scope.functions.iterator() {
                if not function_id.module.equals(current_module.id) {
                    continue
                }

                let function_ = .program.get_function(function_id)

                let previous_function = .current_function
                .current_function = function_
                defer .current_function = previous_function

                if function_.linkage is External or function_.type is ImplicitConstructor or function_.type is ImplicitEnumConstructor {
                    continue
                }

                if not function_.generics.params.is_empty() {
                    output += .codegen_function(function_)
                    output += "\n"
                }
            }

            for child_scope_id in scope.children.iterator() {
                let child_scope = .program.get_scope(child_scope_id)
                if child_scope.namespace_name.has_value() {
                    let name = child_scope.namespace_name!
                    .namespace_stack.push(name)
                    output += "namespace "
                    output += name
                    output += " {\n"
                    output += .codegen_namespace(scope: child_scope, current_module, as_forward)
                    output += "}\n"
                    // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                    let dummy = .namespace_stack.pop()
                }
            }

            return output
        }

        mut output = ""
        for (_, function_id) in scope.functions.iterator() {
            if not function_id.module.equals(current_module.id) {
                continue
            }

            let function_ = .program.get_function(function_id)

            let previous_function = .current_function
            .current_function = function_
            defer .current_function = previous_function

            if function_.linkage is External or function_.type is ImplicitConstructor or function_.type is ImplicitEnumConstructor {
                continue
            }

            if function_.generics.params.is_empty() {
                output += .codegen_function(function_)
                output += "\n"
            }
        }

        for (_, struct_id) in scope.structs.iterator() {
            if not struct_id.module.equals(current_module.id) {
                continue
            }
            let struct_ = .program.get_struct(struct_id)

            if struct_.definition_linkage is External {
                continue
            }

            if not struct_.generic_parameters.is_empty() {
                continue
            }

            output += .codegen_debug_description_getter(struct_)

            let scope = .program.get_scope(struct_.scope_id)
            for (_, function_id) in scope.functions.iterator() {
                let function_ = .program.get_function(function_id)
                let previous_function = .current_function
                .current_function = function_
                defer .current_function = previous_function

                if function_.type is ImplicitConstructor {
                    output += .codegen_constructor(function_)
                    output += "\n"
                } else if not function_.type is ImplicitEnumConstructor and not function_.is_comptime and function_.generics.params.is_empty() {
                    output += .codegen_function_in_namespace(function_, containing_struct: struct_.type_id)
                    output += "\n"
                }
            }
        }

        for (_, enum_id) in scope.enums.iterator() {
            if not enum_id.module.equals(current_module.id) {
                continue
            }
            let enum_ = .program.get_enum(enum_id)

            if enum_.definition_linkage is External {
                continue
            }

            if not enum_.generic_parameters.is_empty() {
                continue
            }

            if enum_.underlying_type_id.equals(void_type_id()) {
                output += .codegen_enum_debug_description_getter(enum_)
            }

            let scope = .program.get_scope(enum_.scope_id)
            for (_, function_id) in scope.functions.iterator() {
                let function_ = .program.get_function(function_id)
                let previous_function = .current_function
                .current_function = function_
                defer .current_function = previous_function
                if not function_.type is ImplicitConstructor and not function_.type is ImplicitEnumConstructor and not function_.is_comptime {
                    output += .codegen_function_in_namespace(function_, containing_struct: enum_.type_id)
                    output += "\n"
                }
            }
        }

        for child_scope_id in scope.children.iterator() {
            let child_scope = .program.get_scope(child_scope_id)
            if child_scope.namespace_name.has_value() {
                let name = child_scope.namespace_name!
                .namespace_stack.push(name)
                output += "namespace "
                output += name
                output += " {\n"
                output += .codegen_namespace(scope: child_scope, current_module, as_forward)
                output += "}\n"
                // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                let dummy = .namespace_stack.pop()
            }
        }

        return output
    }

    function codegen_namespace_predecl(mut this, scope: Scope, current_module: Module) throws -> String {
        if scope.import_path_if_extern.has_value() {
            return ""
        }
        mut output = ""
        if scope.namespace_name.has_value() {
            output += "namespace "
            output += scope.namespace_name!
            output += " {\n"
        }
        for (_, struct_id) in scope.structs.iterator() {
            if not struct_id.module.equals(current_module.id) {
                continue
            }
            let struct_ = .program.get_struct(struct_id)
            output += .codegen_struct_predecl(struct_)
            output += "\n"
        }

        for (_, enum_id) in scope.enums.iterator() {
            if not enum_id.module.equals(current_module.id) {
                continue
            }
            let enum_ = .program.get_enum(enum_id)
            output += .codegen_enum_predecl(enum_)
            output += "\n"
        }

        for child in scope.children.iterator() {
            output += .codegen_namespace_predecl(scope: .program.get_scope(child), current_module)
        }

        for (_, function_id) in scope.functions.iterator() {
            if not function_id.module.equals(current_module.id) {
                continue
            }
            let function_ = .program.get_function(function_id)
            if function_.type is ImplicitEnumConstructor {
                continue
            }

            let previous_function_id = .current_function
            .current_function = Some(function_)
            defer .current_function = previous_function_id

            if not function_.type is ImplicitConstructor and function_.name != "main" {
                output += .codegen_function_predecl(function_)
                output += "\n"
            }
        }

        if scope.namespace_name.has_value() {
            output += "}\n"
        }
        return output
    }

    function codegen_function_generic_parameters(mut this, function_: CheckedFunction) throws -> String {
        mut output = ""

        if not function_.generics.params.is_empty() {
            output += "template <"
            mut first = true
            for generic_parameter in function_.generics.params.iterator() {
                if first {
                    first = false
                } else {
                    output += ","
                }
                output += "typename "
                output += .codegen_type(generic_parameter.type_id())
            }
            output += ">\n"
        }

        return output
    }

    function codegen_function_predecl(mut this, function_: CheckedFunction, as_method: bool = false) throws -> String {
        mut output = ""

        if not function_.generics.params.is_empty() and function_.linkage is External {
            return ""
        }

        if function_.is_comptime {
            return ""
        }

        // FIXME: for now, just exit early if we're a constructor
        if function_.type is ImplicitConstructor {
            return ""
        }

        if function_.linkage is External {
            output += "extern "
        }

        output += .codegen_function_generic_parameters(function_)

        if function_.return_type_id.equals(never_type_id()) {
            output += "[[noreturn]] "
        }

        if function_.name == "main" {
            output += "ErrorOr<int>"
        } else {
            if as_method and function_.is_static() {
                output += "static "
            }

            if function_.is_virtual {
                output += "virtual "
            }

            let naked_return_type = .codegen_type(function_.return_type_id)
            let return_type = match function_.can_throw {
                true => format("ErrorOr<{}>", naked_return_type)
                else => naked_return_type
            }
            output += return_type
        }

        output += " "
        output += function_.name
        output += "("

        mut first = true
        for param in function_.params.iterator() {
            if first and param.variable.name == "this" {
                continue
            }

            if first {
                first = false
            } else {
                output += ", "
            }

            let param_type = .program.get_type(param.variable.type_id)
            output += .codegen_type(param.variable.type_id)
            output += " "
            if not param.variable.is_mutable and not (param_type is Reference or param_type is MutableReference) {
                output += "const "
            }
            output += param.variable.name
        }
        output += ")"
        
        if not function_.is_static() and not function_.is_mutating() {
            output += " const"
        } 
        if function_.is_override {
            output += " override"
        }

        output += ";"

        output += "\n"

        return output
    }

    function codegen_struct_predecl(mut this, struct_: CheckedStruct) throws -> String {
        if struct_.definition_linkage is External {
            return ""
        }
        mut output = ""

        if not struct_.generic_parameters.is_empty() {
            output += "template <"
            mut first = true
            for generic_parameter in struct_.generic_parameters.iterator() {
                if first {
                    first = false
                } else {
                    output += ","
                }
                output += "typename "
                output += .codegen_type(generic_parameter.type_id)
            }
            output += ">"
        }

        output += match struct_.record_type {
            Class => "class "
            Struct => "struct "
            else => ""
        }

        output += struct_.name
        output += ";"

        return output
    }

    function codegen_struct(mut this, struct_: CheckedStruct) throws -> String {
        mut output = ""

        if struct_.definition_linkage is External {
            return ""
        }

        mut generic_parameter_names: [String] = []
        if not struct_.generic_parameters.is_empty() {
            for generic_parameter in struct_.generic_parameters.iterator() {
                generic_parameter_names.push(.codegen_type(generic_parameter.type_id))
            }

            output += format("template <{}>", join(prepend_to_each(generic_parameter_names, prefix: "typename "), separator: ", "))
        }

        match struct_.record_type {
            Class => {
                mut class_name_with_generics = ""
                class_name_with_generics += struct_.name
                mut first = true
                for generic_parameter in struct_.generic_parameters.iterator() {
                    if not first {
                        class_name_with_generics += ", "
                    } else {
                        class_name_with_generics += "<"
                        first = false
                    }
                    class_name_with_generics += .codegen_type(generic_parameter.type_id)
                }
                if not struct_.generic_parameters.is_empty() {
                    class_name_with_generics += ">"
                }

                if struct_.super_struct_id.has_value() {
                    let super_struct = .program.get_struct(struct_.super_struct_id!)
                    output += format("class {}: public {} {{\n", struct_.name, super_struct.name)
                } else {
                    output += format("class {} : public RefCounted<{}>, public Weakable<{}> {{\n", struct_.name, class_name_with_generics, class_name_with_generics)
                }
                output += "  public:\n"
                output += format("virtual ~{}() = default;\n", struct_.name)
            }
            Struct => {
                output += format("struct {}", struct_.name)
                output += " {\n"
                output += "  public:\n"
            }
            SumEnum => {
                todo("codegen_struct SumEnum")
            }
            ValueEnum => {
                todo("codegen_struct ValueEnum")
            }
            else => {}
        }

        for field in struct_.fields.iterator() {
            let variable = .program.get_variable(field.variable_id)
            output += .codegen_type(variable.type_id)
            output += " "
            output += variable.name
            output += ";"
        }

        let scope = .program.get_scope(struct_.scope_id)
        for fn in scope.functions.iterator() {

            let function_ = .program.get_function(fn.1)

            let previous_function_id = .current_function
            .current_function = Some(function_)
            defer .current_function = previous_function_id

            if function_.type is ImplicitConstructor {
                if struct_.generic_parameters.is_empty() {
                    output += .codegen_constructor_predecl(function_)
                } else {
                    output += .codegen_constructor(function_, is_inline: true)
                }
                output += "\n"
            } else {
                if struct_.generic_parameters.is_empty() and function_.generics.params.is_empty() {
                    output += .codegen_function_predecl(function_, as_method: true)
                } else {
                    output += .codegen_function(function_, as_method: true)
                }
            }
        }

        if struct_.generic_parameters.is_empty() {
            output += "ErrorOr<String> debug_description() const;\n"
        } else {
            output += .codegen_debug_description_getter(struct_, is_inline: true)
        }

        output += "};"

        .deferred_output += .codegen_ak_formatter(name: struct_.name, generic_parameter_names)

        return output
    }

    function codegen_enum_predecl(mut this, enum_: CheckedEnum) throws -> String {
        mut output = ""

        if not enum_.underlying_type_id.equals(void_type_id()) {
            if .program.is_integer(enum_.underlying_type_id) {
                return format("enum class {}: {};", enum_.name, .codegen_type(enum_.underlying_type_id))
            } else {
                todo("Enums with a non-integer underlying type")
            }
        }

        let is_generic = not enum_.generic_parameters.is_empty()
        mut template_args_array: [String] = []
        for generic_parameter in enum_.generic_parameters.iterator() {
            if .program.get_type(generic_parameter.type_id) is TypeVariable(name) {
                template_args_array.push("typename " + name)
            }
        }
        mut template_args = join(template_args_array, separator: ", ")

        output += format("namespace {}_Details", enum_.name) + " {\n"
        for variant in enum_.variants.iterator() {
            match variant {
                Untyped(name) | StructLike(name) | Typed(name) => {
                    if is_generic {
                        output += format("template<{}>\n", template_args)
                    }
                    output += format("struct {};\n", name)
                }
                else => {}
            }
        }
        output += "}\n"

        if is_generic {
            output += format("template<{}>\n", template_args)
        }
        output += format("struct {};\n", enum_.name)

        return output
    }

    function codegen_enum(mut this, enum_: CheckedEnum) throws -> String {
        mut output = ""
        if not enum_.underlying_type_id.equals(void_type_id()) {
            if .program.is_integer(enum_.underlying_type_id) {
                output += "enum class " + enum_.name + ": " + .codegen_type(enum_.underlying_type_id) + " {\n"
                for variant in enum_.variants.iterator() {
                    output += match variant {
                        WithValue(name, expr) => name + " = " + .codegen_expression(expr) + ",\n"
                        else => {
                            todo(format("codegen_enum can't generate variant: {}", variant))
                            yield ""
                        }
                    }
                }
                return output + "};\n"
            } else {
                todo("Enums with a non-integer underlying type")
            }
        }

        let is_generic = not enum_.generic_parameters.is_empty()
        mut generic_parameter_names: [String] = []
        for generic_parameter in enum_.generic_parameters.iterator() {
            if .program.get_type(generic_parameter.type_id) is TypeVariable(name) {
                generic_parameter_names.push(name)
            }
        }
        mut template_args = join(prepend_to_each(generic_parameter_names, prefix: "typename "), separator: ", ")

        mut common_fields: [(String, String)] = []
        for field in enum_.fields.iterator() {
            let variable = .program.get_variable(field.variable_id)
            common_fields.push((variable.name, .codegen_type(variable.type_id)))
        }

        output += "namespace " + enum_.name + "_Details {\n"
        for variant in enum_.variants.iterator() {
            let fields = match variant {
                Untyped(name) => {
                    if is_generic {
                        output += "template<" + template_args + ">\n"
                    }
                    output += "struct " + name + " {\n"
                    yield common_fields
                }
                StructLike(name, fields: own_fields) => {
                    mut fields: [(String, String)] = []
                    for field in own_fields.iterator() {
                        let variable = .program.get_variable(field)
                        fields.push((variable.name, .codegen_type(variable.type_id)))
                    }

                    if is_generic {
                        output += "template<" + template_args + ">\n"
                    }
                    output += "struct " + name + " {\n"
                    yield fields
                }
                Typed(name, type_id) => {
                    mut fields: [(String, String)] = []
                    for field in common_fields.iterator() {
                        fields.push(field)
                    }
                    fields.push(("value", .codegen_type(type_id)))

                    if is_generic {
                        output += "template<" + template_args + ">\n"
                    }
                    output += "struct " + name + "{\n"
                    yield fields
                }
                else => {
                    todo(format("codegen enum variant: {}", variant))
                    yield []
                }
            }

            for (name, type) in fields.iterator() {
                output += format("{} {};\n", type, name)
            }
            if not fields.is_empty() {
                output += "template<"
                mut generic_typenames: [String] = []
                mut generic_argument_types: [String] = []
                mut initializers: [String] = []
                for i in 0..fields.size() {
                    generic_typenames.push(format("typename _MemberT{}", i))
                    generic_argument_types.push(format("_MemberT{}&& member_{}", i, i))

                    mut initializer = fields[i].0 + "{ forward<_MemberT"
                    initializer += format("{}>(member_{}", i, i) + ")}"
                    initializers.push(initializer)
                }
                output += join(generic_typenames, separator: ", ")
                output += ">\n"
                output += variant.name() + "(" + join(generic_argument_types, separator: ", ") + "):\n"
                output += join(initializers, separator: ",\n") + "\n{}\n"
            }
            output +="};\n"
        }
        output += "}\n"

        if is_generic {
            output += "template<" + template_args + ">\n"
        }
        mut variant_names: [String] = []
        mut variant_arguments_array: [String] = []
        for variant in enum_.variants.iterator() {
            mut argument = enum_.name + "_Details::" + variant.name()
            if is_generic {
                argument += format("<{}>", join(generic_parameter_names, separator: ", "))
            }
            variant_arguments_array.push(argument)
            variant_names.push(variant.name())
        }
        let variant_args = join(variant_arguments_array, separator: ", ")

        output += format("struct {} : public Variant<{}>", enum_.name, variant_args)
        if enum_.is_boxed {
            output += format(", public RefCounted<{}", enum_.name)
            if is_generic {
                output += format("<{}>", join(generic_parameter_names, separator: ", "))
            }
            output += ">"
        }
        output += " {\n"
        output += "using Variant<" + variant_args + ">::Variant;\n"

        for name in variant_names.iterator() {
            output += "    using " +  name + " = " + enum_.name + "_Details::" + name
            if is_generic {
                output += "<"
                output += join(generic_parameter_names, separator: ", ")
                output += ">"
            }
            output += ";\n"
        }

        if enum_.is_boxed {
            mut fully_instantiated_name = enum_.name
            if is_generic {
                fully_instantiated_name += format("<{}>", join(generic_parameter_names, separator: ", "))
            }
            output += "template<typename V, typename... Args> static auto create(Args&&... args) {\n"
            output += format("return adopt_nonnull_ref_or_enomem(new (nothrow) {}(V(forward<Args>(args)...)));\n", fully_instantiated_name)
            output += "}\n"
        }

        if enum_.generic_parameters.is_empty() {
            output += "ErrorOr<String> debug_description() const;\n"
        } else {
            output += .codegen_enum_debug_description_getter(enum_, is_inline: true)
        }

        for (field_name, type) in common_fields.iterator() {
            output += format("{} const& {}() const {{ switch(this->index()) {{", type, field_name)
            for i in 0..enum_.variants.size() {
                let variant = enum_.variants[i]
                let name = variant.name()
                output += format("case {} /* {} */: ", i, name)
                output += format("return this->template get<{}::{}>().{};\n", enum_.name, name, field_name)
            }
            output += "default: VERIFY_NOT_REACHED();\n"
            output += "}\n}\n"
        }

        let enum_scope = .program.get_scope(enum_.scope_id)
        for function_item in enum_scope.functions.iterator() {
            let function_ = .program.get_function(function_item.1)

            let previous_function_id = .current_function
            .current_function = Some(function_)
            defer .current_function = previous_function_id

            if not function_.type is ImplicitEnumConstructor {
                if enum_.generic_parameters.is_empty() and function_.generics.params.is_empty() {
                    output += .codegen_function_predecl(function_, as_method: true)
                } else {
                    output += .codegen_function(function_, as_method: true)
                }
            }
        }

        output += "};\n"

        .deferred_output += .codegen_ak_formatter(name: enum_.name, generic_parameter_names)

        return output
    }

    function codegen_debug_description_getter(mut this, struct_: CheckedStruct, is_inline: bool = false) throws -> String {
        mut output = ""

        if not is_inline and not struct_.generic_parameters.is_empty() {
            output += "template <"
            mut first = true
            for param in struct_.generic_parameters.iterator() {
                if first {
                    first = false
                } else {
                    output += ","
                }
                output += "typename "
                output += .codegen_type(param.type_id)
            }
            output += ">\n"
        }

        output += "ErrorOr<String> "
        if not is_inline {
            output += .codegen_type_possibly_as_namespace(type_id: struct_.type_id, as_namespace: true)
            output += "::"
        }
        output += "debug_description() const { "
        output += "auto builder = MUST(StringBuilder::create());"
        output += format("TRY(builder.append(\"{}(\"));", struct_.name)
        output += "{\n"
        output += "JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};\n"

        mut i = 0uz
        for field in struct_.fields.iterator() {
            let field_var = .program.get_variable(field.variable_id)
            output += "TRY(JaktInternal::PrettyPrint::output_indentation(builder));"
            output += format("TRY(builder.append(\"{}: \"));", field_var.name)
            output += "TRY(builder.appendff(\""
            if .program.is_string(field_var.type_id) {
                output += "\\\"{}\\\""
            } else {
                output += "{}"
            }
            if i != struct_.fields.size() - 1 {
                output += ", "
            }
            output += "\", "

            output += match .program.get_type(field_var.type_id) {
                Struct(struct_id) => match .program.get_struct(struct_id).record_type {
                    Class => "*"
                    else => ""
                }
                else => ""
            }
            output += field_var.name + "));\n"
            i++
        }

        output += "}\n"
        output += "TRY(builder.append(\")\"));"
        output += "return builder.to_string();"
        output += " }\n"
        return output
    }

    function codegen_enum_debug_description_getter(mut this, enum_: CheckedEnum, is_inline: bool = false) throws -> String {
        mut output = ""

        if not is_inline and not enum_.generic_parameters.is_empty() {
            output += "template <"
            mut first = true
            for param in enum_.generic_parameters.iterator() {
                if first {
                    first = false
                } else {
                    output += ","
                }
                output += "typename "
                output += .codegen_type(param.type_id)
            }
            output += ">\n"
        }

        output += "ErrorOr<String> "
        if not is_inline {
            output += .codegen_type_possibly_as_namespace(type_id: enum_.type_id, as_namespace: true)
            output += "::"
        }
        output += "debug_description() const {\n"
        output += "auto builder = TRY(StringBuilder::create());\n"
        output += "switch (this->index()) {"

        for i in 0..enum_.variants.size() {
            let variant = enum_.variants[i]
            let name = variant.name()
            output += format("case {} /* {} */: {{\n", i, name)
            output += format("[[maybe_unused]] auto const& that = this->template get<{}::{}>();\n", enum_.name, name)
            output += format("TRY(builder.append(\"{}::{}\"));\n", enum_.name, name)
            match variant {
                StructLike(fields) => {
                    output += "TRY(builder.append(\"(\"));\n"
                    output += "{\n";
                    output += "JaktInternal::PrettyPrint::ScopedLevelIncrease increase_indent {};\n"
                    mut i = 0uz
                    for field in fields.iterator() {
                        output += "TRY(JaktInternal::PrettyPrint::output_indentation(builder));\n"
                        let var = .program.get_variable(field)
                        if .program.is_string(var.type_id){
                            output += format("TRY(builder.appendff(\"{}: \\\"{{}}\\\"\", that.{}));\n", var.name, var.name)
                        } else {
                            output += format("TRY(builder.appendff(\"{}: {{}}\", that.{}));\n", var.name, var.name)
                        }
                        if i != fields.size() - 1 {
                            output += "TRY(builder.append(\", \"));\n"
                        }
                        i++
                    }
                    output += "}\n"
                    output += "TRY(builder.append(\")\"));\n"
                }
                Typed(type_id) => {
                    if .program.is_string(type_id){
                        output += "TRY(builder.appendff(\"(\\\"{}\\\")\", that.value));\n"
                    } else {
                        output += "TRY(builder.appendff(\"({})\", that.value));\n"
                    }
                }
                else => {}
            }

            output += "break;}\n"
        }

        output += "}\nreturn builder.to_string();\n}\n"

        return output
    }

    function codegen_ak_formatter(mut this, name: String, generic_parameter_names: [String]) throws -> String {
        mut output = ""

        let template_args = join(prepend_to_each(generic_parameter_names, prefix: "typename "), separator: ", ")
        let generic_type_args = join(generic_parameter_names, separator: ", ")

        mut qualified_name = ""
        for namespace_ in .namespace_stack.iterator() {
            qualified_name += format("{}::", namespace_)
        }

        qualified_name += name

        if not generic_parameter_names.is_empty() {
            qualified_name += format("<{}>\n", generic_type_args)
        }

        output += format("template<{}>", template_args)
        output += format("struct Formatter<{}> : Formatter<StringView>", qualified_name)
        output += "{\n"
        output += format("ErrorOr<void> format(FormatBuilder& builder, {} const& value) {{\n", qualified_name)
        output += "JaktInternal::PrettyPrint::ScopedEnable pretty_print_enable { m_alternative_form };"
        output += "ErrorOr<void> format_error = Formatter<StringView>::format(builder, MUST(value.debug_description()));"
        output += "return format_error; }"

        return output + "};\n"
    }

    function codegen_expression_and_deref_if_generic_and_needed(
        mut this
        anon expression: CheckedExpression
    ) throws -> String => match .program.get_type(expression.type()) {
        TypeVariable => {
            let contents = .codegen_expression(expression)
            yield format("(*([]<typename V>(V const& value) {{ if constexpr (IsSpecializationOf<V, NonnullRefPtr>) return &*value; else return &value; }})({}))", contents)
        }
        else => .codegen_expression(expression)
    }

    function codegen_expression(mut this, anon expression: CheckedExpression) throws -> String => match expression {
        Range(from, to, type_id) => {
            mut output = ""
            let type = .program.get_type(type_id)
            let index_type = match type {
                GenericInstance(id, args) => args[0]
                else => {
                    panic("Internal error: range expression doesn't have Range type")
                }
            }
            output += "("
            output += .codegen_type(type_id)
            output += "{"
            output += "static_cast<"
            output += .codegen_type(index_type)
            output += ">("
            if from.has_value() {
                output += .codegen_expression(from!)
            } else {
                output += "0LL"
            }
            output += "),static_cast<"
            output += .codegen_type(index_type)
            output += ">("
            if to.has_value() {
                output += .codegen_expression(to!)
            } else {
                output += "9223372036854775807LL"
            }
            output += ")})"
            yield output
        }
        OptionalNone => "JaktInternal::OptionalNone()"
        OptionalSome(expr, type_id) => "static_cast<" + .codegen_type(type_id) + ">(" + .codegen_expression(expr) + ")"
        ForcedUnwrap(expr, type_id) => "(" + .codegen_expression(expr) + ".value())"
        QuotedString(val) => {
            let escaped_value = val.replace(replace: "\n", with: "\\n")
            yield "String(\"" + escaped_value + "\")"
        }
        ByteConstant(val) => "'" + val + "'"
        CharacterConstant(val) => "'" + val + "'"
        Var(var) => match var.name {
            "this" => "*this"
            else => var.name
        }
        IndexedExpression(expr, index) => "((" + .codegen_expression(expr) + ")[" + .codegen_expression(index) + "])"
        IndexedDictionary(expr, index) => "((" + .codegen_expression(expr) + ")[" + .codegen_expression(index) + "])"
        IndexedTuple(expr, index, is_optional) => match is_optional {
            true => format("(({}).map([](auto& _value) {{ return _value.template get<{}>(); }}))", .codegen_expression(expr), index)
            else => format("(({}).get<{}>())", .codegen_expression(expr), index)
        }
        IndexedStruct(expr, index, is_optional) => {
            mut output = ""
            let object = .codegen_expression(expression: expr)
            output += "(("
            output += object
            output += ")"

            match .program.get_type(expr.type()) {
                RawPtr => {
                    output += "->"
                }
                Struct(id) | GenericInstance(id) => {
                    let structure = .program.get_struct(id)
                    if structure.record_type is Class and object != "*this" {
                        output += "->"
                    } else {
                        output += "."
                    }
                }
                else => {
                    output += "."
                }
            }
            if is_optional {
                output += "map([](auto& _value) { return _value."
                output += index
                output += "; })"
            } else {
                output += index
            }
            output += ")"
            yield output
        }
        IndexedCommonEnumMember(expr, index, is_optional) => {
            mut output = ""
            let object = .codegen_expression(expression: expr)
            output += "(("
            output += object
            output += ")"

            match .program.get_type(expr.type()) {
                RawPtr => {
                    output += "->"
                }
                Enum(id) | GenericEnumInstance(id) => {
                    let structure = .program.get_enum(id)
                    if structure.record_type is SumEnum(is_boxed) and is_boxed and object != "*this" {
                        output += "->"
                    } else {
                        output += "."
                    }
                }
                else => {
                    output += "."
                }
            }
            if is_optional {
                output += "map([](auto& _value) { return _value."
                output += index
                output += "(); })"
            } else {
                output += index + "()"
            }
            output += ")"
            yield output
        }
        Block(block) => .codegen_block(block)
        Call(call) => .codegen_call(call)
        MethodCall(expr, call, is_optional) => .codegen_method_call(expr, call, is_optional)
        Boolean(val) => match val {
            true => "true"
            else => "false"
        }
        UnaryOp(expr, op, type_id) => {
            mut output = "("
            output += match op {
                PreIncrement => "++"
                PreDecrement => "--"
                Negate => "-"
                Dereference => match .program.get_type(expr.type()) {
                    RawPtr => "*"
                    else => ""
                }
                // FIXME: Remove this once we have proper type mutability support
                RawAddress => "const_cast<" + .codegen_type(type_id) + ">(" + "&"
                LogicalNot => "!"
                BitwiseNot => "~"
                Is(type_id) => {
                    let is_type = match .program.get_type(type_id) {
                        Struct(id) => {
                            let type_module = .program.get_module(id.module)
                            yield .program.get_struct(id).name
                        }
                        else => .codegen_type(type_id)
                    }
                    yield "is<" + is_type + ">("
                }
                TypeCast(cast) => {
                    mut final_type_id = cast.type_id();
                    let cast_type = match cast {
                        Fallible => {
                            let ty = .program.get_type(cast.type_id())
                            let type_id = match ty {
                                GenericInstance(args) => args[0]
                                else => {
                                    panic("Fallible type cast must have Optional result.")
                                }
                            }
                            mut cast_type = "dynamic_cast"
                            if .program.is_integer(type_id) {
                                final_type_id = type_id
                                cast_type = "fallible_integer_cast"
                            }

                            yield cast_type
                        }
                        Infallible => {
                            mut cast_type = "verify_cast"
                            if .program.is_integer(type_id) {
                                cast_type = "infallible_integer_cast"
                            }
                            yield cast_type
                        }
                    }
                    yield cast_type + "<" + .codegen_type(final_type_id) + ">("
                }
                else => ""
            }
            output += "("
            let object = .codegen_expression(expr)
            output += object
            output += match op {
                PostIncrement => "++)"
                PostDecrement => "--)"
                TypeCast | Is => "))"
                IsEnumVariant(enum_variant, type_id: enum_type_id) => {
                    let name = enum_variant.name()
                    mut suffix = ")"
                    let enum_ = .program.get_enum(match .program.get_type(enum_type_id) {
                        Enum(enum_id) => enum_id
                        GenericEnumInstance(id) => id
                        else => {
                            panic(format("Unexpected type in IsEnumVariant: {}", .program.get_type(enum_type_id)))
                        }
                    })
                    let is_boxed = enum_.is_boxed
                    if is_boxed and object != "*this"{
                        suffix += "->"
                    } else {
                        suffix += "."
                    }
                    // FIXME: This should be a call to find(), but we do not yet provide the needed operator== for that
                    mut variant_index = 0;
                    for variant in enum_.variants.iterator() {
                        if variant.name() == name{
                            break
                        }
                        variant_index++
                    }
                    suffix += format("index() == {} /* {} */", variant_index, name)
                    yield suffix
                }
                RawAddress => "))"
                else => ")"
            }
            output += ")"
            yield output
        }
        BinaryOp(lhs, rhs, op, type_id) => .codegen_binary_expression(expression, type_id, lhs, rhs, op)
        NumericConstant(val, type_id) => {
            let suffix = match val {
                I64 => "LL"
                U64 | USize => "ULL"
                else => ""
            }

            let type_name = match val {
                USize => "size_t"
                else => .codegen_type(type_id)
            }

            yield match val {
                F32(val)
                | F64(val)
                | I8(val)
                | I16(val)
                | I32(val)
                | I64(val)
                | U8(val)
                | U16(val)
                | U32(val)
                | U64(val)
                | USize(val)
                => format("static_cast<{}>({}{})", type_name, val, suffix)
            }
        }
        NamespacedVar(namespaces, var) => {
            mut output = ""
            for ns in namespaces.iterator() {
                output += ns.name + "::"
            }
            yield output + var.name
        }
        Match(expr, match_cases, type_id, all_variants_constant) => .codegen_match(expr, match_cases, type_id, all_variants_constant)
        EnumVariantArg(expr, arg, enum_variant) => {
            let var_name = .codegen_expression(expr)
            let enum_type = .codegen_type_possibly_as_namespace(type_id: expr.type(), as_namespace: true)
            let variant_name = enum_variant.name()
            mut arg_name = "value"
            if enum_variant is StructLike {
                arg_name = arg.name ?? arg.binding
            }
            let cpp_deref_operator = match .program.get_enum(enum_variant.enum_id()).is_boxed {
                true => "->"
                else => "."
            }
            yield format("({}{}get<{}::{}>()).{}", var_name, cpp_deref_operator, enum_type, variant_name, arg_name)
        }
        JaktArray(vals, repeat, span, type_id, inner_type_id) => {
            mut output = ""
            if repeat.has_value() {
                let repeat_val = repeat.value()
                output += "("
                output += .current_error_handler()
                output += "((Array<"
                output += .codegen_type(inner_type_id)
                output += ">::filled("
                output += .codegen_expression(repeat_val)
                output += ", "
                output += .codegen_expression(vals[0])
                output += "))))"
            } else {
                output += "("
                output += .current_error_handler()
                output += "((Array<"
                output += .codegen_type(inner_type_id)
                output += ">::create_with({"
                mut first = true
                for val in vals.iterator() {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .codegen_expression(val)
                }
                output += "}))))"
            }

            yield output
        }
        JaktDictionary(vals, span, type_id, key_type_id, value_type_id) => {
            mut output = format("({}((Dictionary<{}, {}>::create_with_entries({{",
                .current_error_handler(),
                .codegen_type(key_type_id),
                .codegen_type(value_type_id))

            mut first = true
            for (key, value) in vals.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                output += "{"
                output += .codegen_expression(key)
                output += ", "
                output += .codegen_expression(value)
                output += "}"
            }

            output += "}))))"

            yield output
        }
        JaktSet(vals, span, type_id, inner_type_id) => {
            mut output = ""
            output += format("({}((Set<{}>::create_with_values({{", .current_error_handler(), .codegen_type(inner_type_id))
            mut first = true
            for value in vals.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }
                output += .codegen_expression(value)
            }
            output += "}))))"
            yield output
        }
        JaktTuple(vals, span, type_id) => {
            mut output = ""
            output += "(Tuple{"
            mut first = true
            for val in vals.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                output += .codegen_expression(val)
            }
            output += "})"

            yield output
        }
        Function(captures, params, can_throw, block, return_type_id, pseudo_function_id) => {
            mut generated_captures: [String] = []
            for capture in captures.iterator() {
                generated_captures.push(match capture {
                    ByValue => capture.name()
                    ByReference | ByMutableReference => format("&{}", capture.name())
                })
            }
            mut generated_params: [String] = []
            for param in params.iterator() {
                generated_params.push(format("{} {}", .codegen_type(param.variable.type_id), param.variable.name))
            }
            let return_type = match can_throw {
                true => format("ErrorOr<{}>", .codegen_type(return_type_id))
                else => .codegen_type(return_type_id)
            }

            mut block_output = ""
            if pseudo_function_id.has_value() {
                let function_ = .program.get_function(pseudo_function_id!)

                let previous_function = .current_function
                .current_function = function_
                defer .current_function = previous_function

                block_output = .codegen_block(block)
            } else {
                block_output = .codegen_block(block)
            }

            yield format("[{}]({}) -> {} {}", join(generated_captures, separator: ", "), join(generated_params, separator: ", "), return_type, block_output)
        }
        TryBlock(stmt, error_name, catch_block, span) => {
            mut output = ""
            let try_var = .fresh_var()

            output += "auto "
            output += try_var
            output += " = [&]() -> ErrorOr<void> {"
            let last_control_flow = .control_flow_state
            .control_flow_state.passes_through_match = false
            .control_flow_state.passes_through_try = true
            output += .codegen_statement(statement: stmt)
            output += ";"
            output += "return {};"
            output += "}();\n"

            output += "if ("
            output += try_var
            output += ".is_error()) {"
            if not error_name.is_empty() {
                output += "auto "
                output += error_name
                output += " = "
                output += try_var
                output += ".release_error();"
            }
            output += .codegen_block(block: catch_block)
            .control_flow_state = last_control_flow
            output += "}"

            yield output
        }
        Try(expr, catch_block, catch_name, span, type_id, inner_type_id) => {
            mut output = ""
            let fresh_var = .fresh_var()
            let is_void = inner_type_id.equals(void_type_id())
            let try_var = .fresh_var()

            let last_control_flow = .control_flow_state
            .control_flow_state.passes_through_match = false
            .control_flow_state.passes_through_try = true
            defer {
                .control_flow_state = last_control_flow
            }

            if not is_void {
                output += "({ Optional<"
                output += .codegen_type(inner_type_id)
                output += "> "
                output += fresh_var
                output += ";\n"
            }

            output += "auto "
            output += try_var
            output += " = [&]() -> ErrorOr<"
            output += .codegen_type(inner_type_id)
            output += "> { return "
            output += .codegen_expression(expr)
            if is_void {
                output += ", ErrorOr<void>{}"
            }
            output += "; }();\n"

            if catch_block.has_value() {
                output += "if ("
                output += try_var
                output += ".is_error()) {"
                if catch_name.has_value() {
                    output += "auto "
                    output += catch_name!
                    output += " = "
                    output += try_var
                    output += ".release_error();\n"
                }

                if catch_block!.yielded_type.has_value() {
                    output += fresh_var
                    output += " = ("
                    output += .codegen_block(block: catch_block!)
                    output += ");\n"
                } else {
                    output += .codegen_block(block: catch_block!)
                }
                
                if not is_void {
                    output += "} else {"
                    output += fresh_var
                    output += " = "
                    output += try_var
                    output += ".release_value();\n"
                }
                output += "}\n"
            } else if not is_void {
                output += "if (!"
                output += try_var
                output += ".is_error()) "
                output += fresh_var
                output += " = "
                output += try_var
                output += ".release_value();\n"
            }

            if not is_void {
                output += fresh_var
                if catch_block.has_value() {
                    output += ".release_value()"
                }
                output += "; })"
            }

            yield output
        }
        else => {
            todo(format("codegen_expression else: {}", expression))
            yield ""
        }
    }

    function codegen_match(mut this, expr: CheckedExpression, match_cases: [CheckedMatchCase], type_id: TypeId, all_variants_constant: bool) throws -> String {
        let last_control_flow = .control_flow_state
        .control_flow_state = .control_flow_state.enter_match()
        mut output = ""

        let expr_type = .program.get_type(expr.type())
        if expr_type is Enum(enum_id) {
            output += .codegen_enum_match(
                enum_: .program.get_enum(enum_id)
                expr
                match_cases
                type_id
                all_variants_constant
            )
        } else {
            output += .codegen_generic_match(
                expr
                cases: match_cases
                return_type_id: type_id
                all_variants_constant
            )
        }
        .control_flow_state = last_control_flow
        return output
    }

    function codegen_generic_match(mut this, expr: CheckedExpression, cases: [CheckedMatchCase], return_type_id: TypeId, all_variants_constant: bool) throws -> String {
        mut output = ""

        mut is_generic_enum: bool = false
        for case_ in cases.iterator() {
            if case_ is EnumVariant {
                is_generic_enum = true
                break
            }
        }
        let match_values_all_constant = all_variants_constant and not is_generic_enum

        output += .control_flow_state.choose_control_flow_macro()

        // TODO: Use switch statement if all values are constant
        output += format(
            "(([&]() -> JaktInternal::ExplicitValueOrControlFlow<{},{}>"
            .codegen_type(return_type_id)
            .codegen_function_return_type(function_: .current_function!)
        ) + "{\n"

        if is_generic_enum {
            output += "auto&& __jakt_enum_value = JaktInternal::deref_if_ref_pointer("
        } else {
            output += "auto __jakt_enum_value = ("
        }
        output += .codegen_expression(expr)
        output += ");\n"

        mut has_default = false
        mut first = true
        for case_ in cases.iterator() {
            match case_ {
                EnumVariant(name, args, subject_type_id, scope_id, body) => {
                    let enum_ = .program.get_enum(match .program.get_type(subject_type_id) {
                        Enum(enum_id) => enum_id
                        GenericEnumInstance(id) => id
                        else => {
                            panic(format("Unexpected type in IsEnumVariant: {}", .program.get_type(subject_type_id)))
                        }
                    })
                    // FIXME: This should be a call to find(), but we do not yet provide the needed operator== for that
                    mut variant_index = 0;
                    for variant in enum_.variants.iterator() {
                        if variant.name() == name{
                            break
                        }
                        variant_index++
                    }

                    output += format("if (__jakt_enum_value.index() == {} /* {} */) {{\n", variant_index, name)

                    mut variant_type_name = ""
                    let qualifier = .codegen_type_possibly_as_namespace(type_id: subject_type_id, as_namespace: true)
                    if not qualifier.is_empty() {
                        variant_type_name += "typename JaktInternal::RemoveRefPtr<"
                        variant_type_name += qualifier
                        variant_type_name += ">::"
                    }
                    variant_type_name += name

                    output += "auto& __jakt_match_value = __jakt_enum_value.template get<"
                    output += variant_type_name
                    output += ">();\n"

                    for arg in args.iterator() {
                        output += "auto& "
                        output += arg.binding
                        output += " = __jakt_match_value."
                        output += arg.name ?? "value"
                        output += ";\n"
                    }

                    output += .codegen_match_body(body, return_type_id)
                    output += "}\n"
                }
                CatchAll(has_arguments, body, marker_span) => {
                    if has_arguments {
                        panic("Bindings aren't allowed in generic else")
                    }

                    // TODO: Use default statement if all values are constant
                    has_default = true

                    if first {
                        output += "{"
                    } else {
                        output += "else {\n"
                    }
                    output += .codegen_match_body(body, return_type_id)
                    output += "}\n"
                }
                Expression(expression, body, marker_span) => {
                    // TODO: Use case statement if all values are constant
                    if not first {
                        output += "else "
                    }
                    if expression is Range(from, to) {
                        output += "if (__jakt_enum_value"
                        if from.has_value() {
                            output += " >= "
                            output += .codegen_expression(from!)
                        }
                        
                        if to.has_value() {
                            if from.has_value() {
                                output += "&& __jakt_enum_value "
                            }
                            output += "< "
                            output += .codegen_expression(to!)
                        }
                    } else {
                        output += "if (__jakt_enum_value == "
                        output += .codegen_expression(expression)
                    }
                    output += ") {\n"
                    output += .codegen_match_body(body, return_type_id)
                    output += "}\n"
                }
            }
            first = false
        }
        if return_type_id.equals(void_type_id()) or return_type_id.equals(unknown_type_id()) {
            output += "return JaktInternal::ExplicitValue<void>();\n"
        } else if not has_default {
            output += "VERIFY_NOT_REACHED();\n"
        }

        output += "}()))\n"

        return output
    }

    function codegen_enum_match(mut this, enum_: CheckedEnum, expr: CheckedExpression, match_cases: [CheckedMatchCase], type_id: TypeId, all_variants_constant: bool) throws -> String {
        mut output = ""
        output += .control_flow_state.choose_control_flow_macro()

        let subject = .codegen_expression(expr)
        let needs_deref = enum_.is_boxed and subject != "*this"

        if enum_.underlying_type_id.equals(void_type_id()) {
            output += "(([&]() -> JaktInternal::ExplicitValueOrControlFlow<"
            output += .codegen_type(type_id)
            output += ", "
            output += .codegen_function_return_type(function_: .current_function!)
            output += ">{\n"
            output += "auto&& __jakt_match_variant = "
            if needs_deref {
                output += "*"
            }
            output += .codegen_expression(expr) + ";\n"
            output += "switch(__jakt_match_variant.index()) {\n"

            mut has_default = false
            for match_case in match_cases.iterator() {
                match match_case {
                    EnumVariant(name, args, subject_type_id, index, scope_id, body) => {
                        let enum_type = .program.get_type(subject_type_id)
                        let enum_id = match enum_type {
                            Enum(id) => id
                            else => {
                                panic("Expected enum type")
                            }
                        }
                        let match_case_enum = .program.get_enum(enum_id)
                        let variant = match_case_enum.variants[index]
                        output += format("case {}: ", index) + "{\n"
                        match variant {
                            Untyped(name) => {
                                output += format("auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n",
                                    .codegen_type_possibly_as_namespace(type_id: subject_type_id, as_namespace: true),
                                    name
                                )
                            }
                            Typed(name, type_id) => {
                                output += format(
                                    "auto&& __jakt_match_value = __jakt_match_variant.template get<typename {}::{}>();\n",
                                    .codegen_type_possibly_as_namespace(type_id: subject_type_id, as_namespace: true),
                                    name
                                )
                                if not args.is_empty() {
                                    let arg = args[0]
                                    let var = .program.find_var_in_scope(scope_id, var: arg.binding)!
                                    output += format("{} const& {} = __jakt_match_value.value;\n", .codegen_type(var.type_id), arg.binding)
                                }
                            }
                            StructLike(name, fields) => {
                                output += format(
                                    "auto&& __jakt_match_value = __jakt_match_variant.template get<{}::{}>();",
                                    .codegen_type_possibly_as_namespace(
                                        type_id: subject_type_id,
                                        as_namespace: true,
                                    ),
                                    name)

                                if not args.is_empty() {
                                    for arg in args.iterator() {
                                        let var = .program.find_var_in_scope(scope_id, var: arg.binding)!
                                        output += .codegen_type(var.type_id)
                                        output += " const& "
                                        output += arg.binding
                                        output += " = __jakt_match_value."
                                        output += arg.name.value_or(arg.binding)
                                        output += ";\n"
                                    }
                                }
                            }
                            else => {
                                todo(format("codegen_enum_match match variant else: {}", variant))
                            }
                        }
                        output += .codegen_match_body(body, return_type_id: type_id)
                        output += "};/*case end*/\n"
                    }
                    CatchAll(body) => {
                        has_default = true

                        output += "default: {\n"
                        output += .codegen_match_body(body, return_type_id: type_id)
                        output += "};/*case end*/\n"
                    }
                    else => {
                        panic("Matching enum subject with non-enum value")
                    }
                }
            }
            if not has_default {
                if enum_.variants.size() != match_cases.size() {
                    panic("Inexhaustive match statement")
                }
                output += "default: VERIFY_NOT_REACHED();"
            }
            output += "}/*switch end*/\n"
            output += "}()\n))"
        } else {
            todo("underlying type enum match")
            // FIXME: underlying type enum match
        }

        return output
    }

    function codegen_match_body(mut this, body: CheckedMatchBody, return_type_id: TypeId) throws -> String {
        mut output = ""

        match body {
            Block(block) => {
                output += .codegen_block(block)

                if return_type_id.equals(void_type_id()) or return_type_id.equals(unknown_type_id()) {
                    output += "return JaktInternal::ExplicitValue<void>();\n"
                }
            }
            Expression(expr) => {
                if expr.type().equals(void_type_id()) or (expr.type().equals(unknown_type_id()) and not expr is OptionalNone) {
                    output += "return ("
                    output += .codegen_expression(expr)
                    output += "), JaktInternal::ExplicitValue<void>();\n"
                } else {
                    output += "return JaktInternal::ExplicitValue("
                    output += .codegen_expression(expr)
                    output += ");\n"
                }
            }
        }
        return output
    }

    function codegen_function_return_type(mut this, anon function_: CheckedFunction) throws -> String {
        if function_.is_static() and function_.name == "main" {
            return "ErrorOr<int>"
        }
        let type_name = .codegen_type(function_.return_type_id)
        if function_.can_throw {
            return format("ErrorOr<{}>", type_name)
        }
        return type_name
    }

    function codegen_binary_expression(mut this, expression: CheckedExpression, type_id: TypeId, lhs: CheckedExpression, rhs: CheckedExpression, op: BinaryOperator) throws -> String {
        if op is NoneCoalescing {
            let rhs_type_id = rhs.type()
            let rhs_type = .program.get_type(rhs_type_id)
            let rhs_can_throw = rhs.can_throw()

            mut output = ""

            if rhs_can_throw {
                output += .current_error_handler()
                output += "(("
            }

            output += .codegen_expression(lhs)
            if rhs_type is GenericInstance(id) and .program.get_struct(id).name == "Optional" {
                if rhs_can_throw {
                    output += ".try_value_or_lazy_evaluated_optional";
                } else {
                    output += ".value_or_lazy_evaluated_optional";
                }
            } else {
                if rhs_can_throw {
                    output += ".try_value_or_lazy_evaluated"
                } else {
                    output += ".value_or_lazy_evaluated"
                }
            }

            if rhs_can_throw {
                output += "([&]() -> ErrorOr<"
                output += .codegen_type(rhs_type_id)
                output += "> { return "
            } else {
                output += "([&] { return "
            }


            output += .codegen_expression(rhs)
            output += "; })"

            if rhs_can_throw {
                output += "))"
            }

            return output
        }

        if op is NoneCoalescingAssign {
            mut output = .codegen_expression(lhs)
            output += ".lazy_emplace([&] { return "
            output += .codegen_expression(rhs)
            output += "; })"
            return output
        }

        if op is ArithmeticRightShift {
            mut output = "JaktInternal::arithmetic_shift_right("
            output += .codegen_expression(lhs)
            output += ","
            output += .codegen_expression(rhs)
            output += ")"
            return output
        }

        if op is Assign and lhs is IndexedDictionary(expr, index) {
            return format(
                "{}({}.set({}, {}))"
                .current_error_handler()
                .codegen_expression(expr)
                .codegen_expression(index)
                .codegen_expression(rhs)
            )
        }

        if .program.is_integer(type_id) {
            // Integer arithmetic is checked by default.
            match op {
                Add | Subtract | Multiply | Divide | Modulo => {
                    if .compiler.optimize {
                        return "(" + .codegen_unchecked_binary_op(lhs, rhs, op, type_id) + ")"
                    } else {
                        return "(" + .codegen_checked_binary_op(lhs, rhs, op, type_id) + ")"
                    }
                }
                AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign => {
                    if .compiler.optimize {
                        return "(" + .codegen_unchecked_binary_op_assignment(lhs, rhs, op, type_id) + ")"
                    } else {
                        return "(" + .codegen_checked_binary_op_assignment(lhs, rhs, op, type_id) + ")"
                    }
                }
                else => { }
            }
        }

        mut output = "("

        output += .codegen_expression(lhs)
        output += match op {
            Add => " + "
            Subtract => " - "
            Multiply => " * "
            Modulo => " % "
            Divide => " / "
            Assign => " = "
            AddAssign => " += "
            SubtractAssign => " -= "
            MultiplyAssign => " *= "
            ModuloAssign => " %= "
            DivideAssign => " /= "
            BitwiseAndAssign => " &= "
            BitwiseOrAssign => " |= "
            BitwiseXorAssign => " ^= "
            BitwiseLeftShiftAssign => " <<= "
            BitwiseRightShiftAssign => " >>= "
            Equal => " == "
            NotEqual => " != "
            LessThan => " < "
            LessThanOrEqual => " <= "
            GreaterThan => " > "
            GreaterThanOrEqual => " >= "
            LogicalAnd => " && "
            LogicalOr => " || "
            BitwiseAnd => " & "
            BitwiseOr => " | "
            BitwiseXor => " ^ "
            ArithmeticLeftShift => " << "
            BitwiseLeftShift => " << "
            BitwiseRightShift => " >> "
            else => {
                todo(format("codegen_binary_expression {}", op))
                yield ""
            }
        }
        output += .codegen_expression(rhs)

        output += ")"
        return output
    }

    function codegen_unchecked_binary_op(mut this, lhs: CheckedExpression, rhs: CheckedExpression, op: BinaryOperator, type_id: TypeId) throws -> String {
        mut output = "static_cast<"
        output += .codegen_type(type_id)
        output += ">("
        output += .codegen_expression(lhs)
        output += match op {
            Add => " + "
            Subtract => " - "
            Multiply => " * "
            Divide => " / "
            Modulo => " % "
            else => {
                panic(format("Checked binary operation codegen is not supported for BinaryOperator::{}", op))
            }
        }
        output += .codegen_expression(rhs)
        output += ")"
        return output
    }

    function codegen_checked_binary_op(mut this, lhs: CheckedExpression, rhs: CheckedExpression, op: BinaryOperator, type_id: TypeId) throws -> String {
        mut output = ""
        output += "JaktInternal::"

        output += match op {
            Add => "checked_add"
            Subtract => "checked_sub"
            Multiply => "checked_mul"
            Divide => "checked_div"
            Modulo => "checked_mod"
            else => {
                panic(format("Checked binary operation codegen is not supported for BinaryOperator::{}", op))
            }
        }

        output += "<"
        output += .codegen_type(type_id)
        output += ">("
        output += .codegen_expression(lhs)
        output += ","
        output += .codegen_expression(rhs)
        output += ")"

        return output
    }

    function codegen_unchecked_binary_op_assignment(mut this, lhs: CheckedExpression, rhs: CheckedExpression, op: BinaryOperator, type_id: TypeId) throws -> String {
        mut output = ""

        output += "{"
        output += "auto& _jakt_ref = "
        output += .codegen_expression(lhs)
        output += ";"
        output += "_jakt_ref = static_cast<"
        output += .codegen_type(type_id)
        output += ">(_jakt_ref "
        output += match op {
            AddAssign => " + "
            SubtractAssign => " - "
            MultiplyAssign => " * "
            DivideAssign => " / "
            ModuloAssign => " % "
            else => {
                panic(format("Checked binary operation assignment codegen is not supported for BinaryOperator::{}", op))
            }
        }
        output += .codegen_expression(rhs)
        output += ");"
        output += "}"
        return output
    }

    function codegen_checked_binary_op_assignment(mut this, lhs: CheckedExpression, rhs: CheckedExpression, op: BinaryOperator, type_id: TypeId) throws -> String {
        mut output = ""

        output += "{"
        output += "auto& _jakt_ref = "
        output += .codegen_expression(lhs)
        output += ";"
        output += "_jakt_ref = JaktInternal::"
        output += match op {
            AddAssign => "checked_add"
            SubtractAssign => "checked_sub"
            MultiplyAssign => "checked_mul"
            DivideAssign => "checked_div"
            ModuloAssign => "checked_mod"
            else => {
                panic(format("Checked binary operation assignment codegen is not supported for BinaryOperator::{}", op))
            }
        }
        output += "<"
        output += .codegen_type(type_id)
        output += ">(_jakt_ref, "
        output += .codegen_expression(rhs)
        output += ");"
        output += "}"
        return output
    }

    function codegen_method_call(mut this, expr: CheckedExpression, call: CheckedCall, is_optional: bool) throws -> String {
        mut output = ""
        if call.callee_throws {
            output += .current_error_handler()
            output += "(("
        }

        let object = .codegen_expression_and_deref_if_generic_and_needed(expr)

        output += "(("
        output += object
        output += ")"

        match .program.get_type(expr.type()) {
            RawPtr => {
                output += "->"
            }
            Struct(id) | GenericInstance(id) => {
                let struct_ = .program.get_struct(id)
                if struct_.record_type is Class and object != "*this" {
                    output += "->"
                } else {
                    output += "."
                }
            }
            Enum(id) => {
                let enum_ = .program.get_enum(id)
                if enum_.is_boxed and object != "*this" {
                    output += "->"
                } else {
                    output += "."
                }
            }
            else => {
                output += "."
            }
        }

        if is_optional {
            output += "map([&](auto& _value) { return _value."
        }

        let generic_parameters = call.type_args
        if not generic_parameters.is_empty() {
            output += "template "
        }

        output += call.name

        if not generic_parameters.is_empty() {
            mut types: [String] = []
            for gen_param in generic_parameters.iterator() {
                types.push(.codegen_type_possibly_as_namespace(type_id: gen_param, as_namespace: false))
            }
            output += format("<{}>", join(types, separator: ", "))
        }

        output += "("

        mut first = true
        for (_, expr) in call.args.iterator() {
            if first {
                first = false
            } else {
                output += ","
            }
            output += .codegen_expression(expr)
        }

        output += ")"

        if is_optional {
            output += "; })"
        }
        output += ")"

        if call.callee_throws {
            output += "))"
        }
        return output
    }

    function codegen_call(mut this, call: CheckedCall) throws -> String {
        mut output = ""

        if call.callee_throws {
            output += .current_error_handler()
            output += "(("
        }
        match call.name {
            "print" | "println" | "eprintln" | "eprint" | "format" => {
                let helper = match call.name {
                    "print" => "out"
                    "println" => "outln"
                    "eprint" => "warn"
                    "eprintln" => "warnln"
                    "format" => "String::formatted"
                    else => ""
                }
                output += helper
                output += "("
                for i in 0..call.args.size() {
                    let (_, expr) = call.args[i]
                    output += .codegen_expression(expr)
                    if i != call.args.size() - 1 {
                        output += ","
                    }
                }
                output += ")"
            }
            else => {
                mut close_enum_type_wrapper = false
                if call.function_id.has_value() {
                    let function_id = call.function_id!
                    let function_ = .program.get_function(function_id)
                    let type_module = .program.get_module(function_id.module)

                    if function_.type is ImplicitConstructor or function_.type is ExternalClassConstructor {
                        let type_id = call.return_type
                        let type = .program.get_type(type_id)

                        if not (
                            type_module.is_root or 
                            type_module.is_prelude() or 
                            function_.linkage is External or 
                            function_.type is Expression or
                            function_.type is Closure or 
                            (not call.namespace_.is_empty() and call.namespace_[0].name == type_module.name)
                        ) {
                            output += type_module.name
                            output += "::"
                        }
                        output += .codegen_namespace_path(call)

                        match type {
                            Struct(struct_id) => {
                                let struct_ = .program.get_struct(struct_id)
                                if struct_.record_type is Class {
                                    output += call.name
                                    output += "::"
                                    output += "create"
                                } else {
                                    output += call.name
                                }
                            }
                            GenericInstance(id, args) => {
                                let struct_ = .program.get_struct(id)
                                if struct_.record_type is Class {
                                    output += .codegen_namespace_qualifier(scope_id: struct_.scope_id)
                                    output += struct_.name
                                    output += "<"
                                    mut first = true
                                    for arg in args.iterator() {
                                        if not first {
                                            output += ", "
                                        } else {
                                            first = false
                                        }
                                        output += .codegen_type(arg)
                                    }
                                    output += ">::create"
                                } else {
                                    output += call.name
                                    output += "<"
                                    mut first = true
                                    for arg in args.iterator() {
                                        if not first {
                                            output += ", "
                                        } else {
                                            first = false
                                        }
                                        output += .codegen_type(arg)
                                    }
                                    output += ">"
                                }
                            }
                            else => {
                                panic("Should be unreachable")
                            }
                        }
                    } else if function_.type is ImplicitEnumConstructor {
                        match .program.get_type(function_.return_type_id) {
                            Enum(enum_id) => {
                                let enum_ = .program.get_enum(enum_id)
                                let enum_type_module = .program.get_module(enum_id.module)
                                if enum_.is_boxed {
                                    if not (
                                        type_module.is_root or 
                                        type_module.is_prelude() or 
                                        function_.linkage is External or 
                                        function_.type is Expression or
                                        function_.type is Closure or 
                                        (not call.namespace_.is_empty() and call.namespace_[0].name == type_module.name)
                                    ) {
                                        output += type_module.name
                                        output += "::"
                                    }
                                    output += .codegen_namespace_path(call)
                                    output += "template create<typename "
                                    output += .codegen_type_possibly_as_namespace(type_id: call.return_type, as_namespace: true)
                                    output += "::" + call.name + ">"
                                } else {
                                    output += " " + .codegen_type(call.return_type)
                                    output += " { "
                                    output += "typename "
                                    output += .codegen_type(call.return_type)
                                    output += "::"
                                    output += call.name

                                    close_enum_type_wrapper = true
                                }
                            }
                            GenericEnumInstance(id) => {
                                todo("codegen generic enum instance")
                            }
                            else => {
                                panic("constructor expected enum type")
                            }
                        }
                    } else {
                        if not (
                            type_module.is_root or 
                            type_module.is_prelude() or 
                            function_.linkage is External or 
                            function_.type is Expression or
                            function_.type is Closure or 
                            (not call.namespace_.is_empty() and call.namespace_[0].name == type_module.name)
                        ) {
                            output += type_module.name
                            output += "::"
                        }
                        output += .codegen_namespace_path(call)

                        // Ensure we fully qualify the names of static functions
                        // in case we're inside a namespace (issue #1226).
                        if function_.is_static() and
                           function_.struct_id.has_value() and
                           function_.type is Normal and
                           function_.linkage is Internal {

                            let struct_ = .program.get_struct(function_.struct_id!)
                            output += struct_.name
                            output += "::"
                        }

                        output += call.name
                    }
                } else {
                    output += .codegen_namespace_path(call)
                    output += call.name
                }

                let generic_parameters = call.type_args

                if not generic_parameters.is_empty() {
                    mut types: [String] = []
                    for gen_param in generic_parameters.iterator() {
                        types.push(.codegen_type_possibly_as_namespace(type_id: gen_param, as_namespace: false))
                    }
                    output += format("<{}>", join(types, separator: ", "))
                }

                mut arguments: [String] = []
                for arg in call.args.iterator() {
                    arguments.push(.codegen_expression(arg.1))
                }

                output += format("({})", join(arguments, separator: ","))

                if close_enum_type_wrapper {
                    output += " } "
                }
            }
        }

        if call.callee_throws {
            output += "))"
        }

        return output
    }

    function codegen_namespace_path(this, call: CheckedCall) throws -> String {
        mut output = ""

        mut index: usize = 0

        for namespace_ in call.namespace_.iterator() {
            // hack warning: this is to get around C++'s limitation that a constructor
            // can't be called like other static methods
            if index == call.namespace_.size() - 1 and namespace_.name == call.name {
                break
            }

            output += namespace_.name
            if namespace_.generic_parameters.has_value() {
                output += "<"
                mut i: usize = 0
                for param in namespace_.generic_parameters!.iterator() {
                    output += .codegen_type(param)
                    if i != namespace_.generic_parameters!.size() - 1 {
                        output += ","
                    }
                    ++i
                }
                output += ">"
            }
            output += "::"

            ++index
        }
        return output
    }

    function codegen_block(mut this, block: CheckedBlock) throws -> String {
        mut output = ""

        if block.yielded_type.has_value() {
            let yielded_type = block.yielded_type!
            let type_output = .codegen_type(yielded_type)
            let fresh_var = .fresh_var()
            let fresh_label = .fresh_label()

            .entered_yieldable_blocks.push((fresh_var, fresh_label))

            output += "({ Optional<"
            output += type_output
            output += "> "
            output += fresh_var
            output += "; "
        }

        output += "{\n"

        for statement in block.statements.iterator() {
            output += .codegen_statement(statement)
        }

        output += "}\n"

        if block.yielded_type.has_value() {
            let (var, label) = .entered_yieldable_blocks.pop()!

            output += label
            output += ":; "
            output += var
            if not block.yielded_none {
                output += ".release_value()"
            }
            output += "; })"
        }

        return output
    }

    function codegen_statement(mut this, statement: CheckedStatement) throws -> String {
        mut add_newline = true
        mut output = ""
        if .debug_info.statement_span_comments and statement.span().has_value() and add_newline {
            output += format("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
        }

        output += match statement {
            Throw(expr) => "return " + .codegen_expression(expr) + ";"
            Continue => match .control_flow_state.passes_through_match {
                true => "return JaktInternal::LoopContinue{};"
                else => "continue;"
            }
            Break => match .control_flow_state.passes_through_match {
                true => "return JaktInternal::LoopBreak{};"
                else => "break;"
            }
            Expression(expr) => .codegen_expression(expr) + ";"
            Defer(statement) => {
                mut output = ""
                output += "ScopeGuard "
                output += .fresh_var()
                output += "([&] {\n"
                let last_control_flow = .control_flow_state
                let old_inside_defer = .inside_defer

                .control_flow_state.passes_through_match = false
                .inside_defer = true

                output += .codegen_statement(statement)
                output += "});"

                .control_flow_state = last_control_flow
                .inside_defer = old_inside_defer
                yield output
            }
            Return(val) => match val.has_value() {
                true => "return (" + .codegen_expression(val!) + ");"
                else => {
                    yield match .current_function!.can_throw {
                        true => "return {};"
                        else => "return;"
                    }
                }
            }
            Loop(block) => {
                mut output = ""
                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output += format("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output += "for (;;)"
                add_newline = false
                let last_control_flow = .control_flow_state
                .control_flow_state = last_control_flow.enter_loop()
                let block_str = .codegen_block(block)
                .control_flow_state = last_control_flow
                output += block_str
                yield output
            }
            While(condition, block) => {
                mut output = ""
                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output += format("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output += "while ("
                output += .codegen_expression(expression: condition)
                output += ")"

                {
                    let last_control_flow = .control_flow_state
                    .control_flow_state = last_control_flow.enter_loop()
                    let code = .codegen_block(block)
                    .control_flow_state = last_control_flow
                    output += code
                }
                add_newline = false
                yield output
            }
            Block(block) => .codegen_block(block)
            Garbage => {
                panic("Garbage statement in codegen")
            }
            DestructuringAssignment(vars, var_decl) => {
                mut output = ""
                output += .codegen_statement(statement: var_decl)

                for v in vars.iterator() {
                    output += .codegen_statement(statement: v)
                }
                yield output
            }
            VarDecl(var_id, init) => {
                let var = .program.get_variable(var_id)

                mut output = ""
                let var_type = .program.get_type(var.type_id)
                output += .codegen_type(var.type_id)
                output += " "
                if not var.is_mutable and not (var_type is Reference or var_type is MutableReference) {
                    output += "const "
                }
                output += var.name
                output += " = "
                output += .codegen_expression(init)
                output += ";"
                yield output
            }
            InlineCpp(lines) => {
                mut output = ""
                for line in lines.iterator() {
                    mut escaped_line = line
                    escaped_line = escaped_line.replace(replace: "\\\"", with: "\"")
                    escaped_line = escaped_line.replace(replace: "\\\\", with: "\\")
                    output += escaped_line
                }
                yield output
            }
            If(condition, then_block, else_statement) => {
                mut output = ""

                if .debug_info.statement_span_comments and statement.span().has_value() {
                    output += format("\n#line {}\n", .debug_info.span_to_source_location(statement.span()!))
                }
                output += "if ("
                output += .codegen_expression(condition)
                output += ")"

                output += .codegen_block(block: then_block)

                output += match else_statement.has_value() {
                    true => "else " + .codegen_statement(statement: else_statement!)
                    else => ""
                }

                add_newline = false

                yield output
            }
            Yield(expr, span) => {
                mut output = ""

                if .entered_yieldable_blocks.size() == 0 {
                    panic("Must be in a block to yield")
                }

                let (var_name, end_label) = .entered_yieldable_blocks.last()!

                output += var_name
                output += " = "
                output += .codegen_expression(expr)
                output += "; goto "
                output += end_label
                output += ";\n"

                yield output
            }
        }

        if add_newline {
            output += "\n"
        }

        return output
    }


    function codegen_type(this, anon type_id: TypeId) throws -> String {
        return .codegen_type_possibly_as_namespace(type_id, as_namespace: false)
    }

    function codegen_type_possibly_as_namespace(this, type_id: TypeId, as_namespace: bool) throws -> String => match .program.get_type(type_id) {
        Void => "void"
        Bool => "bool"
        U8 => "u8"
        U16 => "u16"
        U32 => "u32"
        U64 => "u64"
        I8 => "i8"
        I16 => "i16"
        I32 => "i32"
        I64 => "i64"
        F32 => "f32"
        F64 => "f64"
        Usize => "size_t"
        JaktString => "String"
        CChar => "char"
        CInt => "int"
        Never => "void"
        RawPtr(type_id) => .codegen_type(type_id) + "*"
        Reference(type_id) => .codegen_type(type_id) + " const&"
        MutableReference(type_id) => .codegen_type(type_id) + "&"
        GenericResolvedType(id, args) | GenericInstance(id, args) => .codegen_generic_type_instance(id, args, as_namespace)
        Struct(id) => .codegen_struct_type(id, as_namespace)
        Enum(id) => .codegen_enum_type(id, as_namespace)
        GenericEnumInstance(id, args) => .codegen_generic_enum_instance(id, args, as_namespace)
        TypeVariable(name) => name
        Function(params, can_throw, return_type_id) => {
            mut output = "Function<"
            if can_throw {
                output += "ErrorOr<"
            }
            output += .codegen_type(return_type_id)
            if can_throw {
                output += ">"
            }
            output += "("
            mut first = true
            for param in params.iterator() {
                if first {
                    first = false
                } else {
                    output += ", "
                }
                output += .codegen_type(param)
            }
            output += ")>"
            yield output
        }
        GenericTraitInstance => {
            panic("Generic trait instance in codegen")
        }
        else => {
            // The RBC uses 'auto' here but we probably want to improve in the future
            yield "auto"
        }
    }

    function codegen_generic_type_instance(this, id: StructId, args: [TypeId], as_namespace: bool) throws -> String {
        // FIXME: Handle WeakPtr
        mut output = ""
        let type_module = .program.get_module(id.module)

        mut namespace_ = ""
        // For prelude generic instances prefix with "JaktInternal::" so that there aren't naming clashes
        if type_module.is_prelude() {
            namespace_ += "JaktInternal::"
        } else if not type_module.is_root {
            namespace_ += type_module.name
            namespace_ += "::"
        }

        let inner_weak_ptr_struct_id = .program.check_and_extract_weak_ptr(struct_id: id, args)

        if inner_weak_ptr_struct_id.has_value() {
            output += "WeakPtr<"
            output += namespace_

            let inner_struct_id = inner_weak_ptr_struct_id.value()
            let struct_ = .program.get_struct(inner_struct_id)
            output += .codegen_namespace_qualifier(scope_id: struct_.scope_id)
            output += struct_.name

            output += ">"
        } else {
            let struct_ = .program.get_struct(id)

            let acquired_by_ref = not as_namespace and struct_.record_type is Class
            if acquired_by_ref {
                output += "NonnullRefPtr<"
            }
            output += namespace_
            output += .codegen_namespace_qualifier(scope_id: struct_.scope_id)
            output += struct_.name
            output += "<"
            mut first = true
            for type_id in args.iterator() {
                if not first {
                    output += ","
                } else {
                    first = false
                }
                output += .codegen_type(type_id)
            }
            output += ">"
            if acquired_by_ref {
                output += ">"
            }
        }

        return output
    }

    function codegen_generic_enum_instance(this, id: EnumId, args: [TypeId], as_namespace: bool) throws -> String {
        mut output = ""
        mut close_tag = false
        let enum_ = .program.get_enum(id)
        if not as_namespace and enum_.is_boxed {
            output += "NonnullRefPtr<"
            let qualifier = .codegen_namespace_qualifier(scope_id: enum_.scope_id)

            if not qualifier.is_empty() {
                output += "typename "
                output += qualifier
            }
            output += enum_.name
            close_tag = true
        } else {
            let qualifier = .codegen_namespace_qualifier(scope_id: enum_.scope_id)

            if not qualifier.is_empty() {
                output += "typename "
                output += qualifier
            }
            output += enum_.name
        }
        output += "<"
        mut first = true
        for type_id in args.iterator() {
            if not first {
                output += ", "
            } else {
                first = false
            }

            output += .codegen_type(type_id)
        }
        output += ">"
        if close_tag {
            output += ">"
        }
        return output
    }

    function codegen_namespace_qualifier(this, scope_id: ScopeId) throws -> String {
        mut output = ""
        mut current_scope_id = .program.get_scope(scope_id).parent

        while current_scope_id.has_value() {
            let scope = .program.get_scope(current_scope_id!)
            if scope.namespace_name.has_value() {
                let namespace_name = scope.namespace_name!
                output = format("{}::{}", namespace_name, output)
            }
            current_scope_id = scope.parent
        }
        return output
    }

    function codegen_function(mut this, anon function_: CheckedFunction, as_method: bool = false) throws -> String {
        if function_.is_comptime {
            return ""
        }

        return .codegen_function_in_namespace(function_, containing_struct: None, as_method)
    }

    function codegen_struct_type(this, id: StructId, as_namespace: bool) throws -> String {
        mut output = ""
        let type_module = .program.get_module(id.module)
        let checked_struct = .program.get_struct(id)

        if not as_namespace and checked_struct.record_type is Class {
            output += "NonnullRefPtr<"
            if not type_module.is_root and not type_module.id.equals(ModuleId(id: 0)) {
                output += type_module.name
                output += "::"
            }
            output += .codegen_namespace_qualifier(scope_id: checked_struct.scope_id)
            output += checked_struct.name
            output += ">"
        } else {
            if not (type_module.is_root or type_module.id.equals(ModuleId(id: 0))  or checked_struct.definition_linkage is External) {
                output += type_module.name
                output += "::"
            }
            output += .codegen_namespace_qualifier(scope_id: checked_struct.scope_id)
            output += checked_struct.name
        }

        return output
    }

    function codegen_enum_type(this, id: EnumId, as_namespace: bool) throws -> String {
        mut output = ""
        let type_module = .program.get_module(id.module)
        let checked_enum = .program.get_enum(id)

        if not as_namespace and checked_enum.is_boxed {
            output += "NonnullRefPtr<"
            if not (type_module.is_root or type_module.id.equals(ModuleId(id: 0))) {
                output += type_module.name
                output += "::"
            }
            let qualifier = .codegen_namespace_qualifier(scope_id: checked_enum.scope_id)
            if not qualifier.is_empty() {
                output += "typename "
                output += qualifier
            }
            output += checked_enum.name
            output += ">"
        } else {
            if not (type_module.is_root or type_module.id.equals(ModuleId(id: 0))) {
                output += type_module.name
                output += "::"
            }
            let qualifier = .codegen_namespace_qualifier(scope_id: checked_enum.scope_id)
            if not qualifier.is_empty() {
                output += qualifier
            }
            output += checked_enum.name
        }

        return output
    }

    function codegen_constructor_predecl(mut this, anon function_: CheckedFunction) throws -> String {
        let type_id = function_.return_type_id
        let type_ = .program.get_type(type_id)

        guard type_ is Struct(struct_id) else {
            panic("internal error: call to a constructor, but not a struct/class type")
        }

        let structure = .program.get_struct(struct_id)

        if structure.record_type is Class {
            mut output = ""

            output += "protected:\n"

            output += format("explicit {}(", function_.name)
            mut first = true
            for param in function_.params.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                let param_type_id = param.variable.type_id
                output += .codegen_type(param_type_id)
                output += "&& a_"
                output += param.variable.name
            }
            output += ");\n"

            mut class_name_with_generics = ""
            class_name_with_generics += structure.name

            first = true
            for generic_parameter in structure.generic_parameters.iterator() {
                if not first {
                    class_name_with_generics += ", "
                } else {
                    class_name_with_generics += "<"
                    first = false
                }

                class_name_with_generics += .codegen_type(generic_parameter.type_id)
            }
            if not structure.generic_parameters.is_empty() {
                class_name_with_generics += ">"
            }

            output += "public:\n"
            output += format("static ErrorOr<NonnullRefPtr<{}>> create", class_name_with_generics)
            output += "("

            first = true
            for param in function_.params.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                output += .codegen_type(param.variable.type_id)
                output += " "
                output += param.variable.name
            }

            output += ");\n"
            return output
        }

        mut output = ""
        output += function_.name
        output += "("

        mut first = true
        for param in function_.params.iterator() {
            if not first {
                output += ", "
            } else {
                first = false
            }

            output += .codegen_type(param.variable.type_id)
            output += " a_"
            output += param.variable.name
        }
        output += ");\n"

        return output
    }

    function codegen_constructor(mut this, anon function_: CheckedFunction, is_inline: bool = false) throws -> String {
        let type_id = function_.return_type_id
        let type_ = .program.get_type(type_id)

        guard type_ is Struct(struct_id) else {
            panic("internal error: call to a constructor, but not a struct/class type")
        }

        let structure = .program.get_struct(struct_id)
        let qualified_name = .codegen_type_possibly_as_namespace(type_id, as_namespace: true)
        mut output = ""

        if not is_inline and not structure.generic_parameters.is_empty() {
            output += "template <"
            mut first = true
            for param in structure.generic_parameters.iterator() {
                if first {
                    first = false
                } else {
                    output += ","
                }
                output += "typename "
                output += .codegen_type(param.type_id)
            }
            output += ">\n"
        }

        if structure.record_type is Class {
            if is_inline {
                output += function_.name
                output += "("
            } else {
                output += format("{}::{}(", qualified_name, function_.name)
            }

            mut first = true
            for param in function_.params.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                let param_type_id = param.variable.type_id
                output += .codegen_type(param_type_id)
                output += "&& a_"
                output += param.variable.name
            }
            output += ")"

            if not function_.params.is_empty() {
                output += ": "

                mut initializers: [String] = []

                let parent_constructor_parameter_count = function_.params.size() - structure.fields.size()
                if parent_constructor_parameter_count > 0 {
                    mut parent_initializer = ""
                    parent_initializer += .program.get_struct(structure.super_struct_id!).name
                    parent_initializer += "("

                    mut strings: [String] = []
                    for param in function_.params[0..parent_constructor_parameter_count].iterator() {
                        strings.push("move(a_" + param.variable.name + ")")
                    }
                    parent_initializer += join(strings, separator: ", ")

                    parent_initializer += ")"
                    initializers.push(parent_initializer)
                }

                for i in parent_constructor_parameter_count..function_.params.size() {
                    let param = function_.params[i]
                    initializers.push(param.variable.name + "(move(a_" + param.variable.name + "))")
                }
                output += join(initializers, separator: ", ")
            }

            output += "{}\n"

            mut class_name_with_generics = ""
            class_name_with_generics += structure.name

            first = true
            for generic_parameter in structure.generic_parameters.iterator() {
                if not first {
                    class_name_with_generics += ", "
                } else {
                    class_name_with_generics += "<"
                    first = false
                }

                class_name_with_generics += .codegen_type(generic_parameter.type_id)
            }
            if not structure.generic_parameters.is_empty() {
                class_name_with_generics += ">"
            }

            if is_inline {
                output += "static "
            }

            let qualified_namespace = match is_inline {
                true => ""
                else => qualified_name + "::"
            }
            output += format("ErrorOr<NonnullRefPtr<{}>> {}create", class_name_with_generics, qualified_namespace)
            output += "("

            first = true
            for param in function_.params.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                output += .codegen_type(param.variable.type_id)
                output += " "
                output += param.variable.name
            }

            output += format(") {{ auto o = {}(adopt_nonnull_ref_or_enomem(new (nothrow) {} (", .current_error_handler(), class_name_with_generics)

            first = true
            for param in function_.params.iterator() {
                if not first {
                    output += ", "
                } else {
                    first = false
                }

                output += "move("
                output += param.variable.name
                output += ")"
            }

            output += "))); return o; }"

            return output
        }

        if not is_inline {
            output += qualified_name
            output += "::"
        }
        output += function_.name
        output += "("

        mut first = true
        for param in function_.params.iterator() {
            if not first {
                output += ", "
            } else {
                first = false
            }

            output += .codegen_type(param.variable.type_id)
            output += " a_"
            output += param.variable.name
        }
        output += ") "

        if not function_.params.is_empty() {
            output += ":"
        }

        first = true
        for param in function_.params.iterator() {
            if not first {
                output += ", "
            } else {
                first = false
            }

            output += param.variable.name
            output += "(a_"
            output += param.variable.name
            output += ")"
        }

        output += "{}\n"

        return output
    }

    function codegen_function_in_namespace(mut this, function_: CheckedFunction, containing_struct: TypeId?, as_method: bool = false) throws -> String {
        // Extern generics need to be in the header anyways, so we can't codegen for them.
        if not function_.generics.params.is_empty() {
            if function_.linkage is External {
                return ""
            }
        }

        mut output = ""

        output += .codegen_function_generic_parameters(function_)

        let is_main = function_.name == "main" and not containing_struct.has_value()

        if function_.return_type_id.equals(never_type_id()) {
            output += "[[noreturn]] "
        }
        if is_main {
            output += "ErrorOr<int>"
        } else {
            if as_method and function_.is_static() {
                output += "static "
            }
            output += match function_.can_throw {
                true => format("ErrorOr<{}>", .codegen_type(function_.return_type_id))
                else => .codegen_type(function_.return_type_id)
            }
        }

        output += " "

        if is_main {
            output += "main"
        } else {
            let qualifier = match containing_struct.has_value() {
                true => .codegen_type_possibly_as_namespace(type_id: containing_struct!, as_namespace: true)
                else => ""
            }
            if not qualifier.is_empty() {
                output += qualifier
                output += "::"
            }
            output += function_.name
        }

        output += "("

        if is_main and function_.params.is_empty() {
            output += "Array<String>"
        }

        mut first = true
        for param in function_.params.iterator() {
            let variable = param.variable
            if variable.name == "this" {
                continue
            }
            if not first {
                output += ","
            } else {
                first = false
            }
            let variable_type = .program.get_type(variable.type_id)
            output += .codegen_type(variable.type_id)
            output += " "
            if not variable.is_mutable and not (variable_type is Reference or variable_type is MutableReference) {
                output += "const "
            }
            output += variable.name
        }

        output += ")"

        if not function_.is_static() and not function_.is_mutating() {
            output += " const"
        }

        output += " {\n"
        if is_main {
            output += "\n
            #ifdef _WIN32
            SetConsoleOutputCP(CP_UTF8);
            // Enable buffering to prevent VS from chopping up UTF-8 byte sequences
            setvbuf(stdout, nullptr, _IOFBF, 1000);
            #endif\n"
        }
        // FIXME: Panic if function type is unknown, and this isn't `main()`

        let last_control_flow = .control_flow_state
        .control_flow_state = last_control_flow.enter_function()
        let block = .codegen_block(block: function_.block)
        .control_flow_state = last_control_flow
        output += block

        if is_main {
            output += "return 0;\n"
        } else {
            if function_.can_throw and function_.return_type_id.equals(builtin(BuiltinType::Void)) {
                output += "return {};\n"
            }
        }

        output += "}\n"

        return output
    }
}
