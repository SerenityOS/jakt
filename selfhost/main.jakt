import lexer with JaktSpan, Token, JaktError, empty_span, merge_spans, Lexer, print_error

/// Expect:
/// - output: ""

extern function abort()
extern struct StringBuilder {
    function append(mut this, anon s: u8)
    function to_string(mut this) throws -> String
    function StringBuilder() -> StringBuilder
}

function todo(anon message: String) {
    eprintln("TODO: {}", message)
    abort()
}

function panic(anon message: String) -> void {
    eprintln("internal error: {}", message)
    abort()
}

enum DefinitionLinkage {
    Internal
    External
}

enum DefinitionType {
    Class
    Struct
}

// Parsed Types
struct ParsedNamespace {
    name: String
    functions: [ParsedFunction]
    structs: [ParsedStruct]
}

struct ParsedStruct {
    name: String
    name_span: JaktSpan
    generic_parameters: [[String:JaktSpan]]
    fields: [ParsedField]
    methods: [ParsedMethod]
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
}

struct ParsedFunction {
    name: String
    name_span: JaktSpan
    params: [ParsedParameter]
    generic_parameters: [[String:JaktSpan]]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: JaktSpan
    throws: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    is_mutable: bool
    span: JaktSpan
}

struct ParsedBlock {
    stmts: [ParsedStatement]
}

boxed enum ParsedStatement {
    Expression(ParsedExpression)
    Defer(ParsedStatement)
    UnsafeBlock(ParsedBlock)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?)
    Block(ParsedBlock)
    Loop(ParsedBlock)
    While(guard: ParsedExpression, block: ParsedBlock)
    For(iterator_name: String, name_span: JaktSpan, range: ParsedExpression, block: ParsedBlock)
    Break
    Continue
    Return(expr: ParsedExpression, span: JaktSpan)
    Throw(ParsedExpression)
    Yield(ParsedExpression)
    InlineCpp(block: ParsedBlock, span: JaktSpan)
    Try(stmt: ParsedStatement, error_name: String, error_span: JaktSpan, catch_block: ParsedBlock)
    Garbage
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    Is(ParsedType)
}

struct EnumVariantPatternArgument {
    name: String?
    binding: String
    span: JaktSpan
}

enum ParsedMatchPattern {
    EnumVariant(
        variant_name: [(String, JaktSpan)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: JaktSpan
    )
    Expression(ParsedExpression)
    CatchAll
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: JaktSpan
    body: ParsedMatchBody
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: JaktSpan)
    NumericConstant(val: i64, span: JaktSpan)
    QuotedString(val: String, span: JaktSpan)
    SingleQuotedString(val: String, span: JaktSpan)
    SingleQuotedByteString(val: String, span: JaktSpan)
    Call(call: ParsedCall, span: JaktSpan)
    MethodCall(expr: ParsedExpression, call: ParsedCall, span: JaktSpan)
    IndexedTuple(expr: ParsedExpression, index: usize, span: JaktSpan)
    IndexedStruct(expr: ParsedExpression, field: String, span: JaktSpan)
    Var(name: String, span: JaktSpan)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: JaktSpan)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: JaktSpan)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: JaktSpan)
    Operator(op: BinaryOperator, span: JaktSpan)
    OptionalSome(expr: ParsedExpression, span: JaktSpan)
    OptionalNone(JaktSpan)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: JaktSpan)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: JaktSpan)
    Range(from: ParsedExpression, to: ParsedExpression, span: JaktSpan)
    ForcedUnwrap(expr: ParsedExpression, span: JaktSpan)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: JaktSpan)
    Garbage(JaktSpan)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        SingleQuotedString(val, span) => span
        SingleQuotedByteString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        Match(expr, cases, span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedCall {
    name: String,
    args: [(String, ParsedExpression)]
}

boxed enum ParsedType {
    Name(name: String, span: JaktSpan)
    JaktArray(inner: ParsedType, span: JaktSpan)
    Dictionary(key: ParsedType, value: ParsedType, span: JaktSpan)
    JaktTuple(types: [ParsedType], span: JaktSpan)
    Set(inner: ParsedType, span: JaktSpan)
    Optional(inner: ParsedType, span: JaktSpan)
    RawPtr(inner: ParsedType, span: JaktSpan)
    WeakPtr(inner: ParsedType, span: JaktSpan)
    Empty
}

struct Parser {
    index: usize
    tokens: [Token]
    errors: [JaktError]

    function error(mut this, anon message: String, anon span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: JaktSpan, anon hint: String, anon hint_span: JaktSpan) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens[.tokens.size() - 1]
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(JaktSpan(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mut this) throws -> ParsedNamespace {
        mut parsed_namespace = ParsedNamespace(name: "", functions: [], structs: [])

        while not .eof() {
            match .current() {
                Function => {
                    let function = .parse_function(FunctionLinkage::Internal)
                    parsed_namespace.functions.push(function)
                }
                Struct => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Struct)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Class => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Class)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Struct)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        Class => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Class)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unrecognized token in namespace (probably not implemented yet)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    public function parse_struct(mut this, anon definition_linkage: DefinitionLinkage, anon definition_type: DefinitionType) throws -> ParsedStruct {
        mut parsed_struct = ParsedStruct(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            fields: [],
            methods: [],
            definition_linkage,
            definition_type,
        )

        let definition_type_name = match definition_type {
            Struct => "struct"
            Class => "class"
        }

        let default_visibility = match definition_type {
            Struct => Visibility::Public
            Class => Visibility::Private
        }

        .index++

        // Struct name
        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        let struct_name = match .current() {
            Identifier(name) => name
            else => {
                .error(format("Invalid {} name", definition_type_name), .current().span())
                return parsed_struct
            }
        }
        parsed_struct.name = struct_name
        parsed_struct.name_span = .current().span()

        .index++

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Struct body
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: JaktSpan? = None

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    break
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error(format("Invalid struct member, did not expect a {} here", token), token.span())
                }
            }
        }

        if .index == .tokens.size() {
            .error("Incomplete struct", .previous().span())
        }
        if .current() is RCurly {
            .index++
        } else {
            .error("Incomplete struct", .previous().span())
        }

        parsed_struct.fields = fields
        parsed_struct.methods = methods

        return parsed_struct
    }

    public function parse_function(mut this, anon linkage: FunctionLinkage) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            name: "",
            name_span: empty_span(),
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: JaktSpan(start: 0, end: 0)
            throws: false,
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma => {
                    .index++
                    current_param_requires_label = true
                }
                Anon => {
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .current().span(),
                    ))
                    .index++
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .previous().span(),
                    ))
                }
                else => {
                    .error("Expected parameter", .current().span())
                }
            }
        }

        parsed_function.params = params

        // NOTE: main() always throws
        if function_name == "main" {
            parsed_function.throws = true
        } else if .current() is Throws {
            parsed_function.throws = true
            .index++
        }

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedMethod {
        let parsed_function = .parse_function(linkage)

        // TODO: The bootstrap compiler sets parsed_function.must_instantiate here if the linkage is External.
        //       Do we still need to do that?

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mut this) throws -> ParsedType {
        mut parsed_type = .parse_type_shorthand()

        if not parsed_type is Empty {
            return parsed_type
        }

        let start = .current().span()

        parsed_type = match .current() {
            Raw => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
                yield match inner {
                    Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                    else => ParsedType::RawPtr(inner, span)
                }
            }
            Weak => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
                yield match inner {
                    Optional(inner) => ParsedType::WeakPtr(inner, span)
                    else => {
                        .error("missing `?` after weak pointer type name", span)
                        yield ParsedType::WeakPtr(inner, span)
                    }
                }
            }
            Identifier(name) => {
                let span = .current().span()
                .index++
                yield ParsedType::Name(name, span)
            }
            else => {
                .error("Expected type name", .current().span())
                yield ParsedType::Empty
            }
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        return parsed_type
    }

    function parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                if .current() is Colon {
                    .index++
                } else {
                    return ParsedVarDecl(
                        name: var_name,
                        parsed_type: ParsedType::Empty,
                        is_mutable,
                        span: .previous().span(),
                    )
                }

                let decl_span = .previous().span()

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        let inner = .parse_typename()
        .index++
        if .current() is RCurly {
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            types.push(.parse_typename())
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", merge_spans(start, .current().span()))
        return block
    }

    function parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        println("parse_statement: {}", .current())
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                yield ParsedStatement::Defer(.parse_statement(inside_block: false))
            }
            Unsafe => {
                .index++
                yield ParsedStatement::UnsafeBlock(.parse_block())
            }
            Break => {
                .index++
                yield ParsedStatement::Break
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue
            }
            Loop => {
                .index++
                yield ParsedStatement::Loop(.parse_block())
            }
            Throw => {
                .index++
                yield ParsedStatement::Throw(.parse_expression(allow_assignments: false))
            }
            While => {
                .index++
                let guard = .parse_expression(allow_assignments: false)
                let block = .parse_block()
                yield ParsedStatement::While(guard, block)
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr)
            }
            Return => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                yield ParsedStatement::Return(expr, span: merge_spans(start, .previous().span()))
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++
                let var = .parse_variable_declaration(is_mutable)

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init)
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            Try => .parse_try_statement()
            LCurly => ParsedStatement::Block(.parse_block())
            else => ParsedStatement::Expression(.parse_expression(allow_assignments: true))
        }
    }

    function parse_try_statement(mut this) throws -> ParsedStatement {
        .index++

        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            match .current() {
                Identifier(name) => {
                    error_span = .current().span()
                    error_name = name
                    .index++
                }
                else => { }
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedStatement::Try(stmt, error_name, error_span, catch_block)
    }

    function parse_for_statement(mut this) throws -> ParsedStatement {
        .index++

        return match .current() {
            Identifier(name) => {
                let iterator_name = name
                let name_span = .current().span()
                .index++
                if .current() is In {
                    .index++
                } else {
                    .error("Expected ‘in’", .current().span())
                    return ParsedStatement::Garbage
                }

                let range = .parse_expression(allow_assignments: false)
                let block = .parse_block();

                yield ParsedStatement::For(iterator_name, name_span, range, block)
            }
            else => {
                .error("Expected iterator name", .current().span())
                yield ParsedStatement::Garbage
            }
        }
    }

    function parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false)
        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        if .current() is Else {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    // FIXME: Lint: check that ‘if’ and ‘else’ blocks are not the same.
                    else_statement = ParsedStatement::Block(.parse_block())
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement)
    }

    function parse_expression(mut this, allow_assignments: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eol() {
            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = parsed_operator.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match parsed_operator {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => panic("operator is not an operator")
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => panic("operator is not an operator")
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mut this) throws -> ParsedExpression {
        let span = .current().span()
        match .current() {
            Dot => {
                return ParsedExpression::Var(name: "this", span)
            }
            QuotedString(quote, span) => {
                .index++
                return ParsedExpression::QuotedString(val: quote, span)
            }
            SingleQuotedString(quote, span) => {
                .index++
                return ParsedExpression::SingleQuotedString(val: quote, span)
            }
            SingleQuotedByteString(quote, span) => {
                .index++
                return ParsedExpression::SingleQuotedByteString(val: quote, span)
            }
            Number(number, span) => {
                .index++
                return ParsedExpression::NumericConstant(val: number, span)
            }
            True => {
                .index++
                return ParsedExpression::Boolean(val: true, span)
            }
            False => {
                .index++
                return ParsedExpression::Boolean(val: false, span)
            }
            Not => {
                let start = .current().span()
                .index++
                let expr = .parse_operand()
                let span = merge_spans(start, expr.span())
                return ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
            }
            Identifier(name) => {
                match .peek(1) {
                    LParen => {
                        match name {
                            "Some" => {
                                .index++
                                println("{}", .current())
                                let expr = .parse_expression(allow_assignments: false)
                                return ParsedExpression::OptionalSome(expr, span)
                            }
                            else => {
                                let call = .parse_call()
                                return ParsedExpression::Call(call, span)
                            }
                        }
                       
                    }
                    LessThan => {
                        todo("parse_operand_base generics")
                        .index++
                        return ParsedExpression::Garbage(span)
                    }
                    else => {
                        .index++
                        match name {
                            "None" => {
                                return ParsedExpression::OptionalNone(span)
                            }
                            else => {
                                return ParsedExpression::Var(name, span)
                            }
                        }
                    }
                }

                .index++
                return ParsedExpression::Var(name, span)
            }
            LParen => {
                .index++

                let expr = .parse_expression(allow_assignments: false)
                match .current() {
                    RParen => {
                        .index++
                    }
                    Comma => {
                        todo("parse_operand_base tuple")
                    }
                    else => {
                        .error("Expected ')'", .current().span())
                    }
                }

                return expr
            }
            LSquare => {
                return .parse_array_or_dictionary_literal()
            }
            Match => {
                return .parse_match_expression()
            }
            else => { }
        }
        return ParsedExpression::Garbage(span)
    }

    function parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let span = .current().span()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()

        // Check for postfix operators, while we're at it
        return match .current() {
            DotDot => {
                .index++
                let to = .parse_expression(allow_assignments: false)
                yield ParsedExpression::Range(from: expr, to, span: merge_spans(start, to.span()))
            }
            ExclamationPoint => {
                .index++
                yield ParsedExpression::ForcedUnwrap(expr, span: merge_spans(start, .previous().span()))
            }
            PlusPlus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostIncrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            MinusMinus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostDecrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            Is => {
                .index++
                let parsed_type = .parse_typename()
                let span = merge_spans(start, .current().span())
                yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(parsed_type), span)
            }
            ColonColon => {
                todo("postfix ColonColon")
                yield ParsedExpression::Garbage(span)
            }
            Dot => {
                .index++
                yield match .current() {
                    Number(number) => {
                        // Indexing into a tuple
                        .index++
                        // FIXME: Proper numeric constants.
                        yield ParsedExpression::IndexedTuple(expr, index: number as! usize, span: merge_spans(start, end: .previous().span()))
                    }
                    Identifier(name) => {
                        // Struct field access or method call
                        .index++
                        yield match .current() {
                            LParen => {
                                // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                .index--
                                let call = .parse_call()
                                yield ParsedExpression::MethodCall(expr, call, span: merge_spans(start, end: .previous().span()))
                            }
                            else => ParsedExpression::IndexedStruct(expr, field: name, span: merge_spans(start, end: .current().span()))
                        }
                    }
                    else => {
                        .error("Unsupported dot operation", .current().span())
                        .index++
                        yield expr
                    }
                }
            }
            LSquare => {
                // Indexing operation
                .index++
                let index_expr = .parse_expression(allow_assignments: false)
                if .current() is RSquare {
                    .index++
                } else {
                    .error("Expected ']'", .current().span())
                }
                yield ParsedExpression::IndexedExpression(
                    base: expr,
                    index: index_expr,
                    span: merge_spans(start, .current().span()))
            }
            else => expr
        }
    }

    function parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let expr = .parse_expression(allow_assignments: false)
        let cases = .parse_match_cases()

        return ParsedExpression::Match(expr, cases, span: merge_spans(start, .previous().span()))
    }

    function parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            let marker_span = .current().span()
            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false))
            }

            cases.push(ParsedMatchCase(patterns, marker_span, body))

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    function parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            let pattern = .parse_match_pattern()
            patterns.push(pattern)
            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    function parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | SingleQuotedByteString
        | LParen => ParsedMatchPattern::Expression(.parse_expression(allow_assignments: false))

        Else => {
            .index++
            yield ParsedMatchPattern::CatchAll
        }

        Identifier(name) => {
            let pattern_start_index = .index
            mut variant_name: [(String, JaktSpan)] = []

            while .current() is Identifier {
                .index++
                variant_name.push((name, .current().span()))
                if .current() is ColonColon {
                    .index++
                } else {
                    break
                }
            }

            mut variant_arguments: [EnumVariantPatternArgument] = []
            mut has_parens = false
            let arguments_start = .current().span()

            if .current() is LParen {
                has_parens = true
                .index++

                while not .eof() {
                    match .current() {
                        Identifier(name) => {
                            let arg_name = name
                            if .peek(1) is Colon {
                                .index++
                                match .current() {
                                    Identifier(name) => {
                                        let arg_binding = name
                                        let span = .current().span()
                                        .index++
                                        variant_arguments.push(EnumVariantPatternArgument(
                                            name: Some(arg_name)
                                            binding: arg_binding
                                            span))
                                    }
                                    else => {
                                        .error("Expected binding after ‘:’", .current().span())
                                    }
                                }
                            } else {
                                // FIXME: Hack since compiler doesn't recognize `None` in tuple.
                                let none: String? = None
                                variant_arguments.push(EnumVariantPatternArgument(
                                            name: none
                                            binding: arg_name
                                            span: .current().span()))
                            }
                        }
                        RParen => {
                            .index++
                            break
                        }
                        else => {
                            .error("Expected pattern argument name", .current().span())
                            break
                        }
                    }
                }
            }

            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                variant_name
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::CatchAll
        }
    }

    function parse_call(mut this) throws -> ParsedCall {
        mut call = ParsedCall(
            name: "",
            args: [],
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                if .current() is LessThan {
                    todo("parse_call generics")
                }

                if .current() is LParen {
                    .index++
                } else {
                    .error("Expected '('", .current().span())
                }

                while  not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            break
                        }
                        Eol | Comma => {
                            .index++
                        }
                        else => {
                            let param_name = .parse_argument_label()

                            let expr = .parse_expression(allow_assignments: false)
                            call.args.push((param_name, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mut this) throws -> [[String:JaktSpan]] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [[String:JaktSpan]] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push([name : span])
                    .index++
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                else => {
                    .error("expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mut this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        if not .peek(1) is Colon {
            return ""
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        mut whitelist: [ParsedType] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false);
                    } else {
                        .error("Can't fill array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: JaktSpan)
}

// Checked Types
struct VarId {
    id: usize
}

struct FunctionId {
    id: usize
}

struct StructId {
    id: usize
}

struct EnumId {
    id: usize
}

struct TypeId {
    id: usize
}

struct InferenceId {
    id: usize
}

struct ScopeId {
    id: usize
}

enum BuiltinType: usize {
    Void = 0
    Bool = 1
    U8 = 2
    U16 = 3
    U32 = 4
    U64 = 5
    I8 = 6
    I16 = 7
    I32 = 8
    I64 = 9
    String = 10
    CChar = 11
    CString = 12
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    JaktString
    CChar
    CString
    TypeVariable(String)
    GenericInstance(orig: StructId, params: [TypeId])
    GenericEnumInstance(orig: EnumId, params: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    Inference(InferenceId)
    RawPtr(TypeId)
}

struct Scope {
    namespace_name: String?
    vars: [String: VarId]
    structs: [String: StructId]
    functions: [String: FunctionId]
    enums: [String: EnumId]
    types: [String: TypeId]
    parent: ScopeId
    children: [ScopeId]
    throws: bool
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

struct CheckedFunction {
    name: String
    return_type_id: TypeId
    params: [CheckedParameter]
    block: CheckedBlock
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

struct CheckedVariable {
    var_id: VarId
    definition_span: JaktSpan
}

struct CheckedVarDecl {
    name: String
    var_type_id: TypeId
    is_mutable: bool
    span: JaktSpan
}

struct CheckedBlock {
    statements: [CheckedStatement]
    definitely_returns: bool
}

struct CheckedStruct {
    name: String
    name_span: JaktSpan
    generic_parameters: [TypeId]
    fields: [VarId]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
    type_id: TypeId
}

struct CheckedEnum {
    name: String
    name_span: JaktSpan
    generic_parameters: [TypeId]
    variants: [CheckedEnumVariant]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
    underlying_type_id: TypeId
    type_id: TypeId
}

enum CheckedEnumVariant {
    Untyped(name: String, span: JaktSpan)
    Typed(name: String, type_id: TypeId, span: JaktSpan)
    WithValue(name: String, expr: CheckedExpression, span: JaktSpan)
    StructLike(name: String, fields: [VarId], span: JaktSpan)
}

boxed enum CheckedStatement {
    Expression(CheckedExpression)
    Defer(CheckedStatement)
    VarDecl(var_id: VarId, init: CheckedExpression)
    If(guard: CheckedExpression, then_block: CheckedBlock, else_block: CheckedBlock?)
    Block(CheckedBlock)
    Loop(CheckedBlock)
    While(guard: CheckedExpression, block: CheckedBlock)
    Return(CheckedExpression)
    Break
    Continue
    Throw(CheckedExpression)
    Garbage
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(String)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: JaktSpan)
    NumericConstant(val: CheckedNumericConstant, span: JaktSpan, type_id: TypeId)
    QuotedString(val: String, span: JaktSpan)
    ByteConstant(val: String, span: JaktSpan)
    CharacterConstant(val: String, span: JaktSpan)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: JaktSpan, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: JaktSpan, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: JaktSpan, type_id: TypeId)
    Range(from: CheckedExpression, to: CheckedExpression, span: JaktSpan, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: JaktSpan, type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: JaktSpan, type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: JaktSpan, type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: JaktSpan, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: JaktSpan, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: JaktSpan, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: JaktSpan, type_id: TypeId)
    Call(call: CheckedCall, span: JaktSpan, type_id: TypeId)
}

// FIXME: not a method because of https://github.com/SerenityOS/jakt/issues/527
function expression_type(anon expr: CheckedExpression) -> TypeId => match expr {
    Boolean(val, span) => TypeId(id: BuiltinType::Bool as! usize)
    NumericConstant(val, span, type_id) => type_id
    QuotedString(val, span) => TypeId(id: BuiltinType::String as! usize)
    ByteConstant(val, span) => TypeId(id: BuiltinType::U8 as! usize)
    CharacterConstant(val, span) => TypeId(id: BuiltinType::CChar as! usize)
    UnaryOp(expr, op, span, type_id) => type_id
    BinaryOp(lhs, op, rhs, span, type_id) => type_id
    JaktTuple(vals, span, type_id) => type_id
    Range(from, to, span, type_id) => type_id
    JaktArray(vals, repeat, span, type_id) => type_id
    JaktDictionary(vals, span, type_id) => type_id
    JaktSet(vals, span, type_id) => type_id
    IndexedExpression(expr, index, span, type_id) => type_id
    IndexedDictionary(expr, index, span, type_id) => type_id
    IndexedTuple(expr, index, span, type_id) => type_id
    IndexedStruct(expr, index, span, type_id) => type_id
    Call(call, span, type_id) => type_id
}

// FIXME: not a method because of https://github.com/SerenityOS/jakt/issues/527
function expression_span(anon expr: CheckedExpression) -> JaktSpan => match expr {
    Boolean(val, span) => span
    NumericConstant(val, span, type_id) => span
    QuotedString(val, span) => span
    ByteConstant(val, span) => span
    CharacterConstant(val, span) => span
    UnaryOp(expr, op, span, type_id) => span
    BinaryOp(lhs, op, rhs, span, type_id) => span
    JaktTuple(vals, span, type_id) => span
    Range(from, to, span, type_id) => span
    JaktArray(vals, repeat, span, type_id) => span
    JaktDictionary(vals, span, type_id) => span
    JaktSet(vals, span, type_id) => span
    IndexedExpression(expr, index, span, type_id) => span
    IndexedDictionary(expr, index, span, type_id) => span
    IndexedTuple(expr, index, span, type_id) => span
    IndexedStruct(expr, index, span, type_id) => span
    Call(call, span, type_id) => span
}

struct CheckedCall {
    name: String,
    args: [(String, CheckedExpression)]
    return_type: TypeId
}

struct Typechecker {
    functions: [CheckedFunction]
    variables: [CheckedVarDecl]
    structures: [CheckedStruct]
    enums: [CheckedEnum]
    scopes: [Scope]
    inferences: [TypeId]
    types: [Type]

    errors: [JaktError]

    function get_function(this, anon id: FunctionId) -> CheckedFunction => .functions[id.id]
    function get_variable(this, anon id: VarId) -> CheckedVarDecl => .variables[id.id]

    function error(mut this, anon message: String, anon span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: JaktSpan, anon hint: String, anon hint_span: JaktSpan) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function typecheck_expression(mut this, anon expr: ParsedExpression, scope_id: ScopeId) throws -> CheckedExpression => match expr {
        Boolean(val, span) => CheckedExpression::Boolean(val, span)
        NumericConstant(val, span) => {
            // FIXME: better constant support
            yield CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: TypeId(id: BuiltinType::I64 as! usize))
        }
        QuotedString(val, span) => CheckedExpression::QuotedString(val, span)
        Call(call, span) => .typecheck_call(call, scope_id, span)
        Range(from, to, span) => {
            let checked_from = .typecheck_expression(from, scope_id)
            let checked_to = .typecheck_expression(to, scope_id)

            let from_type = expression_type(checked_from)
            let to_type = expression_type(checked_to)

            // FIXME: add unification
            if from_type.id != to_type.id {
                .error("type mismatch with 'from' of range'", expression_span(checked_to))
            }

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id: from_type)
        } else => {
            panic("not complete")

            yield CheckedExpression::Boolean(val: false, span: JaktSpan(start: 0, end: 0))
        }
    }

    function typecheck_call(mut this, call: ParsedCall, scope_id: ScopeId, span: JaktSpan) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = TypeId(id: BuiltinType::Void as! usize)

        match call.name {
            "print" | "println" | "eprintln" | "format" => {
                for arg in call.args.iterator() {
                    let checked_arg = .typecheck_expression(expr: arg.1, scope_id)

                    args.push((call.name, checked_arg))
                }
            }
            else => {

            }
        }

        return CheckedExpression::Call(call: CheckedCall(name: call.name, args, return_type), span, type_id: return_type)
    }
}

function main(args: [String]) {
    if args.size() <= 1 {
        eprintln("usage: jakt <path>")
        return 1
    }

    mut file = File::open_for_reading(args[1])
    let file_contents = file.read_all()

    mut lexer = Lexer(index: 0, input: file_contents, errors: [])
    mut tokens: [Token] = []

    for token in lexer {
        println("token: {}", token)
        tokens.push(token)
    }

    mut parser = Parser(index: 0, tokens, errors: [])

    let parsed_namespace = parser.parse_namespace()

    for error in lexer.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    for error in parser.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    if not lexer.errors.is_empty() or not parser.errors.is_empty() {
        return 1
    }

    println("{}", parsed_namespace)
}
