/// Expect:
/// - output: ""

extern struct StringBuilder {
    function append(mutable this, anon s: u8)
    function to_string(mutable this) throws -> String
    function StringBuilder() -> StringBuilder
}

extern function abort()

function todo(anon message: String) {
    eprintln("TODO: {}", message)
    abort()
}

function panic(anon message: String) -> void {
    eprintln("internal error: {}", message)
    abort()
}

// FIXME: These should not need explicit "-> bool" return types.
function is_ascii_alpha(anon c: u8) -> bool => (c >= b'a' and c <= b'z') or (c >= b'A' and c <= b'Z')
function is_ascii_digit(anon c: u8) -> bool => (c >= b'0' and c <= b'9')
function is_ascii_hexdigit(anon c: u8) -> bool => (c >= b'0' and c <= b'9') or (c >= b'a' and c <= b'f') or (c >= b'A' and c <= b'F')
function is_ascii_alphanumeric(anon c: u8) -> bool => is_ascii_alpha(c) or is_ascii_digit(c)

//FIXME: Would be nice to name this Span and not have conflict
struct JaktSpan {
    start: usize
    end: usize
}

function merge_spans(anon start: JaktSpan, anon end: JaktSpan) -> JaktSpan => JaktSpan(start: start.start, end: end.end)
function empty_span() -> JaktSpan => JaktSpan(start: 0, end: 0)

enum Token {
    SingleQuotedString(quote: String, span: JaktSpan)
    SingleQuotedByteString(quote: String, span: JaktSpan)
    QuotedString(quote: String, span: JaktSpan)
    Number(number: i64, span: JaktSpan)
    Identifier(name: String, span: JaktSpan)
    Semicolon(JaktSpan)
    Colon(JaktSpan)
    ColonColon(JaktSpan)
    LParen(JaktSpan)
    RParen(JaktSpan)
    LCurly(JaktSpan)
    RCurly(JaktSpan)
    LSquare(JaktSpan)
    RSquare(JaktSpan)
    PercentSign(JaktSpan)
    Plus(JaktSpan)
    Minus(JaktSpan)
    Equal(JaktSpan)
    PlusEqual(JaktSpan)
    PlusPlus(JaktSpan)
    MinusEqual(JaktSpan)
    MinusMinus(JaktSpan)
    AsteriskEqual(JaktSpan)
    ForwardSlashEqual(JaktSpan)
    PercentSignEqual(JaktSpan)
    NotEqual(JaktSpan)
    DoubleEqual(JaktSpan)
    GreaterThan(JaktSpan)
    GreaterThanOrEqual(JaktSpan)
    LessThan(JaktSpan)
    LessThanOrEqual(JaktSpan)
    LeftArithmeticShift(JaktSpan)
    LeftShift(JaktSpan)
    LeftShiftEqual(JaktSpan)
    RightShift(JaktSpan)
    RightArithmeticShift(JaktSpan)
    RightShiftEqual(JaktSpan)
    Asterisk(JaktSpan)
    Ampersand(JaktSpan)
    AmpersandEqual(JaktSpan)
    Pipe(JaktSpan)
    PipeEqual(JaktSpan)
    Caret(JaktSpan)
    CaretEqual(JaktSpan)
    Dollar(JaktSpan)
    Tilde(JaktSpan)
    ForwardSlash(JaktSpan)
    ExclamationPoint(JaktSpan)
    QuestionMark(JaktSpan)
    QuestionMarkQuestionMark(JaktSpan)
    QuestionMarkQuestionMarkEqual(JaktSpan)
    Comma(JaktSpan)
    Dot(JaktSpan)
    DotDot(JaktSpan)
    Eol(JaktSpan)
    Eof(JaktSpan)
    FatArrow(JaktSpan)
    Arrow(JaktSpan)

    // Keywords
    And(JaktSpan)
    Anon(JaktSpan)
    Boxed(JaktSpan)
    Break(JaktSpan)
    Catch(JaktSpan)
    Class(JaktSpan)
    Continue(JaktSpan)
    Cpp(JaktSpan)
    Defer(JaktSpan)
    Else(JaktSpan)
    Enum(JaktSpan)
    Extern(JaktSpan)
    False(JaktSpan)
    For(JaktSpan)
    Function(JaktSpan)
    If(JaktSpan)
    In(JaktSpan)
    Is(JaktSpan)
    Let(JaktSpan)
    Loop(JaktSpan)
    Match(JaktSpan)
    Mutable(JaktSpan)
    Not(JaktSpan)
    Or(JaktSpan)
    Private(JaktSpan)
    Public(JaktSpan)
    Raw(JaktSpan)
    Return(JaktSpan)
    Restricted(JaktSpan)
    Struct(JaktSpan)
    This(JaktSpan)
    Throw(JaktSpan)
    Throws(JaktSpan)
    True(JaktSpan)
    Try(JaktSpan)
    Unsafe(JaktSpan)
    Weak(JaktSpan)
    While(JaktSpan)
    Yield(JaktSpan)

    // Catch-all for failed parses
    Garbage(JaktSpan)

    public function span(this) => match this {
        SingleQuotedString(quote, span) => span
        SingleQuotedByteString(quote, span) => span
        QuotedString(quote, span) => span
        Number(number, span) => span
        Identifier(name, span) => span
        Semicolon(span) => span
        Colon(span) => span
        ColonColon(span) => span
        Cpp(span) => span
        LParen(span) => span
        RParen(span) => span
        LCurly(span) => span
        RCurly(span) => span
        LSquare(span) => span
        RSquare(span) => span
        PercentSign(span) => span
        Plus(span) => span
        Minus(span) => span
        Equal(span) => span
        PlusEqual(span) => span
        PlusPlus(span) => span
        MinusEqual(span) => span
        MinusMinus(span) => span
        Arrow(span) => span
        AsteriskEqual(span) => span
        ForwardSlashEqual(span) => span
        PercentSignEqual(span) => span
        NotEqual(span) => span
        DoubleEqual(span) => span
        GreaterThan(span) => span
        GreaterThanOrEqual(span) => span
        LessThan(span) => span
        LessThanOrEqual(span) => span
        LeftArithmeticShift(span) => span
        LeftShift(span) => span
        LeftShiftEqual(span) => span
        RightShift(span) => span
        RightArithmeticShift(span) => span
        RightShiftEqual(span) => span
        Asterisk(span) => span
        Ampersand(span) => span
        AmpersandEqual(span) => span
        Pipe(span) => span
        PipeEqual(span) => span
        Caret(span) => span
        CaretEqual(span) => span
        Dollar(span) => span
        Tilde(span) => span
        ForwardSlash(span) => span
        ExclamationPoint(span) => span
        QuestionMark(span) => span
        QuestionMarkQuestionMark(span) => span
        QuestionMarkQuestionMarkEqual(span) => span
        Comma(span) => span
        Dot(span) => span
        DotDot(span) => span
        Eol(span) => span
        Eof(span) => span
        FatArrow(span) => span
        And(span) => span
        Anon(span) => span
        Boxed(span) => span
        Break(span) => span
        Catch(span) => span
        Class(span) => span
        Continue(span) => span
        Defer(span) => span
        Else(span) => span
        Enum(span) => span
        Extern(span) => span
        False(span) => span
        For(span) => span
        Function(span) => span
        If(span) => span
        In(span) => span
        Is(span) => span
        Let(span) => span
        Loop(span) => span
        Match(span) => span
        Mutable(span) => span
        Not(span) => span
        Or(span) => span
        Private(span) => span
        Public(span) => span
        Raw(span) => span
        Restricted(span) => span
        Return(span) => span
        Struct(span) => span
        This(span) => span
        Throw(span) => span
        Throws(span) => span
        True(span) => span
        Try(span) => span
        Unsafe(span) => span
        Weak(span) => span
        While(span) => span
        Yield(span) => span
        Garbage(span) => span
    }

    function from_keyword_or_identifier(string: String, span: JaktSpan) => match string {
        "and" => Token::And(span)
        "anon" => Token::Anon(span)
        "boxed" => Token::Boxed(span)
        "break" => Token::Break(span)
        "catch" => Token::Catch(span)
        "class" => Token::Class(span)
        "continue" => Token::Continue(span)
        "cpp" => Token::Cpp(span)
        "defer" => Token::Defer(span)
        "else" => Token::Else(span)
        "enum" => Token::Enum(span)
        "extern" => Token::Extern(span)
        "false" => Token::False(span)
        "for" => Token::For(span)
        "function" => Token::Function(span)
        "if" => Token::If(span)
        "in" => Token::In(span)
        "is" => Token::Is(span)
        "let" => Token::Let(span)
        "loop" => Token::Loop(span)
        "match" => Token::Match(span)
        "mutable" => Token::Mutable(span)
        "not" => Token::Not(span)
        "or" => Token::Or(span)
        "private" => Token::Private(span)
        "public" => Token::Public(span)
        "raw" => Token::Raw(span)
        "return" => Token::Return(span)
        "restricted" => Token::Restricted(span)
        "struct" => Token::Struct(span)
        "this" => Token::This(span)
        "throw" => Token::Throw(span)
        "throws" => Token::Throws(span)
        "true" => Token::True(span)
        "try" => Token::Try(span)
        "unsafe" => Token::Unsafe(span)
        "weak" => Token::Weak(span)
        "while" => Token::While(span)
        "yield" => Token::Yield(span)
        else => Token::Identifier(name: string, span)
    }
}

enum JaktError {
    Message(message: String, span: JaktSpan)
    MessageWithHint(message: String, span: JaktSpan, hint: String, hint_span: JaktSpan)
}

struct Lexer {
    index: usize
    input: [u8]
    errors: [JaktError]

    function error(mutable this, anon message: String, anon span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    // Peek at next upcoming character
    function peek(this) -> u8 {
        if .eof() {
            return 0
        }
        return .input[.index]
    }

    // Peek at upcoming characters, N steps ahead in the stream
    // FIXME: This could be merged with peek() once we support default arguments
    function peek_ahead(this, anon steps: usize) -> u8 {
        if .index + steps >= .input.size() {
            return 0
        }
        return .input[.index + steps]
    }

    function eof(this) -> bool {
        return .index >= .input.size()
    }

    function substring(this, start: usize, length: usize) throws -> String {
        let mutable builder = StringBuilder()
        for i in start..length {
            builder.append(.input[i])
        }
        return builder.to_string()
    }

    function lex_character_constant_or_name(mutable this) throws -> Token {
        if .peek_ahead(1) != b'\'' {
            return .lex_number_or_name()
        }

        let is_byte = .peek() == b'b'
        if is_byte {
            .index++
        }

        let start = .index
        .index++

        let mutable escaped = false;

        while not .eof() and (escaped or .peek() != b'\'') {
            if not escaped and .peek() == b'\\' {
                escaped = true
            } else {
                escaped = false
            }

            .index++
        }

        if .eof() or .peek() != b'\'' {
            .error("expected single quote", JaktSpan(start, end: start))
        }

        // Everything but the quotes
        let mutable builder = StringBuilder()
        builder.append(.input[start + 1])
        let str = builder.to_string()

        .index++

        let end = .index

        if is_byte {
            return Token::SingleQuotedByteString(quote: str, span: JaktSpan(start, end))
        }
        return Token::SingleQuotedString(quote: str, span: JaktSpan(start, end))
    }

    function lex_number_or_name(mutable this) throws -> Token {
        let start = .index

        if .eof() {
            .error("unexpected eof", JaktSpan(start, end: start))
            return Token::Garbage(JaktSpan(start, end: start))
        }
        if is_ascii_digit(.peek()) {
            let mutable total = 0i64

            while is_ascii_digit(.peek()) {
                let value = .input[.index]
                ++.index
                let digit: i64 = as_saturated(value - b'0')
                total = total * 10 + digit
            }
            let end = .index
            return Token::Number(number: total, span: JaktSpan(start, end))
        } else if is_ascii_alpha(.peek()) or .peek() == b'_' {
            let mutable string_builder = StringBuilder()

            while is_ascii_alphanumeric(.peek()) or .peek() == b'_' {
                let value = .input[.index]
                ++.index
                string_builder.append(value)
            }
            let end = .index
            let span = JaktSpan(start, end)
            let string = string_builder.to_string()

            return Token::from_keyword_or_identifier(string, span)
        }

        let unknown_char = .input[.index]
        let end = ++.index
        .error(format("unknown character: {:c}", unknown_char), JaktSpan(start, end))
        return Token::Garbage(JaktSpan(start, end))
    }

    function lex_quoted_string(mutable this, delimiter: u8) throws -> Token {
        let start = .index

        ++.index

        if .eof() {
            .error("unexpected eof", JaktSpan(start, end: start))
            return Token::Garbage(JaktSpan(start, end: start))
        }

        let mutable escaped = false
        while not .eof() and (escaped or .peek() != delimiter) {
            if not escaped and .peek() == b'\\' {
                escaped = true
            } else {
                escaped = false
            }
            ++.index
        }

        let end = .index

        let str = .substring(start: start + 1, length: .index)

        .index++

        if delimiter == b'\'' {
            return Token::SingleQuotedString(quote: str, span: JaktSpan(start, end))
        }

        return Token::QuotedString(quote: str, span: JaktSpan(start, end))
    }

    function lex_plus(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::PlusEqual(JaktSpan(start, end: ++.index))
            b'+' => Token::PlusPlus(JaktSpan(start, end: ++.index))
            else => Token::Plus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_minus(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::MinusEqual(JaktSpan(start, end: ++.index))
            b'-' => Token::MinusMinus(JaktSpan(start, end: ++.index))
            b'>' => Token::Arrow(JaktSpan(start, end: ++.index))
            else => Token::Minus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_asterisk(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::AsteriskEqual(JaktSpan(start, end: ++.index))
            else => Token::Asterisk(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_forward_slash(mutable this) throws -> Token {
        let start = .index++
        if .peek() == b'=' {
            return Token::ForwardSlashEqual(JaktSpan(start, end: ++.index))
        }
        if .peek() != b'/' {
            return Token::ForwardSlash(JaktSpan(start, end: .index))
        }
        // We're in a comment, swallow to end of line.
        while not .eof() {
            let c = .peek()
            .index++
            if c == b'\n' {
                break
            }
        }
        return .next() ?? Token::Eof(JaktSpan(start: .index, end: .index))
    }

    function lex_caret(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::CaretEqual(JaktSpan(start, end: ++.index))
            else => Token::Caret(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_pipe(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::PipeEqual(JaktSpan(start, end: ++.index))
            else => Token::Pipe(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_percent_sign(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::PercentSignEqual(JaktSpan(start, end: ++.index))
            else => Token::PercentSign(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_exclamation_point(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::NotEqual(JaktSpan(start, end: ++.index))
            else => Token::ExclamationPoint(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_ampersand(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::AmpersandEqual(JaktSpan(start, end: ++.index))
            else => Token::Ampersand(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_less_than(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::LessThanOrEqual(JaktSpan(start, end: ++.index))
            b'<' => Token::LeftShift(JaktSpan(start, end: ++.index))
            else => Token::LessThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_greater_than(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::GreaterThanOrEqual(JaktSpan(start, end: ++.index))
            b'>' => Token::RightShift(JaktSpan(start, end: ++.index))
            else => Token::GreaterThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_dot(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'.' => Token::DotDot(JaktSpan(start, end: ++.index))
            else => Token::Dot(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_colon(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b':' => Token::ColonColon(JaktSpan(start, end: ++.index))
            else => Token::Colon(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_question_mark(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'?' => {
                .index++
                yield match .peek() {
                    b'=' => Token::QuestionMarkQuestionMarkEqual(JaktSpan(start, end: ++.index))
                    else => Token::QuestionMarkQuestionMark(JaktSpan(start, end: .index))
                }
            }
            else => Token::QuestionMark(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_equals(mutable this) -> Token {
        let start = .index++
        return match .peek() {
            b'=' => Token::DoubleEqual(JaktSpan(start, end: ++.index))
            b'>' => Token::FatArrow(JaktSpan(start, end: ++.index))
            else => Token::Equal(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function next(mutable this) throws -> Token? {
        if .index == .input.size() {
            ++.index
            return Token::Eof(JaktSpan(start: .index - 1, end: .index - 1))
        }
        if .eof() {
            return None
        }
        loop {
            let ch = .peek()
            if ch == b' ' or ch == b'\t' or ch == b'\r' {
                .index++
            } else {
                break
            }
        }

        let start = .index

        return match .input[.index] {
            b'(' => Token::LParen(JaktSpan(start, end: ++.index))
            b')' => Token::RParen(JaktSpan(start, end: ++.index))
            b'[' => Token::LSquare(JaktSpan(start, end: ++.index))
            b']' => Token::RSquare(JaktSpan(start, end: ++.index))
            b'{' => Token::LCurly(JaktSpan(start, end: ++.index))
            b'}' => Token::RCurly(JaktSpan(start, end: ++.index))
            b'<' => .lex_less_than()
            b'>' => .lex_greater_than()
            b'.' => .lex_dot()
            b',' => Token::Comma(JaktSpan(start, end: ++.index))
            b'~' => Token::Tilde(JaktSpan(start, end: ++.index))
            b';' => Token::Semicolon(JaktSpan(start, end: ++.index))
            b':' => .lex_colon()
            b'?' => .lex_question_mark()
            b'+' => .lex_plus()
            b'-' => .lex_minus()
            b'*' => .lex_asterisk()
            b'/' => .lex_forward_slash()
            b'^' => .lex_caret()
            b'|' => .lex_pipe()
            b'%' => .lex_percent_sign()
            b'!' => .lex_exclamation_point()
            b'&' => .lex_ampersand()
            b'$' => Token::Dollar(JaktSpan(start, end: ++.index))
            b'=' => .lex_equals()
            b'\n' => Token::Eol(JaktSpan(start, end: ++.index))
            b'\'' => .lex_quoted_string(delimiter: b'\'')
            b'\"' => .lex_quoted_string(delimiter: b'"')
            b'b' => .lex_character_constant_or_name()
            b'c' => .lex_character_constant_or_name()
            else => .lex_number_or_name()
        }
    }
}

function print_error(file_name: String, file_contents: [u8], error: JaktError) throws {
    match error {
        Message(message, span) => {
            display_message_with_span(MessageSeverity::Error, file_name, file_contents, message, span)
        }
        MessageWithHint(message, span, hint, hint_span) => {
            display_message_with_span(MessageSeverity::Error, file_name, file_contents, message, span)
            display_message_with_span(MessageSeverity::Hint, file_name, file_contents, message: hint, span: hint_span)
        }
    }
}

enum MessageSeverity {
    Hint
    Error
}

function severity_name(severity: MessageSeverity) throws => match severity {
    Hint => "Hint"
    Error => "Error"
}

function ansi_color_code(severity: MessageSeverity) throws => match severity {
    Hint => "94"  // Bright Blue
    Error => "31" // Red
}

function display_message_with_span(anon severity: MessageSeverity, file_name: String, file_contents: [u8], message: String, span: JaktSpan) throws {
    println("{}: {}", severity_name(severity), message)

    let line_spans = gather_line_spans(file_contents)

    let mutable line_index = 1uz
    let largest_line_number = line_spans.size()

    let width = format("{}", largest_line_number).length()

    while line_index < line_spans.size() {
        if span.start >= line_spans[line_index].0 and span.start <= line_spans[line_index].1 {
            let column_index = span.start - line_spans[line_index].0

            println("----- \u001b[33m{}:{}:{}\u001b[0m", file_name, line_index + 1, column_index + 1)

            if line_index > 0 {
                print_source_line(severity, file_contents, file_span: line_spans[line_index - 1], error_span: span, line_number: line_index, largest_line_number)
            }

            print_source_line(severity, file_contents, file_span: line_spans[line_index], error_span: span, line_number: line_index + 1, largest_line_number)

            for x in 0..(span.start - line_spans[line_index].0 + width + 4) {
                print(" ")
            }

            println("\u001b[{}m^- {}\u001b[0m", ansi_color_code(severity), message)

            while line_index < line_spans.size() and span.end > line_spans[line_index].0 {
                ++line_index
                if line_index >= line_spans.size() {
                    break
                }

                print_source_line(severity, file_contents, file_span: line_spans[line_index], error_span: span, line_number: line_index + 1, largest_line_number)

                break
            }
        } else {
            ++line_index
        }

    }
    println("\u001b[0m-----")
}

function print_source_line(severity: MessageSeverity, file_contents: [u8], file_span: (usize, usize), error_span: JaktSpan, line_number: usize, largest_line_number: usize) throws {
    let mutable index = file_span.0

    let width = format("{}", largest_line_number).length()

    print(" {} | ", line_number)

    while index <= file_span.1 {
        let mutable c = b' '
        if index < file_span.1 {
            c = file_contents[index]
        } else if error_span.start == error_span.end and index == error_span.start {
            c = b'_'
        }

        if (index >= error_span.start and index < error_span.end) or (error_span.start == error_span.end and index == error_span.start) {
            print("\u001b[{}m{:c}", ansi_color_code(severity), c)
        } else {
            print("\u001b[0m{:c}", c)
        }

        ++index
    }
    println("")
}

function gather_line_spans(file_contents: [u8]) throws -> [(usize, usize)] {
    let mutable idx = 0uz
    let mutable output: [(usize, usize)] = []

    let mutable start = idx
    while idx < file_contents.size() {
        if file_contents[idx] == b'\n' {
            output.push((start, idx))
            start = idx + 1
        }
        idx += 1
    }
    if start < idx {
        output.push((start, idx))
    }

    return output
}

enum DefinitionLinkage {
    Internal
    External
}

enum DefinitionType {
    Class
    Struct
}

// Parsed Types
struct ParsedNamespace {
    name: String
    functions: [ParsedFunction]
    structs: [ParsedStruct]
}

struct ParsedStruct {
    name: String
    name_span: JaktSpan
    generic_parameters: [[String:JaktSpan]]
    fields: [ParsedField]
    methods: [ParsedMethod]
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
}

struct ParsedFunction {
    name: String
    name_span: JaktSpan
    params: [ParsedParameter]
    generic_parameters: [[String:JaktSpan]]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: JaktSpan
    throws: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    is_mutable: bool
    span: JaktSpan
}

struct ParsedBlock {
    stmts: [ParsedStatement]
}

boxed enum ParsedStatement {
    Expression(ParsedExpression)
    Defer(ParsedStatement)
    UnsafeBlock(ParsedBlock)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?)
    Block(ParsedBlock)
    Loop(ParsedBlock)
    While(guard: ParsedExpression, block: ParsedBlock)
    For(iterator_name: String, name_span: JaktSpan, range: ParsedExpression, block: ParsedBlock)
    Break
    Continue
    Return(expr: ParsedExpression, span: JaktSpan)
    Throw(ParsedExpression)
    Yield(ParsedExpression)
    InlineCpp(block: ParsedBlock, span: JaktSpan)
    Try(stmt: ParsedStatement, error_name: String, error_span: JaktSpan, catch_block: ParsedBlock)
    Garbage
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    Is(ParsedType)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: JaktSpan)
    NumericConstant(val: i64, span: JaktSpan)
    QuotedString(val: String, span: JaktSpan)
    Call(call: ParsedCall, span: JaktSpan)
    MethodCall(expr: ParsedExpression, call: ParsedCall, span: JaktSpan)
    IndexedTuple(expr: ParsedExpression, index: usize, span: JaktSpan)
    IndexedStruct(expr: ParsedExpression, field: String, span: JaktSpan)
    Var(name: String, span: JaktSpan)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: JaktSpan)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: JaktSpan)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: JaktSpan)
    Operator(op: BinaryOperator, span: JaktSpan)
    OptionalSome(expr: ParsedExpression, span: JaktSpan)
    OptionalNone(JaktSpan)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: JaktSpan)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: JaktSpan)
    Range(from: ParsedExpression, to: ParsedExpression, span: JaktSpan)
    ForcedUnwrap(expr: ParsedExpression, span: JaktSpan)
    Garbage(JaktSpan)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedCall {
    name: String,
    args: [(String, ParsedExpression)]
}

boxed enum ParsedType {
    Name(name: String, span: JaktSpan)
    JaktArray(inner: ParsedType, span: JaktSpan)
    Dictionary(key: ParsedType, value: ParsedType, span: JaktSpan)
    JaktTuple(types: [ParsedType], span: JaktSpan)
    Set(inner: ParsedType, span: JaktSpan)
    Optional(inner: ParsedType, span: JaktSpan)
    RawPtr(inner: ParsedType, span: JaktSpan)
    WeakPtr(inner: ParsedType, span: JaktSpan)
    Empty
}

struct Parser {
    index: usize
    tokens: [Token]
    errors: [JaktError]

    function error(mutable this, anon message: String, anon span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mutable this, anon message: String, anon span: JaktSpan, anon hint: String, anon hint_span: JaktSpan) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens[.tokens.size() - 1]
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(JaktSpan(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mutable this) throws -> ParsedNamespace {
        let mutable parsed_namespace = ParsedNamespace(name: "", functions: [], structs: [])

        while not .eof() {
            match .current() {
                Function => {
                    let function = .parse_function(FunctionLinkage::Internal)
                    parsed_namespace.functions.push(function)
                }
                Struct => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Struct)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Class => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Class)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Struct)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        Class => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Class)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unrecognized token in namespace (probably not implemented yet)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    public function parse_struct(mutable this, anon definition_linkage: DefinitionLinkage, anon definition_type: DefinitionType) throws -> ParsedStruct {
        let mutable parsed_struct = ParsedStruct(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            fields: [],
            methods: [],
            definition_linkage,
            definition_type,
        )

        let definition_type_name = match definition_type {
            Struct => "struct"
            Class => "class"
        }

        let default_visibility = match definition_type {
            Struct => Visibility::Public
            Class => Visibility::Private
        }

        .index++

        // Struct name
        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        let struct_name = match .current() {
            Identifier(name) => name
            else => {
                .error(format("Invalid {} name", definition_type_name), .current().span())
                return parsed_struct
            }
        }
        parsed_struct.name = struct_name
        parsed_struct.name_span = .current().span()

        .index++

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Struct body
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        let mutable fields: [ParsedField] = []
        let mutable methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        let mutable last_visibility: Visibility? = None
        let mutable last_visibility_span: JaktSpan? = None

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    break
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error(format("Invalid struct member, did not expect a {} here", token), token.span())
                }
            }
        }

        if .index == .tokens.size() {
            .error("Incomplete struct", .previous().span())
        }
        if .current() is RCurly {
            .index++
        } else {
            .error("Incomplete struct", .previous().span())
        }

        parsed_struct.fields = fields
        parsed_struct.methods = methods

        return parsed_struct
    }

    public function parse_function(mutable this, anon linkage: FunctionLinkage) throws -> ParsedFunction {
        let mutable parsed_function = ParsedFunction(
            name: "",
            name_span: empty_span(),
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: JaktSpan(start: 0, end: 0)
            throws: false,
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        let mutable params: [ParsedParameter] = []
        let mutable current_param_requires_label = true
        let mutable current_param_is_mutable = true

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma => {
                    .index++
                    current_param_requires_label = true
                }
                Anon => {
                    .index++
                    current_param_requires_label = false
                }
                Mutable => {
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .current().span(),
                    ))
                    .index++
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration()
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .previous().span(),
                    ))
                }
                else => {
                    .error("Expected parameter", .current().span())
                }
            }
        }

        parsed_function.params = params

        // NOTE: main() always throws
        if function_name == "main" {
            parsed_function.throws = true
        } else if .current() is Throws {
            parsed_function.throws = true
            .index++
        }

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mutable this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mutable this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration()

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mutable this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedMethod {
        let parsed_function = .parse_function(linkage)

        // TODO: The bootstrap compiler sets parsed_function.must_instantiate here if the linkage is External.
        //       Do we still need to do that?

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mutable this) throws -> ParsedType {
        let mutable parsed_type = .parse_type_shorthand()

        if not parsed_type is Empty {
            return parsed_type
        }

        let start = .current().span()

        parsed_type = match .current() {
            Raw => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
                yield match inner {
                    Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                    else => ParsedType::RawPtr(inner, span)
                }
            }
            Weak => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
                yield match inner {
                    Optional(inner) => ParsedType::WeakPtr(inner, span)
                    else => {
                        .error("missing `?` after weak pointer type name", span)
                        yield ParsedType::WeakPtr(inner, span)
                    }
                }
            }
            Identifier(name) => {
                let span = .current().span()
                .index++
                yield ParsedType::Name(name, span)
            }
            else => {
                .error("Expected type name", .current().span())
                yield ParsedType::Empty
            }
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        return parsed_type
    }

    function parse_variable_declaration(mutable this) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                if .current() is Colon {
                    .index++
                } else {
                    return ParsedVarDecl(
                        name: var_name,
                        parsed_type: ParsedType::Empty,
                        is_mutable: false,
                        span: .previous().span(),
                    )
                }

                let decl_span = .previous().span()

                // We have "name:" so far.
                let mutable is_mutable = false
                if .current() is Mutable {
                    .index++
                    is_mutable = true
                }

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_type_shorthand(mutable this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mutable this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mutable this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        let inner = .parse_typename()
        .index++
        if .current() is RCurly {
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mutable this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        let mutable types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            types.push(.parse_typename())
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mutable this) throws -> ParsedBlock {
        let start = .current().span()
        let mutable block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", merge_spans(start, .current().span()))
        return block
    }

    function parse_statement(mutable this, inside_block: bool) throws -> ParsedStatement {
        println("parse_statement: {}", .current())
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                yield ParsedStatement::Defer(.parse_statement(inside_block: false))
            }
            Unsafe => {
                .index++
                yield ParsedStatement::UnsafeBlock(.parse_block())
            }
            Break => {
                .index++
                yield ParsedStatement::Break
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue
            }
            Loop => {
                .index++
                yield ParsedStatement::Loop(.parse_block())
            }
            Throw => {
                .index++
                yield ParsedStatement::Throw(.parse_expression(allow_assignments: false))
            }
            While => {
                .index++
                let guard = .parse_expression(allow_assignments: false)
                let block = .parse_block()
                yield ParsedStatement::While(guard, block)
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr)
            }
            Return => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                yield ParsedStatement::Return(expr, span: merge_spans(start, .previous().span()))
            }
            Let => {
                .index++
                let is_mutable = match .current() {
                    Mutable => {
                        .index++
                        yield true
                    }
                    else => false
                }
                let mutable var = .parse_variable_declaration()
                var.is_mutable = is_mutable

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init)
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            Try => .parse_try_statement()
            LCurly => ParsedStatement::Block(.parse_block())
            else => ParsedStatement::Expression(.parse_expression(allow_assignments: true))
        }
    }

    function parse_try_statement(mutable this) throws -> ParsedStatement {
        .index++

        let stmt = .parse_statement(inside_block: false)

        let mutable error_name = ""
        let mutable error_span = .current().span()

        if .current() is Catch {
            .index++
            match .current() {
                Identifier(name) => {
                    error_span = .current().span()
                    error_name = name
                    .index++
                }
                else => { }
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedStatement::Try(stmt, error_name, error_span, catch_block)
    }

    function parse_for_statement(mutable this) throws -> ParsedStatement {
        .index++

        return match .current() {
            Identifier(name) => {
                let iterator_name = name
                let name_span = .current().span()
                .index++
                if .current() is In {
                    .index++
                } else {
                    .error("Expected ‘in’", .current().span())
                    return ParsedStatement::Garbage
                }

                let range = .parse_expression(allow_assignments: false)
                let block = .parse_block();

                yield ParsedStatement::For(iterator_name, name_span, range, block)
            }
            else => {
                .error("Expected iterator name", .current().span())
                yield ParsedStatement::Garbage
            }
        }
    }

    function parse_if_statement(mutable this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false)
        let then_block = .parse_block()

        let mutable else_statement: ParsedStatement? = None

        if .current() is Else {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    // FIXME: Lint: check that ‘if’ and ‘else’ blocks are not the same.
                    else_statement = ParsedStatement::Block(.parse_block())
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement)
    }

    function parse_expression(mutable this, allow_assignments: bool) throws -> ParsedExpression {
        let mutable expr_stack: [ParsedExpression] = []
        let mutable last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eol() {
            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = parsed_operator.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match parsed_operator {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => panic("operator is not an operator")
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => panic("operator is not an operator")
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mutable this) throws -> ParsedExpression {
        let span = .current().span()
        match .current() {
            Dot => {
                return ParsedExpression::Var(name: "this", span)
            }
            QuotedString(quote, span) => {
                .index++
                return ParsedExpression::QuotedString(val: quote, span)
            }
            Number(number, span) => {
                .index++
                return ParsedExpression::NumericConstant(val: number, span)
            }
            True => {
                .index++
                return ParsedExpression::Boolean(val: true, span)
            }
            False => {
                .index++
                return ParsedExpression::Boolean(val: false, span)
            }
            Not => {
                let start = .current().span()
                .index++
                let expr = .parse_operand()
                let span = merge_spans(start, expr.span())
                return ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
            }
            Identifier(name) => {
                match .peek(1) {
                    LParen => {
                        match name {
                            "Some" => {
                                .index++
                                println("{}", .current())
                                let expr = .parse_expression(allow_assignments: false)
                                return ParsedExpression::OptionalSome(expr, span)
                            }
                            else => {
                                let call = .parse_call()
                                return ParsedExpression::Call(call, span)
                            }
                        }
                       
                    }
                    LessThan => {
                        todo("parse_operand_base generics")
                        .index++
                        return ParsedExpression::Garbage(span)
                    }
                    else => {
                        .index++
                        match name {
                            "None" => {
                                return ParsedExpression::OptionalNone(span)
                            }
                            else => {
                                return ParsedExpression::Var(name, span)
                            }
                        }
                    }
                }

                .index++
                return ParsedExpression::Var(name, span)
            }
            LParen => {
                .index++

                let expr = .parse_expression(allow_assignments: false)
                match .current() {
                    RParen => {
                        .index++
                    }
                    Comma => {
                        todo("parse_operand_base tuple")
                    }
                    else => {
                        .error("Expected ')'", .current().span())
                    }
                }

                return expr
            }
            LSquare => {
                return .parse_array_or_dictionary_literal()
            }
            else => { }
        }
        return ParsedExpression::Garbage(span)
    }

    function parse_operand(mutable this) throws -> ParsedExpression {
        .skip_newlines()
        let span = .current().span()
        let start = .current().span()
        .skip_newlines()
        let mutable expr = .parse_operand_base()

        // Check for postfix operators, while we're at it
        return match .current() {
            DotDot => {
                .index++
                let to = .parse_expression(allow_assignments: false)
                yield ParsedExpression::Range(from: expr, to, span: merge_spans(start, to.span()))
            }
            ExclamationPoint => {
                .index++
                yield ParsedExpression::ForcedUnwrap(expr, span: merge_spans(start, .previous().span()))
            }
            PlusPlus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostIncrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            MinusMinus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostDecrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            Is => {
                .index++
                let parsed_type = .parse_typename()
                let span = merge_spans(start, .current().span())
                yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(parsed_type), span)
            }
            ColonColon => {
                todo("postfix ColonColon")
                yield ParsedExpression::Garbage(span)
            }
            Dot => {
                .index++
                yield match .current() {
                    Number(number) => {
                        // Indexing into a tuple
                        .index++
                        // FIXME: Proper numeric constants.
                        yield ParsedExpression::IndexedTuple(expr, index: number as! usize, span: merge_spans(start, end: .previous().span()))
                    }
                    Identifier(name) => {
                        // Struct field access or method call
                        .index++
                        yield match .current() {
                            LParen => {
                                // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                .index--
                                let call = .parse_call()
                                yield ParsedExpression::MethodCall(expr, call, span: merge_spans(start, end: .previous().span()))
                            }
                            else => ParsedExpression::IndexedStruct(expr, field: name, span: merge_spans(start, end: .current().span()))
                        }
                    }
                    else => {
                        .error("Unsupported dot operation", .current().span())
                        .index++
                        yield expr
                    }
                }
            }
            LSquare => {
                // Indexing operation
                .index++
                let index_expr = .parse_expression(allow_assignments: false)
                if .current() is RSquare {
                    .index++
                } else {
                    .error("Expected ']'", .current().span())
                }
                yield ParsedExpression::IndexedExpression(
                    base: expr,
                    index: index_expr,
                    span: merge_spans(start, .current().span()))
            }
            else => expr
        }
    }

    function parse_operator(mutable this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_call(mutable this) throws -> ParsedCall {
        let mutable call = ParsedCall(
            name: "",
            args: [],
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                if .current() is LessThan {
                    todo("parse_call generics")
                }

                if .current() is LParen {
                    .index++
                } else {
                    .error("Expected '('", .current().span())
                }

                while  not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            break
                        }
                        Eol | Comma => {
                            .index++
                        }
                        else => {
                            let param_name = .parse_argument_label()

                            let expr = .parse_expression(allow_assignments: false)
                            call.args.push((param_name, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mutable this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mutable this) throws -> [[String:JaktSpan]] {
        if not .current() is LessThan {
            return []
        }
        .index++
        let mutable generic_parameters: [[String:JaktSpan]] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push([name : span])
                    .index++
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                else => {
                    .error("expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mutable this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        if not .peek(1) is Colon {
            return ""
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mutable this) throws -> Visibility {
        let mutable restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        let mutable whitelist: [ParsedType] = []
        let mutable expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mutable this) throws -> ParsedExpression {
        let mutable is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        let mutable fill_size_expr: ParsedExpression? = None
        let mutable output: [ParsedExpression] = []
        let mutable dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false);
                    } else {
                        .error("Can't fill array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: JaktSpan)
}

// Checked Types
struct VarId {
    id: usize
}

struct FunctionId {
    id: usize
}

struct StructId {
    id: usize
}

struct EnumId {
    id: usize
}

struct TypeId {
    id: usize
}

struct InferenceId {
    id: usize
}

struct ScopeId {
    id: usize
}

struct Typechecker {
    functions: [CheckedFunction]
    variables: [CheckedVarDecl]
    structures: [CheckedStruct]

    function get_function(this, anon id: FunctionId) -> CheckedFunction => .functions[id.id]
    function get_variable(this, anon id: VarId) -> CheckedVarDecl => .variables[id.id]


}

struct Scope {
    namespace_name: String?
    vars: [String: VarId]
    structs: [String: StructId]
    functions: [String: FunctionId]
    enums: [String: EnumId]
    types: [String: TypeId]
    parent: ScopeId
    children: [ScopeId]
    throws: bool
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

struct CheckedFunction {
    name: String
    return_type_id: TypeId
    params: [CheckedParameter]
    block: CheckedBlock
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

struct CheckedVariable {
    var_id: VarId
    definition_span: JaktSpan
}

struct CheckedVarDecl {
    name: String
    var_type_id: TypeId
    is_mutable: bool
    span: JaktSpan
}

struct CheckedBlock {
    statements: [CheckedStatement]
    definitely_returns: bool
}

struct CheckedStruct {
    name: String
    name_span: JaktSpan
    generic_parameters: [TypeId]
    fields: [VarId]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
    type_id: TypeId
}

struct CheckedEnum {
    name: String
    name_span: JaktSpan
    generic_parameters: [TypeId]
    variants: [CheckedEnumVariant]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
    underlying_type_id: TypeId
    type_id: TypeId
}

enum CheckedEnumVariant {
    Untyped(name: String, span: JaktSpan)
    Typed(name: String, type_id: TypeId, span: JaktSpan)
    WithValue(name: String, expr: CheckedExpression, span: JaktSpan)
    StructLike(name: String, fields: [VarId], span: JaktSpan)
}

boxed enum CheckedStatement {
    Expression(CheckedExpression)
    Defer(CheckedStatement)
    VarDecl(var_id: VarId, init: CheckedExpression)
    If(guard: CheckedExpression, then_block: CheckedBlock, else_block: CheckedBlock?)
    Block(CheckedBlock)
    Loop(CheckedBlock)
    While(guard: CheckedExpression, block: CheckedBlock)
    Return(CheckedExpression)
    Break
    Continue
    Throw(CheckedExpression)
    Garbage
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(String)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: JaktSpan)
    Numeric(val: CheckedNumericConstant, span: JaktSpan, type_id: TypeId)
    QuotedString(val: String, span: JaktSpan)
    ByteConstant(val: String, span: JaktSpan)
    CharacterConstant(val: String, span: JaktSpan)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: JaktSpan, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: JaktSpan, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: JaktSpan, type_id: TypeId)
    Range(from: CheckedExpression, to: CheckedExpression, span: JaktSpan, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: JaktSpan, type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: JaktSpan, type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: JaktSpan, type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: JaktSpan, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: JaktSpan, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: JaktSpan, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: JaktSpan, type_id: TypeId)
    Call(call: CheckedCall, span: JaktSpan, type: usize)
}

struct CheckedCall {
    name: String,
    args: [(String, CheckedExpression)]
    return_type: usize
}



function main(args: [String]) {
    if args.size() <= 1 {
        eprintln("usage: jakt <path>")
        return 1
    }

    let mutable file = File::open_for_reading(args[1])
    let file_contents = file.read_all()

    let mutable lexer = Lexer(index: 0, input: file_contents, errors: [])
    let mutable tokens: [Token] = []

    for token in lexer {
        println("token: {}", token)
        tokens.push(token)
    }

    let mutable parser = Parser(index: 0, tokens, errors: [])

    let parsed_namespace = parser.parse_namespace()

    for error in lexer.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    for error in parser.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    if not lexer.errors.is_empty() or not parser.errors.is_empty() {
        return 1
    }

    println("{}", parsed_namespace)
}
