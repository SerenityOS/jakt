/// Expect:
/// - output: ""

// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
//
// SPDX-License-Identifier: BSD-2-Clause

import jakt::libc::io { system }
import jakt::arguments { ArgsParser }
import jakt::file_iterator { RecursiveFileIterator }
import jakt::path { Path, get_path_separator }
import jakt::platform { platform_fs, is_windows }

import build { Builder }
import compiler { Compiler }
import codegen { CodeGenerator }
import error { JaktError, print_error }
import formatter { Formatter }
import ide
import interpreter { Interpreter, InterpreterScope, value_to_checked_expression }
import lexer { Lexer, Token }
import parser { Parser }
import platform { library_name_for_target, platform_compiler }
import project { Project }
import repl { REPL, serialize_ast_node }
import typechecker { Typechecker }
import types { FunctionId, ResolvedNamespace, ScopeId, ModuleId, Value, ValueImpl }
import utility { FileId, Queue, Span, escape_for_quotes, join, write_to_file }
import git

import platform_fs() { DirectoryIterator, make_directory }

import platform_compiler() {
    run_compiler
}

import jakt::platform { Target }


fn usage() => "usage: jakt [cross] [-h] [OPTIONS] <filename>"
fn help() -> String {
    mut output = ""
    output += "Non-cross mode:\n"
    output += "= General:\n"
    output += "  -h,--help\t\t\t\tPrint this help and exit.\n"
    output += "  -v,--version\t\t\t\tPrint the compiler's version and exit.\n"
    output += "  -cr,--compile-run\t\t\tBuild and run an executable file.\n"
    output += "  -r,--run\t\t\t\tRun the given file without compiling it (all positional arguments after the file name will be passed to main).\n"
    output += "  --repl\t\t\t\tStart a Read-Eval-Print loop session.\n"
    output += "  --create NAME\t\t\t\tCreate sample project in $PWD/NAME\n"
    output += "= Compilation:\n"
    output += "  --config KEY=VALUE\t\t\tSet a user configuration value.\n"
    output += "  -c,--check-only\t\t\tOnly check the code for errors.\n"
    output += "  -d\t\t\t\t\tInsert debug statement spans in generated C++ code.\n"
    output += "  -O\t\t\t\t\tBuild an optimized executable.\n"
    output += "  -S,--emit-cpp-source-only\t\tOnly output source (do not build).\n"
    output += "  --ak-is-my-only-stdlib\t\tForget about interop, AK is the one and only STL.\n"
    output += "  --cxx-compiler-path PATH\t\tPath of the C++ compiler to use when compiling the generated sources.\n\t\t\t\t\tDefaults to clang++.\n"
    output += "  -M,--dep-file FILE\t\t\tEmit a depfile listing dependencies of the main output.\n"
    output += "  --extra-cpp-flagFLAG\t\t\tPass FLAG to the compiler. Can be specified multiple times.\n"
    output += "  --use-ccache\t\t\t\tUse ccache when compiling.\n"
    output += "  -o,--output-filename FILE\t\tName of the output binary.\n\t\t\t\t\tDefaults to the input-filename without the extension.\n"
    output += "  -B,--binary-dir PATH\t\t\tOutput directory for compiled files.\n\t\t\t\t\tDefaults to $PWD/build.\n"
    output += "  -E,--exports-dir PATH\t\t\tOutput directory for exported files, relative to $PWD.\n\t\t\t\t\tDefaults to '$PWD/exports'.\n"
    output += "  -I PATH\t\t\t\tAdd PATH to compiler's include list. Can be specified multiple times.\n"
    output += "  -J,--jobs NUMBER\t\t\tSpecify the number of jobs to run in parallel, defaults to 2 (1 on windows).\n"
    output += "  -L PATH\t\t\t\tAdd PATH to linker's search list. Can be specified multiple times.\n"
    output += "  -l,--link-with LIB\t\t\tLink executable with LIB. Can be specified multiple times.\n"
    output += "  -T,--target-triple TARGET\t\tSpecify the target triple used for the build, defaults to native.\n"
    output += "  -WlARG\t\t\t\tPass ARG to the linker. Can be specified multiple times.\n"
    output += "  -X FILE\t\t\t\tPass FILE to the compiler. Can be specified multiple times.\n"
    output += "= Debugging:\n"
    output += "  -dl\t\t\t\t\tPrint debug info for the lexer.\n"
    output += "  -dp\t\t\t\t\tPrint debug info for the parser.\n"
    output += "  -dt\t\t\t\t\tPrint debug info for the typechecker.\n"
    output += "  -fd,--format-debug\t\t\tOutput debug info for the formatter.\n"
    output += "  -p,--prettify-cpp-source\t\tRun emitted C++ source through clang-format.\n"
    output += "  -D,--dot-clang-format-path PATH\tPath to the .clang-format file to use.\n\t\t\t\t\tDefaults to none, invoking clangs default .clang-format file handling.\n"
    output += "  -F,--clang-format-path PATH\t\tPath to clang-format executable.\n\t\t\t\t\tDefaults to clang-format\n"
    output += "  --debug-print\t\t\t\tOutput debug print.\n"
    output += "  --debug-print-cpp-import\t\t\t\tOutput debug print for the c++ import processor.\n"
    output += "= Formatting:\n"
    output += "  -f,--format\t\t\t\tFormat a file or directory and output the result.\n"
    output += "  -fi,--format-inplace\t\t\tFormat a file or directory and save the result inplace.\n"
    output += "  -fr,--format-range RANGE\t\tEmit part of the document with formatting applied.\n"
    output += "= IDE integration:\n"
    output += "  -e,--hover INDEX\t\t\tReturn the type of element at index.\n"
    output += "  -g,--goto-def INDEX\t\t\tReturn the span for the definition at index.\n"
    output += "  -H,--type-hints\t\t\tEmit machine-readable type hints (for IDE integration).\n"
    output += "  -m,--completions INDEX\t\tReturn dot completions at index.\n"
    output += "  --print-symbols\t\t\tEmit a machine-readable (JSON) symbol tree.\n"
    output += "  --try-hints\t\t\t\tEmit machine-readable try hints (for IDE integration).\n"
    output += "  -t,--goto-type-def INDEX\t\tReturn the span for the type definition at index.\n"
    output += "= Misc:\n"
    output += "  --discover\t\t\t\tDiscover all files in the project, print the dependencies and outputs, then exit.\n"
    output += "  -j,--json-errors\t\t\tEmit machine-readable (JSON) errors.\n"
    output += "  --runtime-library-path PATH\t\tSpecify the path to the runtime library.\n"
    output += "  --runtime-path PATH\t\t\tSpecify the path to the host runtime headers.\n"
    output += "  -R,--runtime-path PATH\t\tPath of the Jakt runtime headers.\n\t\t\t\t\tDefaults to $PWD/runtime.\n"
    output += "  --assume-main-file-path PATH\t\tAssume the main file is at PATH.\n"
    output += "\nCross mode:\n"
    output += "All other given options and flags will be passed to the compiler invocation verbatim.\n"
    output += "  --source-file PATH\t\t\tSpecify the path to the source file to compile.\n"
    output += "  -T,--target-triple TARGET\t\tSpecify the target triple used for the build, defaults to native.\n"
    output += "  --sysroot PATH\t\t\tSpecify the sysroot used for the build.\n"
    output += "  --system-include-dir PATH\t\tSpecify a system include directory to use.\n"
    output += "  --system-lib-dir PATH\t\t\tSpecify a system library directory to use.\n"
    output += "  --compiler-include-dir PATH\t\tSpecify a compiler include directory to use.\n"
    output += "  --compiler-lib-dir PATH\t\tSpecify a compiler library directory to use.\n"
    output += "  --install-root PATH\t\t\tSpecify the root directory to install to.\n"
    output += "  --only-support-libs\t\t\tOnly build and install support libraries for the target platform.\n"
    output += "  --target-links-ak\t\t\t\tAssume AK will be provided by the target platform.\n"
    output += "  --runtime-lib-path PATH\t\tSpecify the path to the host runtime library.\n"
    return output
}

fn indent(anon level: usize) -> String {
    mut output = ""
    for i in 0uz..level {
        output += "    "
    }
    return output
}

struct FormatRange {
    start: usize
    end: usize
}
fn parse_format_range(anon range: String, anon input_file_length: usize) -> FormatRange? {
    // range: <start-offset>:<end-offset>
    // {start,end}-offset: usize

    let parts = range.split(c':')
    if parts.is_empty() {
        return FormatRange(
            start: 0
            end: input_file_length
        )
    }

    let start_input = parts[0].to_number<u32>()
    if not start_input.has_value() {
        return None
    }

    let start = start_input! as! usize
    let end = match parts.size() {
        1 => input_file_length
        2 => {
            let end_input = parts[1].to_number<u32>()
            if not end_input.has_value() {
                return None
            }

            yield end_input! as! usize
        }
        else => {
            return None
        }
    }

    return FormatRange(
        start
        end
    )
}

fn value_or_throw<T>(anon maybe: T?) throws -> T {
    if maybe.has_value() {
        return maybe!
    }

    throw Error::from_string_literal("Expected value but found none")
}

fn main(args: [String]) -> c_int {
    if args.size() <= 1 {
        eprintln("{}", usage())
        return 1
    }

    if args[1] == "cross" {
        return selfhost_crosscompiler_main(args)
    }

    return compiler_main(args)
}

fn install(from: Path, to: Path) throws {
    mut directories_to_copy: Queue<(Path, Path)> = Queue()
    directories_to_copy.enqueue((from, Path::from_string(".")))
    while not directories_to_copy.is_empty() {
        let (directory, relative_dir) = directories_to_copy.dequeue()
        for (entry, is_directory) in DirectoryIterator::from_path(path: directory)! {
            let path = directory.join(entry)
            let path_relative_to_target = relative_dir.join(entry)

            if is_directory {
                try make_directory(path: to.join(path_relative_to_target.to_string()).to_string())
                directories_to_copy.enqueue((path, path_relative_to_target))
                continue
            }

            // FIXME: Symlink
            try mkdir_p(path: to.join(path_relative_to_target.to_string()).parent())
            let target_path = to.join(path_relative_to_target.to_string())
            mut input_file = File::open_for_reading(path.to_string())
            mut output_file = File::open_for_writing(target_path.to_string())
            mut buffer = [0u8; 4096]
            while true {
                let bytes_read = input_file.read(buffer)
                if bytes_read == 0 {
                    break
                }

                mut bytes_written: usize = 0
                while bytes_written < bytes_read {
                    bytes_written += output_file.write(buffer[bytes_written..bytes_read].to_array())
                }

                if bytes_written != bytes_read {
                    throw Error::from_string_literal("Failed to write to file")
                }
            }
        }
    }
}

fn selfhost_crosscompiler_main(args: [String]) throws -> c_int {
    mut compiler_args: [String] = []

    mut target_triple: String? = None
    mut sysroot: String? = None
    mut system_lib_dirs: [String] = []
    mut system_include_dirs: [String] = []
    mut compiler_include_dir: String? = None
    mut compiler_lib_dir: String? = None

    mut install_root: String? = None
    mut runtime_lib_path: Path? = None
    mut runtime_path: Path? = None

    mut source_file: String? = None
    mut output_filename: String? = None
    mut only_support_libs = false
    mut target_links_ak = false

    mut args_to_process: Queue<String> = Queue()
    for arg in args[1..] {
        args_to_process.enqueue(arg)
    }

    while not args_to_process.is_empty() {
        let arg = args_to_process.dequeue()
        match arg {
            "--target-triple" | "-T" => { target_triple = args_to_process.dequeue() }
            "--sysroot" => { sysroot = args_to_process.dequeue() }
            "--system-lib-dir" => {
                system_lib_dirs.push(args_to_process.dequeue())
            }
            "--system-include-dir" => {
                system_include_dirs.push(args_to_process.dequeue())
            }
            "--compiler-include-dir" => {
                compiler_include_dir = args_to_process.dequeue()
            }
            "--compiler-lib-dir" => {
                compiler_lib_dir = args_to_process.dequeue()
            }
            "--install-root" => { install_root = args_to_process.dequeue() }
            "--runtime-lib-path" => { runtime_lib_path = Path::from_string(args_to_process.dequeue()) }
            "--runtime-path" => { runtime_path = Path::from_string(args_to_process.dequeue()) }
            "--source-file" => { source_file = args_to_process.dequeue() }
            "--output-filename" | "-o" => { output_filename = args_to_process.dequeue() }
            "--target-links-ak" => { target_links_ak = true }
            "--only-support-libs" => { only_support_libs = true }
            else => { compiler_args.push(arg) }
        }
    }

    if source_file is None and not only_support_libs {
        eprintln("error: Expected --source_file to be passed")
        return 1
    }

    if install_root is None {
        eprintln("error: Expected --install-root to be passed")
        return 1
    }

    if target_triple is None {
        eprintln("error: Expected --target-triple to be passed")
        return 1
    }

    let abbreviated_triple = Target::from_triple(target_triple!).name(abbreviate: true)

    let install_dir = Path::from_string(install_root!)
    let install_lib_dir = install_dir.join("lib").join(target_triple!)
    let install_runtime_dir = install_dir.join("include/runtime")
    let install_bin_dir = install_dir.join("bin")

    let current_executable_path = Path::from_string(File::current_executable_path())
    let local_install_base_path = current_executable_path.parent().parent()
    if runtime_path is None {
        runtime_path = local_install_base_path.join("include/runtime")
    }
    if runtime_lib_path is None {
        runtime_lib_path = local_install_base_path.join("lib").join(Target::active().name())
    }

    let compiler_invocation_args = fn[
        &compiler_args
        &abbreviated_triple
        &sysroot
        &compiler_include_dir
        &compiler_lib_dir
        &system_include_dirs
        &system_lib_dirs
        &runtime_lib_path
        &runtime_path
    ]() -> [String] {
        mut args = compiler_args[..].to_array()
        args.push("--target-triple")
        args.push(format("{}-unknown", abbreviated_triple))

        if sysroot.has_value() {
            args.push("--extra-cpp-flag")
            args.push(format("--sysroot={}", sysroot!))
        }

        if compiler_include_dir.has_value() {
            args.push("-I")
            args.push(compiler_include_dir!)
        }

        if compiler_lib_dir.has_value() {
            args.push("-L")
            args.push(compiler_lib_dir!)
        }

        for system_include_dir in system_include_dirs {
            args.push("-I")
            args.push(system_include_dir)
        }

        for system_lib_dir in system_lib_dirs {
            args.push("-L")
            args.push(system_lib_dir)
        }

        if runtime_lib_path.has_value() {
            args.push("--runtime-library-path")
            args.push(runtime_lib_path!.to_string())
        }

        if runtime_path.has_value() {
            args.push("--runtime-path")
            args.push(runtime_path!.to_string())
        }

        return args
    }

    if not install_lib_dir.exists() { mkdir_p(path: install_lib_dir) }
    install(from: runtime_path!, to: install_runtime_dir)
    if not install_bin_dir.exists() { mkdir_p(path: install_bin_dir) }

    let runtime_archive_path = install_lib_dir.join(format("libjakt_runtime_{}.a", target_triple!))
    let main_archive_path = install_lib_dir.join(format("libjakt_main_{}.a", target_triple!))

    let build_archive = fn[&compiler_invocation_args](anon sources: [Path], anon target: Path) throws -> c_int {
        mut invocation_args = compiler_invocation_args()
        for source in sources {
            invocation_args.push("-X")
            invocation_args.push(source.to_string())
        }

        invocation_args.push("--static")
        invocation_args.push("--link-archive")
        invocation_args.push(target.to_string())
        invocation_args.push("/dev/null")

        return compiler_main(invocation_args)
    }

    if not runtime_archive_path.exists() {
        eprintln("Building jakt runtime for target {}...", abbreviated_triple)
        mut sources: [Path] = [runtime_path!.join("IO/File.cpp")]
        if not target_links_ak {
            sources.push_values(&find_with_extension(path: runtime_path!.join("AK"), extension: "cpp"))
        }
        sources.push_values(&find_with_extension(path: runtime_path!.join("Jakt"), extension: "cpp"))

        if build_archive(sources, runtime_archive_path) != 0 {
            return 1
        }
    }

    if not main_archive_path.exists() {
        eprintln("Building jakt main for target {}...", abbreviated_triple)
        mut sources: [Path] = [runtime_path!.join("Main.cpp")]

        if build_archive(sources, main_archive_path) != 0 {
            return 1
        }
    }

    runtime_lib_path = install_lib_dir.parent()
    runtime_path = install_runtime_dir

    if not only_support_libs {
        mut compiler_args = compiler_invocation_args()
        let source_path = Path::from_string(source_file!)
        compiler_args.push(source_path.to_string())
        compiler_args.push("-o")
        let default_output_filename = install_bin_dir.join(output_filename ?? source_path.basename(strip_extension: true)).to_string()
        compiler_args.push(default_output_filename)

        return compiler_main(compiler_args)
    }

    return 0
}

fn mkdir_p(anon path: Path) throws {
    let components = path.components()
    if components.is_empty() { return }

    mut current_path = Path::from_string(components[0])
    for part in components[1..] {
        if not current_path.exists() {
            eprintln("- mkdir {}", current_path)
            make_directory(path: current_path.to_string())
        }

        current_path = current_path.join(part)
    }

    if not current_path.exists() {
        make_directory(path: current_path.to_string())
    }
}

fn find_with_extension(path: Path, extension: String) throws -> [Path] {
    mut directories_to_search: Queue<Path> = Queue()
    directories_to_search.enqueue(path)
    mut files_found: [Path] = []
    while not directories_to_search.is_empty() {
        let directory = directories_to_search.dequeue()
        for (entry, is_directory) in DirectoryIterator::from_path(path: directory)! {
            let path = directory.join(entry)
            if is_directory {
                directories_to_search.enqueue(path)
            } else if entry.extension() == extension {
                files_found.push(path)
            }
        }
    }

    return files_found
}

fn escape_for_depfile(anon input: String) -> String {
    // $ -> $$, # -> \#, <space> -> \<space>
    return input.replace(replace: "$", with: "$$").replace(replace: "#", with: "\\#").replace(replace: " ", with: "\\ ")
}

fn compiler_main(anon args: [String]) throws -> c_int {
    mut args_parser = ArgsParser::from_args(args)

    if args_parser.flag(["-h", "--help"]) {
        println("{}\n", usage())
        println("{}", help())
        return 0
    }

    if args_parser.flag(["-v", "--version"]) {
        println("{}", git::commit_hash())
        return 0
    }

    let current_executable_path = Path::from_string(File::current_executable_path())
    let install_base_path = current_executable_path.parent().parent()
    let default_runtime_path = install_base_path.join("include/runtime")
    let default_runtime_library_path = install_base_path.join("lib")
    let default_compiler_path = match is_windows() { true => "clang-cl", else => "clang++" }

    let optimize = args_parser.flag(["-O"])
    let lexer_debug = args_parser.flag(["-dl"])
    let parser_debug = args_parser.flag(["-dp"])
    let typechecker_debug = args_parser.flag(["-dt"])
    let build_executable = not args_parser.flag(["-S", "--emit-cpp-source-only"])
    let run_executable = args_parser.flag(["-cr", "--compile-run"])
    let codegen_debug = args_parser.flag(["-d"])
    let debug_print = args_parser.flag(["--debug-print"])
    let debug_print_cpp_import = args_parser.flag(["--debug-print-cpp-import"])
    let prettify_cpp_source = args_parser.flag(["-p", "--prettify-cpp-source"])
    let json_errors = args_parser.flag(["-j","--json-errors"])
    let dump_type_hints = args_parser.flag(["-H", "--type-hints"])
    let dump_try_hints = args_parser.flag(["--try-hints"])
    let check_only = args_parser.flag(["-c", "--check-only"])
    let generate_depfile = args_parser.option(["-M", "--dep-file"])
    let target_triple = args_parser.option(["-T", "--target-triple"])
    let runtime_library_path = args_parser.option(["-RLP", "--runtime-library-path"]) ?? default_runtime_library_path.to_string()
    mut compiler_job_count = args_parser.option(["-J", "--jobs"]) ?? "2"

    // FIXME: Remove this when parallel runs on windows work correctly.
    if is_windows() {
        compiler_job_count = "1"
    }

    let clang_format_path = args_parser.option(["-F", "--clang-format-path"]) ?? "clang-format"
    let runtime_path = args_parser.option(["-R", "--runtime-path"]) ?? default_runtime_path.to_string()
    let assume_main_file_path = args_parser.option(["--assume-main-file-path"])
    let binary_dir = Path::from_string(args_parser.option(["-B", "--binary-dir"]) ?? "build")
    let exports_dir = Path::from_string(args_parser.option(["-E", "--exports-dir"]) ?? "exports")
    let dot_clang_format_path = args_parser.option(["-D", "--dot-clang-format-path"])
    let cxx_compiler_path = args_parser.option(["-C", "--cxx-compiler-path"]) ?? default_compiler_path
    let archiver_path = args_parser.option(["-A", "--archiver"])
    let link_archive = args_parser.option(["-a", "--link-archive"])
    let archive_link_support_libs = args_parser.flag(["--archive-link-support-libs"])
    let build_static = args_parser.flag(["--static"])
    let extra_include_paths = args_parser.option_multiple(["-I"])
    let extra_lib_paths = args_parser.option_multiple(["-L"])
    let extra_link_libs = args_parser.option_multiple(["-l"])
    let extra_linker_args = args_parser.option_multiple(["-Wl"])
    let extra_cpp_files = args_parser.option_multiple(["-X"])
    let extra_cpp_flags = args_parser.option_multiple(["--extra-cpp-flag"])
    let set_output_filename = args_parser.option(["-o", "--output-filename"])
    let goto_def = args_parser.option(["-g", "--goto-def"])
    let goto_type_def = args_parser.option(["-t", "--goto-type-def"])
    let hover = args_parser.option(["-e", "--hover"])
    let completions = args_parser.option(["-m", "--completions"])
    let print_symbols = args_parser.flag(["--print-symbols"])
    let project_name = args_parser.option(["--create"])
    let use_ccache = args_parser.flag(["--use-ccache"])
    let user_configuration_specs = args_parser.option_multiple(["--config"])

    mut user_configuration: [String:String] = [:]
    for spec in user_configuration_specs {
        let parts = spec.split(c'=')
        match parts.size() {
            1 => {
                user_configuration[parts[0]] = "true"
            }
            2 => {
                user_configuration[parts[0]] = parts[1]
            }
            else => {
                eprintln("error: invalid configuration specification: {}", spec)
                return 1
            }
        }
    }

    let interpret_run = args_parser.flag(["-r", "--run"])

    let format = args_parser.flag(["-f", "--format"])
    let format_inplace = args_parser.flag(["-fi", "--format-inplace"])
    let format_debug = args_parser.flag(["-fd", "--format-debug"])
    let input_format_range = args_parser.option(["-fr", "--format-range"]) ?? ""

    let ak_stdlib = args_parser.flag(["--ak-is-my-only-stdlib"])
    let discover_only = args_parser.flag(["--discover"])

    let max_concurrent = try value_or_throw(compiler_job_count.to_number<u32>()) catch {
        eprintln("error: invalid value for --jobs: {}", compiler_job_count)
        return 1
    } as! usize

    if args_parser.flag(["--repl"]) {
        mut repl = REPL::create(
            std_include_path: Path::from_parts([runtime_path, "jaktlib"])
            prelude_path: Path::from_parts([runtime_path, "prelude.jakt"])
            target_triple, user_configuration)
        repl.run()
        return 0
    }

    let positional_arguments = args_parser.remaining_arguments()

    if project_name.has_value() {
        let project = Project(name: project_name!)
        project.populate()
        return 0
    }

    let compiler_is = fn[cxx_compiler_path](anon name: String) throws -> bool {
        return Path::from_string(cxx_compiler_path).basename().contains(name)
    }

    mut file_name: String? = None
    mut first_arg = true
    mut interpreted_main_arguments: [String] = []

    for arg in positional_arguments {
        if first_arg {
            first_arg = false
            continue
        }

        if not file_name.has_value() {
            file_name = arg
            continue
        }

        if not interpret_run {
            eprintln(
                "Extra unknown argument '{}', you can only pass one source file (was '{}')"
                arg
                file_name
            )
            eprintln("{}", usage())
            return 1
        }

        interpreted_main_arguments.push(arg)
    }
    if not file_name.has_value() {
        eprintln("you must pass a source file")
        eprintln("{}", usage())
        return 1
    }

    let file_path = Path::from_string(file_name!)
    // if file_path.ext() != "jakt" {
    //     eprintln("the compiler expects files with file extension .jakt")
    //     eprintln("{}", usage())
    //     return 1
    // }

    let guessed_output_filename = file_path.basename(strip_extension: true)
    let output_filename = binary_dir.join(set_output_filename ?? guessed_output_filename).to_string()

    mut errors: [JaktError] = []

    mut compiler = Compiler(
        files: []
        file_ids: [:]
        errors: []
        current_file: None
        current_file_contents: []
        dump_lexer: lexer_debug
        dump_parser: parser_debug
        ignore_parser_errors: false
        debug_print: debug_print
        debug_print_cpp_import: debug_print_cpp_import
        // FIXME: Case sensitivity on win/mac requires this path be named different than the jakt cpp lib
        std_include_path: Path::from_parts([runtime_path, "jaktlib"])
        prelude_path: Path::from_parts([runtime_path, "prelude.jakt"])
        include_paths: extra_include_paths
        extra_cpp_flags
        json_errors
        dump_type_hints
        dump_try_hints
        optimize
        target_triple
        user_configuration
        binary_dir
        exports_dir
        assume_main_file_path: match assume_main_file_path.has_value() {
            true => Some(Path::from_string(assume_main_file_path!))
            false => None
        }
        files_used_in_build: {}
    )

    compiler.load_prelude()

    if format or format_debug or format_inplace {
        let directory_or_file_paths = RecursiveFileIterator::make(directory: file_path, extension: "jakt")
        for directory_or_file_path in directory_or_file_paths {
            let file_id = compiler.get_file_id_or_register(directory_or_file_path)
            let file_is_set = compiler.set_current_file(file_id)
            if not file_is_set {
                return 1
            }

            let format_range = parse_format_range(
                range: input_format_range
                input_file_length: compiler.current_file_contents.size()
            )
            if not format_range.has_value() {
                eprintln("invalid format range '{}', expected <start>(:<end>?)", input_format_range)
                return 1
            }

            let tokens = Lexer::lex(compiler)

            format_output(file_path: directory_or_file_path, tokens, format_range, format_debug, format_inplace)
        }

        return 0
    }

    let main_file_id = compiler.get_file_id_or_register(file_path)
    let file_is_set = compiler.set_current_file(main_file_id)
    if not file_is_set {
        return 1
    }

    let tokens = Lexer::lex(compiler)

    if lexer_debug {
        for token in tokens {
            println("token: {}", token)
        }
    }

    let parsed_namespace = Parser::parse(compiler, tokens)

    if parser_debug {
        println("{:#}", parsed_namespace);
    }

    if print_symbols {
        let symbols = ide::find_symbols_in_namespace(parsed_namespace)

        mut symbol_representations: [String] = []
        for symbol in symbols {
            symbol_representations.push(symbol.to_json())
        }
        println("[{}]", join(symbol_representations, separator: ","))
        return 0
    }

    mut typechecker = Typechecker::typecheck(
        compiler
        parsed_namespace
    )
    let checked_program = typechecker.program

    if interpret_run {
        mut interpreter = typechecker.interpreter()

        // Find the main function in the main module
        let main_module_scope_id = ScopeId(module_id: ModuleId(id: 1), id: 0)
        mut main_function_id: FunctionId? = None
        for module in checked_program.modules {
            for scope in module.scopes {
                if not (scope.parent?.equals(main_module_scope_id) ?? false) {
                    continue
                }

                for (function_name, overload_set) in scope.functions {
                    if function_name == "main" {
                        main_function_id = overload_set[0]
                        break
                    }
                }

                if main_function_id.has_value() {
                    break
                }
            }
            if main_function_id.has_value() {
                break
            }
        }

        if not main_function_id.has_value() {
            eprintln("Error: No main function  found in program")
            return 1
        }

        let namespace_: [ResolvedNamespace] = []
        let call_span = Span(file_id: FileId(id: 0), start: 0, end: 0)
        let first_main_param = checked_program.get_function(main_function_id!).params.first()
        let arguments = match first_main_param.has_value() {
            true => {
                mut passed_arguments: [Value] = [Value(impl: ValueImpl::JaktString(file_name!), span: call_span)]
                for argument in interpreted_main_arguments {
                    passed_arguments.push(Value(impl: ValueImpl::JaktString(argument), span: call_span))
                }
                yield [Value(
                    impl: ValueImpl::JaktArray(values: passed_arguments, type_id: first_main_param!.variable.type_id)
                    span: call_span
                )]
            }
            false => []
        }

        let main_result = interpreter.execute(
            function_to_run_id: main_function_id!
            namespace_
            this_argument: None
            arguments
            call_span
            is_main: true)

        match main_result {
            Return(x) => match x.impl {
                CInt(ret_val) | I64(ret_val) => {
                    return ret_val as! c_int
                }
                Void => {
                    return 0
                }
                else => {
                    eprintln("Error: Main function  must return an integer")
                    return 1
                }
            }

            Throw(x) => {
                eprintln("Error: Main function  threw: {}", serialize_ast_node(value_to_checked_expression(x, interpreter)))
                return 1
            }
        }
    }

    if goto_def.has_value() {
        let index = goto_def!.to_number<u32>()! as! usize;

        let result = ide::find_definition_in_program(program: checked_program, span: Span(file_id: FileId(id: 1), start: index, end: index))

        if result.file_id.id == 1 {
            println("{{\"start\": {}, \"end\": {}}}", result.start, result.end);
        } else {
            let file_path = compiler.get_file_path(result.file_id)

            println("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}", result.start, result.end, escape_for_quotes(file_path!.to_string()));
        }
        return 0
    }
    if goto_type_def.has_value() {
        let index = goto_type_def!.to_number<u32>()! as! usize;

        let result = ide::find_type_definition_in_program(program: checked_program, span: Span(file_id: FileId(id: 1), start: index, end: index))

        if result.file_id.id == 1 {
            println("{{\"start\": {}, \"end\": {}}}", result.start, result.end);
        } else {
            let file_path = compiler.get_file_path(result.file_id)

            println("{{\"start\": {}, \"end\": {}, \"file\": \"{}\"}}", result.start, result.end, escape_for_quotes(file_path!.to_string()));
        }
        return 0
    }
    if hover.has_value() {
        let index = hover!.to_number<u32>()! as! usize;

        let result = ide::find_typename_in_program(program: checked_program, span: Span(file_id: FileId(id: 1), start: index, end: index))

        if result.has_value() {
            println("{{\"hover\": \"{}\"}}", result!)
        }
        return 0
    }
    if completions.has_value() {
        let index = completions!.to_number<u32>()! as! usize;

        let result = ide::find_dot_completions(program: checked_program, span: Span(file_id: FileId(id: 1), start: index, end: index))

        print("{{\"completions\": [");
        mut first = true
        for completion in result {
            if not first {
                print(", ")
            } else {
                first = false
            }
            print("\"{}\"", completion)
        }
        println("]}}");
        return 0
    }

    if typechecker_debug {
        println("{:#}", checked_program);
    }

    compiler.print_errors()

    if not compiler.errors.is_empty() {
        return 1
    }

    if check_only {
        return 0
    }


    if not binary_dir.exists() {
        make_directory(path: binary_dir.to_string())
    }

    if not exports_dir.exists() {
        make_directory(path: exports_dir.to_string())
    }

    mut exported_files: [String:String] = [:]
    let codegen_result = CodeGenerator::generate(compiler, checked_program, debug_info: codegen_debug, &mut exported_files)

    if discover_only {
        for (file, contents_and_path) in codegen_result {
            let (_, module_file_path) = contents_and_path
            if module_file_path == "__prelude__" {
                continue
            }

            let path = binary_dir.join(file)
            println(
                "{}:{}"
                path.to_string()
                module_file_path
            )
        }
        return 0
    }

    mut depfile_builder = StringBuilder::create()

    if generate_depfile.has_value() {
        if link_archive.has_value() {
            depfile_builder.append(escape_for_depfile(binary_dir.join(link_archive!).to_string()))
        } else {
            depfile_builder.append(escape_for_depfile(output_filename))
        }
        depfile_builder.append(" : ")
        mut seen_files: {String} = {}
        for (_, contents_and_path) in codegen_result {
            let (contents, module_file_path) = contents_and_path
            if module_file_path == "__prelude__" {
                continue
            }

            let file = escape_for_depfile(module_file_path)
            if seen_files.contains(file) {
                continue
            }

            seen_files.add(file)
            depfile_builder.append(" \\\n  ")
            depfile_builder.append(file)
        }
        for (path, _) in typechecker.cpp_import_cache {
            let full_path = compiler.find_in_search_paths(Path::from_string(path))
            mut entry = path
            if full_path.has_value() {
                entry = full_path!.to_string()
            }

            depfile_builder.append(" \\\n  ")
            depfile_builder.append(escape_for_depfile(entry))
        }
        for path in compiler.files_used_in_build {
            if seen_files.contains(path) {
                continue
            }

            seen_files.add(path)
            depfile_builder.append(" \\\n  ")
            depfile_builder.append(escape_for_depfile(path))
        }

        depfile_builder.append("\n")
    }

    for (file, contents_and_path) in codegen_result {
        let (contents, module_file_path) = contents_and_path

        let path = binary_dir.join(file)

        try write_only_if_updated(data: contents, output_filename: path.to_string()) catch error {
            eprintln("Error: Could not write to file: {} ({})", file, error)
            return 1
        }
    }

    for (file, contents) in exported_files {
        let path = exports_dir.join(file)

        try write_only_if_updated(data: contents, output_filename: path.to_string()) catch error {
            eprintln("Error: Could not write to file: {} ({})", file, error)
            return 1
        }
    }

    if generate_depfile.has_value() {
        try {
            write_only_if_updated(
                data: depfile_builder.to_string()
                output_filename: generate_depfile!
            )
        } catch error {
            eprintln("Error: Could not write to file list ({})", error)
            return 1
        }
    }

    if prettify_cpp_source {
        mut command = StringBuilder::create()
        command.appendff("{} -i", clang_format_path)

        if dot_clang_format_path.has_value() {
            command.appendff(" --style=file:{}", dot_clang_format_path)
        }

        for (file, _) in codegen_result {
            let path = binary_dir.join(file)
            command.appendff(" {}", path.to_string())
        }

        system(command.to_string().c_string())
    }

    if build_executable or run_executable {
        mut files: [String] = []
        for (file_name, _) in codegen_result {
            if file_name.ends_with(".h") {
                continue
            }
            files.push(file_name)
        }

        for file in extra_cpp_files {
            files.push(file)
        }

        mut builder = Builder::for_building(
            files
            max_concurrent
        )

        mut extra_compiler_flags = ["-c"]
        if ak_stdlib {
            extra_compiler_flags.push("-DJAKT_USING_AK_AS_STANDARD_LIBRARY=1")
        }

        if build_static {
            extra_compiler_flags.push("-static")
        }

        if target_triple.has_value() {
            if compiler_is("clang++") and target_triple! != Target::active().name() {
                extra_compiler_flags.push("-target")
                // FIXME: The Serenity clang toolchain doesn't like getting -unknown appended to the target triple
                //        This is fine for now unless you're targeting musl libc, in which case, you're out of luck
                extra_compiler_flags.push(Target::from_triple(target_triple!).name(abbreviate: true))
            }
        }

        for flag in extra_cpp_flags {
            extra_compiler_flags.push(flag)
        }

        try builder.build_all(
            binary_dir
            compiler_invocation: &fn[
                use_ccache
                cxx_compiler_path
                runtime_path
                extra_include_paths
                optimize
                extra_compiler_flags
            ](input_filename: String, output_filename: String) throws -> [String] {
                return run_compiler(
                    cxx_compiler_path
                    cpp_filename: input_filename
                    output_filename
                    runtime_path
                    extra_include_paths
                    extra_lib_paths: []
                    extra_link_libs: []
                    optimize
                    extra_compiler_flags
                    use_ccache
                )
            }
        ) catch {
            return 1
        }

        let runtime_lib_path = Path::from_string(runtime_library_path)
        let target = match target_triple.has_value() {
            true => Target::from_triple(target_triple!)
            false => Target::active()
        }

        if link_archive.has_value() {
            mut extra_arguments: [String] = []
            if archive_link_support_libs {
                extra_arguments.push(runtime_lib_path.join(library_name_for_target("main", target)).to_string())
                extra_arguments.push(runtime_lib_path.join(library_name_for_target("runtime", target)).to_string())
            }

            try builder.link_into_archive(
                archiver: archiver_path ?? "ar"
                archive_filename: binary_dir.join(link_archive!).to_string()
                extra_arguments
            ) catch {
                return 1
            }
        } else {
            mut extra_arguments: [String] = ["-g"]

            for flag in extra_cpp_flags {
                extra_arguments.push(flag)
            }

            if target_triple.has_value() {
                if compiler_is("clang++") and target_triple! != Target::active().name() {
                    extra_arguments.push("-target")
                    extra_arguments.push(target.name(abbreviate: true))
                }
            }

            extra_arguments.push(runtime_lib_path.join(library_name_for_target("main", target)).to_string())
            extra_arguments.push(runtime_lib_path.join(library_name_for_target("runtime", target)).to_string())

            for path in extra_lib_paths {
                extra_arguments.push("-L")
                extra_arguments.push(path)
            }

            for lib in extra_link_libs {
                extra_arguments.push("-l")
                extra_arguments.push(lib)
            }

            if is_windows() and compiler_is("clang-cl") {
                extra_arguments.push("/link")
                extra_arguments.push("/subsystem:console")
            }

            for arg in extra_linker_args {
                extra_arguments.push(format("-Wl,{}", arg))
            }

            try builder.link_into_executable(
                cxx_compiler_path
                output_filename
                extra_arguments
            ) catch {
                return 1
            }
        }
    }

    if run_executable {
        return system(output_filename.c_string())
    }

    return 0
}

fn format_output(file_path: Path, tokens: [Token], format_range: FormatRange?, format_debug: bool, format_inplace: bool) throws {
    mut formatted_file = StringBuilder::create()

    mut on_new_line = true
    for formatted_line in Formatter::for_tokens(tokens, debug: format_debug) {
        for formatted_token in formatted_line {
            if not formatted_token.token.span().is_in_offset_range(start: format_range!.start, end: format_range!.end) {
                continue
            }

            for byte in formatted_token.preceding_trivia {
                formatted_file.append(byte)
            }

            match formatted_token.token {
                Eol(comment) => {
                    if comment.has_value() {
                        mut next_char = b' '
                        if comment!.length() != 0 {
                            next_char = comment!.byte_at(0)
                        }
                        let space = match next_char {
                            b' ' | b'\t' | b'/' => ""
                            else => " "
                        }
                        let lhs_space = match on_new_line {
                            true => indent(formatted_token.indent)
                            else => " "
                        }

                        formatted_file.appendff("{}//{}{}", lhs_space, space, comment!)
                    }
                    on_new_line = true
                }
                Garbage(consumed) => {
                    if consumed.has_value() {
                        formatted_file.appendff("{}", consumed!)
                    }
                }
                else => {
                    if on_new_line {
                        formatted_file.appendff("{}", indent(formatted_token.indent))
                    }
                    formatted_file.appendff("{}", formatted_token.token_text())
                    on_new_line = false
                }
            }

            for byte in formatted_token.trailing_trivia {
                formatted_file.appendff("{:c}", byte)
            }

            if formatted_token.token is Eol {
                formatted_file.append("\n")
            }
        }
    }

    if format_inplace {
        write_to_file(
            data: formatted_file.to_string()
            output_filename: file_path.to_string()
        )
    } else {
        print("{}", formatted_file.to_string())
    }
}

fn write_only_if_updated(data: String, output_filename: String) throws {
    if file_needs_updating(path: output_filename, new_contents: data) {
        write_to_file(data, output_filename)
    }
}

fn file_needs_updating(path: String, new_contents: String) -> bool {
    mut maybe_file = try File::open_for_reading(path)

    // It doesn't exist, write it anyway
    guard maybe_file.has_value() else {
        return true
    }

    let contents = try maybe_file!.read_all()

    // Could not read contents, so write it anyway.
    guard contents.has_value() else {
        return true
    }

    return to_string(contents!) != new_contents
}
