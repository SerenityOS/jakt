/// Expect:
/// - output: ""

extern struct StringBuilder {
    function append(mutable this, anonymous s: u8)
    function to_string(mutable this) throws -> String
    function StringBuilder() -> StringBuilder
}

extern function abort()

function todo(anonymous message: String) {
    eprintln("TODO: {}", message)
    abort()
}

// FIXME: These should not need explicit "-> bool" return types.
function is_ascii_alpha(anonymous c: u8) -> bool => (c >= b'a' and c <= b'z') or (c >= b'A' and c <= b'Z')
function is_ascii_digit(anonymous c: u8) -> bool => (c >= b'0' and c <= b'9')
function is_ascii_hexdigit(anonymous c: u8) -> bool => (c >= b'0' and c <= b'9') or (c >= b'a' and c <= b'f') or (c >= b'A' and c <= b'F')
function is_ascii_alphanumeric(anonymous c: u8) -> bool => is_ascii_alpha(c) or is_ascii_digit(c)

//FIXME: Would be nice to name this Span and not have conflict
struct JaktSpan {
    start: usize
    end: usize
}
function empty_span() -> JaktSpan => JaktSpan(start: 0, end: 0)

enum Token {
    SingleQuotedString(quote: String, span: JaktSpan)
    SingleQuotedByteString(quote: String, span: JaktSpan)
    QuotedString(quote: String, span: JaktSpan)
    Number(number: i64, span: JaktSpan)
    Identifier(name: String, span: JaktSpan)
    Semicolon(JaktSpan)
    Colon(JaktSpan)
    ColonColon(JaktSpan)
    LParen(JaktSpan)
    RParen(JaktSpan)
    LCurly(JaktSpan)
    RCurly(JaktSpan)
    LSquare(JaktSpan)
    RSquare(JaktSpan)
    PercentSign(JaktSpan)
    Plus(JaktSpan)
    Minus(JaktSpan)
    Equal(JaktSpan)
    PlusEqual(JaktSpan)
    PlusPlus(JaktSpan)
    MinusEqual(JaktSpan)
    MinusMinus(JaktSpan)
    AsteriskEqual(JaktSpan)
    ForwardSlashEqual(JaktSpan)
    PercentSignEqual(JaktSpan)
    NotEqual(JaktSpan)
    DoubleEqual(JaktSpan)
    GreaterThan(JaktSpan)
    GreaterThanOrEqual(JaktSpan)
    LessThan(JaktSpan)
    LessThanOrEqual(JaktSpan)
    LeftArithmeticShift(JaktSpan)
    LeftShift(JaktSpan)
    LeftShiftEqual(JaktSpan)
    RightShift(JaktSpan)
    RightArithmeticShift(JaktSpan)
    RightShiftEqual(JaktSpan)
    Asterisk(JaktSpan)
    Ampersand(JaktSpan)
    AmpersandEqual(JaktSpan)
    Pipe(JaktSpan)
    PipeEqual(JaktSpan)
    Caret(JaktSpan)
    CaretEqual(JaktSpan)
    Dollar(JaktSpan)
    Tilde(JaktSpan)
    ForwardSlash(JaktSpan)
    ExclamationPoint(JaktSpan)
    QuestionMark(JaktSpan)
    QuestionMarkQuestionMark(JaktSpan)
    Comma(JaktSpan)
    Dot(JaktSpan)
    DotDot(JaktSpan)
    Eol(JaktSpan)
    Eof(JaktSpan)
    FatArrow(JaktSpan)
    Arrow(JaktSpan)

    // Keywords
    And(JaktSpan)
    Anonymous(JaktSpan)
    Boxed(JaktSpan)
    Break(JaktSpan)
    Catch(JaktSpan)
    Class(JaktSpan)
    Continue(JaktSpan)
    Cpp(JaktSpan)
    Defer(JaktSpan)
    Else(JaktSpan)
    Enum(JaktSpan)
    Extern(JaktSpan)
    False(JaktSpan)
    For(JaktSpan)
    Function(JaktSpan)
    If(JaktSpan)
    In(JaktSpan)
    Is(JaktSpan)
    Let(JaktSpan)
    Loop(JaktSpan)
    Match(JaktSpan)
    Mutable(JaktSpan)
    Not(JaktSpan)
    Or(JaktSpan)
    Private(JaktSpan)
    Public(JaktSpan)
    Raw(JaktSpan)
    Return(JaktSpan)
    Restricted(JaktSpan)
    Struct(JaktSpan)
    This(JaktSpan)
    Throw(JaktSpan)
    Throws(JaktSpan)
    True(JaktSpan)
    Try(JaktSpan)
    Unsafe(JaktSpan)
    Weak(JaktSpan)
    While(JaktSpan)
    Yield(JaktSpan)

    // Catch-all for failed parses
    Garbage(JaktSpan)

    public function span(this) -> JaktSpan {
        return match this {
            SingleQuotedString(quote, span) => span
            SingleQuotedByteString(quote, span) => span
            QuotedString(quote, span) => span
            Number(number, span) => span
            Identifier(name, span) => span
            Semicolon(span) => span
            Colon(span) => span
            ColonColon(span) => span
            Cpp(span) => span
            LParen(span) => span
            RParen(span) => span
            LCurly(span) => span
            RCurly(span) => span
            LSquare(span) => span
            RSquare(span) => span
            PercentSign(span) => span
            Plus(span) => span
            Minus(span) => span
            Equal(span) => span
            PlusEqual(span) => span
            PlusPlus(span) => span
            MinusEqual(span) => span
            MinusMinus(span) => span
            Arrow(span) => span
            AsteriskEqual(span) => span
            ForwardSlashEqual(span) => span
            PercentSignEqual(span) => span
            NotEqual(span) => span
            DoubleEqual(span) => span
            GreaterThan(span) => span
            GreaterThanOrEqual(span) => span
            LessThan(span) => span
            LessThanOrEqual(span) => span
            LeftArithmeticShift(span) => span
            LeftShift(span) => span
            LeftShiftEqual(span) => span
            RightShift(span) => span
            RightArithmeticShift(span) => span
            RightShiftEqual(span) => span
            Asterisk(span) => span
            Ampersand(span) => span
            AmpersandEqual(span) => span
            Pipe(span) => span
            PipeEqual(span) => span
            Caret(span) => span
            CaretEqual(span) => span
            Dollar(span) => span
            Tilde(span) => span
            ForwardSlash(span) => span
            ExclamationPoint(span) => span
            QuestionMark(span) => span
            QuestionMarkQuestionMark(span) => span
            Comma(span) => span
            Dot(span) => span
            DotDot(span) => span
            Eol(span) => span
            Eof(span) => span
            FatArrow(span) => span
            And(span) => span
            Anonymous(span) => span
            Boxed(span) => span
            Break(span) => span
            Catch(span) => span
            Class(span) => span
            Continue(span) => span
            Defer(span) => span
            Else(span) => span
            Enum(span) => span
            Extern(span) => span
            False(span) => span
            For(span) => span
            Function(span) => span
            If(span) => span
            In(span) => span
            Is(span) => span
            Let(span) => span
            Loop(span) => span
            Match(span) => span
            Mutable(span) => span
            Not(span) => span
            Or(span) => span
            Private(span) => span
            Public(span) => span
            Raw(span) => span
            Restricted(span) => span
            Return(span) => span
            Struct(span) => span
            This(span) => span
            Throw(span) => span
            Throws(span) => span
            True(span) => span
            Try(span) => span
            Unsafe(span) => span
            Weak(span) => span
            While(span) => span
            Yield(span) => span
            Garbage(span) => span
        }
    }
}

enum JaktError {
    Message(message: String, span: JaktSpan)
    MessageWithHint(message: String, span: JaktSpan, hint: String, hint_span: JaktSpan)
}

struct Lexer {
    index: usize
    input: [u8]
    errors: [JaktError]

    function error(mutable this, anonymous message: String, anonymous span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    // Peek at next upcoming character
    function peek(this) -> u8 {
        if .eof() {
            return 0
        }
        return .input[.index]
    }

    // Peek at upcoming characters, N steps ahead in the stream
    // FIXME: This could be merged with peek() once we support default arguments
    function peek_ahead(this, anonymous steps: usize) -> u8 {
        if .index + steps >= .input.size() {
            return 0
        }
        return .input[.index + steps]
    }

    function eof(this) -> bool {
        return .index >= .input.size()
    }

    function substring(this, start: usize, length: usize) throws -> String {
        let mutable builder = StringBuilder()
        for i in start..length {
            builder.append(.input[i])
        }
        return builder.to_string()
    }

    function lex_character_constant_or_name(mutable this) throws -> Token {
        if .peek_ahead(1) != b'\'' {
            return .lex_number_or_name()
        }

        let is_byte = .peek() == b'b'
        if is_byte {
            .index++
        }

        let start = .index
        .index++

        let mutable escaped = false;

        while not .eof() and (escaped or .peek() != b'\'') {
            if not escaped and .peek() == b'\\' {
                escaped = true
            } else {
                escaped = false
            }

            .index++
        }

        if .eof() or .peek() != b'\'' {
            .error("expected single quote", JaktSpan(start, end: start))
        }

        // Everything but the quotes
        let mutable builder = StringBuilder()
        builder.append(.input[start + 1])
        let str = builder.to_string()

        .index++

        let end = .index

        if is_byte {
            return Token::SingleQuotedByteString(quote: str, span: JaktSpan(start, end))
        }
        return Token::SingleQuotedString(quote: str, span: JaktSpan(start, end))
    }

    function lex_number_or_name(mutable this) throws -> Token {
        let start = .index

        if .eof() {
            .error("unexpected eof", JaktSpan(start, end: start))
            return Token::Garbage(JaktSpan(start, end: start))
        }
        if is_ascii_digit(.peek()) {
            let mutable total = 0i64

            while is_ascii_digit(.peek()) {
                let value = .input[.index]
                ++.index
                let digit: i64 = as_saturated(value - b'0')
                total = total * 10 + digit
            }
            let end = .index
            return Token::Number(number: total, span: JaktSpan(start, end))
        } else if is_ascii_alpha(.peek()) or .peek() == b'_' {
            let mutable string_builder = StringBuilder()

            while is_ascii_alphanumeric(.peek()) or .peek() == b'_' {
                let value = .input[.index]
                ++.index
                string_builder.append(value)
            }
            let end = .index
            let span = JaktSpan(start, end)

            let name = string_builder.to_string()
            return match name {
                "and" => Token::And(span)
                "anonymous" => Token::Anonymous(span)
                "boxed" => Token::Boxed(span)
                "break" => Token::Break(span)
                "catch" => Token::Catch(span)
                "class" => Token::Class(span)
                "continue" => Token::Continue(span)
                "cpp" => Token::Cpp(span)
                "defer" => Token::Defer(span)
                "else" => Token::Else(span)
                "enum" => Token::Enum(span)
                "extern" => Token::Extern(span)
                "false" => Token::False(span)
                "for" => Token::For(span)
                "function" => Token::Function(span)
                "if" => Token::If(span)
                "in" => Token::In(span)
                "is" => Token::Is(span)
                "let" => Token::Let(span)
                "loop" => Token::Loop(span)
                "match" => Token::Match(span)
                "mutable" => Token::Mutable(span)
                "not" => Token::Not(span)
                "or" => Token::Or(span)
                "private" => Token::Private(span)
                "public" => Token::Public(span)
                "raw" => Token::Raw(span)
                "return" => Token::Return(span)
                "restricted" => Token::Restricted(span)
                "struct" => Token::Struct(span)
                "this" => Token::This(span)
                "throw" => Token::Throw(span)
                "throws" => Token::Throws(span)
                "true" => Token::True(span)
                "try" => Token::Try(span)
                "unsafe" => Token::Unsafe(span)
                "weak" => Token::Weak(span)
                "while" => Token::While(span)
                "yield" => Token::Yield(span)
                else => Token::Identifier(name, span)
            }
        }

        let unknown_char = .input[.index]
        let end = ++.index
        .error(format("unknown character: {:c}", unknown_char), JaktSpan(start, end))
        return Token::Garbage(JaktSpan(start, end))
    }

    function lex_quoted_string(mutable this, delimiter: u8) throws -> Token {
        let start = .index

        ++.index

        if .eof() {
            .error("unexpected eof", JaktSpan(start, end: start))
            return Token::Garbage(JaktSpan(start, end: start))
        }

        let mutable escaped = false
        while not .eof() and (escaped or .peek() != delimiter) {
            if not escaped and .peek() == b'\\' {
                escaped = true
            } else {
                escaped = false
            }
            ++.index
        }

        let end = .index

        let str = .substring(start: start + 1, length: .index)

        .index++

        if delimiter == b'\'' {
            return Token::SingleQuotedString(quote: str, span: JaktSpan(start, end))
        }

        return Token::QuotedString(quote: str, span: JaktSpan(start, end))
    }

    function lex_plus(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::PlusEqual(JaktSpan(start, end: ++.index))
            b'+' => Token::PlusPlus(JaktSpan(start, end: ++.index))
            else => Token::Plus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_minus(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::MinusEqual(JaktSpan(start, end: ++.index))
            b'-' => Token::MinusMinus(JaktSpan(start, end: ++.index))
            b'>' => Token::Arrow(JaktSpan(start, end: ++.index))
            else => Token::Minus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_asterisk(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::AsteriskEqual(JaktSpan(start, end: ++.index))
            else => Token::Asterisk(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_forward_slash(mutable this) throws -> Token {
        let start = .index
        ++.index
        if .peek() == b'=' {
            return Token::ForwardSlashEqual(JaktSpan(start, end: ++.index))
        }
        if .peek() != b'/' {
            return Token::ForwardSlash(JaktSpan(start, end: .index))
        }
        // We're in a comment, swallow to end of line.
        while not .eof() {
            let c = .peek()
            .index++
            if c == b'\n' {
                break
            }
        }
        return .next() ?? Token::Eof(JaktSpan(start: .index, end: .index))
    }

    function lex_caret(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::CaretEqual(JaktSpan(start, end: ++.index))
            else => Token::Caret(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_pipe(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::PipeEqual(JaktSpan(start, end: ++.index))
            else => Token::Pipe(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_percent_sign(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::PercentSignEqual(JaktSpan(start, end: ++.index))
            else => Token::PercentSign(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_exclamation_point(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::NotEqual(JaktSpan(start, end: ++.index))
            else => Token::ExclamationPoint(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_ampersand(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::AmpersandEqual(JaktSpan(start, end: ++.index))
            else => Token::Ampersand(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_less_than(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::LessThanOrEqual(JaktSpan(start, end: ++.index))
            b'<' => Token::LeftShift(JaktSpan(start, end: ++.index))
            else => Token::LessThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_greater_than(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::GreaterThanOrEqual(JaktSpan(start, end: ++.index))
            b'>' => Token::RightShift(JaktSpan(start, end: ++.index))
            else => Token::GreaterThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_dot(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'.' => Token::DotDot(JaktSpan(start, end: ++.index))
            else => Token::Dot(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_colon(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b':' => Token::ColonColon(JaktSpan(start, end: ++.index))
            else => Token::Colon(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_question_mark(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'?' => Token::QuestionMarkQuestionMark(JaktSpan(start, end: ++.index))
            else => Token::QuestionMark(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_equals(mutable this) -> Token {
        let start = .index
        ++.index
        return match .peek() {
            b'=' => Token::DoubleEqual(JaktSpan(start, end: ++.index))
            b'>' => Token::FatArrow(JaktSpan(start, end: ++.index))
            else => Token::Equal(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function next(mutable this) throws -> Token? {
        if .eof() {
            return None
        }
        if .index == .input.size() {
            ++.index
            return Token::Eof(JaktSpan(start: .index - 1, end: .index - 1))
        }

        loop {
            let ch = .peek()
            if ch == b' ' or ch == b'\t' or ch == b'\r' {
                .index++
            } else {
                break
            }
        }

        let start = .index

        return match .input[.index] {
            b'(' => Token::LParen(JaktSpan(start, end: ++.index))
            b')' => Token::RParen(JaktSpan(start, end: ++.index))
            b'[' => Token::LSquare(JaktSpan(start, end: ++.index))
            b']' => Token::RSquare(JaktSpan(start, end: ++.index))
            b'{' => Token::LCurly(JaktSpan(start, end: ++.index))
            b'}' => Token::RCurly(JaktSpan(start, end: ++.index))
            b'<' => .lex_less_than()
            b'>' => .lex_greater_than()
            b'.' => .lex_dot()
            b',' => Token::Comma(JaktSpan(start, end: ++.index))
            b'~' => Token::Tilde(JaktSpan(start, end: ++.index))
            b';' => Token::Semicolon(JaktSpan(start, end: ++.index))
            b':' => .lex_colon()
            b'?' => .lex_question_mark()
            b'+' => .lex_plus()
            b'-' => .lex_minus()
            b'*' => .lex_asterisk()
            b'/' => .lex_forward_slash()
            b'^' => .lex_caret()
            b'|' => .lex_pipe()
            b'%' => .lex_percent_sign()
            b'!' => .lex_exclamation_point()
            b'&' => .lex_ampersand()
            b'$' => Token::Dollar(JaktSpan(start, end: ++.index))
            b'=' => .lex_equals()
            b'\n' => Token::Eol(JaktSpan(start, end: ++.index))
            b'\'' => .lex_quoted_string(delimiter: b'\'')
            b'\"' => .lex_quoted_string(delimiter: b'"')
            b'b' => .lex_character_constant_or_name()
            b'c' => .lex_character_constant_or_name()
            else => .lex_number_or_name()
        }
    }
}

function print_error(file_name: String, file_contents: [u8], error: JaktError) throws {
    match error {
        Message(message, span) => {
            display_message_with_span(severity: MessageSeverity::Error, file_name, file_contents, message, span)
        }
        MessageWithHint(message, span, hint, hint_span) => {
            display_message_with_span(severity: MessageSeverity::Error, file_name, file_contents, message, span)
            display_message_with_span(severity: MessageSeverity::Hint, file_name, file_contents, message: hint, span: hint_span)
        }
    }
}

enum MessageSeverity {
    Hint
    Error
}

function severity_name(severity: MessageSeverity) throws -> String {
    return match severity {
        MessageSeverity::Hint => "Hint"
        MessageSeverity::Error => "Error"
    }
}

function ansi_color_code(severity: MessageSeverity) throws -> String {
    return match severity {
        MessageSeverity::Hint => "94"  // Bright Blue
        MessageSeverity::Error => "31" // Red
    }
}

function display_message_with_span(severity: MessageSeverity, file_name: String, file_contents: [u8], message: String, span: JaktSpan) throws {
    println("{}: {}", severity_name(severity), message)

    let line_spans = gather_line_spans(file_contents)

    let mutable line_index = 1uz
    let largest_line_number = line_spans.size()

    let width = format("{}", largest_line_number).length()

    while line_index < line_spans.size() {
        if span.start >= line_spans[line_index].0 and span.start <= line_spans[line_index].1 {
            let column_index = span.start - line_spans[line_index].0

            println("----- \u001b[33m{}:{}:{}\u001b[0m", file_name, line_index + 1, column_index + 1)

            if line_index > 0 {
                print_source_line(severity, file_contents, file_span: line_spans[line_index - 1], error_span: span, line_number: line_index, largest_line_number)
            }

            print_source_line(severity, file_contents, file_span: line_spans[line_index], error_span: span, line_number: line_index + 1, largest_line_number)

            for x in 0..(span.start - line_spans[line_index].0 + width + 4) {
                print(" ")
            }

            println("\u001b[{}m^- {}\u001b[0m", ansi_color_code(severity), message)

            while line_index < line_spans.size() and span.end > line_spans[line_index].0 {
                ++line_index
                if line_index >= line_spans.size() {
                    break
                }

                print_source_line(severity, file_contents, file_span: line_spans[line_index], error_span: span, line_number: line_index + 1, largest_line_number)

                break
            }
        } else {
            ++line_index
        }

    }
    println("\u001b[0m-----")
}

function print_source_line(severity: MessageSeverity, file_contents: [u8], file_span: (usize, usize), error_span: JaktSpan, line_number: usize, largest_line_number: usize) throws {
    let mutable index = file_span.0

    let width = format("{}", largest_line_number).length()

    print(" {} | ", line_number)

    while index <= file_span.1 {
        let mutable c = b' '
        if index < file_span.1 {
            c = file_contents[index]
        } else if error_span.start == error_span.end and index == error_span.start {
            c = b'_'
        }

        if (index >= error_span.start and index < error_span.end) or (error_span.start == error_span.end and index == error_span.start) {
            print("\u001b[{}m{:c}", ansi_color_code(severity), c)
        } else {
            print("\u001b[0m{:c}", c)
        }

        ++index
    }
    println("")
}

function gather_line_spans(file_contents: [u8]) throws -> [(usize, usize)] {
    let mutable idx = 0uz
    let mutable output: [(usize, usize)] = []

    let mutable start = idx
    while idx < file_contents.size() {
        if file_contents[idx] == b'\n' {
            output.push((start, idx))
            start = idx + 1
        }
        idx += 1
    }
    if start < idx {
        output.push((start, idx))
    }

    return output
}

// Compiler
struct Project {
    functions: [CheckedFunction]
    scopes: [Scope]
    types: [Type]
}

struct Scope {
    functions: [String: (usize, JaktSpan)]
}

enum Type {
    Builtin
}

enum DefinitionLinkage {
    Internal
    External
}

enum DefinitionType {
    Class
    Struct
}

// Parsed Types
struct ParsedNamespace {
    name: String
    functions: [ParsedFunction]
    structs: [ParsedStruct]
}

struct ParsedStruct {
    name: String
    name_span: JaktSpan
    generic_parameters: [[String:JaktSpan]]
    fields: [ParsedField]
    methods: [ParsedMethod]
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
}

struct ParsedFunction {
    name: String
    name_span: JaktSpan
    params: [ParsedParameter]
    generic_parameters: [[String:JaktSpan]]
    block: ParsedBlock
    return_type: ParsedType
    throws: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    is_mutable: bool
    span: JaktSpan
}

struct ParsedBlock {
    stmts: [ParsedStatement]
}

boxed enum ParsedStatement {
    Expression(ParsedExpression)
    Defer(ParsedStatement)
    UnsafeBlock(ParsedBlock)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?)
    Block(ParsedBlock)
    Loop(ParsedBlock)
    While(guard: ParsedExpression, block: ParsedBlock)
    For(name: String, name_span: JaktSpan, range: ParsedExpression, block: ParsedBlock)
    Break
    Continue
    Return(expr: ParsedExpression, span: JaktSpan)
    Throw(ParsedExpression)
    Yield(ParsedExpression)
    InlineCpp(block: ParsedBlock, span: JaktSpan)
    Garbage
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    LogicalAnd
    LogicalOr
    Garbage
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    Is(ParsedType)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: JaktSpan)
    NumericConstant(val: i64, span: JaktSpan)
    QuotedString(val: String, span: JaktSpan)
    Call(call: ParsedCall, span: JaktSpan)
    Var(name: String, span: JaktSpan)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: JaktSpan)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: JaktSpan)
    BinaryOp(lhs: ParsedExpression, op: ParsedExpression, rhs: ParsedExpression, span: JaktSpan)
    Operator(op: BinaryOperator, span: JaktSpan)
    OptionalNone(JaktSpan)
    Garbage(JaktSpan)

    function is_garbage(this) -> bool {
        return match this {
            Garbage(span) => true
            else => false
        }
    }

    function span(this) -> JaktSpan {
        return match this {
            Boolean(val, span) => span
            NumericConstant(val, span) => span
            QuotedString(val, span) => span
            Call(call, span) => span
            Var(name, span) => span
            IndexedExpression(base, index, span) => span
            UnaryOp(expr, op, span) => span
            BinaryOp(lhs, op, rhs, span) => span
            Operator(op, span) => span
            OptionalNone(span) => span
            Garbage(span) => span
        }
    }

    function as_operator(this) -> BinaryOperator {
        return match this {
            Operator(op, span) => op
            else => BinaryOperator::Garbage
        }
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: JaktSpan
}

struct ParsedCall {
    name: String,
    args: [(String, ParsedExpression)]
}

boxed enum ParsedType {
    Name(name: String, span: JaktSpan)
    Array(inner: ParsedType, span: JaktSpan)
    Dictionary(key: ParsedType, value: ParsedType, span: JaktSpan)
    Set(inner: ParsedType, span: JaktSpan)
    Optional(inner: ParsedType, span: JaktSpan)
    RawPtr(inner: ParsedType, span: JaktSpan)
    WeakPtr(inner: ParsedType, span: JaktSpan)
    Empty
}

// Checked Types
// FIXME: we want a unique type for return_type_id and others, like TypeId
struct CheckedNamespace {
    name: String
    scope: usize
}

struct CheckedFunction {
    name: String
    return_type_id: usize
    params: [CheckedParameter]
    block: CheckedBlock
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

struct CheckedVariable {
    name: String
    var_type_id: usize
    is_mutable: bool
    definition_span: JaktSpan
}

struct CheckedVarDecl {
    name: String
    var_type_id: usize
    is_mutable: bool
    span: JaktSpan
}

struct CheckedBlock {
    statements: [CheckedStatement]
    definitely_returns: bool
}

boxed enum CheckedStatement {
    Expression(CheckedExpression)
    Defer(CheckedStatement)
    VarDecl(var: CheckedVarDecl, init: CheckedExpression)
    If(guard: CheckedExpression, then_block: CheckedBlock, else_block: CheckedBlock?)
    Block(CheckedBlock)
    Loop(CheckedBlock)
    While(guard: CheckedExpression, block: CheckedBlock)
    Return(CheckedExpression)
    Break
    Continue
    Throw(CheckedExpression)
    Garbage
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: JaktSpan)
    QuotedString(val: String, span: JaktSpan)
    Call(call: CheckedCall, span: JaktSpan, type: usize)
}

struct CheckedCall {
    name: String,
    args: [(String, CheckedExpression)]
    return_type: usize
}

struct Parser {
    index: usize
    tokens: [Token]
    errors: [JaktError]

    function error(mutable this, anonymous message: String, anonymous span: JaktSpan) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mutable this, anonymous message: String, anonymous span: JaktSpan, anonymous hint: String, anonymous hint_span: JaktSpan) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function peek(this, anonymous steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens[.tokens.size() - 1]
        }
        return .tokens[.index + steps]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    function eof(this) -> bool {
        return .index >= .tokens.size()
    } 

    public function parse_namespace(mutable this) throws -> ParsedNamespace {
        let mutable parsed_namespace = ParsedNamespace(name: "", functions: [], structs: [])

        let mutable should_break = false
        while not should_break and not .eof() {
            match .current() {
                Function => {
                    let function = .parse_function(FunctionLinkage::Internal)
                    parsed_namespace.functions.push(function)
                }
                Struct => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Struct)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Class => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Class)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    should_break = true
                }
                else => {
                    .error("Unrecognized token in namespace (probably not implemented yet)", .current().span())
                    should_break = true
                }
            }
        }

        return parsed_namespace
    }

    public function parse_struct(mutable this, anonymous definition_linkage: DefinitionLinkage, anonymous definition_type: DefinitionType) throws -> ParsedStruct {
        let mutable parsed_struct = ParsedStruct(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            fields: [],
            methods: [],
            definition_linkage,
            definition_type,
        )

        let definition_type_name = match definition_type {
            Struct => "struct"
            Class => "class"
        }

        let default_visibility = match definition_type {
            Struct => Visibility::Public
            Class => Visibility::Private
        }

        .index++

        // Struct name
        if .index >= .tokens.size() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        let struct_name = match .current() {
            Identifier(name) => name
            else => {
                .error(format("Invalid {} name", definition_type_name), .current().span())
                return parsed_struct
            }
        }
        parsed_struct.name = struct_name
        parsed_struct.name_span = .current().span()

        .index++

        if .index >= .tokens.size() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .index >= .tokens.size() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Struct body
        match .current() {
            LCurly(span) => {
                .index++
            }
            else => {
                .error("Expected ‘{’", .current().span())
            }
        }

        let mutable fields: [ParsedField] = []
        let mutable methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        let mutable last_visibility: Visibility? = None
        let mutable last_visibility_span: JaktSpan? = None

        let mutable should_break = false
        while not should_break and .index < .tokens.size() {
            let token = .current()
            match token {
                Eof => {
                    should_break = true
                }
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    should_break = true
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error(format("Invalid struct member, did not expect a {} here", token), token.span())
                }
            }
        }

        if .index == .tokens.size() {
            .error("Incomplete struct", .tokens[.index - 1].span())
        }
        match .current() {
            Token::RCurly(span) => {
                .index++
            }
            else => {
                .error("Incomplete struct", .tokens[.index - 1].span())
            }
        }

        parsed_struct.fields = fields
        parsed_struct.methods = methods

        return parsed_struct
    }

    public function parse_function(mutable this, anonymous linkage: FunctionLinkage) throws -> ParsedFunction {
        let mutable parsed_function = ParsedFunction(
            name: "",
            name_span: empty_span(),
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            throws: false,
        )

        .index++

        if .index >= .tokens.size() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .index >= .tokens.size() {
            .error("Incomplete function", .current().span())
        }

        match .current() {
            LParen(span) => {
                .index++
            }
            else => {
                .error("Expected '('", .current().span())
            }
        }

        let mutable params: [ParsedParameter] = []
        let mutable current_param_requires_label = true
        let mutable current_param_is_mutable = true
        let mutable should_break = false

        while not should_break and .index < .tokens.size() {
            match .current() {
                RParen => {
                    .index++
                    should_break = true
                }
                Comma => {
                    .index++
                    current_param_requires_label = true
                }
                Anonymous => {
                    current_param_requires_label = false
                    .index++
                }
                Mutable => {
                    current_param_is_mutable = true
                    .index++
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .current().span(),
                    ))
                    .index++
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration()
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .tokens[.index - 1].span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .tokens[.index - 1].span(),
                    ))
                }
                else => {
                    .error("Expected parameter", .current().span())
                }
            }
        }

        // NOTE: main() always throws
        if function_name == "main" {
            parsed_function.throws = true
        } else {
            match .current() {
                Throws => {
                    parsed_function.throws = true
                    .index++
                }
                else => { }
            }
        }

        // Accept return type specification with '->'
        let mutable return_type = ParsedType::Empty
        let mutable return_type_span: JaktSpan? = None

        match .current() {
            Arrow => {
                .index++
                let start = .current().span().start
                return_type = .parse_typename()
                return_type_span = JaktSpan(start, end: .index)
            }
            else => {}
        }

        parsed_function.block = match .current() {
            FatArrow => .parse_fat_arrow()
            else => .parse_block()
        }
        
        parsed_function.params = params

        return parsed_function
    }

    function parse_fat_arrow(mutable this) throws -> ParsedBlock {
        .index++
        let start = .current().span().start
        let expr = .parse_expression()
        let return_statement = ParsedStatement::Return(expr, span: JaktSpan(start, end: .index))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mutable this, anonymous visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration()

        match parsed_variable_declaration.parsed_type {
            Empty => {
                .error("Field missing type", parsed_variable_declaration.span)
            }
            else => {}
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mutable this, anonymous linkage: FunctionLinkage, anonymous visibility: Visibility) throws -> ParsedMethod {
        let parsed_function = .parse_function(linkage)

        // TODO: The bootstrap compiler sets parsed_function.must_instantiate here if the linkage is External.
        //       Do we still need to do that?

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mutable this) throws -> ParsedType {
        let mutable parsed_type = .parse_shorthand_type()

        match parsed_type {
            Empty => { }
            else => {
                return parsed_type
            }
        }

        match .current() {
            Raw => {
                todo("raw")
            }
            Weak => {
                todo("weak")
            }
            Identifier(name) => {
                let span = .current().span()
                .index++
                return ParsedType::Name(name, span)
            }
            else => {
                .error("Expected type name", .current().span())
            }
        }

        return parsed_type
    }

    function parse_variable_declaration(mutable this) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                match .current() {
                    Colon => {
                        .index++
                    }
                    else => {
                        return ParsedVarDecl(
                            name: var_name,
                            parsed_type: ParsedType::Empty,
                            is_mutable: false,
                            span: .tokens[.index - 1].span(),
                        )
                    }
                }

                let decl_span = .tokens[.index - 1].span()

                // We have "name:" so far.
                let mutable is_mutable = false
                match .current() {
                    Mutable => {
                        .index++
                        is_mutable = true
                    }
                    else => { }
                }

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_shorthand_type(mutable this) throws -> ParsedType {
        let start = .current().span().start
        match .current() {
            LSquare => {
                // [T] is shorthand for Array<T>
                // [K:V] is shorthand for Dictionary<K, V>
                .index++
                let inner = .parse_typename()
                match .current() {
                    RSquare => {
                        let span = JaktSpan(start, end: .current().span().end)
                        .index++
                        return ParsedType::Array(inner, span)
                    }
                    Colon => {
                        .index++
                        let value = .parse_typename()
                        match .current() {
                            RSquare => {
                                .index++
                            }
                            else => {
                                .error("Expected ']'", .current().span())
                            }
                        }
                        let span = JaktSpan(start, end: .current().span().end)
                        return ParsedType::Dictionary(key: inner, value, span)
                    }
                    else => {
                        .error("Expected shorthand type", .current().span())
                    }
                }
            }
            LCurly => {
                // {T} is shorthand for Set<T>
                let inner = .parse_typename()
                .index++

                match .current() {
                    RCurly => {
                        let span = JaktSpan(start, end: .current().span().end)
                        return ParsedType::Set(inner, span)
                    }
                    else => {
                        .error("Expected '}'", .current().span())
                    }
                }
            }
            LParen => {
                // (A, B, C) is shorthand for Tuple<A, B, C>
                todo("Implement tuple type shorthand")
            }
            else => { }
        }
        return ParsedType::Empty
    }

    function parse_block(mutable this) throws -> ParsedBlock {
        let start = .current().span().start
        let mutable block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", JaktSpan(start, end: start))
            return block
        }

        .skip_newlines()

        match .current() {
            LCurly => { .index++ }
            else => { 
                .error("Expected '{'", JaktSpan(start, end: start))
            }
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon => {
                    .index++
                }
                Eol => {
                    .index++
                }
                else => {
                    let stmt = .parse_statement()
                    block.stmts.push(stmt)
                }
            }
        }

        .error("Expected complete block", JaktSpan(start, end: .current().span().end))
        return block
    }

    function parse_statement(mutable this) throws -> ParsedStatement {
        println("parse_statement: {}", .current())
        let start = .current().span().start

        return match .current() {
            Cpp => {
                .index++
                let end = .tokens[.index - 1].span().end
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: JaktSpan(start, end))
            }
            Defer => {
                .index++
                yield ParsedStatement::Defer(.parse_statement())
            }
            Unsafe => {
                .index++
                yield ParsedStatement::UnsafeBlock(.parse_block())
            }
            Break => {
                .index++
                yield ParsedStatement::Break
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue
            }
            Loop => {
                .index++
                yield ParsedStatement::Loop(.parse_block())
            }
            Throw => {
                .index++
                yield ParsedStatement::Throw(.parse_expression())
            }
            While => {
                .index++
                let guard = .parse_expression()
                let block = .parse_block()
                yield ParsedStatement::While(guard, block)
            }
            Yield => {
                .index++
                yield ParsedStatement::Yield(.parse_expression())
            }
            Return => {
                .index++
                let expr = .parse_expression()
                let end = .tokens[.index - 1].span().end
                yield ParsedStatement::Return(expr, span: JaktSpan(start, end))
            }
            Let => {
                .index++
                let is_mutable = match .current() {
                    Mutable => {
                        .index++
                        yield true
                    }
                    else => false
                }
                let mutable var = .parse_variable_declaration()
                var.is_mutable = is_mutable

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression()
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init)
            }
            If => .parse_if_statement()
            LCurly => ParsedStatement::Block(.parse_block())
            else => ParsedStatement::Expression(.parse_expression())
        }
    }

    function parse_if_statement(mutable this) throws -> ParsedStatement {
        // FIXME: This would look nicer as `if not .current() is If`
        //        Or perhaps even `if .current() isnt If` :yakthonk:
        if match .current() {
            If => false
            else => true
        } {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression()
        let then_block = .parse_block()

        let mutable else_statement: ParsedStatement? = None

        // FIXME: This would look nicer as `if .current() is Else`
        if match .current() {
            Else => true
            else => false
        } {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    // FIXME: Lint: check that ‘if’ and ‘else’ blocks are not the same.
                    else_statement = ParsedStatement::Block(.parse_block())
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .tokens[.index - 1].span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement)
    }

    function parse_expression(mutable this) throws -> ParsedExpression {
        let mutable expr_stack: [ParsedExpression] = []
        let mutable last_prec = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eof() {
            // TODO: Check if the next token is eol, if so stop

            let op = .parse_operator()

            if op.is_garbage() {
                break
            }

            let rhs = .parse_operand()

            expr_stack.push(op)
            expr_stack.push(rhs)
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let op = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            let start = lhs.span().start
            let end = rhs.span().end

            let span = JaktSpan(start, end)

            expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span))
        }

        return expr_stack[0]
    }

    function parse_operand_base(mutable this) throws -> ParsedExpression {
        let span = .current().span()
        match .current() {
            Dot => {
                return ParsedExpression::Var(name: "this", span)
            }
            QuotedString(quote, span) => {
                .index++
                return ParsedExpression::QuotedString(val: quote, span)
            }
            Number(number, span) => {
                .index++
                return ParsedExpression::NumericConstant(val: number, span)
            }
            True => {
                .index++
                return ParsedExpression::Boolean(val: true, span)
            }
            False => {
                .index++
                return ParsedExpression::Boolean(val: true, span)
            }
            Not => {
                let start = .current().span().start
                .index++
                let expr = .parse_operand()
                let span = JaktSpan(start, end: expr.span().end)
                return ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
            }
            Identifier(name) => {
                match .peek(1) {
                    LParen => {
                        // FIXME: "Some"
                        let call = .parse_call()
                        return ParsedExpression::Call(call, span)
                    }
                    LessThan => {
                        todo("parse_operand_base generics")
                        .index++
                        return ParsedExpression::Garbage(span)
                    }
                    else => {
                        .index++
                        match name {
                            "None" => {
                                return ParsedExpression::OptionalNone(span)
                            }
                            else => {
                                return ParsedExpression::Var(name, span)
                            }
                        }
                    }
                }

                .index++
                return ParsedExpression::Var(name, span)
            }
            LParen => {
                .index++

                let expr = .parse_expression()
                match .current() {
                    RParen => {
                        .index++
                    }
                    Comma => {
                        todo("parse_operand_base tuple")
                    }
                    else => {
                        .error("Expected ')'", .current().span())
                    }
                }
            }
            else => { }
        }
        return ParsedExpression::Garbage(span)
    }

    function parse_operand(mutable this) throws -> ParsedExpression {
        .skip_newlines()
        let span = .current().span()
        let start = .current().span().start
        .skip_newlines()
        let mutable expr = .parse_operand_base()

        // Check for postfix operators, while we're at it
        return match .current() {
            DotDot => {
                todo("postfix DotDot")
                yield ParsedExpression::Garbage(span)
            }
            ExclamationPoint => {
                todo("postfix ExclamationPoint")
                yield ParsedExpression::Garbage(span)
            }
            PlusPlus => {
                let end = .current().span().end
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostIncrement,
                    span: JaktSpan(start, end),
                )
            }
            MinusMinus => {
                let end = .current().span().end
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostDecrement,
                    span: JaktSpan(start, end),
                )
            }
            Is => {
                .index++
                let parsed_type = .parse_typename()
                let span = JaktSpan(start, end: .current().span().end)
                yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(parsed_type), span)
            }
            ColonColon => {
                todo("postfix ColonColon")
                yield ParsedExpression::Garbage(span)
            }
            Dot => {
                todo("postfix Dot")
                yield ParsedExpression::Garbage(span)
            }
            LSquare => {
                // Indexing operation
                .index++
                let index_expr = .parse_expression()
                match .current() {
                    RSquare => {
                        .index++
                    }
                    else => {
                        .error("Expected ']'", .current().span())
                    }
                }
                yield ParsedExpression::IndexedExpression(
                    base: expr,
                    index: index_expr,
                    span: JaktSpan(start, end: .current().span().end))
            }
            else => expr
        }
    }

    function unknown_operator(mutable this, span: JaktSpan) throws -> BinaryOperator {
        //.error("unknown operator", span)

        return BinaryOperator::Garbage
    }

    function parse_operator(mutable this) throws -> ParsedExpression {
        let span = .current().span()
        return match .current() {
            Plus => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::Add, span)
            }
            Minus => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::Subtract, span)
            }
            Asterisk => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::Multiply, span)
            }
            ForwardSlash => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::Divide, span)
            }
            And => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::LogicalAnd, span)
            }
            Or => {
                .index++
                yield ParsedExpression::Operator(op: BinaryOperator::LogicalOr, span)
            }
            else => ParsedExpression::Garbage(span)
        }
    }

    function parse_call(mutable this) throws -> ParsedCall {
        let mutable call = ParsedCall(
            name: "",
            args: [],
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                match .current() {
                    LessThan => {
                        todo("parse_call generics")
                        .index++
                    }
                    else => { }
                }

                match .current() {
                    LParen => {
                        .index++
                    }
                    else => {
                        .error("Expected '('", .current().span())
                    }
                }

                let mutable should_break = false
                while not should_break and not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            should_break = true
                        }
                        Eol => {
                            .index++
                        }
                        Comma => {
                            .index++
                        }
                        else => {
                            let param_name = .parse_argument_label()

                            let expr = .parse_expression()
                            call.args.push((param_name, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mutable this) {
        loop { 
            let newline = match .current() {
                Eol => true
                else => false
            }
            if not newline {
                break
            }
            .index++
        }
    }

    function parse_generic_parameters(mutable this) throws -> [[String:JaktSpan]] {
        if (match .current() {
            LessThan => false
            else => true
        }) {
            return []
        }
        .index++
        let mutable generic_parameters: [[String:JaktSpan]] = []
        .skip_newlines()
        while(match .current() {
            GreaterThan => false
            Garbage => false
            else => true
        }) {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push([name : span])
                    .index++
                    match .current() {
                        Comma | Eol => {
                            .index++
                        }
                        else => {}
                    }
                }
                else => {
                    .error("expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if (match .current() {
            GreaterThan => true
            else => false
        }) {
            .index++
        } else {
            .error("expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mutable this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        match .peek(1) {
            Colon => { }
            else => {
                return ""
            }
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mutable this) throws -> Visibility {
        let mutable restricted_span = .current().span()
        
        .index++

        match .current() {
            LParen => {
                .index++
            }
            else => {
                .error("Expected ‘(’", .current().span())
            }
        }

        let mutable whitelist: [ParsedType] = []
        let mutable should_break = false
        let mutable expect_comma = false

        while not should_break and .index < .tokens.size() {
            match .current() {
                RParen => {
                    should_break = true
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        match .current() {
            RParen => {
                .index++
            }
            else => {
                .error("Expected ‘)’", .current().span())
            }
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: JaktSpan)
}

function main(args: [String]) {
    if args.size() <= 1 {
        eprintln("usage: jakt <path>")
        return 1
    }

    let mutable file = File::open_for_reading(args[1])
    let file_contents = file.read_all()

    let mutable lexer = Lexer(index: 0, input: file_contents, errors: [])
    let mutable tokens: [Token] = []

    for token in lexer {
        println("token: {}", token)
        tokens.push(token)
    }

    let mutable parser = Parser(index: 0, tokens, errors: [])

    let parsed_namespace = parser.parse_namespace()

    for error in lexer.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    for error in parser.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }

    if not lexer.errors.is_empty() or not parser.errors.is_empty() {
        return 1
    }

    println("{}", parsed_namespace)
}
