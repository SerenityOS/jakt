import lexer with Token, Span, merge_spans, empty_span, JaktError
import utility with panic, todo

enum DefinitionLinkage {
    Internal
    External
}

enum DefinitionType {
    Class
    Struct
}

struct ParsedNamespace {
    name: String?
    name_span: Span?
    functions: [ParsedFunction]
    structs: [ParsedStruct]
    namespaces: [ParsedNamespace]
    enums: [ParsedEnum]
}

struct ParsedStruct {
    name: String
    name_span: Span
    generic_parameters: [[String:Span]]
    fields: [ParsedField]
    methods: [ParsedMethod]
    definition_linkage: DefinitionLinkage
    definition_type: DefinitionType
}

struct ParsedEnum {
    definition_linkage: DefinitionLinkage,
    generic_parameters: [[String:Span]],
    is_boxed: bool,
    methods: [ParsedMethod],
    name_span: Span,
    name: String,
    underlying_type: ParsedType,
    variants: [EnumVariant],
}

enum EnumVariant {
    Untyped(name: String, span: Span)
    WithValue(name: String, value: ParsedExpression, span: Span)
    StructLike(name: String, params: [ParsedVarDecl], span: Span)
    Typed(name: String, inner_type: ParsedType, span: Span)
}

struct ParsedFunction {
    name: String
    name_span: Span
    params: [ParsedParameter]
    generic_parameters: [[String:Span]]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: Span
    throws: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    is_mutable: bool
    span: Span
}

struct ParsedBlock {
    stmts: [ParsedStatement]
}

boxed enum ParsedStatement {
    Expression(ParsedExpression)
    Defer(ParsedStatement)
    UnsafeBlock(ParsedBlock)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?)
    Block(ParsedBlock)
    Loop(ParsedBlock)
    While(guard: ParsedExpression, block: ParsedBlock)
    For(iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock)
    Break
    Continue
    Return(expr: ParsedExpression, span: Span)
    Throw(ParsedExpression)
    Yield(ParsedExpression)
    InlineCpp(block: ParsedBlock, span: Span)
    Try(stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock)
    Garbage
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    Is(ParsedType)
}

struct EnumVariantPatternArgument {
    name: String?
    binding: String
    span: Span
}

enum ParsedMatchPattern {
    EnumVariant(
        variant_name: [(String, Span)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Expression(ParsedExpression)
    CatchAll
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: Span
    body: ParsedMatchBody
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: i64, span: Span)
    QuotedString(val: String, span: Span)
    SingleQuotedString(val: String, span: Span)
    SingleQuotedByteString(val: String, span: Span)
    Call(call: ParsedCall, span: Span)
    MethodCall(expr: ParsedExpression, call: ParsedCall, span: Span)
    IndexedTuple(expr: ParsedExpression, index: usize, span: Span)
    IndexedStruct(expr: ParsedExpression, field: String, span: Span)
    Var(name: String, span: Span)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: Span)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: Span)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: Span)
    Operator(op: BinaryOperator, span: Span)
    OptionalSome(expr: ParsedExpression, span: Span)
    OptionalNone(Span)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: Span)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: Span)
    Range(from: ParsedExpression, to: ParsedExpression, span: Span)
    ForcedUnwrap(expr: ParsedExpression, span: Span)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: Span)
    Garbage(Span)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        SingleQuotedString(val, span) => span
        SingleQuotedByteString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        Match(expr, cases, span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedCall {
    name: String,
    args: [(String, ParsedExpression)]
}

boxed enum ParsedType {
    Name(name: String, span: Span)
    GenericType(name: String, generic_parameters: [(String, Span)], span: Span), // FIXME: tuple should be dictionary
    JaktArray(inner: ParsedType, span: Span)
    Dictionary(key: ParsedType, value: ParsedType, span: Span)
    JaktTuple(types: [ParsedType], span: Span)
    Set(inner: ParsedType, span: Span)
    Optional(inner: ParsedType, span: Span)
    RawPtr(inner: ParsedType, span: Span)
    WeakPtr(inner: ParsedType, span: Span)
    Empty
}

struct Parser {
    index: usize
    tokens: [Token]
    errors: [JaktError]

    function error(mut this, anon message: String, anon span: Span) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens[.tokens.size() - 1]
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(Span(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mut this) throws -> ParsedNamespace {
        //FIXME: The constructor should just be able to accept None directly and infer its type
        let none_string: String? = None
        let none_span: Span? = None
        mut parsed_namespace = ParsedNamespace(
            name: none_string
            name_span: none_span
            functions: []
            structs: []
            namespaces: []
            enums: []
        )

        while not .eof() {
            match .current() {
                Function => {
                    let function = .parse_function(FunctionLinkage::Internal)
                    parsed_namespace.functions.push(function)
                }
                Struct => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Struct)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Class => {
                    let parsed_struct = .parse_struct(DefinitionLinkage::Internal, DefinitionType::Class)
                    parsed_namespace.structs.push(parsed_struct)
                }
                Enum => {
                    let parsed_enum = .parse_enum(DefinitionLinkage::Internal, is_boxed: false)
                    parsed_namespace.enums.push(parsed_enum)
                }
                Boxed => {
                    .index++
                    let parsed_enum = .parse_enum(DefinitionLinkage::Internal, is_boxed: true)
                    parsed_namespace.enums.push(parsed_enum)
                }
                Namespace => {
                    .index++
                    let name: (String, Span)? = match .current() {
                        Identifier(name, span) => {
                            .index++
                            yield Some((name, span))
                        }
                        else => {
                            //FIXME: We should just be able to write `yield None` and have the compiler infer its type
                            let tuple_none: (String, Span)? = None
                            yield tuple_none
                        }
                    }
                    if .current() is LCurly {
                        .index++
                    } else {
                        .error("Expected ‘{’", .current().span())
                    }
                    mut namespace_ = .parse_namespace()
                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Incomplete namespace", .previous().span())
                    }
                    if name.has_value() {
                        namespace_.name = name!.0
                        namespace_.name_span = name!.1
                    }
                    parsed_namespace.namespaces.push(namespace_)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Struct)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        Class => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External, DefinitionType::Class)
                            parsed_namespace.structs.push(parsed_struct)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unrecognized token in namespace (probably not implemented yet)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    function parse_enum(mut this, anon definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ParsedEnum {
        mut enumeration = ParsedEnum(
            definition_linkage,
            generic_parameters: [],
            is_boxed,
            methods: [],
            name_span: empty_span(),
            name: "",
            underlying_type: ParsedType::Empty,
            variants: [],
        )
        .index++

        match .current() {
            Token::Identifier(name, span) => {
                enumeration.name = name
                enumeration.name_span = span
                .index++
            }
            else => {
                .error("Expected identifier for enum", .current().span())
            }
        }


        if .current() is Colon {
            .index++
            enumeration.underlying_type = .parse_typename()
        }

        if .current() is LessThan {
            enumeration.generic_parameters = .parse_generic_parameters()
        }

        if not .current() is LCurly {
            .error("Expected `{` to start the enum body", .current().span())
        }
        
        .index++
        .skip_newlines()
        if .eof() {
            .error("Expected variant name", .previous().span())
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is LParen {
                        .index += 2

                        mut var_decls: [ParsedVarDecl] = []
                        mut is_structlike = false

                        while not .eof() {
                            if .peek(1) is Colon {
                                is_structlike = true
                                let var_decl = .parse_variable_declaration(is_mutable: false)
                                match var_decl.parsed_type {
                                    Name(name) => {
                                        if name == enumeration.name {
                                            .error("use 'boxed enum' to make the enum recursive", var_decl.span)
                                        }
                                    }
                                    else => {}
                                }
                                var_decls.push(var_decl)
                                continue
                            }

                            match .current() {
                                RParen => {
                                    .index++
                                    break
                                }
                                Comma | Eol => {
                                    .index++
                                }
                                RCurly => {
                                    break
                                }
                                else => {
                                    is_structlike = false
                                    let inner_type = .parse_typename()
                                    enumeration.variants.push(EnumVariant::Typed(name, inner_type, span))
                                }
                            }
                        }

                        if is_structlike {
                            enumeration.variants.push(EnumVariant::StructLike(name, params: var_decls, span))
                        }
                    } else {
                        if .peek(1) is Equal {
                            .index += 2
                            let expr = .parse_expression(allow_assignments: false)
                            enumeration.variants.push(EnumVariant::WithValue(name, value: expr, span))
                        } else {
                            .index++
                            match enumeration.underlying_type {
                                ParsedType::Empty => {
                                    enumeration.variants.push(EnumVariant::Untyped(name, span))
                                }
                                else => {
                                    enumeration.variants.push(EnumVariant::Typed(name, inner_type: enumeration.underlying_type, span))
                                }
                            }
                        }
                    }
                }
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function => {
                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    enumeration.methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if enumeration.variants.is_empty() {
            .error("Empty enums are not allowed", enumeration.name_span)
        }
    
        return enumeration
    }

    public function parse_struct(mut this, anon definition_linkage: DefinitionLinkage, anon definition_type: DefinitionType) throws -> ParsedStruct {
        mut parsed_struct = ParsedStruct(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            fields: [],
            methods: [],
            definition_linkage,
            definition_type,
        )

        let definition_type_name = match definition_type {
            Struct => "struct"
            Class => "class"
        }

        let default_visibility = match definition_type {
            Struct => Visibility::Public
            Class => Visibility::Private
        }

        .index++

        // Struct name
        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        let struct_name = match .current() {
            Identifier(name) => name
            else => {
                .error(format("Invalid {} name", definition_type_name), .current().span())
                return parsed_struct
            }
        }
        parsed_struct.name = struct_name
        parsed_struct.name_span = .current().span()

        .index++

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error(format("Incomplete {} definition", definition_type_name), .current().span())
            return parsed_struct
        }

        // Struct body
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    break
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error(format("Invalid struct member, did not expect a {} here", token), token.span())
                }
            }
        }

        if .index == .tokens.size() {
            .error("Incomplete struct", .previous().span())
        }
        if .current() is RCurly {
            .index++
        } else {
            .error("Incomplete struct", .previous().span())
        }

        parsed_struct.fields = fields
        parsed_struct.methods = methods

        return parsed_struct
    }

    public function parse_function(mut this, anon linkage: FunctionLinkage) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            name: "",
            name_span: empty_span(),
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: Span(start: 0, end: 0)
            throws: false,
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma => {
                    .index++
                    current_param_requires_label = true
                }
                Anon => {
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .current().span(),
                    ))
                    .index++
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .previous().span(),
                    ))
                }
                else => {
                    .error("Expected parameter", .current().span())
                }
            }
        }

        parsed_function.params = params

        // NOTE: main() always throws
        if function_name == "main" {
            parsed_function.throws = true
        } else if .current() is Throws {
            parsed_function.throws = true
            .index++
        }

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedMethod {
        let parsed_function = .parse_function(linkage)

        // TODO: The bootstrap compiler sets parsed_function.must_instantiate here if the linkage is External.
        //       Do we still need to do that?

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mut this) throws -> ParsedType {
        mut parsed_type = .parse_type_shorthand()

        if not parsed_type is Empty {
            return parsed_type
        }

        let start = .current().span()

        parsed_type = match .current() {
            Raw => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
                yield match inner {
                    Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                    else => ParsedType::RawPtr(inner, span)
                }
            }
            Weak => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
                yield match inner {
                    Optional(inner) => ParsedType::WeakPtr(inner, span)
                    else => {
                        .error("missing `?` after weak pointer type name", span)
                        yield ParsedType::WeakPtr(inner, span)
                    }
                }
            }
            Identifier(name) => {
                let span = .current().span()
                .index++
                mut parsed_type =  ParsedType::Name(name, span)
                if .current() is LessThan {
                    mut parsed_generics = .parse_generic_parameters()
                    // FIXME: clean this up when ParsedType::GenericType can have [[String:Span]] generic parameters
                    mut generic_parameters: [(String, Span)] = []
                    for dict in parsed_generics.iterator() {
                        for generic in dict.iterator() { 
                            generic_parameters.push(generic)
                        }
                    }

                    parsed_type = ParsedType::GenericType(name, generic_parameters, span)
                }
                yield parsed_type
            }
            else => {
                .error("Expected type name", .current().span())
                yield ParsedType::Empty
            }
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        return parsed_type
    }

    function parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                if .current() is Colon {
                    .index++
                } else {
                    return ParsedVarDecl(
                        name: var_name,
                        parsed_type: ParsedType::Empty,
                        is_mutable,
                        span: .current().span(),
                    )
                }

                let decl_span = .current().span()

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        if .current() is LCurly {
            .index++
        }
        let inner = .parse_typename()
        if .current() is RCurly {
            .index++
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            types.push(.parse_typename())
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", merge_spans(start, .current().span()))
        return block
    }

    function parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        println("parse_statement: {}", .current())
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                yield ParsedStatement::Defer(.parse_statement(inside_block: false))
            }
            Unsafe => {
                .index++
                yield ParsedStatement::UnsafeBlock(.parse_block())
            }
            Break => {
                .index++
                yield ParsedStatement::Break
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue
            }
            Loop => {
                .index++
                yield ParsedStatement::Loop(.parse_block())
            }
            Throw => {
                .index++
                yield ParsedStatement::Throw(.parse_expression(allow_assignments: false))
            }
            While => {
                .index++
                let guard = .parse_expression(allow_assignments: false)
                let block = .parse_block()
                yield ParsedStatement::While(guard, block)
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr)
            }
            Return => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                yield ParsedStatement::Return(expr, span: merge_spans(start, .previous().span()))
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++
                let var = .parse_variable_declaration(is_mutable)

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init)
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            Try => .parse_try_statement()
            LCurly => ParsedStatement::Block(.parse_block())
            else => ParsedStatement::Expression(.parse_expression(allow_assignments: true))
        }
    }

    function parse_try_statement(mut this) throws -> ParsedStatement {
        .index++

        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            match .current() {
                Identifier(name) => {
                    error_span = .current().span()
                    error_name = name
                    .index++
                }
                else => { }
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedStatement::Try(stmt, error_name, error_span, catch_block)
    }

    function parse_for_statement(mut this) throws -> ParsedStatement {
        .index++

        return match .current() {
            Identifier(name) => {
                let iterator_name = name
                let name_span = .current().span()
                .index++
                if .current() is In {
                    .index++
                } else {
                    .error("Expected ‘in’", .current().span())
                    return ParsedStatement::Garbage
                }

                let range = .parse_expression(allow_assignments: false)
                let block = .parse_block();

                yield ParsedStatement::For(iterator_name, name_span, range, block)
            }
            else => {
                .error("Expected iterator name", .current().span())
                yield ParsedStatement::Garbage
            }
        }
    }

    function parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false)
        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        if .current() is Else {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    // FIXME: Lint: check that ‘if’ and ‘else’ blocks are not the same.
                    else_statement = ParsedStatement::Block(.parse_block())
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement)
    }

    function parse_expression(mut this, allow_assignments: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eol() {
            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = parsed_operator.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match parsed_operator {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => panic("operator is not an operator")
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => panic("operator is not an operator")
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mut this) throws -> ParsedExpression {
        let span = .current().span()
        match .current() {
            Dot => {
                return ParsedExpression::Var(name: "this", span)
            }
            QuotedString(quote, span) => {
                .index++
                return ParsedExpression::QuotedString(val: quote, span)
            }
            SingleQuotedString(quote, span) => {
                .index++
                return ParsedExpression::SingleQuotedString(val: quote, span)
            }
            SingleQuotedByteString(quote, span) => {
                .index++
                return ParsedExpression::SingleQuotedByteString(val: quote, span)
            }
            Number(number, span) => {
                .index++
                return ParsedExpression::NumericConstant(val: number, span)
            }
            True => {
                .index++
                return ParsedExpression::Boolean(val: true, span)
            }
            False => {
                .index++
                return ParsedExpression::Boolean(val: false, span)
            }
            Not => {
                let start = .current().span()
                .index++
                let expr = .parse_operand()
                let span = merge_spans(start, expr.span())
                return ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
            }
            Identifier(name) => {
                match .peek(1) {
                    LParen => {
                        match name {
                            "Some" => {
                                .index++
                                println("{}", .current())
                                let expr = .parse_expression(allow_assignments: false)
                                return ParsedExpression::OptionalSome(expr, span)
                            }
                            else => {
                                let call = .parse_call()
                                return ParsedExpression::Call(call, span)
                            }
                        }
                       
                    }
                    LessThan => {
                        todo("parse_operand_base generics")
                        .index++
                        return ParsedExpression::Garbage(span)
                    }
                    else => {
                        .index++
                        match name {
                            "None" => {
                                return ParsedExpression::OptionalNone(span)
                            }
                            else => {
                                return ParsedExpression::Var(name, span)
                            }
                        }
                    }
                }

                .index++
                return ParsedExpression::Var(name, span)
            }
            LParen => {
                .index++

                let expr = .parse_expression(allow_assignments: false)
                match .current() {
                    RParen => {
                        .index++
                    }
                    Comma => {
                        todo("parse_operand_base tuple")
                    }
                    else => {
                        .error("Expected ')'", .current().span())
                    }
                }

                return expr
            }
            PlusPlus => {
                let start = .current().span()
                .index++

                let expr = .parse_operand()
                let span = merge_spans(start, expr.span())
                return ParsedExpression::UnaryOp(expr, op: UnaryOperator::PreIncrement, span)
            }
            LSquare => {
                return .parse_array_or_dictionary_literal()
            }
            Match => {
                return .parse_match_expression()
            }
            else => { }
        }
        return ParsedExpression::Garbage(span)
    }

    function parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let span = .current().span()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()

        // Check for postfix operators, while we're at it
        return match .current() {
            DotDot => {
                .index++
                let to = .parse_expression(allow_assignments: false)
                yield ParsedExpression::Range(from: expr, to, span: merge_spans(start, to.span()))
            }
            ExclamationPoint => {
                .index++
                yield ParsedExpression::ForcedUnwrap(expr, span: merge_spans(start, .previous().span()))
            }
            PlusPlus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostIncrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            MinusMinus => {
                .index++
                yield ParsedExpression::UnaryOp(
                    expr,
                    op: UnaryOperator::PostDecrement,
                    span: merge_spans(start, .previous().span()),
                )
            }
            Is => {
                .index++
                let parsed_type = .parse_typename()
                let span = merge_spans(start, .current().span())
                yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(parsed_type), span)
            }
            ColonColon => {
                todo("postfix ColonColon")
                yield ParsedExpression::Garbage(span)
            }
            Dot => {
                .index++
                yield match .current() {
                    Number(number) => {
                        // Indexing into a tuple
                        .index++
                        // FIXME: Proper numeric constants.
                        yield ParsedExpression::IndexedTuple(expr, index: number as! usize, span: merge_spans(start, end: .previous().span()))
                    }
                    Identifier(name) => {
                        // Struct field access or method call
                        .index++
                        yield match .current() {
                            LParen => {
                                // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                .index--
                                let call = .parse_call()
                                yield ParsedExpression::MethodCall(expr, call, span: merge_spans(start, end: .previous().span()))
                            }
                            else => ParsedExpression::IndexedStruct(expr, field: name, span: merge_spans(start, end: .current().span()))
                        }
                    }
                    else => {
                        .error("Unsupported dot operation", .current().span())
                        .index++
                        yield expr
                    }
                }
            }
            LSquare => {
                // Indexing operation
                .index++
                let index_expr = .parse_expression(allow_assignments: false)
                if .current() is RSquare {
                    .index++
                } else {
                    .error("Expected ']'", .current().span())
                }
                yield ParsedExpression::IndexedExpression(
                    base: expr,
                    index: index_expr,
                    span: merge_spans(start, .current().span()))
            }
            else => expr
        }
    }

    function parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let expr = .parse_expression(allow_assignments: false)
        let cases = .parse_match_cases()

        return ParsedExpression::Match(expr, cases, span: merge_spans(start, .previous().span()))
    }

    function parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            let marker_span = .current().span()
            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false))
            }

            cases.push(ParsedMatchCase(patterns, marker_span, body))

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    function parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            let pattern = .parse_match_pattern()
            patterns.push(pattern)
            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    function parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | SingleQuotedByteString
        | LParen => ParsedMatchPattern::Expression(.parse_expression(allow_assignments: false))

        Else => {
            .index++
            yield ParsedMatchPattern::CatchAll
        }

        Identifier(name) => {
            let pattern_start_index = .index
            mut variant_name: [(String, Span)] = []

            while .current() is Identifier {
                .index++
                variant_name.push((name, .current().span()))
                if .current() is ColonColon {
                    .index++
                } else {
                    break
                }
            }

            mut variant_arguments: [EnumVariantPatternArgument] = []
            mut has_parens = false
            let arguments_start = .current().span()

            if .current() is LParen {
                has_parens = true
                .index++

                while not .eof() {
                    match .current() {
                        Identifier(name) => {
                            let arg_name = name
                            if .peek(1) is Colon {
                                .index++
                                match .current() {
                                    Identifier(name) => {
                                        let arg_binding = name
                                        let span = .current().span()
                                        .index++
                                        variant_arguments.push(EnumVariantPatternArgument(
                                            name: Some(arg_name)
                                            binding: arg_binding
                                            span))
                                    }
                                    else => {
                                        .error("Expected binding after ‘:’", .current().span())
                                    }
                                }
                            } else {
                                // FIXME: Hack since compiler doesn't recognize `None` in tuple.
                                let none: String? = None
                                variant_arguments.push(EnumVariantPatternArgument(
                                            name: none
                                            binding: arg_name
                                            span: .current().span()))
                            }
                        }
                        RParen => {
                            .index++
                            break
                        }
                        else => {
                            .error("Expected pattern argument name", .current().span())
                            break
                        }
                    }
                }
            }

            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                variant_name
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::CatchAll
        }
    }

    function parse_call(mut this) throws -> ParsedCall {
        mut call = ParsedCall(
            name: "",
            args: [],
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                if .current() is LessThan {
                    todo("parse_call generics")
                }

                if .current() is LParen {
                    .index++
                } else {
                    .error("Expected '('", .current().span())
                }

                while  not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            break
                        }
                        Eol | Comma => {
                            .index++
                        }
                        else => {
                            let param_name = .parse_argument_label()

                            let expr = .parse_expression(allow_assignments: false)
                            call.args.push((param_name, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mut this) throws -> [[String:Span]] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [[String:Span]] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push([name : span])
                    .index++
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                else => {
                    .error("expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mut this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        if not .peek(1) is Colon {
            return ""
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        mut whitelist: [ParsedType] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false);
                    } else {
                        .error("Can't fill array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if expr is Garbage {
                        break
                    }

                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: Span)
}
