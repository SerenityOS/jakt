// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
//
// SPDX-License-Identifier: BSD-2-Clause

import error { JaktError }
import lexer { Token }
import utility { panic, todo, Span }

function merge_spans(anon start: Span, anon end: Span) -> Span => Span(start: start.start, end: end.end)
function empty_span() -> Span => Span(start: 0, end: 0)

enum DefinitionLinkage {
    Internal
    External
}

struct ImportName {
    name: String
    span: Span
}

struct ParsedImport {
    module_name: ImportName
    import_list: [ImportName]
}

struct ParsedNamespace {
    name: String?
    name_span: Span?
    functions: [ParsedFunction]
    records: [ParsedRecord]
    namespaces: [ParsedNamespace]
    imports: [ParsedImport]
}
struct ValueEnumVariant {
  name: String
  span: Span
  value: ParsedExpression?
}
struct SumEnumVariant {
  name: String
  span: Span
  params: [ParsedVarDecl]?
}
enum RecordType {
    Struct(fields: [ParsedField])
    Class(fields: [ParsedField], super_class: ParsedType?)
    ValueEnum(underlying_type: ParsedType, variants: [ValueEnumVariant])
    SumEnum(is_boxed: bool, variants: [SumEnumVariant])
    Garbage
}
struct ParsedRecord {
    name: String
    name_span: Span
    generic_parameters: [[String:Span]]
    definition_linkage: DefinitionLinkage
    methods: [ParsedMethod]
    record_type: RecordType
}

struct ParsedFunction {
    name: String
    name_span: Span
    params: [ParsedParameter]
    generic_parameters: [[String:Span]]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: Span
    throws: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    is_mutable: bool
    span: Span
}

struct ParsedBlock {
    stmts: [ParsedStatement]
}

boxed enum ParsedStatement {
    Expression(ParsedExpression)
    Defer(ParsedStatement)
    UnsafeBlock(ParsedBlock)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?)
    Block(ParsedBlock)
    Loop(ParsedBlock)
    While(guard: ParsedExpression, block: ParsedBlock)
    For(iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock)
    Break
    Continue
    Return(expr: ParsedExpression, span: Span)
    Throw(ParsedExpression)
    Yield(ParsedExpression)
    InlineCpp(block: ParsedBlock, span: Span)
    Try(stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock)
    Garbage
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum TypeCast {
    Fallible(ParsedType)
    Infallible(ParsedType)
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(TypeCast)
    Is(ParsedType)
}

struct EnumVariantPatternArgument {
    name: String?
    binding: String
    span: Span
}

enum ParsedMatchPattern {
    EnumVariant(
        variant_name: [(String, Span)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Expression(ParsedExpression)
    CatchAll
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: Span
    body: ParsedMatchBody
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: i64, span: Span)
    QuotedString(val: String, span: Span)
    SingleQuotedString(val: String, span: Span)
    SingleQuotedByteString(val: String, span: Span)
    Call(call: ParsedCall, span: Span)
    MethodCall(expr: ParsedExpression, call: ParsedCall, span: Span)
    IndexedTuple(expr: ParsedExpression, index: usize, span: Span)
    IndexedStruct(expr: ParsedExpression, field: String, span: Span)
    Var(name: String, span: Span)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: Span)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: Span)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: Span)
    Operator(op: BinaryOperator, span: Span)
    OptionalSome(expr: ParsedExpression, span: Span)
    OptionalNone(Span)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: Span)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: Span)
    JaktTuple(values: [ParsedExpression], span: Span)
    Range(from: ParsedExpression, to: ParsedExpression, span: Span)
    ForcedUnwrap(expr: ParsedExpression, span: Span)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: Span)
    NamespacedVar(name: String, namespace_: [String], span: Span)
    Garbage(Span)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        SingleQuotedString(val, span) => span
        SingleQuotedByteString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        JaktTuple(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        Match(expr, cases, span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
        NamespacedVar(name, namespace_, span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedCall {
    namespace_: [String]
    name: String
    args: [(String, ParsedExpression)]
    type_args: [ParsedType]
}

boxed enum ParsedType {
    Name(name: String, span: Span)
    NamespacedName(name: String, namespaces: [String], params: [ParsedType], span: Span)
    GenericType(name: String, generic_parameters: [(String, Span)], span: Span), // FIXME: tuple should be dictionary
    JaktArray(inner: ParsedType, span: Span)
    Dictionary(key: ParsedType, value: ParsedType, span: Span)
    JaktTuple(types: [ParsedType], span: Span)
    Set(inner: ParsedType, span: Span)
    Optional(inner: ParsedType, span: Span)
    RawPtr(inner: ParsedType, span: Span)
    WeakPtr(inner: ParsedType, span: Span)
    Empty
}

struct Parser {
    index: usize
    tokens: [Token]
    errors: [JaktError]

    function error(mut this, anon message: String, anon span: Span) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens[.tokens.size() - 1]
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(Span(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mut this) throws -> ParsedNamespace {
        //FIXME: The constructor should just be able to accept None directly and infer its type
        let none_string: String? = None
        let none_span: Span? = None
        mut parsed_namespace = ParsedNamespace(
            name: none_string
            name_span: none_span
            functions: []
            records: []
            namespaces: []
            imports: []
        )

        while not .eof() {
            match .current() {
                Import => {
                    parsed_namespace.imports.push(.parse_import())
                }
                Function => {
                    let parsed_function = .parse_function(FunctionLinkage::Internal)
                    parsed_namespace.functions.push(parsed_function)
                }
                Struct | Class | Enum | Boxed => {
                    let parsed_record = .parse_record(DefinitionLinkage::Internal)
                    parsed_namespace.records.push(parsed_record)
                }
                Namespace => {
                    .index++
                    let name: (String, Span)? = match .current() {
                        Identifier(name, span) => {
                            .index++
                            yield Some((name, span))
                        }
                        else => {
                            //FIXME: We should just be able to write `yield None` and have the compiler infer its type
                            let tuple_none: (String, Span)? = None
                            yield tuple_none
                        }
                    }
                    if .current() is LCurly {
                        .index++
                    } else {
                        .error("Expected ‘{’", .current().span())
                    }
                    mut namespace_ = .parse_namespace()
                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Incomplete namespace", .previous().span())
                    }
                    if name.has_value() {
                        namespace_.name = name!.0
                        namespace_.name_span = name!.1
                    }
                    parsed_namespace.namespaces.push(namespace_)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_struct)
                        }
                        Class => {
                            let parsed_class = .parse_class(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_class)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unrecognized token in namespace (probably not implemented yet)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    function parse_record(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord => match .current() {
        Struct => .parse_struct(definition_linkage)
        Class => .parse_class(definition_linkage)
        Enum => .parse_enum(definition_linkage, is_boxed: false)
        Boxed => {
            .index++
            yield .parse_enum(definition_linkage, is_boxed: true)
        }
        else => {
            .error("Expected `struct`, `class`, `enum`, or `boxed`", .current().span())
            yield ParsedRecord(
                name: "",
                name_span: empty_span(),
                generic_parameters: [],
                definition_linkage,
                methods: [],
                record_type: RecordType::Garbage
            )
        }
    }

    function parse_import(mut this) throws -> ParsedImport {
        mut parsed_import = ParsedImport(
            module_name: ImportName(name: "", span: .current().span())
            import_list: []
        )

        .index++
        parsed_import.module_name = match .current() {
            Identifier(name, span) => ImportName(name, span)
            else => {
                .error("Expected module name", .current().span())
                return parsed_import
            }
        }

        .index++

        if .eol() {
            return parsed_import
        }

        // FIXME: Parse module alias

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        while not .eol() {
            match .current() {
                Identifier(name, span) => {
                    parsed_import.import_list.push(ImportName(name, span))
                    .index++
                }
                Comma => {
                    .index++
                }
                RCurly => {
                    .index++
                    break
                }
                else => {
                    .error("Expected import symbol", .current().span())
                    .index++
                }
            }
        }

        return parsed_import
    }

    function parse_value_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage) throws -> ([ValueEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [ValueEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is Equal {
                        .index += 2
                        let expr = .parse_expression(allow_assignments: false)
                        variants.push(ValueEnumVariant(name, span, value: expr))
                    } else {
                        .index++
                        let none_expr: ParsedExpression? = None
                        variants.push(ValueEnumVariant(name, span, value: none_expr))
                    }
                }
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function => {
                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if .eof() {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_sum_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage is_boxed: bool) throws -> ([SumEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [SumEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is LParen {
                        .index += 2

                        mut var_decls: [ParsedVarDecl] = []

                        while not .eof() {
                            if .peek(1) is Colon {
                                let var_decl = .parse_variable_declaration(is_mutable: false)
                                match var_decl.parsed_type {
                                    Name(name) => {
                                        if name == partial_enum.name and not is_boxed{
                                            .error("use 'boxed enum' to make the enum recursive", var_decl.span)
                                        }
                                    }
                                    else => {}
                                }
                                var_decls.push(var_decl)
                                continue
                            }

                            match .current() {
                                RParen => {
                                    .index++
                                    break
                                }
                                Comma | Eol => {
                                    .index++
                                }
                                else => {
                                    .error("Incomplete enum variant defintion, expected `,` or `)`", .current().span())
                                    break;
                                }
                            }
                        }
                        variants.push(SumEnumVariant(name, span, params: var_decls))
                    } else {
                        let none_decls: [ParsedVarDecl]? = None
                        variants.push(SumEnumVariant(name, span, params: none_decls))
                    }
                }
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function => {
                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if .eof() {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_enum(mut this, anon definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ParsedRecord {
        mut parsed_enum = ParsedRecord(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut underlying_type: ParsedType? = None
        if .current() is Enum {
            .index++
        } else {
            .error("expected `enum` keyword", .current().span())
            return parsed_enum
        }

        if .eof() {
            .error("Incomplete enum definition, expected name", .current().span())
            return parsed_enum
        }

        match .current() {
            Token::Identifier(name, span) => {
                parsed_enum.name = name
                parsed_enum.name_span = span
                .index++
            }
            else => {
                .error("Incomplete enum definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete enum definition, expected generic parameters or underlying type or body", .current().span())
            return parsed_enum
        }


        if .current() is LessThan {
            parsed_enum.generic_parameters = .parse_generic_parameters()
        }

        if .eof() {
            .error("Incomplete enum definition, expected underlying type or body", .current(). span())
            return parsed_enum
        }

        if .current() is Colon {
            if is_boxed {
                .error("Invalid enum definition: Value enums must not have an underlying type", .current().span())
            }
            .index++
            underlying_type = .parse_typename()
        }

        if .eof() {
            .error("Incomplete enum definition, expected body", .current().span())
            return parsed_enum
        }

        if underlying_type.has_value() {
            let variants_methods = .parse_value_enum_body(partial_enum: parsed_enum, definition_linkage)
            parsed_enum.methods = variants_methods.1
            parsed_enum.record_type = RecordType::ValueEnum(
                underlying_type: underlying_type!
                variants: variants_methods.0
            )
        } else {
            let variants_methods = .parse_sum_enum_body(partial_enum: parsed_enum, definition_linkage, is_boxed)
            parsed_enum.methods = variants_methods.1
            parsed_enum.record_type = RecordType::SumEnum(
                is_boxed: is_boxed,
                variants: variants_methods.0
            )
        }

        return parsed_enum
    }

    public function parse_struct_class_body(mut this, definition_linkage: DefinitionLinkage default_visibility: Visibility) throws -> ([ParsedField],[ParsedMethod]) {
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None

        // Have we already found an error?
        mut error = false;

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    .index++
                    break
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error(format("Invalid member, did not expect a {} here", token), token.span())
                        error = true
                    }
                    .index++
                }
            }
        }
        return (fields, methods)
    }

    public function parse_struct(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord{
        mut parsed_struct = ParsedRecord(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        if .current() is Struct {
            .index++
        } else {
            .error("expected `struct` keyword", .current().span())
            return parsed_struct
        }
        // Struct name
        if .eof() {
            .error("Incomplete struct definition, expected name", .current().span())
            return parsed_struct
        }

        match .current() {
            Identifier(name, span) => {
                .index++
                parsed_struct.name = name
                parsed_struct.name_span = span
            }
            else => {
                .error("Incomplete struct definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete struct definition, expected generic parameters or body", .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete struct definition, expected body", .current().span())
            return parsed_struct
        }

	let fields_methods = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Public)

	if .eof() {
	    .error("Incomplete struct definition, expected `}`", .current().span())
	    return parsed_struct
	}

        parsed_struct.methods = fields_methods.1
        parsed_struct.record_type = RecordType::Struct(fields: fields_methods.0)

        return parsed_struct
    }

    public function parse_class(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_class = ParsedRecord(
            name: "",
            name_span: empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut super_class: ParsedType? = None
        if .current() is Class {
            .index++
        } else {
            .error("expected `class` keyword", .current().span())
            return parsed_class
        }
        // Class name
        if .eof() {
            .error("Incomplete class definition, expected name", .current().span())
            return parsed_class
        }

        match .current() {
            Identifier(name, span) => {
                .index++
                parsed_class.name = name
                parsed_class.name_span = span
            }
            else => {
                .error("Incomplete class definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete class definition, expected generic parameters or super class or body", .current().span())
            return parsed_class
        }

        // Generic parameters
        parsed_class.generic_parameters = .parse_generic_parameters()


        if .eof() {
            .error("Incomplete class definition, expected super class or body", .current().span())
            return parsed_class
        }

        // Super class
        if .current() is Colon {
            .index++
            super_class = .parse_typename()
        }

        if .eof() {
            .error("Incomplete class definition, expected body", .current().span())
            return parsed_class
        }

	let fields_methods = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Private)

	if .eof() {
	    .error("Incomplete struct definition, expected `}`", .current().span())
	    return parsed_class
	}

        parsed_class.methods = fields_methods.1
        parsed_class.record_type = RecordType::Class(fields: fields_methods.0, super_class)

        return parsed_class
    }

    public function parse_function(mut this, anon linkage: FunctionLinkage) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            name: "",
            name_span: empty_span(),
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: Span(start: 0, end: 0)
            throws: false,
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        // Have we already found an error?
        mut error = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma => {
                    .index++
                    current_param_requires_label = true
                }
                Anon => {
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .current().span(),
                    ))
                    .index++
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        is_mutable: current_param_is_mutable,
                        span: .previous().span(),
                    ))
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                }
            }
        }

        parsed_function.params = params

        // NOTE: main() always throws
        if function_name == "main" {
            parsed_function.throws = true
        } else if .current() is Throws {
            parsed_function.throws = true
            .index++
        }

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedMethod {
        let parsed_function = .parse_function(linkage)

        // TODO: The bootstrap compiler sets parsed_function.must_instantiate here if the linkage is External.
        //       Do we still need to do that?

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mut this) throws -> ParsedType {
        mut parsed_type = .parse_type_shorthand()

        if not parsed_type is Empty {
            return parsed_type
        }

        let start = .current().span()

        parsed_type = match .current() {
            Raw => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
                yield match inner {
                    Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                    else => ParsedType::RawPtr(inner, span)
                }
            }
            Weak => {
                .index++
                let inner = .parse_typename()
                let span = merge_spans(start, .current().span())
                // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
                yield match inner {
                    Optional(inner) => ParsedType::WeakPtr(inner, span)
                    else => {
                        .error("missing `?` after weak pointer type name", span)
                        yield ParsedType::WeakPtr(inner, span)
                    }
                }
            }
            Identifier(name) => {
                let span = .current().span()
                .index++
                mut parsed_type =  ParsedType::Name(name, span)
                if .current() is LessThan {
                    mut parsed_generics = .parse_generic_parameters()
                    // FIXME: clean this up when ParsedType::GenericType can have [[String:Span]] generic parameters
                    mut generic_parameters: [(String, Span)] = []
                    for dict in parsed_generics.iterator() {
                        for generic in dict.iterator() { 
                            generic_parameters.push(generic)
                        }
                    }

                    parsed_type = ParsedType::GenericType(name, generic_parameters, span)
                }
                yield parsed_type
            }
            else => {
                .error("Expected type name", .current().span())
                yield ParsedType::Empty
            }
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        return parsed_type
    }

    function parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                if .current() is Colon {
                    .index++
                } else {
                    return ParsedVarDecl(
                        name: var_name,
                        parsed_type: ParsedType::Empty,
                        is_mutable,
                        span: .current().span(),
                    )
                }

                let decl_span = .current().span()

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        if .current() is LCurly {
            .index++
        }
        let inner = .parse_typename()
        if .current() is RCurly {
            .index++
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            types.push(.parse_typename())
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", merge_spans(start, .current().span()))
        return block
    }

    function parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                yield ParsedStatement::Defer(.parse_statement(inside_block: false))
            }
            Unsafe => {
                .index++
                yield ParsedStatement::UnsafeBlock(.parse_block())
            }
            Break => {
                .index++
                yield ParsedStatement::Break
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue
            }
            Loop => {
                .index++
                yield ParsedStatement::Loop(.parse_block())
            }
            Throw => {
                .index++
                yield ParsedStatement::Throw(.parse_expression(allow_assignments: false))
            }
            While => {
                .index++
                let guard = .parse_expression(allow_assignments: false)
                let block = .parse_block()
                yield ParsedStatement::While(guard, block)
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr)
            }
            Return => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                yield ParsedStatement::Return(expr, span: merge_spans(start, .previous().span()))
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++
                let var = .parse_variable_declaration(is_mutable)

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init)
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            Try => .parse_try_statement()
            LCurly => ParsedStatement::Block(.parse_block())
            else => ParsedStatement::Expression(.parse_expression(allow_assignments: true))
        }
    }

    function parse_try_statement(mut this) throws -> ParsedStatement {
        .index++

        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            match .current() {
                Identifier(name) => {
                    error_span = .current().span()
                    error_name = name
                    .index++
                }
                else => { }
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedStatement::Try(stmt, error_name, error_span, catch_block)
    }

    function parse_for_statement(mut this) throws -> ParsedStatement {
        .index++

        return match .current() {
            Identifier(name) => {
                let iterator_name = name
                let name_span = .current().span()
                .index++
                if .current() is In {
                    .index++
                } else {
                    .error("Expected ‘in’", .current().span())
                    return ParsedStatement::Garbage
                }

                let range = .parse_expression(allow_assignments: false)
                let block = .parse_block();

                yield ParsedStatement::For(iterator_name, name_span, range, block)
            }
            else => {
                .error("Expected iterator name", .current().span())
                yield ParsedStatement::Garbage
            }
        }
    }

    function parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false)
        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        if .current() is Else {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    // FIXME: Lint: check that ‘if’ and ‘else’ blocks are not the same.
                    else_statement = ParsedStatement::Block(.parse_block())
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement)
    }

    function parse_expression(mut this, allow_assignments: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eol() {
            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = parsed_operator.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match parsed_operator {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => panic("operator is not an operator")
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => panic("operator is not an operator")
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mut this) throws => match .current() {
        Dot(span) => {
            yield ParsedExpression::Var(name: "this", span)
        }
        QuotedString(quote, span) => {
            .index++
            yield ParsedExpression::QuotedString(val: quote, span)
        }
        SingleQuotedString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedString(val: quote, span)
        }
        SingleQuotedByteString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedByteString(val: quote, span)
        }
        Number(number, span) => {
            .index++
            yield ParsedExpression::NumericConstant(val: number, span)
        }
        True(span) => {
            .index++
            yield ParsedExpression::Boolean(val: true, span)
        }
        False(span) => {
            .index++
            yield ParsedExpression::Boolean(val: false, span)
        }
        Not(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
        }
        Identifier(name, span) => {
            if .peek(1) is LParen {
                if name == "Some" {
                    .index++
                    let expr = .parse_expression(allow_assignments: false)
                    return ParsedExpression::OptionalSome(expr, span)
                }
                let call = .parse_call()
                return ParsedExpression::Call(call: call!, span)
            }
            if .peek(1) is LessThan {
                // We *try* to see if it's a generic, but the parse errors, we back up and try something else
                let call = .parse_call()
                if not call.has_value() {
                    return match name {
                        "None" => ParsedExpression::OptionalNone(span)
                        else => ParsedExpression::Var(name, span)
                    }
                }
                return ParsedExpression::Call(call: call!, span)
            }
            .index++
            if name == "None" {
                return ParsedExpression::OptionalNone(span)
            }
            yield ParsedExpression::Var(name, span)
        }
        LParen(span) => {
            let start_span = .current().span()
            .index++
            
            mut expr = .parse_expression(allow_assignments: false)

            .skip_newlines()

            match .current() {
                RParen => {
                    .index++
                }
                Comma => {
                    // We have a tuple
                    .index++

                    mut tuple_exprs: [ParsedExpression] = [expr]
                    mut end_span = start_span

                    while not .eof() {
                        match .current() {
                            Eol | Comma => {
                                .index++
                            }
                            RParen => {
                                .index++
                                break
                            }
                            else => {
                                let expr = .parse_expression(allow_assignments: false)
                                end_span = expr.span()
                                tuple_exprs.push(expr)
                            }
                        }
                    }

                    if .eof() {
                        .error("Expected ')'", .current().span());
                    }

                    expr = ParsedExpression::JaktTuple(
                        values: tuple_exprs,
                        span: merge_spans(start_span, end_span)
                    )
                }
                else => {
                    .error("Expected ')'", .current().span())
                }
            }

            yield expr
        }
        PlusPlus(span) => {
            let start = .current().span()
            .index++

            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::PreIncrement, span)
        }
        LSquare => {
            yield .parse_array_or_dictionary_literal()
        }
        Match => {
            yield .parse_match_expression()
        }
        else => {
            let span = .current().span()
            .index++
            .error("Unsupported expression", span)
            yield ParsedExpression::Garbage(span)
        }
    }
    

    function parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()
        return .parse_operand_postfix_operator(start, expr)
    }

    function parse_operand_postfix_operator(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression => match .current() {
        DotDot => {
            .index++
            let to = .parse_expression(allow_assignments: false)
            yield ParsedExpression::Range(from: expr, to, span: merge_spans(start, to.span()))
        }
        ExclamationPoint => {
            .index++
            yield ParsedExpression::ForcedUnwrap(expr, span: merge_spans(start, .previous().span()))
        }
        PlusPlus => {
            .index++
            yield ParsedExpression::UnaryOp(
                expr,
                op: UnaryOperator::PostIncrement,
                span: merge_spans(start, .previous().span()),
            )
        }
        MinusMinus => {
            .index++
            yield ParsedExpression::UnaryOp(
                expr,
                op: UnaryOperator::PostDecrement,
                span: merge_spans(start, .previous().span()),
            )
        }
        As => {
            .index++
            let cast_span = merge_spans(.previous().span(), .current().span())
            let cast = match .current() {
                ExclamationPoint => {
                    .index++
                    yield TypeCast::Infallible(.parse_typename())
                }
                QuestionMark => {
                    .index++
                    yield TypeCast::Fallible(.parse_typename())
                }
                else => {
                    .error("Invalid cast syntax", cast_span)
                    yield TypeCast::Fallible(ParsedType::Empty)
                }
            }
            let span = merge_spans(start, merge_spans(cast_span, .current().span()))
            yield ParsedExpression::UnaryOp(
                expr,
                op: UnaryOperator::TypeCast(cast),
                span
            )
        }
        Is => {
            .index++
            let parsed_type = .parse_typename()
            let span = merge_spans(start, .current().span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(parsed_type), span)
        }
        ColonColon => .parse_postfix_colon_colon(start, expr)
        Dot => {
            .index++
            yield match .current() {
                Number(number) => {
                    // Indexing into a tuple
                    .index++
                    // FIXME: Proper numeric constants.
                    yield ParsedExpression::IndexedTuple(expr, index: number as! usize, span: merge_spans(start, end: .previous().span()))
                }
                Identifier(name) => {
                    // Struct field access or method call
                    .index++
                    yield match .current() {
                        LParen => {
                            // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                            .index--
                            let call = .parse_call()
                            yield ParsedExpression::MethodCall(expr, call: call!, span: merge_spans(start, end: .previous().span()))
                        }
                        else => ParsedExpression::IndexedStruct(expr, field: name, span: merge_spans(start, end: .current().span()))
                    }
                }
                else => {
                    .error("Unsupported dot operation", .current().span())
                    .index++
                    yield expr
                }
            }
        }
        LSquare => {
            // Indexing operation
            .index++
            let index_expr = .parse_expression(allow_assignments: false)
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            yield ParsedExpression::IndexedExpression(
                base: expr,
                index: index_expr,
                span: merge_spans(start, .current().span()))
        }
        else => expr
    }

    function parse_postfix_colon_colon(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        .index++
        mut namespace_: [String] = []
        match expr {
            Var(name) => {
                namespace_.push(name)
            }
            else => {
                .error("Expected namespace", expr.span())
            }
        }
        if .eof() {
            .error("Incomplete static method call", .current().span())
        }
        while not .eof() {
            let current_name = match .current() {
                Identifier(name) => name
                else => {
                    .error("Unsupported static method call", .current().span())
                    return expr
                }
            }
            .index++
            if .current() is LParen {
                .index--
                mut call = .parse_call()
                call!.namespace_ = namespace_
                return ParsedExpression::Call(call: call!, span: merge_spans(expr.span(), .current().span()))
            }
            if .current() is ColonColon {
                match .previous() {
                    Identifier(name) => {
                        namespace_.push(name)
                    }
                    else => {
                        .error("Expected namespace", expr.span())
                    }
                }
                .index++
                continue
            }
            if .current() is LessThan {
                // Generic function arguments
                .index--
                let maybe_call = .parse_call()
                if maybe_call.has_value() {
                    mut call = maybe_call!
                    call.namespace_ = namespace_
                    return ParsedExpression::Call(call, span: merge_spans(expr.span(), .current().span()))
                }
                return ParsedExpression::Garbage(.current().span())
            }
            return ParsedExpression::NamespacedVar(
                name: current_name,
                namespace_,
                span: merge_spans(start, .current().span())
            )
        }
        // FIXME: This is not reachable, so a return should not be required.
        return ParsedExpression::Garbage(.current().span())
    }

    function parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let expr = .parse_expression(allow_assignments: false)
        let cases = .parse_match_cases()

        return ParsedExpression::Match(expr, cases, span: merge_spans(start, .previous().span()))
    }

    function parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            let marker_span = .current().span()
            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false))
            }

            cases.push(ParsedMatchCase(patterns, marker_span, body))

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    function parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            let pattern = .parse_match_pattern()
            patterns.push(pattern)
            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    function parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | SingleQuotedByteString
        | LParen => ParsedMatchPattern::Expression(.parse_expression(allow_assignments: false))

        Else => {
            .index++
            yield ParsedMatchPattern::CatchAll
        }

        Identifier(name) => {
            let pattern_start_index = .index
            mut variant_name: [(String, Span)] = []

            while not .eof() {
                match .current() {
                    Identifier(name) => {
                        .index++
                        variant_name.push((name, .current().span()))
                    }
                    ColonColon => {
                        .index++
                    }
                    else => {
                        break
                    }
                }
            }

            mut variant_arguments: [EnumVariantPatternArgument] = []
            mut has_parens = false
            let arguments_start = .current().span()

            if .current() is LParen {
                has_parens = true
                .index++

                while not .eof() {
                    match .current() {
                        Identifier(name) => {
                            let arg_name = name
                            if .peek(1) is Colon {
                                .index += 2
                                match .current() {
                                    Identifier(name) => {
                                        let arg_binding = name
                                        let span = .current().span()
                                        .index++
                                        variant_arguments.push(EnumVariantPatternArgument(
                                            name: Some(arg_name)
                                            binding: arg_binding
                                            span))
                                    }
                                    else => {
                                        .error("Expected binding after ‘:’", .current().span())
                                    }
                                }
                            } else {
                                // FIXME: Hack since compiler doesn't recognize `None` in tuple.
                                let none: String? = None
                                variant_arguments.push(EnumVariantPatternArgument(
                                            name: none
                                            binding: arg_name
                                            span: .current().span()))
                                .index++
                            }
                        }
                        Comma => {
                            .index++
                        }
                        RParen => {
                            .index++
                            break
                        }
                        else => {
                            .error("Expected pattern argument name", .current().span())
                            break
                        }
                    }
                }
            }

            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                variant_name
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::CatchAll
        }
    }

    function parse_call(mut this) throws -> ParsedCall? {
        mut call = ParsedCall(
            namespace_: []
            name: ""
            args: []
            type_args: []
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                // This is to allow the lookahead. Without it, we may see something like
                // foo < Bar, and think the start of a generic call when it actually isn't.
                let index_reset = .index

                if .current() is LessThan {
                    // Generic type
                    .index++
                    mut inner_types: [ParsedType] = []

                    while not .eof() {
                        match .current() {
                            GreaterThan => {
                                .index++
                                break
                            }
                            Comma | Eol => {
                                .index++
                            }
                            else => {
                                let index_before = .index
                                let inner_type = .parse_typename()
                                if index_before == .index {
                                    // Can't parse further, this is not a generic call.
                                    .index = index_reset;
                                    break
                                }
                                inner_types.push(inner_type)
                            }
                        }
                    }

                    call.type_args = inner_types
                }

                if .current() is LParen {
                    .index++
                } else {
                    .error("Expected '('", .current().span())
                }

                while  not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            break
                        }
                        Eol | Comma => {
                            .index++
                        }
                        else => {
                            let param_name = .parse_argument_label()

                            let expr = .parse_expression(allow_assignments: false)
                            call.args.push((param_name, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mut this) throws -> [[String:Span]] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [[String:Span]] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push([name : span])
                    .index++
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                else => {
                    .error("expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mut this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        if not .peek(1) is Colon {
            return ""
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        mut whitelist: [ParsedType] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false);
                    } else {
                        .error("Can't fill array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if expr is Garbage {
                        break
                    }

                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: Span)
}
