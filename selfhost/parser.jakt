// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Charles Mirabile <charlie.mirabile@gmail.com>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause


import error { JaktError, print_error}
import lexer { Token, LiteralPrefix, LiteralSuffix }
import utility { panic, todo, FileId, Span, join }
import compiler { Compiler }

enum NumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)
    UnknownSigned(i64)
    UnknownUnsigned(u64)

    public fn to_usize(this) -> usize => match this {
        I8(num) => num as! usize
        I16(num) => num as! usize
        I32(num) => num as! usize
        I64(num) => num as! usize
        U8(num) => num as! usize
        U16(num) => num as! usize
        U32(num) => num as! usize
        U64(num) => num as! usize
        USize(num) => num as! usize
        UnknownSigned(num) => num as! usize
        UnknownUnsigned(num) => num as! usize
        // FIXME: handle floats properly - if the function is used at all?
        else =>  0 as! usize
    }
}

// A simple function to convert integers to floats. T is intended
// to be either f32 or f64.
// FIXME: Remove when a more general conversion is in place
fn u64_to_float<T>(anon number: u64) -> T {
    mut float_value: T = 0

    unsafe {
        cpp {
            "float_value = number;"
        }
    }

    return float_value
}

// FIXME: Remove when a more general conversion is in place
fn f64_to_f32(anon number: f64) -> f32 {
    mut f32_value: f32 = 0

    unsafe {
        cpp {
            "f32_value = (f32)number;"
        }
    }

    return f32_value
}

fn merge_spans(anon start: Span, anon end: Span) throws -> Span {
    if end.file_id.id == 0 and end.start == 0 and end.end == 0 {
        return start
    }

    if start.file_id.id != end.file_id.id {
        panic(
            format("cannot merge spans from two different files ({} and {})", start, end)
        )
    }

    return Span(file_id: start.file_id, start: start.start, end: end.end)
}

enum DefinitionLinkage {
    Internal
    External
}

enum ImportName {
    Literal(name: String, span: Span)
    Comptime(expression: ParsedExpression)

    fn equals(this, anon other: ImportName) -> bool => match this {
        Literal(name) => match other {
            Literal(name: other_name) => name == other_name
            else => false
        }
        Comptime(expression) => match other {
            Comptime(expression: other_expression) => expression.equals(other_expression)
            else => false
        }
    }

    fn literal_name(this) throws -> String {
        guard this is Literal(name) else {
            panic("Cannot get literal name of non-literal import name")
        }

        return name
    }

    fn span(this) -> Span => match this {
        Literal(span) => span
        Comptime(expression) => {
            return expression.span()
        }
    }
}

enum ImportList {
    List([ImportName])
    All

    fn is_empty(this) -> bool => match this {
        List(names) => names.is_empty()
        All => false
    }

    fn add(mut this, anon name: ImportName) throws {
        match this {
            List(names) => {
                mut mutable_names = names
                mutable_names.push(name)
            }
            All => {}
        }
    }
}

struct ParsedModuleImport {
    module_name: ImportName
    alias_name: ImportName?
    import_list: ImportList

    fn is_equivalent_to(this, anon other: ParsedModuleImport) -> bool =>
        .module_name.equals(other.module_name) and .has_same_alias_than(other) and .has_same_import_semantics(other)

    // we do this because imports with an empty import list mean a namespaced
    // import
    fn has_same_import_semantics(this, anon other: ParsedModuleImport) -> bool =>
        .import_list.is_empty() == other.import_list.is_empty()


    fn has_same_alias_than(this, anon other: ParsedModuleImport) -> bool  {
        if .alias_name.has_value() {
            return other.alias_name.has_value() and other.alias_name!.equals(.alias_name!)
        } else {
            return not other.alias_name.has_value()
        }
    }

    fn merge_import_list(mut this, anon list: ImportList) throws {
        // generate a set of the names that exist
        mut name_set: {String} = {}
        mut everything = false
        match .import_list {
            List(names) => {
                for name in names {
                    name_set.add(name.literal_name())
                }
            }
            All => {
                everything = true
            }
        }

        if not everything {
            match list {
                List(names) => {
                    for name in names {
                        if not name_set.contains(name.literal_name()) {
                            .import_list.add(name)
                        }
                    }
                }
                All => {
                    everything = true
                }
            }
        }

        if everything {
            .import_list = ImportList::All
        }
    }
}

enum IncludeAction {
    Define(name: String, span: Span, value: String)
    Undefine(name: String, span: Span)
}

struct ParsedExternImport {
    is_c: bool
    assigned_namespace: ParsedNamespace
    before_include: [IncludeAction]
    after_include: [IncludeAction]

    fn get_path(this) -> String => .assigned_namespace.import_path_if_extern!

    fn get_name(this) -> String => .assigned_namespace.name!

    fn is_equivalent_to(this, anon other: ParsedExternImport) throws -> bool {
        return .is_c and other.is_c and .get_path() == other.get_path() and .get_name() == other.get_name()
    }
}

struct ParsedAlias {
    alias_name: ParsedName?
    target: [ParsedNameWithGenericParameters]
}

struct ParsedNamespace {
    name: String?
    name_span: Span?
    functions: [ParsedFunction]
    records: [ParsedRecord]
    traits: [ParsedTrait]
    external_trait_implementations: [ParsedExternalTraitImplementation]
    namespaces: [ParsedNamespace]
    aliases: [ParsedAlias]
    module_imports: [ParsedModuleImport]
    extern_imports: [ParsedExternImport]
    import_path_if_extern: String?
    generating_import_extern_before_include: [IncludeAction]
    generating_import_extern_after_include: [IncludeAction]
    forall_chunks: [([ParsedGenericParameter], ParsedNamespace)]

    fn is_equivalent_to(this, anon other: ParsedNamespace) -> bool =>
        .name == other.name and .import_path_if_extern == other.import_path_if_extern

    fn add_module_import(mut this, anon import_: ParsedModuleImport) throws {
        for module_import in .module_imports {
            if module_import.is_equivalent_to(import_) {
                module_import.merge_import_list(import_.import_list)
                return
            }
        }
        .module_imports.push(import_)
    }

    fn add_extern_import(mut this, anon import_: ParsedExternImport) throws {
        for extern_import in .extern_imports {
            if extern_import.is_equivalent_to(import_) {
                extern_import.assigned_namespace.merge_with(import_.assigned_namespace)
                extern_import.before_include.push_values(&import_.before_include)
                extern_import.after_include.push_values(&import_.after_include)
                return
            }
        }
        .extern_imports.push(import_)
    }

    fn add_child_namespace(mut this, anon namespace_: ParsedNamespace) throws {
        for child_namespace in .namespaces {
            if child_namespace.is_equivalent_to(namespace_) {
                child_namespace.merge_with(namespace_)
                return
            }
        }
        .namespaces.push(namespace_)
    }

    fn add_alias(mut this, anon alias: ParsedAlias) throws {
        .aliases.push(alias)
    }

    fn merge_with(mut this, anon namespace_: ParsedNamespace) throws {
        .functions.push_values(&namespace_.functions)
        .records.push_values(&namespace_.records)

        .module_imports.add_capacity(namespace_.module_imports.size())
        for import_ in namespace_.module_imports {
            .add_module_import(import_)
        }

        .extern_imports.add_capacity(namespace_.extern_imports.size())
        for import_ in namespace_.extern_imports {
            .add_extern_import(import_)
        }

        for child_namespace in namespace_.namespaces {
            .add_child_namespace(child_namespace)
        }

        for alias in namespace_.aliases {
            .add_alias(alias)
        }
    }
}

struct ValueEnumVariant {
    name: String
    span: Span
    value: ParsedExpression?
}
struct SumEnumVariant {
    name: String
    span: Span
    params: [ParsedVarDecl]?
    default_values: [ParsedExpression?]?
}
enum RecordType {
    Struct(fields: [ParsedField], super_type: ParsedType?)
    Class(fields: [ParsedField], super_type: ParsedType?)
    ValueEnum(underlying_type: ParsedType, variants: [ValueEnumVariant])
    SumEnum(is_boxed: bool, fields: [ParsedField], variants: [SumEnumVariant])
    Garbage

    public fn record_type_name(this) throws -> String => match this {
        Struct => "struct"
        Class => "class"
        ValueEnum => "value enum"
        SumEnum => "sum enum"
        Garbage => "<garbage record type>"
    }
}
struct ParsedRecord {
    name: String
    name_span: Span
    generic_parameters: [ParsedGenericParameter]
    definition_linkage: DefinitionLinkage
    // if not empty, must have at least one value.
    implements_list: [ParsedNameWithGenericParameters]?
    methods: [ParsedMethod]
    record_type: RecordType

    external_name: String? = None
}

enum FunctionType {
    Normal
    Destructor
    ImplicitConstructor
    ImplicitEnumConstructor
    ExternalClassConstructor
    Expression
    Closure
}

enum ArgumentStoreLevel {
    InObject(argument_index: usize)
    InStaticStorage
}

struct ParsedFunction {
    id: usize
    name: String
    name_span: Span
    visibility: Visibility
    params: [ParsedParameter]
    generic_parameters: [ParsedGenericParameter]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: Span
    can_throw: bool
    type: FunctionType
    linkage: FunctionLinkage
    must_instantiate: bool
    is_comptime: bool
    is_fat_arrow: bool
    is_unsafe: bool

    external_name: String? = None
    deprecated_message: String? = None // if not None, the function is deprecated
    stores_arguments: [(usize, ArgumentStoreLevel)]? = None // if not None, the function stores the given arguments, extending their lifetime requirements.
    force_inline: bool? = None // true -> force inline, false -> force not inline, None -> don't care

    fn equals(this, anon other: ParsedFunction, ignore_block: bool = false) -> bool {
        if this.name != other.name or
        this.can_throw != other.can_throw or
        this.is_comptime != other.is_comptime or
        this.is_fat_arrow != other.is_fat_arrow {
            return false
        }

        if not ignore_block and not this.block.equals(other.block) {
            return false
        }

        if this.params.size() != other.params.size() {
            return false
        }

        for param_index in 0..this.params.size() {
            if not this.params[param_index].equals(other.params[param_index])  {
                return false
            }
        }

        if this.generic_parameters.size() != other.generic_parameters.size() {
            return false
        }

        return true
    }
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    default_argument: ParsedExpression?
    span: Span

    fn equals(this, anon rhs_param: ParsedParameter) -> bool {
        guard .requires_label == rhs_param.requires_label and .variable.equals(rhs_param.variable) else {
            return false
        }

        if .default_argument.has_value() and rhs_param.default_argument.has_value() {
            return .default_argument!.equals(rhs_param.default_argument!)
        }

        return not .default_argument.has_value() and not rhs_param.default_argument.has_value()
    }
}

struct ParsedName {
    name: String
    span: Span
}

struct ParsedNameWithGenericParameters {
    name: String
    name_span: Span
    generic_parameters: [ParsedType]
}

struct ParsedGenericParameter {
    name: String
    span: Span
    // the list, if it exists, must have at least one element.
    requires_list: [ParsedNameWithGenericParameters]?
}

enum ParsedTraitRequirements {
    Nothing
    Methods([ParsedFunction])
    ComptimeExpression(ParsedExpression)
}

struct ParsedTrait {
    name: String
    name_span: Span
    generic_parameters: [ParsedGenericParameter]

    requirements: ParsedTraitRequirements
}

struct ParsedExternalTraitImplementation {
    for_type: ParsedType
    traits: [ParsedNameWithGenericParameters]
    methods: [ParsedMethod]
}

struct ParsedBlock {
    stmts: [ParsedStatement]

    fn equals(this, anon rhs_block: ParsedBlock) -> bool {
        if .stmts.size() != rhs_block.stmts.size() {
            return false
        }

        for x in 0..(.stmts.size()) {
            if not .stmts[x].equals(rhs_block.stmts[x]) {
                return false
            }
        }
        return true
    }

    fn find_yield_span(this) -> Span? {
        for stmt in .stmts {
            if stmt is Yield(expr) {
                return expr.span()
            }
        }
        return None
    }

    fn find_yield_keyword_span(this) -> Span? {
        for stmt in .stmts {
            if stmt is Yield(expr) {
                return stmt.span()
            }
        }
        return None
    }

    fn span(this, parser: Parser) throws -> Span? {
        mut start: usize? = None
        mut end: usize = 0

        for stmt in .stmts {
            let stmt_span = stmt.span()
            if not start.has_value() {
                start = stmt_span.start
            }
            end = stmt_span.end
        }

        if start.has_value() {
            return parser.span(start: start!, end)
        }

        return None
    }
}

boxed enum ParsedStatement {
    Expression(expr: ParsedExpression, span: Span)
    Defer(statement: ParsedStatement, span: Span)
    UnsafeBlock(block: ParsedBlock, span: Span)
    DestructuringAssignment(vars: [ParsedVarDecl], var_decl: ParsedStatement, span: Span)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression, span: Span)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, span: Span)
    Block(block: ParsedBlock, span: Span)
    Loop(block: ParsedBlock, span: Span)
    While(condition: ParsedExpression, block: ParsedBlock, span: Span)
    For(iterator_name: String, name_span: Span, is_destructuring: bool, range: ParsedExpression, block: ParsedBlock, span: Span)
    Break(Span)
    Continue(Span)
    Return(expr: ParsedExpression?, span: Span)
    Throw(expr: ParsedExpression, span: Span)
    Yield(expr: ParsedExpression, span: Span)
    InlineCpp(block: ParsedBlock, span: Span)
    Guard(expr: ParsedExpression, else_block: ParsedBlock, remaining_code: ParsedBlock, span: Span)
    Garbage(Span)

    fn equals(this, anon rhs_statement: ParsedStatement) -> bool => match this {
        Expression(expr: lhs_expr) => match rhs_statement {
            Expression(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Defer(statement: lhs_statement) => match rhs_statement {
            Defer(statement: rhs_statement) => lhs_statement.equals(rhs_statement)
            else => false
        }
        UnsafeBlock(block: lhs_block) => match rhs_statement {
            UnsafeBlock(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        VarDecl(var: lhs_var, init: lhs_init) => match rhs_statement {
            VarDecl(var: rhs_var, init: rhs_init) => lhs_var.equals(rhs_var) and lhs_init.equals(rhs_init)
            else => false
        }
        DestructuringAssignment(vars: lhs_vars, var_decl: lhs_var_decl) => match rhs_statement {
            DestructuringAssignment(vars: rhs_vars, var_decl: rhs_var_decl) => {
                if lhs_vars.size() != rhs_vars.size() {
                    return false
                }
                for i in 0..lhs_vars.size() {
                    if not lhs_vars[i].equals(rhs_vars[i]) {
                        return false
                    }
                }

                if not lhs_var_decl.equals(rhs_var_decl) {
                    return false
                }

                return true
            }
            else => false
        }
        If(condition: lhs_condition, then_block: lhs_then_block, else_statement: lhs_else_statement) => match rhs_statement {
            If(condition: rhs_condition, then_block: rhs_then_block, else_statement: rhs_else_statement) => {
                if not (lhs_condition.equals(rhs_condition) and lhs_then_block.equals(rhs_then_block)) {
                    return false
                }
                if not lhs_else_statement.has_value() {
                    return not rhs_else_statement.has_value()
                } else {
                    if not rhs_else_statement.has_value() {
                        return false
                    }
                    if lhs_else_statement!.equals(rhs_else_statement!) {
                        return true
                    }
                    return false
                }
            }
            else => false
        }
        Block(block: lhs_block) => match rhs_statement {
            Block(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        Loop(block: lhs_block) => match rhs_statement {
            Loop(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        While(condition: lhs_condition, block: lhs_block) => match rhs_statement {
            While(condition: rhs_condition, block: rhs_block) => lhs_condition.equals(rhs_condition) and lhs_block.equals(rhs_block)
            else => false
        }
        For(iterator_name: lhs_iterator_name, range: lhs_range, block: lhs_block) => match rhs_statement {
            For(iterator_name: rhs_iterator_name, range: rhs_range, block: rhs_block) => {
                yield lhs_iterator_name == rhs_iterator_name and lhs_range.equals(rhs_range) and lhs_block.equals(rhs_block)
            }
            else => false
        }
        Break => rhs_statement is Break
        Continue => rhs_statement is Continue
        Return(expr: lhs_expr) => match rhs_statement {
            Return(expr: rhs_expr) => {
                if not lhs_expr.has_value() {
                    return not rhs_expr.has_value()
                } else {
                    if not rhs_expr.has_value() {
                        return false
                    }
                    if lhs_expr!.equals(rhs_expr!) {
                        return true
                    }
                    return false
                }
            }
            else => false
        }
        Throw(expr: lhs_expr) => match rhs_statement {
            Throw(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Yield(expr: lhs_expr) =>  match rhs_statement {
            Yield(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        InlineCpp(block: lhs_block) =>  match rhs_statement {
            InlineCpp(block) => lhs_block.equals(block)
            else => false
        }
        Guard(expr: lhs_expr, else_block: lhs_else_block) => match rhs_statement {
            Guard(expr: rhs_expr, else_block: rhs_else_block) => lhs_expr.equals(rhs_expr) and lhs_else_block.equals(rhs_else_block)
            else => false
        }
        Garbage => rhs_statement is Garbage
    }

    fn span(this) -> Span => match this {
        else(span) => span
    }
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    fn equals(this, anon rhs_op: BinaryOperator) -> bool => match this {
        Add => rhs_op is Add
        Subtract => rhs_op is Subtract
        Multiply => rhs_op is Multiply
        Divide => rhs_op is Divide
        Modulo => rhs_op is Modulo
        LessThan => rhs_op is LessThan
        LessThanOrEqual => rhs_op is LessThanOrEqual
        GreaterThan => rhs_op is GreaterThan
        GreaterThanOrEqual => rhs_op is GreaterThanOrEqual
        Equal => rhs_op is Equal
        NotEqual => rhs_op is NotEqual
        BitwiseAnd => rhs_op is BitwiseAnd
        BitwiseXor => rhs_op is BitwiseXor
        BitwiseOr => rhs_op is BitwiseOr
        BitwiseLeftShift => rhs_op is BitwiseLeftShift
        BitwiseRightShift => rhs_op is BitwiseRightShift
        ArithmeticLeftShift => rhs_op is ArithmeticLeftShift
        ArithmeticRightShift => rhs_op is ArithmeticRightShift
        LogicalOr => rhs_op is LogicalOr
        LogicalAnd => rhs_op is LogicalAnd
        NoneCoalescing => rhs_op is NoneCoalescing
        Assign => rhs_op is Assign
        BitwiseAndAssign => rhs_op is BitwiseAndAssign
        BitwiseOrAssign => rhs_op is BitwiseOrAssign
        BitwiseXorAssign => rhs_op is BitwiseXorAssign
        BitwiseLeftShiftAssign => rhs_op is BitwiseLeftShiftAssign
        BitwiseRightShiftAssign => rhs_op is BitwiseRightShiftAssign
        AddAssign => rhs_op is AddAssign
        SubtractAssign => rhs_op is SubtractAssign
        MultiplyAssign => rhs_op is MultiplyAssign
        ModuloAssign => rhs_op is ModuloAssign
        DivideAssign => rhs_op is DivideAssign
        NoneCoalescingAssign => rhs_op is NoneCoalescingAssign
        Garbage => rhs_op is Garbage
    }

    fn is_assignment(this) -> bool => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum TypeCast {
    Fallible(ParsedType)
    Infallible(ParsedType)

    fn parsed_type(this) -> ParsedType => match this {
        Fallible(parsed_type) => parsed_type
        Infallible(parsed_type) => parsed_type
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    Reference
    MutableReference
    LogicalNot
    BitwiseNot
    TypeCast(TypeCast)
    Is(ParsedType)
    IsEnumVariant(inner: ParsedType, bindings: [EnumVariantPatternArgument])
    Sizeof(ParsedType)

    fn equals(this, anon rhs_op: UnaryOperator) -> bool => match this {
        PreIncrement => rhs_op is PreIncrement
        PostIncrement =>  rhs_op is PostIncrement
        PreDecrement => rhs_op is PreDecrement
        PostDecrement => rhs_op is PostDecrement
        Negate => rhs_op is Negate
        Dereference => rhs_op is Dereference
        RawAddress => rhs_op is RawAddress
        Reference => rhs_op is Reference
        MutableReference => rhs_op is MutableReference
        LogicalNot => rhs_op is LogicalNot
        BitwiseNot => rhs_op is BitwiseNot
        TypeCast(lhs_type_cast) => match rhs_op {
            TypeCast(rhs_type_cast) => lhs_type_cast.parsed_type().equals(rhs_type_cast.parsed_type())
            else => false
        }
        Is(lhs_type) => match rhs_op {
            Is(rhs_type) => lhs_type.equals(rhs_type)
            else => false
        }
        Sizeof(lhs_type) => match rhs_op {
            Sizeof(rhs_type) => lhs_type.equals(rhs_type)
            else => false
        }
        IsEnumVariant(inner: lhs_inner_type, bindings: lhs_bindings) => match rhs_op {
            IsEnumVariant(inner: rhs_inner_type, bindings: rhs_bindings) => {
                mut equal = false
                if lhs_inner_type.equals(rhs_inner_type) and lhs_bindings.size() == rhs_bindings.size() {
                    mut bindings_equal = true
                    for i in ..lhs_bindings.size() {
                        if not lhs_bindings[i].equals(rhs_bindings[i]) {
                            bindings_equal = false
                            break
                        }
                    }

                    if bindings_equal {
                        equal = true
                    }
                }

                yield equal
            }
            else => false
        }
    }
}

struct EnumVariantPatternArgument {
    name: String?
    name_span: Span?
    binding: String
    span: Span
    is_reference: bool
    is_mutable: bool

    fn name_in_enum(this) -> String => .name ?? .binding
    fn name_in_enum_span(this) -> Span => .name_span ?? .span

    fn equals(this, anon rhs_variant_pattern_argument: EnumVariantPatternArgument) -> bool {
        if .binding != rhs_variant_pattern_argument.binding {
            return false
        }

        if .name.has_value() and rhs_variant_pattern_argument.name.has_value() {
            return .name! == rhs_variant_pattern_argument.name!
        }

        if .is_reference != rhs_variant_pattern_argument.is_reference {
            return false
        }

        if .is_mutable != rhs_variant_pattern_argument.is_mutable {
            return false
        }

        return not .name.has_value() and not rhs_variant_pattern_argument.name.has_value()
    }
}

struct ParsedPatternDefault {
    variable: ParsedVarDecl
    value: ParsedExpression
}

enum ParsedMatchPattern {
    defaults: [String:ParsedPatternDefault]

    EnumVariant(
        variant_names: [(String, Span)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Expression(ParsedExpression)
    CatchAll(
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Invalid

    fn defaults_equal(this, anon defaults: [String:ParsedPatternDefault]) -> bool {
        if defaults.size() != .defaults.size() {
            return false
        }

        for (name, default_) in .defaults {
            let matching = defaults.get(name)
            if not matching.has_value() {
                return false
            }
            if not matching!.value.equals(default_.value) {
                return false
            }
            if matching!.variable.is_mutable != default_.variable.is_mutable {
                return false
            }
        }

        return true
    }

    fn is_equal_pattern(this, anon rhs_parsed_match_pattern: ParsedMatchPattern) -> bool => match this {
        EnumVariant(variant_names: lhs_variant_names) => {
            guard rhs_parsed_match_pattern is EnumVariant(variant_names: rhs_variant_names) else {
                return false
            }

            // compare name & namespaces in reverse order
            // -> when one is a subset of the other they are treated equal
            mut namespace_count = lhs_variant_names.size();
            if rhs_variant_names.size() < namespace_count {
                namespace_count = rhs_variant_names.size()
            }

            for i in 0..namespace_count {
                let lhs_name = lhs_variant_names[lhs_variant_names.size() - i - 1].0
                let rhs_name = rhs_variant_names[rhs_variant_names.size() - i - 1].0
                guard lhs_name == rhs_name else {
                    return false
                }
            }

            return true
        }
        Expression(lhs_parsed_expression) => match rhs_parsed_match_pattern {
            Expression(rhs_parsed_expression) => lhs_parsed_expression.equals(rhs_parsed_expression)
            else => false
        }
        CatchAll => rhs_parsed_match_pattern is CatchAll
        Invalid => rhs_parsed_match_pattern is Invalid
    }

    fn equals(this, anon rhs_parsed_match_pattern: ParsedMatchPattern) -> bool {
        guard .is_equal_pattern(rhs_parsed_match_pattern) else {
            return false
        }

        guard .defaults_equal(rhs_parsed_match_pattern.defaults) else {
            return false
        }

        if this is EnumVariant(variant_arguments: lhs_variant_arguments) {
            guard rhs_parsed_match_pattern is EnumVariant(variant_arguments: rhs_variant_arguments) else {
                return false
            }

            guard lhs_variant_arguments.size() == rhs_variant_arguments.size() else {
                return false
            }

            for i in ..lhs_variant_arguments.size() {
                if not lhs_variant_arguments[i].equals(rhs_variant_arguments[i]) {
                    return false
                }
            }
        }

        return true
    }
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: Span
    body: ParsedMatchBody

    fn has_equal_pattern(this, anon rhs_match_case: ParsedMatchCase) -> bool {
        guard .patterns.size() == rhs_match_case.patterns.size() else {
            return false
        }

        for i in ..(.patterns.size()) {
            if not .patterns[i].is_equal_pattern(rhs_match_case.patterns[i]) {
                return false
            }
        }

        return true
    }

    fn equals(this, anon rhs_match_case: ParsedMatchCase) -> bool {
        guard .patterns.size() == rhs_match_case.patterns.size() else {
            return false
        }

        for i in ..(.patterns.size()) {
            if not .patterns[i].equals(rhs_match_case.patterns[i]) {
                return false
            }
        }

        return .body.equals(rhs_match_case.body)
    }
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)

    fn equals(this, anon rhs_match_body: ParsedMatchBody) -> bool => match this {
        Expression(lhs_expr) => {
            guard rhs_match_body is Expression(rhs_expr) else {
                return false
            }

            yield lhs_expr.equals(rhs_expr)
        }
        Block(lhs_block) => {
            guard rhs_match_body is Block(rhs_block) else {
                return false
            }

            yield lhs_block.equals(rhs_block)
        }
    }
}

enum ParsedCapture {
    name: String
    span: Span

    ByValue
    ByReference
    ByMutableReference
    ByComptimeDependency
    AllByReference
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: NumericConstant, span: Span)
    QuotedString(val: String, span: Span)
    SingleQuotedString(val: String, prefix: String?, span: Span)
    Call(call: ParsedCall, span: Span)
    MethodCall(expr: ParsedExpression, call: ParsedCall, is_optional: bool, span: Span)
    IndexedTuple(expr: ParsedExpression, index: usize, is_optional: bool, span: Span)
    IndexedStruct(expr: ParsedExpression, field_name: String, is_optional: bool, span: Span)
    ComptimeIndex(expr: ParsedExpression, index: ParsedExpression, is_optional: bool, span: Span)
    Var(name: String, span: Span)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: Span)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: Span)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: Span)
    Operator(op: BinaryOperator, span: Span)
    OptionalSome(expr: ParsedExpression, span: Span)
    OptionalNone(Span)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: Span)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: Span)
    Set(values: [ParsedExpression], span: Span)
    JaktTuple(values: [ParsedExpression], span: Span)
    Range(from: ParsedExpression?, to: ParsedExpression?, span: Span)
    ForcedUnwrap(expr: ParsedExpression, span: Span)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: Span, marker_span: Span)
    EnumVariantArg(expr: ParsedExpression, arg: EnumVariantPatternArgument, enum_variant: ParsedType, span: Span)
    NamespacedVar(name: String, namespace_: [String], span: Span)
    Function(captures: [ParsedCapture], params: [ParsedParameter], can_throw: bool, is_fat_arrow: bool, return_type: ParsedType, block: ParsedBlock, span: Span)
    Try(expr: ParsedExpression, catch_block: ParsedBlock?, catch_name: String?, span: Span)
    TryBlock(stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, span: Span)
    Reflect(type: ParsedType, span: Span)
    Garbage(Span)
    Unsafe(expr: ParsedExpression, span: Span)

    fn span(this) -> Span => match this {
        else(span) => span
    }

    fn precedence(this) -> i64 => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }

    fn equals(this, anon rhs_expression: ParsedExpression) -> bool => match this {
        Boolean(val: lhs_val) => match rhs_expression {
            Boolean(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        NumericConstant(val: lhs_val) => match rhs_expression {
            NumericConstant(val: rhs_val) => lhs_val.to_usize() == rhs_val.to_usize()
            else => false
        }
        QuotedString(val: lhs_val) => match rhs_expression {
            QuotedString(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        SingleQuotedString(val: lhs_val, prefix: lhs_prefix) => match rhs_expression {
            SingleQuotedString(val: rhs_val, prefix: rhs_prefix) => (lhs_val == rhs_val) and (lhs_prefix == rhs_prefix)
            else => false
        }
        Call(call: lhs_call) => match rhs_expression {
            Call(call: rhs_call) => lhs_call.equals(rhs_call)
            else => false
        }
        MethodCall(expr: lhs_expr, call: lhs_call, is_optional: lhs_optional) => match rhs_expression {
            MethodCall(expr: rhs_expr, call: rhs_call, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_call.equals(rhs_call)
            else => false
        }
        IndexedTuple(expr: lhs_expr, index: lhs_index, is_optional: lhs_optional) => match rhs_expression {
            IndexedTuple(expr: rhs_expr, index: rhs_index, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_index == rhs_index
            else => false
        }
        IndexedStruct(expr: lhs_expr, field_name: lhs_field, is_optional: lhs_optional) => match rhs_expression {
            IndexedStruct(expr: rhs_expr, field_name: rhs_field, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_field == rhs_field
            else => false
        }
        ComptimeIndex(expr: lhs_expr, index: lhs_index, is_optional: lhs_optional) => match rhs_expression {
            ComptimeIndex(expr: rhs_expr, index: rhs_index, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_index.equals(rhs_index)
            else => false
        }
        Var(name: lhs_name) => match rhs_expression {
            Var(name: rhs_name) => lhs_name == rhs_name
            else => false
        }
        IndexedExpression(base: lhs_base, index: lhs_index) => match rhs_expression {
            IndexedExpression(base: rhs_base, index: rhs_index) => lhs_base.equals(, rhs_base) and lhs_index.equals(rhs_index)
            else => false
        }
        UnaryOp(expr: lhs_expr, op: lhs_op) => match rhs_expression {
            UnaryOp(expr: rhs_expr, op: rhs_op) => lhs_expr.equals(rhs_expr) and lhs_op.equals(rhs_op)
            else => false
        }
        BinaryOp(lhs: lhs_lhs, op: lhs_op, rhs: lhs_rhs) => match rhs_expression {
            BinaryOp(lhs: rhs_lhs, op: rhs_op, rhs: rhs_rhs) => lhs_lhs.equals(rhs_lhs) and lhs_op.equals(rhs_op) and lhs_rhs.equals(rhs_rhs)
            else => false
        }
        Operator(op: lhs_op) => match rhs_expression {
            Operator(op: rhs_op) => lhs_op.equals(rhs_op)
            else => false
        }
        OptionalSome(expr: lhs_expr) => match rhs_expression {
            OptionalSome(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        OptionalNone => rhs_expression is OptionalNone
        JaktArray(values: lhs_values, fill_size: lhs_fill_size) => match rhs_expression {
            JaktArray(values: rhs_values, fill_size: rhs_fill_size) => {
                if not lhs_fill_size.has_value() {
                    if rhs_fill_size.has_value() {
                        return false
                    }
                } else {
                    if not rhs_fill_size.has_value() {
                        return false
                    }
                    if not lhs_fill_size!.equals(rhs_fill_size!) {
                        return false
                    }
                }

                guard lhs_values.size() == rhs_values.size() else {
                    return false
                }

                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        JaktDictionary(values: lhs_values) => match rhs_expression {
            JaktDictionary(values: rhs_values) => {
                guard lhs_values.size() == rhs_values.size() else {
                    return false
                }

                for i in 0..lhs_values.size() {
                    if not (lhs_values[i].0.equals(rhs_values[i].0) and lhs_values[i].1.equals(rhs_values[i].1)) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        Set(values: lhs_values) => match rhs_expression {
            Set(values: rhs_values) => {
                guard lhs_values.size() == rhs_values.size() else {
                    return false
                }

                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        JaktTuple(values: lhs_values) => match rhs_expression {
            JaktTuple(values: rhs_values) => {
                guard lhs_values.size() == rhs_values.size() else {
                    return false
                }

                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        Range(from: lhs_from, to: lhs_to) => match rhs_expression {
            Range(from: rhs_from, to: rhs_to) => {
                mut equal = false
                if lhs_from.has_value() == rhs_from.has_value() and lhs_to.has_value() == rhs_to.has_value() {
                    if lhs_from.has_value() and lhs_to.has_value() {
                        equal = lhs_from!.equals(rhs_from!) and lhs_to!.equals(rhs_to!)
                    } else {
                        equal = true;
                    }
                }

                yield equal
            }
            else => false
        }
        ForcedUnwrap(expr: lhs_expr) => match rhs_expression {
            ForcedUnwrap(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Match(expr: lhs_expr, cases: lhs_cases) => match rhs_expression {
            Match(expr: rhs_expr, cases: rhs_cases) => {
                guard lhs_expr.equals(rhs_expr) and lhs_cases.size() == rhs_cases.size() else {
                    return false
                }

                for i in ..lhs_cases.size() {
                    mut current_case_has_match = false

                    for k in ..rhs_cases.size() {
                        if lhs_cases[i].equals(rhs_cases[k]) {
                            current_case_has_match = true
                            break
                        }
                    }

                    guard current_case_has_match else {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        EnumVariantArg(expr: lhs_expr) => match rhs_expression {
            EnumVariantArg(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        NamespacedVar(name: lhs_name, namespace_: lhs_namespace) => match rhs_expression {
            NamespacedVar(name: rhs_name, namespace_: rhs_namespace) => {
                if lhs_namespace.size() != rhs_namespace.size() {
                    return false
                }
                for i in 0..lhs_namespace.size() {
                    if lhs_namespace[i] != rhs_namespace[i] {
                        return false
                    }
                }
                yield lhs_name == rhs_name
            }
            else => false
        }
        Try(expr: lhs_expr, catch_block: lhs_catch_block) => match rhs_expression {
            Try(expr: rhs_expr, catch_block: rhs_catch_block) => {
                mut equals = lhs_expr.equals(rhs_expr)
                if equals {
                    if lhs_catch_block.has_value() {
                        if rhs_catch_block.has_value() {
                            equals = lhs_catch_block!.equals(rhs_catch_block!)
                        } else {
                            equals = false
                        }
                    } else {
                        equals = not rhs_catch_block.has_value()
                    }
                }
                yield equals
            }
            else => false
        }
        TryBlock(stmt: lhs_stmt, error_name: lhs_error_name, catch_block: lhs_catch_block) => match rhs_expression {
            TryBlock(stmt: rhs_stmt, error_name: rhs_error_name, catch_block: rhs_catch_block) => lhs_stmt.equals(rhs_stmt) and (lhs_error_name == rhs_error_name) and lhs_catch_block.equals(rhs_catch_block)
            else => false
        }
        Function(captures: lhs_captures, params: lhs_params, can_throw: lhs_can_throw, return_type: lhs_return_type) => match rhs_expression {
            Function(captures: rhs_captures, params: rhs_params, can_throw: rhs_can_throw, return_type: rhs_return_type) => {
                guard lhs_return_type.equals(rhs_return_type) and
                    lhs_can_throw == rhs_can_throw and
                    lhs_captures.size() == rhs_captures.size() and
                    lhs_params.size() == rhs_params.size() else {
                    return false
                }

                for i in ..lhs_captures.size() {
                    if not (lhs_captures[i].name == rhs_captures[i].name) {
                        return false
                    }
                }

                for i in ..lhs_params.size() {
                    if not lhs_params[i].equals(rhs_params[i]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        Reflect(type) => match rhs_expression {
            Reflect(type: rhs_type) => type.equals(rhs_type)
            else => false
        }
        Garbage => rhs_expression is Garbage
        Unsafe(expr) => match rhs_expression {
            Unsafe(expr: rhs_expr) => expr.equals(rhs_expr)
            else => false
        }
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    inlay_span: Span?
    span: Span
    external_name: String? = None

    fn equals(this, anon rhs_var_decl: ParsedVarDecl) -> bool {
        return .name == rhs_var_decl.name and .is_mutable == rhs_var_decl.is_mutable
    }
}

struct ParsedVarDeclTuple {
    var_decls: [ParsedVarDecl]
    span: Span
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
    default_value: ParsedExpression?
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
    is_virtual: bool
    is_override: bool
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span

    fn equals(this, anon rhs_parsed_varible: ParsedVariable) -> bool {
        return .name == rhs_parsed_varible.name and
        .parsed_type.equals(rhs_parsed_varible.parsed_type) and
        .is_mutable ==  rhs_parsed_varible.is_mutable
    }
}

struct ParsedCall {
    namespace_: [String]
    name: String
    args: [(String, Span, ParsedExpression)]
    type_args: [ParsedType]

    fn equals(this, anon rhs_parsed_call: ParsedCall) -> bool {
        if .name != rhs_parsed_call.name {
            return false
        }
        if .args.size() != rhs_parsed_call.args.size() {
            return false
        }
        for i in 0..(.args.size()) {
            let (lhs_str, _, lhs_expr) = .args[i]
            let (rhs_str, __, rhs_expr) = rhs_parsed_call.args[i]
            if (lhs_str != rhs_str) or (not lhs_expr.equals(rhs_expr)) {
                return false
            }
        }
        return true
    }
}

boxed enum ParsedType {
    Name(name: String, span: Span)
    NamespacedName(name: String, namespaces: [String], params: [ParsedType], span: Span)
    GenericType(name: String, generic_parameters: [ParsedType], span: Span)
    JaktArray(inner: ParsedType, span: Span)
    Dictionary(key: ParsedType, value: ParsedType, span: Span)
    JaktTuple(types: [ParsedType], span: Span)
    Set(inner: ParsedType, span: Span)
    Optional(inner: ParsedType, span: Span)
    Reference(inner: ParsedType, span: Span)
    MutableReference(inner: ParsedType, span: Span)
    RawPtr(inner: ParsedType, span: Span)
    WeakPtr(inner: ParsedType, span: Span)
    Function(params: [ParsedParameter], can_throw: bool, return_type: ParsedType, span: Span)
    Empty

    fn span(this) -> Span => match this {
        Empty => Span(file_id: FileId(id: 0uz), start: 0, end: 0) // FIXME: For some reason we can't see `empty_span()` here.
        else(span) => span
    }

    fn equals(this, anon rhs_parsed_type: ParsedType) -> bool => match this {
        Name(name: lhs_name) => match rhs_parsed_type {
            Name(name: rhs_name) => lhs_name == rhs_name
            else => false
        }
        NamespacedName(name: lhs_name, namespaces: lhs_namespaces, params: lhs_params) => match rhs_parsed_type {
            NamespacedName(name: rhs_name, namespaces: rhs_namespaces, params: rhs_params) => {
                if lhs_name != rhs_name {
                    return false
                }

                if lhs_namespaces.size() != rhs_namespaces.size() {
                    return false
                }
                for namespace_index in 0..lhs_namespaces.size() {
                    if lhs_namespaces[namespace_index] != rhs_namespaces[namespace_index] {
                        return false
                    }
                }

                if lhs_params.size() != rhs_params.size() {
                    return false
                }
                for param_index in 0..lhs_params.size() {
                    if not lhs_params[param_index].equals(rhs_params[param_index]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        GenericType(name: lhs_name, generic_parameters: lhs_generic_parameters) => match rhs_parsed_type {
            GenericType(name: rhs_name, generic_parameters: rhs_generic_parameters) => {
                if lhs_name != rhs_name {
                    return false
                }

                if lhs_generic_parameters.size() != rhs_generic_parameters.size() {
                    return false
                }
                for param_index in 0..lhs_generic_parameters.size() {
                    if not lhs_generic_parameters[param_index].equals(rhs_generic_parameters[param_index]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        JaktArray(inner: lhs_inner) => match rhs_parsed_type {
            JaktArray(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        Dictionary(key: lhs_key, value: lhs_value) => match rhs_parsed_type {
            Dictionary(key: rhs_key, value: rhs_value) => lhs_key.equals(rhs_key) and lhs_value.equals(rhs_value)
            else => false
        }
        JaktTuple(types: lhs_types) => match rhs_parsed_type {
            JaktTuple(types: rhs_types) => {
                if lhs_types.size() != rhs_types.size() {
                    return false
                }
                for type_index in 0..lhs_types.size() {
                    if not lhs_types[type_index].equals(rhs_types[type_index]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        Set(inner: lhs_inner) => match rhs_parsed_type {
            Set(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        Optional(inner: lhs_inner) => match rhs_parsed_type {
            Optional(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        Reference(inner: lhs_inner) => match rhs_parsed_type {
            Reference(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        MutableReference(inner: lhs_inner) => match rhs_parsed_type {
            MutableReference(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        RawPtr(inner: lhs_inner) => match rhs_parsed_type {
            RawPtr(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        WeakPtr(inner: lhs_inner) => match rhs_parsed_type {
            WeakPtr(inner: rhs_inner) => lhs_inner.equals(rhs_inner)
            else => false
        }
        Function(params: lhs_params, can_throw: lhs_can_throw, return_type: lhs_return_type) => match rhs_parsed_type {
            Function(params: rhs_params, can_throw: rhs_can_throw, return_type: rhs_return_type) => {
                if lhs_can_throw != rhs_can_throw {
                    return false
                }

                if not lhs_return_type.equals(rhs_return_type) {
                    return false
                }

                if lhs_params.size() != rhs_params.size() {
                    return false
                }
                for param_index in 0..lhs_params.size() {
                    if not lhs_params[param_index].equals(rhs_params[param_index]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        Empty => rhs_parsed_type is Empty
    }
}

enum FunctionLinkage {
    Internal
    External
}

struct VisibilityRestriction {
    namespace_: [String]
    name: String
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [VisibilityRestriction], span: Span)
}

struct ParsedAttributeArgument {
    name: String
    span: Span
    assigned_value: String?
}

struct ParsedAttribute {
    name: String
    span: Span
    assigned_value: String?
    arguments: [ParsedAttributeArgument]
}

struct Parser {
    index: usize
    tokens: [Token]
    compiler: Compiler
    can_have_trailing_closure: bool = true
    next_function_id: usize = 0

    fn parse(compiler: Compiler, tokens: [Token]) throws -> ParsedNamespace {
        mut parser = Parser(index: 0, tokens, compiler)
        return parser.parse_namespace()
    }

    fn span(this, start: usize, end: usize) -> Span {
        return Span(file_id: .compiler.current_file!, start, end)
    }

    fn empty_span(this) -> Span => .span(start: 0, end: 0)

    fn error(mut this, anon message: String, anon span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::Message(message, span))
        }
    }

    fn error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
        }
    }

    fn eof(this) -> bool => .index >= .tokens.size() - 1

    fn eol(this) -> bool => .eof() or .tokens[.index] is Eol

    fn peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens.last()!
        }
        return .tokens[.index + steps]
    }

    fn previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(.span(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    fn current(this) -> Token {
        return .peek(0)
    }

    fn inject_token(mut this, token: Token) throws {
        .tokens.insert(before_index: .index + 1, value: token)
    }

    public fn parse_forall(mut this) throws -> ([ParsedGenericParameter], ParsedNamespace) {
        // forall<T requires(Trait...), ...> namespace-contents
        let parameters = .parse_generic_parameters()
        let contents = .parse_namespace(process_only_one_entity: true)
        return (parameters, contents)
    }

    public fn parse_namespace(mut this, process_only_one_entity: bool = false) throws -> ParsedNamespace {
        mut parsed_namespace = ParsedNamespace(
            name: None
            name_span: None
            functions: []
            records: []
            traits: []
            external_trait_implementations: []
            namespaces: []
            aliases: []
            module_imports: []
            extern_imports: []
            import_path_if_extern: None
            generating_import_extern_before_include: []
            generating_import_extern_after_include: []
            forall_chunks: []
        )

        mut active_attributes: [ParsedAttribute] = []
        mut saw_an_entity = false

        while not .eof() {
            if process_only_one_entity and saw_an_entity { break }

            match .current() {
                Trait => {
                    if not active_attributes.is_empty() {
                        .error("Cannot apply attributes to trait declarations", active_attributes[0].span)
                        active_attributes = []
                    }
                    .index++
                    parsed_namespace.traits.push(.parse_trait())
                    saw_an_entity = true
                }
                Identifier(name) => match name {
                    "type" => {
                        if not active_attributes.is_empty() {
                            .error("Cannot apply attributes to external trait declarations", active_attributes[0].span)
                            active_attributes = []
                        }
                        .index++
                        parsed_namespace.external_trait_implementations.push(.parse_external_trait_implementation())
                        saw_an_entity = true
                    }
                    "use" => {
                        if not active_attributes.is_empty() {
                            .error("Cannot apply attributes to use declarations", active_attributes[0].span)
                            active_attributes = []
                        }
                        .index++
                        parsed_namespace.aliases.push(.parse_using())
                        saw_an_entity = true
                    }
                    "forall" => {
                        if not active_attributes.is_empty() {
                            .error("Cannot apply attributes to forall declarations", active_attributes[0].span)
                            active_attributes = []
                        }
                        .index++
                        parsed_namespace.forall_chunks.push(.parse_forall())
                        saw_an_entity = true
                    }
                    else => {
                        active_attributes = []
                        .error("Unexpected token (expected keyword)", .current().span())
                        break
                    }
                }
                Import => {
                    if not active_attributes.is_empty() {
                        .error("Cannot apply attributes to imports", active_attributes[0].span)
                        active_attributes = []
                    }
                    .index++
                    .parse_import(parent: &mut parsed_namespace)
                    saw_an_entity = true
                }
                LSquare => {
                    if .peek(1) is LSquare {
                        .index += 2
                        .parse_attribute_list(&mut active_attributes)
                    } else {
                        .error("Unexpected token (expected ‘[[’)", .current().span())
                        .index += 1
                    }
                }
                Unsafe => {
                    .index++
                    if .current() is Fn {
                        mut parsed_function = .parse_function(
                            FunctionLinkage::Internal
                            Visibility::Public
                            is_comptime: .current() is Comptime
                            is_destructor: false
                            is_unsafe: true
                        )
                        .apply_attributes(&mut parsed_function, &active_attributes)
                        active_attributes = []
                        parsed_namespace.functions.push(parsed_function)
                        saw_an_entity = true
                    } else {
                        .error("Expected 'fn' after 'unsafe'", .current().span())
                    }
                }
                Fn | Comptime => {
                    mut parsed_function = .parse_function(
                        FunctionLinkage::Internal
                        Visibility::Public
                        is_comptime: .current() is Comptime
                        is_destructor: false
                        is_unsafe: false
                    )
                    .apply_attributes(&mut parsed_function, &active_attributes)
                    active_attributes = []
                    parsed_namespace.functions.push(parsed_function)
                    saw_an_entity = true
                }
                Struct | Class | Enum | Boxed => {
                    mut parsed_record = .parse_record(DefinitionLinkage::Internal)
                    .apply_attributes(&mut parsed_record, &active_attributes)
                    active_attributes = []
                    parsed_namespace.records.push(parsed_record)
                    saw_an_entity = true
                }
                Namespace => {
                    if not active_attributes.is_empty() {
                        .error("Cannot apply attributes to namespaces", active_attributes[0].span)
                        active_attributes = []
                    }
                    .index++
                    let name: (String, Span)? = match .current() {
                        Identifier(name, span) => {
                            .index++
                            yield Some((name, span))
                        }
                        else => None
                    }
                    .skip_newlines()
                    if .current() is LCurly {
                        .index++
                    } else {
                        .error("Expected ‘{’", .current().span())
                    }
                    mut namespace_ = .parse_namespace()
                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Incomplete namespace", .previous().span())
                    }
                    if name.has_value() {
                        namespace_.name = name!.0
                        namespace_.name_span = name!.1
                    }
                    parsed_namespace.add_child_namespace(namespace_)
                    saw_an_entity = true
                }
                Extern => {
                    .index++
                    match .current() {
                        Unsafe => {
                            .index++
                            if .current() is Fn {
                                mut parsed_function = .parse_function(
                                    FunctionLinkage::External
                                    Visibility::Public
                                    is_comptime: false
                                    is_destructor: false
                                    is_unsafe: true
                                )
                                .apply_attributes(&mut parsed_function, &active_attributes)
                                active_attributes = []
                                parsed_namespace.functions.push(parsed_function)
                                saw_an_entity = true
                            } else {
                                .error("Expected 'fn' after 'unsafe'", .current().span())
                            }
                        }
                        Fn => {
                            mut parsed_function = .parse_function(
                                FunctionLinkage::External
                                Visibility::Public
                                is_comptime: false
                                is_destructor: false
                                is_unsafe: false
                            )
                            .apply_attributes(&mut parsed_function, &active_attributes)
                            active_attributes = []
                            parsed_namespace.functions.push(parsed_function)
                            saw_an_entity = true
                        }
                        Struct => {
                            mut parsed_struct = .parse_struct(DefinitionLinkage::External)
                            .apply_attributes(&mut parsed_struct, &active_attributes)
                            active_attributes = []
                            parsed_namespace.records.push(parsed_struct)
                            saw_an_entity = true
                        }
                        Class => {
                            mut parsed_class = .parse_class(DefinitionLinkage::External)
                            .apply_attributes(&mut parsed_class, &active_attributes)
                            active_attributes = []
                            parsed_namespace.records.push(parsed_class)
                            saw_an_entity = true
                        }
                        else => {
                            active_attributes = []
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unexpected token (expected keyword)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    fn apply_attributes(mut this, anon field: &mut ParsedField, active_attributes: &[ParsedAttribute]) throws {
        for attribute in *active_attributes {
            match attribute.name {
                "name" => {
                    guard attribute.assigned_value.has_value() else {
                        .error(
                            format("The attribute '{}' requires a value", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    if field.var_decl.external_name.has_value() {
                        .error(
                            format("The attribute '{}' cannot be applied more than once", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    field.var_decl.external_name = attribute.assigned_value
                }
                else => {
                    .error(
                        format("The attribute '{}' does not apply to fields", attribute.name)
                        attribute.span
                    )
                }
            }
        }
    }

    fn apply_attributes(mut this, anon parsed_function: &mut ParsedFunction, active_attributes: &[ParsedAttribute]) throws {
        for attribute in *active_attributes {
            match attribute.name {
                "name" => {
                    guard attribute.assigned_value.has_value() else {
                        .error(
                            format("The attribute '{}' requires a value", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    if parsed_function.external_name.has_value() {
                        .error(
                            format("The attribute '{}' cannot be applied more than once", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    parsed_function.external_name = attribute.assigned_value
                }
                "deprecated" => {
                    if parsed_function.deprecated_message.has_value() {
                        .error(
                            format("The attribute '{}' cannot be applied more than once", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    let message = attribute.arguments.first()?.name ?? format("The function '{}' is marked as deprecated", parsed_function.name)
                    parsed_function.deprecated_message = message
                }
                "inline" => {
                    if parsed_function.force_inline.has_value() {
                        .error(
                            format("The attribute '{}' cannot be applied more than once", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    let force_inline = (attribute.arguments.first()?.name ?? "") != "never"
                    parsed_function.force_inline = force_inline
                }
                "stores_arguments" => {
                    // [[stores_arguments(foo: this, bar)]] -> [(foo, InObject("this")), (bar, InStaticStorage)]
                    mut stores_arguments: [(usize, ArgumentStoreLevel)] = []
                    for argument in attribute.arguments {
                        let target = argument.assigned_value

                        mut target_index: usize? = None
                        mut name_index: usize? = None
                        mut index = 0uz
                        for param in parsed_function.params {
                            defer index += 1
                            if param.variable.name == argument.name {
                                name_index = index
                            }
                            if target.has_value() and param.variable.name == target! {
                                target_index = index
                            }
                        }
                        if not name_index.has_value() {
                            .error(
                                format("Argument '{}' declared as stored here does not exist", argument.name)
                                argument.span
                            )
                            continue
                        }
                        if target.has_value() and not target_index.has_value() {
                            .error(
                                format("Argument '{}' declared as store target here does not exist", target!)
                                argument.span
                            )
                            continue
                        }

                        mut entry = (name_index!, ArgumentStoreLevel::InStaticStorage)
                        if target.has_value() {
                            entry.1 = ArgumentStoreLevel::InObject(argument_index: target_index!)
                        }
                        stores_arguments.push(entry)
                    }

                    if parsed_function.stores_arguments.has_value() {
                        parsed_function.stores_arguments!.push_values(&stores_arguments)
                    } else {
                        parsed_function.stores_arguments = stores_arguments
                    }
                }
                else => {
                    .error(
                        format("The attribute '{}' does not apply to functions", attribute.name)
                        attribute.span
                    )
                }
            }
        }
    }

    fn apply_attributes(mut this, anon parsed_method: &mut ParsedMethod, active_attributes: &[ParsedAttribute]) throws {
        .apply_attributes(parsed_function: &mut parsed_method.parsed_function, active_attributes)
    }

    fn apply_attributes(mut this, anon parsed_record: &mut ParsedRecord, active_attributes: &[ParsedAttribute]) throws {
        for attribute in *active_attributes {
            match attribute.name {
                "name" => {
                    guard attribute.assigned_value.has_value() else {
                        .error(
                            format("The attribute '{}' requires a value", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    if parsed_record.external_name.has_value() {
                        .error(
                            format("The attribute '{}' cannot be applied more than once", attribute.name)
                            attribute.span
                        )
                        continue
                    }

                    parsed_record.external_name = attribute.assigned_value
                }
                else => {
                    .error(
                        format("The attribute '{}' does not apply to records", attribute.name)
                        attribute.span
                    )
                }
            }
        }
    }

    fn parse_attribute_list(mut this, active_attributes: &mut [ParsedAttribute]) throws {
        while not .eof() and not .current() is RSquare and not .peek(1) is RSquare {
            let attribute = .parse_attribute()
            if attribute.has_value() {
                active_attributes.push(attribute!)
            }
        }
        if .current() is RSquare and .peek(1) is RSquare {
            .index += 2
        } else {
            .error("Expected ‘]]’", .current().span())
        }
    }

    fn parse_attribute(mut this) throws -> ParsedAttribute? {
        // Ident ('(' ((Ident|String) (':' (Ident|String))? ','?)* ')')? ('=' (Ident|String))?
        let span = .current().span()
        let name = match .current() {
            Identifier(name) => {
                .index++
                yield name
            }
            This => {
                .index++
                yield "this"
            }
            else => {
                .error("Expected identifier", .current().span())
                .index++
                return None
            }
        }

        mut arguments: [ParsedAttributeArgument] = []
        if .current() is LParen {
            .index++
            while not .eof() and not .current() is RParen {
                let span = .current().span()

                let argument_name = match .current() {
                    Identifier(name) => {
                        .index++
                        yield name
                    }
                    This => {
                        .index++
                        yield "this"
                    }
                    QuotedString(quote) => {
                        .index++
                        yield quote
                    }
                    else => {
                        .error("Expected identifier or string literal", .current().span())
                        return None
                    }
                }

                mut argument_value: String? = None
                if .current() is Colon {
                    .index++
                    argument_value = match .current() {
                        Identifier(name) => {
                            .index++
                            yield name
                        }
                        This => {
                            .index++
                            yield "this"
                        }
                        QuotedString(quote) => {
                            .index++
                            yield quote
                        }
                        else => {
                            .error("Expected identifier or string literal", .current().span())
                            return None
                        }
                    }
                }

                arguments.push(ParsedAttributeArgument(
                    name: argument_name
                    span
                    assigned_value: argument_value
                ))

                if .current() is Comma {
                    .index++
                } else if not .current() is RParen {
                    .error("Expected ‘,’ or ‘)’", .current().span())
                    break
                }
            }

            if .current() is RParen {
                .index++
            } else {
                .error("Expected ‘)’", .current().span())
            }
        }

        mut assigned_value: String? = None
        if .current() is Equal {
            .index++
            assigned_value = match .current() {
                Identifier(name) => {
                    .index++
                    yield Some(name)
                }
                This => {
                    .index++
                    yield "this"
                }
                QuotedString(quote) => {
                    .index++
                    yield Some(quote)
                }
                else => {
                    .error("Expected identifier or string literal", .current().span())
                    yield None
                }
            }
        }

        return ParsedAttribute(
            name
            span
            assigned_value
            arguments
        )
    }

    fn parse_using(mut this) throws -> ParsedAlias {
        // (using) qualified_name [as Ident]
        mut alias = ParsedAlias(
            alias_name: None
            target: []
        )

        loop {
            match .current() {
                Eol | As | Eof => {
                    break
                }
                ColonColon => {
                    .index++
                    continue
                }
                Identifier(name, span) => {
                    mut parsed_name = ParsedNameWithGenericParameters(
                        name
                        name_span: span
                        generic_parameters: []
                    )
                    .index++
                    if .current() is LessThan {
                        // Generic type
                        .index++

                        while not .eof() {
                            match .current() {
                                GreaterThan => {
                                    .index++
                                    break
                                }
                                Comma | Eol => {
                                    .index++
                                }
                                RightShift => {
                                    .inject_token(token: Token::GreaterThan(.current().span()))
                                    .index += 1
                                    break
                                }
                                else => {
                                    let index_before = .index
                                    let inner_type = .parse_typename()
                                    if index_before == .index {
                                        .error("Expected type name", .current().span())
                                        break
                                    }
                                    parsed_name.generic_parameters.push(inner_type)
                                }
                            }
                        }
                    }
                    alias.target.push(parsed_name)
                }
                else(span) => {
                    .error("Expected alias target name", span)
                    break
                }
            }
        }

        if .previous() is ColonColon(span) {
            .error("Expected alias target name", span)
        }

        if .current() is As {
            .index++

            match .current() {
                Identifier(name, span) => {
                    alias.alias_name = ParsedName(
                        name
                        span
                    )
                    .index++
                }
                else(span) => {
                    .error("Expected alias name", span)
                }
            }
        }

        return alias
    }

    fn parse_external_trait_implementation(mut this) throws -> ParsedExternalTraitImplementation {
        // (type) TypeName implements(TraitName...) { <method list> }
        let type_name = .parse_typename()
        .skip_newlines()
        if .current() is Implements {
            .index++
        } else {
            .error("Expected ‘implements’", .current().span())
        }
        let trait_list = .parse_trait_list()
        if not trait_list.has_value() {
            .error("Expected non-empty trait list", .current().span())
            return ParsedExternalTraitImplementation(
                for_type: type_name
                traits: []
                methods: []
            )
        }

        .skip_newlines()

        guard .current() is LCurly else {
            .error("Expected ‘{’", .current().span())
            return ParsedExternalTraitImplementation(for_type: type_name, traits: trait_list!, methods: [])
        }

        let (fields, methods) = .parse_struct_class_body(
            definition_linkage: DefinitionLinkage::Internal
            default_visibility: Visibility::Public
            is_class: false
        )

        if not fields.is_empty() {
            .error("External trait implementations cannot have fields", fields[0].var_decl.span)
        }

        return ParsedExternalTraitImplementation(for_type: type_name, traits: trait_list!, methods)
    }

    fn parse_trait(mut this) throws -> ParsedTrait {

        mut parsed_trait = ParsedTrait(
            name: ""
            name_span: .empty_span()
            generic_parameters: []
            requirements: ParsedTraitRequirements::Nothing
        )

        guard .current() is Identifier(name, span: name_span) else {
            .error("Expected trait name", .current().span())
            return parsed_trait
        }
        parsed_trait.name = name
        parsed_trait.name_span = name_span

        .index++

        if .current() is LessThan {
            parsed_trait.generic_parameters = .parse_generic_parameters()
        }

        match .current() {
            LCurly => {
                .index++
                mut methods: [ParsedFunction] = []
                // Attributes being parsed for the next entity
                mut active_attributes: [ParsedAttribute] = []

                loop {
                    match .current() {
                        RCurly => {
                            .index++
                            break
                        }
                        Eof(span) => {
                            .error("Expected '}' to close the trait body", span)
                        }
                        LSquare => {
                            if .peek(1) is LSquare {
                                .index += 2
                                .parse_attribute_list(&mut active_attributes)
                            } else {
                                .error("Unexpected token (expected ‘[[’)", .current().span())
                                .index += 1
                            }
                        }
                        Eol => {
                            .index++
                            continue
                        }
                        Fn => {
                            // pretend it's external so that we only parse the signature
                            mut method = .parse_function(
                                FunctionLinkage::Internal
                                Visibility::Public
                                is_comptime: false
                                is_destructor: false
                                is_unsafe: false // FIXME: Parse unsafe trait methods(?)
                                allow_missing_body: true
                            )
                            if method.block.stmts.is_empty() {
                                method.linkage = FunctionLinkage::External
                            }

                            .apply_attributes(&mut method, &active_attributes)
                            active_attributes = []

                            methods.push(method)
                        }
                        else(span) => {
                            .error_with_hint("Expected 'function' keyword inside trait definition", span,
                                format(
                                    "Inside '{}' trait's definition only function declarations can appear"
                                    parsed_trait.name
                                ), parsed_trait.name_span)
                            return parsed_trait
                        }
                    }

                    parsed_trait.requirements = ParsedTraitRequirements::Methods(methods)
                }
            }
            Equal => {
                .index += 1
                let expression = .parse_expression(allow_assignments: false, allow_newlines: true)
                parsed_trait.requirements = ParsedTraitRequirements::ComptimeExpression(expression)
            }
            else => {
                .error("Expected '{' to enter the body of the trait, or '=' to specify trait requirements",
                    .current().span())
                return parsed_trait
            }
        }

        return parsed_trait
    }

    fn parse_record(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord => match .current() {
        Struct => .parse_struct(definition_linkage)
        Class => .parse_class(definition_linkage)
        Enum => .parse_enum(definition_linkage, is_boxed: false)
        Boxed => {
            .index++
            yield .parse_enum(definition_linkage, is_boxed: true)
        }
        else => {
            .error("Expected `struct`, `class`, `enum`, or `boxed`", .current().span())
            yield ParsedRecord(
                name: "",
                name_span: .empty_span(),
                generic_parameters: [],
                definition_linkage,
                implements_list: None,
                methods: [],
                record_type: RecordType::Garbage
            )
        }
    }

    fn parse_import(mut this, parent: &mut ParsedNamespace) throws  {
        // import . <extern <extern-import> | <module-import>>
        if .current() is Extern {
            .index++
            parent.add_extern_import(.parse_extern_import(parent))
        } else {
            parent.add_module_import(.parse_module_import())
        }
    }

    fn parse_extern_import(mut this, parent: &mut ParsedNamespace) throws -> ParsedExternImport {
        // import extern . [c] "<path>" [as <alias-name>] namespace
        mut parsed_import = ParsedExternImport(
            is_c: false
            assigned_namespace: ParsedNamespace(
                name: None
                name_span: None
                functions: []
                records: []
                traits: []
                external_trait_implementations: []
                namespaces: []
                aliases: []
                module_imports: []
                extern_imports: []
                import_path_if_extern: None
                generating_import_extern_before_include: []
                generating_import_extern_after_include: []
                forall_chunks: []
            )
            before_include: []
            after_include: []
        )

        if .current() is Identifier(name, span) {
            .index++
            if name == "c" or name == "C" {
                parsed_import.is_c = true
            } else {
                .error("Expected 'c' or path after `import extern`"
                       .current().span())
            }
        }

        let import_path = match .current() {
            QuotedString(quote) => {
                .index++
                yield quote
            }
            else => {
                .error("Expected path after `import extern`"
                       .current().span())
                yield ""
            }
        }

        if .current() is As {
            .index++
            if .current() is Identifier(name, span) {
                .index++
                parsed_import.assigned_namespace.name = name
                parsed_import.assigned_namespace.name_span = span
            } else {
                .error("Expected name after 'as' keyword to name the extern import"
                        .current().span())
            }
        }

        if not .current() is LCurly {
            .error("Expected '{' to start namespace for the extern import"
                    .current().span())
        }
        .index++

        parsed_import.assigned_namespace = .parse_namespace()
        parsed_import.assigned_namespace.import_path_if_extern = Some(import_path)
        parsed_import.assigned_namespace.generating_import_extern_before_include = parsed_import.before_include
        parsed_import.assigned_namespace.generating_import_extern_after_include = parsed_import.after_include

        if .current() is RCurly {
            .index++
        } else {
            .error("Expected '}' to end namespace for the extern import"
                    .current().span())
        }

        loop {
            if .current() is Identifier(name) {
                match name {
                    "before_include" => {
                        .index++
                        let actions = .parse_include_action()
                        if actions.has_value() {
                            parsed_import.before_include.push_values(&actions!)
                        }
                    }
                    "after_include" => {
                        .index++
                        let actions = .parse_include_action()
                        if actions.has_value() {
                            parsed_import.after_include.push_values(&actions!)
                        }
                    }
                    else => {
                        break
                    }
                }
            } else {
                break
            }
        }

        parent.add_child_namespace(parsed_import.assigned_namespace)

        return parsed_import
    }

    fn parse_include_action(mut this) throws -> [IncludeAction]? {
        .skip_newlines()
        if .current() is Identifier(name) {
            // define { name = "value" ... }
            // undefine { name ... }
            match name {
                "define" => {
                    .index++
                    .skip_newlines()
                    if .current() is LCurly {
                        .index++
                        .skip_newlines()
                    } else {
                        .error("Expected '{' to start define action", .current().span())
                        return None
                    }

                    mut defines: [IncludeAction] = []
                    loop {
                        if .current() is Identifier(name) {
                            let span = .current().span()
                            .index++
                            .skip_newlines()
                            if .current() is Equal {
                                .index++
                            } else {
                                .error("Expected '=' to assign value to defined symbols", .current().span())
                                continue
                            }

                            let value = match .current() {
                                QuotedString(quote) => {
                                    .index++
                                    yield quote
                                }
                                else => {
                                    .error("Expected quoted string to assign value to defined symbols", .current().span())
                                    yield ""
                                }
                            }

                            defines.push(IncludeAction::Define(name, span, value))
                            .skip_newlines()
                            if .current() is Comma {
                                .index++
                                .skip_newlines()
                            }
                        } else {
                            break
                        }
                    }

                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Expected '}' to end define action", .current().span())
                    }

                    return Some(defines)
                }
                "undefine" => {
                    .index++
                    .skip_newlines()
                    if .current() is LCurly {
                        .index++
                        .skip_newlines()
                    } else {
                        .error("Expected '{' to start undefine include action", .current().span())
                        return None
                    }

                    mut defines: [IncludeAction] = []
                    loop {
                        if .current() is Identifier(name) {
                            let span = .current().span()
                            .index++

                            defines.push(IncludeAction::Undefine(name, span))

                            .skip_newlines()
                            if .current() is Comma {
                                .index++
                                .skip_newlines()
                            }
                        } else {
                            break
                        }
                    }

                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Expected '}' to end undefine action", .current().span())
                    }

                    return Some(defines)
                }
                else => {}
            }

            .error("Expected 'define' or 'undefine' in include action"
                    .current().span())
            return None
        } else {
            .error("Expected 'define' or 'undefine' in include action"
                    .current().span())
            return None
        }
    }

    fn parse_module_import(mut this) throws -> ParsedModuleImport {
        mut parsed_import = ParsedModuleImport(
            module_name: ImportName::Literal(name: "", span: .empty_span())
            alias_name: None
            import_list: ImportList::List([])
        )

        parsed_import.module_name = match .current() {
            Identifier(name, span) => match .peek(1) {
                LParen => {
                    let previous_can_have_trailing_closure = .can_have_trailing_closure
                    .can_have_trailing_closure = false
                    let expression = ParsedExpression::Call(
                        call: .parse_call()!
                        span
                    )
                    .can_have_trailing_closure = previous_can_have_trailing_closure
                    .index--
                    yield ImportName::Comptime(expression)
                }
                else => ImportName::Literal(name, span)
            }
            else => {
                .error("Expected module name", .current().span())
                return parsed_import
            }
        }
        .index++

        if .eol() {
            return parsed_import
        }

        if not .current() is LCurly {
            mut module_name: String = parsed_import.module_name.literal_name()
            mut module_span: Span = parsed_import.module_name.span()

            while (.current() is ColonColon) {
                .index++
                module_name += "::"
                match .current() {
                    Identifier(name, span) => {
                        module_name += name
                        module_span = merge_spans(module_span, span)
                        .index++
                    }
                    As | LCurly => { break }
                    else => {
                        .error("Expected module name fragment", .current().span())
                        return parsed_import
                    }
                }
            }

            parsed_import.module_name = ImportName::Literal(name: module_name, span: module_span)
        }

        if .current() is As {
            .index++
            if .current() is Identifier(name, span) {
                .index++
                parsed_import.alias_name = ImportName::Literal(name, span)
            } else  {
                .error("Expected name", .current().span())
                .index++
            }
        }

        if .eol() {
            return parsed_import
        }

        if not (.current() is LCurly) {
            .error("Expected '{'", .current().span())
        }
        .index++

        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if parsed_import.import_list is List(names) {
                        mut mutable_names = names
                        mutable_names.push(ImportName::Literal(name, span))
                    } else {
                        .error_with_hint(
                            format("Already importing everything from '{}'", parsed_import.module_name.literal_name()),
                            .current().span()
                            "Remove the '*' to import specific names"
                            .current().span()
                        )
                    }
                    .index++
                }
                Asterisk => {
                    if parsed_import.import_list is List(names) and names.is_empty() {
                        parsed_import.import_list = ImportList::All
                    } else {
                        if parsed_import.import_list is All {
                            .error(
                                format("Cannot repeat '*' in import list for '{}'", parsed_import.module_name.literal_name()),
                                .current().span()
                            )
                        } else {
                            .error(
                                format("Cannot mix '*' and specific names in import list for '{}'", parsed_import.module_name.literal_name()),
                                .current().span()
                            )
                        }
                    }
                    .index++
                }
                Comma | Eol => {
                    .index++
                }
                RCurly => {
                    .index++
                    break
                }
                else => {
                    .error("Expected import symbol", .current().span())
                    .index++
                }
            }
        }

        return parsed_import
    }

    fn parse_value_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage) throws -> ([ValueEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [ValueEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is Equal {
                        .index += 2
                        let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                        variants.push(ValueEnumVariant(name, span, value: expr))
                    } else {
                        .index++
                        variants.push(ValueEnumVariant(name, span, value: None))
                    }
                }
                RCurly => {
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Fn | Comptime => {
                    let is_comptime = .current() is Comptime

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(
                        function_linkage
                        visibility
                        is_virtual: false
                        is_override: false
                        is_comptime
                        is_destructor: false
                        is_unsafe: false // FIXME: Parse unsafe methods.
                    )

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if not .current() is RCurly {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }

        .index++

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    fn parse_sum_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ([SumEnumVariant], [ParsedField], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [SumEnumVariant] = []
        mut fields: [ParsedField] = []
        mut seen_a_variant = false

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant or field name", .previous().span())
            return (variants, fields, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is Colon {
                        let field = .parse_field(visibility: last_visibility ?? Visibility::Public)
                        if seen_a_variant {
                            .error_with_hint(
                                "Common enum fields must be declared before variants", span,
                                "Previous variant is here", variants.last()!.span
                            )
                        } else {
                            fields.push(field)
                        }
                        continue
                    }

                    seen_a_variant = true

                    if not (.peek(1) is LParen) {
                        .index++
                        variants.push(SumEnumVariant(name, span, params: None, default_values: None))
                        continue
                    }

                    .index += 2

                    mut var_decls: [ParsedVarDecl] = []
                    mut default_values: [ParsedExpression?] = []

                    while not .eof() {
                        if .peek(1) is Colon {
                            mut var_decl = .parse_variable_declaration(is_mutable: false)
                            if var_decl.parsed_type is Name(name, span) {
                                var_decl.inlay_span = span
                                if name == partial_enum.name and not is_boxed{
                                    .error("use 'boxed enum' to make the enum recursive", var_decl.span)
                                }
                            }
                            var_decls.push(var_decl)
                            continue
                        }

                        match .current() {
                            Identifier | LSquare | LCurly => {
                                var_decls.push(ParsedVarDecl(
                                    name: ""
                                    parsed_type: .parse_typename()
                                    is_mutable: false
                                    inlay_span: None
                                    span: .current().span()
                                ))
                            }
                            else => {}
                        }

                        match .current() {
                            Equal => {
                                .index++
                                let default_value = .parse_expression(allow_assignments: false, allow_newlines: false)
                                default_values.push(Some(default_value))
                            }
                            else => {
                                default_values.push(None)
                            }
                        }

                        match .current() {
                            RParen => {
                                .index++
                                break
                            }
                            Comma | Eol => {
                                .index++
                            }
                            else => {
                                .error(format("Incomplete enum variant definition, expected `,` or `)`; got ‘{}’", .current()), .current().span())
                                break;
                            }
                        }
                    }
                    variants.push(SumEnumVariant(name, span, params: var_decls, default_values))
                }
                RCurly => {
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Fn | Comptime => {
                    let is_comptime = .current() is Comptime

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(
                        function_linkage
                        visibility
                        is_virtual: false
                        is_override: false
                        is_comptime
                        is_destructor: false
                        is_unsafe: false // FIXME: Parse unsafe methods.
                    )

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if not .current() is RCurly {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, fields, methods)
        }
        .index++

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, fields, methods)
    }

    fn parse_enum(mut this, anon definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ParsedRecord {
        mut parsed_enum = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            implements_list: None,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut underlying_type: ParsedType? = None
        if .current() is Enum {
            .index++
        } else {
            .error("Expected ‘enum’ keyword", .current().span())
            return parsed_enum
        }

        if .eof() {
            .error("Incomplete enum definition, expected name", .current().span())
            return parsed_enum
        }

        if .current() is Identifier(name, span) {
            parsed_enum.name = name
            parsed_enum.name_span = span
            .index++
        } else {
            .error("Incomplete enum definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete enum definition, expected generic parameters or underlying type or body", .current().span())
            return parsed_enum
        }

        if .current() is LessThan {
            parsed_enum.generic_parameters = .parse_generic_parameters()
        }

        if .current() is Implements {
            .index++
            parsed_enum.implements_list = .parse_trait_list()
        }

        if .eof() {
            .error("Incomplete enum definition, expected underlying type or body", .current(). span())
            return parsed_enum
        }

        if .current() is Colon {
            if is_boxed {
                .error("Invalid enum definition: Value enums must not have an underlying type", .current().span())
            }
            .index++
            underlying_type = .parse_typename()
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected body", .current().span())
            return parsed_enum
        }

        if underlying_type.has_value() {
            let (variants, methods) = .parse_value_enum_body(partial_enum: parsed_enum, definition_linkage)
            parsed_enum.methods = methods
            parsed_enum.record_type = RecordType::ValueEnum(
                underlying_type: underlying_type!
                variants
            )
        } else {
            let (variants, fields, methods) = .parse_sum_enum_body(partial_enum: parsed_enum, definition_linkage, is_boxed)
            parsed_enum.methods = methods
            parsed_enum.record_type = RecordType::SumEnum(
                is_boxed: is_boxed,
                fields,
                variants
            )
        }

        return parsed_enum
    }

    public fn parse_struct_class_body(
        mut this
        definition_linkage: DefinitionLinkage
        default_visibility: Visibility
        is_class: bool
    ) throws -> ([ParsedField], [ParsedMethod]) {
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        mut last_virtual = false
        mut last_override = false
        mut last_extern = false

        // Have we already found an error?
        mut error = false;

        // Attributes being parsed for the next entity
        mut active_attributes: [ParsedAttribute] = []

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    if not active_attributes.is_empty() {
                        .error("Expected function after attribute", token.span())
                    }
                    .index++
                    return (fields, methods)
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Extern => {
                    last_extern = true
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                LSquare => {
                    if .peek(1) is LSquare {
                        .index += 2
                        .parse_attribute_list(&mut active_attributes)
                    } else {
                        .error("Unexpected token (expected ‘[[’)", .current().span())
                        .index += 1
                    }
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    if last_virtual or last_override {
                        .error("Fields cannot be ‘virtual’ or ‘override’", .current().span())
                    }
                    last_virtual = false
                    last_override = false

                    if last_extern {
                        .error("Fields cannot be ‘extern’", .current().span())
                    }
                    last_extern = false

                    mut field = .parse_field(visibility)
                    .apply_attributes(&mut field, &active_attributes)
                    active_attributes = []

                    fields.push(field)
                }
                Fn | Comptime | Destructor => {
                    // Parse a method
                    let is_comptime = .current() is Comptime
                    let is_destructor = .current() is Destructor

                    let function_linkage = match definition_linkage {
                        Internal => match last_extern {
                            true => FunctionLinkage::External
                            false => FunctionLinkage::Internal
                        }
                        External => FunctionLinkage::External
                    }
                    last_extern = false

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let is_virtual = last_virtual
                    let is_override = last_override
                    last_virtual = false
                    last_override = false

                    mut parsed_method = .parse_method(
                        function_linkage
                        visibility
                        is_virtual
                        is_override
                        is_comptime
                        is_destructor
                        is_unsafe: false // FIXME: Parse unsafe methods.
                    )
                    .apply_attributes(&mut parsed_method, &active_attributes)
                    active_attributes = []

                    methods.push(parsed_method)
                }
                Virtual => {
                    last_virtual = true
                    .index++
                }
                Override => {
                    last_override = true
                    .index++
                }
                else => {
                    active_attributes = []

                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error(format("Invalid member, did not expect a {} here", token), token.span())
                        error = true
                    }
                    .index++
                }
            }
        }
        if is_class {
            .error("Incomplete class body, expected ‘}’", .current().span())
        } else {
            .error("Incomplete struct body, expected ‘}’", .current().span())
        }
        return (fields, methods)
    }

    public fn parse_struct(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_struct = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            implements_list: None,
            methods: [],
            record_type: RecordType::Garbage
        )
        if .current() is Struct {
            .index++
        } else {
            .error("Expected `struct` keyword", .current().span())
            return parsed_struct
        }
        // Struct name
        if .eof() {
            .error("Incomplete struct definition, expected name", .current().span())
            return parsed_struct
        }

        if .current() is Identifier(name, span) {
            .index++
            parsed_struct.name = name
            parsed_struct.name_span = span
        } else {
            .error("Incomplete struct definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete struct definition, expected generic parameters or body", .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .current() is Implements {
            .index++
            parsed_struct.implements_list = .parse_trait_list()
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete struct definition, expected body", .current().span())
            return parsed_struct
        }

        let (fields, methods) = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Public, is_class: false)

        parsed_struct.methods = methods
        let super_type: ParsedType? = None
        parsed_struct.record_type = RecordType::Struct(fields, super_type)

        return parsed_struct
    }

    public fn parse_class(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_class = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            implements_list: None,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut super_type: ParsedType? = None
        if .current() is Class {
            .index++
        } else {
            .error("Expected `class` keyword", .current().span())
            return parsed_class
        }
        // Class name
        if .eof() {
            .error("Incomplete class definition, expected name", .current().span())
            return parsed_class
        }

        if .current() is Identifier(name, span) {
            .index++
            parsed_class.name = name
            parsed_class.name_span = span
        } else {
            .error("Incomplete class definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete class definition, expected generic parameters or super class or body", .current().span())
            return parsed_class
        }

        // Generic parameters
        parsed_class.generic_parameters = .parse_generic_parameters()

        if .current() is Implements {
            .index++
            parsed_class.implements_list = .parse_trait_list()
        }


        if .eof() {
            .error("Incomplete class definition, expected super class or body", .current().span())
            return parsed_class
        }

        // Super class
        if .current() is Colon {
            .index++
            super_type = .parse_typename()
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete class definition, expected body", .current().span())
            return parsed_class
        }

        let (fields, methods) = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Private, is_class: true)

        parsed_class.methods = methods
        parsed_class.record_type = RecordType::Class(fields, super_type)

        return parsed_class
    }

    public fn parse_function_parameters(mut this) throws -> [ParsedParameter] {
        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        .skip_newlines()

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        // Have we already found an error?
        mut error = false
        mut parameter_complete = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma | Eol => {
                    if not parameter_complete and not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = true
                    current_param_is_mutable = false
                    parameter_complete = false
                }
                Anon => {
                    if parameter_complete and not error  {
                        .error("‘anon’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘anon’ must appear before ‘mut’", .current().span())
                        error = true
                    }
                    if not current_param_requires_label and not error  {
                        .error("‘anon’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    if parameter_complete and not error  {
                        .error("‘mut’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘mut’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        default_argument: None,
                        span: .current().span(),
                    ))
                    .index++
                    parameter_complete = true
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)

                    mut default_argument: ParsedExpression? = None

                    if .current() is Equal {
                        .index++
                        default_argument = .parse_expression(allow_assignments: false, allow_newlines: true)
                    }

                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        default_argument,
                        span: .previous().span(),
                    ))
                    parameter_complete = true
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                }
            }
        }
        return params
    }

    public fn parse_function(
        mut this
        anon linkage: FunctionLinkage
        anon visibility: Visibility
        is_comptime: bool
        is_destructor: bool
        is_unsafe: bool
        allow_missing_body: bool = false
    ) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            id: .next_function_id++
            name: "",
            name_span: .empty_span(),
            visibility,
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: .span(start: 0, end: 0),
            can_throw: false,
            type: FunctionType::Normal,
            linkage,
            must_instantiate: false,
            is_comptime
            is_fat_arrow: false
            is_unsafe
        )

        if is_destructor {
            // Destructors have an implicit ‘mut this’ parameter.
            parsed_function.type = FunctionType::Destructor
            parsed_function.params.push(ParsedParameter(
                requires_label: false
                variable: ParsedVariable(
                    name: "this",
                    parsed_type: ParsedType::Empty
                    is_mutable: true
                    span: .current().span()
                )
                default_argument: None
                span: .current().span()
            ))
        }

        if not is_destructor {
            .index++
        }

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        if is_destructor {
            parsed_function.name = "~"
            parsed_function.name_span = .previous().span()
        } else {
            guard .current() is Identifier(name) else {
                .error("Incomplete function definition", .current().span())
                return parsed_function
            }
            parsed_function.name = name
            parsed_function.name_span = .current().span()
        }

        .index++

        if not is_destructor {
            parsed_function.generic_parameters = .parse_generic_parameters()
        }

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if not is_destructor {
            parsed_function.params = .parse_function_parameters()
        }

        // NOTE: main() always throws
        mut can_throw = parsed_function.name == "main"
        if .current() is Throws {
            if is_destructor {
                .error("Destructor cannot throw", .current().span())
            } else {
                can_throw = true
            }
            .index++
        }
        parsed_function.can_throw = can_throw

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        } else {
            parsed_function.return_type_span = .previous().span()
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
            parsed_function.is_fat_arrow = true
        } else {
            if allow_missing_body {
                .skip_newlines()
                guard .current() is LCurly else { return parsed_function }
            }

            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    fn parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    fn parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        mut default_value: ParsedExpression? = None

        if .peek(0) is Equal {
            .index++
            default_value = .parse_expression(allow_assignments: false, allow_newlines: false)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
            default_value
        )
    }

    fn parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility, is_virtual: bool, is_override: bool, is_comptime: bool, is_destructor: bool, is_unsafe: bool) throws -> ParsedMethod {
        mut parsed_function = .parse_function(linkage, visibility, is_comptime, is_destructor, is_unsafe)

        if linkage is External {
            parsed_function.must_instantiate = true
        }

        return ParsedMethod(
            parsed_function
            visibility
            is_virtual
            is_override
        )
    }

    fn parse_type_parameter_list(mut this) throws -> [ParsedType] {
        mut params: [ParsedType] = []
        if .current() is LessThan {
            .index++
            mut saw_ending_bracket = false
            while not .eof() {
                match .current() {
                    GreaterThan => {
                        .index++
                        saw_ending_bracket = true
                        break
                    }
                    RightShift => {
                        .inject_token(token: Token::GreaterThan(.current().span()))
                        .index++
                        saw_ending_bracket = true
                        break
                    }
                    else => {
                        mut index_before = .index
                        params.push(.parse_typename())
                        if .index == index_before {
                            .error("Expected type parameter", .current().span())
                            break
                        }
                        if .current() is Comma {
                            .index++
                        }
                    }
                }
            }

            if not saw_ending_bracket {
                .error("Expected `>` after type parameters", .current().span())
            }
        }

        return params
    }

    fn parse_typename(mut this) throws -> ParsedType {
        let start = .current().span()
        mut is_reference = false
        mut is_mutable_reference = false

        if .current() is Ampersand {
            is_reference = true
            .index++
            if .current() is Mut {
                is_mutable_reference = true
                .index++
            }
        }

        mut parsed_type = .parse_type_shorthand()

        if parsed_type is Empty {
            parsed_type = .parse_type_longhand()
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        if is_reference {
            let span = merge_spans(start, .current().span())
            if is_mutable_reference {
                parsed_type = ParsedType::MutableReference(inner: parsed_type, span)
            } else {
                parsed_type = ParsedType::Reference(inner: parsed_type, span)
            }
        }

        return parsed_type
    }

    fn parse_type_longhand(mut this) throws -> ParsedType => match .current() {
        Raw => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
            yield match inner {
                Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                else => ParsedType::RawPtr(inner, span)
            }
        }
        Weak => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            yield ParsedType::WeakPtr(inner, span)
        }
        Identifier(name) => {
            let span = .current().span()
            .index++
            mut parsed_type =  ParsedType::Name(name, span)
            if .current() is LessThan {
                mut params = .parse_type_parameter_list()
                parsed_type = ParsedType::GenericType(name, generic_parameters: params, span)
            }

            if .current() is ColonColon {
                .index++
                mut namespaces: [String] = [name]

                while not .eof() {
                    match .current() {
                        Identifier(name: namespace_name) => {
                            if .previous() is ColonColon {
                                namespaces.push(namespace_name)
                                .index++
                            } else {
                                .error("Expected ‘::’ here", span: Span(file_id: span.file_id, start: span.start, end: span.start))
                                break
                            }
                        }
                        ColonColon => {
                            if .previous() is Identifier {
                                .index++
                            } else {
                                .error("Expected name after", span)
                                break
                            }
                        }
                        else => {
                            break
                        }
                    }
                }

                let type_name = namespaces.pop()!

                mut params = .parse_type_parameter_list()
                parsed_type = ParsedType::NamespacedName(name: type_name, namespaces, params, span: .previous().span())
            }

            yield parsed_type
        }
        Fn => {
            let start = .current().span()
            .index++

            let params = .parse_function_parameters()

            let can_throw = .current() is Throws
            if can_throw {
                .index++
            }

            mut return_type = ParsedType::Empty
            if .current() is Arrow {
                .index++
                return_type = .parse_typename()
            } else {
                .error("Expected '->'", .current().span())
            }

            yield ParsedType::Function(params, can_throw, return_type, span: merge_spans(start, return_type.span()))
        }
        else => {
            .error("Expected type name", .current().span())
            yield ParsedType::Empty
        }
    }

    fn parse_destructuring_assignment(mut this, is_mutable: bool) throws -> ParsedVarDeclTuple {
        let start = .current().span()
        .index++

        mut var_declarations: [ParsedVarDecl] = []

        loop {
            match .current() {
                Identifier => {
                    var_declarations.push(.parse_variable_declaration(is_mutable))
                }
                Comma => {
                    .index++
                }
                RParen => {
                    .index++
                    break
                }
                else => {
                    .error("Expected close of destructuring assignment block", .current().span())
                    var_declarations = []
                    break
                }
            }
        }

        return ParsedVarDeclTuple(
            var_decls: var_declarations,
            span: merge_spans(start, .previous().span())
        )
    }

    fn parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        let span = .current().span()

        guard .current() is Identifier(name) else {
            return ParsedVarDecl(
                name: ""
                parsed_type: ParsedType::Empty
                is_mutable: false
                inlay_span: None
                span
            )
        }

        .index++
        if .current() is Colon {
            .index++
        } else {
            return ParsedVarDecl(
                name
                parsed_type: ParsedType::Empty
                is_mutable
                inlay_span: span
                span
            )
        }

        let parsed_type = .parse_typename()
        if is_mutable and (parsed_type is Reference or parsed_type is MutableReference) {
            .error("Reference parameter can not be mutable", span)
        }

        return ParsedVarDecl(
            name
            parsed_type
            is_mutable
            inlay_span: None
            span
        )
    }

    fn parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    fn parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    fn parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        if .current() is LCurly {
            .index++
        }
        let inner = .parse_typename()
        if .current() is RCurly {
            .index++
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    fn parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            let index_before = .index
            let type = .parse_typename()
            let index_after = .index
            if index_before == index_after {
                break
            }
            types.push(type)
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    fn parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", .current().span())
        return block
    }

    fn parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                let statement = .parse_statement(inside_block: false)
                yield ParsedStatement::Defer(statement, span: merge_spans(start, .previous().span()))
            }
            Unsafe => match .peek(1) {
                LCurly => {
                    .index++
                    let block = .parse_block()
                    yield ParsedStatement::UnsafeBlock(block, span: merge_spans(start, .previous().span()))
                }
                else => {
                    let expr = .parse_expression(allow_assignments: true, allow_newlines: false)
                    yield ParsedStatement::Expression(expr, span: merge_spans(start, .previous().span()))
                }
            }
            Break => {
                .index++
                yield ParsedStatement::Break(start)
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue(start)
            }
            Loop => {
                .index++
                let block = .parse_block()
                yield ParsedStatement::Loop(block, span: merge_spans(start, .previous().span()))
            }
            Throw => {
                .index++
                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                yield ParsedStatement::Throw(expr, span: merge_spans(start, .previous().span()))
            }
            While => {
                .index++

                let previous_can_have_trailing_closure = .can_have_trailing_closure
                .can_have_trailing_closure = false
                let condition = .parse_expression(allow_assignments: false, allow_newlines: true)
                .can_have_trailing_closure = previous_can_have_trailing_closure

                let block = .parse_block()
                yield ParsedStatement::While(condition, block, span: merge_spans(start, .previous().span()))
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr, span: merge_spans(start, .previous().span()))
            }
            Return => {
                .index++
                yield match .current() {
                    Eol | Eof | RCurly => ParsedStatement::Return(expr: None, span: start)
                    else => ParsedStatement::Return(expr: .parse_expression(allow_assignments: false, allow_newlines: false), span: merge_spans(start, .previous().span()))
                }
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++

                mut vars: [ParsedVarDecl] = []
                mut is_destructuring_assingment = false
                mut tuple_var_name = ""
                mut tuple_var_decl = ParsedVarDecl(
                    name: "",
                    parsed_type: ParsedType::Empty,
                    is_mutable: is_mutable,
                    inlay_span: None,
                    span: .current().span(),
                )

                if .current() is LParen {
                    vars = .parse_destructuring_assignment(is_mutable).var_decls
                    for var in vars {
                        tuple_var_name += var.name
                        tuple_var_name += "_"
                    }
                    tuple_var_decl.name = tuple_var_name
                    is_destructuring_assingment = true
                } else {
                    tuple_var_decl = .parse_variable_declaration(is_mutable)
                }

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false, allow_newlines: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                mut return_statement = ParsedStatement::VarDecl(var: tuple_var_decl, init, span: merge_spans(start, .previous().span()))

                if is_destructuring_assingment {
                    let old_return_statement = return_statement
                    return_statement = ParsedStatement::DestructuringAssignment(vars, var_decl: old_return_statement, span: merge_spans(start, .previous().span()))
                }
                yield return_statement
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            LCurly => {
                let block = .parse_block()
                yield ParsedStatement::Block(block, span: merge_spans(start, .previous().span()))
            }
            Guard => .parse_guard_statement()
            else => {
                let expr = .parse_expression(allow_assignments: true, allow_newlines: false)
                yield ParsedStatement::Expression(expr, span: merge_spans(start, .previous().span()))
            }
        }
    }

    fn parse_guard_statement(mut this) throws -> ParsedStatement {
        let span = .current().span()
        .index++
        let previous_can_have_trailing_closure = .can_have_trailing_closure
        .can_have_trailing_closure = false
        let expr = .parse_expression(allow_assignments: false, allow_newlines: true)
        .can_have_trailing_closure = previous_can_have_trailing_closure
        if .current() is Else {
            .index++
        } else {
            .error("Expected `else` keyword", .current().span())
        }
        let else_block = .parse_block()

        mut remaining_code = ParsedBlock(stmts: [])

        while not .eof() {
            match .current() {
                RCurly => {
                    return ParsedStatement::Guard(expr, else_block, remaining_code, span)
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    remaining_code.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        return ParsedStatement::Guard(expr, else_block, remaining_code, span)
    }

    fn parse_try_block(mut this) throws -> ParsedExpression {
        let start_span = .current().span()
        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            if .current() is Identifier(name) {
                error_span = .current().span()
                error_name = name
                .index++
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedExpression::TryBlock(stmt, error_name, error_span, catch_block, span: merge_spans(start_span, .previous().span()))
    }

    fn parse_for_statement(mut this) throws -> ParsedStatement {
        let start_span = .current().span()
        .index++

        mut iterator_name = ""
        mut destructured_var_decls: [ParsedVarDecl] = []

        mut name_span = .current().span()

        match .current() {
            Identifier(name) => {
                iterator_name = name
                .index++
            }
            LParen => {
                let destructured_assignment = .parse_destructuring_assignment(is_mutable: false)
                destructured_var_decls = destructured_assignment.var_decls
                mut tuple_var_name = ""
                for var in destructured_var_decls {
                    tuple_var_name += var.name
                    tuple_var_name += "__"
                }
                name_span = destructured_assignment.span
                iterator_name = tuple_var_name
            }
            else => {
                .error("Expected iterator name or destructuring pattern", .current().span())
                return ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
            }
        }

        if .current() is In {
            .index++
        } else {
            .error("Expected ‘in’", .current().span())
            return ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
        }

        let previous_can_have_trailing_closure = .can_have_trailing_closure
        .can_have_trailing_closure = false
        let range = .parse_expression(allow_assignments: false, allow_newlines: false)
        .can_have_trailing_closure = previous_can_have_trailing_closure

        mut is_destructuring = false
        mut block = .parse_block();

        if destructured_var_decls.size() > 0 {
            is_destructuring = true
            mut tuple_var_name = "jakt__"
            tuple_var_name += iterator_name
            mut tuple_var_decl = ParsedVarDecl(
                name: tuple_var_name,
                parsed_type: ParsedType::Empty,
                is_mutable: false,
                inlay_span: None,
                span: .current().span(),
            )
            let init = ParsedExpression::Var(name: iterator_name, span: merge_spans(start_span, .previous().span()))
            let var_decl = ParsedStatement::VarDecl(var: tuple_var_decl, init, span: merge_spans(start_span, .previous().span()))
            let destructured_vars_stmt = ParsedStatement::DestructuringAssignment(vars: destructured_var_decls, var_decl, span: merge_spans(start_span, .previous().span()))
            mut block_stmts: [ParsedStatement] = []
            block_stmts.push(destructured_vars_stmt)
            block_stmts.push_values(&block.stmts)
            block.stmts = block_stmts
        }

        return ParsedStatement::For(iterator_name, name_span, is_destructuring, range, block, span: merge_spans(start_span, .previous().span()))
    }

    fn parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage(.current().span())
        }

        let start_span = .current().span()
        .index++

        let previous_can_have_trailing_closure = .can_have_trailing_closure
        .can_have_trailing_closure = false
        let condition = .parse_expression(allow_assignments: false, allow_newlines: true)
        .can_have_trailing_closure = previous_can_have_trailing_closure

        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        .skip_newlines()

        if .current() is Else {
            .index++
            .skip_newlines()
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    let block = .parse_block()
                    if then_block.equals(block) {
                        .error("if and else have identical blocks", .current().span())
                    }
                    else_statement = ParsedStatement::Block(block, span: merge_spans(start_span, .previous().span()))
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement, span: merge_spans(start_span, .previous().span()))
    }

    fn parse_expression(mut this, allow_assignments: bool, allow_newlines: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        loop {
            if allow_newlines {
                if .eof() or .current() is LCurly {
                    break
                }
                .skip_newlines()
            } else {
                if .eol() {
                    break
                }
            }

            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = op.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match op {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => {
                        .compiler.panic("operator is not an operator")
                    }
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => {
                    .compiler.panic("operator is not an operator")
                }
            }
        }

        return expr_stack[0]
    }

    fn parse_operand_base(mut this) throws -> ParsedExpression => match .current() {
        Dot(span) => {
            yield ParsedExpression::Var(name: "this", span)
        }
        Try(span) => {
            .index++
            yield match .current() {
                LCurly => .parse_try_block()
                else => {
                    let expression = .parse_expression(allow_assignments: true, allow_newlines: true)
                    mut catch_block: ParsedBlock? = None
                    mut catch_name: String? = None
                    if .current() is Catch {
                        .index++
                        if .current() is Identifier(name) {
                            catch_name = name
                            .index++
                        }
                        catch_block = .parse_block()
                    }
                    yield ParsedExpression::Try(expr: expression, catch_block, catch_name, span)
                }
            }
        }
        QuotedString(quote, span) => {
            .index++
            yield ParsedExpression::QuotedString(val: quote, span)
        }
        SingleQuotedString(quote, prefix, span) => {
            .index++
            yield ParsedExpression::SingleQuotedString(val: quote, prefix, span)
        }
        Number(prefix, number, suffix, span) => .parse_number(prefix, number, suffix, span)
        True(span) => {
            .index++
            yield ParsedExpression::Boolean(val: true, span)
        }
        False(span) => {
            .index++
            yield ParsedExpression::Boolean(val: false, span)
        }
        This(span) => {
            .index++
            yield ParsedExpression::Var(name: "this", span)
        }
        Not(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
        }
        Tilde(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::BitwiseNot, span)
        }
        Sizeof(span) => {
            let start = .current().span()
            .index++
            let parsed_type = .parse_typename()
            let span = merge_spans(start, parsed_type.span())
            yield ParsedExpression::UnaryOp(
                expr: ParsedExpression::Garbage(span)
                op: UnaryOperator::Sizeof(parsed_type)
                span
            )
        }
        Reflect(span) => {
            let start = .current().span()
            .index++
            let type = .parse_typename()
            let span = merge_spans(start, type.span())
            yield ParsedExpression::Reflect(type, span)
        }
        Identifier(name, span) => {
            if .peek(1) is LParen {
                if name == "Some" {
                    .index++
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    return ParsedExpression::OptionalSome(expr, span)
                }
                let call = .parse_call()
                return ParsedExpression::Call(call: call!, span)
            }
            if .peek(1) is LessThan {
                // We *try* to see if it's a generic, but the parse errors, we back up and try something else
                .compiler.ignore_parser_errors = true
                let call = .parse_call()
                .compiler.ignore_parser_errors = false
                if not call.has_value() {
                    return match name {
                        "None" => ParsedExpression::OptionalNone(span)
                        else => ParsedExpression::Var(name, span)
                    }
                }
                return ParsedExpression::Call(call: call!, span)
            }
            .index++
            if name == "None" {
                return ParsedExpression::OptionalNone(span)
            }
            yield ParsedExpression::Var(name, span)
        }
        LParen(span) => {
            let start_span = .current().span()
            .index++

            mut expr = .parse_expression(allow_assignments: false, allow_newlines: false)

            .skip_newlines()

            match .current() {
                RParen => {
                    .index++
                }
                Comma => {
                    // We have a tuple
                    .index++

                    mut tuple_exprs: [ParsedExpression] = [expr]
                    mut end_span = start_span

                    while not .eof() {
                        match .current() {
                            Eol | Comma => {
                                .index++
                            }
                            RParen => {
                                .index++
                                break
                            }
                            else => {
                                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                                end_span = expr.span()
                                tuple_exprs.push(expr)
                            }
                        }
                    }

                    if .eof() {
                        .error("Expected ')'", .current().span());
                    }

                    expr = ParsedExpression::JaktTuple(
                        values: tuple_exprs,
                        span: merge_spans(start_span, end_span)
                    )
                }
                else => {
                    .error("Expected ')'", .current().span())
                }
            }

            yield expr
        }
        PlusPlus(span)
        | MinusMinus(span)
        | Minus(span) => {

            let op = match .current() {
                PlusPlus => UnaryOperator::PreIncrement
                MinusMinus => UnaryOperator::PreDecrement
                Minus => UnaryOperator::Negate
                else => {
                    .compiler.panic("unreachable")
                }
            }

            let start = .current().span()
            .index++

            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())

            yield ParsedExpression::UnaryOp(expr, op, span)
        }
        LSquare => {
            yield .parse_array_or_dictionary_literal()
        }
        Match => {
            yield .parse_match_expression()
        }
        LCurly => {
            yield .parse_set_literal()
        }
        Ampersand => .parse_ampersand()
        Asterisk => .parse_asterisk()
        Fn => .parse_lambda()
        DotDot => .parse_range()
        Unsafe => .parse_unsafe_expr()
        else => {
            let span = .current().span()
            .index++
            .error("Unsupported expression", span)
            yield ParsedExpression::Garbage(span)
        }
    }

    fn parse_number(mut this, prefix: LiteralPrefix, number: String, mut suffix: LiteralSuffix, span: Span) throws -> ParsedExpression {
        .index++
        mut total = 0u64

        if not prefix is None {
            match prefix {
                Hexadecimal => {
                    if number.length() == 0 {
                        .error(format("Could not parse hexadecimal number due to no digits"), span)
                        return ParsedExpression::Garbage(span)
                    }

                    for cp in number.code_points() {
                        let byte = as_saturated<u8>(cp)

                        if byte != b'_' {
                            mut offset: u8 = 0
                            if (byte >= b'a' and byte <= b'z') {
                                offset = 39
                            } else if (byte >= b'A' and byte <= b'Z') {
                                offset = 7
                            }
                            let value = byte - offset
                            let digit: u64 = as_saturated(value - b'0')
                            total = total * 16 + digit
                        }
                    }
                }
                Octal => {
                    if number.length() == 0 {
                        .error(format("Could not parse octal number due to no digits"), span)
                        return ParsedExpression::Garbage(span)
                    }

                    for cp in number.code_points() {
                        let byte = as_saturated<u8>(cp)

                        if byte != b'_' {
                            let digit: u64 = as_saturated(byte - b'0')
                            total = total * 8 + digit
                        }
                    }
                }
                Binary => {
                    if number.length() == 0 {
                        .error(format("Could not parse binary number due to no digits"), span)
                        return ParsedExpression::Garbage(span)
                    }

                    for cp in number.code_points() {
                        let byte = as_saturated<u8>(cp)

                        if byte != b'_' {
                            let digit: u64 = as_saturated(byte - b'0')
                            total = total * 2 + digit
                        }
                    }
                }
                None => {}
            }

            let constant_value = .make_integer_numeric_constant(number: total, suffix, span)
            if constant_value.has_value() {
                return ParsedExpression::NumericConstant(val: constant_value!, span)
            }

            return ParsedExpression::Garbage(span)
        }

        mut number_too_large = false
        mut floating = false

        mut fraction_nominator: u64 = 0
        mut fraction_denominator: u64 = 1

        if number.length() == 0 {
            .error(format("Could not parse number due to no digits"), span)
            return ParsedExpression::Garbage(span)
        }

        for cp in number.code_points() {
            let byte = as_saturated<u8>(cp)

            if byte != b'_' {
                if byte == b'.' {
                    floating = true
                    continue
                }

                let digit: u64 = as_saturated(byte - b'0')

                if floating {
                    fraction_nominator = fraction_nominator * 10u64 + digit
                    fraction_denominator *= 10u64
                } else {
                    // NOTE: We use unchecked arithmetic here to see if the number is too large
                    //       for our u64 storage type.
                    let old_total = total
                    total = unchecked_add(unchecked_mul(total, 10u64), digit)
                    if total < old_total {
                        number_too_large = true
                    }
                }
            }
        }

        if number_too_large {
            .error(format("Integer literal too large"), span)
            return ParsedExpression::Garbage(span)
        }

        if floating and suffix is None {
            suffix = LiteralSuffix::F64
        }

        // Sanity check for float numbers with an integer suffix
        let is_float_suffix = match suffix {
            LiteralSuffix::F32 | LiteralSuffix::F64 => true
            else => false
        }
        if floating and not is_float_suffix {
            // FIXME: Provide better error handling
            return ParsedExpression::Garbage(span)
        }

        let constant_value = match suffix {
            LiteralSuffix::F32 | LiteralSuffix::F64 => {
                let number: f64 = u64_to_float<f64>(total) + u64_to_float<f64>(fraction_nominator)/u64_to_float<f64>(fraction_denominator)
                yield .make_float_numeric_constant(number, suffix, span)
            }
            else => .make_integer_numeric_constant(number: total, suffix, span)
        }

        if constant_value.has_value() {
            return ParsedExpression::NumericConstant(val: constant_value!, span)
        }

        return ParsedExpression::Garbage(span)
    }

    fn make_integer_numeric_constant(mut this, number: u64, suffix: LiteralSuffix, span: Span) throws -> NumericConstant? {
        // FIXME: consider unifying with make_float_numeric_constant() to a single function
        match suffix {
            None => {
                let n = number as? i64
                if n.has_value() {
                    return NumericConstant::UnknownSigned(n!)
                }
                return NumericConstant::UnknownUnsigned(number)
            }
            U8 => {
                let n = number as? u8
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::U8(n!)
            }
            U16 => {
                let n = number as? u16
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::U16(n!)
            }
            U32 => {
                let n = number as? u32
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::U32(n!)
            }
            U64 => {
                let n = number as? u64
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::U64(n!)
            }
            UZ => {
                let n = number as? usize
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::USize(n! as! u64)
            }
            I8 => {
                let n = number as? i8
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::I8(n!)
            }
            I16 => {
                let n = number as? i16
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::I16(n!)
            }
            I32 => {
                let n = number as? i32
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::I32(n!)
            }
            I64 => {
                let n = number as? i64
                if not n.has_value() {
                    .error(format("Number {} cannot fit in integer type {}", number, suffix), span)
                    return NumericConstant::U64(number)
                }
                return NumericConstant::I64(n!)
            }
            else => {}
        }

        return None
    }

    fn make_float_numeric_constant(mut this, number: f64, suffix: LiteralSuffix, span: Span) throws -> NumericConstant? => match suffix {
        // FIXME: consider unifying with make_integer_numeric_constant() to a single function
        LiteralSuffix::F32 => NumericConstant::F32(f64_to_f32(number))
        LiteralSuffix::F64 => NumericConstant::F64(number)
        else => None
    }

    fn parse_captures(mut this) throws -> [ParsedCapture] {
        mut captures: [ParsedCapture] = []
        guard .current() is LSquare else {
            return []
        }
        .index++

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Ampersand => {
                    .index++
                    match .current() {
                        Mut => {
                            .index++
                            if .current() is Identifier(name) {
                                captures.push(ParsedCapture::ByMutableReference(name, span: .current().span()))
                                .index++
                            } else {
                                .error(format("Expected identifier, got '{}'", .current()), .current().span())
                                .index++
                            }
                        }
                        Identifier(name) => {
                            captures.push(ParsedCapture::ByReference(name, span: .current().span()))
                            .index++
                        }
                        else => {
                            .error(format("Expected identifier or mut, got '{}'", .current()), .current().span())
                            .index++
                        }
                    }
                }
                Comptime => {
                    .index++

                    if .current() is Identifier(name) {
                        captures.push(ParsedCapture::ByComptimeDependency(name, span: .current().span()))
                        .index++
                    } else {
                        .error(format("Expected identifier, got '{}'", .current()), .current().span())
                        .index++
                    }
                }
                Identifier(name) => {
                    captures.push(ParsedCapture::ByValue(name, span: .current().span()))
                    .index++
                }
                This => {
                    // NOTE: We capture `this` "by value" here, but `this` is actually a raw reference
                    captures.push(ParsedCapture::ByValue(name: "this", span: .current().span()))
                    .index++
                }
                Comma | Eol => {
                    .index++
                }
                else => {
                    .error(format("Unexpected token '{}' in captures list", .current()), .current().span())
                    .index++
                }
            }
        }

        return captures
    }

    fn parse_lambda(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        let captures = .parse_captures()
        let params = .parse_function_parameters()
        let can_throw = .current() is Throws
        if can_throw {
            .index++
        }

        mut return_type = match .current() {
            Arrow => {
                .index++
                yield .parse_typename()
            }
            else => ParsedType::Empty
        }

        mut is_fat_arrow = false
        let block = match .current() {
            FatArrow => {
                is_fat_arrow = true
                .index++
                let expr = .parse_expression(allow_assignments: true, allow_newlines: false)
                let span = expr.span()
                yield ParsedBlock(stmts: [ParsedStatement::Return(expr, span)])
            }
            else => .parse_block()
        }

        return ParsedExpression::Function(
            captures
            params
            can_throw
            is_fat_arrow
            return_type
            block
            span: merge_spans(start, .current().span())
        )
    }

    fn parse_asterisk(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        let expr = .parse_operand()
        return ParsedExpression::UnaryOp(expr, op: UnaryOperator::Dereference, span: merge_spans(start, .current().span()))
    }

    fn parse_ampersand(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        if .current() is Raw {
            .index++
            let expr = .parse_operand()
            return ParsedExpression::UnaryOp(expr, op: UnaryOperator::RawAddress, span: merge_spans(start, expr.span()))
        }
        if .current() is Mut {
            .index++
            let expr = .parse_operand()
            return ParsedExpression::UnaryOp(expr, op: UnaryOperator::MutableReference, span: merge_spans(start, expr.span()))
        }
        let expr = .parse_operand()
        return ParsedExpression::UnaryOp(expr, op: UnaryOperator::Reference, span: merge_spans(start, expr.span()))
    }

    fn parse_range(mut this) throws -> ParsedExpression {
        let start = .current().span()

        .index++

        mut to: ParsedExpression? = None
        match .current() {
            RSquare | Eol | Comma | RParen => {}
            else => {
                to = .parse_operand()
            }
        }

        return ParsedExpression::Range(from: None, to, span: merge_spans(start, .current().span()))
    }

    fn parse_unsafe_expr(mut this) throws -> ParsedExpression {
        let start = .current().span()

        .index++

        let expr = .parse_operand()

        return ParsedExpression::Unsafe(expr, span: merge_spans(start, expr.span()))
    }

    fn parse_set_literal(mut this) throws -> ParsedExpression {
        let start = .current().span()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut output: [ParsedExpression] = []
        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    if expr is Garbage {
                        break
                    }

                    output.push(expr)
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RCurly {
            .error("Expected ‘}’ to close the set", .tokens[end].span())
        }

        return ParsedExpression::Set(values: output, span: merge_spans(start, .tokens[end].span()))
    }

    fn parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()
        return .parse_operand_postfix_operator(start, expr)
    }

    fn parse_operand_postfix_operator(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        mut result = expr
        loop {
            result = match .current() {
                DotDot => {
                    .index++

                    mut to: ParsedExpression? = None
                    mut span_end = .current().span()
                    match .current() {
                        RSquare | Eol | Comma | RParen => {}
                        else => {
                            to = .parse_operand()
                            span_end = to!.span()
                        }
                    }

                    yield ParsedExpression::Range(from: result, to, span: merge_spans(start, span_end))
                }
                ExclamationPoint => {
                    .index++
                    yield ParsedExpression::ForcedUnwrap(expr: result, span: merge_spans(start, .previous().span()))
                }
                PlusPlus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostIncrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                MinusMinus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostDecrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                As => {
                    .index++
                    let cast_span = merge_spans(.previous().span(), .current().span())
                    let cast = match .current() {
                        ExclamationPoint => {
                            .index++
                            yield TypeCast::Infallible(.parse_typename())
                        }
                        QuestionMark => {
                            .index++
                            yield TypeCast::Fallible(.parse_typename())
                        }
                        else => {
                            .error_with_hint("Invalid cast syntax", cast_span, "Use `as!` for an infallible cast, or `as?` for a fallible cast", .previous().span())
                            yield TypeCast::Fallible(.parse_typename())
                        }
                    }
                    let span = merge_spans(start, merge_spans(cast_span, .current().span()))
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::TypeCast(cast),
                        span
                    )
                }
                Is => {
                    .index++
                    let parsed_type = .parse_typename()
                    let span = merge_spans(start, .current().span())
                    mut bindings: [EnumVariantPatternArgument] = []
                    mut unary_operator_is: ParsedExpression? = None
                    if .current() is LParen and ((parsed_type is NamespacedName) or (parsed_type is Name)) {
                        bindings = .parse_variant_arguments()
                        unary_operator_is = ParsedExpression::UnaryOp(expr: result, op: UnaryOperator::IsEnumVariant(inner: parsed_type, bindings), span)
                    } else {
                        unary_operator_is = ParsedExpression::UnaryOp(expr: result, op: UnaryOperator::Is(parsed_type), span)
                    }
                    yield unary_operator_is!
                }
                ColonColon => .parse_postfix_colon_colon(start, expr: result)
                QuestionMark | Dot => {
                    let is_optional = .current() is QuestionMark
                    if is_optional {
                        .index++
                        if not .current() is Dot {
                            .error("Expected ‘.’ after ‘?’ for optional chaining access", .current().span())
                        }
                    }

                    .index++
                    yield match .current() {
                        Number(prefix, number, suffix, span) => {
                            let numeric_constant = .parse_number(prefix, number, suffix, span)
                            guard numeric_constant is NumericConstant(val) else {
                                .error("Invalid Numeric Constant", span)
                                return expr
                            }

                            // Indexing into a tuple
                            let num = val.to_usize()
                            yield ParsedExpression::IndexedTuple(
                                expr: result
                                index: num
                                is_optional
                                span: merge_spans(start, end: .previous().span()))
                        }
                        Identifier(name) => {
                            // Struct field access or method call
                            .index++
                            yield match .current() {
                                LessThan => {
                                    // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                    let original_index = .index
                                    let existing_errors = .compiler.errors[..].to_array()
                                    .index--
                                    let call = .parse_call()
                                    yield match call.has_value() {
                                        true => ParsedExpression::MethodCall(
                                            expr: result
                                            call: call!
                                            is_optional
                                            span: merge_spans(start, end: .previous().span()))
                                        else => {
                                            .index = original_index
                                            .compiler.errors = existing_errors
                                            yield ParsedExpression::IndexedStruct(
                                                expr: result
                                                field_name: name
                                                is_optional
                                                span: merge_spans(start, end: .current().span()))
                                        }
                                    }
                                }
                                LParen => {
                                    // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                    .index--
                                    let call = .parse_call()
                                    yield ParsedExpression::MethodCall(
                                        expr: result
                                        call: call!
                                        is_optional
                                        span: merge_spans(start, end: .previous().span()))
                                }
                                else => ParsedExpression::IndexedStruct(
                                    expr: result
                                    field_name: name
                                    is_optional
                                    span: merge_spans(start, end: .current().span()))
                            }
                        }
                        LSquare => {
                            // indexing with a comptime name (or number)
                            .index++
                            let index = .parse_expression(allow_assignments: false, allow_newlines: false)
                            if not .current() is RSquare {
                                .error("Expected ‘]’ to close the index", .current().span())
                            }
                            .index++

                            yield ParsedExpression::ComptimeIndex(
                                expr: result
                                index
                                is_optional
                                span: merge_spans(start, end: .previous().span()))
                        }
                        else => {
                            .error("Unsupported dot operation", .current().span())
                            .index++
                            yield result
                        }
                    }
                }
                LSquare => {
                    // Indexing operation
                    .index++
                    let index_expr = .parse_expression(allow_assignments: false, allow_newlines: true)
                    if .current() is RSquare {
                        .index++
                    } else {
                        .error("Expected ']'", .current().span())
                    }

                    let end = .index - 1
                    yield ParsedExpression::IndexedExpression(
                        base: result,
                        index: index_expr,
                        span: merge_spans(start, .tokens[end].span()))
                }
                else => {
                    break
                }
            }
        }
        return result
    }

    fn parse_postfix_colon_colon(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        .index++
        mut namespace_: [String] = []
        if expr is Var(name) {
            namespace_.push(name)
        } else {
            .error("Expected namespace", expr.span())
        }

        while not .eof() {
            guard .current() is Identifier(name: current_name) else {
                .error("Unsupported static method call", .current().span())
                return expr
            }

            .index++
            if .current() is LParen {
                .index--
                mut call = .parse_call()
                call!.namespace_ = namespace_
                return ParsedExpression::Call(call: call!, span: merge_spans(expr.span(), .current().span()))
            }

            if .current() is LessThan {
                // Generic function arguments
                .index--
                let maybe_call = .parse_call()
                if maybe_call.has_value() {
                    mut call = maybe_call!
                    call.namespace_ = namespace_
                    return ParsedExpression::Call(call, span: merge_spans(expr.span(), .current().span()))
                }
                return ParsedExpression::Garbage(.current().span())
            }

            if .current() is ColonColon {
                if .previous() is Identifier(name) {
                    namespace_.push(name)
                } else {
                    .error("Expected namespace", expr.span())
                }
                .index++
            } else {
                return ParsedExpression::NamespacedVar(
                    name: current_name,
                    namespace_,
                    span: merge_spans(start, .current().span())
                )
            }
        }

        .error("Incomplete static method call", .current().span())
        return expr
    }

    fn parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()

        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            AmpersandAmpersand => {
                .error("‘&&’ is not allowed, use ‘and’ instead", span);
                yield BinaryOperator::LogicalAnd
            }
            Pipe => BinaryOperator::BitwiseOr
            PipePipe => {
                .error("‘||’ is not allowed, use ‘or’ instead", span);
                yield BinaryOperator::LogicalOr
            }
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    fn parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let previous_can_have_trailing_closure = .can_have_trailing_closure
        .can_have_trailing_closure = false
        let expr = .parse_expression(allow_assignments: false, allow_newlines: true)
        .can_have_trailing_closure = previous_can_have_trailing_closure
        let cases = .parse_match_cases()


        if cases.size() > 1 {
            for i in ..(cases.size() - 1) {
                for k in (i + 1)..cases.size() {
                    if cases[i].has_equal_pattern(cases[k]) {
                        .error_with_hint(
                            "Duplicated match pattern", cases[k].marker_span,
                            "Original pattern here", cases[i].marker_span
                        )
                    }
                }
            }
        }

        return ParsedExpression::Match(
            expr
            cases
            span: merge_spans(start, .previous().span())
            marker_span: start
        )
    }

    fn parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let marker_span = .current().span()
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            .skip_newlines()

            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            .skip_newlines()

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false, allow_newlines: true))
            }

            for pattern in patterns {
                cases.push(ParsedMatchCase(patterns: [pattern], marker_span, body))
            }

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }

            .skip_newlines()
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    fn parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            mut pattern = .parse_match_pattern()
            defer patterns.push(pattern)
            mut defaults = pattern.defaults

            .skip_newlines()
            if .current() is Identifier(name) and name == "default" {
                // parse default(var_decl*)
                mut defaults = pattern.defaults
                .index += 1
                if not .current() is LParen {
                    .error(
                        message: "Expected '(' after 'default'",
                        span: .current().span()
                    )
                    continue
                }
                .index += 1

                while not .current() is RParen and not .eof() {
                    let is_mutable = .current() is Mut
                    if is_mutable {
                        .index++
                    }

                    let declaration = .parse_variable_declaration(is_mutable)
                    let value = match .current() {
                        Equal => {
                            .index++
                            yield .parse_expression(allow_assignments: false, allow_newlines: false)
                        }
                        else => {
                            .error("Expected initializer", .current().span())
                            yield ParsedExpression::Garbage(.current().span())
                        }
                    }

                    defaults.set(
                        declaration.name
                        ParsedPatternDefault(
                            variable: declaration
                            value
                        )
                    )
                }

                if .current() is RParen {
                    .index += 1
                } else {
                    .error("Expected a ')' to end 'defaults' list", .current().span())
                }
            }

            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    fn parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | LParen => ParsedMatchPattern::Expression(defaults: [:], .parse_operand())

        Else => {
            .index++

            mut variant_arguments = .parse_variant_arguments()
            let arguments_start = .current().span()
            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::CatchAll(
                defaults: [:]
                variant_arguments
                arguments_span
            )
        }

        Identifier => {
            mut variant_names: [(String, Span)] = []
            mut just_saw_name = false

            while not .eof() {
                .skip_newlines()
                match .current() {
                    Identifier(name) => {
                        if just_saw_name {
                            break
                        }

                        just_saw_name = true

                        .index++
                        variant_names.push((name, .current().span()))
                    }
                    ColonColon => {
                        .index++
                        just_saw_name = false
                    }
                    else => {
                        break
                    }
                }
            }

            mut variant_arguments = .parse_variant_arguments()
            let arguments_start = .current().span()
            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                defaults: [:]
                variant_names
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::Invalid(defaults: [:])
        }
    }

    fn parse_variant_arguments(mut this) throws -> [EnumVariantPatternArgument] {
        mut variant_arguments: [EnumVariantPatternArgument] = []
        mut has_parens = false
        if .current() is LParen {
            has_parens = true
            .index++

            mut is_reference = false
            mut is_mutable = false

            while not .eof() {
                .skip_newlines()
                match .current() {
                    Ampersand => {
                        is_reference = true
                        .index++
                    }
                    Mut => {
                        is_mutable = true
                        .index++
                    }
                    Identifier(name: arg_name) => {
                        let arg_name_span = .current().span()
                        if .peek(1) is Colon {
                            .index += 2
                            if .current() is Identifier(name: arg_binding) {
                                let span = .current().span()
                                .index++
                                variant_arguments.push(EnumVariantPatternArgument(
                                    name: Some(arg_name)
                                    name_span: Some(arg_name_span)
                                    binding: arg_binding
                                    span
                                    is_reference
                                    is_mutable
                                ))
                            } else {
                                .error("Expected binding after ‘:’", .current().span())
                            }
                        } else {
                            variant_arguments.push(EnumVariantPatternArgument(
                                name: None
                                name_span: None
                                binding: arg_name
                                span: .current().span()
                                is_reference
                                is_mutable
                            ))
                            .index++
                        }
                        is_reference = false
                        is_mutable = false
                    }
                    Comma => {
                        .index++
                    }
                    RParen => {
                        .index++
                        break
                    }
                    else => {
                        .error("Expected pattern argument name", .current().span())
                        break
                    }
                }
            }
        }

        return variant_arguments
    }

    fn parse_call(mut this) throws -> ParsedCall? {
        mut call = ParsedCall(
            namespace_: []
            name: ""
            args: []
            type_args: []
        )

        guard .current() is Identifier(name) else {
            .error("Expected function call", .current().span())
            return call
        }

        call.name = name
        .index++

        // This is to allow the lookahead. Without it, we may see something like
        // foo < Bar, and think the start of a generic call when it actually isn't.
        let index_reset = .index

        if .current() is LessThan {
            // Generic type
            .index++
            mut inner_types: [ParsedType] = []

            while not .eof() {
                match .current() {
                    GreaterThan => {
                        .index++
                        break
                    }
                    RightShift => {
                        .inject_token(token: Token::GreaterThan(.current().span()))
                        .index++
                        break
                    }
                    Comma | Eol => {
                        .index++
                    }
                    else => {
                        let index_before = .index
                        let inner_type = .parse_typename()
                        if index_before == .index {
                            // Can't parse further, this is not a generic call.
                            .index = index_reset;
                            break
                        }
                        inner_types.push(inner_type)
                    }
                }
            }

            call.type_args = inner_types
        }

        if .current() is LParen {
            .index++
        } else {
            .index = index_reset
            .error("Expected '('", .current().span())
            return None
        }

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Eol | Comma => {
                    .index++
                }
                else => {
                    let label_span = .current().span()
                    let label = .parse_argument_label()

                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)

                    call.args.push((label, label_span, expr))
                }
            }
        }

        // Look for a possible trailing closure. For now, this has to be a block with no parameters, which captures everything by reference.
        // FIXME: Support explicit captures, and maybe parameters.
        if .can_have_trailing_closure and .current() is LCurly {
            let start = .current().span()
            let block = .parse_block()
            let span = merge_spans(start, .current().span())
            let captures = [ParsedCapture::AllByReference(name: "", span: .empty_span())]
            let trailing_closure = ParsedExpression::Function(captures, params: [], can_throw: false, is_fat_arrow: false, return_type: ParsedType::Empty, block, span)
            let reference_to_closure = ParsedExpression::UnaryOp(expr: trailing_closure, op: UnaryOperator::Reference, span)
            call.args.push(("", .empty_span(), reference_to_closure))
        }

        return call
    }

    fn skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    fn parse_trait_list(mut this) throws -> [ParsedNameWithGenericParameters]? {
        guard .current() is LParen else {
            .error("Expected '(' to start the trait list", .current().span())
            return None
        }
        .index++

        mut result: [ParsedNameWithGenericParameters] = []

        while not .eof() {
            match .current() {
                Eol | Comma => {
                    .index++
                    continue
                }
                Eof(span) => {
                    .error("Expected ')' to close the trait list", span)
                    break
                }
                RParen => {
                    .index++
                    break
                }
                Identifier(name, span) => {
                    mut parsed_name = ParsedNameWithGenericParameters(
                        name
                        name_span: span
                        generic_parameters: []
                    )
                    .index++
                    parsed_name.generic_parameters = .parse_type_parameter_list()
                    result.push(parsed_name)
                }
                else(span) => {
                    .error("Expected trait name", span)
                    break
                }
            }
        }
        if result.is_empty() {
            .error("Expected trait list to have at least one trait inside it",
                .previous().span())
            return None
        } else {
            return Some(result)
        }
    }

    fn parse_generic_parameters(mut this) throws -> [ParsedGenericParameter] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [ParsedGenericParameter] = []
        .skip_newlines()

        mut saw_ending_bracket = false
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    mut requires_list: [ParsedNameWithGenericParameters]? = None

                    .index++
                    if .current() is Requires {
                        .index++
                        requires_list = .parse_trait_list()
                    }

                    generic_parameters.push(ParsedGenericParameter(name, span, requires_list))
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                GreaterThan => {
                    .index++
                    saw_ending_bracket = true
                    break
                }
                RightShift => {
                    .inject_token(token: Token::GreaterThan(.current().span()))
                    .index += 1
                    saw_ending_bracket = true
                    break
                }
                Garbage => {
                    .error("Expected `>` to end the generic parameters", .current().span())
                    return generic_parameters
                }
                else => {
                    .error("Expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if not saw_ending_bracket {
            .error("Expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    fn parse_argument_label(mut this) throws -> String {
        if .peek(1) is Colon and .current() is Identifier(name) {
            .index += 2
            return name
        }
        return ""
    }

    fn parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()

        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
            return Visibility::Restricted(whitelist: [], span: restricted_span)
        }

        mut whitelist: [VisibilityRestriction] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    // Either a plain name, or a namespaced name
                    mut names: [String] = []
                    loop {
                        guard .current() is Identifier(name) else {
                            break
                        }

                        names.push(name)
                        .index++
                        if .current() is ColonColon {
                            .index++
                        } else {
                            break
                        }
                    }
                    if names.is_empty() {
                        .error("Expected identifier", .current().span())
                    } else {
                        let name = names.pop()!
                        whitelist.push(VisibilityRestriction(namespace_: names, name))
                    }
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error_with_hint(
                "Restriction list cannot be empty", restricted_span
                "Did you mean to use ‘private’ instead of ‘restricted’?", restricted_span
            )
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    fn parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    } else {
                        .error("Can't fill an Array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    if expr is Garbage {
                        break
                    }

                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false, allow_newlines: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}
