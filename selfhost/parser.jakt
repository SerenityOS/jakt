// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Charles Mirabile <charlie.mirabile@gmail.com>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause


import error { JaktError, print_error}
import lexer { Token, NumericConstant }
import utility { panic, todo, FileId, Span, extend_array, join }
import compiler { Compiler }

function merge_spans(anon start: Span, anon end: Span) throws -> Span {
    if end.file_id.id == 0 and end.start == 0 and end.end == 0 {
        return start
    }

    if start.file_id.id != end.file_id.id {
        panic(
            format("cannot merge spans from two different files ({} and {})", start, end)
        )
    }

    return Span(file_id: start.file_id, start: start.start, end: end.end)
}

enum DefinitionLinkage {
    Internal
    External
}

struct ImportName {
    name: String
    span: Span
}

struct ParsedModuleImport {
    module_name: ImportName
    alias_name: ImportName?
    import_list: [ImportName]

    function is_equivalent_to(this, anon other: ParsedModuleImport) -> bool =>
        .module_name.name == other.module_name.name and .has_same_alias_than(other) and .has_same_import_semantics(other)

    // we do this because imports with an empty import list mean a namespaced
    // import
    function has_same_import_semantics(this, anon other: ParsedModuleImport) -> bool =>
        .import_list.is_empty() == other.import_list.is_empty()


    function has_same_alias_than(this, anon other: ParsedModuleImport) -> bool  {
        if .alias_name.has_value() {
            return other.alias_name.has_value() and other.alias_name!.name == .alias_name!.name
        } else {
            return not other.alias_name.has_value()
        }
    }

    function merge_import_list(mut this, anon list: [ImportName]) throws {
        .import_list.add_capacity(list.size())
        // generate a set of the names that exist
        mut name_set: {String} = {}
        for import_ in .import_list.iterator() {
            name_set.add(import_.name)
        }

        for import_ in list.iterator() {
            if not name_set.contains(import_.name) {
                name_set.add(import_.name)
                .import_list.push(import_)
            }
        }
    }
}

struct ParsedExternImport {
    is_c: bool
    assigned_namespace: ParsedNamespace


    function get_path(this) -> String => .assigned_namespace.import_path_if_extern!

    function get_name(this) -> String => .assigned_namespace.name!

    function is_equivalent_to(this, anon other: ParsedExternImport) throws {
        return .is_c and other.is_c and .get_path() == other.get_path() and .get_name() == other.get_name()
    }
}

struct ParsedNamespace {
    name: String?
    name_span: Span?
    functions: [ParsedFunction]
    records: [ParsedRecord]
    namespaces: [ParsedNamespace]
    module_imports: [ParsedModuleImport]
    extern_imports: [ParsedExternImport]
    import_path_if_extern: String?

    function is_equivalent_to(this, anon other: ParsedNamespace) -> bool =>
        .name == other.name and .import_path_if_extern == other.import_path_if_extern

    function add_module_import(mut this, anon import_: ParsedModuleImport) throws {
        for module_import in .module_imports.iterator() {
            if module_import.is_equivalent_to(import_) {
                module_import.merge_import_list(import_.import_list)
                return
            }
        }
        .module_imports.push(import_)
    }

    function add_extern_import(mut this, anon import_: ParsedExternImport) throws {
        for extern_import in .extern_imports.iterator() {
            if extern_import.is_equivalent_to(import_) {
                extern_import.assigned_namespace.merge_with(import_.assigned_namespace)
                return
            }
        }
        .extern_imports.push(import_)
    }

    function add_child_namespace(mut this, anon namespace_: ParsedNamespace) throws {
        for child_namespace in .namespaces.iterator() {
            if child_namespace.is_equivalent_to(namespace_) {
                child_namespace.merge_with(namespace_)
                return
            }
        }
        .namespaces.push(namespace_)
    }

    function merge_with(mut this, anon namespace_: ParsedNamespace) throws {
        extend_array(target: .functions, extend_with: namespace_.functions)
        extend_array(target: .records, extend_with: namespace_.records)

        .module_imports.add_capacity(namespace_.module_imports.size())
        for import_ in namespace_.module_imports.iterator() {
            .add_module_import(import_)
        }

        .extern_imports.add_capacity(namespace_.extern_imports.size())
        for import_ in namespace_.extern_imports.iterator() {
            .add_extern_import(import_)
        }

        for child_namespace in namespace_.namespaces.iterator() {
            .add_child_namespace(child_namespace)
        }
    }
}


struct ValueEnumVariant {
    name: String
    span: Span
    value: ParsedExpression?
}
struct SumEnumVariant {
    name: String
    span: Span
    params: [ParsedVarDecl]?
}
enum RecordType {
    Struct(fields: [ParsedField], super_type: ParsedType?)
    Class(fields: [ParsedField], super_type: ParsedType?)
    ValueEnum(underlying_type: ParsedType, variants: [ValueEnumVariant])
    SumEnum(is_boxed: bool, variants: [SumEnumVariant])
    Garbage

    public function record_type_name(this) => match this {
        Struct => "struct"
        Class => "class"
        ValueEnum => "value enum"
        SumEnum => "sum enum"
        Garbage => "<garbage record type>"
    }
}
struct ParsedRecord {
    name: String
    name_span: Span
    generic_parameters: [ParsedGenericParameter]
    definition_linkage: DefinitionLinkage
    methods: [ParsedMethod]
    record_type: RecordType
}

enum FunctionType {
    Normal
    ImplicitConstructor
    ImplicitEnumConstructor
    ExternalClassConstructor
}

struct ParsedFunction {
    name: String
    name_span: Span
    visibility: Visibility
    params: [ParsedParameter]
    generic_parameters: [ParsedGenericParameter]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: Span
    can_throw: bool
    type: FunctionType
    linkage: FunctionLinkage
    must_instantiate: bool
    is_comptime: bool
    is_fat_arrow: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    default_argument: ParsedExpression?
    span: Span

    function equals(this, anon rhs_param: ParsedParameter) -> bool {
        guard .requires_label == rhs_param.requires_label and .variable.equals(rhs_param.variable) else {
            return false
        }

        if .default_argument.has_value() and rhs_param.default_argument.has_value() {
            return .default_argument!.equals(rhs_param.default_argument!)
        }

        return not .default_argument.has_value() and not rhs_param.default_argument.has_value()
    }
}

struct ParsedGenericParameter {
    name: String
    span: Span
}

struct ParsedBlock {
    stmts: [ParsedStatement]

    function equals(this, anon rhs_block: ParsedBlock) -> bool {
        if .stmts.size() != rhs_block.stmts.size() {
            return false
        }

        for x in 0..(.stmts.size()) {
            if not .stmts[x].equals(rhs_block.stmts[x]) {
                return false
            }
        }
        return true
    }

    function find_yield_span(this) -> Span? {
        for stmt in .stmts.iterator() {
            if stmt is Yield(expr) {
                return expr.span()
            }
        }
        return None
    }

    function find_yield_keyword_span(this) -> Span? {
        for stmt in .stmts.iterator() {
            if stmt is Yield(expr) {
                return stmt.span()
            }
        }
        return None
    }

    function span(this, parser: Parser) throws -> Span? {
        mut start: usize? = None
        mut end: usize = 0

        for stmt in .stmts.iterator() {
            let stmt_span = stmt.span()
            if not start.has_value() {
                start = stmt_span.start
            }
            end = stmt_span.end
        }

        if start.has_value() {
            return parser.span(start: start!, end)
        }

        return None
    }
}

boxed enum ParsedStatement {
    Expression(expr: ParsedExpression, span: Span)
    Defer(statement: ParsedStatement, span: Span)
    UnsafeBlock(block: ParsedBlock, span: Span)
    DestructuringAssignment(vars: [ParsedVarDecl], var_decl: ParsedStatement, span: Span)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression, span: Span)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, span: Span)
    Block(block: ParsedBlock, span: Span)
    Loop(block: ParsedBlock, span: Span)
    While(condition: ParsedExpression, block: ParsedBlock, span: Span)
    For(iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock, span: Span)
    Break(Span)
    Continue(Span)
    Return(expr: ParsedExpression?, span: Span)
    Throw(expr: ParsedExpression, span: Span)
    Yield(expr: ParsedExpression, span: Span)
    InlineCpp(block: ParsedBlock, span: Span)
    Guard(expr: ParsedExpression, else_block: ParsedBlock, remaining_code: ParsedBlock, span: Span)
    Garbage(Span)

    function equals(this, anon rhs_statement: ParsedStatement) -> bool => match this {
        Expression(expr: lhs_expr) => match rhs_statement {
            Expression(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Defer(statement: lhs_statement) => match rhs_statement {
            Defer(statement: rhs_statement) => lhs_statement.equals(rhs_statement)
            else => false
        }
        UnsafeBlock(block: lhs_block) => match rhs_statement {
            UnsafeBlock(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        VarDecl(var: lhs_var, init: lhs_init) => match rhs_statement {
            VarDecl(var: rhs_var, init: rhs_init) => lhs_var.equals(rhs_var) and lhs_init.equals(rhs_init)
            else => false
        }
        DestructuringAssignment(vars: lhs_vars, var_decl: lhs_var_decl) => match rhs_statement {
            DestructuringAssignment(vars: rhs_vars, var_decl: rhs_var_decl) => {
                if lhs_vars.size() != rhs_vars.size() {
                    return false
                }
                for i in 0..lhs_vars.size() {
                    if not lhs_vars[i].equals(rhs_vars[i]) {
                        return false
                    }
                }

                if not lhs_var_decl.equals(rhs_var_decl) {
                    return false
                }

                return true
            }
            else => false
        }
        If(condition: lhs_condition, then_block: lhs_then_block, else_statement: lhs_else_statement) => match rhs_statement {
            If(condition: rhs_condition, then_block: rhs_then_block, else_statement: rhs_else_statement) => {
                if not (lhs_condition.equals(rhs_condition) and lhs_then_block.equals(rhs_then_block)) {
                    return false
                }
                if not lhs_else_statement.has_value() {
                    return not rhs_else_statement.has_value()
                } else {
                    if not rhs_else_statement.has_value() {
                        return false
                    }
                    if lhs_else_statement!.equals(rhs_else_statement!) {
                        return true
                    }
                    return false
                }
            }
            else => false
        }
        Block(block: lhs_block) => match rhs_statement {
            Block(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        Loop(block: lhs_block) => match rhs_statement {
            Loop(block: rhs_block) => lhs_block.equals(rhs_block)
            else => false
        }
        While(condition: lhs_condition, block: lhs_block) => match rhs_statement {
            While(condition: rhs_condition, block: rhs_block) => lhs_condition.equals(rhs_condition) and lhs_block.equals(rhs_block)
            else => false
        }
        For(iterator_name: lhs_iterator_name, range: lhs_range, block: lhs_block) => match rhs_statement {
            For(iterator_name: rhs_iterator_name, range: rhs_range, block: rhs_block) => {
                yield lhs_iterator_name == rhs_iterator_name and lhs_range.equals(rhs_range) and lhs_block.equals(rhs_block)
            }
            else => false
        }
        Break => rhs_statement is Break
        Continue => rhs_statement is Continue
        Return(expr: lhs_expr) => match rhs_statement {
            Return(expr: rhs_expr) => {
                if not lhs_expr.has_value() {
                    return not rhs_expr.has_value()
                } else {
                    if not rhs_expr.has_value() {
                        return false
                    }
                    if lhs_expr!.equals(rhs_expr!) {
                        return true
                    }
                    return false
                }
            }
            else => false
        }
        Throw(expr: lhs_expr) => match rhs_statement {
            Throw(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Yield(expr: lhs_expr) =>  match rhs_statement {
            Yield(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        InlineCpp(block: lhs_block) =>  match rhs_statement {
            InlineCpp(block) => lhs_block.equals(block)
            else => false
        }
        Guard(expr: lhs_expr, else_block: lhs_else_block) => match rhs_statement {
            Guard(expr: rhs_expr, else_block: rhs_else_block) => lhs_expr.equals(rhs_expr) and lhs_else_block.equals(rhs_else_block)
            else => false
        }
        Garbage => rhs_statement is Garbage
    }

    function span(this) -> Span => match this {
        Expression(span) => span
        Defer(span) => span
        UnsafeBlock(span) => span
        DestructuringAssignment(span) => span
        VarDecl(span) => span
        If(span) => span
        Block(span) => span
        Loop(span) => span
        While(span) => span
        For(span) => span
        Break(span) => span
        Continue(span) => span
        Return(span) => span
        Throw(span) => span
        Yield(span) => span
        InlineCpp(span) => span
        Guard(span) => span
        Garbage(span) => span
    }
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function equals(this, anon rhs_op: BinaryOperator) -> bool => match this {
        Add => rhs_op is Add
        Subtract => rhs_op is Subtract
        Multiply => rhs_op is Multiply
        Divide => rhs_op is Divide
        Modulo => rhs_op is Modulo
        LessThan => rhs_op is LessThan
        LessThanOrEqual => rhs_op is LessThanOrEqual
        GreaterThan => rhs_op is GreaterThan
        GreaterThanOrEqual => rhs_op is GreaterThanOrEqual
        Equal => rhs_op is Equal
        NotEqual => rhs_op is NotEqual
        BitwiseAnd => rhs_op is BitwiseAnd
        BitwiseXor => rhs_op is BitwiseXor
        BitwiseOr => rhs_op is BitwiseOr
        BitwiseLeftShift => rhs_op is BitwiseLeftShift
        BitwiseRightShift => rhs_op is BitwiseRightShift
        ArithmeticLeftShift => rhs_op is ArithmeticLeftShift
        ArithmeticRightShift => rhs_op is ArithmeticRightShift
        LogicalOr => rhs_op is LogicalOr
        LogicalAnd => rhs_op is LogicalAnd
        NoneCoalescing => rhs_op is NoneCoalescing
        Assign => rhs_op is Assign
        BitwiseAndAssign => rhs_op is BitwiseAndAssign
        BitwiseOrAssign => rhs_op is BitwiseOrAssign
        BitwiseXorAssign => rhs_op is BitwiseXorAssign
        BitwiseLeftShiftAssign => rhs_op is BitwiseLeftShiftAssign
        BitwiseRightShiftAssign => rhs_op is BitwiseRightShiftAssign
        AddAssign => rhs_op is AddAssign
        SubtractAssign => rhs_op is SubtractAssign
        MultiplyAssign => rhs_op is MultiplyAssign
        ModuloAssign => rhs_op is ModuloAssign
        DivideAssign => rhs_op is DivideAssign
        NoneCoalescingAssign => rhs_op is NoneCoalescingAssign
        Garbage => rhs_op is Garbage
    }

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum TypeCast {
    Fallible(ParsedType)
    Infallible(ParsedType)

    function parsed_type(this) -> ParsedType => match this {
        Fallible(parsed_type) => parsed_type
        Infallible(parsed_type) => parsed_type
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    Reference
    MutableReference
    LogicalNot
    BitwiseNot
    TypeCast(TypeCast)
    Is(ParsedType)
    IsEnumVariant(inner: ParsedType, bindings: [EnumVariantPatternArgument])

    function equals(this, anon rhs_op: UnaryOperator) -> bool => match this {
        PreIncrement => rhs_op is PreIncrement
        PostIncrement =>  rhs_op is PostIncrement
        PreDecrement => rhs_op is PreDecrement
        PostDecrement => rhs_op is PostDecrement
        Negate => rhs_op is Negate
        Dereference => rhs_op is Dereference
        RawAddress => rhs_op is RawAddress
        Reference => rhs_op is Reference
        MutableReference => rhs_op is MutableReference
        LogicalNot => rhs_op is LogicalNot
        BitwiseNot => rhs_op is BitwiseNot
        TypeCast(lhs_type_cast) => match rhs_op {
            TypeCast(rhs_type_cast) => lhs_type_cast.parsed_type().equals(rhs_type_cast.parsed_type())
            else => false
        }
        Is(lhs_type) => match rhs_op {
            Is(rhs_type) => lhs_type.equals(rhs_type)
            else => false
        }
        IsEnumVariant(inner: lhs_inner_type, bindings: lhs_bindings) => match rhs_op {
            IsEnumVariant(inner: rhs_inner_type, bindings: rhs_bindings) => {
                mut equal = false
                if lhs_inner_type.equals(rhs_inner_type) and lhs_bindings.size() == rhs_bindings.size() {
                    mut bindings_equal = true
                    for i in ..lhs_bindings.size() {
                        if not lhs_bindings[i].equals(rhs_bindings[i]) {
                            bindings_equal = false
                            break
                        }
                    }

                    if bindings_equal {
                        equal = true
                    }
                }

                yield equal
            }
            else => false
        }
    }
}

struct EnumVariantPatternArgument {
    name: String?
    binding: String
    span: Span

    function equals(this, anon rhs_variant_pattern_argument: EnumVariantPatternArgument) -> bool {
        if .binding != rhs_variant_pattern_argument.binding {
            return false
        }

        if .name.has_value() and rhs_variant_pattern_argument.name.has_value() {
            return .name! == rhs_variant_pattern_argument.name!
        }

        return not .name.has_value() and not rhs_variant_pattern_argument.name.has_value()
    }
}

enum ParsedMatchPattern {
    EnumVariant(
        variant_names: [(String, Span)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Expression(ParsedExpression)
    CatchAll

    function equals(this, anon rhs_parsed_match_pattern: ParsedMatchPattern) -> bool => match this {
        EnumVariant(variant_names: lhs_variant_names, variant_arguments: lhs_variant_arguments) => match rhs_parsed_match_pattern {
            EnumVariant(variant_names: rhs_variant_names, variant_arguments: rhs_variant_arguments) => {
                guard lhs_variant_names.size() == rhs_variant_names.size() and lhs_variant_arguments.size() == rhs_variant_arguments.size() else {
                    return false
                }

                for i in ..lhs_variant_names.size() {
                    if lhs_variant_names[i].0 != rhs_variant_names[i].0 {
                        return false
                    }
                }

                for i in ..lhs_variant_arguments.size() {
                    if not lhs_variant_arguments[i].equals(rhs_variant_arguments[i]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        Expression(lhs_parsed_expression) => match rhs_parsed_match_pattern {
            Expression(rhs_parsed_expression) => lhs_parsed_expression.equals(rhs_parsed_expression)
            else => false
        }
        CatchAll => rhs_parsed_match_pattern is CatchAll
    }
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: Span
    body: ParsedMatchBody

    function equals(this, anon rhs_match_case: ParsedMatchCase) -> bool {
        guard .patterns.size() == rhs_match_case.patterns.size() else {
            return false
        }

        for i in ..(.patterns.size()) {
            if not .patterns[i].equals(rhs_match_case.patterns[i]) {
                return false
            }
        }

        return true
    }
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)
}

enum ParsedCapture {
    ByValue(name: String, span: Span)
    ByReference(name: String, span: Span)
    ByMutableReference(name: String, span: Span)

    function name(this) => match this {
        ByValue(name) => name
        ByReference(name) => name
        ByMutableReference(name) => name
    }

    function span(this) => match this {
        ByValue(span) => span
        ByReference(span) => span
        ByMutableReference(span) => span
    }
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: NumericConstant, span: Span)
    QuotedString(val: String, span: Span)
    SingleQuotedString(val: String, span: Span)
    SingleQuotedByteString(val: String, span: Span)
    Call(call: ParsedCall, span: Span)
    MethodCall(expr: ParsedExpression, call: ParsedCall, is_optional: bool, span: Span)
    IndexedTuple(expr: ParsedExpression, index: usize, is_optional: bool, span: Span)
    IndexedStruct(expr: ParsedExpression, field: String, is_optional: bool, span: Span)
    Var(name: String, span: Span)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: Span)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: Span)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: Span)
    Operator(op: BinaryOperator, span: Span)
    OptionalSome(expr: ParsedExpression, span: Span)
    OptionalNone(Span)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: Span)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: Span)
    Set(values: [ParsedExpression], span: Span)
    JaktTuple(values: [ParsedExpression], span: Span)
    Range(from: ParsedExpression?, to: ParsedExpression?, span: Span)
    ForcedUnwrap(expr: ParsedExpression, span: Span)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: Span)
    EnumVariantArg(expr: ParsedExpression, arg: EnumVariantPatternArgument, enum_variant: ParsedType, span: Span)
    NamespacedVar(name: String, namespace_: [String], span: Span)
    Function(captures: [ParsedCapture], params: [ParsedParameter], can_throw: bool, return_type: ParsedType, block: ParsedBlock, span: Span)
    Try(expr: ParsedExpression, catch_block: ParsedBlock?, catch_name: String?, span: Span)
    TryBlock(stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, span: Span)
    Garbage(Span)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        SingleQuotedString(val, span) => span
        SingleQuotedByteString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        Set(span) => span
        JaktTuple(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        Match(expr, cases, span) => span
        EnumVariantArg(span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
        NamespacedVar(name, namespace_, span) => span
        Function(span) => span
        Try(span) => span
        TryBlock(span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }

    function equals(this, anon rhs_expression: ParsedExpression) -> bool => match this {
        Boolean(val: lhs_val) => match rhs_expression {
            Boolean(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        NumericConstant(val: lhs_val) => match rhs_expression {
            NumericConstant(val: rhs_val) => lhs_val.to_usize() == rhs_val.to_usize()
            else => false
        }
        QuotedString(val: lhs_val) => match rhs_expression {
            QuotedString(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        SingleQuotedString(val: lhs_val) => match rhs_expression {
            SingleQuotedString(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        SingleQuotedByteString(val: lhs_val) => match rhs_expression {
            SingleQuotedByteString(val: rhs_val) => lhs_val == rhs_val
            else => false
        }
        Call(call: lhs_call) => match rhs_expression {
            Call(call: rhs_call) => lhs_call.equals(rhs_call)
            else => false
        }
        MethodCall(expr: lhs_expr, call: lhs_call, is_optional: lhs_optional) => match rhs_expression {
            MethodCall(expr: rhs_expr, call: rhs_call, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_call.equals(rhs_call)
            else => false
        }
        IndexedTuple(expr: lhs_expr, index: lhs_index, is_optional: lhs_optional) => match rhs_expression {
            IndexedTuple(expr: rhs_expr, index: rhs_index, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_index == rhs_index
            else => false
        }
        IndexedStruct(expr: lhs_expr, field: lhs_field, is_optional: lhs_optional) => match rhs_expression {
            IndexedStruct(expr: rhs_expr, field: rhs_field, is_optional: rhs_optional) => lhs_optional == rhs_optional and lhs_expr.equals(rhs_expr) and lhs_field == rhs_field
            else => false
        }
        Var(name: lhs_name) => match rhs_expression {
            Var(name: rhs_name) => lhs_name == rhs_name
            else => false
        }
        IndexedExpression(base: lhs_base, index: lhs_index) => match rhs_expression {
            IndexedExpression(base: rhs_base, index: rhs_index) => lhs_base.equals(, rhs_base) and lhs_index.equals(rhs_index)
            else => false
        }
        UnaryOp(expr: lhs_expr, op: lhs_op) => match rhs_expression {
            UnaryOp(expr: rhs_expr, op: rhs_op) => lhs_expr.equals(rhs_expr) and lhs_op.equals(rhs_op)
            else => false
        }
        BinaryOp(lhs: lhs_lhs, op: lhs_op, rhs: lhs_rhs) => match rhs_expression {
            BinaryOp(lhs: rhs_lhs, op: rhs_op, rhs: rhs_rhs) => lhs_lhs.equals(rhs_lhs) and lhs_op.equals(rhs_op) and lhs_rhs.equals(rhs_rhs)
            else => false
        }
        Operator(op: lhs_op) => match rhs_expression {
            Operator(op: rhs_op) => lhs_op.equals(rhs_op)
            else => false
        }
        OptionalSome(expr: lhs_expr) => match rhs_expression {
            OptionalSome(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        OptionalNone => rhs_expression is OptionalNone
        JaktArray(values: lhs_values, fill_size: lhs_fill_size) => match rhs_expression {
            JaktArray(values: rhs_values, fill_size: rhs_fill_size) => {
                if not lhs_fill_size.has_value() {
                    if rhs_fill_size.has_value() {
                        return false
                    }
                } else {
                    if not rhs_fill_size.has_value() {
                        return false
                    }
                    if not lhs_fill_size!.equals(rhs_fill_size!) {
                        return false
                    }
                }
                if not lhs_values.size() == rhs_values.size() {
                    return false
                }

                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        JaktDictionary(values: lhs_values) => match rhs_expression {
            JaktDictionary(values: rhs_values) => {
                if not lhs_values.size() == rhs_values.size() {
                    return false
                }
                for i in 0..lhs_values.size() {
                    if not (lhs_values[i].0.equals(rhs_values[i].0) and lhs_values[i].1.equals(rhs_values[i].1)) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        Set(values: lhs_values) => match rhs_expression {
            Set(values: rhs_values) => {
                if not lhs_values.size() == rhs_values.size() {
                    return false
                }
                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        JaktTuple(values: lhs_values) => match rhs_expression {
            JaktTuple(values: rhs_values) => {
                if not lhs_values.size() == rhs_values.size() {
                    return false
                }
                for i in 0..lhs_values.size() {
                    if not lhs_values[i].equals(rhs_values[i]) {
                        return false
                    }
                }
                yield true
            }
            else => false
        }
        Range(from: lhs_from, to: lhs_to) => match rhs_expression {
            Range(from: rhs_from, to: rhs_to) => {
                mut equal = false
                if lhs_from.has_value() == rhs_from.has_value() and lhs_to.has_value() == rhs_to.has_value() {
                    if lhs_from.has_value() and lhs_to.has_value() {
                        equal = lhs_from!.equals(rhs_from!) and lhs_to!.equals(rhs_to!)
                    } else {
                        equal = true;
                    }
                }

                yield equal
            }
            else => false
        }
        ForcedUnwrap(expr: lhs_expr) => match rhs_expression {
            ForcedUnwrap(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        Match(expr: lhs_expr, cases: lhs_cases) => match rhs_expression {
            Match(expr: rhs_expr, cases: rhs_cases) => {
                guard lhs_expr.equals(rhs_expr) and lhs_cases.size() == rhs_cases.size() else {
                    return false
                }

                // FIXME: cases should probably be sorted before being compared
                for i in ..lhs_cases.size() {
                    if not lhs_cases[i].equals(rhs_cases[i]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        EnumVariantArg(expr: lhs_expr) => match rhs_expression {
            EnumVariantArg(expr: rhs_expr) => lhs_expr.equals(rhs_expr)
            else => false
        }
        NamespacedVar(name: lhs_name, namespace_: lhs_namespace) => match rhs_expression {
            NamespacedVar(name: rhs_name, namespace_: rhs_namespace) => {
                if lhs_namespace.size() != rhs_namespace.size() {
                    return false
                }
                for i in 0..lhs_namespace.size() {
                    if lhs_namespace[i] != rhs_namespace[i] {
                        return false
                    }
                }
                yield lhs_name == rhs_name
            }
            else => false
        }
        Try(expr: lhs_expr, catch_block: lhs_catch_block) => match rhs_expression {
            Try(expr: rhs_expr, catch_block: rhs_catch_block) => {
                mut equals = lhs_expr.equals(rhs_expr)
                if equals {
                    if lhs_catch_block.has_value() {
                        if rhs_catch_block.has_value() {
                            equals = lhs_catch_block!.equals(rhs_catch_block!)
                        } else {
                            equals = false
                        }
                    } else {
                        equals = not rhs_catch_block.has_value()
                    }
                }
                yield equals
            }
            else => false
        }
        TryBlock(stmt: lhs_stmt, error_name: lhs_error_name, catch_block: lhs_catch_block) => match rhs_expression {
            TryBlock(stmt: rhs_stmt, error_name: rhs_error_name, catch_block: rhs_catch_block) => lhs_stmt.equals(rhs_stmt) and (lhs_error_name == rhs_error_name) and lhs_catch_block.equals(rhs_catch_block)
            else => false
        }
        Function(captures: lhs_captures, params: lhs_params, can_throw: lsh_can_throw, return_type: lhs_return_type) => match rhs_expression {
            Function(captures: rhs_captures, params: rhs_params, can_throw: rsh_can_throw, return_type: rhs_return_type) => {
                guard lhs_return_type.equals(rhs_return_type) and 
                    lsh_can_throw == rsh_can_throw and
                    lhs_captures.size() == rhs_captures.size() and
                    lhs_params.size() == rhs_params.size() else {
                    return false
                }

                for i in ..lhs_captures.size() {
                    if not (lhs_captures[i].name() == rhs_captures[i].name()) {
                        return false
                    }
                }

                for i in ..lhs_params.size() {
                    if not lhs_params[i].equals(rhs_params[i]) {
                        return false
                    }
                }

                return true
            }
            else => false
        }
        Garbage => rhs_expression is Garbage
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    inlay_span: Span?
    span: Span

    function equals(this, anon rhs_var_decl: ParsedVarDecl) -> bool {
        return .name == rhs_var_decl.name and .is_mutable == rhs_var_decl.is_mutable
    }
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
    is_virtual: bool
    is_override: bool
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span

    function equals(this, anon rhs_parsed_varible: ParsedVariable) -> bool {
        return .name == rhs_parsed_varible.name and 
        .parsed_type.equals(rhs_parsed_varible.parsed_type) and 
        .is_mutable ==  rhs_parsed_varible.is_mutable
    }
}

struct ParsedCall {
    namespace_: [String]
    name: String
    args: [(String, Span, ParsedExpression)]
    type_args: [ParsedType]

    function equals(this, anon rhs_parsed_call: ParsedCall) -> bool {
        if .name != rhs_parsed_call.name {
            return false
        }
        if .args.size() != rhs_parsed_call.args.size() {
            return false
        }
        for i in 0..(.args.size()) {
            let (lhs_str, _, lhs_expr) = .args[i]
            let (rhs_str, __, rhs_expr) = rhs_parsed_call.args[i]
            if (lhs_str != rhs_str) or (not lhs_expr.equals(rhs_expr)) {
                return false
            }
        }
        return true
    }
}

boxed enum ParsedType {
    Name(name: String, span: Span)
    NamespacedName(name: String, namespaces: [String], params: [ParsedType], span: Span)
    GenericType(name: String, generic_parameters: [ParsedType], span: Span)
    JaktArray(inner: ParsedType, span: Span)
    Dictionary(key: ParsedType, value: ParsedType, span: Span)
    JaktTuple(types: [ParsedType], span: Span)
    Set(inner: ParsedType, span: Span)
    Optional(inner: ParsedType, span: Span)
    Reference(inner: ParsedType, span: Span)
    MutableReference(inner: ParsedType, span: Span)
    RawPtr(inner: ParsedType, span: Span)
    WeakPtr(inner: ParsedType, span: Span)
    Function(params: [ParsedParameter], can_throw: bool, return_type: ParsedType, span: Span)
    Empty

    function span(this) => match this {
        Name(name, span) => span
        NamespacedName(name, namespaces, params, span) => span
        GenericType(name, generic_parameters, span) => span
        JaktArray(inner, span) => span
        Dictionary(key, value, span) => span
        JaktTuple(types, span) => span
        Set(inner, span) => span
        Optional(inner, span) => span
        Reference(span) => span
        MutableReference(span) => span
        RawPtr(inner, span) => span
        WeakPtr(inner, span) => span
        Function(span) => span
        Empty => Span(file_id: FileId(id: 0uz), start: 0, end: 0) // FIXME: For some reason we can't see `empty_span()` here.
    }

    function equals(this, anon rhs_parsed_type: ParsedType) -> bool => match this {
        Name => rhs_parsed_type is Name
        NamespacedName => rhs_parsed_type is NamespacedName
        GenericType => rhs_parsed_type is GenericType
        JaktArray => rhs_parsed_type is JaktArray
        Dictionary => rhs_parsed_type is Dictionary
        JaktTuple => rhs_parsed_type is JaktTuple
        Set => rhs_parsed_type is Set
        Optional => rhs_parsed_type is Optional
        Reference => rhs_parsed_type is Reference
        MutableReference => rhs_parsed_type is MutableReference
        RawPtr => rhs_parsed_type is RawPtr
        WeakPtr => rhs_parsed_type is WeakPtr
        Function => rhs_parsed_type is Function
        Empty => rhs_parsed_type is Empty
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: Span)
}

struct Parser {
    index: usize
    tokens: [Token]
    compiler: Compiler

    function parse(compiler: Compiler, tokens: [Token]) throws -> ParsedNamespace {
        mut parser = Parser(index: 0, tokens, compiler)
        return parser.parse_namespace()
    }

    function span(this, start: usize, end: usize) -> Span {
        return Span(file_id: .compiler.current_file!, start, end)
    }

    function empty_span(this) => .span(start: 0, end: 0)

    function error(mut this, anon message: String, anon span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::Message(message, span))
        }
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
        }
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens.last()!
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(.span(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mut this) throws -> ParsedNamespace {
        mut parsed_namespace = ParsedNamespace(
            name: None
            name_span: None
            functions: []
            records: []
            namespaces: []
            module_imports: []
            extern_imports: []
            import_path_if_extern: None
        )

        while not .eof() {
            match .current() {
                Import => {
                    .index++
                    .parse_import(parent: &mut parsed_namespace)
                }
                Function | Comptime => {
                    let parsed_function = .parse_function(FunctionLinkage::Internal, Visibility::Public, is_comptime: .current() is Comptime)
                    parsed_namespace.functions.push(parsed_function)
                }
                Struct | Class | Enum | Boxed => {
                    let parsed_record = .parse_record(DefinitionLinkage::Internal)
                    parsed_namespace.records.push(parsed_record)
                }
                Namespace => {
                    .index++
                    let name: (String, Span)? = match .current() {
                        Identifier(name, span) => {
                            .index++
                            yield Some((name, span))
                        }
                        else => None
                    }
                    if .current() is LCurly {
                        .index++
                    } else {
                        .error("Expected ‘{’", .current().span())
                    }
                    mut namespace_ = .parse_namespace()
                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Incomplete namespace", .previous().span())
                    }
                    if name.has_value() {
                        namespace_.name = name!.0
                        namespace_.name_span = name!.1
                    }
                    parsed_namespace.add_child_namespace(namespace_)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External, Visibility::Public, is_comptime: false)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_struct)
                        }
                        Class => {
                            let parsed_class = .parse_class(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_class)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unexpected token (expected keyword)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    function parse_record(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord => match .current() {
        Struct => .parse_struct(definition_linkage)
        Class => .parse_class(definition_linkage)
        Enum => .parse_enum(definition_linkage, is_boxed: false)
        Boxed => {
            .index++
            yield .parse_enum(definition_linkage, is_boxed: true)
        }
        else => {
            .error("Expected `struct`, `class`, `enum`, or `boxed`", .current().span())
            yield ParsedRecord(
                name: "",
                name_span: .empty_span(),
                generic_parameters: [],
                definition_linkage,
                methods: [],
                record_type: RecordType::Garbage
            )
        }
    }

    function parse_import(mut this, parent: &mut ParsedNamespace) throws  {
        // import . <extern <extern-import> | <module-import>>
        if .current() is Extern {
            .index++
            parent.add_extern_import(.parse_extern_import(parent))
        } else {
            parent.add_module_import(.parse_module_import())
        }
    }

    function parse_extern_import(mut this, parent: &mut ParsedNamespace) throws -> ParsedExternImport {
        // import extern . [c] "<path>" [as <alias-name>] namespace
        mut parsed_import = ParsedExternImport(
            is_c: false
            assigned_namespace: ParsedNamespace(
                name: None
                name_span: None
                functions: []
                records: []
                namespaces: []
                module_imports: []
                extern_imports: []
                import_path_if_extern: None))

        
        if .current() is Identifier(name, span) {
            .index++
            if name == "c" or name == "C" {
                parsed_import.is_c = true
            } else {
                .error("Expected 'c' or path after `import extern`"
                       .current().span())
            }
        }

        let import_path = match .current() {
            QuotedString(quote) => {
                .index++
                yield quote
            }
            else => {
                .error("Expected path after `import extern`"
                       .current().span())
                yield ""
            }
        }

        if .current() is As {
            .index++
            if .current() is Identifier(name, span) {
                .index++
                parsed_import.assigned_namespace.name = name
                parsed_import.assigned_namespace.name_span = span
            } else {
                .error("Expected name after 'as' keyword to name the extern import"
                        .current().span())
            }
        }

        if not .current() is LCurly {
            .error("Expected '{' to start namespace for the extern import"
                    .current().span())
        }
        .index++

        parsed_import.assigned_namespace = .parse_namespace()
        parsed_import.assigned_namespace.import_path_if_extern = Some(import_path)
        if .current() is RCurly {
            .index++
        }

        parent.add_child_namespace(parsed_import.assigned_namespace)

        return parsed_import
    }

    function parse_module_import(mut this) throws -> ParsedModuleImport {
        mut parsed_import = ParsedModuleImport(
            module_name: ImportName(name: "", span: .empty_span())
            alias_name: None
            import_list: [])

        parsed_import.module_name = match .current() {
            Identifier(name, span) => ImportName(name, span)
            else => { 
                .error("Expected module name", .current().span())
                return parsed_import
            }
        }
        .index++

        if .eol() {
            return parsed_import
        }

        if .current() is As {
            .index++
            if .current() is Identifier(name, span) {
                .index++
                parsed_import.alias_name = ImportName(name, span)
            } else  {
                .error("Expected name", .current().span())
                .index++
            }
        }

        if .eol() {
            return parsed_import
        }

        if not (.current() is LCurly) {
            .error("Expected '{'", .current().span())
        }
        .index++

        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    parsed_import.import_list.push(ImportName(name, span))
                    .index++
                }
                Comma | Eol => {
                    .index++
                }
                RCurly => {
                    .index++
                    break
                }
                else => {
                    .error("Expected import symbol", .current().span())
                    .index++
                }
            }
        }

        return parsed_import
    }

    function parse_value_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage) throws -> ([ValueEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [ValueEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is Equal {
                        .index += 2
                        let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                        variants.push(ValueEnumVariant(name, span, value: expr))
                    } else {
                        .index++
                        variants.push(ValueEnumVariant(name, span, value: None))
                    }
                }
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function | Comptime => {
                    let is_comptime = .current() is Comptime

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility, is_virtual: false, is_override: false, is_comptime)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if .eof() {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_sum_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ([SumEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [SumEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if not .peek(1) is LParen {
                        .index++
                        variants.push(SumEnumVariant(name, span, params: None))
                        continue
                    }
                    .index += 2

                    mut var_decls: [ParsedVarDecl] = []

                    while not .eof() {
                        if .peek(1) is Colon {
                            mut var_decl = .parse_variable_declaration(is_mutable: false)
                            if var_decl.parsed_type is Name(name, span) {
                                var_decl.inlay_span = span
                                if name == partial_enum.name and not is_boxed{
                                    .error("use 'boxed enum' to make the enum recursive", var_decl.span)
                                }
                            }
                            var_decls.push(var_decl)
                            continue
                        }

                        match .current() {
                            Identifier | LSquare | LCurly => {
                                var_decls.push(ParsedVarDecl(
                                    name: ""
                                    parsed_type: .parse_typename()
                                    is_mutable: false
                                    inlay_span: None
                                    span: .current().span()
                                ))
                            }
                            else => {}
                        }

                        match .current() {
                            RParen => {
                                .index++
                                break
                            }
                            Comma | Eol => {
                                .index++
                            }
                            else => {
                                .error(format("Incomplete enum variant defintion, expected `,` or `)`; got `{}`", .current()), .current().span())
                                break;
                            }
                        }
                    }
                    variants.push(SumEnumVariant(name, span, params: var_decls))
                }
                RCurly => {
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function | Comptime => {
                    let is_comptime = .current() is Comptime

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility, is_virtual: false, is_override: false, is_comptime)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if not .current() is RCurly {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }
        .index++

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_enum(mut this, anon definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ParsedRecord {
        mut parsed_enum = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut underlying_type: ParsedType? = None
        if .current() is Enum {
            .index++
        } else {
            .error("Expected ‘enum’ keyword", .current().span())
            return parsed_enum
        }

        if .eof() {
            .error("Incomplete enum definition, expected name", .current().span())
            return parsed_enum
        }

        if .current() is Identifier(name, span) {
            parsed_enum.name = name
            parsed_enum.name_span = span
            .index++
        } else {
            .error("Incomplete enum definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete enum definition, expected generic parameters or underlying type or body", .current().span())
            return parsed_enum
        }


        if .current() is LessThan {
            parsed_enum.generic_parameters = .parse_generic_parameters()
        }

        if .eof() {
            .error("Incomplete enum definition, expected underlying type or body", .current(). span())
            return parsed_enum
        }

        if .current() is Colon {
            if is_boxed {
                .error("Invalid enum definition: Value enums must not have an underlying type", .current().span())
            }
            .index++
            underlying_type = .parse_typename()
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected body", .current().span())
            return parsed_enum
        }

        if underlying_type.has_value() {
            let (variants, methods) = .parse_value_enum_body(partial_enum: parsed_enum, definition_linkage)
            parsed_enum.methods = methods
            parsed_enum.record_type = RecordType::ValueEnum(
                underlying_type: underlying_type!
                variants
            )
        } else {
            let (variants, methods) = .parse_sum_enum_body(partial_enum: parsed_enum, definition_linkage, is_boxed)
            parsed_enum.methods = methods
            parsed_enum.record_type = RecordType::SumEnum(
                is_boxed: is_boxed,
                variants
            )
        }

        return parsed_enum
    }

    public function parse_struct_class_body(mut this, definition_linkage: DefinitionLinkage, default_visibility: Visibility, is_class: bool) throws -> ([ParsedField],[ParsedMethod]) {
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        mut last_virtual = false
        mut last_override = false

        // Have we already found an error?
        mut error = false;

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    .index++
                    return (fields, methods)
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    if last_virtual or last_override {
                        .error("Fields cannot be ‘virtual’ or ‘override’", .current().span())
                    }
                    last_virtual = false
                    last_override = false

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function | Comptime => {
                    // Parse a method
                    let is_comptime = .current() is Comptime

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    if function_linkage is External and is_comptime {
                        .error("External functions cannot be comptime", .current().span())
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let is_virtual = last_virtual
                    let is_override = last_override
                    last_virtual = false
                    last_override = false

                    let parsed_method = .parse_method(function_linkage, visibility, is_virtual, is_override, is_comptime: .current() is Comptime)

                    methods.push(parsed_method)
                }
                Virtual => {
                    last_virtual = true
                    .index++
                }
                Override => {
                    last_override = true
                    .index++
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error(format("Invalid member, did not expect a {} here", token), token.span())
                        error = true
                    }
                    .index++
                }
            }
        }
        if is_class {
            .error("Incomplete class body, expected ‘}’", .current().span())
        } else {
            .error("Incomplete struct body, expected ‘}’", .current().span())
        }
        return (fields, methods)
    }

    public function parse_struct(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_struct = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        if .current() is Struct {
            .index++
        } else {
            .error("Expected `struct` keyword", .current().span())
            return parsed_struct
        }
        // Struct name
        if .eof() {
            .error("Incomplete struct definition, expected name", .current().span())
            return parsed_struct
        }

        if .current() is Identifier(name, span) {
            .index++
            parsed_struct.name = name
            parsed_struct.name_span = span
        } else {
            .error("Incomplete struct definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete struct definition, expected generic parameters or body", .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        .skip_newlines()

        if .eof() {
            .error("Incomplete struct definition, expected body", .current().span())
            return parsed_struct
        }

        let (fields, methods) = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Public, is_class: false)

        parsed_struct.methods = methods
        let super_type: ParsedType? = None
        parsed_struct.record_type = RecordType::Struct(fields, super_type)

        return parsed_struct
    }

    public function parse_class(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_class = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut super_type: ParsedType? = None
        if .current() is Class {
            .index++
        } else {
            .error("Expected `class` keyword", .current().span())
            return parsed_class
        }
        // Class name
        if .eof() {
            .error("Incomplete class definition, expected name", .current().span())
            return parsed_class
        }

        if .current() is Identifier(name, span) {
            .index++
            parsed_class.name = name
            parsed_class.name_span = span
        } else {
            .error("Incomplete class definition, expected name", .current().span())
        }

        if .eof() {
            .error("Incomplete class definition, expected generic parameters or super class or body", .current().span())
            return parsed_class
        }

        // Generic parameters
        parsed_class.generic_parameters = .parse_generic_parameters()


        if .eof() {
            .error("Incomplete class definition, expected super class or body", .current().span())
            return parsed_class
        }

        // Super class
        if .current() is Colon {
            .index++
            super_type = .parse_typename()
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete class definition, expected body", .current().span())
            return parsed_class
        }

        let (fields, methods) = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Private, is_class: true)

        parsed_class.methods = methods
        parsed_class.record_type = RecordType::Class(fields, super_type)

        return parsed_class
    }

    public function parse_function_parameters(mut this) throws -> [ParsedParameter] {
        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        .skip_newlines()

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        // Have we already found an error?
        mut error = false
        mut parameter_complete = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma | Eol => {
                    if not parameter_complete and not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = true
                    current_param_is_mutable = false
                    parameter_complete = false
                }
                Anon => {
                    if parameter_complete and not error  {
                        .error("‘anon’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘anon’ must appear before ‘mut’", .current().span())
                        error = true
                    }
                    if not current_param_requires_label and not error  {
                        .error("‘anon’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    if parameter_complete and not error  {
                        .error("‘mut’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘mut’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        default_argument: None,
                        span: .current().span(),
                    ))
                    .index++
                    parameter_complete = true
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)

                    mut default_argument: ParsedExpression? = None
                    
                    if .current() is Equal {
                        .index++
                        default_argument = .parse_expression(allow_assignments: false, allow_newlines: true)
                    }

                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        default_argument,
                        span: .previous().span(),
                    ))
                    parameter_complete = true
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                }
            }
        }
        return params
    }

    public function parse_function(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility, is_comptime: bool) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            name: "",
            name_span: .empty_span(),
            visibility,
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: .span(start: 0, end: 0),
            can_throw: false,
            type: FunctionType::Normal,
            linkage,
            must_instantiate: false,
            is_comptime
            is_fat_arrow: false
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        guard .current() is Identifier(name) else {
            return parsed_function
        }
        parsed_function.name = name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        parsed_function.params = .parse_function_parameters()

        // NOTE: main() always throws
        mut can_throw = name == "main"
        if .current() is Throws {
            can_throw = true
            .index++
        }
        parsed_function.can_throw = can_throw

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
            parsed_function.is_fat_arrow = true
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility, is_virtual: bool, is_override: bool, is_comptime: bool) throws -> ParsedMethod {
        mut parsed_function = .parse_function(linkage, visibility, is_comptime)

        if linkage is External {
            parsed_function.must_instantiate = true
        }

        return ParsedMethod(
            parsed_function
            visibility
            is_virtual
            is_override
        )
    }

    function parse_typename(mut this) throws -> ParsedType {
        let start = .current().span()
        mut is_reference = false
        mut is_mutable_reference = false

        if .current() is Ampersand {
            is_reference = true
            .index++
            if .current() is Mut {
                is_mutable_reference = true
                .index++
            }
        }

        mut parsed_type = .parse_type_shorthand()

        if parsed_type is Empty {
            parsed_type = .parse_type_longhand()
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        if is_reference {
            let span = merge_spans(start, .current().span())
            if is_mutable_reference {
                parsed_type = ParsedType::MutableReference(inner: parsed_type, span)
            } else {
                parsed_type = ParsedType::Reference(inner: parsed_type, span)
            }
        }

        return parsed_type
    }

    function parse_type_longhand(mut this) throws -> ParsedType => match .current() {
        Raw => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
            yield match inner {
                Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                else => ParsedType::RawPtr(inner, span)
            }
        }
        Weak => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
            yield match inner {
                Optional(inner) => ParsedType::WeakPtr(inner, span)
                else => {
                    .error("missing `?` after weak pointer type name", span)
                    yield ParsedType::WeakPtr(inner, span)
                }
            }
        }
        Identifier(name) => {
            let span = .current().span()
            .index++
            mut parsed_type =  ParsedType::Name(name, span)
            if .current() is LessThan {
                mut params: [ParsedType] = []
                if .current() is LessThan {
                    .index++
                    while not .current() is GreaterThan and not .eof() {
                        params.push(.parse_typename())
                        if .current() is Comma {
                            .index++
                        }
                    }
                    if .current() is GreaterThan {
                        .index++
                    } else {
                        .error("Expected `>` after type parameters", .current().span())
                    }
                }
                parsed_type = ParsedType::GenericType(name, generic_parameters: params, span)
            }

            if .current() is ColonColon {
                .index++
                mut namespaces: [String] = [name]

                while not .eof() {
                    match .current() {
                        Identifier(name: namespace_name) => {
                            if .previous() is ColonColon {
                                namespaces.push(namespace_name)
                                .index++
                            }
                        }
                        ColonColon => {
                            if .previous() is Identifier {
                                .index++
                            } else {
                                .error("Expected name after", span)
                            }
                        }
                        else => {
                            break
                        }
                    }
                }

                let type_name = namespaces.pop()!

                mut params: [ParsedType] = []
                if .current() is LessThan {
                    .index++
                    while not .current() is GreaterThan and not .eof() {
                        params.push(.parse_typename())
                        if .current() is Comma {
                            .index++
                        }
                    }
                    if .current() is GreaterThan {
                        .index++
                    } else {
                        .error("Expected `>` after type parameters", .current().span())
                    }
                }

                parsed_type = ParsedType::NamespacedName(name: type_name, namespaces, params, span: .previous().span())
            }

            yield parsed_type
        }
        Function => {
            let start = .current().span()
            .index++

            let params = .parse_function_parameters()

            let can_throw = .current() is Throws
            if can_throw {
                .index++
            }

            mut return_type = ParsedType::Empty
            if .current() is Arrow {
                .index++
                return_type = .parse_typename()
            } else {
                .error("Expected '->'", .current().span())
            }

            yield ParsedType::Function(params, can_throw, return_type, span: merge_spans(start, return_type.span()))
        }
        else => {
            .error("Expected type name", .current().span())
            yield ParsedType::Empty
        }
    }

    function parse_destructuring_assignment(mut this, is_mutable: bool) throws -> [ParsedVarDecl] {
        .index++
        mut var_declarations: [ParsedVarDecl] = []

        loop {
            match .current() {
                Identifier => {
                    var_declarations.push(.parse_variable_declaration(is_mutable))
                }
                Comma => {
                    .index++
                }
                RParen => {
                    .index++
                    return var_declarations
                }
                else => {
                    .error("Expected close of destructuring assignment block", .current().span())
                    return []
                }
            }
        }
        
        return []
    }

    function parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        let span = .current().span()

        guard .current() is Identifier(name) else {
            return ParsedVarDecl(
                name: ""
                parsed_type: ParsedType::Empty
                is_mutable: false
                inlay_span: None
                span
            )
        }

        .index++
        if .current() is Colon {
            .index++
        } else {
            return ParsedVarDecl(
                name
                parsed_type: ParsedType::Empty
                is_mutable
                inlay_span: span
                span
            )
        }

        let parsed_type = .parse_typename()
        if is_mutable and (parsed_type is Reference or parsed_type is MutableReference) {
            .error("Reference parameter can not be mutable", span)
        }

        return ParsedVarDecl(
            name
            parsed_type
            is_mutable
            inlay_span: None
            span
        )
    }

    function parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        if .current() is LCurly {
            .index++
        }
        let inner = .parse_typename()
        if .current() is RCurly {
            .index++
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            let index_before = .index
            let type = .parse_typename()
            let index_after = .index
            if index_before == index_after {
                break
            }
            types.push(type)
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", .current().span())
        return block
    }

    function parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                let statement = .parse_statement(inside_block: false)
                yield ParsedStatement::Defer(statement, span: merge_spans(start, .previous().span()))
            }
            Unsafe => {
                .index++
                let block = .parse_block()
                yield ParsedStatement::UnsafeBlock(block, span: merge_spans(start, .previous().span()))
            }
            Break => {
                .index++
                yield ParsedStatement::Break(start)
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue(start)
            }
            Loop => {
                .index++
                let block = .parse_block()
                yield ParsedStatement::Loop(block, span: merge_spans(start, .previous().span()))
            }
            Throw => {
                .index++
                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                yield ParsedStatement::Throw(expr, span: merge_spans(start, .previous().span()))
            }
            While => {
                .index++
                let condition = .parse_expression(allow_assignments: false, allow_newlines: true)
                let block = .parse_block()
                yield ParsedStatement::While(condition, block, span: merge_spans(start, .previous().span()))
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr, span: merge_spans(start, .previous().span()))
            }
            Return => {
                .index++
                yield match .current() {
                    Eol | Eof | RCurly => ParsedStatement::Return(expr: None, span: .current().span())
                    else => ParsedStatement::Return(expr: .parse_expression(allow_assignments: false, allow_newlines: false), span: merge_spans(start, .previous().span()))
                }
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++

                mut vars: [ParsedVarDecl] = []
                mut is_destructuring_assingment = false
                mut tuple_var_name = ""
                mut tuple_var_decl = ParsedVarDecl(
                    name: "",
                    parsed_type: ParsedType::Empty,
                    is_mutable: is_mutable,
                    inlay_span: None,
                    span: .current().span(),
                )

                if .current() is LParen {
                    vars = .parse_destructuring_assignment(is_mutable)
                    for var in vars.iterator() {
                        tuple_var_name += var.name
                        tuple_var_name += "_"
                    }
                    tuple_var_decl.name = tuple_var_name
                    is_destructuring_assingment = true
                } else {
                    tuple_var_decl = .parse_variable_declaration(is_mutable)
                }

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false, allow_newlines: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                mut return_statement = ParsedStatement::VarDecl(var: tuple_var_decl, init, span: merge_spans(start, .previous().span()))

                if is_destructuring_assingment {
                    let old_return_statement = return_statement
                    return_statement = ParsedStatement::DestructuringAssignment(vars, var_decl: old_return_statement, span: merge_spans(start, .previous().span()))
                }
                yield return_statement
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            LCurly => {
                let block = .parse_block()
                yield ParsedStatement::Block(block, span: merge_spans(start, .previous().span()))
            }
            Guard => .parse_guard_statement()
            else => {
                let expr = .parse_expression(allow_assignments: true, allow_newlines: false)
                yield ParsedStatement::Expression(expr, span: merge_spans(start, .previous().span()))
            }
        }
    }

    function parse_guard_statement(mut this) throws -> ParsedStatement {
        let span = .current().span()
        .index++
        let expr = .parse_expression(allow_assignments: false, allow_newlines: true)
        if .current() is Else {
            .index++
        } else {
            .error("Expected `else` keyword", .current().span())
        }
        let else_block = .parse_block()

        mut remaining_code = ParsedBlock(stmts: [])

        while not .eof() {
            match .current() {
                RCurly => {
                    return ParsedStatement::Guard(expr, else_block, remaining_code, span)
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    remaining_code.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        return ParsedStatement::Guard(expr, else_block, remaining_code, span)
    }

    function parse_try_block(mut this) throws -> ParsedExpression {
        let start_span = .current().span()
        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            if .current() is Identifier(name) {
                error_span = .current().span()
                error_name = name
                .index++
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedExpression::TryBlock(stmt, error_name, error_span, catch_block, span: merge_spans(start_span, .previous().span()))
    }

    function parse_for_statement(mut this) throws -> ParsedStatement {
        let start_span = .current().span()
        .index++

        mut iterator_name = ""
        mut destructured_var_decls: [ParsedVarDecl] = []
        
        match .current() {
            Identifier(name) => {
                iterator_name = name
                .index++
            }
            LParen => {
                destructured_var_decls = .parse_destructuring_assignment(is_mutable: false)
                mut tuple_var_name = ""
                for var in destructured_var_decls.iterator() {
                    tuple_var_name += var.name
                    tuple_var_name += "__"
                }
                iterator_name = tuple_var_name
            }
            else => {
                .error("Expected iterator name or destructuring pattern", .current().span())
                return ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
            }
        }

        let name_span = .current().span()
        if .current() is In {
            .index++
        } else {
            .error("Expected ‘in’", .current().span())
            return ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
        }

        let range = .parse_expression(allow_assignments: false, allow_newlines: false)
        mut block = .parse_block();

        if destructured_var_decls.size() > 0 {
            mut tuple_var_name = "jakt__"
            tuple_var_name += iterator_name
            mut tuple_var_decl = ParsedVarDecl(
                name: tuple_var_name,
                parsed_type: ParsedType::Empty,
                is_mutable: false,
                inlay_span: None,
                span: .current().span(),
            )
            let init = ParsedExpression::Var(name: iterator_name, span: merge_spans(start_span, .previous().span()))
            let var_decl = ParsedStatement::VarDecl(var: tuple_var_decl, init, span: merge_spans(start_span, .previous().span()))
            let destructured_vars_stmt = ParsedStatement::DestructuringAssignment(vars: destructured_var_decls, var_decl, span: merge_spans(start_span, .previous().span()))
            mut block_stmts: [ParsedStatement] = []
            block_stmts.push(destructured_vars_stmt)
            for stmt in block.stmts.iterator() {
                block_stmts.push(stmt)
            }
            block.stmts = block_stmts
        }

        return ParsedStatement::For(iterator_name, name_span, range, block, span: merge_spans(start_span, .previous().span()))
    }

    function parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage(span: .current().span())
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false, allow_newlines: true)
        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        .skip_newlines()

        if .current() is Else {
            .index++
            .skip_newlines()
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    let block = .parse_block()
                    if then_block.equals(block) {
                        .error("if and else have identical blocks", .current().span())
                    }
                    else_statement = ParsedStatement::Block(block, span: merge_spans(start_span, .previous().span()))
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement, span: merge_spans(start_span, .previous().span()))
    }

    function parse_expression(mut this, allow_assignments: bool, allow_newlines: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        loop {
            if allow_newlines {
                if .eof() or .current() is LCurly {
                    break
                }
                .skip_newlines()
            } else {
                if .eol() {
                    break
                }
            }

            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = op.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match op {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => {
                        .compiler.panic("operator is not an operator")
                    }
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => {
                    .compiler.panic("operator is not an operator")
                }
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mut this) throws => match .current() {
        Dot(span) => {
            yield ParsedExpression::Var(name: "this", span)
        }
        Try(span) => {
            .index++
            yield match .current() {
                LCurly => .parse_try_block()
                else => {
                    let expression = .parse_expression(allow_assignments: true, allow_newlines: true)
                    mut catch_block: ParsedBlock? = None
                    mut catch_name: String? = None
                    if .current() is Catch {
                        .index++
                        if .current() is Identifier(name) {
                            catch_name = name
                            .index++
                        }
                        catch_block = .parse_block()
                    }
                    yield ParsedExpression::Try(expr: expression, catch_block, catch_name, span)
                }
            }
        }
        QuotedString(quote, span) => {
            .index++
            yield ParsedExpression::QuotedString(val: quote, span)
        }
        SingleQuotedString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedString(val: quote, span)
        }
        SingleQuotedByteString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedByteString(val: quote, span)
        }
        Number(number, span) => {
            .index++
            yield ParsedExpression::NumericConstant(val: number, span)
        }
        True(span) => {
            .index++
            yield ParsedExpression::Boolean(val: true, span)
        }
        False(span) => {
            .index++
            yield ParsedExpression::Boolean(val: false, span)
        }
        This(span) => {
            .index++
            yield ParsedExpression::Var(name: "this", span)
        }
        Not(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
        }
        Tilde(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::BitwiseNot, span)
        }
        Identifier(name, span) => {
            if .peek(1) is LParen {
                if name == "Some" {
                    .index++
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    return ParsedExpression::OptionalSome(expr, span)
                }
                let call = .parse_call()
                return ParsedExpression::Call(call: call!, span)
            }
            if .peek(1) is LessThan {
                // We *try* to see if it's a generic, but the parse errors, we back up and try something else
                .compiler.ignore_parser_errors = true
                let call = .parse_call()
                .compiler.ignore_parser_errors = false
                if not call.has_value() {
                    return match name {
                        "None" => ParsedExpression::OptionalNone(span)
                        else => ParsedExpression::Var(name, span)
                    }
                }
                return ParsedExpression::Call(call: call!, span)
            }
            .index++
            if name == "None" {
                return ParsedExpression::OptionalNone(span)
            }
            yield ParsedExpression::Var(name, span)
        }
        LParen(span) => {
            let start_span = .current().span()
            .index++
            
            mut expr = .parse_expression(allow_assignments: false, allow_newlines: false)

            .skip_newlines()

            match .current() {
                RParen => {
                    .index++
                }
                Comma => {
                    // We have a tuple
                    .index++

                    mut tuple_exprs: [ParsedExpression] = [expr]
                    mut end_span = start_span

                    while not .eof() {
                        match .current() {
                            Eol | Comma => {
                                .index++
                            }
                            RParen => {
                                .index++
                                break
                            }
                            else => {
                                let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                                end_span = expr.span()
                                tuple_exprs.push(expr)
                            }
                        }
                    }

                    if .eof() {
                        .error("Expected ')'", .current().span());
                    }

                    expr = ParsedExpression::JaktTuple(
                        values: tuple_exprs,
                        span: merge_spans(start_span, end_span)
                    )
                }
                else => {
                    .error("Expected ')'", .current().span())
                }
            }

            yield expr
        }
        PlusPlus(span)
        | MinusMinus(span)
        | Minus(span) => {

            let op = match .current() {
                PlusPlus => UnaryOperator::PreIncrement
                MinusMinus => UnaryOperator::PreDecrement
                Minus => UnaryOperator::Negate
                else => {
                    .compiler.panic("unreachable")
                }
            }

            let start = .current().span()
            .index++

            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())

            yield ParsedExpression::UnaryOp(expr, op, span)
        }
        LSquare => {
            yield .parse_array_or_dictionary_literal()
        }
        Match => {
            yield .parse_match_expression()
        }
        LCurly => {
            yield .parse_set_literal()
        }
        Ampersand => .parse_ampersand()
        Asterisk => .parse_asterisk()
        Function => .parse_lambda()
        DotDot => .parse_range()
        else => {
            let span = .current().span()
            .index++
            .error("Unsupported expression", span)
            yield ParsedExpression::Garbage(span)
        }
    }

    function parse_captures(mut this) throws -> [ParsedCapture] {
        mut captures: [ParsedCapture] = []
        guard .current() is LSquare else {
            return []
        }
        .index++
        
        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Ampersand => {
                    .index++
                    match .current() {
                        Mut => {
                            .index++
                            if .current() is Identifier(name) {
                                captures.push(ParsedCapture::ByMutableReference(name, span: .current().span()))
                                .index++
                            } else {
                                .error(format("Expected identifier, got '{}'", .current()), .current().span())
                                .index++
                            }
                        }
                        Identifier(name) => {
                            captures.push(ParsedCapture::ByReference(name, span: .current().span()))
                            .index++
                        }
                        else => {
                            .error(format("Expected identifier or mut, got '{}'", .current()), .current().span())
                            .index++
                        }
                    }
                }
                Identifier(name) => {
                    captures.push(ParsedCapture::ByValue(name, span: .current().span()))
                    .index++
                }
                Comma | Eol => {
                    .index++
                }
                else => {
                    .error(format("Unexpected token '{}' in captures list", .current()), .current().span())
                    .index++
                }
            }
        }

        return captures
    }

    function parse_lambda(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        let captures = .parse_captures()
        let params = .parse_function_parameters()
        let can_throw = .current() is Throws
        if can_throw {
            .index++
        }

        mut return_type = match .current() {
            Arrow => {
                .index++
                yield .parse_typename()
            }
            else => ParsedType::Empty
        }

        let block = match .current() {
            FatArrow => {
                .index++
                let expr = .parse_expression(allow_assignments: true, allow_newlines: false)
                let span = expr.span()
                yield ParsedBlock(stmts: [ParsedStatement::Return(expr, span)])
            }
            else => .parse_block()
        }

        return ParsedExpression::Function(captures, params, can_throw, return_type, block, span: merge_spans(start, .current().span()))
    }

    function parse_asterisk(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        let expr = .parse_operand()
        return ParsedExpression::UnaryOp(expr, op: UnaryOperator::Dereference, span: merge_spans(start, .current().span()))
    }

    function parse_ampersand(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        if .current() is Raw {
            .index++
            let expr = .parse_operand()
            return ParsedExpression::UnaryOp(expr, op: UnaryOperator::RawAddress, span: merge_spans(start, expr.span()))
        }
        if .current() is Mut {
            .index++
            let expr = .parse_operand()
            return ParsedExpression::UnaryOp(expr, op: UnaryOperator::MutableReference, span: merge_spans(start, expr.span()))
        }
        let expr = .parse_operand()
        return ParsedExpression::UnaryOp(expr, op: UnaryOperator::Reference, span: merge_spans(start, expr.span()))
    }

    function parse_range(mut this) throws -> ParsedExpression {
        let start = .current().span()

        .index++

        mut to: ParsedExpression? = None
        match .current() {
            RSquare | Eol | Comma | RParen => {}
            else => {
                to = .parse_expression(allow_assignments: false, allow_newlines: false)
            }
        }
        
        return ParsedExpression::Range(from: None, to, span: merge_spans(start, .current().span()))
    }

    function parse_set_literal(mut this) throws -> ParsedExpression {
        let start = .current().span()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut output: [ParsedExpression] = []
        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    if expr is Garbage {
                        break
                    }

                    output.push(expr)
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RCurly {
            .error("Expected ‘}’ to close the set", .tokens[end].span())
        }

        return ParsedExpression::Set(values: output, span: merge_spans(start, .tokens[end].span()))
    }
    
    function parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()
        return .parse_operand_postfix_operator(start, expr)
    }

    function parse_operand_postfix_operator(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        mut result = expr
        loop {
            result = match .current() {
                DotDot => {
                    .index++

                    mut to: ParsedExpression? = None
                    mut span_end = .current().span()
                    match .current() {
                        RSquare | Eol | Comma | RParen => {}
                        else => {
                            to = .parse_expression(allow_assignments: false, allow_newlines: false)
                            span_end = to!.span()
                        }
                    }

                    yield ParsedExpression::Range(from: result, to, span: merge_spans(start, span_end))
                }
                ExclamationPoint => {
                    .index++
                    yield ParsedExpression::ForcedUnwrap(expr: result, span: merge_spans(start, .previous().span()))
                }
                PlusPlus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostIncrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                MinusMinus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostDecrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                As => {
                    .index++
                    let cast_span = merge_spans(.previous().span(), .current().span())
                    let cast = match .current() {
                        ExclamationPoint => {
                            .index++
                            yield TypeCast::Infallible(.parse_typename())
                        }
                        QuestionMark => {
                            .index++
                            yield TypeCast::Fallible(.parse_typename())
                        }
                        else => {
                            .error_with_hint("Invalid cast syntax", cast_span, "Use `as!` for an infallible cast, or `as?` for a fallible cast", .previous().span())
                            yield TypeCast::Fallible(.parse_typename())
                        }
                    }
                    let span = merge_spans(start, merge_spans(cast_span, .current().span()))
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::TypeCast(cast),
                        span
                    )
                }
                Is => {
                    .index++
                    let parsed_type = .parse_typename()
                    let span = merge_spans(start, .current().span())
                    mut bindings: [EnumVariantPatternArgument] = []
                    mut unary_operator_is: ParsedExpression? = None
                    if .current() is LParen and ((parsed_type is NamespacedName) or (parsed_type is Name)) {
                        bindings = .parse_variant_arguments()
                        unary_operator_is = ParsedExpression::UnaryOp(expr: result, op: UnaryOperator::IsEnumVariant(inner: parsed_type, bindings), span)
                    } else {
                        unary_operator_is = ParsedExpression::UnaryOp(expr: result, op: UnaryOperator::Is(parsed_type), span)
                    }
                    yield unary_operator_is!
                }
                ColonColon => .parse_postfix_colon_colon(start, expr: result)
                QuestionMark | Dot => {
                    let is_optional = .current() is QuestionMark
                    if is_optional {
                        .index++
                        if not .current() is Dot {
                            .error("Expected ‘.’ after ‘?’ for optional chaining access", .current().span())
                        }
                    }

                    .index++
                    yield match .current() {
                        Number(number) => {
                            // Indexing into a tuple
                            .index++
                            let num = number.to_usize()
                            yield ParsedExpression::IndexedTuple(
                                expr: result
                                index: num
                                is_optional
                                span: merge_spans(start, end: .previous().span()))
                        }
                        Identifier(name) => {
                            // Struct field access or method call
                            .index++
                            yield match .current() {
                                LParen => {
                                    // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                    .index--
                                    let call = .parse_call()
                                    yield ParsedExpression::MethodCall(
                                        expr: result
                                        call: call!
                                        is_optional
                                        span: merge_spans(start, end: .previous().span()))
                                }
                                else => ParsedExpression::IndexedStruct(
                                    expr: result
                                    field: name
                                    is_optional
                                    span: merge_spans(start, end: .current().span()))
                            }
                        }
                        else => {
                            .error("Unsupported dot operation", .current().span())
                            .index++
                            yield result
                        }
                    }
                }
                LSquare => {
                    // Indexing operation
                    .index++
                    let index_expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    if .current() is RSquare {
                        .index++
                    } else {
                        .error("Expected ']'", .current().span())
                    }

                    yield ParsedExpression::IndexedExpression(
                        base: result,
                        index: index_expr,
                        span: merge_spans(start, .current().span()))
                }
                else => {
                    break
                }
            }
        }
        return result
    }

    function parse_postfix_colon_colon(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        .index++
        mut namespace_: [String] = []
        if expr is Var(name) {
            namespace_.push(name)
        } else {
            .error("Expected namespace", expr.span())
        }
        if .eof() {
            .error("Incomplete static method call", .current().span())
        }
        while not .eof() {
            guard .current() is Identifier(name: current_name) else {
                .error("Unsupported static method call", .current().span())
                    return expr
            }
            .index++
            if .current() is LParen {
                .index--
                mut call = .parse_call()
                call!.namespace_ = namespace_
                return ParsedExpression::Call(call: call!, span: merge_spans(expr.span(), .current().span()))
            }
            if .current() is ColonColon {
                if .previous() is Identifier(name) {
                    namespace_.push(name)
                } else {
                    .error("Expected namespace", expr.span())
                }
                .index++
                continue
            }
            if .current() is LessThan {
                // Generic function arguments
                .index--
                let maybe_call = .parse_call()
                if maybe_call.has_value() {
                    mut call = maybe_call!
                    call.namespace_ = namespace_
                    return ParsedExpression::Call(call, span: merge_spans(expr.span(), .current().span()))
                }
                return ParsedExpression::Garbage(.current().span())
            }
            return ParsedExpression::NamespacedVar(
                name: current_name,
                namespace_,
                span: merge_spans(start, .current().span())
            )
        }
    }

    function parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let expr = .parse_expression(allow_assignments: false, allow_newlines: true)
        let cases = .parse_match_cases()

        return ParsedExpression::Match(expr, cases, span: merge_spans(start, .previous().span()))
    }

    function parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let marker_span = .current().span()
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            .skip_newlines()

            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            .skip_newlines()

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false, allow_newlines: false))
            }

            for pattern in patterns.iterator() {
                cases.push(ParsedMatchCase(patterns: [pattern], marker_span, body))
            }

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }

            .skip_newlines()
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    function parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            let pattern = .parse_match_pattern()
            patterns.push(pattern)
            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    function parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | SingleQuotedByteString
        | LParen => ParsedMatchPattern::Expression(.parse_operand())

        Else => {
            .index++
            yield ParsedMatchPattern::CatchAll
        }

        Identifier(name) => {
            let pattern_start_index = .index
            mut variant_names: [(String, Span)] = []

            while not .eof() {
                match .current() {
                    Identifier(name) => {
                        .index++
                        variant_names.push((name, .current().span()))
                    }
                    ColonColon => {
                        .index++
                    }
                    else => {
                        break
                    }
                }
            }

            mut variant_arguments = .parse_variant_arguments()
            let arguments_start = .current().span()
            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                variant_names
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::CatchAll
        }
    }

    function parse_variant_arguments(mut this) throws -> [EnumVariantPatternArgument] {
        mut variant_arguments: [EnumVariantPatternArgument] = []
        mut has_parens = false
        if .current() is LParen {
            has_parens = true
            .index++

            while not .eof() {
                match .current() {
                    Identifier(name: arg_name) => {
                        if .peek(1) is Colon {
                            .index += 2
                            if .current() is Identifier(name: arg_binding) {
                                let span = .current().span()
                                .index++
                                variant_arguments.push(EnumVariantPatternArgument(
                                    name: Some(arg_name)
                                    binding: arg_binding
                                    span)
                                )
                            } else {
                                .error("Expected binding after ‘:’", .current().span())
                            }
                        } else {
                            variant_arguments.push(EnumVariantPatternArgument(
                                        name: None
                                        binding: arg_name
                                        span: .current().span()))
                            .index++
                        }
                    }
                    Comma => {
                        .index++
                    }
                    RParen => {
                        .index++
                        break
                    }
                    else => {
                        .error("Expected pattern argument name", .current().span())
                        break
                    }
                }
            }
        }

        return variant_arguments
    }

    function parse_call(mut this) throws -> ParsedCall? {
        mut call = ParsedCall(
            namespace_: []
            name: ""
            args: []
            type_args: []
        )

        guard .current() is Identifier(name) else {
            .error("Expected function call", .current().span())
            return call
        }

        call.name = name
        .index++

        // This is to allow the lookahead. Without it, we may see something like
        // foo < Bar, and think the start of a generic call when it actually isn't.
        let index_reset = .index

        if .current() is LessThan {
            // Generic type
            .index++
            mut inner_types: [ParsedType] = []

            while not .eof() {
                match .current() {
                    GreaterThan => {
                        .index++
                        break
                    }
                    Comma | Eol => {
                        .index++
                    }
                    else => {
                        let index_before = .index
                        let inner_type = .parse_typename()
                        if index_before == .index {
                            // Can't parse further, this is not a generic call.
                            .index = index_reset;
                            break
                        }
                        inner_types.push(inner_type)
                    }
                }
            }

            call.type_args = inner_types
        }

        if .current() is LParen {
            .index++
        } else {
            .index = index_reset
            .error("Expected '('", .current().span())
            return None
        }

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Eol | Comma => {
                    .index++
                }
                else => {
                    let label_span = .current().span()
                    let label = .parse_argument_label()

                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)

                    call.args.push((label, label_span, expr))
                }
            }
        }

        return call
    }

    function skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mut this) throws -> [ParsedGenericParameter] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [ParsedGenericParameter] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            if .current() is Identifier(name, span) {
                generic_parameters.push(ParsedGenericParameter(name, span))
                .index++
                if .current() is Comma or .current() is Eol {
                    .index++
                }
            } else {
                .error("Expected generic parameter name", .current().span())
                return generic_parameters
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("Expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mut this) throws -> String {
        if .peek(1) is Colon and .current() is Identifier(name) {
            .index += 2
            return name
        }
        return ""
    }

    function parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        mut whitelist: [ParsedType] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    } else {
                        .error("Can't fill an Array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false, allow_newlines: false)
                    if expr is Garbage {
                        break
                    }

                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false, allow_newlines: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}
