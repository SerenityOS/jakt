// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Charles Mirabile <charlie.mirabile@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause


import error { JaktError, print_error}
import lexer { Token, NumericConstant }
import utility { panic, todo, FileId, Span }
import compiler { Compiler }
import prelude { JaktPrelude }

function merge_spans(anon start: Span, anon end: Span) -> Span {
    if start.file_id.id != end.file_id.id {
        panic("cannot merge spans from two different files!")
    }

    return Span(file_id: start.file_id, start: start.start, end: end.end)
}

enum DefinitionLinkage {
    Internal
    External
}

struct ImportName {
    name: String
    span: Span
}

struct ImportAlias {
    name: String
    span: Span
}

struct ParsedImport {
    module_name: ImportName
    alias_name: ImportAlias?
    import_list: [ImportName]
}

struct ParsedNamespace {
    name: String?
    name_span: Span?
    functions: [ParsedFunction]
    records: [ParsedRecord]
    namespaces: [ParsedNamespace]
    imports: [ParsedImport]
}
struct ValueEnumVariant {
    name: String
    span: Span
    value: ParsedExpression?
}
struct SumEnumVariant {
    name: String
    span: Span
    params: [ParsedVarDecl]?
}
enum RecordType {
    Struct(fields: [ParsedField])
    Class(fields: [ParsedField], super_class: ParsedType?)
    ValueEnum(underlying_type: ParsedType, variants: [ValueEnumVariant])
    SumEnum(is_boxed: bool, variants: [SumEnumVariant])
    Garbage
}
struct ParsedRecord {
    name: String
    name_span: Span
    generic_parameters: [ParsedGenericParameter]
    definition_linkage: DefinitionLinkage
    methods: [ParsedMethod]
    record_type: RecordType
}

enum FunctionType {
    Normal
    ImplicitConstructor
    ImplicitEnumConstructor
    ExternalClassConstructor
}

struct ParsedFunction {
    name: String
    name_span: Span
    visibility: Visibility
    params: [ParsedParameter]
    generic_parameters: [ParsedGenericParameter]
    block: ParsedBlock
    return_type: ParsedType
    return_type_span: Span
    can_throw: bool
    type: FunctionType
    linkage: FunctionLinkage
    must_instantiate: bool
}

struct ParsedParameter {
    requires_label: bool
    variable: ParsedVariable
    span: Span
}

struct ParsedGenericParameter {
    name: String
    span: Span
}

struct ParsedBlock {
    stmts: [ParsedStatement]

    function find_yield_span(this) -> Span? {
        for stmt in .stmts.iterator() {
            match stmt {
                Yield(expr) => {
                    return expr.span()
                }
                else => { }
            }
        }
        return None
    }

    function span(this, parser: Parser) throws -> Span? {
        mut start: usize? = None
        mut end: usize = 0

        for stmt in .stmts.iterator() {
            let stmt_span = stmt.span()
            if not start.has_value() {
                start = stmt_span.start
            }
            end = stmt_span.end
        }

        if start.has_value() {
            return parser.span(start: start!, end)
        }

        return None
    }
}

boxed enum ParsedStatement {
    Expression(expr: ParsedExpression, span: Span)
    Defer(statement: ParsedStatement, span: Span)
    UnsafeBlock(block: ParsedBlock, span: Span)
    VarDecl(var: ParsedVarDecl, init: ParsedExpression, span: Span)
    If(condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, span: Span)
    Block(block: ParsedBlock, span: Span)
    Loop(block: ParsedBlock, span: Span)
    While(condition: ParsedExpression, block: ParsedBlock, span: Span)
    For(iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock, span: Span)
    Break(Span)
    Continue(Span)
    Return(expr: ParsedExpression?, span: Span)
    Throw(expr: ParsedExpression, span: Span)
    Yield(expr: ParsedExpression, span: Span)
    InlineCpp(block: ParsedBlock, span: Span)
    Try(stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, span: Span)
    Garbage(Span)

    function span(this) -> Span => match this {
        Expression(span) => span
        Defer(span) => span
        UnsafeBlock(span) => span
        VarDecl(span) => span
        If(span) => span
        Block(span) => span
        Loop(span) => span
        While(span) => span
        For(span) => span
        Break(span) => span
        Continue(span) => span
        Return(span) => span
        Throw(span) => span
        Yield(span) => span
        InlineCpp(span) => span
        Try(span) => span
        Garbage(span) => span
    }
}

enum BinaryOperator {
    Add
    Subtract
    Multiply
    Divide
    Modulo
    LessThan
    LessThanOrEqual
    GreaterThan
    GreaterThanOrEqual
    Equal
    NotEqual

    BitwiseAnd
    BitwiseXor
    BitwiseOr
    BitwiseLeftShift
    BitwiseRightShift
    ArithmeticLeftShift
    ArithmeticRightShift

    LogicalAnd
    LogicalOr

    NoneCoalescing

    Assign
    BitwiseAndAssign
    BitwiseOrAssign
    BitwiseXorAssign
    BitwiseLeftShiftAssign
    BitwiseRightShiftAssign
    AddAssign
    SubtractAssign
    MultiplyAssign
    ModuloAssign
    DivideAssign
    NoneCoalescingAssign

    Garbage

    function is_assignment(this) => match this {
        Assign
        | BitwiseAndAssign
        | BitwiseOrAssign
        | BitwiseXorAssign
        | BitwiseLeftShiftAssign
        | BitwiseRightShiftAssign
        | AddAssign
        | SubtractAssign
        | MultiplyAssign
        | ModuloAssign
        | DivideAssign
        | NoneCoalescingAssign => true

        else => false
    }
}

enum TypeCast {
    Fallible(ParsedType)
    Infallible(ParsedType)

    function parsed_type(this) -> ParsedType => match this {
        Fallible(parsed_type) => parsed_type
        Infallible(parsed_type) => parsed_type
    }
}

enum UnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(TypeCast)
    Is(ParsedType)
}

struct EnumVariantPatternArgument {
    name: String?
    binding: String
    span: Span
}

enum ParsedMatchPattern {
    EnumVariant(
        variant_name: [(String, Span)]
        variant_arguments: [EnumVariantPatternArgument]
        arguments_span: Span
    )
    Expression(ParsedExpression)
    CatchAll
}

struct ParsedMatchCase {
    patterns: [ParsedMatchPattern]
    marker_span: Span
    body: ParsedMatchBody
}

enum ParsedMatchBody {
    Expression(ParsedExpression)
    Block(ParsedBlock)
}

boxed enum ParsedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: NumericConstant, span: Span)
    QuotedString(val: String, span: Span)
    SingleQuotedString(val: String, span: Span)
    SingleQuotedByteString(val: String, span: Span)
    Call(call: ParsedCall, span: Span)
    MethodCall(expr: ParsedExpression, call: ParsedCall, span: Span)
    IndexedTuple(expr: ParsedExpression, index: usize, span: Span)
    IndexedStruct(expr: ParsedExpression, field: String, span: Span)
    Var(name: String, span: Span)
    IndexedExpression(base: ParsedExpression, index: ParsedExpression, span: Span)
    UnaryOp(expr: ParsedExpression, op: UnaryOperator, span: Span)
    BinaryOp(lhs: ParsedExpression, op: BinaryOperator, rhs: ParsedExpression, span: Span)
    Operator(op: BinaryOperator, span: Span)
    OptionalSome(expr: ParsedExpression, span: Span)
    OptionalNone(Span)
    JaktArray(values: [ParsedExpression], fill_size: ParsedExpression?, span: Span)
    JaktDictionary(values: [(ParsedExpression, ParsedExpression)], span: Span)
    Set(values: [ParsedExpression], span: Span)
    JaktTuple(values: [ParsedExpression], span: Span)
    Range(from: ParsedExpression, to: ParsedExpression, span: Span)
    ForcedUnwrap(expr: ParsedExpression, span: Span)
    Match(expr: ParsedExpression, cases: [ParsedMatchCase], span: Span)
    NamespacedVar(name: String, namespace_: [String], span: Span)
    Garbage(Span)

    function span(this) => match this {
        Boolean(val, span) => span
        NumericConstant(val, span) => span
        QuotedString(val, span) => span
        SingleQuotedString(val, span) => span
        SingleQuotedByteString(val, span) => span
        Call(call, span) => span
        Var(name, span) => span
        IndexedExpression(base, index, span) => span
        UnaryOp(expr, op, span) => span
        BinaryOp(lhs, op, rhs, span) => span
        Operator(op, span) => span
        OptionalSome(expr, span) => span
        OptionalNone(span) => span
        JaktArray(values, fill_size, span) => span
        JaktDictionary(values, span) => span
        Set(span) => span
        JaktTuple(values, span) => span
        Range(from, to, span) => span
        ForcedUnwrap(expr, span) => span
        Garbage(span) => span
        MethodCall(expr, call, span) => span
        Match(expr, cases, span) => span
        IndexedTuple(expr, index, span) => span
        IndexedStruct(expr, field, span) => span
        NamespacedVar(name, namespace_, span) => span
    }

    function precedence(this) => match this {
        Operator(op, span) => match op {
            Multiply
            | Modulo
            | Divide => 100

            Add
            | Subtract => 90

            BitwiseLeftShift
            | BitwiseRightShift
            | ArithmeticLeftShift
            | ArithmeticRightShift => 85

            LessThan
            | LessThanOrEqual
            | GreaterThan
            | GreaterThanOrEqual
            | Equal
            | NotEqual => 80

            BitwiseAnd => 73
            BitwiseXor => 72
            BitwiseOr => 71
            LogicalAnd => 70

            LogicalOr
            | NoneCoalescing => 69

            Assign
            | BitwiseAndAssign
            | BitwiseOrAssign
            | BitwiseXorAssign
            | BitwiseLeftShiftAssign
            | BitwiseRightShiftAssign
            | AddAssign
            | SubtractAssign
            | MultiplyAssign
            | ModuloAssign
            | DivideAssign
            | NoneCoalescingAssign => 50

            else => 0
        }
        else => 0
    }
}

struct ParsedVarDecl {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedField {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    var_decl: ParsedVarDecl
    visibility: Visibility
}

struct ParsedMethod {
    // FIXME: It would be nice to extend the ParsedVarDecl struct instead.
    parsed_function: ParsedFunction
    visibility: Visibility
}

struct ParsedVariable {
    name: String
    parsed_type: ParsedType
    is_mutable: bool
    span: Span
}

struct ParsedCall {
    namespace_: [String]
    name: String
    args: [(String, Span, ParsedExpression)]
    type_args: [ParsedType]
}

boxed enum ParsedType {
    Name(name: String, span: Span)
    NamespacedName(name: String, namespaces: [String], params: [ParsedType], span: Span)
    GenericType(name: String, generic_parameters: [ParsedType], span: Span), // FIXME: tuple should be dictionary
    JaktArray(inner: ParsedType, span: Span)
    Dictionary(key: ParsedType, value: ParsedType, span: Span)
    JaktTuple(types: [ParsedType], span: Span)
    Set(inner: ParsedType, span: Span)
    Optional(inner: ParsedType, span: Span)
    RawPtr(inner: ParsedType, span: Span)
    WeakPtr(inner: ParsedType, span: Span)
    Empty

    function span(this) => match this {
        Name(name, span) => span
        NamespacedName(name, namespaces, params, span) => span
        GenericType(name, generic_parameters, span) => span
        JaktArray(inner, span) => span
        Dictionary(key, value, span) => span
        JaktTuple(types, span) => span
        Set(inner, span) => span
        Optional(inner, span) => span
        RawPtr(inner, span) => span
        WeakPtr(inner, span) => span
        Empty => Span(file_id: FileId(id: 0uz), start: 0, end: 0) // FIXME: For some reason we can't see `empty_span()` here.
    }
}

struct Parser {
    index: usize
    tokens: [Token]
    compiler: Compiler

    function parse(compiler: Compiler, tokens: [Token]) throws -> ParsedNamespace {
        mut parser = Parser(index: 0, tokens, compiler)
        return parser.parse_namespace()
    }

    function span(this, start: usize, end: usize) -> Span {
        return Span(file_id: .compiler.current_file!, start, end)
    }

    function empty_span(this) -> Span => .span(start: 0, end: 0)

    function error(mut this, anon message: String, anon span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::Message(message, span))
        }
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        if not .compiler.ignore_parser_errors {
            .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
        }
    }

    function eof(this) => .index >= .tokens.size() - 1

    function eol(this) => .eof() or .tokens[.index] is Eol

    function peek(this, anon steps: usize) -> Token {
        if .eof() or (steps + .index) >= .tokens.size()  {
            return .tokens.last()!
        }
        return .tokens[.index + steps]
    }

    function previous(this) -> Token {
        if .index == 0 or .index > .tokens.size() {
            return Token::Eof(.span(start: 0, end: 0))
        }
        return .tokens[.index - 1]
    }

    function current(this) -> Token {
        return .peek(0)
    }

    public function parse_namespace(mut this) throws -> ParsedNamespace {
        //FIXME: The constructor should just be able to accept None directly and infer its type
        let none_string: String? = None
        let none_span: Span? = None
        mut parsed_namespace = ParsedNamespace(
            name: none_string
            name_span: none_span
            functions: []
            records: []
            namespaces: []
            imports: []
        )

        while not .eof() {
            match .current() {
                Import => {
                    parsed_namespace.imports.push(.parse_import())
                }
                Function => {
                    let parsed_function = .parse_function(FunctionLinkage::Internal, Visibility::Public)
                    parsed_namespace.functions.push(parsed_function)
                }
                Struct | Class | Enum | Boxed => {
                    let parsed_record = .parse_record(DefinitionLinkage::Internal)
                    parsed_namespace.records.push(parsed_record)
                }
                Namespace => {
                    .index++
                    let name: (String, Span)? = match .current() {
                        Identifier(name, span) => {
                            .index++
                            yield Some((name, span))
                        }
                        else => {
                            //FIXME: We should just be able to write `yield None` and have the compiler infer its type
                            let tuple_none: (String, Span)? = None
                            yield tuple_none
                        }
                    }
                    if .current() is LCurly {
                        .index++
                    } else {
                        .error("Expected ‘{’", .current().span())
                    }
                    mut namespace_ = .parse_namespace()
                    if .current() is RCurly {
                        .index++
                    } else {
                        .error("Incomplete namespace", .previous().span())
                    }
                    if name.has_value() {
                        namespace_.name = name!.0
                        namespace_.name_span = name!.1
                    }
                    parsed_namespace.namespaces.push(namespace_)
                }
                Extern => {
                    .index++
                    match .current() {
                        Function => {
                            let parsed_function = .parse_function(FunctionLinkage::External, Visibility::Public)
                            parsed_namespace.functions.push(parsed_function)
                        }
                        Struct => {
                            let parsed_struct = .parse_struct(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_struct)
                        }
                        Class => {
                            let parsed_class = .parse_class(DefinitionLinkage::External)
                            parsed_namespace.records.push(parsed_class)
                        }
                        else => {
                            .error("Unexpected keyword", .current().span())
                        }
                    }
                }
                Eol => {
                    // Ignore
                    .index++
                }
                RCurly => {
                    break
                }
                else => {
                    .error("Unexpected token (expected keyword)", .current().span())
                    break
                }
            }
        }

        return parsed_namespace
    }

    function parse_record(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord => match .current() {
        Struct => .parse_struct(definition_linkage)
        Class => .parse_class(definition_linkage)
        Enum => .parse_enum(definition_linkage, is_boxed: false)
        Boxed => {
            .index++
            yield .parse_enum(definition_linkage, is_boxed: true)
        }
        else => {
            .error("Expected `struct`, `class`, `enum`, or `boxed`", .current().span())
            yield ParsedRecord(
                name: "",
                name_span: .empty_span(),
                generic_parameters: [],
                definition_linkage,
                methods: [],
                record_type: RecordType::Garbage
            )
        }
    }

    function parse_import(mut this) throws -> ParsedImport {
        let none_alias: ImportAlias? = None // FIXME: directly set None when compiler allowes it
        mut parsed_import = ParsedImport(
            module_name: ImportName(name: "", span: .current().span())
            alias_name: none_alias
            import_list: []
        )

        .index++
        parsed_import.module_name = match .current() {
            Identifier(name, span) => ImportName(name, span)
            else => {
                .error("Expected module name", .current().span())
                return parsed_import
            }
        }

        .index++

        if .eol() {
            return parsed_import
        }

        match .current() {
            As => {
                .index++
                match .current() {
                    Identifier(name, span) => {
                        .index++
                        parsed_import.alias_name = ImportAlias(name, span)
                    }
                    else => {
                        .error("Expected name", .current().span())
                        .index++
                    }
                }
            }
            else => {}
        }

        if .eol() {
            return parsed_import
        }

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    parsed_import.import_list.push(ImportName(name, span))
                    .index++
                }
                Comma | Eol => {
                    .index++
                }
                RCurly => {
                    .index++
                    break
                }
                else => {
                    .error("Expected import symbol", .current().span())
                    .index++
                }
            }
        }

        return parsed_import
    }

    function parse_value_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage) throws -> ([ValueEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [ValueEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is Equal {
                        .index += 2
                        let expr = .parse_expression(allow_assignments: false)
                        variants.push(ValueEnumVariant(name, span, value: expr))
                    } else {
                        .index++
                        let none_expr: ParsedExpression? = None
                        variants.push(ValueEnumVariant(name, span, value: none_expr))
                    }
                }
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function => {
                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if .eof() {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_sum_enum_body(mut this, partial_enum: ParsedRecord, definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ([SumEnumVariant], [ParsedMethod]) {
        mut methods: [ParsedMethod] = []
        mut variants: [SumEnumVariant] = []

        if .current() is LCurly {
            .index++
        } else {
            .error("Expected `{` to start the enum body", .current().span())
        }

        .skip_newlines()

        if .eof() {
            .error("Incomplete enum definition, expected variant name", .previous().span())
            return (variants, methods)
        }

        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None
        while not .eof() {
            match .current() {
                Identifier(name, span) => {
                    if .peek(1) is LParen {
                        .index += 2

                        mut var_decls: [ParsedVarDecl] = []

                        while not .eof() {
                            if .peek(1) is Colon {
                                let var_decl = .parse_variable_declaration(is_mutable: false)
                                match var_decl.parsed_type {
                                    Name(name) => {
                                        if name == partial_enum.name and not is_boxed{
                                            .error("use 'boxed enum' to make the enum recursive", var_decl.span)
                                        }
                                    }
                                    else => {}
                                }
                                var_decls.push(var_decl)
                                continue
                            }

                            match .current() {
                                Identifier | LSquare | LCurly => {
                                    var_decls.push(ParsedVarDecl(
                                        name: ""
                                        parsed_type: .parse_typename()
                                        is_mutable: false
                                        span: .current().span()
                                    ))
                                }
                                else => {}
                            }

                            match .current() {
                                RParen => {
                                    .index++
                                    break
                                }
                                Comma | Eol => {
                                    .index++
                                }
                                else => {
                                    .error(format("Incomplete enum variant defintion, expected `,` or `)`; got `{}`", .current()), .current().span())
                                    break;
                                }
                            }
                        }
                        variants.push(SumEnumVariant(name, span, params: var_decls))
                    } else {
                        .index++
                        let none_decls: [ParsedVarDecl]? = None
                        variants.push(SumEnumVariant(name, span, params: none_decls))
                    }
                }
                RCurly => {
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Function => {
                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? Visibility::Public
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    .error("Expected identifier or the end of enum block", .current().span())
                    .index++
                }
            }
        }

        if not .current() is RCurly {
            .error("Invalid enum definition, expected `}`", .current().span())
            return (variants, methods)
        }
        .index++

        if variants.is_empty() {
            .error("Empty enums are not allowed", partial_enum.name_span)
        }
        return (variants, methods)
    }

    function parse_enum(mut this, anon definition_linkage: DefinitionLinkage, is_boxed: bool) throws -> ParsedRecord {
        mut parsed_enum = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut underlying_type: ParsedType? = None
        if .current() is Enum {
            .index++
        } else {
            .error("Expected ‘enum’ keyword", .current().span())
            return parsed_enum
        }

        if .eof() {
            .error("Incomplete enum definition, expected name", .current().span())
            return parsed_enum
        }

        match .current() {
            Token::Identifier(name, span) => {
                parsed_enum.name = name
                parsed_enum.name_span = span
                .index++
            }
            else => {
                .error("Incomplete enum definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete enum definition, expected generic parameters or underlying type or body", .current().span())
            return parsed_enum
        }


        if .current() is LessThan {
            parsed_enum.generic_parameters = .parse_generic_parameters()
        }

        if .eof() {
            .error("Incomplete enum definition, expected underlying type or body", .current(). span())
            return parsed_enum
        }

        if .current() is Colon {
            if is_boxed {
                .error("Invalid enum definition: Value enums must not have an underlying type", .current().span())
            }
            .index++
            underlying_type = .parse_typename()
        }

        if .eof() {
            .error("Incomplete enum definition, expected body", .current().span())
            return parsed_enum
        }

        if underlying_type.has_value() {
            let variants_methods = .parse_value_enum_body(partial_enum: parsed_enum, definition_linkage)
            parsed_enum.methods = variants_methods.1
            parsed_enum.record_type = RecordType::ValueEnum(
                underlying_type: underlying_type!
                variants: variants_methods.0
            )
        } else {
            let variants_methods = .parse_sum_enum_body(partial_enum: parsed_enum, definition_linkage, is_boxed)
            parsed_enum.methods = variants_methods.1
            parsed_enum.record_type = RecordType::SumEnum(
                is_boxed: is_boxed,
                variants: variants_methods.0
            )
        }

        return parsed_enum
    }

    public function parse_struct_class_body(mut this, definition_linkage: DefinitionLinkage, default_visibility: Visibility, is_class: bool) throws -> ([ParsedField],[ParsedMethod]) {
        if .current() is LCurly {
            .index++
        } else {
            .error("Expected ‘{’", .current().span())
        }

        mut fields: [ParsedField] = []
        mut methods: [ParsedMethod] = []

        // This gets reset after each loop. If someone doesn't consume it, we error out.
        mut last_visibility: Visibility? = None
        mut last_visibility_span: Span? = None

        // Have we already found an error?
        mut error = false;

        while not .eof() {
            let token = .current()
            match token {
                RCurly => {
                    if last_visibility.has_value() {
                        .error("Expected function or parameter after visibility modifier", token.span())
                    }
                    .index++
                    return (fields, methods)
                }
                Comma | Eol => {
                    // Treat comma as whitespace? Might require them in the future
                    .index++
                }
                Public(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Public
                    last_visibility_span = span
                    .index++
                }
                Private(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = Visibility::Private
                    last_visibility_span = span
                    .index++
                }
                Restricted(span) => {
                    if last_visibility.has_value() {
                        .error_with_hint("Multiple visibility modifiers on one field or method are not allowed", span, "Previous modifier is here", last_visibility_span!)
                    }
                    last_visibility = .parse_restricted_visibility_modifier()
                    last_visibility_span = span
                }
                Identifier => {
                    // Parse a field
                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let field = .parse_field(visibility)

                    fields.push(field)
                }
                Function => {
                    // Parse a method

                    let function_linkage = match definition_linkage {
                        Internal => FunctionLinkage::Internal
                        External => FunctionLinkage::External
                    }

                    let visibility = last_visibility ?? default_visibility
                    last_visibility = None
                    last_visibility_span = None

                    let parsed_method = .parse_method(function_linkage, visibility)

                    methods.push(parsed_method)
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error(format("Invalid member, did not expect a {} here", token), token.span())
                        error = true
                    }
                    .index++
                }
            }
        }
        if is_class {
            .error("Incomplete class body, expected ‘}’", .current().span())
        } else {
            .error("Incomplete struct body, expected ‘}’", .current().span())
        }
        return (fields, methods)
    }

    public function parse_struct(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_struct = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        if .current() is Struct {
            .index++
        } else {
            .error("Expected `struct` keyword", .current().span())
            return parsed_struct
        }
        // Struct name
        if .eof() {
            .error("Incomplete struct definition, expected name", .current().span())
            return parsed_struct
        }

        match .current() {
            Identifier(name, span) => {
                .index++
                parsed_struct.name = name
                parsed_struct.name_span = span
            }
            else => {
                .error("Incomplete struct definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete struct definition, expected generic parameters or body", .current().span())
            return parsed_struct
        }

        // Generic parameters
        parsed_struct.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete struct definition, expected body", .current().span())
            return parsed_struct
        }

        let fields_methods = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Public, is_class: false)

        parsed_struct.methods = fields_methods.1
        parsed_struct.record_type = RecordType::Struct(fields: fields_methods.0)

        return parsed_struct
    }

    public function parse_class(mut this, anon definition_linkage: DefinitionLinkage) throws -> ParsedRecord {
        mut parsed_class = ParsedRecord(
            name: "",
            name_span: .empty_span(),
            generic_parameters: [],
            definition_linkage,
            methods: [],
            record_type: RecordType::Garbage
        )
        mut super_class: ParsedType? = None
        if .current() is Class {
            .index++
        } else {
            .error("Expected `class` keyword", .current().span())
            return parsed_class
        }
        // Class name
        if .eof() {
            .error("Incomplete class definition, expected name", .current().span())
            return parsed_class
        }

        match .current() {
            Identifier(name, span) => {
                .index++
                parsed_class.name = name
                parsed_class.name_span = span
            }
            else => {
                .error("Incomplete class definition, expected name", .current().span())
            }
        }

        if .eof() {
            .error("Incomplete class definition, expected generic parameters or super class or body", .current().span())
            return parsed_class
        }

        // Generic parameters
        parsed_class.generic_parameters = .parse_generic_parameters()


        if .eof() {
            .error("Incomplete class definition, expected super class or body", .current().span())
            return parsed_class
        }

        // Super class
        if .current() is Colon {
            .index++
            super_class = .parse_typename()
        }

        if .eof() {
            .error("Incomplete class definition, expected body", .current().span())
            return parsed_class
        }

        let fields_methods = .parse_struct_class_body(definition_linkage, default_visibility: Visibility::Private, is_class: true)

        parsed_class.methods = fields_methods.1
        parsed_class.record_type = RecordType::Class(fields: fields_methods.0, super_class)

        return parsed_class
    }

    public function parse_function(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedFunction {
        mut parsed_function = ParsedFunction(
            name: "",
            name_span: .empty_span(),
            visibility,
            params: [],
            generic_parameters: [],
            block: ParsedBlock(stmts: []),
            return_type: ParsedType::Empty,
            return_type_span: .span(start: 0, end: 0),
            can_throw: false,
            type: FunctionType::Normal,
            linkage,
            must_instantiate: false,
        )

        .index++

        if .eof() {
            .error("Incomplete function definition", .current().span())
            return parsed_function
        }

        let function_name = match .current() {
            Identifier(name) => name
            else => { return parsed_function }
        }
        parsed_function.name = function_name
        parsed_function.name_span = .current().span()

        .index++

        parsed_function.generic_parameters = .parse_generic_parameters()

        if .eof() {
            .error("Incomplete function", .current().span())
        }

        if .current() is LParen {
            .index++
        } else {
            .error("Expected '('", .current().span())
        }

        mut params: [ParsedParameter] = []
        mut current_param_requires_label = true
        mut current_param_is_mutable = false

        // Have we already found an error?
        mut error = false
        mut parameter_complete = false

        while not .eof() {
            match .current() {
                RParen => {
                    .index++
                    break
                }
                Comma => {
                    if not parameter_complete and not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = true
                    current_param_is_mutable = false
                    parameter_complete = false
                }
                Anon => {
                    if parameter_complete and not error  {
                        .error("‘anon’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘anon’ must appear before ‘mut’", .current().span())
                        error = true
                    }
                    if not current_param_requires_label and not error  {
                        .error("‘anon’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_requires_label = false
                }
                Mut => {
                    if parameter_complete and not error  {
                        .error("‘mut’ must appear at start of parameter declaration, not the end", .current().span())
                        error = true
                    }
                    if current_param_is_mutable and not error  {
                        .error("‘mut’ cannot appear multiple times in one parameter declaration", .current().span())
                        error = true
                    }
                    .index++
                    current_param_is_mutable = true
                }
                This => {
                    params.push(ParsedParameter(
                        requires_label: false,
                        variable: ParsedVariable(
                            name: "this",
                            parsed_type: ParsedType::Empty,
                            is_mutable: current_param_is_mutable,
                            span: .current().span(),
                        ),
                        span: .current().span(),
                    ))
                    .index++
                    parameter_complete = true
                }
                Identifier(name, span) => {
                    let var_decl = .parse_variable_declaration(is_mutable: current_param_is_mutable)
                    params.push(ParsedParameter(
                        requires_label: current_param_requires_label,
                        variable: ParsedVariable(
                            name: var_decl.name,
                            parsed_type: var_decl.parsed_type,
                            is_mutable: var_decl.is_mutable,
                            span: .previous().span(),
                        ),
                        span: .previous().span(),
                    ))
                    parameter_complete = true
                }
                else => {
                    // TODO: Find a better way of only reporting the first error.
                    //       Also, should we report every error when running as the "language server"?
                    if not error {
                        .error("Expected parameter", .current().span())
                        error = true
                    }
                    .index++
                }
            }
        }

        parsed_function.params = params

        // NOTE: main() always throws
        mut can_throw = function_name == "main"
        if .current() is Throws {
            can_throw = true
            .index++
        }
        parsed_function.can_throw = can_throw

        if .current() is Arrow {
            .index++
            let start = .current().span()
            parsed_function.return_type = .parse_typename()
            parsed_function.return_type_span = merge_spans(start, .previous().span())
        }

        if linkage is External {
            return parsed_function
        }

        if .current() is FatArrow {
            parsed_function.block = .parse_fat_arrow()
        } else {
            parsed_function.block = .parse_block()
        }

        return parsed_function
    }

    function parse_fat_arrow(mut this) throws -> ParsedBlock {
        .index++
        let start = .current().span()
        let expr = .parse_expression(allow_assignments: false)
        let return_statement = ParsedStatement::Return(expr, span: merge_spans(start, .current().span()))
        return ParsedBlock(stmts: [return_statement])
    }

    function parse_field(mut this, anon visibility: Visibility) throws -> ParsedField {
        let parsed_variable_declaration = .parse_variable_declaration(is_mutable: true)

        if parsed_variable_declaration.parsed_type is Empty {
            .error("Field missing type", parsed_variable_declaration.span)
        }

        return ParsedField(
            var_decl: parsed_variable_declaration,
            visibility,
        )
    }

    function parse_method(mut this, anon linkage: FunctionLinkage, anon visibility: Visibility) throws -> ParsedMethod {
        mut parsed_function = .parse_function(linkage, visibility)

        if linkage is External {
            parsed_function.must_instantiate = true
        }

        return ParsedMethod(
            parsed_function,
            visibility,
        )
    }

    function parse_typename(mut this) throws -> ParsedType {
        let start = .current().span()
        mut parsed_type = .parse_type_shorthand()

        if parsed_type is Empty {
            parsed_type = .parse_type_longhand()
        }

        if .current() is QuestionMark {
            .index++
            let span = merge_spans(start, .current().span())
            parsed_type = ParsedType::Optional(inner: parsed_type, span)
        }

        return parsed_type
    }

    function parse_type_longhand(mut this) throws -> ParsedType => match .current() {
        Raw => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            // NOTE: We rewrite `raw T?` from `RawPtr<Optional<T>>` to `Optional<RawPtr<T>>`
            yield match inner {
                Optional(inner) => ParsedType::Optional(inner: ParsedType::RawPtr(inner, span), span)
                else => ParsedType::RawPtr(inner, span)
            }
        }
        Weak => {
            let start = .current().span()
            .index++
            let inner = .parse_typename()
            let span = merge_spans(start, .current().span())
            // NOTE: We rewrite `weak T?` from `WeakPtr<Optional<T>>` to `WeakPtr<T>`
            yield match inner {
                Optional(inner) => ParsedType::WeakPtr(inner, span)
                else => {
                    .error("missing `?` after weak pointer type name", span)
                    yield ParsedType::WeakPtr(inner, span)
                }
            }
        }
        Identifier(name) => {
            let span = .current().span()
            .index++
            mut parsed_type =  ParsedType::Name(name, span)
            if .current() is LessThan {
                mut parsed_generics = .parse_generic_parameters()
                // FIXME: clean this up when ParsedType::GenericType can have [[String:Span]] generic parameters
                mut generic_parameters: [ParsedType] = []
                for parsed_generic in parsed_generics.iterator() {
                    generic_parameters.push(ParsedType::Name(name: parsed_generic.name, span: parsed_generic.span))
                }
                parsed_type = ParsedType::GenericType(name, generic_parameters, span)
            }

            if .current() is ColonColon {
                .index++
                mut namespaces: [String] = [name]

                while not .eof() {
                    match .current() {
                        Identifier(name: namespace_name) => {
                            if .previous() is ColonColon {
                                namespaces.push(namespace_name)
                                .index++
                            }
                        }
                        ColonColon => {
                            if .previous() is Identifier {
                                .index++
                            } else {
                                .error("Expected name after", span)
                            }
                        }
                        else => {
                            break
                        }
                    }
                }

                let type_name = namespaces.pop()!

                mut params: [ParsedType] = []
                if .current() is LessThan {
                    // TODO: Implement Generic Inner Types for Namespaced Type
                }

                parsed_type = ParsedType::NamespacedName(name: type_name, namespaces, params, span: .previous().span())
            }

            yield parsed_type
        }
        else => {
            .error("Expected type name", .current().span())
            yield ParsedType::Empty
        }
    }

    function parse_variable_declaration(mut this, is_mutable: bool) throws -> ParsedVarDecl {
        match .current() {
            Identifier(name) => {
                let var_name = name
                .index++
                if .current() is Colon {
                    .index++
                } else {
                    return ParsedVarDecl(
                        name: var_name,
                        parsed_type: ParsedType::Empty,
                        is_mutable,
                        span: .current().span(),
                    )
                }

                let decl_span = .current().span()

                let var_type = .parse_typename()
                return ParsedVarDecl(
                    name: var_name,
                    parsed_type: var_type,
                    is_mutable,
                    span: decl_span,
                )
            }
            else => { }
        }
        return ParsedVarDecl(
            name: "",
            parsed_type: ParsedType::Empty,
            is_mutable: false,
            span: .current().span(),
        )
    }

    function parse_type_shorthand(mut this) throws -> ParsedType => match .current() {
        LSquare => .parse_type_shorthand_array_or_dictionary()
        LCurly => .parse_type_shorthand_set()
        LParen => .parse_type_shorthand_tuple()
        else => ParsedType::Empty
    }

    function parse_type_shorthand_array_or_dictionary(mut this) throws -> ParsedType {
        // [T] is shorthand for Array<T>
        // [K:V] is shorthand for Dictionary<K, V>
        let start = .current().span()
        .index++
        let inner = .parse_typename()
        if .current() is RSquare {
            .index++
            return ParsedType::JaktArray(inner, span: merge_spans(start, .previous().span()))
        }
        if .current() is Colon {
            .index++
            let value = .parse_typename()
            if .current() is RSquare {
                .index++
            } else {
                .error("Expected ']'", .current().span())
            }
            return ParsedType::Dictionary(key: inner, value, span: merge_spans(start, .current().span()))
        }
        .error("Expected shorthand type", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_set(mut this) throws -> ParsedType {
        // {T} is shorthand for Set<T>
        let start = .current().span()
        if .current() is LCurly {
            .index++
        }
        let inner = .parse_typename()
        if .current() is RCurly {
            .index++
            return ParsedType::Set(inner, span: merge_spans(start, .current().span()))
        }
        .error("Expected '}'", .current().span())
        return ParsedType::Empty
    }

    function parse_type_shorthand_tuple(mut this) throws -> ParsedType {
        // (A, B, C) is shorthand for Tuple<A, B, C>
        let start = .current().span()
        .index++
        mut types: [ParsedType] = []
        while not .eof() {
            if .current() is RParen {
                .index++
                return ParsedType::JaktTuple(types, span: merge_spans(start, .previous().span()))
            }
            if .current() is Comma {
                .index++
            }
            let index_before = .index
            let type = .parse_typename()
            let index_after = .index
            if index_before == index_after {
                break
            }
            types.push(type)
        }
        .error("Expected ‘)’", .current().span())
        return ParsedType::Empty
    }

    function parse_block(mut this) throws -> ParsedBlock {
        let start = .current().span()
        mut block = ParsedBlock(stmts: [])

        if .eof() {
            .error("Incomplete block", start)
            return block
        }

        .skip_newlines()

        if .current() is LCurly {
            .index++
        } else { 
            .error("Expected '{'", start)
        }

        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    return block
                }
                Semicolon | Eol => {
                    .index++
                }
                else => {
                    block.stmts.push(.parse_statement(inside_block: true))
                }
            }
        }

        .error("Expected complete block", merge_spans(start, .current().span()))
        return block
    }

    function parse_statement(mut this, inside_block: bool) throws -> ParsedStatement {
        let start = .current().span()

        return match .current() {
            Cpp => {
                .index++
                yield ParsedStatement::InlineCpp(block: .parse_block(), span: merge_spans(start, .previous().span()))
            }
            Defer => {
                .index++
                let statement = .parse_statement(inside_block: false)
                yield ParsedStatement::Defer(statement, span: merge_spans(start, .previous().span()))
            }
            Unsafe => {
                .index++
                let block = .parse_block()
                yield ParsedStatement::UnsafeBlock(block, span: merge_spans(start, .previous().span()))
            }
            Break => {
                .index++
                yield ParsedStatement::Break(start)
            }
            Continue => {
                .index++
                yield ParsedStatement::Continue(start)
            }
            Loop => {
                .index++
                let block = .parse_block()
                yield ParsedStatement::Loop(block, span: merge_spans(start, .previous().span()))
            }
            Throw => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                yield ParsedStatement::Throw(expr, span: merge_spans(start, .previous().span()))
            }
            While => {
                .index++
                let condition = .parse_expression(allow_assignments: false)
                let block = .parse_block()
                yield ParsedStatement::While(condition, block, span: merge_spans(start, .previous().span()))
            }
            Yield => {
                .index++
                let expr = .parse_expression(allow_assignments: false)
                if not inside_block {
                    .error("‘yield’ can only be used inside a block", span: merge_spans(start, end: expr.span()))
                }
                yield ParsedStatement::Yield(expr, span: merge_spans(start, .previous().span()))
            }
            Return => {
                .index++
                let none_expr: ParsedExpression? = None
                yield match .current() {
                    Eol | Eof | RCurly => ParsedStatement::Return(expr: none_expr, span: .current().span())
                    else => ParsedStatement::Return(expr: .parse_expression(allow_assignments: false), span: merge_spans(start, .previous().span()))
                }
            }
            Let | Mut => {
                let is_mutable = .current() is Mut
                .index++
                let var = .parse_variable_declaration(is_mutable)

                let init = match .current() {
                    Equal => {
                        .index++
                        yield .parse_expression(allow_assignments: false)
                    }
                    else => {
                        .error("Expected initializer", .current().span())
                        yield ParsedExpression::Garbage(.current().span())
                    }
                }

                yield ParsedStatement::VarDecl(var, init, span: merge_spans(start, .previous().span()))
            }
            If => .parse_if_statement()
            For => .parse_for_statement()
            Try => .parse_try_statement()
            LCurly => {
                let block = .parse_block()
                yield ParsedStatement::Block(block, span: merge_spans(start, .previous().span()))
            }
            else => {
                let expr = .parse_expression(allow_assignments: true)
                yield ParsedStatement::Expression(expr, span: merge_spans(start, .previous().span()))
            }
        }
    }

    function parse_try_statement(mut this) throws -> ParsedStatement {
        let start_span = .current().span()

        .index++

        let stmt = .parse_statement(inside_block: false)

        mut error_name = ""
        mut error_span = .current().span()

        if .current() is Catch {
            .index++
            match .current() {
                Identifier(name) => {
                    error_span = .current().span()
                    error_name = name
                    .index++
                }
                else => { }
            }
        } else {
            .error("Expected ‘catch’", .current().span())
        }

        let catch_block = .parse_block()
        return ParsedStatement::Try(stmt, error_name, error_span, catch_block, span: merge_spans(start_span, .previous().span()))
    }

    function parse_for_statement(mut this) throws -> ParsedStatement {
        let start_span = .current().span()
        .index++

        return match .current() {
            Identifier(name) => {
                let iterator_name = name
                let name_span = .current().span()
                .index++
                if .current() is In {
                    .index++
                } else {
                    .error("Expected ‘in’", .current().span())
                    return ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
                }

                let range = .parse_expression(allow_assignments: false)
                let block = .parse_block();

                yield ParsedStatement::For(iterator_name, name_span, range, block, span: merge_spans(start_span, .previous().span()))
            }
            else => {
                .error("Expected iterator name", .current().span())
                yield ParsedStatement::Garbage(merge_spans(start_span, .current().span()))
            }
        }
    }

    function parse_if_statement(mut this) throws -> ParsedStatement {
        if not .current() is If {
            .error("Expected ‘if’ statement", .current().span())
            return ParsedStatement::Garbage(span: .current().span())
        }

        let start_span = .current().span()
        .index++

        let condition = .parse_expression(allow_assignments: false)
        let then_block = .parse_block()

        mut else_statement: ParsedStatement? = None

        if .current() is Else {
            .index++
            match .current() {
                If => {
                    // This is an `else if`
                    else_statement = .parse_if_statement()
                }
                LCurly => {
                    let block = .parse_block()
                    if parsed_block_equals(then_block, block) {
                        .error("if and else have identical blocks", .current().span())
                    }
                    else_statement = ParsedStatement::Block(block, span: merge_spans(start_span, .previous().span()))
                }
                else => {
                    .error("‘else’ missing ‘if’ or block", .previous().span())
                }
            }
        }

        return ParsedStatement::If(condition, then_block, else_statement, span: merge_spans(start_span, .previous().span()))
    }

    function parse_expression(mut this, allow_assignments: bool) throws -> ParsedExpression {
        mut expr_stack: [ParsedExpression] = []
        mut last_precedence = 1000000

        let lhs = .parse_operand()
        expr_stack.push(lhs)

        while not .eol() {
            let parsed_operator = .parse_operator(allow_assignments);

            if parsed_operator is Garbage {
                break
            }

            let precedence = parsed_operator.precedence();

            .skip_newlines()

            let rhs = .parse_operand()

            while precedence <= last_precedence and expr_stack.size() > 1 {
                let rhs = expr_stack.pop()!
                let op = expr_stack.pop()!

                last_precedence = op.precedence()

                if last_precedence < precedence {
                    expr_stack.push(op)
                    expr_stack.push(rhs)
                    break
                }

                let lhs = expr_stack.pop()!

                match op {
                    Operator(op, span) => {
                        let new_span = merge_spans(lhs.span(), rhs.span())

                        expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                    }
                    else => .compiler.panic("operator is not an operator")
                }
            }

            expr_stack.push(parsed_operator)
            expr_stack.push(rhs)

            last_precedence = precedence
        }

        while expr_stack.size() > 1 {
            let rhs = expr_stack.pop()!
            let parsed_operator = expr_stack.pop()!
            let lhs = expr_stack.pop()!

            match parsed_operator {
                Operator(op, span) => {
                    let new_span = merge_spans(lhs.span(), rhs.span())
                    expr_stack.push(ParsedExpression::BinaryOp(lhs, op, rhs, span: new_span))
                }
                else => .compiler.panic("operator is not an operator")
            }
        }

        return expr_stack[0]
    }

    function parse_operand_base(mut this) throws => match .current() {
        Dot(span) => {
            yield ParsedExpression::Var(name: "this", span)
        }
        QuotedString(quote, span) => {
            .index++
            yield ParsedExpression::QuotedString(val: quote, span)
        }
        SingleQuotedString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedString(val: quote, span)
        }
        SingleQuotedByteString(quote, span) => {
            .index++
            yield ParsedExpression::SingleQuotedByteString(val: quote, span)
        }
        Number(number, span) => {
            .index++
            yield ParsedExpression::NumericConstant(val: number, span)
        }
        True(span) => {
            .index++
            yield ParsedExpression::Boolean(val: true, span)
        }
        False(span) => {
            .index++
            yield ParsedExpression::Boolean(val: false, span)
        }
        This(span) => {
            .index++
            yield ParsedExpression::Var(name: "this", span)
        }
        Not(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::LogicalNot, span)
        }
        Tilde(span) => {
            let start = .current().span()
            .index++
            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())
            yield ParsedExpression::UnaryOp(expr, op: UnaryOperator::BitwiseNot, span)
        }
        Identifier(name, span) => {
            if .peek(1) is LParen {
                if name == "Some" {
                    .index++
                    let expr = .parse_expression(allow_assignments: false)
                    return ParsedExpression::OptionalSome(expr, span)
                }
                let call = .parse_call()
                return ParsedExpression::Call(call: call!, span)
            }
            if .peek(1) is LessThan {
                // We *try* to see if it's a generic, but the parse errors, we back up and try something else
                .compiler.ignore_parser_errors = true
                let call = .parse_call()
                .compiler.ignore_parser_errors = false
                if not call.has_value() {
                    return match name {
                        "None" => ParsedExpression::OptionalNone(span)
                        else => ParsedExpression::Var(name, span)
                    }
                }
                return ParsedExpression::Call(call: call!, span)
            }
            .index++
            if name == "None" {
                return ParsedExpression::OptionalNone(span)
            }
            yield ParsedExpression::Var(name, span)
        }
        LParen(span) => {
            let start_span = .current().span()
            .index++
            
            mut expr = .parse_expression(allow_assignments: false)

            .skip_newlines()

            match .current() {
                RParen => {
                    .index++
                }
                Comma => {
                    // We have a tuple
                    .index++

                    mut tuple_exprs: [ParsedExpression] = [expr]
                    mut end_span = start_span

                    while not .eof() {
                        match .current() {
                            Eol | Comma => {
                                .index++
                            }
                            RParen => {
                                .index++
                                break
                            }
                            else => {
                                let expr = .parse_expression(allow_assignments: false)
                                end_span = expr.span()
                                tuple_exprs.push(expr)
                            }
                        }
                    }

                    if .eof() {
                        .error("Expected ')'", .current().span());
                    }

                    expr = ParsedExpression::JaktTuple(
                        values: tuple_exprs,
                        span: merge_spans(start_span, end_span)
                    )
                }
                else => {
                    .error("Expected ')'", .current().span())
                }
            }

            yield expr
        }
        PlusPlus(span)
        | MinusMinus(span)
        | Minus(span) => {

            let op = match .current() {
                PlusPlus => UnaryOperator::PreIncrement
                MinusMinus => UnaryOperator::PreDecrement
                Minus => UnaryOperator::Negate
                else => {
                    // FIXME: This is unreachable
                    .compiler.panic("unreachable")
                    yield UnaryOperator::Negate
                }
            }

            let start = .current().span()
            .index++

            let expr = .parse_operand()
            let span = merge_spans(start, expr.span())

            yield ParsedExpression::UnaryOp(expr, op, span)
        }
        LSquare => {
            yield .parse_array_or_dictionary_literal()
        }
        Match => {
            yield .parse_match_expression()
        }
        LCurly => {
            yield .parse_set_literal()
        }
        Ampersand => .parse_ampersand()
        Asterisk => .parse_asterisk()
        else => {
            let span = .current().span()
            .index++
            .error("Unsupported expression", span)
            yield ParsedExpression::Garbage(span)
        }
    }

    function parse_asterisk(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        let expr = .parse_operand()
        return ParsedExpression::UnaryOp(expr, op: UnaryOperator::Dereference, span: merge_spans(start, .current().span()))
    }

    function parse_ampersand(mut this) throws -> ParsedExpression {
        let start = .current().span()
        .index++
        if .current() is Raw {
            .index++
            let expr = .parse_operand()
            return ParsedExpression::UnaryOp(expr, op: UnaryOperator::RawAddress, span: merge_spans(start, expr.span()))
        }
        .error("Ampersand not currently supported", start)
        return ParsedExpression::Garbage(.current().span())
    }

    function parse_set_literal(mut this) throws -> ParsedExpression {
        let start = .current().span()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut output: [ParsedExpression] = []
        while not .eof() {
            match .current() {
                RCurly => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if expr is Garbage {
                        break
                    }

                    output.push(expr)
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RCurly {
            .error("Expected ‘}’ to close the set", .tokens[end].span())
        }

        return ParsedExpression::Set(values: output, span: merge_spans(start, .tokens[end].span()))
    }
    

    function parse_operand(mut this) throws -> ParsedExpression {
        .skip_newlines()
        let start = .current().span()
        .skip_newlines()
        mut expr = .parse_operand_base()
        return .parse_operand_postfix_operator(start, expr)
    }

    function parse_operand_postfix_operator(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        mut result = expr
        loop {
            result = match .current() {
                DotDot => {
                    .index++
                    let to = .parse_expression(allow_assignments: false)
                    yield ParsedExpression::Range(from: result, to, span: merge_spans(start, to.span()))
                }
                ExclamationPoint => {
                    .index++
                    yield ParsedExpression::ForcedUnwrap(expr: result, span: merge_spans(start, .previous().span()))
                }
                PlusPlus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostIncrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                MinusMinus => {
                    .index++
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::PostDecrement,
                        span: merge_spans(start, .previous().span()),
                    )
                }
                As => {
                    .index++
                    let cast_span = merge_spans(.previous().span(), .current().span())
                    let cast = match .current() {
                        ExclamationPoint => {
                            .index++
                            yield TypeCast::Infallible(.parse_typename())
                        }
                        QuestionMark => {
                            .index++
                            yield TypeCast::Fallible(.parse_typename())
                        }
                        else => {
                            .error("Invalid cast syntax", cast_span)
                            yield TypeCast::Fallible(ParsedType::Empty)
                        }
                    }
                    let span = merge_spans(start, merge_spans(cast_span, .current().span()))
                    yield ParsedExpression::UnaryOp(
                        expr: result,
                        op: UnaryOperator::TypeCast(cast),
                        span
                    )
                }
                Is => {
                    .index++
                    let parsed_type = .parse_typename()
                    let span = merge_spans(start, .current().span())
                    yield ParsedExpression::UnaryOp(expr: result, op: UnaryOperator::Is(parsed_type), span)
                }
                ColonColon => .parse_postfix_colon_colon(start, expr: result)
                Dot => {
                    .index++
                    yield match .current() {
                        Number(number) => {
                            // Indexing into a tuple
                            .index++
                            let num = number.to_usize()
                            yield ParsedExpression::IndexedTuple(expr: result, index: num, span: merge_spans(start, end: .previous().span()))
                        }
                        Identifier(name) => {
                            // Struct field access or method call
                            .index++
                            yield match .current() {
                                LParen => {
                                    // NOTE: We step backwards since parse_call() expects to start at the callee identifier.
                                    .index--
                                    let call = .parse_call()
                                    yield ParsedExpression::MethodCall(expr: result, call: call!, span: merge_spans(start, end: .previous().span()))
                                }
                                else => ParsedExpression::IndexedStruct(expr: result, field: name, span: merge_spans(start, end: .current().span()))
                            }
                        }
                        else => {
                            .error("Unsupported dot operation", .current().span())
                            .index++
                            yield result
                        }
                    }
                }
                LSquare => {
                    // Indexing operation
                    .index++
                    let index_expr = .parse_expression(allow_assignments: false)
                    if .current() is RSquare {
                        .index++
                    } else {
                        .error("Expected ']'", .current().span())
                    }
                    yield ParsedExpression::IndexedExpression(
                        base: result,
                        index: index_expr,
                        span: merge_spans(start, .current().span()))
                }
                else => {
                    break
                    // FIXME: This is unreachable.
                    yield result
                }
            }
        }
        return result
    }

    function parse_postfix_colon_colon(mut this, start: Span, expr: ParsedExpression) throws -> ParsedExpression {
        .index++
        mut namespace_: [String] = []
        match expr {
            Var(name) => {
                namespace_.push(name)
            }
            else => {
                .error("Expected namespace", expr.span())
            }
        }
        if .eof() {
            .error("Incomplete static method call", .current().span())
        }
        while not .eof() {
            let current_name = match .current() {
                Identifier(name) => name
                else => {
                    .error("Unsupported static method call", .current().span())
                    return expr
                }
            }
            .index++
            if .current() is LParen {
                .index--
                mut call = .parse_call()
                call!.namespace_ = namespace_
                return ParsedExpression::Call(call: call!, span: merge_spans(expr.span(), .current().span()))
            }
            if .current() is ColonColon {
                match .previous() {
                    Identifier(name) => {
                        namespace_.push(name)
                    }
                    else => {
                        .error("Expected namespace", expr.span())
                    }
                }
                .index++
                continue
            }
            if .current() is LessThan {
                // Generic function arguments
                .index--
                let maybe_call = .parse_call()
                if maybe_call.has_value() {
                    mut call = maybe_call!
                    call.namespace_ = namespace_
                    return ParsedExpression::Call(call, span: merge_spans(expr.span(), .current().span()))
                }
                return ParsedExpression::Garbage(.current().span())
            }
            return ParsedExpression::NamespacedVar(
                name: current_name,
                namespace_,
                span: merge_spans(start, .current().span())
            )
        }
        // FIXME: This is not reachable, so a return should not be required.
        return ParsedExpression::Garbage(.current().span())
    }

    function parse_operator(mut this, allow_assignments: bool) throws -> ParsedExpression {
        let span = .current().span()
        let op = match .current() {
            QuestionMarkQuestionMark => BinaryOperator::NoneCoalescing
            Plus => BinaryOperator::Add
            Minus => BinaryOperator::Subtract
            Asterisk => BinaryOperator::Multiply
            ForwardSlash => BinaryOperator::Divide
            PercentSign => BinaryOperator::Modulo
            And => BinaryOperator::LogicalAnd
            Or => BinaryOperator::LogicalOr
            DoubleEqual => BinaryOperator::Equal
            NotEqual => BinaryOperator::NotEqual
            LessThan => BinaryOperator::LessThan
            LessThanOrEqual => BinaryOperator::LessThanOrEqual
            GreaterThan => BinaryOperator::GreaterThan
            GreaterThanOrEqual => BinaryOperator::GreaterThanOrEqual
            Ampersand => BinaryOperator::BitwiseAnd
            Pipe => BinaryOperator::BitwiseOr
            Caret => BinaryOperator::BitwiseXor
            LeftShift => BinaryOperator::BitwiseLeftShift
            RightShift => BinaryOperator::BitwiseRightShift
            LeftArithmeticShift => BinaryOperator::ArithmeticLeftShift
            RightArithmeticShift => BinaryOperator::ArithmeticRightShift
            Equal => BinaryOperator::Assign
            LeftShiftEqual => BinaryOperator::BitwiseLeftShiftAssign
            RightShiftEqual => BinaryOperator::BitwiseRightShiftAssign
            AmpersandEqual => BinaryOperator::BitwiseAndAssign
            PipeEqual => BinaryOperator::BitwiseOrAssign
            CaretEqual => BinaryOperator::BitwiseXorAssign
            PlusEqual => BinaryOperator::AddAssign
            MinusEqual => BinaryOperator::SubtractAssign
            AsteriskEqual => BinaryOperator::MultiplyAssign
            ForwardSlashEqual => BinaryOperator::DivideAssign
            PercentSignEqual => BinaryOperator::ModuloAssign
            QuestionMarkQuestionMarkEqual => BinaryOperator::NoneCoalescingAssign
            else => {
                return ParsedExpression::Garbage(span)
            }
        }

        .index++

        if not allow_assignments and op.is_assignment() {
            .error("Assignment is not allowed in this position", span)
            return ParsedExpression::Operator(op, span)
        }

        return ParsedExpression::Operator(op, span)
    }

    function parse_match_expression(mut this) throws -> ParsedExpression {
        mut start = .current().span()
        .index++

        let expr = .parse_expression(allow_assignments: false)
        let cases = .parse_match_cases()

        return ParsedExpression::Match(expr, cases, span: merge_spans(start, .previous().span()))
    }

    function parse_match_cases(mut this) throws -> [ParsedMatchCase] {
        mut cases: [ParsedMatchCase] = []

        .skip_newlines()

        if not .current() is LCurly {
            .error("Expected ‘{’", .current().span())
            return cases
        }

        .index++
        .skip_newlines()

        while not .eof() and not .current() is RCurly {
            let pattern_start_index = .index
            let patterns = .parse_match_patterns()

            .skip_newlines()

            let marker_span = .current().span()
            if .current() is FatArrow {
                .index++
            } else {
                .error("Expected ‘=>’", .current().span())
            }

            .skip_newlines()

            let body = match .current() {
                LCurly => ParsedMatchBody::Block(.parse_block())
                else => ParsedMatchBody::Expression(.parse_expression(allow_assignments: false))
            }

            for pattern in patterns.iterator() {
                cases.push(ParsedMatchCase(patterns: [pattern], marker_span, body))
            }

            if .index == pattern_start_index {
                // Parser didn't advance, bail.
                break
            }

            if .current() is Eol or .current() is Comma {
                .index++
            }

            .skip_newlines()
        }

        .skip_newlines()

        if not .current() is RCurly {
            .error("Expected ‘}’", .current().span())
        }

        .index++
        return cases
    }

    function parse_match_patterns(mut this) throws -> [ParsedMatchPattern] {
        mut patterns: [ParsedMatchPattern] = []
        .skip_newlines()
        while not .eof() {
            let pattern = .parse_match_pattern()
            patterns.push(pattern)
            .skip_newlines()
            if .current() is Pipe {
                .index++
                continue
            }
            break
        }
        return patterns
    }

    function parse_match_pattern(mut this) throws -> ParsedMatchPattern => match .current() {
        True
        | False
        | Number
        | QuotedString
        | SingleQuotedString
        | SingleQuotedByteString
        | LParen => ParsedMatchPattern::Expression(.parse_operand())

        Else => {
            .index++
            yield ParsedMatchPattern::CatchAll
        }

        Identifier(name) => {
            let pattern_start_index = .index
            mut variant_name: [(String, Span)] = []

            while not .eof() {
                match .current() {
                    Identifier(name) => {
                        .index++
                        variant_name.push((name, .current().span()))
                    }
                    ColonColon => {
                        .index++
                    }
                    else => {
                        break
                    }
                }
            }

            mut variant_arguments: [EnumVariantPatternArgument] = []
            mut has_parens = false
            let arguments_start = .current().span()

            if .current() is LParen {
                has_parens = true
                .index++

                while not .eof() {
                    match .current() {
                        Identifier(name) => {
                            let arg_name = name
                            if .peek(1) is Colon {
                                .index += 2
                                match .current() {
                                    Identifier(name) => {
                                        let arg_binding = name
                                        let span = .current().span()
                                        .index++
                                        variant_arguments.push(EnumVariantPatternArgument(
                                            name: Some(arg_name)
                                            binding: arg_binding
                                            span))
                                    }
                                    else => {
                                        .error("Expected binding after ‘:’", .current().span())
                                    }
                                }
                            } else {
                                // FIXME: Hack since compiler doesn't recognize `None` in tuple.
                                let none: String? = None
                                variant_arguments.push(EnumVariantPatternArgument(
                                            name: none
                                            binding: arg_name
                                            span: .current().span()))
                                .index++
                            }
                        }
                        Comma => {
                            .index++
                        }
                        RParen => {
                            .index++
                            break
                        }
                        else => {
                            .error("Expected pattern argument name", .current().span())
                            break
                        }
                    }
                }
            }

            let arguments_end = .previous().span()
            let arguments_span = merge_spans(arguments_start, arguments_end)

            yield ParsedMatchPattern::EnumVariant(
                variant_name
                variant_arguments
                arguments_span
            )
        }

        else => {
            .error("Expected pattern or ‘else’", .current().span())
            yield ParsedMatchPattern::CatchAll
        }
    }

    function parse_call(mut this) throws -> ParsedCall? {
        mut call = ParsedCall(
            namespace_: []
            name: ""
            args: []
            type_args: []
        )

        match .current() {
            Identifier(name) => {
                call.name = name
                .index++

                // This is to allow the lookahead. Without it, we may see something like
                // foo < Bar, and think the start of a generic call when it actually isn't.
                let index_reset = .index

                if .current() is LessThan {
                    // Generic type
                    .index++
                    mut inner_types: [ParsedType] = []

                    while not .eof() {
                        match .current() {
                            GreaterThan => {
                                .index++
                                break
                            }
                            Comma | Eol => {
                                .index++
                            }
                            else => {
                                let index_before = .index
                                let inner_type = .parse_typename()
                                if index_before == .index {
                                    // Can't parse further, this is not a generic call.
                                    .index = index_reset;
                                    break
                                }
                                inner_types.push(inner_type)
                            }
                        }
                    }

                    call.type_args = inner_types
                }

                if .current() is LParen {
                    .index++
                } else {
                    .index = index_reset
                    .error("Expected '('", .current().span())
                    return None
                }

                while  not .eof() {
                    match .current() {
                        RParen => {
                            .index++
                            break
                        }
                        Eol | Comma => {
                            .index++
                        }
                        else => {
                            let label_span = .current().span()
                            let label = .parse_argument_label()

                            let expr = .parse_expression(allow_assignments: false)

                            call.args.push((label, label_span, expr))
                        }
                    }
                }
            }
            else => {
                .error("Expected function call", .current().span())
            }
        }

        return call
    }

    function skip_newlines(mut this) {
        while .current() is Eol {
            .index++
        }
    }

    function parse_generic_parameters(mut this) throws -> [ParsedGenericParameter] {
        if not .current() is LessThan {
            return []
        }
        .index++
        mut generic_parameters: [ParsedGenericParameter] = []
        .skip_newlines()
        while not .current() is GreaterThan and not .current() is Garbage {
            match .current() {
                Identifier(name, span) => {
                    generic_parameters.push(ParsedGenericParameter(name, span))
                    .index++
                    if .current() is Comma or .current() is Eol {
                        .index++
                    }
                }
                else => {
                    .error("Expected generic parameter name", .current().span())
                    return generic_parameters
                }
            }
        }

        if .current() is GreaterThan {
            .index++
        } else {
            .error("Expected `>` to end the generic parameters", .current().span())
            return generic_parameters
        }

        return generic_parameters
    }

    function parse_argument_label(mut this) throws -> String {
        // FIXME: Tidy this up once we can match on tuples:
        //        match (.current(), .peek(1)) {
        //            (Name(name), Colon) => ...
        //        }
        if not .peek(1) is Colon {
            return ""
        }
        return match .current() {
            Identifier(name) => {
                .index += 2
                yield name
            }
            else => ""
        }
    }

    function parse_restricted_visibility_modifier(mut this) throws -> Visibility {
        mut restricted_span = .current().span()
        
        .index++

        if .current() is LParen {
            .index++
        } else {
            .error("Expected ‘(’", .current().span())
        }

        mut whitelist: [ParsedType] = []
        mut expect_comma = false

        while .index < .tokens.size() {
            match .current() {
                RParen => {
                    break
                }
                Comma(span) => {
                    if expect_comma {
                        expect_comma = false
                    } else {
                        .error("Unexpected comma", span)
                    }
                    .index++
                }
                else => {
                    if expect_comma {
                        .error("Expected comma", .current().span())
                    }

                    .skip_newlines()
                    let parsed_type = .parse_typename()
                    whitelist.push(parsed_type)
                    expect_comma = true
                }
            }
        }

        restricted_span.end = .current().span().end

        if whitelist.is_empty() {
            .error("Type list cannot be empty", restricted_span)
        }

        if .current() is RParen {
            .index++
        } else {
            .error("Expected ‘)’", .current().span())
        }

        return Visibility::Restricted(whitelist, span: restricted_span)
    }

    function parse_array_or_dictionary_literal(mut this) throws -> ParsedExpression {
        mut is_dictionary = false
        let start = .current().span()

        if not .current() is LSquare {
            .error("Expected ‘[’", .current().span());
            return ParsedExpression::Garbage(.current().span())
        }
        .index++

        mut fill_size_expr: ParsedExpression? = None
        mut output: [ParsedExpression] = []
        mut dict_output: [(ParsedExpression, ParsedExpression)] = []

        while not .eof() {
            match .current() {
                RSquare => {
                    .index++
                    break
                }
                Comma | Eol => {
                    .index++
                }
                Semicolon => {
                    if output.size() == 1 {
                        .index++
                        fill_size_expr = .parse_expression(allow_assignments: false);
                    } else {
                        .error("Can't fill an Array with more than one expression", .current().span())
                        .index++
                    }
                }
                Colon => {
                    .index++
                    if dict_output.is_empty() {
                        if .current() is RSquare {
                            .index++
                            is_dictionary = true
                            break
                        } else {
                            .error("Expected ‘]’", .current().span())
                        }
                    } else {
                        .error("Missing key in dictionary literal", .current().span())
                    }
                }
                else => {
                    let expr = .parse_expression(allow_assignments: false)
                    if expr is Garbage {
                        break
                    }

                    if .current() is Colon {
                        if not output.is_empty() {
                            .error("Mixing dictionary and array values", .current().span())
                        }

                        is_dictionary = true
                        .index++

                        if .eof() {
                            .error("Key missing value in dictionary", .current().span())
                            return ParsedExpression::Garbage(.current().span())
                        }
                        let value = .parse_expression(allow_assignments: false)
                        dict_output.push((expr, value))
                    } else if not is_dictionary {
                        output.push(expr)
                    }
                }
            }
        }

        let end = .index - 1
        if end >= .tokens.size() or not .tokens[end] is RSquare {
            .error("Expected ‘]’ to close the array", .tokens[end].span())
        }

        if is_dictionary {
            return ParsedExpression::JaktDictionary(values: dict_output, span: merge_spans(start, .tokens[end].span()))
        } else {
            return ParsedExpression::JaktArray(values: output, fill_size: fill_size_expr, span: merge_spans(start, .tokens[end].span()))
        }
    }
}

enum FunctionLinkage {
    Internal
    External
}

enum Visibility {
    Public
    Private
    Restricted(whitelist: [ParsedType], span: Span)
}

function parsed_block_equals(anon lhs_block: ParsedBlock, anon rhs_block: ParsedBlock) -> bool {
    if lhs_block.stmts.size() != rhs_block.stmts.size() {
        return false
    }
    for x in 0..lhs_block.stmts.size() {
        let lhs_statement = lhs_block.stmts[x]
        let rhs_statement = rhs_block.stmts[x]
        let are_statements_equal = parsed_statement_equals(lhs_block.stmts[x], rhs_block.stmts[x])
        if not are_statements_equal {
            return false
        }
    }
    return true
}

function parsed_statement_equals(anon lhs_statement: ParsedStatement, anon rhs_statement: ParsedStatement) -> bool => match lhs_statement {
    Expression(expr: lhs_expr) => match rhs_statement {
        Expression(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    Defer(statement: lhs_statement) => match rhs_statement {
        Defer(statement: rhs_statement) => parsed_statement_equals(lhs_statement, rhs_statement)
        else => false
    }
    UnsafeBlock(block: lhs_block) => match rhs_statement {
        UnsafeBlock(block: rhs_block) => parsed_block_equals(lhs_block, rhs_block)
        else => false
    }
    VarDecl(var: lhs_var, init: lhs_init) => match rhs_statement {
        VarDecl(var: rhs_var, init: rhs_init) => parsed_var_decl_equals(lhs_var, rhs_var) and parsed_expression_equals(lhs_init, rhs_init)
        else => false
    }
    If(condition: lhs_condition, then_block: lhs_then_block, else_statement: lhs_else_statement) => match rhs_statement {
        If(condition: rhs_condition, then_block: rhs_then_block, else_statement: rhs_else_statement) => {
            if not (parsed_expression_equals(lhs_condition, rhs_condition) and parsed_block_equals(lhs_then_block, rhs_then_block)) {
                return false
            }
            if not lhs_else_statement.has_value() {
                return not rhs_else_statement.has_value()
            } else {
                if not rhs_else_statement.has_value() {
                    return false
                }
                if parsed_statement_equals(lhs_else_statement!, rhs_else_statement!) {
                    return true
                }
                return false
            }
        }
        else => false
    }
    Block(block: lhs_block) => match rhs_statement {
        Block(block: rhs_block) => parsed_block_equals(lhs_block, rhs_block)
        else => false
    }
    Loop(block: lhs_block) => match rhs_statement {
        Loop(block: rhs_block) => parsed_block_equals(lhs_block, rhs_block)
        else => false
    }
    While(condition: lhs_condition, block: lhs_block) => match rhs_statement {
        While(condition: rhs_condition, block: rhs_block) => parsed_expression_equals(lhs_condition, rhs_condition) and parsed_block_equals(lhs_block, rhs_block)
        else => false
    }
    For(iterator_name: lhs_iterator_name, range: lhs_range, block: lhs_block) => match rhs_statement {
        For(iterator_name: rhs_iterator_name, range: rhs_range, block: rhs_block) => {
            yield lhs_iterator_name == rhs_iterator_name and parsed_expression_equals(lhs_range, rhs_range) and parsed_block_equals(lhs_block, rhs_block)
        }
        else => false
    }
    Break => rhs_statement is Break
    Continue => rhs_statement is Continue
    Return(expr: lhs_expr) => match rhs_statement {
        Return(expr: rhs_expr) => {
            if not lhs_expr.has_value() {
                return not rhs_expr.has_value()
            } else {
                if not rhs_expr.has_value() {
                    return false
                }
                if parsed_expression_equals(lhs_expr!, rhs_expr!) {
                    return true
                }
                return false
            }
        }
        else => false
    }
    Throw(expr: lhs_expr) => match rhs_statement {
        Throw(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    Yield(expr: lhs_expr) =>  match rhs_statement {
        Yield(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    InlineCpp(block: lhs_block) =>  match rhs_statement {
        InlineCpp(block) => parsed_block_equals(lhs_block, block)
        else => false
    }
    Try(stmt: lhs_stmt, error_name: lhs_error_name, catch_block: lhs_catch_block) => match rhs_statement {
        Try(stmt: rhs_stmt, error_name: rhs_error_name, catch_block: rhs_catch_block) => {
            yield lhs_error_name == rhs_error_name and parsed_statement_equals(lhs_stmt, rhs_stmt) and parsed_block_equals(lhs_catch_block, rhs_catch_block)
        }
        else => false
    }
    Garbage => rhs_statement is Garbage
}

function parsed_expression_equals(anon lhs_expression: ParsedExpression, anon rhs_expression: ParsedExpression) -> bool => match lhs_expression {
    Boolean(val: lhs_val) => match rhs_expression {
        Boolean(val: rhs_val) => lhs_val == rhs_val
        else => false
    }
    NumericConstant(val: lhs_val) => match rhs_expression {
        NumericConstant(val: rhs_val) => lhs_val.to_usize() == rhs_val.to_usize()
        else => false
    }
    QuotedString(val: lhs_val) => match rhs_expression {
        QuotedString(val: rhs_val) => lhs_val == rhs_val
        else => false
    }
    SingleQuotedString(val: lhs_val) => match rhs_expression {
        SingleQuotedString(val: rhs_val) => lhs_val == rhs_val
        else => false
    }
    SingleQuotedByteString(val: lhs_val) => match rhs_expression {
        SingleQuotedByteString(val: rhs_val) => lhs_val == rhs_val
        else => false
    }
    Call(call: lhs_call) => match rhs_expression {
        Call(call: rhs_call) => parsed_call_equals(lhs_call, rhs_call)
        else => false
    }
    MethodCall(expr: lhs_expr, call: lhs_call) => match rhs_expression {
        MethodCall(expr: rhs_expr, call: rhs_call) => parsed_expression_equals(lhs_expr, rhs_expr) and parsed_call_equals(lhs_call, rhs_call)
        else => false
    }
    IndexedTuple(expr: lhs_expr, index: lhs_index) => match rhs_expression {
        IndexedTuple(expr: rhs_expr, index: rhs_index) => parsed_expression_equals(lhs_expr, rhs_expr) and lhs_index == rhs_index
        else => false
    }
    IndexedStruct(expr: lhs_expr, field: lhs_field) => match rhs_expression {
        IndexedStruct(expr: rhs_expr, field: rhs_field) => parsed_expression_equals(lhs_expr, rhs_expr) and lhs_field == rhs_field
        else => false
    }
    Var(name: lhs_name) => match rhs_expression {
        Var(name: rhs_name) => lhs_name == rhs_name
        else => false
    }
    IndexedExpression(base: lhs_base, index: lhs_index) => match rhs_expression {
        IndexedExpression(base: rhs_base, index: rhs_index) => parsed_expression_equals(lhs_base, rhs_base) and parsed_expression_equals(lhs_index, rhs_index)
        else => false
    }
    UnaryOp(expr: lhs_expr, op: lhs_op) => match rhs_expression {
        UnaryOp(expr: rhs_expr, op: rhs_op) => parsed_expression_equals(lhs_expr, rhs_expr) and unary_operator_equals(lhs_op, rhs_op)
        else => false
    }
    BinaryOp(lhs: lhs_lhs, op: lhs_op, rhs: lhs_rhs) => match rhs_expression {
        BinaryOp(lhs: rhs_lhs, op: rhs_op, rhs: rhs_rhs) => parsed_expression_equals(lhs_lhs, rhs_lhs) and binary_operator_equals(lhs_op, rhs_op) and parsed_expression_equals(lhs_rhs, rhs_rhs)
        else => false
    }
    Operator(op: lhs_op) => match rhs_expression {
        Operator(op: rhs_op) => binary_operator_equals(lhs_op, rhs_op)
        else => false
    }
    OptionalSome(expr: lhs_expr) => match rhs_expression {
        OptionalSome(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    OptionalNone => rhs_expression is OptionalNone
    JaktArray(values: lhs_values, fill_size: lhs_fill_size) => match rhs_expression {
        JaktArray(values: rhs_values, fill_size: rhs_fill_size) => {
            if not lhs_fill_size.has_value() {
                if rhs_fill_size.has_value() {
                    return false
                }
            } else {
                if not rhs_fill_size.has_value() {
                    return false
                }
                if not parsed_expression_equals(lhs_fill_size!, rhs_fill_size!) {
                    return false
                }
            }
            if not lhs_values.size() == rhs_values.size() {
                return false
            }
            for i in 0..lhs_values.size() {
                if not parsed_expression_equals(lhs_values[i], rhs_values[i]) {
                    return false
                }
            }
            yield true
        }
        else => false
    }
    JaktDictionary(values: lhs_values) => match rhs_expression {
        JaktDictionary(values: rhs_values) => {
            if not lhs_values.size() == rhs_values.size() {
                return false
            }
            for i in 0..lhs_values.size() {
                if not (parsed_expression_equals(lhs_values[i].0, rhs_values[i].0) and parsed_expression_equals(lhs_values[i].1, rhs_values[i].1))  {
                    return false
                }
            }
            yield true
        }
        else => false
    }
    Set(values: lhs_values) => match rhs_expression {
        Set(values: rhs_values) => {
            if not lhs_values.size() == rhs_values.size() {
                return false
            }
            for i in 0..lhs_values.size() {
                if not parsed_expression_equals(lhs_values[i], rhs_values[i]) {
                    return false
                }
            }
            yield true
        }
        else => false
    }
    JaktTuple(values: lhs_values) => match rhs_expression {
        JaktTuple(values: rhs_values) => {
            if not lhs_values.size() == rhs_values.size() {
                return false
            }
            for i in 0..lhs_values.size() {
                if not parsed_expression_equals(lhs_values[i], rhs_values[i]) {
                    return false
                }
            }
            yield true
        }
        else => false
    }
    Range(from: lhs_from, to: lhs_to) => match rhs_expression {
        Range(from: rhs_from, to: rhs_to) => parsed_expression_equals(lhs_from, rhs_from) and parsed_expression_equals(lhs_to, rhs_to)
        else => false
    }
    ForcedUnwrap(expr: lhs_expr) => match rhs_expression {
        ForcedUnwrap(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    Match(expr: lhs_expr) => match rhs_expression {
        // FIXME: compare MachedCases as well
        ForcedUnwrap(expr: rhs_expr) => parsed_expression_equals(lhs_expr, rhs_expr)
        else => false
    }
    NamespacedVar(name: lhs_name, namespace_: lhs_namespace) => match rhs_expression {
        NamespacedVar(name: rhs_name, namespace_: rhs_namespace) => {
            if lhs_namespace.size() != rhs_namespace.size() {
                return false
            }
            for i in 0..lhs_namespace.size() {
                if lhs_namespace[i] != rhs_namespace[i] {
                    return false
                }
            }
            yield lhs_name == rhs_name
        }
        else => false
    }
    Garbage => rhs_expression is Garbage
}

function parsed_var_decl_equals(anon lhs_var_decl: ParsedVarDecl, anon rhs_var_decl: ParsedVarDecl) -> bool {
    return lhs_var_decl.name == rhs_var_decl.name and lhs_var_decl.is_mutable == rhs_var_decl.is_mutable
}

function parsed_call_equals(anon lhs_parsed_call: ParsedCall, anon rhs_parsed_call: ParsedCall) -> bool {
    if lhs_parsed_call.name != rhs_parsed_call.name {
        return false
    }
    if lhs_parsed_call.args.size() != rhs_parsed_call.args.size() {
        return false
    }
    for i in 0..lhs_parsed_call.args.size() {
        let lhs_str = lhs_parsed_call.args[i].0
        let rhs_str = rhs_parsed_call.args[i].0
        let lhs_expr = lhs_parsed_call.args[i].2
        let rhs_expr = rhs_parsed_call.args[i].2
        if (lhs_str != rhs_str) or (not parsed_expression_equals(lhs_expr, rhs_expr)) {
            return false
        }
    }
    return true
}

function unary_operator_equals(anon lhs_op: UnaryOperator, anon rhs_op: UnaryOperator) -> bool => match lhs_op {
    PreIncrement => rhs_op is PreIncrement
    PostIncrement =>  rhs_op is PostIncrement
    PreDecrement => rhs_op is PreDecrement
    PostDecrement => rhs_op is PostDecrement
    Negate => rhs_op is Negate
    Dereference => rhs_op is Dereference
    RawAddress => rhs_op is RawAddress
    LogicalNot => rhs_op is LogicalNot
    BitwiseNot => rhs_op is BitwiseNot
    // FIXME: Compare Types
    TypeCast => match rhs_op {
        TypeCast => true
        else => false
    }
    // FIXME: Compare Types
    Is => match rhs_op {
        Is => true
        else => false
    }
}

function binary_operator_equals(anon lhs_op: BinaryOperator, anon rhs_op: BinaryOperator) -> bool => match lhs_op {
    Add => rhs_op is Add
    Subtract => rhs_op is Subtract
    Multiply => rhs_op is Multiply
    Divide => rhs_op is Divide
    Modulo => rhs_op is Modulo
    LessThan => rhs_op is LessThan
    LessThanOrEqual => rhs_op is LessThanOrEqual
    GreaterThan => rhs_op is GreaterThan
    GreaterThanOrEqual => rhs_op is GreaterThanOrEqual
    Equal => rhs_op is Equal
    NotEqual => rhs_op is NotEqual
    BitwiseAnd => rhs_op is BitwiseAnd
    BitwiseXor => rhs_op is BitwiseXor
    BitwiseOr => rhs_op is BitwiseOr
    BitwiseLeftShift => rhs_op is BitwiseLeftShift
    BitwiseRightShift => rhs_op is BitwiseRightShift
    ArithmeticLeftShift => rhs_op is ArithmeticLeftShift
    ArithmeticRightShift => rhs_op is ArithmeticRightShift
    LogicalOr => rhs_op is LogicalOr
    LogicalAnd => rhs_op is LogicalAnd
    NoneCoalescing => rhs_op is NoneCoalescing
    Assign => rhs_op is Assign
    BitwiseAndAssign => rhs_op is BitwiseAndAssign
    BitwiseOrAssign => rhs_op is BitwiseOrAssign
    BitwiseXorAssign => rhs_op is BitwiseXorAssign
    BitwiseLeftShiftAssign => rhs_op is BitwiseLeftShiftAssign
    BitwiseRightShiftAssign => rhs_op is BitwiseRightShiftAssign
    AddAssign => rhs_op is AddAssign
    SubtractAssign => rhs_op is SubtractAssign
    MultiplyAssign => rhs_op is MultiplyAssign
    ModuloAssign => rhs_op is ModuloAssign
    DivideAssign => rhs_op is DivideAssign
    NoneCoalescingAssign => rhs_op is NoneCoalescingAssign
    Garbage => rhs_op is Garbage
}