// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
//
// SPDX-License-Identifier: BSD-2-Clause

function panic(anon message: String) -> never {
    eprintln("internal error: {}", message)
    abort()
}

function todo(anon message: String) {
    eprintln("TODO: {}", message)
    abort()
}

function join(anon strings: [String], separator: String) -> String {
    mut output = ""
    
    mut i = 0uz
    for s in strings.iterator() {
        output += s
        if i < strings.size() - 1 {
            output += separator
        }
        i++
    }

    return output
}

function prepend_to_each(anon strings: [String], prefix: String) throws -> [String] {
    mut output: [String] = []
    for str in strings.iterator() {
        output.push(prefix + str)
    }
    return output
}

function append_to_each(anon strings: [String], suffix: String) throws -> [String] {
    mut output: [String] = []
    for str in strings.iterator() {
        output.push(str + suffix)
    }
    return output
}

struct Span {
    file_id: FileId
    start: usize
    end: usize

    function contains(this, span: Span) -> bool {
        return .file_id.equals(span.file_id) and span.start >= .start and span.end <= .end
    }

    function is_in_offset_range(this, start: usize, end: usize) => start <= .start and end >= .end
}

struct FileId {
    id: usize

    function equals(this, anon rhs: FileId) -> bool {
        return .id == rhs.id
    }
}

// FIXME: Use jakt stdlib if available
class FilePath {
    public path: String

    public function make(anon filepath: String) throws -> FilePath {
        return FilePath(path: filepath)
    }

    public function dirname(this) throws -> String {
        let parts = .split_at_last_slash()
        if parts.0 == "" {
            return "."
        }

        return parts.0
    }

    public function basename(this) throws -> String {
        let parts = .split_at_last_slash()
        return parts.1
    }

    public function ext(this) throws -> String {
        for i in ((.path.length() - 1)..0).inclusive() {
            let c = .path.byte_at(i)
            if c == b'/' {
                break
            }

            if c == b'.' {
                return .path.substring(start: i + 1, length: (.path.length() - 1 - i))
            }
        }

        return ""
    }

    private function split_at_last_slash(this) throws -> (String, String) {
        let len = .path.length()
        let last_slash = FilePath::last_slash(.path)

        if last_slash.has_value() {
            let dir = .path.substring(start: 0, length: (last_slash!))
            let base = .path.substring(start: (last_slash! + 1), length: (len - last_slash! - 1))
            return (dir, base)
        }

        return ("", .path)
    }


    private function last_slash(anon path: String) -> usize? {
        mut i = path.length() - 1
        while (i >= 1 and path.byte_at(i) != b'/') {
            i--
        }

        if (i == 0 and path.byte_at(i) != b'/') {
            return None
        }

        return i
    }
}

function extend_array<T>(mut target: [T], extend_with: [T]) throws {
    target.add_capacity(extend_with.size())
    for v in extend_with.iterator() {
        target.push(v)
    }
}

function escape_for_quotes(anon s: String) throws -> String {
    mut builder = StringBuilder::create()
    for i in 0..s.length() {
        let c = s.byte_at(i)
        match c {
            b'"' =>  { builder.append_string("\\\"") }
            b'\\' => { builder.append_string("\\\\") }
            b'\n' => { builder.append_string("\\n") }
            else =>  { builder.append(c) }
        }
    }

    return builder.to_string()
}

function interpret_escapes(anon s: String) throws -> String {
    mut builder = StringBuilder::create()
    mut in_escape = false
    for i in 0..s.length() {
        let c = s.byte_at(i)
        match c {
            b'\\' => {
                if in_escape {
                    builder.append(b'\\')
                    in_escape = false
                } else {
                    in_escape = true
                }
            }
            b'"' | b'\'' => {
                if in_escape {
                    builder.append(c)
                    in_escape = false
                }
            }
            b'n' => {
                if in_escape {
                    builder.append(b'\n')
                    in_escape = false
                } else {
                    builder.append(c)
                }
            }
            else => {
                builder.append(c)
                in_escape = false
            }
        }
    }

    return builder.to_string()
}