import error { JaktError }
import parser { BinaryOperator, DefinitionLinkage, DefinitionType, UnaryOperator,
                FunctionLinkage, FunctionType, ParsedBlock, ParsedCall,
                ParsedExpression, ParsedFunction, ParsedNamespace,
                ParsedType, ParsedStatement, ParsedVarDecl, RecordType,
                ParsedRecord, ParsedField, TypeCast }
import utility { panic, todo, Span }

enum SafetyMode {
    Safe
    Unsafe
}

struct ModuleId {
    id: usize

    function equals(this, anon rhs: ModuleId) -> bool {
        return this.id == rhs.id
    }
}

struct VarId {
    module: ModuleId
    id: usize
}

struct FunctionId {
    module: ModuleId
    id: usize
}

struct StructId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: StructId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct EnumId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: EnumId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

enum StructOrEnumId {
    Struct(StructId)
    Enum(EnumId)
}

struct TypeId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: TypeId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function to_string(this) throws -> String {
        return format("{}_{}", .module.id, .id)
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function from_string(anon type_id_string: String) throws -> TypeId {
        let parts = type_id_string.split('_')
        if not (parts.size() == 2) {
            throw Error::from_errno(999) // FIXME: good error message
        }

        let module_id = parts[0].to_uint()
        let type_id = parts[1].to_uint()
        if module_id.has_value() or not type_id.has_value() {
            throw Error::from_errno(9999) // FIXME: good error message
        }

        return TypeId(module: ModuleId(id: module_id.value() as! usize), id: type_id.value() as! usize)
    }
}

struct ScopeId {
    module: ModuleId
    id: usize

    function equals(this, anon other: ScopeId) -> bool {
        return this.module.id == other.module.id and this.id == other.id
    }
}

enum BuiltinType: usize {
    Void = 0
    Bool = 1
    U8 = 2
    U16 = 3
    U32 = 4
    U64 = 5
    I8 = 6
    I16 = 7
    I32 = 8
    I64 = 9
    F32 = 10
    F64 = 11
    Usize = 12
    String = 13
    CChar = 14
    CInt = 15
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    TypeVariable(String)
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    RawPtr(TypeId)

    function equals(this, anon rhs: Type) -> bool {
        if this is Void and rhs is Void {
            return true
        } else if this is Bool and rhs is Bool {
            return true
        } else if this is U8 and rhs is U8 {
            return true
        } else if this is U16 and rhs is U16 {
            return true
        } else if this is U32 and rhs is U32 {
            return true
        } else if this is U64 and rhs is U64 {
            return true
        } else if this is I8 and rhs is I8 {
            return true
        } else if this is I16 and rhs is I16 {
            return true
        } else if this is I32 and rhs is I32 {
            return true
        } else if this is I64 and rhs is I64 {
            return true
        } else if this is F32 and rhs is F32 {
            return true
        } else if this is F64 and rhs is F64 {
            return true
        } else if this is Usize and rhs is Usize {
            return true
        } else if this is JaktString and rhs is JaktString {
            return true
        } else if this is CChar and rhs is CChar {
            return true
        } else if this is CInt and rhs is CInt {
            return true
        } else {
            match this {
                TypeVariable(lhs_name) => {
                    match rhs {
                        TypeVariable(rhs_name) => {
                            return lhs_name == rhs_name
                        }
                        else => {
                            return false
                        }
                    }
                }
                GenericInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                GenericEnumInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericEnumInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                Struct(lhs_id) => {
                    match rhs {
                        Struct(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                Enum(lhs_id) => {
                    match rhs {
                        Enum(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                RawPtr(lhs_id) => {
                    match rhs {
                        RawPtr(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                else => {
                    return false
                }
            }
            return false
        }
    }

    function is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt => true
        else => false
    }

    function get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    function is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    function min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    function max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }
}

class Scope {
    public namespace_name: String?
    public vars: [String: VarId]
    public structs: [String: StructId]
    public functions: [String: FunctionId]
    public enums: [String: EnumId]
    public types: [String: TypeId]
    public imports: [String: (ModuleId, Span)]
    public parent: ScopeId?
    public children: [ScopeId]
    public can_throw: bool
}

class Module {
    public id: ModuleId
    public name: String
    public functions: [CheckedFunction]
    public structures: [CheckedStruct]
    public enums: [CheckedEnum]
    public scopes: [Scope]
    public types: [Type]
    public variables: [CheckedVariable]
    public imports: [ModuleId]

    public is_root: bool

    public function new_type_variable(mut this) throws -> TypeId {
        let new_id = .types.size()

        .types.push(Type::TypeVariable(format("T{}", new_id)))

        return TypeId(module: .id, id: new_id)
    }

    public function add_function(mut this, checked_function: CheckedFunction) throws -> FunctionId {
        let new_id = .functions.size()

        .functions.push(checked_function)

        return FunctionId(module: .id, id: new_id)
    }

    public function add_variable(mut this, anon checked_variable: CheckedVariable) throws -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

class CheckedFunction {
    public name: String
    public name_span: Span
    public return_type_id: TypeId
    public params: [CheckedParameter]
    public generic_params: [FunctionGenericParameter]
    public block: CheckedBlock
    public can_throw: bool
    public type: FunctionType
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId

    public function is_static(this) -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public function is_mutating(this) -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

enum FunctionGenericParameter {
    InferenceGuide(TypeId)
    Parameter(TypeId)
}

struct CheckedVariable {
    name: String
    type_id: TypeId
    is_mutable: bool
    definition_span: Span
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

struct CheckedBlock {
    statements: [CheckedStatement]
    scope_id: ScopeId
    definitely_returns: bool
    yielded_type: TypeId?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    fields: [VarId]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    type_id: TypeId
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    variants: [CheckedEnumVariant]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
}

enum CheckedEnumVariant {
    Untyped(name: String, span: Span)
    Typed(name: String, type_id: TypeId, span: Span)
    WithValue(name: String, expr: CheckedExpression, span: Span)
    StructLike(name: String, fields: [VarId], span: Span)
}

boxed enum CheckedStatement {
    Expression(CheckedExpression)
    Defer(CheckedStatement)
    VarDecl(var_id: VarId, init: CheckedExpression)
    If(condition: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?)
    Block(CheckedBlock)
    Loop(CheckedBlock)
    While(condition: CheckedExpression, block: CheckedBlock)
    Return(CheckedExpression?)
    Break
    Continue
    Throw(CheckedExpression)
    Yield(CheckedExpression)
    Try(stmt: CheckedStatement, error_name: String, catch_block: CheckedBlock)
    InlineCpp([String])
    Garbage
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    function can_fit_number(this, type_id: TypeId, program: CheckedProgram) -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                    yield false
                }
                F64 => true
                else => false
            }
        }
    }
}
// FIXME: Make this a member function of NumberConstant.
//        Right now we cannot do that as the compiler does not know the CheckedNumericConstant
//        constructors when we use them in a member function (https://github.com/SerenityOS/jakt/issues/677).
function promote(anon num_const: NumberConstant, type_id: TypeId, program: CheckedProgram) -> CheckedNumericConstant? {
    if not num_const.can_fit_number(type_id, program) {
        return None
    }

    let bits = program.get_bits(type_id)
    let is_signed = program.is_signed(type_id)
    let new_constant = match num_const {
        Signed(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value as! u64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Unsigned(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value as! i64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Floating(value) => match is_signed {
            true => match bits {
                32 => {
                    todo("Add conversion from f64 to f32")
                    yield CheckedNumericConstant::I64(0)
                }
                64 => CheckedNumericConstant::F64(value)
                else => {
                    panic("Floating numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => {
                panic("Floating numeric constant cannot be unsigned")
                yield CheckedNumericConstant::I64(0)
            }
        }
    }

    return new_constant
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    // FIXME: make this into a FAMF (fat arrow match function) once we can yield `None` out of the match (https://github.com/SerenityOS/jakt/issues/669)
    //          or once we can cast f32 to f64
    function number_constant(this) -> NumberConstant? {
        match this {
            I8(value) => { return NumberConstant::Signed(value as! i64) }
            I16(value) => { return NumberConstant::Signed(value as! i64) }
            I32(value) => { return NumberConstant::Signed(value as! i64) }
            I64(value) => { return NumberConstant::Signed(value as! i64) }
            U8(value) => { return NumberConstant::Unsigned(value as! u64) }
            U16(value) => { return NumberConstant::Unsigned(value as! u64) }
            U32(value) => { return NumberConstant::Unsigned(value as! u64) }
            U64(value) => { return NumberConstant::Unsigned(value as! u64) }
            USize(value) => { return NumberConstant::Unsigned(value as! u64) }

            // FIXME: add a case for F32 once we can cast f32 to f64

            F64(value) => { return NumberConstant::Floating(value) }
            else => {}
        }

        return None
    }
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)

    function type_id(this) -> TypeId => match this {
        Fallible(type_id) => type_id
        Infallible(type_id) => type_id
    }
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(String)
}

enum CheckedMatchBody {
    Expression(CheckedExpression)
    Block(CheckedBlock)
}

enum CheckedMatchCases {
    EnumVariant(name: String, args: [(String?, String, Span)], subject_type_id: TypeId, index: usize, scope_id: ScopeId, body: CheckedMatchBody, marker_span: Span)
    Expression(expression: CheckedExpression, body: CheckedMatchBody, marker_span: Span)
    CatchAll(body: CheckedMatchBody, marker_span: Span)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: String, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression, to: CheckedExpression, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: Span, type_id: TypeId)
    Match(expr: CheckedExpression, match_cases: [CheckedMatchCases], span: Span, type_id: TypeId, all_variants_constant: bool)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Garbage(Span)

    // FIXME: rewrite this into a FAMF once we can yield None out of a match (https://github.com/SerenityOS/jakt/issues/669)
    function to_number_constant(this, program: CheckedProgram) -> NumberConstant? {
        match this {
            NumericConstant(val, span, type_id) => { return val.number_constant() }
            UnaryOp(expr, op, span, type_id) => {
                match op {
                    TypeCast(cast) => {
                        if not cast is Infallible {
                            return None
                        }
                        if not program.is_integer(type_id) and not program.is_floating(type_id) {
                            return None
                        }
                        match expr {
                            NumericConstant(val, span: span_, type_id: type_id_) => { return val.number_constant() }
                            else => {}
                        }
                    }
                    else => {}
                }
            }
            else => {}
        }
        return None
    }
}

function expression_type(anon expr: CheckedExpression) -> TypeId => match expr {
    Boolean => builtin(BuiltinType::Bool)
    NumericConstant(type_id) => type_id
    QuotedString => builtin(BuiltinType::String)
    ByteConstant => builtin(BuiltinType::U8)
    CharacterConstant => builtin(BuiltinType::CChar)
    UnaryOp(type_id) => type_id
    BinaryOp(type_id) => type_id
    JaktTuple(type_id) => type_id
    Range(type_id) => type_id
    JaktArray(type_id) => type_id
    JaktDictionary(type_id) => type_id
    JaktSet(type_id) => type_id
    IndexedExpression(type_id) => type_id
    IndexedDictionary(type_id) => type_id
    IndexedTuple(type_id) => type_id
    IndexedStruct(type_id) => type_id
    Call(type_id) => type_id
    MethodCall(type_id) => type_id
    NamespacedVar(var) => var.type_id
    Var(var) => var.type_id
    OptionalNone(type_id) => type_id
    OptionalSome(type_id) => type_id
    ForcedUnwrap(type_id) => type_id
    Match(type_id) => type_id
    Block(type_id) => type_id
    Garbage => builtin(BuiltinType::Void)
}

function checked_expression_definitely_returns(anon check_expression: CheckedExpression) -> bool {
    mut ret = false

    match check_expression {
        Match(expr, match_cases, span, type_id, all_variants_constant) => {
            mut case_ret = true
            for case_ in match_cases.iterator() {
                match case_ {
                    EnumVariant(body) => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                    Expression(body)  => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                    CatchAll(body)  => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                }
            }
            ret = case_ret
        }
        else => {
            return false
        }
    }
    return ret
}

struct ResolvedNamespace {
    name: String
    generic_parameters: [TypeId]?
}

struct CheckedCall {
    namespace_: [ResolvedNamespace]
    name: String,
    args: [(String, CheckedExpression)]
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool
}

function unknown_type_id() -> TypeId => TypeId(module: ModuleId(id: 0), id: 0)

function builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin as! usize)
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    public modules: [Module]

    public function get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public function get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public function get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public function get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public function get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public function get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public function get_scope(this, anon id: ScopeId) -> Scope => .modules[id.module.id].scopes[id.id]

    public function is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public function is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public function is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public function get_bits(this, anon type_id: TypeId) => .get_type(type_id).get_bits()

    public function is_signed(this, anon type_id: TypeId) => .get_type(type_id).is_signed()
}

struct Typechecker {
    program: CheckedProgram
    current_module_id: ModuleId
    current_struct_type_id: TypeId?
    current_function_id: FunctionId?
    inside_defer: bool
    errors: [JaktError]

    function typecheck(parsed_namespace: ParsedNamespace, errors: [JaktError]) throws -> CheckedProgram {
        let root_module_id = ModuleId(id: 0)
        let module = Module(
            id: root_module_id,
            name: parsed_namespace.name ?? "Root Module",
            functions: [],
            structures: [],
            enums: [],
            scopes: [],
            types: [
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
            ],
            variables: [],
            imports: [],
            is_root: true,
        )

        let none_type_id: TypeId? = None
        let none_function_id: FunctionId? = None

        mut typechecker = Typechecker(
            program: CheckedProgram(modules: [module]),
            current_module_id: root_module_id,
            current_struct_type_id: none_type_id
            current_function_id: none_function_id
            inside_defer: false
            errors
        )

        let none: ScopeId? = None
        typechecker.create_scope(parent_scope_id: none, can_throw: false)

        typechecker.typecheck_module(parsed_namespace, scope_id: ScopeId(module: root_module_id, id: 0))

        return typechecker.program
    }

    function get_function(this, anon id: FunctionId) => .program.get_function(id)
    function get_variable(this, anon id: VarId) => .program.get_variable(id)
    function get_type(this, anon id: TypeId) => .program.get_type(id)
    function get_enum(this, anon id: EnumId) => .program.get_enum(id)
    function get_struct(this, anon id: StructId) => .program.get_struct(id)
    function get_scope(this, anon id: ScopeId) => .program.get_scope(id)

    function current_module(this) => .program.get_module(.current_module_id)

    function error(mut this, anon message: String, anon span: Span) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function is_integer(this, anon type_id: TypeId) => .program.is_integer(type_id)
    function is_floating(this, anon type_id: TypeId) => .program.is_floating(type_id)
    function is_numeric(this, anon type_id: TypeId) => .program.is_numeric(type_id)

    function create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool) throws -> ScopeId {
        // Check that parent_scope_id is a valid ScopeId
        if parent_scope_id.has_value() {
            // Check that the ModuleId is valid
            if parent_scope_id!.module.id >= .program.modules.size() {
                panic(format("create_scope: parent_scope_id.module is invalid! No module with id {}.", parent_scope_id!.module.id))
                return ScopeId(module: ModuleId(id: 0), id: 0)
            }

            // Check that ScopeId.id is valid in the module
            if parent_scope_id!.id >= .program.modules[parent_scope_id!.module.id].scopes.size() {
                panic(format("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}.", parent_scope_id!.module.id, parent_scope_id!.id))
                return ScopeId(module: ModuleId(id: 0), id: 0)
            }
        }

        let none_string: String? = None

        let scope = Scope(
            namespace_name: none_string
            vars: [:]
            structs: [:]
            functions: [:]
            enums: [:]
            types: [:]
            imports: [:]
            parent: parent_scope_id
            children: []
            can_throw
        )

        .program.modules[.current_module_id.id].scopes.push(scope)

        return ScopeId(module: .current_module_id, id: .program.modules[.current_module_id.id].scopes.size() - 1)
    }

    function find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // FIXME: Remove this short-circuit once we actually start parsing the prelude!
        return StructId(module: ModuleId(id: 0), id: 0)

        // start at the prelude scope id
        let scope_id = ScopeId(module: ModuleId(id: 0), id: 0)
        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return struct_id.value()
        }

        panic(format("internal error: {} builtin definition not found", name))
        return StructId(module: ModuleId(id: 0), id: 0)
    }

    function find_type_in_prelude(this, anon name: String) throws -> TypeId {
        // FIXME: Remove this short-circuit once we actually start parsing the prelude!
        return TypeId(module: ModuleId(id: 0), id: 0)

        // start at the prelude scope id
        let scope_id = ScopeId(module: ModuleId(id: 0), id: 0)
        let type_id = .find_type_in_scope(scope_id, name)
        if type_id.has_value() {
            return type_id.value()
        }
        panic(format("internal error: {} builtin definition not found", name))
        return TypeId(module: ModuleId(id: 0), id: 0)
    }

    function try_to_promote_constant_expr_to_type(mut this, lhs_type: TypeId, checked_rhs: CheckedExpression, span: Span) throws -> CheckedExpression? {
        if not .is_integer(lhs_type) {
            return None
        }

        let rhs_constant_opt = checked_rhs.to_number_constant(program: .program)
        if not rhs_constant_opt.has_value() {
            return None
        }
        let rhs_constant = rhs_constant_opt!

        let result = promote(rhs_constant, type_id: lhs_type, program: .program)
        if not result.has_value() {
            let type = .get_type(lhs_type)
            .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type.min(), type.max(), .type_name(lhs_type)), span)
            return None
        }
        let new_constant = result!

        return CheckedExpression::NumericConstant(val: new_constant, span, type_id: lhs_type)
    }

    function type_name(this, anon type_id: TypeId) throws -> String {
        let type = .get_type(type_id)

        return match type {
            F32 => "f32"
            F64 => "f64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            Void => "void"
            JaktString => "String"
            Enum(id) => .get_enum(id).name
            Struct(id) => .get_struct(id).name
            GenericEnumInstance(id, args) => {
                mut output = format("enum {}", .get_enum(id).name)

                output += "<"
                mut first = true
                for arg in args.iterator() {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg)
                }

                output += ">"

                yield output
            }
            GenericInstance(id, args) => {
                // FIXME: remove prelude_struct_id debugging branch once prelude is added
                let prelude_struct_id = StructId(module: ModuleId(id:0), id:0)

                let array_struct_id = .find_struct_in_prelude("Array")
                let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
                let optional_struct_id = .find_struct_in_prelude("Optional")
                let range_struct_id = .find_struct_in_prelude("Range")
                let set_struct_id = .find_struct_in_prelude("Set")
                let tuple_struct_id = .find_struct_in_prelude("Tuple")
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                mut output = ""

                if id.equals(prelude_struct_id) {
                    mut arg_names: [String] = []
                    for type_id in args.iterator() {
                        arg_names.push(.type_name(type_id))
                    }
                    output = format("TODO prelude struct: {}, args: {}", id, arg_names)
                } else if id.equals(array_struct_id) {
                    output = format("[{}]", .type_name(args[0]))
                } else if id.equals(dictionary_struct_id) {
                    output = format("[{}:{}]", .type_name(args[0]), .type_name(args[1]))
                } else if id.equals(optional_struct_id) {
                    output = format("{}?", .type_name(args[0]))
                } else if id.equals(range_struct_id) {
                    output = format("{}..{}", .type_name(args[0]), .type_name(args[0]))
                } else if id.equals(set_struct_id) {
                    output = format("{{{}}}", .type_name(args[0]))
                } else if id.equals(tuple_struct_id) {
                    output = "("
                    mut first = true
                    for arg in args.iterator() {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(type_id)
                    }
                    output += "}"
                } else if id.equals(weak_ptr_struct_id) {
                    output = format("weak {}?", .type_name(args[0]))
                } else {
                    let structure = .get_struct(id)
                    output = structure.name
                    output += "<"
                    mut first = true
                    for arg in args.iterator() {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(type_id)
                    }
                    output += ">"
                }

                yield output
            }
            TypeVariable(name) => name
            RawPtr(type_id) => format("raw {}", .type_name(type_id))
        }
    }

    // FIXME: not a method of expression because of https://github.com/SerenityOS/jakt/issues/527
    function expression_span(this, anon expr: CheckedExpression) -> Span => match expr {
        Boolean(span) => span
        NumericConstant(span) => span
        QuotedString(span) => span
        ByteConstant(span) => span
        CharacterConstant(span) => span
        UnaryOp(span) => span
        BinaryOp(span) => span
        JaktTuple(span) => span
        Range(span) => span
        JaktArray(span) => span
        JaktDictionary(span) => span
        JaktSet(span) => span
        IndexedExpression(span) => span
        IndexedDictionary(span) => span
        IndexedTuple(span) => span
        IndexedStruct(span) => span
        Call(span) => span
        MethodCall(span) => span
        NamespacedVar(span) => span
        Var(span) => span
        OptionalNone(span) => span
        OptionalSome(span) => span
        ForcedUnwrap(span) => span
        Match(span) => span
        Block(span) => span
        Garbage(span) => span
    }

    function expression_is_mutable(this, anon expr: CheckedExpression) -> bool => match expr {
        Var(var) => var.is_mutable
        IndexedStruct(expr) => .expression_is_mutable(expr)
        IndexedExpression(expr) => .expression_is_mutable(expr)
        IndexedTuple(expr) => .expression_is_mutable(expr)
        IndexedDictionary(expr) => .expression_is_mutable(expr)
        ForcedUnwrap(expr) => .expression_is_mutable(expr)
        else => false
    }

    function unify(mut this, lhs: TypeId, lhs_span: Span, rhs: TypeId, rhs_span: Span) throws -> TypeId? {
        // FIXME: Add more unification logic
        if lhs.id != rhs.id {
            .error("types incompatible ", rhs_span)
            return None
        } else {
            return lhs
        }
    }

    function find_or_add_type_id(mut this, anon type: Type) throws -> TypeId {
        let module = .program.modules[.current_module_id.id]
        let module_id = module.id

        mut idx = 0uz
        for item in module.types.iterator() {
            if item.equals(type) {
                return TypeId(module: module_id, id: idx)
            }
            ++idx
        }

        idx = 0uz
        for item in .program.modules[0].types.iterator() {
            if item.equals(type) {
                return TypeId(module: .program.modules[0].id, id: idx)
            }
            ++idx
        }

        .program.modules[.current_module_id.id].types.push(type)

        return TypeId(module: module_id, id: .program.modules[.current_module_id.id].types.size() - 1)
    }

    function find_type_in_scope(this, scope_id: ScopeId, name: String) -> TypeId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)

            for type in scope.types.iterator() {
                if type.0 == name {
                    return type.1
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    function find_enum_in_scope(this, scope_id: ScopeId, name: String) -> EnumId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)

            for enum_ in scope.enums.iterator() {
                if enum_.0 == name {
                    return enum_.1
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    // Find the namespace in the current scope, or one of its parents,
    // and whether the found scope was an import.
    function find_namespace_in_scope(this, scope_id: ScopeId, name: String) -> (ScopeId, bool)? {
        mut current = scope_id;

        loop {
            let scope = .get_scope(current)

            for child in scope.children.iterator() {
                let child_scope = .get_scope(child)
                if child_scope.namespace_name.has_value() {
                    if name == child_scope.namespace_name.value() {
                        return (child, false)
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        // if we do not find it then check imports
        let module_id = current.module

        for imp in .get_scope(ScopeId(module: module_id, id: 0)).imports.iterator() {
            if name == imp.0 {
                let value = imp.1
                return (ScopeId(module: value.0, id: 0), true)
            }
        }

        return None
    }

    function add_struct_to_scope(mut this, scope_id: ScopeId, name: String, struct_id: StructId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)

        if scope.structs.contains(name) {
            let existing_struct_id = scope.structs[name]
            let definition_span = .get_struct(existing_struct_id).name_span

            .error_with_hint(
                format("redefinition of struct/class {}", name)
                span
                format("struct/class {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.structs.set(key: name, value: struct_id)
        return true
    }

    function add_enum_to_scope(mut this, scope_id: ScopeId, name: String, enum_id: EnumId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)

        if scope.enums.contains(name) {
            let existing_enum_id = scope.enums[name]
            let definition_span = .get_enum(existing_enum_id).name_span

            .error_with_hint(
                format("redefinition of enum {}", name)
                span
                format("enum {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.enums.set(key: name, value: enum_id)
        return true
    }

    function add_type_to_scope(mut this, scope_id: ScopeId, type_name: String, type_id: TypeId, span: Span) throws -> bool {
        mut scope = .get_scope(id: scope_id)
        let found_type_id = .find_type_in_scope(scope_id, name: type_name)
        if found_type_id.has_value() {
            // FIXME: Show hint of the original definition, once we store the name span.
            .error(
                format("Redefinition of type ‘{}’", type_name)
                span
            )
            return false
        }
        scope.types.set(key: type_name, value: type_id)
        return true
    }

    function add_function_to_scope(mut this, parent_scope_id: ScopeId, name: String, function_id: FunctionId, span: Span) throws -> bool {
        mut scope = .get_scope(id: parent_scope_id)
        for existing_function in scope.functions.iterator() {
            if name == existing_function.0 {
                // FIXME: Show hint of the original definition, once we store the name span.
                .error(format("Redefinition of function ‘{}’", name), span)
                return false
            }
        }
        scope.functions.set(key: name, value: function_id)
        return true
    }

    function add_var_to_scope(mut this, scope_id: ScopeId, name: String, var_id: VarId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        for existing_var in scope.vars.iterator() {
            if name == existing_var.0 {
                // FIXME: Show hint of the original definition, once we store the name span.
                .error(format("Redefinition of variable ‘{}’", name), span)
            }
        }
        scope.vars.set(key: name, value: var_id)
        return true
    }
    
    function find_function_in_scope(this, parent_scope_id: ScopeId, function_name: String) -> FunctionId? {
        mut scope_id = Some(parent_scope_id)
        while scope_id.has_value() {
            let scope = .get_scope(id: scope_id!)
            for s in scope.functions.iterator() {
                if s.0 == function_name {
                    return Some(s.1)
                }
            }

            if scope.parent.has_value() {
                if scope_id!.equals(scope.parent!) {
                    mut msg = ""
                    try {
                        msg = format("Scope {} is its own parent!", scope_id)
                    } catch error {
                        msg = "Scope is its own parent!"
                    }

                    panic(msg)
                }
            }

            scope_id = scope.parent
        }

        return None
    }

    function find_struct_in_scope(this, scope_id: ScopeId, name: String) -> StructId? {
        mut current_scope_id = Some(scope_id)
        while current_scope_id.has_value() {
            let scope = .get_scope(id: current_scope_id!)
            for s in scope.structs.iterator() {
                if s.0 == name {
                    return Some(s.1)
                }
            }
            current_scope_id = scope.parent
        }
        return None
    }

    function typecheck_module(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        .typecheck_namespace_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_fields(parsed_namespace, scope_id)
        .typecheck_namespace_declarations(parsed_namespace, scope_id)
    }

    function typecheck_namespace_fields(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for namespce in parsed_namespace.namespaces.iterator() {
            let namespace_name = namespce.name
            mut namespace_scope_id = ScopeId(module: ModuleId(id: 0), id: 0)
            if namespace_name.has_value() {
                // Typecheck struct fields in the named namespaces
                let namespace_scope_tuple = .find_namespace_in_scope(scope_id, name: namespace_name!)
                if not namespace_scope_tuple.has_value() {
                    panic(format("can't find previously added namespace {}", namespace_name!))
                }
                namespace_scope_id = namespace_scope_tuple!.0
            } else {
                // Typecheck struct fields in the unnamed namespace
                namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
                mut scope = .get_scope(scope_id)
                scope.children.push(namespace_scope_id)
            }

            .typecheck_namespace_fields(parsed_namespace: namespce, scope_id: namespace_scope_id)
        }

        for record in parsed_namespace.records.iterator() {
            if record.record_type is Struct {
                let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                if not struct_id.has_value() {
                    panic("can't find previously added struct")
                }
                .typecheck_struct_fields(record, struct_id: struct_id!)
            }
        }
    }

    function typecheck_struct_fields(mut this, record: ParsedRecord, struct_id: StructId) throws {
        mut structure = .get_struct(struct_id)

        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let parsed_fields = match record.record_type {
            Struct(fields) => fields
            Class(fields) => fields
            else => {
                panic("typecheck_struct_fields cannot handle non-structs")
                let none: [ParsedField] = []
                yield none
            }
        }

        for unchecked_member in parsed_fields.iterator() {
            let parsed_var_decl = unchecked_member.var_decl
            let checked_member_type = .typecheck_typename(parsed_type: parsed_var_decl.parsed_type, scope_id: checked_struct_scope_id)

            mut module = .current_module()
            let var_id = module.add_variable(checked_variable: CheckedVariable(
                name: parsed_var_decl.name
                type_id: checked_member_type
                is_mutable: parsed_var_decl.is_mutable
                definition_span: parsed_var_decl.span
            ))
            structure.fields.push(var_id)
        }
    }

    function typecheck_namespace_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let module_struct_len = .current_module().structures.size()
        let module_enum_len = .current_module().enums.size()

        // 1. Initialize structs
        mut struct_index: usize = 0
        mut enum_index: usize = 0
        for parsed_record in parsed_namespace.records.iterator() {
            match parsed_record.record_type {
                Struct | Class => { .typecheck_struct_predecl_initial(parsed_record, struct_index: struct_index++, module_struct_len, scope_id) }
                SumEnum => {}
                ValueEnum => { .typecheck_value_enum_predecl_initial(parsed_record, enum_index: enum_index++, module_enum_len, scope_id) }
                else => {
                    todo(format("typecheck_namespace_predecl: else {}", parsed_record.record_type))
                }
            }
        }
        // 2. Typecheck subnamespaces
        for namespce in parsed_namespace.namespaces.iterator() {
            // Find all predeclarations in namespaces that are children of this namespace
            if namespce.name.has_value() {
                let namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

                mut child_scope = .get_scope(namespace_scope_id)
                child_scope.namespace_name = namespce.name!

                mut parent_scope = .get_scope(scope_id)
                parent_scope.children.push(namespace_scope_id)

                .typecheck_namespace_predecl(parsed_namespace: namespce, scope_id: namespace_scope_id)
            }
        }
        // 3. Typecheck struct predeclaration
        struct_index = 0
        enum_index = 0
        for parsed_record in parsed_namespace.records.iterator() {
            let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
            match parsed_record.record_type {
                Struct | Class => {
                    .typecheck_struct_predecl(parsed_record, struct_id, scope_id)
                    struct_index++
                }
                SumEnum => {}
                ValueEnum => {
                    let enum_id = EnumId(module: .current_module_id, id: enum_index++ + module_enum_len)
                    .typecheck_value_enum_predecl(parsed_record, enum_id, scope_id)
                }
                else => {
                    todo(format("typecheck_namespace_predecl: else {}", parsed_record.record_type))
                }
            }
        }
        // 4. Typecheck functions
        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function_predecl(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_value_enum_predecl_initial(mut this, parsed_record: ParsedRecord, enum_index: usize, module_enum_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
        mut module = .current_module()
        module.types.push(Type::Enum(enum_id))

        let enum_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: enum_type_id, span: parsed_record.name_span)

        // Add a placeholder entry, this will be replaced later.
        module.enums.push(CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            scope_id: ScopeId(module: ModuleId(id: 0), id: 0)
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id: enum_type_id
            type_id: enum_type_id
        ))
    }

    function typecheck_value_enum_predecl(mut this, parsed_record: ParsedRecord, enum_id: EnumId, scope_id: ScopeId) throws {
        let enum_type_id = .find_or_add_type_id(type: Type::Enum(enum_id))

        let enum_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

        .add_enum_to_scope(scope_id, name: parsed_record.name, enum_id, span: parsed_record.name_span)

        let underlying_type_id = match parsed_record.record_type {
            ValueEnum(underlying_type) => .typecheck_typename(parsed_type: underlying_type, scope_id)
            else => builtin(BuiltinType::Void)
        }

        mut module = .current_module()
        module.enums[enum_id.id] = CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            scope_id: enum_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id
            type_id: enum_type_id
        )

        mut generic_parameters: [TypeId] = module.enums[enum_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: enum_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }
    }

    function typecheck_struct_predecl(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {

        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let struct_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

        .add_struct_to_scope(scope_id, name: parsed_record.name, struct_id, span: parsed_record.name_span)

        let is_extern = parsed_record.definition_linkage

        mut module = .current_module()
        module.structures[struct_id.id] = CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: struct_scope_id
            definition_linkage: is_extern
            record_type: parsed_record.record_type
            type_id: struct_type_id
        )

        mut generic_parameters: [TypeId] = module.structures[struct_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: struct_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        for method in parsed_record.methods.iterator() {
            let func = method.parsed_function

            let method_scope_id = .create_scope(parent_scope_id: struct_scope_id, can_throw: func.can_throw)
            let block_scope_id = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw)

            let is_generic = not parsed_record.generic_parameters.is_empty() or not func.generic_parameters.is_empty()

            let none_type_id: TypeId? = None
            mut checked_function = CheckedFunction(
                name: func.name
                name_span: func.name_span
                return_type_id: unknown_type_id()
                params: []
                generic_params: []
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    definitely_returns: false
                    yielded_type: none_type_id
                )
                can_throw: func.can_throw
                type: func.type
                linkage: func.linkage
                function_scope_id: method_scope_id
            )

            module.functions.push(checked_function)
            let function_id = FunctionId(
                module: .current_module_id
                id: .current_module().functions.size() - 1
            )
            let previous_index = .current_function_id
            .current_function_id = function_id

            mut check_scope: ScopeId? = None
            if is_generic {
                check_scope = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw)
            }

            for gen_parameter in func.generic_parameters.iterator() {
                module.types.push(Type::TypeVariable(gen_parameter.name))
                let type_var_type_id = TypeId(
                    module: .current_module_id
                    id: .current_module().types.size() - 1
                )

                checked_function.generic_params.push(FunctionGenericParameter::Parameter(type_var_type_id))
                .add_type_to_scope(scope_id: method_scope_id, type_name: gen_parameter.name, type_id: type_var_type_id, span: gen_parameter.span)
            }

            for param in func.params.iterator() {
                if param.variable.name == "this" {
                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: struct_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                    )

                    checked_function.params.push(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                } else {
                    let param_type = .typecheck_typename(parsed_type: param.variable.parsed_type, scope_id: method_scope_id)

                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: param_type
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                    )

                    checked_function.params.push(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                }
            }

            .add_function_to_scope(
                parent_scope_id: struct_scope_id
                name: func.name
                function_id: FunctionId(module: .current_module_id, id: .current_module().functions.size() - 1)
                span: parsed_record.name_span
            )

            let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: method_scope_id)

            checked_function.return_type_id = function_return_type_id

            if is_generic {
                if not check_scope.has_value() {
                    panic("Generic method with generic parameters must have a check scope")
                }

                let block = .typecheck_block(parsed_block: func.block, parent_scope_id: check_scope!, safety_mode: SafetyMode::Safe)

                mut return_type_id: TypeId = builtin(BuiltinType::Void)
                if function_return_type_id.equals(unknown_type_id()) {
                    if not block.statements.is_empty() {
                        let ret = block.statements[block.statements.size() - 1]
                        // expression_type
                        match ret {
                            Return(val) => {
                                if val.has_value() {
                                    return_type_id = .resolve_type_var(type_var_type_id: expression_type(val!), scope_id: method_scope_id)
                                }
                            }
                            else => {}
                        }
                    }
                } else {
                    return_type_id = .resolve_type_var(type_var_type_id: function_return_type_id, scope_id)
                }

                checked_function.block = block
                checked_function.return_type_id = return_type_id
            }

            module.functions[function_id.id] = checked_function
            .current_function_id = previous_index
        }

        module.structures[struct_id.id].generic_parameters = generic_parameters

        .current_struct_type_id = None
    }

    function typecheck_struct_predecl_initial(mut this, parsed_record: ParsedRecord, struct_index: usize, module_struct_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
        mut module = .current_module()
        module.types.push(Type::Struct(struct_id))

        let struct_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: struct_type_id, span: parsed_record.name_span)

        // Add a placeholder entry, this will be replaced later.
        module.structures.push(CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: ScopeId(module: ModuleId(id: 0), id: 0)
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
        ))
    }

    function typecheck_namespace_declarations(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for namespce in parsed_namespace.namespaces.iterator() {
            mut namespace_scope_id: ScopeId = ScopeId(module: ModuleId(id: 0), id: 0)
            if namespce.name.has_value() {
                // Finish typecheck of the named namespaces
                let namespace_name = namespce.name!
                let namespace_scope_tuple = .find_namespace_in_scope(scope_id, name: namespace_name)

                if not namespace_scope_tuple.has_value() {
                    panic("can't find previously added namespace")
                }
                namespace_scope_id = namespace_scope_tuple!.0
            } else {
                // Create the unnamed namespace (aka a block scope)
                namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
                mut scope = .get_scope(scope_id)
                scope.children.push(namespace_scope_id)

                .typecheck_namespace_predecl(parsed_namespace: namespce, scope_id: namespace_scope_id)
            }
            .typecheck_namespace_declarations(parsed_namespace: namespce, scope_id: namespace_scope_id)
        }

        for record in parsed_namespace.records.iterator() {
            match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        panic("can't find struct that has been previous added")
                    }
                    .typecheck_struct(record, struct_id: struct_id!, parent_scope_id: scope_id)
                }
                SumEnum => {}
                ValueEnum => {
                    let enum_id = .find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        panic("can't find enum that has been previous added")
                    }
                    .typecheck_enum(record, enum_id: enum_id!, parent_scope_id: scope_id)
                }
                else => {
                    todo(format("typecheck_namespace_declarations implement parsion of record type {}", record.record_type))
                }
            }
        }

        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_enum(mut this, record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        mut checked_variants: [CheckedEnumVariant] = []
        mut next_constant_value = 0u64
        mut seen_names: [String] = [] // FIXME: HashSet

        let enum_ = .get_enum(enum_id)

        match record.record_type {
            ValueEnum(underlying_type, variants) => {
                let underlying_type_id = .typecheck_typename(parsed_type: underlying_type, scope_id: parent_scope_id)
                mut module = .current_module()
                for variant in variants.iterator() {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                    } else {
                        seen_names.push(variant.name)

                        let expr = match variant.value.has_value() {
                            true => .cast_to_underlying(variant.value!, scope_id: parent_scope_id, parsed_type: underlying_type)
                            else => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(next_constant_value++), span: variant.span, type_id: underlying_type_id)
                        }

                        checked_variants.push(CheckedEnumVariant::WithValue(name: variant.name, expr, span: variant.span))
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant.name
                            type_id: underlying_type_id
                            is_mutable: false
                            definition_span: variant.span
                        ))
                        .add_var_to_scope(scope_id: enum_.scope_id, name: variant.name, var_id, span: variant.span)
                    }
                }
                module.enums[enum_id.id].variants = checked_variants
            }
            else => {}
        }
    }

    function cast_to_underlying(mut this, anon expr: ParsedExpression, scope_id: ScopeId, parsed_type: ParsedType) throws -> CheckedExpression {
        let cast_expression = ParsedExpression::UnaryOp(expr, op: UnaryOperator::TypeCast(TypeCast::Infallible(parsed_type)), span: expr.span())
        return .typecheck_expression(cast_expression, scope_id, safety_mode: SafetyMode::Safe)
    }

    function typecheck_struct(mut this, record: ParsedRecord, struct_id: StructId, parent_scope_id: ScopeId) throws {
        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        let module_id = .current_module_id
        .current_struct_type_id = struct_type_id

        let constructor_id = .find_function_in_scope(parent_scope_id: checked_struct_scope_id, function_name: record.name)
        if constructor_id.has_value() {
            if record.record_type is Class and record.definition_linkage is External {
                // XXX: The parser always sets the linkage type of an extern class'
                //      constructor to External, but we actually want to call the
                //      class' ::create function, just like we do with a
                //      ImplicitConstructor class.
                mut func = .get_function(constructor_id!)
                func.linkage = FunctionLinkage::External
            }
        } else if not record.definition_linkage is External {
            // No constructor found, so let's make one

            let constructor_can_throw = record.record_type is Class
            let function_scope_id = .create_scope(parent_scope_id, can_throw: constructor_can_throw)
            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: constructor_can_throw)

            let none_type_id: TypeId? = None
            let checked_constructor = CheckedFunction(
                name: record.name
                name_span: record.name_span
                return_type_id: struct_type_id
                params: []
                generic_params: []
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    definitely_returns: false
                    yielded_type: none_type_id
                )
                can_throw: constructor_can_throw
                type: FunctionType::ImplicitConstructor
                linkage: FunctionLinkage::Internal
                function_scope_id
            )

            // Internal constructor
            mut module = .current_module()
            module.functions.push(checked_constructor)

            mut func = module.functions[module.functions.size() - 1]
            for field_id in .get_struct(struct_id).fields.iterator() {
                let field = .get_variable(field_id)
                func.params.push(CheckedParameter(
                    requires_label: true
                    variable: field
                ))
            }

            // Add constructor to the struct's scope
            .add_function_to_scope(
                parent_scope_id: checked_struct_scope_id
                name: record.name
                function_id: FunctionId(module: module_id, id: .current_module().functions.size() - 1)
                span: record.name_span
            )
        }

        for method in record.methods.iterator() {
            .typecheck_method(func: method.parsed_function, parent_id: StructOrEnumId::Struct(struct_id))
        }

        .current_struct_type_id = None
    }

    function typecheck_method(mut this, func: ParsedFunction, parent_id: StructOrEnumId) throws {
        mut parent_generic_parameters: [TypeId] = []
        mut scope_id = ScopeId(module: ModuleId(id: 0), id: 0)
        mut definition_linkage = DefinitionLinkage::Internal

        match parent_id {
            Struct(struct_id) => {
                mut structure = .get_struct(struct_id)
                parent_generic_parameters = structure.generic_parameters
                scope_id = structure.scope_id
                definition_linkage = structure.definition_linkage
            }
            Enum => {
                todo("typecheck_method implement enum case")
            }
        }

        if (not func.generic_parameters.is_empty() or not parent_generic_parameters.is_empty()) and not func.must_instantiate {
            return
        }

        let structure_scope_id = scope_id
        let structure_linkage = definition_linkage

        let method_id = .find_function_in_scope(parent_scope_id: structure_scope_id, function_name: func.name)
        if not method_id.has_value() {
            panic("we just pushed the checked function, but it's not present")
        }

        mut checked_function = .get_function(method_id!)
        let function_scope_id = checked_function.function_scope_id

        mut module = .current_module()
        for param in checked_function.params.iterator() {
            let variable = param.variable
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Set current function index before a block type check so that
        // method return type is checked against its implementation
        .current_function_id = method_id

        let VOID_TYPE_ID = builtin(BuiltinType::Void)

        let block = .typecheck_block(parsed_block: func.block, parent_scope_id: function_scope_id, safety_mode: SafetyMode::Safe)
        let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: function_scope_id)

        mut return_type_id = function_return_type_id
        if function_return_type_id.equals(unknown_type_id()) and not block.statements.is_empty() {
            // If the return type is unknown, and the function starts with a return statement,
            // we infer the return type from its expression.
            match block.statements[0] {
                Return(ret) => {
                    if ret.has_value() {
                        return_type_id = expression_type(ret!)
                    } else {
                        return_type_id = VOID_TYPE_ID
                    }
                }
                else => {
                    return_type_id = VOID_TYPE_ID
                }
            }
        } else if function_return_type_id.equals(unknown_type_id()) {
            return_type_id = VOID_TYPE_ID
        }

        if not structure_linkage is External and not return_type_id.equals(VOID_TYPE_ID) and not block.definitely_returns {
            // FIXME: Use better span
            .error("Control reaches end of non-void function", func.name_span)
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function typecheck_function_predecl(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        let function_scope_id = .create_scope(parent_scope_id, can_throw: parsed_function.can_throw)
        let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: parsed_function.can_throw)
        let module_id = .current_module_id.id

        // TODO: Make this true if it's a method of a generic class/struct.
        let is_generic = not parsed_function.generic_parameters.is_empty()

        let none_type_id: TypeId? = None

        mut checked_function = CheckedFunction(
            name: parsed_function.name
            name_span: parsed_function.name_span
            return_type_id: unknown_type_id()
            params: []
            generic_params: []
            block: CheckedBlock(
                statements: []
                scope_id: block_scope_id
                definitely_returns: false
                yielded_type: none_type_id
            )
            can_throw: parsed_function.can_throw
            type: FunctionType::Normal
            linkage: parsed_function.linkage
            function_scope_id
        )
        // FIXME: We can't return a `mut Foo` from a function right now, but assigning anything to a `mut` variable makes it mutable.
        //        AKA, working around one bug with another bug. :^)
        mut current_module = .current_module()
        let function_id = current_module.add_function(checked_function)
        let checked_function_scope_id = checked_function.function_scope_id

        // Check generic parameters
        for generic_parameter in parsed_function.generic_parameters.iterator() {

            current_module.types.push(Type::TypeVariable(generic_parameter.name))

            let type_var_type_id = TypeId(
                module: current_module.id
                id: current_module.types.size() - 1
            )
            checked_function.generic_params.push(FunctionGenericParameter::Parameter(type_var_type_id))

            let external_linkage = match parsed_function.linkage {
                FunctionLinkage::External => true
                else => false
            }
            if not parsed_function.must_instantiate or external_linkage {
                .add_type_to_scope(
                    scope_id: checked_function_scope_id
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }
        }

        // Check parameters
        for parameter in parsed_function.params.iterator() {
            let type_id = .typecheck_typename(parsed_type: parameter.variable.parsed_type, scope_id: checked_function_scope_id)

            let variable = CheckedVariable(
                name: parameter.variable.name
                type_id
                is_mutable: parameter.variable.is_mutable
                definition_span: parameter.variable.span
            )

            let checked_parameter = CheckedParameter(
                requires_label: parameter.requires_label
                variable
            )

            checked_function.params.push(checked_parameter)
        }

        // Check return type
        checked_function.return_type_id = .typecheck_typename(parsed_type: parsed_function.return_type, scope_id: checked_function_scope_id)

        .add_function_to_scope(parent_scope_id, name: parsed_function.name, function_id, span: parsed_function.name_span)
    }

    function typecheck_jakt_main(mut this, parsed_function: ParsedFunction) throws {
        let param_type_error = "Main function must take a single array of strings as its parameter"
        if parsed_function.params.size() > 1 {
            .error(param_type_error, parsed_function.name_span)
        }

        if not parsed_function.params.is_empty() {
            match parsed_function.params[0].variable.parsed_type {
                ParsedType::JaktArray(inner, span) => {
                    match inner {
                        ParsedType::Name(name, span) => {
                            if (name != "String") {
                                .error(param_type_error, span)
                            }
                        }
                        else => {
                            .error(param_type_error, span)
                        }
                    }
                }
                else => {
                    .error(param_type_error, parsed_function.name_span)
                }
            }
        }

        let return_type_error = "Main function must return c_int"
        match parsed_function.return_type {
            ParsedType::Empty => {}
            ParsedType::Name(name, span) => {
                if name != "c_int" {
                    .error(return_type_error, span)
                }
            }
            else => {
                .error(return_type_error, parsed_function.return_type_span)
            }
        }
    }

    function typecheck_function(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        if not parsed_function.generic_parameters.is_empty() and not parsed_function.must_instantiate {
            return
        } 

        // FIXME: Optional.expect("...") would be nicer here.
        let function_id = .find_function_in_scope(parent_scope_id, function_name: parsed_function.name)
        if not function_id.has_value() {
            panic("Internal error: missing previously defined function")
        }
        if parsed_function.name == "main" {
            .typecheck_jakt_main(parsed_function)
        }
        mut checked_function = .get_function(function_id!)
        let function_scope_id = checked_function.function_scope_id
        let function_linkage = checked_function.linkage

        mut param_vars: [CheckedVariable] = []

        for param in checked_function.params.iterator() {
            param_vars.push(param.variable)
        }

        for variable in param_vars.iterator() {
            mut module = .current_module()
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Resolve concrete types
        mut function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
        )
        checked_function.return_type_id = function_return_type_id

        // TODO: Typecheck function block
        let block = .typecheck_block(
            parsed_function.block
            parent_scope_id: function_scope_id
            safety_mode: SafetyMode::Safe
        )

        // Typecheck return type a second time to resolve generics
        function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
        )

        // Infer return type if necessary
        // If the return type is unknown, and the function starts with a return statement,
        // we infer the return type from its expression.
        let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)
        let VOID_TYPE_ID = builtin(BuiltinType::Void)
        mut return_type_id = VOID_TYPE_ID
        if function_return_type_id.equals(UNKNOWN_TYPE_ID) {
            if block.statements.is_empty() {
                return_type_id = VOID_TYPE_ID
            } else {
                let last_stmt: CheckedStatement = block.statements[block.statements.size() - 1]
                match last_stmt {
                    CheckedStatement::Return(ret) => {
                        if ret.has_value() {
                            return_type_id = expression_type(expr: ret.value())
                        }
                    }
                    else => {
                        return_type_id = VOID_TYPE_ID
                    }
                }
            }
        } else {
            return_type_id = .resolve_type_var(
                type_var_type_id: function_return_type_id,
                scope_id: function_scope_id
            )
        }

        let external_linkage = match function_linkage {
            FunctionLinkage::External => true
            else => false
        }
        if not external_linkage and not return_type_id.equals(VOID_TYPE_ID) and not block.definitely_returns
        {
            // FIXME: Use better span
            .error("Control reaches end of non-void function", parsed_function.name_span)
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function statement_definitely_returns(this, anon statement: CheckedStatement) -> bool => match statement{
        Return(expr) => true
        // FIXME: CheckedStatement::If branches ugly implementation due to current compiler limitations
        If(condition, then_block, else_statement) => {
            mut ret = false
            let condition_result = match condition {
                Boolean(val) => {
                    if val and then_block.definitely_returns {
                        ret = true
                    }
                    yield ret
                }
                else => false
            }
            if not condition_result and else_statement.has_value(){
                if then_block.definitely_returns and .statement_definitely_returns(else_statement.value()) {
                    ret = true
                }
            }
            yield ret
        }
        Block(block) => block.definitely_returns
        Loop(block) => block.definitely_returns
        While(condition, block) => block.definitely_returns
        Expression(match_expr) => match match_expr {
            Match() => checked_expression_definitely_returns(match_expr)
            else => false
        }
        else => false
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function check_types_for_compat(mut this, lhs_type_id: TypeId, rhs_type_id: TypeId, mut generic_inferences: [String:String], span: Span) throws -> bool {
        let lhs_type = .get_type(lhs_type_id)

        let lhs_type_id_string = lhs_type_id.to_string()
        let rhs_type_id_string = rhs_type_id.to_string()

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

        
        match lhs_type {
            TypeVariable() => {
                // If the call expects a generic type variable, let's see if we've already seen it
                let seen_type_id_string = generic_inferences.get(lhs_type_id_string)
                if seen_type_id_string.has_value() {
                    // We've seen this type variable assigned something before
                    // we should error if it's incompatible.

                    if seen_type_id_string.value() != rhs_type_id_string {
                        .error(
                            format(
                                "Type mismatch: expected ‘{}’, but got ‘{}’"
                                .type_name(TypeId::from_string(seen_type_id_string.value()))
                                .type_name(rhs_type_id)
                            )
                            span
                        )
                        return false
                    }
                } else {
                    generic_inferences.set(key: lhs_type_id_string, value: rhs_type_id_string)
                }
            }
            GenericEnumInstance(id, args) => {
                let lhs_enum_id = id
                let lhs_args = args
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        let rhs_enum_id = id
                        let rhs_args = args
                        if lhs_enum_id.equals(rhs_enum_id) {
                            let lhs_enum = .get_enum(lhs_enum_id)
                            if lhs_args.size() != rhs_args.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_args[idx]
                                    rhs_type_id: rhs_args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            GenericInstance(id, args) => {
                let lhs_struct_id = id
                let lhs_args = args

                // If lhs is T? or weak T? and rhs is T, skip type compat check
                if (lhs_struct_id.equals(optional_struct_id)) or 
                    (lhs_struct_id.equals(weakptr_struct_id)) {
                    if lhs_args.size() > 0 {
                        if (lhs_args[0].equals(rhs_type_id)) {
                            return true
                        }
                    }
                }

                let rhs_type = .get_type(rhs_type_id)

                match rhs_type {
                    GenericInstance(id, args) => {
                        let rhs_struct_id = id
                        if lhs_struct_id.equals(rhs_struct_id) {
                            let rhs_args = args
                            let lhs_struct = .get_struct(lhs_struct_id)
                            if lhs_args.size() != rhs_args.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_args[idx]
                                    rhs_type_id: rhs_args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        } else {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Enum(enum_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        if enum_id.equals(id) {
                            let lhs_enum = .get_enum(enum_id)
                            if args.size() != lhs_enum.generic_parameters.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_enum.generic_parameters[idx]
                                    rhs_type_id: args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Struct(lhs_struct_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericInstance(id, args) => {
                        let lhs_struct = .get_struct(lhs_struct_id)
                        if args.size() != lhs_struct.generic_parameters.size() {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_struct.generic_parameters[idx]
                                rhs_type_id: args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }

                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            RawPtr(lhs_rawptr_type_id) => {
                if lhs_rawptr_type_id.equals(rhs_type_id) {
                    return true
                }

                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    RawPtr(rhs_rawptr_type_id) => {
                        if not .check_types_for_compat(
                            lhs_type_id: lhs_rawptr_type_id
                            rhs_type_id: rhs_rawptr_type_id
                            generic_inferences
                            span
                        ) {
                            // FIXME: maybe emit secondary error?
                            return false
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            else => {
                if not rhs_type_id.equals(lhs_type_id) {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
        }

        return true
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: [String: String]) throws -> TypeId {
        mut result = .substitute_typevars_in_type_helper(type_id, generic_inferences)

        loop {
            let fixed_point = .substitute_typevars_in_type_helper(type_id, generic_inferences)

            if fixed_point.equals(result) {
                break
            } else {
                result = fixed_point
            }
        }
        return result
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function substitute_typevars_in_type_helper(mut this, type_id: TypeId , generic_inferences: [String: String]) throws -> TypeId {
        let type_ = .get_type(type_id)

        match type_ {
            TypeVariable() => {
                let replacment_type_id_string = generic_inferences.get(type_id.to_string())
                if replacment_type_id_string.has_value() {
                    return TypeId::from_string(replacment_type_id_string.value())
                }
            }
            GenericInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args.iterator() {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                }

                return .find_or_add_type_id(Type::GenericInstance(id, args: new_args))
            }
            GenericEnumInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args.iterator() {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                }
                return .find_or_add_type_id(Type::GenericEnumInstance(id, args: new_args))
            }
            Struct(struct_id) => {
                let struct_ = .get_struct(struct_id)
                if not struct_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(struct_.generic_parameters.size())
                    for arg in struct_.generic_parameters.iterator() {
                        new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                    }
                    return .find_or_add_type_id(Type::GenericInstance(id: struct_id, args: new_args))
                }
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                if not enum_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(enum_.generic_parameters.size())
                    for arg in enum_.generic_parameters.iterator() {
                        new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                    }
                    return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id, args: new_args))
                }
            }
            RawPtr(rawptr_type_id) => {
                let rawptr_type = Type::RawPtr(
                    .substitute_typevars_in_type(type_id: rawptr_type_id, generic_inferences)
                )
                return .find_or_add_type_id(rawptr_type)
            }
            else => {
                return type_id
            }
        }
        return type_id
    }

    function typecheck_block(mut this, anon parsed_block: ParsedBlock, parent_scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedBlock {
        let parent_throws = .get_scope(parent_scope_id).can_throw
        let block_scope_id = .create_scope(parent_scope_id, can_throw: parent_throws)
        let none_type_id: TypeId? = None
        mut checked_block = CheckedBlock(
            statements: []
            scope_id: block_scope_id
            definitely_returns: false
            yielded_type: none_type_id
        )
        // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
        mut generic_inferences: [String: String] = [:]

        for parsed_statement in parsed_block.stmts.iterator() {

            let checked_statement = .typecheck_statement(
                statement: parsed_statement
                scope_id: block_scope_id
                safety_mode
            )

            // check that statment definitly returns
            checked_block.definitely_returns = .statement_definitely_returns(checked_statement)

            let none_yield: Span? = None // FIXME: Can't yield None directly
            let yield_span: Span? = match parsed_statement {
                ParsedStatement::Yield(expr) => Some(expr.span())
                else => none_yield
            }
            let  none_expr: CheckedExpression? = None // FIXME: Can't yield None directly
            let checked_yield_expression: CheckedExpression? = match checked_statement {
                CheckedStatement::Yield(expr) => Some(expr)
                else => none_expr
            }
            if yield_span.has_value() and checked_yield_expression.has_value() {
                let type_var_type_id = expression_type(checked_yield_expression.value())
                let type_ = .resolve_type_var(type_var_type_id , scope_id: block_scope_id)
                if checked_block.yielded_type.has_value() {
                    // TODO check types for compat
                    .check_types_for_compat(
                        lhs_type_id: checked_block.yielded_type.value()
                        rhs_type_id: type_
                        generic_enferences: generic_inferences
                        span: yield_span.value()
                    )
                } else {
                    checked_block.yielded_type = Some(type_)
                }
            }

            checked_block.statements.push(checked_statement)
        }

        if checked_block.yielded_type.has_value() {
             checked_block.yielded_type = Some(.substitute_typevars_in_type(
                 type_id: checked_block.yielded_type.value()
                 generic_inferences
             ))
        }

        return checked_block
    }

    function typecheck_typename(mut this, parsed_type: ParsedType, scope_id: ScopeId) throws -> TypeId { 
        match parsed_type {
            NamespacedName(name, namespaces, params, span) => {
                mut current_namespace_scope_id = scope_id

                for ns in namespaces.iterator() {
                    let result = .find_namespace_in_scope(scope_id: current_namespace_scope_id, name: ns)

                    if result.has_value() {
                        current_namespace_scope_id = result!.0
                    } else {
                        .error(format("Unknown namespace: '{}'", ns), span)
                        return unknown_type_id()
                    }
                }

                mut generic_args: [TypeId] = []

                for param in params.iterator() {
                    let checked_arg = .typecheck_typename(parsed_type: param, scope_id)

                    generic_args.push(checked_arg)
                }

                // TODO: add synthetic type_name and generic support

                return .typecheck_typename(parsed_type, scope_id)
            }
            Name(name, span) => {
                return match name {
                    "i8" => builtin(BuiltinType::I8)
                    "i16" => builtin(BuiltinType::I16)
                    "i32" => builtin(BuiltinType::I32)
                    "i64" => builtin(BuiltinType::I64)
                    "u8" => builtin(BuiltinType::U8)
                    "u16" => builtin(BuiltinType::U16)
                    "u32" => builtin(BuiltinType::U32)
                    "u64" => builtin(BuiltinType::U64)
                    "f32" => builtin(BuiltinType::F32)
                    "f64" => builtin(BuiltinType::F64)
                    "c_char" => builtin(BuiltinType::CChar)
                    "c_int" => builtin(BuiltinType::CInt)
                    "usize" => builtin(BuiltinType::Usize)
                    "String" => builtin(BuiltinType::String)
                    "bool" => builtin(BuiltinType::Bool)
                    "void" => builtin(BuiltinType::Void)
                    else => {
                        let type_id = .find_type_in_scope(scope_id, name)

                        if type_id.has_value() {
                            return type_id.value()
                        } else {
                            .error(format("Unknown type ‘{}’", name), span)
                            return unknown_type_id()
                        }
                    }
                }
            }
            Empty => {
                return unknown_type_id()
            }
            JaktTuple(types, span) => {
                mut checked_types: [TypeId] = []
                for parsed_type in types.iterator() {
                    checked_types.push(.typecheck_typename(parsed_type, scope_id))
                }
                let tuple_struct_id = .find_struct_in_prelude("Tuple")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

                return type_id
            }
            JaktArray(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let array_struct_id = .find_struct_in_prelude("Array")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))

                return type_id
            }
            Dictionary(key, value, span) => {
                let key_type_id = .typecheck_typename(parsed_type: key, scope_id)
                let value_type_id = .typecheck_typename(parsed_type: value, scope_id)

                let dict_struct_id = .find_struct_in_prelude("Dictionary")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: dict_struct_id, args: [key_type_id, value_type_id]))

                return type_id
            }
            Set(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let set_struct_id = .find_struct_in_prelude("Set")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [inner_type_id]))

                return type_id
            }
            Optional(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let optional_struct_id = .find_struct_in_prelude("Optional")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [inner_type_id]))

                return type_id
            }
            WeakPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: weakptr_struct_id, args: [inner_type_id]))

                return type_id
            }
            RawPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let type_id = .find_or_add_type_id(Type::RawPtr(id: inner_type_id))

                return type_id
            }
            GenericType(name, generic_parameters, span) => {
                mut checked_inner_types: [TypeId] = []

                for inner_type in generic_parameters.iterator() {
                    let inner_type_id = .typecheck_typename(parsed_type, scope_id)
                    checked_inner_types.push(inner_type_id)
                }
                // FIXME: add support for "GenericResolvedType", though the Rust version
                // puts this in the parser even though it should be in the typechecker
                // as the parser doesn't have a concept of type ids
                return unknown_type_id()
            }
        }
        // FIXME: This is unreachable but the generated C++ causes a warning.
        panic("should be unreachable")
        return unknown_type_id()
    }

    function typecheck_unary_operation(mut this, checked_expr: CheckedExpression, checked_op: CheckedUnaryOperator, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let expr_type_id = expression_type(checked_expr)
        let expr_type = .get_type(expr_type_id)

        match checked_op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                if .is_integer(expr_type_id) {
                    if not .expression_is_mutable(checked_expr) {
                        .error("Increment/decrement of immutable variable", span)
                    }
                } else {
                    .error("Increment/decrement of non-numeric value", span)
                }
            }
            LogicalNot | BitwiseNot => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            TypeCast(cast) => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: cast.type_id())
            }
            Negate => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            else => {
                todo(format("typecheck_unary_operation: expr:{}, op:{}", checked_expr, checked_op))
            }
        }
        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
    }

    function typecheck_binary_operation(mut this, checked_lhs: CheckedExpression, op: BinaryOperator, checked_rhs: CheckedExpression, scope_id: ScopeId, span: Span) throws -> TypeId {
        let lhs_type_id = expression_type(checked_lhs)
        let rhs_type_id = expression_type(checked_rhs)

        let lhs_span = .expression_span(checked_lhs)
        let rhs_span = .expression_span(checked_rhs)

        mut type_id = expression_type(checked_lhs)

        match op {
            NoneCoalescing | NoneCoalescingAssign => {
                // 1. LHS must be Optional<T>.
                // 2. RHS must be Optional<T> or T.
                // 3. Resulting type is Optional<T> or T, respectively.

                // if an assignment, the LHS must be a mutable variable.
                if op is NoneCoalescingAssign {
                    match checked_lhs {
                        Var(var, span) => {
                            if not var.is_mutable {
                                .error_with_hint(message: "left-hand side of ??= must be a mutable variable", span, hint: "This variable isn't marked as mutable", hint_span: var.definition_span)
                                return unknown_type_id()
                            }
                        }
                        else => {
                            .error(message: "left-hand side of ??= must be a mutable variable", span)
                            return unknown_type_id()
                        }
                    }
                }

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        if id.equals(optional_struct_id) {
                            // Success: LHS is T? and RHS is T?.
                            if lhs_type_id.equals(rhs_type_id) {
                                return lhs_type_id
                            }

                            // Extract T from Optional<T>.
                            let inner_type_id = args[0]

                            if inner_type_id.equals(rhs_type_id) {
                                // Success: LHS is T? and RHS is T.
                                return inner_type_id
                            }
                        } else {
                            .error_with_hint(format(
                                "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            ), span,
                            "Left side of ?? must be an Optional but isn't",
                            lhs_span)
                        }
                    }
                    else => {
                        .error_with_hint(format(
                            "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                            .type_name(lhs_type_id),
                            .type_name(rhs_type_id),
                        ), span,
                        "Left side of ?? must be an Optional but isn't",
                        lhs_span)
                    }
                }

                .error(format(
                    "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                    .type_name(lhs_type_id),
                    .type_name(rhs_type_id),
                ), span)

                return lhs_type_id
            }
            LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Equal | NotEqual => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format("Binary comparison between incompatible types ({} vs {})", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            LogicalAnd | LogicalOr => {
                if not lhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("left side of logical binary operation is not a boolean", lhs_span)
                }

                if not rhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("right side of logical binary operation is not a boolean", rhs_span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            Assign => {
                if not .expression_is_mutable(checked_lhs) {
                    .error("Assignment to immutable variable", span)
                    return lhs_type_id
                }
                match checked_rhs {
                    OptionalNone(span, type_id) => {
                        let lhs_type = .get_type(lhs_type_id)
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        match lhs_type {
                            GenericInstance(id, args) => {
                                if id.equals(optional_struct_id) {
                                    return lhs_type_id
                                }
                            }
                            else => {}
                        }
                    }
                    else => {}
                }

                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format("Assignment between incompatible types (‘{}’ and ‘{}’)", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }
                return result.value_or(lhs_type_id)
            }
            AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign | BitwiseAndAssign | BitwiseOrAssign | BitwiseXorAssign | BitwiseLeftShiftAssign | BitwiseRightShiftAssign => {
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        if id.equals(weak_ptr_struct_id) {
                            let inner_type_id = args[0]
                            match .get_type(inner_type_id) {
                                Type::Struct(struct_id: lhs_struct_id) => {
                                    match .get_type(rhs_type_id) {
                                        Type::Struct(struct_id: rhs_struct_id) => {
                                            if lhs_struct_id.equals(rhs_struct_id) {
                                                return lhs_type_id
                                            }
                                        }
                                        else => {}
                                    }
                                }
                                else => {}
                            }
                        }

                        if not lhs_type_id.equals(rhs_type_id) {
                            .error(format(
                                "Assignment between incompatible types (‘{}’ and ‘{}’)",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            ), span)
                        }

                        if not .expression_is_mutable(checked_lhs) {
                            .error("Assignment to immutbale variable", span)
                        }
                    }
                    else => {}
                }
            }
            Add | Subtract | Multiply | Divide | Modulo => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format(
                        "Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ),
                    span)
                }

                type_id = lhs_type_id
            }
            else => {}
        }

        return type_id
    }

    function typecheck_statement(mut this, anon statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement => match statement {
        Expression(expr) => CheckedStatement::Expression(expr: .typecheck_expression(expr, scope_id, safety_mode))
        UnsafeBlock(parsed_block) => CheckedStatement::Block(.typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode: SafetyMode::Unsafe))
        Yield(expr) => CheckedStatement::Yield(.typecheck_expression(expr, scope_id, safety_mode))
        Return(expr, span) => .typecheck_return(expr, span, scope_id, safety_mode)
        Block(parsed_block) => .typecheck_block_statement(parsed_block, scope_id, safety_mode)
        InlineCpp(block, span) => .typecheck_inline_cpp(block, span, safety_mode)
        Defer(statement, span) => .typecheck_defer(statement, scope_id, safety_mode, span)
        Loop(parsed_block) => .typecheck_loop(parsed_block, scope_id, safety_mode)
        Try(stmt, error_name, error_span, catch_block) => .typecheck_try(stmt, error_name, error_span, catch_block, scope_id, safety_mode)
        Throw(expr) => .typecheck_throw(expr, scope_id, safety_mode)
        While(condition, block) => .typecheck_while(condition, block, scope_id, safety_mode)
        Continue => CheckedStatement::Continue
        Break => CheckedStatement::Break
        VarDecl(var, init) => .typecheck_var_decl(var, init, scope_id, safety_mode)
        If(condition, then_block, else_statement) => .typecheck_if(condition, then_block, else_statement, scope_id, safety_mode)
        Garbage => CheckedStatement::Garbage
        For(iterator_name, name_span, range, block) => .typecheck_for(iterator_name,  name_span, range, block, scope_id, safety_mode)
    }

    function typecheck_for(mut this, iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let maybe_span = block.find_yield_span()
        if maybe_span.has_value() {
            .error("a 'for' loop block is not allowed to yield values", maybe_span!)
        }


        // Translate `for x in expr { body }` to
        // block {
        //     let (mutable) _magic = expr
        //     loop {
        //         let x = _magic.next()
        //         if not x.has_value() {
        //             break
        //         }
        //         let iterator_name = x!
        //         body
        //     }
        // }
        //
        // The only restrictions placed on the iterator are such:
        //     1- Must respond to .next(); the mutability of the iterator is inferred from .next()'s signature
        //     2- The result of .next() must be an Optional.

        // TODO: when optional type hint is available, add `None` as the type hint
        let iterable_expr = .typecheck_expression(range, scope_id, safety_mode) 
        mut iterable_should_be_mutable = false


        let iterable_type = .program.get_type(expression_type(iterable_expr))

        match iterable_type {
            TypeVariable => {
                // Since we're not sure, just make it mutable.
                iterable_should_be_mutable = true
            }
            GenericInstance(id, args) | Struct(id) => {
                let struct_ = .get_struct(id)
                let next_method_function_id = .find_function_in_scope(
                    parent_scope_id: struct_.scope_id,
                    function_name: "next"
                    )
                if not next_method_function_id.has_value() {
                    .error("Iterator must have a .next() method", range.span())
                } else {
                    let next_method_function = .get_function(next_method_function_id!)
                    // Check whether we need to make the iteratar mutable
                    if next_method_function.is_mutating() {
                        iterable_should_be_mutable = true
                    }
                }
            }
            else => {
                .error("Iterator must have a .next() method", name_span)
            }
        }


        // FIXME: proper type inference for `None`
        let else_statement: ParsedStatement? = None

        let rewritten_statement = ParsedStatement::Block(ParsedBlock(
                stmts: [
                    // let (mutable) _magic = expr
                    ParsedStatement::VarDecl(
                        var: ParsedVarDecl(
                            name: "_magic",
                            parsed_type: ParsedType::Empty,
                            is_mutable: iterable_should_be_mutable,
                            span: name_span
                        ),
                        init: range
                    )
                    // loop {
                    ParsedStatement::Loop(ParsedBlock(
                        stmts: [
                            // let _magic_value = _magic.next()
                            ParsedStatement::VarDecl(
                                var: ParsedVarDecl(
                                    name: "_magic_value",
                                    parsed_type: ParsedType::Empty,
                                    is_mutable: iterable_should_be_mutable,
                                    span: name_span
                                ),
                                init: ParsedExpression::MethodCall(
                                    expr: ParsedExpression::Var(
                                        name: "_magic",
                                        span: name_span
                                    ),
                                    call: ParsedCall(
                                        namespace_: [],
                                            name: "next",
                                            args: [],
                                        type_args: []
                                    ),
                                    span: name_span
                                )
                            ),
                            // if not _magic_value.has_value() {
                            ParsedStatement::If(
                                condition: ParsedExpression::UnaryOp(
                                    expr: ParsedExpression::MethodCall(
                                        expr: ParsedExpression::Var(
                                            name: "_magic_value",
                                            span: name_span
                                        ),
                                        call: ParsedCall(
                                            namespace_: [],
                                            name: "has_value",
                                            args: [],
                                            type_args: []
                                        )
                                        span: name_span
                                    ),
                                    op: UnaryOperator::LogicalNot,
                                    span: name_span
                                ),
                                then_block: ParsedBlock(
                                    stmts: [
                                        // break
                                        ParsedStatement::Break
                                    ]
                                ),
                                else_statement
                            ),
                           // let iterator_name = _magic_value!
                           ParsedStatement::VarDecl(
                               var: ParsedVarDecl(
                                   name: iterator_name,
                                   parsed_type: ParsedType::Empty,
                                   // FIXME: loop variable mutability should be independent
                                   // of iterable mutability
                                   is_mutable: iterable_should_be_mutable,
                                   span: name_span
                                ),
                                init: ParsedExpression::ForcedUnwrap(
                                    expr: ParsedExpression::Var(
                                        name: "_magic_value",
                                        span: name_span
                                    )
                                    span: name_span
                                )
                           ),
                           ParsedStatement::Block(block)
                        ]
                    ))
                ]
        ))

        return .typecheck_statement(rewritten_statement, scope_id, safety_mode)
    }

    function typecheck_if(mut this, condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression(condition, scope_id, safety_mode)
        if not expression_type(checked_condition).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(then_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("An ‘if’ block is not allowed to yield values", then_block.find_yield_span()!)
        }

        mut checked_else: CheckedStatement? = None
        if else_statement.has_value() {
            checked_else = .typecheck_statement(else_statement!, scope_id, safety_mode)
        }
        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else)
    }

    function typecheck_var_decl(mut this, var: ParsedVarDecl, init: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        mut lhs_type_id = .typecheck_typename(parsed_type: var.parsed_type, scope_id)
        mut checked_expr = .typecheck_expression(expr: init, scope_id, safety_mode)
        let rhs_type_id = expression_type(checked_expr)

        if lhs_type_id.equals(unknown_type_id()) and not rhs_type_id.equals(unknown_type_id()) {
            lhs_type_id = rhs_type_id
        }

        let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type: lhs_type_id, checked_rhs: checked_expr, span: init.span())
        if promoted_rhs.has_value() {
            checked_expr = promoted_rhs!
        }

        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let optional_struct_id = .find_struct_in_prelude("Optional")

        let lhs_type = .get_type(lhs_type_id)

        match lhs_type {
            GenericInstance(id, args) => {
                if id.equals(weak_ptr_struct_id) {
                    if not var.is_mutable {
                        .error("Weak reference must be mutable", var.span)
                    }

                    if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                    }
                }
                if id.equals(optional_struct_id) {
                    if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                    }
                }
            }
            else => {
                if lhs_type.is_builtin() {
                    let number_constant = checked_expr.to_number_constant(program: .program)

                    mut is_rhs_zero = false
                    if number_constant.has_value() {
                        is_rhs_zero = match number_constant! {
                            Signed(value) => value == 0
                            Unsigned(value) => value == 0
                            Floating(value) => value == 0.0
                        }
                    }

                    if not (.is_numeric(lhs_type_id) and is_rhs_zero) and (.is_integer(lhs_type_id) ^ .is_integer(rhs_type_id)) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                        return CheckedStatement::Garbage
                    }
                }
            }
        }

        let checked_var = CheckedVariable(
            name: var.name
            type_id: lhs_type_id
            is_mutable: var.is_mutable
            definition_span: var.span
        )

        // TODO: dump type hints

        mut module = .current_module()
        let var_id = module.add_variable(checked_var)
        .add_var_to_scope(scope_id, name: var.name, var_id, span: checked_var.definition_span)
        return CheckedStatement::VarDecl(var_id, init: checked_expr)
    }

    function typecheck_while(mut this, condition: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression(condition, scope_id, safety_mode)
        if not expression_type(checked_condition).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘while’ block is not allowed to yield values", block.find_yield_span()!)
        }

        return CheckedStatement::While(condition: checked_condition, block: checked_block)
    }

    function typecheck_try(mut this, stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true)
        let checked_stmt = .typecheck_statement(stmt, scope_id, safety_mode)
        let error_struct_id = .find_struct_in_prelude("Error")
        let error_decl = CheckedVariable(
            name: error_name
            type_id: unknown_type_id()
            is_mutable: false
            definition_span: error_span
        )
        mut module = .current_module()
        let error_id = module.add_variable(name: error_decl)

        let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
        .add_var_to_scope(scope_id: catch_scope_id, name: error_name, var_id: error_id, span: error_span)
        let checked_catch_block = .typecheck_block(catch_block, parent_scope_id: catch_scope_id, safety_mode)

        return CheckedStatement::Try(stmt: checked_stmt, error_name, catch_block: checked_catch_block)
    }

    function typecheck_throw(mut this, expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {

        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)

        let error_type_id = .find_type_in_prelude("Error")
        if not expression_type(checked_expr).equals(error_type_id) {
            .error("throw expression does not produce an error", expr.span())
        }

        let scope = .get_scope(scope_id)
        if not scope.can_throw {
            .error("Throw statment needs to be in a try statement or a function marked as throws", expr.span())
        }

        return CheckedStatement::Throw(checked_expr)
    }

    function typecheck_loop(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘loop’ block is not allowed to yield values", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Loop(checked_block)
    }

    function typecheck_defer(mut this, statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let was_inside_defer = .inside_defer
        .inside_defer = true
        defer .inside_defer = was_inside_defer
        let checked_statement = .typecheck_statement(statement, scope_id, safety_mode)
        match checked_statement {
            Block(block) => {
                if block.yielded_type.has_value() {
                    .error("‘yield’ inside ‘defer’ is meaningless", span)
                }
            }
            else => { }
        }
        return CheckedStatement::Defer(checked_statement)
    }

    function typecheck_block_statement(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A block used as a statement cannot yield values, as the value cannot be observed in any way", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Block(checked_block)
    }

    function typecheck_inline_cpp(mut this, block: ParsedBlock, span: Span, safety_mode: SafetyMode) throws -> CheckedStatement {
        if safety_mode is Safe {
            .error("Use of inline cpp block outside of unsafe block", span)
        }

        mut strings: [String] = []
        for statement in block.stmts.iterator() {
            match statement {
                ParsedStatement::Expression(expression) => {
                    match expression {
                        ParsedExpression::QuotedString(val, span) => {
                            strings.push(val)
                        }
                        else => .error("Expected block of strings", span)
                    }
                }
                else => {
                    .error("Expected block of strings", span)
                }
            }
        }

        return CheckedStatement::InlineCpp(strings)
    }

    function typecheck_return(mut this, expr: ParsedExpression?, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        if .inside_defer {
            .error("‘return’ is not allowed inside ‘defer’", span)
        }
        if not expr.has_value() {
            let none_expr: CheckedExpression? = None
            return CheckedStatement::Return(none_expr)
        }
        let checked_expr = .typecheck_expression(expr!, scope_id, safety_mode)
        return CheckedStatement::Return(checked_expr)
    }

    function typecheck_indexed_struct(mut this, expr: ParsedExpression, field: String, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
        let checked_expr_type_id = expression_type(checked_expr)
        let checked_expr_type = .get_type(checked_expr_type_id)

        let struct_id = match checked_expr_type {
            Type::GenericInstance(id) => id
            Type::Struct(struct_id) => struct_id
            else => {
                panic(format("typecheck_indexed_struct: {}", checked_expr_type))
                // FIXME: This is unreachable
                yield StructId(module: ModuleId(id: 0), id: 0)
            }
        }
        let structure = .get_struct(struct_id)
        for member_id in structure.fields.iterator() {
            let member = .get_variable(member_id)
            let resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
            // FIXME: Unify with type
            // FIXME: Access checks
            return CheckedExpression::IndexedStruct(expr: checked_expr, index: field, span, type_id: resolved_type_id)
        }

        // FIXME: Unify with type
        return CheckedExpression::IndexedStruct(expr: checked_expr, index: field, span, type_id: checked_expr_type_id)
    }

    function typecheck_expression(mut this, anon expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression => match expr {
        IndexedStruct(expr, field, span) => .typecheck_indexed_struct(expr, field, scope_id, safety_mode, span)
        Boolean(val, span) => CheckedExpression::Boolean(val, span)
        NumericConstant(val, span) => {
            // FIXME: better constant support
            yield match val {
                I8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val), span, type_id: builtin(BuiltinType::I8))
                I16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val), span, type_id: builtin(BuiltinType::I16))
                I32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val), span, type_id: builtin(BuiltinType::I32))
                I64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
                U8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val), span, type_id: builtin(BuiltinType::U8))
                U16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val), span, type_id: builtin(BuiltinType::U16))
                U32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val), span, type_id: builtin(BuiltinType::U32))
                U64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
                USize(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val), span, type_id: builtin(BuiltinType::U64))
            }
        }
        SingleQuotedString(val, span) => CheckedExpression::CharacterConstant(val, span)
        SingleQuotedByteString(val, span) => CheckedExpression::ByteConstant(val, span)
        QuotedString(val, span) => CheckedExpression::QuotedString(val, span)
        Call(call, span) => .typecheck_call(call, scope_id, span, safety_mode, must_be_enum_constructor: false)
        MethodCall(expr, call, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let checked_call_expr = .typecheck_call(call, scope_id, span, safety_mode, must_be_enum_constructor: false)
            let type_id = expression_type(checked_call_expr)
            yield match checked_call_expr {
                Call(call) => CheckedExpression::MethodCall(expr: checked_expr, call, span, type_id)
                else => {
                    panic("typecheck_call should return `CheckedExpression::Call()`")
                    yield CheckedExpression::Garbage(span)
                }
            }
        }
        Range(from, to, span) => {
            let checked_from = .typecheck_expression(from, scope_id, safety_mode)
            let checked_to = .typecheck_expression(to, scope_id, safety_mode)

            let from_type = expression_type(checked_from)
            let to_type = expression_type(checked_to)

            let from_span = .expression_span(checked_from)
            let to_span = .expression_span(checked_to)

            let type_id = .unify(lhs: from_type, lhs_span: from_span, rhs: to_type, rhs_span: from_span) ?? unknown_type_id()

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id)
        }
        UnaryOp(expr, op, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let checked_op = match op {
                PreIncrement => CheckedUnaryOperator::PreIncrement
                PostIncrement => CheckedUnaryOperator::PostIncrement
                PreDecrement => CheckedUnaryOperator::PreDecrement
                PostDecrement => CheckedUnaryOperator::PostDecrement
                Negate => CheckedUnaryOperator::Negate
                Dereference => CheckedUnaryOperator::Dereference
                RawAddress => CheckedUnaryOperator::RawAddress
                LogicalNot => CheckedUnaryOperator::LogicalNot
                BitwiseNot => CheckedUnaryOperator::BitwiseNot
                TypeCast(cast) => {
                    let type_id = .typecheck_typename(parsed_type: cast.parsed_type(), scope_id)
                    let checked_cast = match cast {
                        Fallible => CheckedTypeCast::Fallible(type_id)
                        Infallible => CheckedTypeCast::Infallible(type_id)
                    }
                    yield CheckedUnaryOperator::TypeCast(checked_cast)
                }
                else => {
                    todo(format("UnaryOp else: {}", op))
                    yield CheckedUnaryOperator::PreIncrement
                }
            }
            yield .typecheck_unary_operation(checked_expr, checked_op, span, scope_id, safety_mode)
        }
        BinaryOp(lhs, op, rhs, span) => {
            let checked_lhs = .typecheck_expression(lhs, scope_id, safety_mode)
            mut checked_rhs = .typecheck_expression(rhs, scope_id, safety_mode)

            let lhs_type = expression_type(checked_lhs)

            let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type, checked_rhs, span)
            if promoted_rhs.has_value() {
                checked_rhs = promoted_rhs!
            }

            let output_type = .typecheck_binary_operation(checked_lhs, op, checked_rhs, scope_id, span)

            yield CheckedExpression::BinaryOp(lhs: checked_lhs, op, rhs: checked_rhs, span, type_id: output_type)
        }
        OptionalNone(span) => {
            yield CheckedExpression::OptionalNone(span, type_id: unknown_type_id())
        }
        OptionalSome(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let type_id = expression_type(checked_expr)
            let optional_struct_id = .find_struct_in_prelude("Optional")
            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
            let optional_type_id = .find_or_add_type_id(optional_type)
            yield CheckedExpression::OptionalSome(expr: checked_expr, span, type_id: optional_type_id)
        }
        Var(name, span) => {
            let var = .find_var_in_scope(scope_id, var: name)
            return match var.has_value() { // FIXME: this wants to be a match on Optional instead of boolean
                true => CheckedExpression::Var(var: var!, span)
                else => {
                    .error(format("Variable '{}' not found", name), span)
                    yield CheckedExpression::Garbage(span)
                }
            }
        }
        ForcedUnwrap(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let type = .get_type(expression_type(checked_expr))

            let optional_struct_id = .find_struct_in_prelude("Optional")
            let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

            let type_id: TypeId = match type {
                GenericInstance(id, args) => {
                    mut inner_type_id = unknown_type_id()
                    if  id.equals(optional_struct_id) or id.equals(weakptr_struct_id) {
                        inner_type_id = args[0]
                    } else {
                        .error("Forced unwrap only works on Optional", span)
                    }
                    yield inner_type_id
                }
                else => {
                    .error("Forced unwrap only works on Optional", span)
                    yield TypeId(module: ModuleId(id: 0), id: 0)
                }
            }

            yield CheckedExpression::ForcedUnwrap(expr: checked_expr, span, type_id)
        }
        JaktArray(values, fill_size, span) => {
            mut repeat: CheckedExpression? = None
            if fill_size.has_value() {
                // Check fill size is an integer.
                // TODO: Check fill size is positive when possible.
                let fill_size_value = fill_size.value()
                let fill_size_checked = .typecheck_expression(fill_size_value, scope_id, safety_mode)
                let fill_size_type = expression_type(fill_size_checked)
                if not .is_integer(fill_size_type) {
                    .error(
                        format("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions.", .type_name(fill_size_type)), 
                        fill_size_value.span()
                    )
                }
                repeat = repeat
            }
            let array_struct_id = .find_struct_in_prelude("Array")
            mut inner_type_id = unknown_type_id()
            mut inferred_type_span: Span? = None

            mut vals: [CheckedExpression] = []
            for value in values.iterator() {
                let checked_expr = .typecheck_expression(value, scope_id, safety_mode)
                let current_value_type_id = expression_type(checked_expr)

                if inner_type_id.equals(unknown_type_id()) {
                    inner_type_id = current_value_type_id
                    inferred_type_span = value.span()
                } else if not inner_type_id.equals(current_value_type_id) {
                    .error_with_hint(
                        format("Type '{}' does not match type '{}' of previous values in array", .type_name(current_value_type_id), .type_name(inner_type_id)),
                        value.span(),
                        format("array was inferred to store type '{}' here", .type_name(inner_type_id))
                        inferred_type_span!
                    )
                }
                vals.push(checked_expr)
            }
            let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))
            yield CheckedExpression::JaktArray(vals, repeat, span, type_id)
        }
        JaktTuple(values, span) => {
            let VOID_TYPE_ID = builtin(BuiltinType::Void)
            mut checked_values: [CheckedExpression] = []
            mut checked_types: [TypeId] = []

            for value in values.iterator() {
                let checked_value= .typecheck_expression(value, scope_id, safety_mode)
                let type_id = expression_type(checked_value)
                if type_id.equals(VOID_TYPE_ID) {
                    .error("Cannot create a tuple that contains a value of type void", value.span())
                }
                checked_types.push(type_id)
                checked_values.push(checked_value)
            }

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

            // FIXME: Unify type

            yield CheckedExpression::JaktTuple(vals: checked_values, span, type_id)
        }
        IndexedExpression(base, index, span) => {
            let checked_base = .typecheck_expression(base, scope_id, safety_mode)
            let checked_index = .typecheck_expression(index, scope_id, safety_mode)

            let array_struct_id = .find_struct_in_prelude("Array")
            let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
            mut expr_type_id = unknown_type_id()

            match .get_type(expression_type(checked_base)) {
                GenericInstance(id, args) => {
                    if id.equals(array_struct_id) {
                        if .is_integer(expression_type(checked_index)) {
                            expr_type_id = args[0]
                        } else {
                            .error("Index is not an integer", span)
                        }
                    } else if id.equals(dictionary_struct_id) {
                        expr_type_id = args[1]
                    }
                }
                else => {
                    .error("Index used on value that cannot be indexed", span)
                }
            }

            yield CheckedExpression::IndexedExpression(expr: checked_base, index: checked_index, span, type_id: expr_type_id)
        }
        IndexedTuple(expr, index, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            mut expr_type_id = unknown_type_id()

            match .get_type(expression_type(checked_expr)) {
                GenericInstance(id, args) => {
                    if id.equals(tuple_struct_id) {
                        if (index >= args.size()){
                            .error("Tuple index past the end of the tuple", span)
                        }
                        expr_type_id = args[index]
                    }
                }
                else => {
                    .error("Tuple index used non-tuple value", span)
                }
            }

            yield CheckedExpression::IndexedTuple(expr: checked_expr, index: index, span, type_id: expr_type_id)
        }
        Garbage(span) => CheckedExpression::Garbage(span)
        NamespacedVar(name, namespace_, span) => {
            mut scopes = [scope_id]
            for ns in namespace_.iterator() {
                let scope = scopes[scopes.size() - 1]
                let ns_in_scope = .find_namespace_in_scope(scope_id: scope, name: ns)
                let enum_in_scope = .find_enum_in_scope(scope_id: scope, name: ns)
                mut next_scope = scope
                if ns_in_scope.has_value() {
                    next_scope = ns_in_scope!.0
                } else if enum_in_scope.has_value() {
                    next_scope = .get_enum(enum_in_scope!).scope_id
                } else {
                    panic(format("Namespace {} not found", ns))
                }
                scopes.push(next_scope)
            }

            let scope = scopes[scopes.size() - 1]

            mut i = 0uz
            let min_length = match scopes.size() <= namespace_.size() {
                true => scopes.size()
                else => namespace_.size()
            }
            mut checked_namespaces: [CheckedNamespace] = []
            while i < min_length {
                checked_namespaces.push(CheckedNamespace(name: namespace_[i], scope_id: scope))
                i++
            }

            let var = .find_var_in_scope(scope_id: scope, var: name)
            yield match var.has_value() {
                true => CheckedExpression::NamespacedVar(namespaces: checked_namespaces, var: var!, span)
                else => {
                    let implicit_constructor_call = ParsedCall(namespace_, name, args: [], type_args: [])
                    let call_expression = .typecheck_call(call: implicit_constructor_call, scope_id, span, safety_mode, must_be_enum_constructor: true)
                    let type_id = expression_type(call_expression)
                    let checked_call = match call_expression {
                        Call(call) => call
                        else => {
                            panic("typecheck_call returned something other than a CheckedCall")
                            // FIXME: Unreachable
                            let none_function_id: FunctionId? = None
                            yield CheckedCall(namespace_: [], name: "", args: [], function_id: none_function_id, return_type: builtin(BuiltinType::Void), callee_throws: true)
                        }
                    }
                    yield match .errors.is_empty() {
                        true => CheckedExpression::Call(call: checked_call, span, type_id)
                        else => {
                            .error(format("Variable {} not found", name), span)
                            yield CheckedExpression::NamespacedVar(
                                namespaces: checked_namespaces,
                                var: CheckedVariable(
                                    name,
                                    type_id: unknown_type_id(),
                                    is_mutable: false,
                                    definition_span: span
                                ),
                                span
                            )
                        }
                    }
                }
            }

            yield CheckedExpression::Garbage(span)
        }
        else => {
            panic(format("typechecker needs support for {}", expr))

            yield CheckedExpression::Boolean(val: false, span: Span(start: 0, end: 0))
        }
    }

    function find_var_in_scope(mut this, scope_id: ScopeId, var: String) -> CheckedVariable? {
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            for existing_var in scope.vars.iterator() {
                if existing_var.0 == var {
                    return .program.get_variable(existing_var.1)
                }
            }
            if not scope.parent.has_value() {
                break
            }
            current_scope_id = scope.parent!
        }
        return None
    }

    function resolve_call(mut this, call: ParsedCall, namespaces: [ResolvedNamespace], span: Span, scope_id: ScopeId, must_be_enum_constructor: bool) throws -> FunctionId? {
        mut callee: FunctionId? = None
        mut current_scope_id = scope_id

        for namespace_index in 0..call.namespace_.size() {
            let scope_name = call.namespace_[namespace_index]
            let maybe_ns_scope = .find_namespace_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_ns_scope.has_value() {
                let scope_id = maybe_ns_scope!.0
                let is_import = maybe_ns_scope!.1
                if is_import {
                    namespaces[namespace_index].name = .program.modules[scope_id.module.id].name
                }
                current_scope_id = scope_id
                continue
            }
            let maybe_struct_scope = .find_struct_in_scope(scope_id, name: scope_name)
            if maybe_struct_scope.has_value() {
                let structure = .get_struct(maybe_struct_scope!)
                current_scope_id = structure.scope_id
                continue
            }
            let maybe_enum_scope = .find_enum_in_scope(scope_id, name: scope_name)
            if maybe_enum_scope.has_value() {
                let enum_ = .get_enum(maybe_enum_scope!)
                current_scope_id = enum_.scope_id
                continue
            }

            .error(format("Not a namespace, enum, class, or struct: ‘{}’", call.namespace_), span)
        }

        // 1. Look for a function with this name.
        let maybe_function_id = .find_function_in_scope(parent_scope_id: current_scope_id, function_name: call.name)
        if maybe_function_id.has_value() {
            let function_id = maybe_function_id!
            if not must_be_enum_constructor or .get_function(function_id).type is ImplicitEnumConstructor {
                return function_id
            }
        }

        if must_be_enum_constructor {
            .error(format("No such enum constructor ‘{}’", call.name), span)
            return callee
        }

        // 2. Look for a struct, class or enum constructor with this name.
        let maybe_struct_id = .find_struct_in_scope(scope_id: current_scope_id, name: call.name)
        if maybe_struct_id.has_value() {
            let struct_id = maybe_struct_id!
            let structure = .get_struct(struct_id)
            let maybe_function_id = .find_function_in_scope(parent_scope_id: structure.scope_id, function_name: call.name)
            if maybe_function_id.has_value() {
                return maybe_function_id!
            }
            return callee
        }

        .error(format("Call to unknown function: ‘{}’", call.name), span)

        return None
    }

    function typecheck_call(mut this, call: ParsedCall, scope_id: ScopeId, span: Span, safety_mode: SafetyMode, must_be_enum_constructor: bool) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = builtin(BuiltinType::Void)
        mut callee_throws = false

        mut resolved_namespaces: [ResolvedNamespace] = []
        for name in call.namespace_.iterator() {
            let generic_parameters: [TypeId]? = None
            resolved_namespaces.push(ResolvedNamespace(name, generic_parameters))
        }

        match call.name {
            "print" | "println" | "eprintln" | "format" => {
                for arg in call.args.iterator() {
                    let checked_arg = .typecheck_expression(expr: arg.2, scope_id, safety_mode)

                    args.push((call.name, checked_arg))
                }
                
                if call.name == "format" {
                    return_type = builtin(BuiltinType::String)
                    callee_throws = true
                }
            }
            else => {
                let maybe_function_id = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor)

                if not maybe_function_id.has_value() {
                    let none_function_id: FunctionId? = None
                    return CheckedExpression::Call(call: CheckedCall(namespace_: [], name: call.name, args, function_id: none_function_id, return_type, callee_throws), span, type_id: return_type)
                }

                let function_id = maybe_function_id!
                let callee = .get_function(function_id)
                callee_throws = callee.can_throw
                return_type = callee.return_type_id

                if callee.params.size() != call.args.size() {
                    .error("Wrong number of arguments", span)
                }

                for i in 0..call.args.size() {
                    if i == callee.params.size() {
                        break
                    }

                    let parsed_label_and_arg = call.args[i]
                    let param = callee.params[i]

                    if param.requires_label {
                        .validate_argument_label(param, label: parsed_label_and_arg.0, span: parsed_label_and_arg.1, expr: parsed_label_and_arg.2)
                    }
                    let checked_arg = .typecheck_expression(expr: parsed_label_and_arg.2, scope_id, safety_mode)

                    // FIXME: It's super awkward that we have to pass "generic_inferences" here:
                    .check_types_for_compat(lhs_type_id: param.variable.type_id, rhs_type_id: expression_type(checked_arg), generic_inferences: ["":""], span)

                    args.push((call.name, checked_arg))
                }
            }
        }

        let none_function_id: FunctionId? = None
        return CheckedExpression::Call(call: CheckedCall(namespace_: [], name: call.name, args, function_id: none_function_id, return_type, callee_throws), span, type_id: return_type)
    }

    function resolve_type_var(this, type_var_type_id: TypeId, scope_id: ScopeId) -> TypeId {
        mut current_type_id = type_var_type_id

        loop {
            let type_var_type = .get_type(current_type_id)
            match type_var_type {
                Type::TypeVariable(type_name) => {
                    let maybe_found_type_id = .find_type_in_scope(scope_id, name: type_name)
                    if maybe_found_type_id.has_value() {
                        let found_type_id = maybe_found_type_id.value()
                        if found_type_id.equals(current_type_id) {
                            return current_type_id
                        }
                        current_type_id = found_type_id
                    } else {
                        return current_type_id
                    }
                } else => {
                    return current_type_id
                }
            }
        }
        return current_type_id
    }

    function validate_argument_label(mut this, param: CheckedParameter, label: String, span: Span, expr: ParsedExpression) throws -> bool {
        if label == param.variable.name {
            return true
        }
        match expr {
            Var(name, span) => {
                if name == param.variable.name {
                    return true
                }
                .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", name, param.variable.name), span)
            }
            else => {}
        }
        .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", label, param.variable.name), span)
        return false
    }
}
