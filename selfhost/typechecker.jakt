// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
//
// SPDX-License-Identifier: BSD-2-Clause

import error { JaktError, print_error }
import lexer { Lexer, NumericConstant }
import parser { Parser, BinaryOperator, DefinitionLinkage, DefinitionType, UnaryOperator,
                FunctionLinkage, FunctionType, ParsedBlock, ParsedCall,
                ParsedExpression, ParsedFunction, ParsedNamespace,
                ParsedType, ParsedStatement, ParsedVarDecl, RecordType,
                ParsedRecord, ParsedField, TypeCast, EnumVariantPatternArgument,
                ParsedMatchBody, ParsedMatchCase, Visibility }
import utility { panic, todo, Span, join, FilePath }
import compiler { Compiler }
import prelude { JaktPrelude }

enum SafetyMode {
    Safe
    Unsafe
}

struct ModuleId {
    id: usize

    function equals(this, anon rhs: ModuleId) -> bool {
        return this.id == rhs.id
    }
}

struct VarId {
    module: ModuleId
    id: usize
}

struct FunctionId {
    module: ModuleId
    id: usize
}

struct StructId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: StructId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct EnumId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: EnumId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

enum StructOrEnumId {
    Struct(StructId)
    Enum(EnumId)
}

struct TypeId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: TypeId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function to_string(this) throws -> String {
        return format("{}_{}", .module.id, .id)
    }

    // FIXME: Remove when we have language support, used as workaround [String:String] <-> [TypeId:TypeId]
    function from_string(anon type_id_string: String) throws -> TypeId {
        let parts = type_id_string.split('_')
        if not (parts.size() == 2) {
            throw Error::from_errno(999) // FIXME: good error message
        }

        let module_id = parts[0].to_uint()
        let type_id = parts[1].to_uint()
        if not module_id.has_value() or not type_id.has_value() {
            throw Error::from_errno(9999) // FIXME: good error message
        }

        return TypeId(module: ModuleId(id: module_id.value() as! usize), id: type_id.value() as! usize)
    }
}

struct ScopeId {
    module_id: ModuleId
    id: usize

    function equals(this, anon other: ScopeId) -> bool {
        return this.module_id.id == other.module_id.id and this.id == other.id
    }
}

enum BuiltinType: usize {
    Void = 0
    Bool = 1
    U8 = 2
    U16 = 3
    U32 = 4
    U64 = 5
    I8 = 6
    I16 = 7
    I32 = 8
    I64 = 9
    F32 = 10
    F64 = 11
    Usize = 12
    String = 13
    CChar = 14
    CInt = 15
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    TypeVariable(String)
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    GenericResolvedType(id: StructId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    RawPtr(TypeId)

    function equals(this, anon rhs: Type) -> bool {
        if this is Void and rhs is Void {
            return true
        } else if this is Bool and rhs is Bool {
            return true
        } else if this is U8 and rhs is U8 {
            return true
        } else if this is U16 and rhs is U16 {
            return true
        } else if this is U32 and rhs is U32 {
            return true
        } else if this is U64 and rhs is U64 {
            return true
        } else if this is I8 and rhs is I8 {
            return true
        } else if this is I16 and rhs is I16 {
            return true
        } else if this is I32 and rhs is I32 {
            return true
        } else if this is I64 and rhs is I64 {
            return true
        } else if this is F32 and rhs is F32 {
            return true
        } else if this is F64 and rhs is F64 {
            return true
        } else if this is Usize and rhs is Usize {
            return true
        } else if this is JaktString and rhs is JaktString {
            return true
        } else if this is CChar and rhs is CChar {
            return true
        } else if this is CInt and rhs is CInt {
            return true
        } else {
            match this {
                TypeVariable(lhs_name) => {
                    match rhs {
                        TypeVariable(rhs_name) => {
                            return lhs_name == rhs_name
                        }
                        else => {
                            return false
                        }
                    }
                }
                GenericInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if not lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                GenericEnumInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericEnumInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                Struct(lhs_id) => {
                    match rhs {
                        Struct(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                Enum(lhs_id) => {
                    match rhs {
                        Enum(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                RawPtr(lhs_id) => {
                    match rhs {
                        RawPtr(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                else => {
                    return false
                }
            }
            return false
        }
    }

    function is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt => true
        else => false
    }

    function get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    function is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    function min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    function max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }
}

class Scope {
    public namespace_name: String?
    public vars: [String: VarId]
    public structs: [String: StructId]
    public functions: [String: FunctionId]
    public enums: [String: EnumId]
    public types: [String: TypeId]
    public imports: [String: ModuleId] // FIXME: Span
    public parent: ScopeId?
    public children: [ScopeId]
    public can_throw: bool
}

class Module {
    public id: ModuleId
    public name: String
    public functions: [CheckedFunction]
    public structures: [CheckedStruct]
    public enums: [CheckedEnum]
    public scopes: [Scope]
    public types: [Type]
    public variables: [CheckedVariable]
    public imports: [ModuleId]

    public is_root: bool

    public function new_type_variable(mut this) throws -> TypeId {
        let new_id = .types.size()

        .types.push(Type::TypeVariable(format("T{}", new_id)))

        return TypeId(module: .id, id: new_id)
    }

    public function add_function(mut this, checked_function: CheckedFunction) throws -> FunctionId {
        let new_id = .functions.size()

        .functions.push(checked_function)

        return FunctionId(module: .id, id: new_id)
    }

    public function add_variable(mut this, anon checked_variable: CheckedVariable) throws -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

struct LoadedModule {
    module_id: ModuleId
    file_name: FilePath
    file_contents: [u8]
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

class CheckedFunction {
    public name: String
    public name_span: Span
    public visibility: Visibility
    public return_type_id: TypeId
    public params: [CheckedParameter]
    public generic_params: [FunctionGenericParameter]
    public block: CheckedBlock
    public can_throw: bool
    public type: FunctionType
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId

    public function is_static(this) -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public function is_mutating(this) -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

enum FunctionGenericParameter {
    InferenceGuide(TypeId)
    Parameter(TypeId)
}

struct CheckedVariable {
    name: String
    type_id: TypeId
    is_mutable: bool
    definition_span: Span
    visibility: Visibility
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

struct CheckedBlock {
    statements: [CheckedStatement]
    scope_id: ScopeId
    definitely_returns: bool
    yielded_type: TypeId?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    fields: [VarId]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    type_id: TypeId
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    variants: [CheckedEnumVariant]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
    is_boxed: bool
}

enum CheckedEnumVariant {
    Untyped(name: String, span: Span)
    Typed(name: String, type_id: TypeId, span: Span)
    WithValue(name: String, expr: CheckedExpression, span: Span)
    StructLike(name: String, fields: [VarId], span: Span)

    function equals(this, anon other: CheckedEnumVariant) -> bool {
        return match this {
            Untyped(name: this_name) => match other {
                Untyped(name: other_name) => this_name == other_name
                else => false
            }
            else => false
        }
    }

    function span(this) -> Span => match this {
        Untyped(span) => span
        Typed(span) => span
        WithValue(span) => span
        StructLike(span)  => span
    }

    function name(this) -> String => match this {
        Untyped(name) => name
        Typed(name) => name
        WithValue(name) => name
        StructLike(name)  => name
    }
}

boxed enum CheckedStatement {
    Expression(expr: CheckedExpression, span: Span)
    Defer(statement: CheckedStatement, span: Span)
    VarDecl(var_id: VarId, init: CheckedExpression, span: Span)
    If(condition: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?, span: Span)
    Block(block: CheckedBlock, span: Span)
    Loop(block: CheckedBlock, span: Span)
    While(condition: CheckedExpression, block: CheckedBlock, span: Span)
    Return(val: CheckedExpression?, span: Span?)
    Break(Span)
    Continue(Span)
    Throw(expr: CheckedExpression, span: Span)
    Yield(expr: CheckedExpression, span: Span)
    Try(stmt: CheckedStatement, error_name: String, catch_block: CheckedBlock, span: Span)
    InlineCpp(lines: [String], span: Span)
    Garbage(Span)

    function span(this) => match this {
        Expression(span) => Some(span)
        Defer(span) => span
        VarDecl(span) => span
        If(span) => span
        Block(span) => span
        Loop(span) => span
        While(span) => span
        Return(span) => span
        Break(span) => span
        Continue(span) => span
        Throw(span) => span
        Yield(span) => span
        Try(span) => span
        InlineCpp(span) => span
        Garbage(span) => span
    }
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    function can_fit_number(this, type_id: TypeId, program: CheckedProgram) -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                    yield false
                }
                F64 => true
                else => false
            }
        }
    }
}
// FIXME: Make this a member function of NumberConstant.
//        Right now we cannot do that as the compiler does not know the CheckedNumericConstant
//        constructors when we use them in a member function (https://github.com/SerenityOS/jakt/issues/677).
function promote(anon num_const: NumberConstant, type_id: TypeId, program: CheckedProgram) -> CheckedNumericConstant? {
    if not num_const.can_fit_number(type_id, program) {
        return None
    }

    let bits = program.get_bits(type_id)
    let is_signed = program.is_signed(type_id)
    let new_constant = match num_const {
        Signed(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value as! u64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Unsigned(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value as! i64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Floating(value) => match is_signed {
            true => match bits {
                32 => {
                    todo("Add conversion from f64 to f32")
                    yield CheckedNumericConstant::I64(0)
                }
                64 => CheckedNumericConstant::F64(value)
                else => {
                    panic("Floating numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => {
                panic("Floating numeric constant cannot be unsigned")
                yield CheckedNumericConstant::I64(0)
            }
        }
    }

    return new_constant
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    // FIXME: make this into a FAMF (fat arrow match function) once we can yield `None` out of the match (https://github.com/SerenityOS/jakt/issues/669)
    //          or once we can cast f32 to f64
    function number_constant(this) -> NumberConstant? {
        match this {
            I8(value) => { return NumberConstant::Signed(value as! i64) }
            I16(value) => { return NumberConstant::Signed(value as! i64) }
            I32(value) => { return NumberConstant::Signed(value as! i64) }
            I64(value) => { return NumberConstant::Signed(value as! i64) }
            U8(value) => { return NumberConstant::Unsigned(value as! u64) }
            U16(value) => { return NumberConstant::Unsigned(value as! u64) }
            U32(value) => { return NumberConstant::Unsigned(value as! u64) }
            U64(value) => { return NumberConstant::Unsigned(value as! u64) }
            USize(value) => { return NumberConstant::Unsigned(value as! u64) }

            // FIXME: add a case for F32 once we can cast f32 to f64

            F64(value) => { return NumberConstant::Floating(value) }
            else => {}
        }

        return None
    }
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)

    function type_id(this) -> TypeId => match this {
        Fallible(type_id) => type_id
        Infallible(type_id) => type_id
    }
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(name: String, enum_type_id: TypeId)
}

enum CheckedMatchBody {
    Expression(CheckedExpression)
    Block(CheckedBlock)
}

enum CheckedMatchCase {
    EnumVariant(name: String, args: [EnumVariantPatternArgument], subject_type_id: TypeId, index: usize, scope_id: ScopeId, body: CheckedMatchBody, marker_span: Span)
    Expression(expression: CheckedExpression, body: CheckedMatchBody, marker_span: Span)
    CatchAll(body: CheckedMatchBody, marker_span: Span)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: String, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression, to: CheckedExpression, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId, inner_type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: Span, type_id: TypeId)
    Match(expr: CheckedExpression, match_cases: [CheckedMatchCase], span: Span, type_id: TypeId, all_variants_constant: bool)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Garbage(Span)

    // FIXME: rewrite this into a FAMF once we can yield None out of a match (https://github.com/SerenityOS/jakt/issues/669)
    function to_number_constant(this, program: CheckedProgram) -> NumberConstant? {
        match this {
            NumericConstant(val, span, type_id) => { return val.number_constant() }
            UnaryOp(expr, op, span, type_id) => {
                match op {
                    TypeCast(cast) => {
                        if not cast is Infallible {
                            return None
                        }
                        if not program.is_integer(type_id) and not program.is_floating(type_id) {
                            return None
                        }
                        match expr {
                            NumericConstant(val, span: span_, type_id: type_id_) => { return val.number_constant() }
                            else => {}
                        }
                    }
                    else => {}
                }
            }
            else => {}
        }
        return None
    }
}

function expression_type(anon expr: CheckedExpression) -> TypeId => match expr {
    Boolean => builtin(BuiltinType::Bool)
    NumericConstant(type_id) => type_id
    QuotedString => builtin(BuiltinType::String)
    ByteConstant => builtin(BuiltinType::U8)
    CharacterConstant => builtin(BuiltinType::CChar)
    UnaryOp(type_id) => type_id
    BinaryOp(type_id) => type_id
    JaktTuple(type_id) => type_id
    Range(type_id) => type_id
    JaktArray(type_id) => type_id
    JaktDictionary(type_id) => type_id
    JaktSet(type_id) => type_id
    IndexedExpression(type_id) => type_id
    IndexedDictionary(type_id) => type_id
    IndexedTuple(type_id) => type_id
    IndexedStruct(type_id) => type_id
    Call(type_id) => type_id
    MethodCall(type_id) => type_id
    NamespacedVar(var) => var.type_id
    Var(var) => var.type_id
    OptionalNone(type_id) => type_id
    OptionalSome(type_id) => type_id
    ForcedUnwrap(type_id) => type_id
    Match(type_id) => type_id
    Block(type_id) => type_id
    Garbage => builtin(BuiltinType::Void)
}

function checked_expression_definitely_returns(anon check_expression: CheckedExpression) -> bool {
    mut ret = false

    match check_expression {
        Match(expr, match_cases, span, type_id, all_variants_constant) => {
            mut case_ret = true
            for case_ in match_cases.iterator() {
                match case_ {
                    EnumVariant(body) => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                    Expression(body)  => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                    CatchAll(body)  => match body {
                        Block(block) => {
                            if block.definitely_returns {
                                continue
                            }
                        }
                        else => {
                            case_ret = false
                            break
                        }
                    }
                }
            }
            ret = case_ret
        }
        else => {
            return false
        }
    }
    return ret
}

struct ResolvedNamespace {
    name: String
    generic_parameters: [TypeId]?
}

struct CheckedCall {
    namespace_: [ResolvedNamespace]
    name: String,
    args: [(String, CheckedExpression)]
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool
}

function unknown_type_id() -> TypeId => TypeId(module: ModuleId(id: 0), id: 0)
function void_type_id() -> TypeId => builtin(BuiltinType::Void)

function builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin as! usize)
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    compiler: Compiler
    public modules: [Module]
    public loaded_modules: [String: LoadedModule]

    public function get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public function get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public function get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public function get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public function get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public function get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public function get_scope(this, anon id: ScopeId) throws -> Scope {
        let max_scope = .modules[id.module_id.id].scopes.size() - 1
        if id.id > max_scope {
            .compiler.panic(format("scope_id {} does not exist in module", id))
        }
        
        return .modules[id.module_id.id].scopes[id.id]
    } 

    public function set_loaded_module(mut this, module_name: String, loaded_module: LoadedModule) throws {
        .loaded_modules.set(
            key: module_name
            value: loaded_module 
        )  
    }
    public function get_loaded_module(this, anon module_name: String) -> LoadedModule? {
        return .loaded_modules.get(module_name)
    }

    public function find_var_in_scope(this, scope_id: ScopeId, var: String) throws -> CheckedVariable? {
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            let maybe_var = scope.vars.get(var)
            if maybe_var.has_value() {
                return .get_variable(maybe_var!)
            }
            if not scope.parent.has_value() {
                break
            }
            current_scope_id = scope.parent!
        }
        return None
    }

    public function is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public function is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public function is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public function is_string(this, anon type_id: TypeId) -> bool => .get_type(type_id) is JaktString 

    public function get_bits(this, anon type_id: TypeId) => .get_type(type_id).get_bits()

    public function is_signed(this, anon type_id: TypeId) => .get_type(type_id).is_signed()
}

struct Typechecker {
    compiler: Compiler
    program: CheckedProgram
    current_module_id: ModuleId
    current_struct_type_id: TypeId?
    current_function_id: FunctionId?
    inside_defer: bool
    checkidx: usize

    function set_current_file_and_contents(mut this, file_name: FilePath, file_contents: [u8]) throws {
        .compiler.set_current_file(file_name)
        .compiler.set_current_file_contents(file_contents)
    }

    function typecheck(mut compiler: Compiler, parsed_namespace: ParsedNamespace) throws -> CheckedProgram {

        let input_file = compiler.current_file
        let input_file_contents = compiler.current_file_contents

        let placeholder_module_id = ModuleId(id: 0)

        let none_type_id: TypeId? = None
        let none_function_id: FunctionId? = None

        mut typechecker = Typechecker(
            compiler
            program: CheckedProgram(compiler, modules: [], loaded_modules: [:]),
            current_module_id: placeholder_module_id,
            current_struct_type_id: none_type_id
            current_function_id: none_function_id
            inside_defer: false
            checkidx: 0uz
        )

        typechecker.include_prelude()

        let root_module_name = "Root Module"
        let root_module_id = typechecker.create_module(name: root_module_name, is_root: true)
        typechecker.current_module_id = root_module_id
        typechecker.set_current_file_and_contents(file_name: input_file, file_contents: input_file_contents)
        typechecker.program.set_loaded_module(
            module_name: root_module_name
            loaded_module: LoadedModule(
                module_id: root_module_id
                file_name: input_file
                file_contents: input_file_contents
            )
        )

        let PRELUDE_SCOPE_ID: ScopeId = typechecker.prelude_scope_id()
        let root_scope_id = typechecker.create_scope(parent_scope_id: PRELUDE_SCOPE_ID, can_throw: false)
        typechecker.typecheck_module(parsed_namespace, scope_id: root_scope_id)

        return typechecker.program
    }

    function get_function(this, anon id: FunctionId) => .program.get_function(id)
    function get_variable(this, anon id: VarId) => .program.get_variable(id)
    function get_type(this, anon id: TypeId) => .program.get_type(id)
    function get_enum(this, anon id: EnumId) => .program.get_enum(id)
    function get_struct(this, anon id: StructId) => .program.get_struct(id)
    function get_scope(this, anon id: ScopeId) throws => .program.get_scope(id)
    function find_var_in_scope(this, scope_id: ScopeId, var: String) throws -> CheckedVariable? => .program.find_var_in_scope(scope_id, var)

    function get_root_path(this) throws -> FilePath {
        return .program.get_loaded_module("Root Module")!.file_name
    }
    function prelude_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 0), id: 0)
    function root_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 1), id: 0)

    function current_module(this) => .program.get_module(.current_module_id)

    public function scope_can_access(this, accessor: ScopeId, accessee: ScopeId) throws -> bool {
        if accessor.equals(accessee) {
            return true
        }
        mut accessor_scope = .get_scope(accessor)
        while accessor_scope.parent.has_value() {
            let parent = accessor_scope.parent!
            if parent.equals(accessee) {
                return true
            }
            accessor_scope = .get_scope(parent)
        }
        return false
    }

    function error(mut this, anon message: String, anon span: Span) throws {
        .compiler.errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function is_integer(this, anon type_id: TypeId) => .program.is_integer(type_id)
    function is_floating(this, anon type_id: TypeId) => .program.is_floating(type_id)
    function is_numeric(this, anon type_id: TypeId) => .program.is_numeric(type_id)

    function create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool) throws -> ScopeId {
        // Check that parent_scope_id is a valid ScopeId
        if parent_scope_id.has_value() {
            // Check that the ModuleId is valid
            if parent_scope_id!.module_id.id >= .program.modules.size() {
                .compiler.panic(format("create_scope: parent_scope_id.module is invalid! No module with id {}.", parent_scope_id!.module_id.id))
                return .prelude_scope_id()
            }

            // Check that ScopeId.id is valid in the module
            if parent_scope_id!.id >= .program.modules[parent_scope_id!.module_id.id].scopes.size() {
                .compiler.panic(format("create_scope: parent_scope_id.id is invalid! Module {} does not have a scope with id {}.", parent_scope_id!.module_id.id, parent_scope_id!.id))
                return .prelude_scope_id()
            }
        }

        let none_string: String? = None

        let scope = Scope(
            namespace_name: none_string
            vars: [:]
            structs: [:]
            functions: [:]
            enums: [:]
            types: [:]
            imports: [:]
            parent: parent_scope_id
            children: []
            can_throw
        )

        .program.modules[.current_module_id.id].scopes.push(scope)

        return ScopeId(module_id: .current_module_id, id: .program.modules[.current_module_id.id].scopes.size() - 1)
    }

    function create_module(mut this, name: String, is_root: bool) throws -> ModuleId {
        let new_id = .program.modules.size()
        let module_id = ModuleId(id: new_id)
        let module = Module(
            id: module_id,
            name: name,
            functions: [],
            structures: [],
            enums: [],
            scopes: [],
            types: [ // FIXME: use general builtin types array
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
            ],
            variables: [],
            imports: [],
            is_root: is_root,
        )
        .program.modules.push(module)

        return module_id
    }

    function include_prelude(mut this) throws {
        let module_name = "__prelude__"
        let file_name = FilePath::make(module_name)
        let file_contents = JaktPrelude::to_bytes()
        // we are using the root module (so it doesn't have to be optional)
        let prelude_module_id = .create_module(name: module_name, is_root: false)
        .current_module_id = prelude_module_id
        .program.set_loaded_module(
            module_name
            loaded_module: LoadedModule(
                module_id: prelude_module_id
                file_name
                file_contents
         ))

        let none_scope_id: ScopeId? = None // FIXME: set None directly when compiler allows it
        let prelude_scope_id = .create_scope(
            parent_scope_id: none_scope_id
            can_throw: false
        )

        let parsed_namespace = .lex_and_parse_file_contents(file_contents)
        .compiler.dbg_println(format("before typechecking parsed prelude, modules `{}`", .program.modules))
        .typecheck_module(
            parsed_namespace
            scope_id: prelude_scope_id
        )
    }

    function lex_and_parse_file_contents(mut this, anon file_contents: [u8]) throws -> ParsedNamespace {

        let tokens = Lexer::lex(compiler: .compiler, input: file_contents)
        .compiler.print_errors()

        if .compiler.dump_lexer {
            for token in tokens.iterator() {
                println("token: {}", token)
            }
        }

        let parsed_namespace = Parser::parse(compiler: .compiler, tokens)

        if .compiler.dump_parser {
            println("{:#}", parsed_namespace)
        }
        .compiler.print_errors()

        return parsed_namespace
    } 

    function find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return struct_id.value()
        }

        .compiler.panic(format("internal error: {} builtin definition not found", name))
        return StructId(module: ModuleId(id: 0), id: 0)
    }

    function find_type_in_prelude(this, anon name: String) throws -> TypeId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let type_id = .find_type_in_scope(scope_id, name)
        if type_id.has_value() {
            return type_id.value()
        }
        .compiler.panic(format("internal error: {} builtin definition not found", name))
        return TypeId(module: ModuleId(id: 0), id: 0)
    }

    function try_to_promote_constant_expr_to_type(mut this, lhs_type: TypeId, checked_rhs: CheckedExpression, span: Span) throws -> CheckedExpression? {
        if not .is_integer(lhs_type) {
            return None
        }

        let rhs_constant_opt = checked_rhs.to_number_constant(program: .program)
        if not rhs_constant_opt.has_value() {
            return None
        }
        let rhs_constant = rhs_constant_opt!

        let result = promote(rhs_constant, type_id: lhs_type, program: .program)
        if not result.has_value() {
            let type = .get_type(lhs_type)
            .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type.min(), type.max(), .type_name(lhs_type)), span)
            return None
        }
        let new_constant = result!

        return CheckedExpression::NumericConstant(val: new_constant, span, type_id: lhs_type)
    }

    function type_name(this, anon type_id: TypeId) throws -> String {
        let type = .get_type(type_id)

        return match type {
            F32 => "f32"
            F64 => "f64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            Void => "void"
            JaktString => "String"
            Enum(id) => .get_enum(id).name
            Struct(id) => .get_struct(id).name
            GenericEnumInstance(id, args) => {
                mut output = format("enum {}", .get_enum(id).name)

                output += "<"
                mut first = true
                for arg in args.iterator() {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }

                    output += .type_name(arg)
                }

                output += ">"

                yield output
            }
            GenericInstance(id, args) => {

                let array_struct_id = .find_struct_in_prelude("Array")
                let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
                let optional_struct_id = .find_struct_in_prelude("Optional")
                let range_struct_id = .find_struct_in_prelude("Range")
                let set_struct_id = .find_struct_in_prelude("Set")
                let tuple_struct_id = .find_struct_in_prelude("Tuple")
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                mut output = ""

                if id.equals(array_struct_id) {
                    output = format("[{}]", .type_name(args[0]))
                } else if id.equals(dictionary_struct_id) {
                    output = format("[{}:{}]", .type_name(args[0]), .type_name(args[1]))
                } else if id.equals(optional_struct_id) {
                    output = format("{}?", .type_name(args[0]))
                } else if id.equals(range_struct_id) {
                    output = format("{}..{}", .type_name(args[0]), .type_name(args[0]))
                } else if id.equals(set_struct_id) {
                    output = format("{{{}}}", .type_name(args[0]))
                } else if id.equals(tuple_struct_id) {
                    output = "("
                    mut first = true
                    for arg in args.iterator() {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(type_id)
                    }
                    output += "}"
                } else if id.equals(weak_ptr_struct_id) {
                    output = format("weak {}?", .type_name(args[0]))
                } else {
                    let structure = .get_struct(id)
                    output = structure.name
                    output += "<"
                    mut first = true
                    for arg in args.iterator() {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }
                        output += .type_name(type_id)
                    }
                    output += ">"
                }

                yield output
            }
            GenericResolvedType(id, args) => {
                mut output = .program.get_struct(id).name
                mut first = true
                output += "<"
                for arg in args.iterator() {
                    if not first {
                        output += ", "
                    } else {
                        first = false
                    }
                    output += .type_name(type_id)
                }
                output += ">"

                yield output
            }
            TypeVariable(name) => name
            RawPtr(type_id) => format("raw {}", .type_name(type_id))
        }
    }

    // FIXME: not a method of expression because of https://github.com/SerenityOS/jakt/issues/527
    function expression_span(this, anon expr: CheckedExpression) -> Span => match expr {
        Boolean(span) => span
        NumericConstant(span) => span
        QuotedString(span) => span
        ByteConstant(span) => span
        CharacterConstant(span) => span
        UnaryOp(span) => span
        BinaryOp(span) => span
        JaktTuple(span) => span
        Range(span) => span
        JaktArray(span) => span
        JaktDictionary(span) => span
        JaktSet(span) => span
        IndexedExpression(span) => span
        IndexedDictionary(span) => span
        IndexedTuple(span) => span
        IndexedStruct(span) => span
        Call(span) => span
        MethodCall(span) => span
        NamespacedVar(span) => span
        Var(span) => span
        OptionalNone(span) => span
        OptionalSome(span) => span
        ForcedUnwrap(span) => span
        Match(span) => span
        Block(span) => span
        Garbage(span) => span
    }

    function expression_is_mutable(this, anon expr: CheckedExpression) -> bool => match expr {
        Var(var) => var.is_mutable
        IndexedStruct(expr) => .expression_is_mutable(expr)
        IndexedExpression(expr) => .expression_is_mutable(expr)
        IndexedTuple(expr) => .expression_is_mutable(expr)
        IndexedDictionary(expr) => .expression_is_mutable(expr)
        ForcedUnwrap(expr) => .expression_is_mutable(expr)
        else => false
    }

    function unify(mut this, lhs: TypeId, lhs_span: Span, rhs: TypeId, rhs_span: Span) throws -> TypeId? {
        // FIXME: Add more unification logic
        if lhs.id != rhs.id {
            .error("types incompatible ", rhs_span)
            return None
        } else {
            return lhs
        }
    }

    function find_or_add_type_id(mut this, anon type: Type) throws -> TypeId {
        let module = .program.modules[.current_module_id.id]
        let module_id = module.id

        mut idx = 0uz
        for item in module.types.iterator() {
            if item.equals(type) {
                return TypeId(module: module_id, id: idx)
            }
            ++idx
        }

        idx = 0uz
        for item in .program.modules[0].types.iterator() {
            if item.equals(type) {
                return TypeId(module: .program.modules[0].id, id: idx)
            }
            ++idx
        }

        .program.modules[.current_module_id.id].types.push(type)

        return TypeId(module: module_id, id: .current_module().types.size() - 1)
    }

    function find_type_in_scope(this, scope_id: ScopeId, name: String) throws -> TypeId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_type = scope.types.get(name)
            if maybe_type.has_value() {
                return maybe_type
            }
            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    function find_enum_in_scope(this, scope_id: ScopeId, name: String) throws -> EnumId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_enum = scope.enums.get(name)
            if maybe_enum.has_value() {
                return maybe_enum
            }
            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    // Find the namespace in the current scope, or one of its parents,
    // and whether the found scope was an import.
    function find_namespace_in_scope(this, scope_id: ScopeId, name: String) throws -> (ScopeId, bool)? {
        mut current = scope_id;

        loop {
            let scope = .get_scope(current)

            for child in scope.children.iterator() {
                let child_scope = .get_scope(child)
                if child_scope.namespace_name.has_value() {
                    if name == child_scope.namespace_name.value() {
                        return (child, false)
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        // if we do not find it then check imports
        let module_id = scope_id.module_id

        let search_scope_id = ScopeId(module_id: module_id, id: 0)
        let search_scope = .get_scope(search_scope_id)
        let search_imports = search_scope.imports
        let maybe_import: ModuleId? = search_imports.get(name)
        if maybe_import.has_value() {
            let import_module_id: ModuleId = maybe_import!
            let import_scope_id = ScopeId(module_id: import_module_id, id: 0)
            return (import_scope_id, true)
        }

        return None
    }

    function add_struct_to_scope(mut this, scope_id: ScopeId, name: String, struct_id: StructId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_scope_id = scope.structs.get(name)
        if maybe_scope_id.has_value() {
            let existing_struct_id = maybe_scope_id!
            let definition_span = .get_struct(existing_struct_id).name_span

            .error_with_hint(
                format("redefinition of struct/class {}", name)
                span
                format("struct/class {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.structs.set(key: name, value: struct_id)
        return true
    }

    function add_enum_to_scope(mut this, scope_id: ScopeId, name: String, enum_id: EnumId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_enum_id = scope.enums.get(name)
        if maybe_enum_id.has_value() {
            let existing_enum_id = maybe_enum_id!
            let definition_span = .get_enum(existing_enum_id).name_span

            .error_with_hint(
                format("redefinition of enum {}", name)
                span
                format("enum {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.enums.set(key: name, value: enum_id)
        return true
    }

    function add_type_to_scope(mut this, scope_id: ScopeId, type_name: String, type_id: TypeId, span: Span) throws -> bool {
        mut scope = .get_scope(id: scope_id)
        let found_type_id = .find_type_in_scope(scope_id, name: type_name)
        if found_type_id.has_value() {
            // FIXME: Show hint of the original definition, once we store the name span.
            .error(
                format("Redefinition of type {}", type_name)
                span
            )
            return false
        }
        scope.types.set(key: type_name, value: type_id)
        return true
    }

    function add_function_to_scope(mut this, parent_scope_id: ScopeId, name: String, function_id: FunctionId, span: Span) throws -> bool {
        mut scope = .get_scope(id: parent_scope_id)
        for existing_function in scope.functions.iterator() {
            if name == existing_function.0 {
                let function_ = .get_function(existing_function.1)
                .error_with_hint(message: format("Redefinition of function {}", name), span, hint: "previous definition here", hint_span: function_.name_span)
                return false
            }
        }
        scope.functions.set(key: name, value: function_id)
        return true
    }

    function add_var_to_scope(mut this, scope_id: ScopeId, name: String, var_id: VarId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        for existing_var in scope.vars.iterator() {
            if name == existing_var.0 {
                let variable_ = .get_variable(existing_var.1)
                .error_with_hint(message: format("Redefinition of variable {}", name), span, hint: "previous definition here", hint_span: variable_.definition_span)
            }
        }
        scope.vars.set(key: name, value: var_id)
        return true
    }
    
    function find_function_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> FunctionId? {
        mut scope_id = Some(parent_scope_id)
        while scope_id.has_value() {
            let scope = .get_scope(id: scope_id!)
            let maybe_function = scope.functions.get(function_name)
            if maybe_function.has_value() {
                return maybe_function
            }
            if scope.parent.has_value() {
                if scope_id!.equals(scope.parent!) {
                    .compiler.panic(format("Scope {} is its own parent!", scope_id))
                }
            }
            scope_id = scope.parent
        }

        return None
    }

    function find_struct_in_scope(this, scope_id: ScopeId, name: String) throws -> StructId? {
        mut current_scope_id = Some(scope_id)
        while current_scope_id.has_value() {
            let scope = .get_scope(id: current_scope_id!)
            let maybe_scope = scope.structs.get(name)
            if maybe_scope.has_value() {
                return maybe_scope
            }
            current_scope_id = scope.parent
        }
        return None
    }

    function typecheck_module(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        .typecheck_namespace_imports(parsed_namespace, scope_id)
        .typecheck_namespace_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_fields(parsed_namespace, scope_id)
        .typecheck_namespace_declarations(parsed_namespace, scope_id)
    }

    function typecheck_namespace_fields(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for namespce in parsed_namespace.namespaces.iterator() {
            let namespace_name = namespce.name
            mut namespace_scope_id = .prelude_scope_id()
            if namespace_name.has_value() {
                // Typecheck struct fields in the named namespaces
                let namespace_scope_tuple = .find_namespace_in_scope(scope_id, name: namespace_name!)
                if not namespace_scope_tuple.has_value() {
                    .compiler.panic(format("can't find previously added namespace {}", namespace_name!))
                }
                namespace_scope_id = namespace_scope_tuple!.0
            } else {
                // Typecheck struct fields in the unnamed namespace
                namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
                mut scope = .get_scope(scope_id)
                scope.children.push(namespace_scope_id)
            }

            .typecheck_namespace_fields(parsed_namespace: namespce, scope_id: namespace_scope_id)
        }

        for record in parsed_namespace.records.iterator() {
            if record.record_type is Struct or record.record_type is Class {
                let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                if not struct_id.has_value() {
                    .compiler.panic("can't find previously added struct")
                }
                .typecheck_struct_fields(record, struct_id: struct_id!)
            }
        }
    }

    function typecheck_struct_fields(mut this, record: ParsedRecord, struct_id: StructId) throws {
        mut structure = .get_struct(struct_id)

        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let parsed_fields = match record.record_type {
            Struct(fields) => fields
            Class(fields) => fields
            else => {
                .compiler.panic("typecheck_struct_fields cannot handle non-structs")
                let none: [ParsedField] = []
                yield none
            }
        }

        for unchecked_member in parsed_fields.iterator() {
            let parsed_var_decl = unchecked_member.var_decl
            let checked_member_type = .typecheck_typename(parsed_type: parsed_var_decl.parsed_type, scope_id: checked_struct_scope_id, ignore_errors: false)

            mut module = .current_module()
            let var_id = module.add_variable(checked_variable: CheckedVariable(
                name: parsed_var_decl.name
                type_id: checked_member_type
                is_mutable: parsed_var_decl.is_mutable
                definition_span: parsed_var_decl.span
                visibility: unchecked_member.visibility
            ))
            structure.fields.push(var_id)
        }
    }

    function typecheck_namespace_imports(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws -> bool {

        for import_ in parsed_namespace.imports.iterator() {
            //TODO include paths
            .compiler.dbg_println(format("import module name: {}", import_.module_name.name))
            mut already_loaded = false
            mut imported_module_id: ModuleId? = None

            // FIXME: use match
            let maybe_loaded_module = .program.get_loaded_module(import_.module_name.name)
            if maybe_loaded_module.has_value() {
                already_loaded = true
                imported_module_id = maybe_loaded_module!.module_id
            }

            if not already_loaded {
                mut file_contents: [u8] = []
                let file_name = FilePath::make(format("{}{}.jakt", .get_root_path().dirname(), import_.module_name.name))

                mut was_able_to_load_file = true // FIXME: return false directly in try scope
                try {
                    mut file = File::open_for_reading(file_name.path)
                    file_contents = file.read_all()
                } catch error {
                    mut panic_message: String = ""
                    try {
                        .error(format("Module '{}' not found", import_.module_name.name), import_.module_name.span)
                        was_able_to_load_file = false
                    } catch {
                        panic("couldn't create panic message for module file loading error")
                    }
                }
                if not was_able_to_load_file {
                    return false
                }
                let parsed_namespace = .lex_and_parse_file_contents(file_contents)
                let original_current_module_id = .current_module_id

                imported_module_id = .create_module(name: import_.module_name.name, is_root: false)
                .program.set_loaded_module(
                    module_name: import_.module_name.name
                    loaded_module: LoadedModule(
                        module_id: imported_module_id!
                        file_name
                        file_contents
                ))

                .current_module_id = imported_module_id!
                
                let imported_scope_id = .create_scope(parent_scope_id: .root_scope_id(), can_throw: false)
                .typecheck_module(parsed_namespace: parsed_namespace, scope_id: imported_scope_id)

                .current_module_id = original_current_module_id
            }

            mut current_module_imports = .current_module().imports
            current_module_imports.push(imported_module_id.value())

            if import_.import_list.is_empty() {
                mut scope_imports = .get_scope(scope_id).imports

                mut import_name = import_.module_name.name
                if (import_.alias_name.has_value()) {
                    import_name = import_.alias_name.value().name
                }
                scope_imports.set(
                   key: import_name
                   value: imported_module_id! // FIXME: Add span and should this be alias span if there is an alias?
                )
            } else {

                let import_scope_id = ScopeId(module_id: imported_module_id!, id: 0)
                for imported_name in import_.import_list.iterator() {

                    // if it is a function, add function to scope
                    let maybe_function_id = .find_function_in_scope(
                        parent_scope_id: import_scope_id
                        function_name: imported_name.name
                    )
                    if maybe_function_id.has_value() {
                        // NOTE: what should we do if this returns false? error is already created in the function itself and rust compiler goes on
                        .add_function_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.name
                            function_id: maybe_function_id!
                            span: imported_name.span
                        )
                    }

                    // if it is an enum, add enum to scope
                    let maybe_enum_id = .find_enum_in_scope(
                        scope_id: import_scope_id
                        name: imported_name.name
                    )
                    if maybe_enum_id.has_value() {
                        // NOTE: what should we do if this returns false? error is already created in the enum itself and rust compiler goes on
                        .add_enum_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.name
                            enum_id: maybe_enum_id!
                            span: imported_name.span 
                        )
                    }

                    // if it is a type, add type to scope
                    let maybe_type_id = .find_type_in_scope(
                        scope_id: import_scope_id
                        name: imported_name.name
                    )
                    if maybe_type_id.has_value() {
                        // NOTE: what should we do if this returns false? error is already created in the type itself and rust compiler goes on 
                        .add_type_to_scope(
                            parent_scope_id: scope_id
                            type_name: imported_name.name
                            type_id: maybe_type_id!
                            span: imported_name.span
                        )
                    }

                    // if it is a struct, add struct to scope
                    let maybe_struct_id = .find_struct_in_scope(
                        scope_id: import_scope_id
                        name: imported_name.name
                    )
                    if maybe_struct_id.has_value() {
                        // NOTE: what should we do if this returns false? error is already created in the struct itself and rust compiler goes on 
                        .add_struct_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.name
                            struct_id: maybe_struct_id!
                            span: imported_name.span
                        )
                    }
                }
            }
        }

        return true
    }

    function typecheck_namespace_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let module_struct_len = .current_module().structures.size()
        let module_enum_len = .current_module().enums.size()

        // 1. Initialize structs
        mut struct_index: usize = 0
        mut enum_index: usize = 0
        for parsed_record in parsed_namespace.records.iterator() {
            match parsed_record.record_type {
                Struct | Class => { .typecheck_struct_predecl_initial(parsed_record, struct_index: struct_index++, module_struct_len, scope_id) }
                SumEnum | ValueEnum => { .typecheck_enum_predecl_initial(parsed_record, enum_index: enum_index++, module_enum_len, scope_id) }
                else => {
                    todo(format("typecheck_namespace_predecl: else {}", parsed_record.record_type))
                }
            }
        }
        // 2. Typecheck subnamespaces
        for namespce in parsed_namespace.namespaces.iterator() {
            // Find all predeclarations in namespaces that are children of this namespace
            if namespce.name.has_value() {
                let namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

                mut child_scope = .get_scope(namespace_scope_id)
                child_scope.namespace_name = namespce.name!

                mut parent_scope = .get_scope(scope_id)
                parent_scope.children.push(namespace_scope_id)

                .typecheck_namespace_predecl(parsed_namespace: namespce, scope_id: namespace_scope_id)
            }
        }
        // 3. Typecheck struct predeclaration
        struct_index = 0
        enum_index = 0
        for parsed_record in parsed_namespace.records.iterator() {
            let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
            match parsed_record.record_type {
                Struct | Class => {
                    .typecheck_struct_predecl(parsed_record, struct_id, scope_id)
                    struct_index++
                }
                SumEnum | ValueEnum => {
                    let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
                    .typecheck_enum_predecl(parsed_record, enum_id, scope_id)
                    enum_index++
                }
                else => {
                    todo(format("typecheck_namespace_predecl: else {}", parsed_record.record_type))
                }
            }
        }
        // 4. Typecheck functions
        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function_predecl(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_enum_predecl_initial(mut this, parsed_record: ParsedRecord, enum_index: usize, module_enum_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
        mut module = .current_module()
        module.types.push(Type::Enum(enum_id))

        let enum_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: enum_type_id, span: parsed_record.name_span)

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }
        // Add a placeholder entry, this will be replaced later.
        module.enums.push(CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            scope_id: .prelude_scope_id()
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id: enum_type_id
            type_id: enum_type_id
            is_boxed
        ))
    }

    function typecheck_enum_predecl(mut this, parsed_record: ParsedRecord, enum_id: EnumId, scope_id: ScopeId) throws {
        let enum_type_id = .find_or_add_type_id(type: Type::Enum(enum_id))

        let enum_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

        .add_enum_to_scope(scope_id, name: parsed_record.name, enum_id, span: parsed_record.name_span)

        let underlying_type_id = match parsed_record.record_type {
            ValueEnum(underlying_type) => .typecheck_typename(parsed_type: underlying_type, scope_id, ignore_errors: false)
            else => builtin(BuiltinType::Void)
        }

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }
        mut module = .current_module()
        module.enums[enum_id.id] = CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            scope_id: enum_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id
            type_id: enum_type_id
            is_boxed
        )

        mut generic_parameters: [TypeId] = module.enums[enum_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: enum_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }
    }

    function typecheck_struct_predecl(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {

        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let struct_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)

        .add_struct_to_scope(scope_id, name: parsed_record.name, struct_id, span: parsed_record.name_span)

        let is_extern = parsed_record.definition_linkage

        mut module = .current_module()
        module.structures[struct_id.id] = CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: struct_scope_id
            definition_linkage: is_extern
            record_type: parsed_record.record_type
            type_id: struct_type_id
        )

        mut generic_parameters: [TypeId] = module.structures[struct_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: struct_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        for method in parsed_record.methods.iterator() {
            let func = method.parsed_function

            let method_scope_id = .create_scope(parent_scope_id: struct_scope_id, can_throw: func.can_throw)
            let block_scope_id = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw)

            let is_generic = not parsed_record.generic_parameters.is_empty() or not func.generic_parameters.is_empty()

            let none_type_id: TypeId? = None
            mut checked_function = CheckedFunction(
                name: func.name
                name_span: func.name_span
                visibility: method.visibility
                return_type_id: unknown_type_id()
                params: []
                generic_params: []
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    definitely_returns: false
                    yielded_type: none_type_id
                )
                can_throw: func.can_throw
                type: func.type
                linkage: func.linkage
                function_scope_id: method_scope_id
            )

            module.functions.push(checked_function)
            let function_id = FunctionId(
                module: .current_module_id
                id: .current_module().functions.size() - 1
            )
            let previous_index = .current_function_id
            .current_function_id = function_id

            mut check_scope: ScopeId? = None
            if is_generic {
                check_scope = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw)
            }

            for gen_parameter in func.generic_parameters.iterator() {
                module.types.push(Type::TypeVariable(gen_parameter.name))
                let type_var_type_id = TypeId(
                    module: .current_module_id
                    id: .current_module().types.size() - 1
                )

                checked_function.generic_params.push(FunctionGenericParameter::Parameter(type_var_type_id))
                .add_type_to_scope(scope_id: method_scope_id, type_name: gen_parameter.name, type_id: type_var_type_id, span: gen_parameter.span)
            }

            for param in func.params.iterator() {
                if param.variable.name == "this" {
                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: struct_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        visibility: Visibility::Public
                    )

                    checked_function.params.push(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                } else {
                    let param_type = .typecheck_typename(parsed_type: param.variable.parsed_type, scope_id: method_scope_id, ignore_errors: false)

                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: param_type
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        visibility: Visibility::Public
                    )

                    checked_function.params.push(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                }
            }

            .add_function_to_scope(
                parent_scope_id: struct_scope_id
                name: func.name
                function_id: FunctionId(module: .current_module_id, id: .current_module().functions.size() - 1)
                span: parsed_record.name_span
            )

            let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: method_scope_id, ignore_errors: false)

            checked_function.return_type_id = function_return_type_id

            if is_generic {
                if not check_scope.has_value() {
                    .compiler.panic("Generic method with generic parameters must have a check scope")
                }

                let block = .typecheck_block(parsed_block: func.block, parent_scope_id: check_scope!, safety_mode: SafetyMode::Safe)

                mut return_type_id: TypeId = builtin(BuiltinType::Void)
                if function_return_type_id.equals(unknown_type_id()) {
                    if not block.statements.is_empty() {
                        let ret = block.statements[block.statements.size() - 1]
                        // expression_type
                        match ret {
                            Return(val) => {
                                if val.has_value() {
                                    return_type_id = .resolve_type_var(type_var_type_id: expression_type(val!), scope_id: method_scope_id)
                                }
                            }
                            else => {}
                        }
                    }
                } else {
                    return_type_id = .resolve_type_var(type_var_type_id: function_return_type_id, scope_id)
                }

                checked_function.block = block
                checked_function.return_type_id = return_type_id
            }

            module.functions[function_id.id] = checked_function
            .current_function_id = previous_index
        }

        module.structures[struct_id.id].generic_parameters = generic_parameters

        .current_struct_type_id = None
    }

    function typecheck_struct_predecl_initial(mut this, parsed_record: ParsedRecord, struct_index: usize, module_struct_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
        mut module = .current_module()
        module.types.push(Type::Struct(struct_id))

        let struct_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: struct_type_id, span: parsed_record.name_span)

        // Add a placeholder entry, this will be replaced later.
        module.structures.push(CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: .prelude_scope_id()
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
        ))
    }

    function typecheck_namespace_declarations(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for namespce in parsed_namespace.namespaces.iterator() {
            mut namespace_scope_id: ScopeId = .prelude_scope_id()
            if namespce.name.has_value() {
                // Finish typecheck of the named namespaces
                let namespace_name = namespce.name!
                let namespace_scope_tuple = .find_namespace_in_scope(scope_id, name: namespace_name)

                if not namespace_scope_tuple.has_value() {
                    .compiler.panic("can't find previously added namespace")
                }
                namespace_scope_id = namespace_scope_tuple!.0
            } else {
                // Create the unnamed namespace (aka a block scope)
                namespace_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
                mut scope = .get_scope(scope_id)
                scope.children.push(namespace_scope_id)

                .typecheck_namespace_predecl(parsed_namespace: namespce, scope_id: namespace_scope_id)
            }
            .typecheck_namespace_declarations(parsed_namespace: namespce, scope_id: namespace_scope_id)
        }

        for record in parsed_namespace.records.iterator() {
            match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        .compiler.panic("can't find struct that has been previous added")
                    }
                    .typecheck_struct(record, struct_id: struct_id!, parent_scope_id: scope_id)
                }
                SumEnum | ValueEnum => {
                    let enum_id = .find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        panic("can't find enum that has been previous added")
                    }
                    .typecheck_enum(record, enum_id: enum_id!, parent_scope_id: scope_id)
                }
                else => {
                    todo(format("typecheck_namespace_declarations implement parsion of record type {}", record.record_type))
                }
            }
        }

        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_enum(mut this, record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        mut checked_variants: [CheckedEnumVariant] = []
        mut next_constant_value = 0u64
        mut seen_names: {String} = {}

        mut enum_ = .get_enum(enum_id)

        match record.record_type {
            ValueEnum(underlying_type, variants) => {
                let underlying_type_id = .typecheck_typename(parsed_type: underlying_type, scope_id: parent_scope_id, ignore_errors: false)
                mut module = .current_module()
                for variant in variants.iterator() {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                    } else {
                        seen_names.add(variant.name)

                        let expr = match variant.value.has_value() {
                            true => {
                                let value_expression = .cast_to_underlying(variant.value!, scope_id: parent_scope_id, parsed_type: underlying_type)
                                let number_constant = value_expression.to_number_constant(program: .program)
                                match number_constant.has_value() {
                                    true => {
                                        next_constant_value = match number_constant! {
                                            Signed(val) => (val + 1) as! u64
                                            Unsigned(val) => val + 1
                                            Floating(val) => {
                                                todo("Implement floats")
                                                yield 0u64
                                            }
                                        }
                                    }
                                    else => {
                                        .error(format("Enum variant '{}' in enum '{}' has a non-constant value: {}", variant.name, enum_.name, value_expression), variant.span)
                                    }
                                }
                                yield value_expression
                            }
                            else => .cast_to_underlying(
                                expr: ParsedExpression::NumericConstant(val: NumericConstant::U64(next_constant_value++), span: variant.span)
                                scope_id: parent_scope_id
                                parsed_type: underlying_type
                            )
                        }
                        
                        enum_.variants.push(CheckedEnumVariant::WithValue(name: variant.name, expr, span: variant.span))
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant.name
                            type_id: underlying_type_id
                            is_mutable: false
                            definition_span: variant.span
                            visibility: Visibility::Public
                        ))
                        .add_var_to_scope(scope_id: enum_.scope_id, name: variant.name, var_id, span: variant.span)
                    }
                }
            }
            SumEnum(is_boxed, variants) => {
                mut module = .current_module()
                for variant in variants.iterator() {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                        continue
                    } 
                    seen_names.add(variant.name)
                    let is_structlike = variant.params.has_value() and variant.params!.size() > 0 and variant.params![0].name != ""
                    let is_typed = variant.params.has_value() and variant.params!.size() == 1 and variant.params![0].name == ""
                    if is_structlike {
                        mut seen_fields: {String} = {}
                        mut fields: [VarId] = []
                        mut params: [CheckedParameter] = []
                        for param in variant.params!.iterator() {
                            if seen_fields.contains(param.name) {
                                .error(format("Enum variant '{}' has a member named '{}' more than once", variant.name, param.name), param.span)
                                continue
                            }
                            seen_fields.add(param.name)

                            let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, ignore_errors: false)
                            let checked_var = CheckedVariable(
                                name: param.name
                                type_id
                                is_mutable: param.is_mutable
                                definition_span: param.span
                                visibility: Visibility::Public
                            )
                            params.push(CheckedParameter(requires_label: true, variable: checked_var))

                            // TODO: dump type hints

                            mut module = .current_module()
                            let var_id = module.add_variable(checked_var)
                            .add_var_to_scope(scope_id: enum_.scope_id, name: checked_var.name, var_id, span: checked_var.definition_span)
                            fields.push(var_id)
                        }
                        enum_.variants.push(CheckedEnumVariant::StructLike(name: variant.name, fields, span: variant.span))
                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw)
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw)
                            let none_type_id: TypeId? = None
                            let checked_function = CheckedFunction(
                                name: variant.name,
                                name_span: variant.span,
                                visibility: Visibility::Public,
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id)),
                                params,
                                generic_params: [],
                                block: CheckedBlock(statements: [], scope_id: block_scope_id, definitely_returns: true, yielded_type: none_type_id),
                                can_throw: can_function_throw,
                                type: FunctionType::ImplicitEnumConstructor,
                                linkage: FunctionLinkage::Internal,
                                function_scope_id
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    } else if is_typed {
                        let param = variant.params![0]
                        let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, ignore_errors: false)
                        enum_.variants.push(CheckedEnumVariant::Typed(name: variant.name, type_id, span: param.span))

                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw)
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw)
                            let none_type_id: TypeId? = None
                            let variable = CheckedVariable(
                                name: "value"
                                type_id
                                is_mutable: false
                                definition_span: param.span
                                visibility: Visibility::Public
                            )
                            let checked_function = CheckedFunction(
                                name: variant.name,
                                name_span: variant.span,
                                visibility: Visibility::Public,
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id)),
                                params: [CheckedParameter(requires_label: false, variable)],
                                generic_params: [],
                                block: CheckedBlock(statements: [], scope_id: block_scope_id, definitely_returns: true, yielded_type: none_type_id),
                                can_throw: can_function_throw,
                                type: FunctionType::ImplicitEnumConstructor,
                                linkage: FunctionLinkage::Internal,
                                function_scope_id
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    } else {
                        enum_.variants.push(CheckedEnumVariant::Untyped(name: variant.name, span: variant.span))
                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw)
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw)
                            let none_type_id: TypeId? = None
                            let checked_function = CheckedFunction(
                                name: variant.name,
                                name_span: variant.span,
                                visibility: Visibility::Public,
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id)),
                                params: [],
                                generic_params: [],
                                block: CheckedBlock(statements: [], scope_id: block_scope_id, definitely_returns: true, yielded_type: none_type_id),
                                can_throw: can_function_throw,
                                type: FunctionType::ImplicitEnumConstructor,
                                linkage: FunctionLinkage::Internal,
                                function_scope_id
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    }
                }
            }
            else => {}
        }
    }

    function cast_to_underlying(mut this, anon expr: ParsedExpression, scope_id: ScopeId, parsed_type: ParsedType) throws -> CheckedExpression {
        let cast_expression = ParsedExpression::UnaryOp(expr, op: UnaryOperator::TypeCast(TypeCast::Infallible(parsed_type)), span: expr.span())
        return .typecheck_expression(cast_expression, scope_id, safety_mode: SafetyMode::Safe)
    }

    function typecheck_struct(mut this, record: ParsedRecord, struct_id: StructId, parent_scope_id: ScopeId) throws {
        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        let module_id = .current_module_id
        .current_struct_type_id = struct_type_id

        let constructor_id = .find_function_in_scope(parent_scope_id: checked_struct_scope_id, function_name: record.name)
        if constructor_id.has_value() {
            if record.record_type is Class and record.definition_linkage is External {
                // XXX: The parser always sets the linkage type of an extern class'
                //      constructor to External, but we actually want to call the
                //      class' ::create function, just like we do with a
                //      ImplicitConstructor class.
                mut func = .get_function(constructor_id!)
                func.linkage = FunctionLinkage::External
            }
        } else if not record.definition_linkage is External {
            // No constructor found, so let's make one

            let constructor_can_throw = record.record_type is Class
            let function_scope_id = .create_scope(parent_scope_id, can_throw: constructor_can_throw)
            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: constructor_can_throw)

            let none_type_id: TypeId? = None
            let checked_constructor = CheckedFunction(
                name: record.name
                name_span: record.name_span
                visibility: Visibility::Public
                return_type_id: struct_type_id
                params: []
                generic_params: []
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    definitely_returns: false
                    yielded_type: none_type_id
                )
                can_throw: constructor_can_throw
                type: FunctionType::ImplicitConstructor
                linkage: FunctionLinkage::Internal
                function_scope_id
            )

            // Internal constructor
            mut module = .current_module()
            module.functions.push(checked_constructor)

            mut func = module.functions[module.functions.size() - 1]
            for field_id in .get_struct(struct_id).fields.iterator() {
                let field = .get_variable(field_id)
                func.params.push(CheckedParameter(
                    requires_label: true
                    variable: field
                ))
            }

            // Add constructor to the struct's scope
            .add_function_to_scope(
                parent_scope_id: checked_struct_scope_id
                name: record.name
                function_id: FunctionId(module: module_id, id: .current_module().functions.size() - 1)
                span: record.name_span
            )
        }

        for method in record.methods.iterator() {
            .typecheck_method(func: method.parsed_function, parent_id: StructOrEnumId::Struct(struct_id))
        }

        .current_struct_type_id = None
    }

    function typecheck_method(mut this, func: ParsedFunction, parent_id: StructOrEnumId) throws {
        mut parent_generic_parameters: [TypeId] = []
        mut scope_id = .prelude_scope_id()
        mut definition_linkage = DefinitionLinkage::Internal

        match parent_id {
            Struct(struct_id) => {
                mut structure = .get_struct(struct_id)
                parent_generic_parameters = structure.generic_parameters
                scope_id = structure.scope_id
                definition_linkage = structure.definition_linkage
            }
            Enum => {
                todo("typecheck_method implement enum case")
            }
        }

        if (not func.generic_parameters.is_empty() or not parent_generic_parameters.is_empty()) and not func.must_instantiate {
            return
        }

        let structure_scope_id = scope_id
        let structure_linkage = definition_linkage

        let method_id = .find_function_in_scope(parent_scope_id: structure_scope_id, function_name: func.name)
        if not method_id.has_value() {
            .compiler.panic("we just pushed the checked function, but it's not present")
        }

        mut checked_function = .get_function(method_id!)
        let function_scope_id = checked_function.function_scope_id

        mut module = .current_module()
        for param in checked_function.params.iterator() {
            let variable = param.variable
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Set current function index before a block type check so that
        // method return type is checked against its implementation
        .current_function_id = method_id

        let VOID_TYPE_ID = builtin(BuiltinType::Void)

        let block = .typecheck_block(parsed_block: func.block, parent_scope_id: function_scope_id, safety_mode: SafetyMode::Safe)
        let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: function_scope_id, ignore_errors: false)

        mut return_type_id = function_return_type_id
        if function_return_type_id.equals(unknown_type_id()) and not block.statements.is_empty() {
            // If the return type is unknown, and the function starts with a return statement,
            // we infer the return type from its expression.
            match block.statements[0] {
                Return(val) => {
                    if val.has_value() {
                        return_type_id = expression_type(val!)
                    } else {
                        return_type_id = VOID_TYPE_ID
                    }
                }
                else => {
                    return_type_id = VOID_TYPE_ID
                }
            }
        } else if function_return_type_id.equals(unknown_type_id()) {
            return_type_id = VOID_TYPE_ID
        }

        if not structure_linkage is External and not return_type_id.equals(VOID_TYPE_ID) and not block.definitely_returns {
            // FIXME: Use better span
            .error("Control reaches end of non-void function", func.name_span)
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function typecheck_function_predecl(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        let function_scope_id = .create_scope(parent_scope_id, can_throw: parsed_function.can_throw)
        let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: parsed_function.can_throw)
        let module_id = .current_module_id.id

        // TODO: Make this true if it's a method of a generic class/struct.
        let is_generic = not parsed_function.generic_parameters.is_empty()

        let none_type_id: TypeId? = None

        mut checked_function = CheckedFunction(
            name: parsed_function.name
            name_span: parsed_function.name_span
            visibility: parsed_function.visibility
            return_type_id: unknown_type_id()
            params: []
            generic_params: []
            block: CheckedBlock(
                statements: []
                scope_id: block_scope_id
                definitely_returns: false
                yielded_type: none_type_id
            )
            can_throw: parsed_function.can_throw
            type: FunctionType::Normal
            linkage: parsed_function.linkage
            function_scope_id
        )
        // FIXME: We can't return a `mut Foo` from a function right now, but assigning anything to a `mut` variable makes it mutable.
        //        AKA, working around one bug with another bug. :^)
        mut current_module = .current_module()
        let function_id = current_module.add_function(checked_function)
        let checked_function_scope_id = checked_function.function_scope_id

        // Check generic parameters
        for generic_parameter in parsed_function.generic_parameters.iterator() {

            current_module.types.push(Type::TypeVariable(generic_parameter.name))

            let type_var_type_id = TypeId(
                module: current_module.id
                id: current_module.types.size() - 1
            )
            checked_function.generic_params.push(FunctionGenericParameter::Parameter(type_var_type_id))

            let external_linkage = match parsed_function.linkage {
                FunctionLinkage::External => true
                else => false
            }
            if not parsed_function.must_instantiate or external_linkage {
                .add_type_to_scope(
                    scope_id: checked_function_scope_id
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }
        }

        // Check parameters
        for parameter in parsed_function.params.iterator() {
            let type_id = .typecheck_typename(parsed_type: parameter.variable.parsed_type, scope_id: checked_function_scope_id, ignore_errors: false)

            let variable = CheckedVariable(
                name: parameter.variable.name
                type_id
                is_mutable: parameter.variable.is_mutable
                definition_span: parameter.variable.span
                visibility: Visibility::Public
            )

            let checked_parameter = CheckedParameter(
                requires_label: parameter.requires_label
                variable
            )

            checked_function.params.push(checked_parameter)
        }

        // Check return type
        checked_function.return_type_id = .typecheck_typename(parsed_type: parsed_function.return_type, scope_id: checked_function_scope_id, ignore_errors: false)

        .add_function_to_scope(parent_scope_id, name: parsed_function.name, function_id, span: parsed_function.name_span)
    }

    function typecheck_jakt_main(mut this, parsed_function: ParsedFunction) throws {
        let param_type_error = "Main function must take a single array of strings as its parameter"
        if parsed_function.params.size() > 1 {
            .error(param_type_error, parsed_function.name_span)
        }

        if not parsed_function.params.is_empty() {
            match parsed_function.params[0].variable.parsed_type {
                ParsedType::JaktArray(inner, span) => {
                    match inner {
                        ParsedType::Name(name, span) => {
                            if (name != "String") {
                                .error(param_type_error, span)
                            }
                        }
                        else => {
                            .error(param_type_error, span)
                        }
                    }
                }
                else => {
                    .error(param_type_error, parsed_function.name_span)
                }
            }
        }

        let return_type_error = "Main function must return c_int"
        match parsed_function.return_type {
            ParsedType::Empty => {}
            ParsedType::Name(name, span) => {
                if name != "c_int" {
                    .error(return_type_error, span)
                }
            }
            else => {
                .error(return_type_error, parsed_function.return_type_span)
            }
        }
    }

    function typecheck_function(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        if not parsed_function.generic_parameters.is_empty() and not parsed_function.must_instantiate {
            return
        } 

        // FIXME: Optional.expect("...") would be nicer here.
        let function_id = .find_function_in_scope(parent_scope_id, function_name: parsed_function.name)
        if not function_id.has_value() {
            .compiler.panic("Internal error: missing previously defined function")
        }
        if parsed_function.name == "main" {
            .typecheck_jakt_main(parsed_function)
        }
        mut checked_function = .get_function(function_id!)
        let function_scope_id = checked_function.function_scope_id
        let function_linkage = checked_function.linkage

        mut param_vars: [CheckedVariable] = []

        for param in checked_function.params.iterator() {
            param_vars.push(param.variable)
        }

        for variable in param_vars.iterator() {
            mut module = .current_module()
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Resolve concrete types
        mut function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
            ignore_errors: false
        )
        checked_function.return_type_id = function_return_type_id

        // TODO: Typecheck function block
        let block = .typecheck_block(
            parsed_function.block
            parent_scope_id: function_scope_id
            safety_mode: SafetyMode::Safe
        )

        // Typecheck return type a second time to resolve generics
        function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
            ignore_errors: false
        )

        // Infer return type if necessary
        // If the return type is unknown, and the function starts with a return statement,
        // we infer the return type from its expression.
        let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)
        let VOID_TYPE_ID = builtin(BuiltinType::Void)
        mut return_type_id = VOID_TYPE_ID
        if function_return_type_id.equals(UNKNOWN_TYPE_ID) {
            if block.statements.is_empty() {
                return_type_id = VOID_TYPE_ID
            } else {
                let last_stmt: CheckedStatement = block.statements[block.statements.size() - 1]
                match last_stmt {
                    CheckedStatement::Return(val) => {
                        if val.has_value() {
                            return_type_id = expression_type(expr: val.value())
                        }
                    }
                    else => {
                        return_type_id = VOID_TYPE_ID
                    }
                }
            }
        } else {
            return_type_id = .resolve_type_var(
                type_var_type_id: function_return_type_id,
                scope_id: function_scope_id
            )
        }

        let external_linkage = match function_linkage {
            FunctionLinkage::External => true
            else => false
        }
        if not external_linkage and not return_type_id.equals(VOID_TYPE_ID) and not block.definitely_returns
        {
            // FIXME: Use better span
            .error("Control reaches end of non-void function", parsed_function.name_span)
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function statement_definitely_returns(this, anon statement: CheckedStatement) -> bool => match statement{
        Return => true
        // FIXME: CheckedStatement::If branches ugly implementation due to current compiler limitations
        If(condition, then_block, else_statement) => {
            mut ret = false
            let condition_result = match condition {
                Boolean(val) => {
                    if val and then_block.definitely_returns {
                        ret = true
                    }
                    yield ret
                }
                else => false
            }
            if not condition_result and else_statement.has_value(){
                if then_block.definitely_returns and .statement_definitely_returns(else_statement.value()) {
                    ret = true
                }
            }
            yield ret
        }
        Block(block) => block.definitely_returns
        Loop(block) => block.definitely_returns
        While(condition, block) => block.definitely_returns
        Expression(expr) => match expr {
            Match() => checked_expression_definitely_returns(expr)
            else => false
        }
        else => false
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function check_types_for_compat(mut this, lhs_type_id: TypeId, rhs_type_id: TypeId, mut generic_inferences: [String:String], span: Span) throws -> bool {
        let lhs_type = .get_type(lhs_type_id)

        let lhs_type_id_string = lhs_type_id.to_string()
        let rhs_type_id_string = rhs_type_id.to_string()

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

        
        match lhs_type {
            TypeVariable() => {
                // If the call expects a generic type variable, let's see if we've already seen it
                let seen_type_id_string = generic_inferences.get(lhs_type_id_string)
                if seen_type_id_string.has_value() {
                    // We've seen this type variable assigned something before
                    // we should error if it's incompatible.

                    if seen_type_id_string.value() != rhs_type_id_string {
                        .error(
                            format(
                                "Type mismatch: expected {}, but got {}"
                                .type_name(TypeId::from_string(seen_type_id_string.value()))
                                .type_name(rhs_type_id)
                            )
                            span
                        )
                        return false
                    }
                } else {
                    generic_inferences.set(key: lhs_type_id_string, value: rhs_type_id_string)
                }
            }
            GenericEnumInstance(id, args) => {
                let lhs_enum_id = id
                let lhs_args = args
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        let rhs_enum_id = id
                        let rhs_args = args
                        if lhs_enum_id.equals(rhs_enum_id) {
                            let lhs_enum = .get_enum(lhs_enum_id)
                            if lhs_args.size() != rhs_args.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_args[idx]
                                    rhs_type_id: rhs_args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            GenericInstance(id, args) => {
                let lhs_struct_id = id
                let lhs_args = args

                // If lhs is T? or weak T? and rhs is T, skip type compat check
                if (lhs_struct_id.equals(optional_struct_id)) or 
                    (lhs_struct_id.equals(weakptr_struct_id)) {
                    if lhs_args.size() > 0 {
                        if (lhs_args[0].equals(rhs_type_id)) {
                            return true
                        }
                    }
                }

                let rhs_type = .get_type(rhs_type_id)

                match rhs_type {
                    GenericInstance(id, args) => {
                        let rhs_struct_id = id
                        if lhs_struct_id.equals(rhs_struct_id) {
                            let rhs_args = args
                            let lhs_struct = .get_struct(lhs_struct_id)
                            if lhs_args.size() != rhs_args.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_args[idx]
                                    rhs_type_id: rhs_args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        } else {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Enum(enum_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        if enum_id.equals(id) {
                            let lhs_enum = .get_enum(enum_id)
                            if args.size() != lhs_enum.generic_parameters.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_enum.generic_parameters[idx]
                                    rhs_type_id: args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Struct(lhs_struct_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }
                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    GenericInstance(id, args) => {
                        let lhs_struct = .get_struct(lhs_struct_id)
                        if args.size() != lhs_struct.generic_parameters.size() {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_struct.generic_parameters[idx]
                                rhs_type_id: args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }

                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            RawPtr(lhs_rawptr_type_id) => {
                if lhs_rawptr_type_id.equals(rhs_type_id) {
                    return true
                }

                let rhs_type = .get_type(rhs_type_id)
                match rhs_type {
                    RawPtr(rhs_rawptr_type_id) => {
                        if not .check_types_for_compat(
                            lhs_type_id: lhs_rawptr_type_id
                            rhs_type_id: rhs_rawptr_type_id
                            generic_inferences
                            span
                        ) {
                            // FIXME: maybe emit secondary error?
                            return false
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            else => {
                if not rhs_type_id.equals(lhs_type_id) {
                    .error(
                        format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
        }

        return true
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: [String: String]) throws -> TypeId {
        mut result = .substitute_typevars_in_type_helper(type_id, generic_inferences)

        loop {
            let fixed_point = .substitute_typevars_in_type_helper(type_id, generic_inferences)

            if fixed_point.equals(result) {
                break
            } else {
                result = fixed_point
            }
        }
        return result
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function substitute_typevars_in_type_helper(mut this, type_id: TypeId , generic_inferences: [String: String]) throws -> TypeId {
        let type_ = .get_type(type_id)

        match type_ {
            TypeVariable() => {
                let replacment_type_id_string = generic_inferences.get(type_id.to_string())
                if replacment_type_id_string.has_value() {
                    return TypeId::from_string(replacment_type_id_string.value())
                }
            }
            GenericInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args.iterator() {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                }

                return .find_or_add_type_id(Type::GenericInstance(id, args: new_args))
            }
            GenericEnumInstance(id, args) => {
                mut new_args:[TypeId] = []
                new_args.ensure_capacity(args.size())
                for arg in args.iterator() {
                    new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                }
                return .find_or_add_type_id(Type::GenericEnumInstance(id, args: new_args))
            }
            Struct(struct_id) => {
                let struct_ = .get_struct(struct_id)
                if not struct_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(struct_.generic_parameters.size())
                    for arg in struct_.generic_parameters.iterator() {
                        new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                    }
                    return .find_or_add_type_id(Type::GenericInstance(id: struct_id, args: new_args))
                }
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                if not enum_.generic_parameters.is_empty() {
                    mut new_args:[TypeId] = []
                    new_args.ensure_capacity(enum_.generic_parameters.size())
                    for arg in enum_.generic_parameters.iterator() {
                        new_args.push(.substitute_typevars_in_type(type_id: arg, generic_inferences))
                    }
                    return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id, args: new_args))
                }
            }
            RawPtr(rawptr_type_id) => {
                let rawptr_type = Type::RawPtr(
                    .substitute_typevars_in_type(type_id: rawptr_type_id, generic_inferences)
                )
                return .find_or_add_type_id(rawptr_type)
            }
            else => {
                return type_id
            }
        }
        return type_id
    }

    function typecheck_block(mut this, anon parsed_block: ParsedBlock, parent_scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedBlock {
        let parent_throws = .get_scope(parent_scope_id).can_throw
        let block_scope_id = .create_scope(parent_scope_id, can_throw: parent_throws)
        let none_type_id: TypeId? = None
        mut checked_block = CheckedBlock(
            statements: []
            scope_id: block_scope_id
            definitely_returns: false
            yielded_type: none_type_id
        )
        // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
        mut generic_inferences: [String: String] = [:]

        for parsed_statement in parsed_block.stmts.iterator() {

            let checked_statement = .typecheck_statement(
                statement: parsed_statement
                scope_id: block_scope_id
                safety_mode
            )

            // check that statment definitly returns
            checked_block.definitely_returns = .statement_definitely_returns(checked_statement)

            let none_yield: Span? = None // FIXME: Can't yield None directly
            let yield_span: Span? = match parsed_statement {
                ParsedStatement::Yield(expr) => Some(expr.span())
                else => none_yield
            }
            let  none_expr: CheckedExpression? = None // FIXME: Can't yield None directly
            let checked_yield_expression: CheckedExpression? = match checked_statement {
                CheckedStatement::Yield(expr) => Some(expr)
                else => none_expr
            }
            if yield_span.has_value() and checked_yield_expression.has_value() {
                let type_var_type_id = expression_type(checked_yield_expression.value())
                let type_ = .resolve_type_var(type_var_type_id , scope_id: block_scope_id)
                if checked_block.yielded_type.has_value() {
                    // TODO check types for compat
                    .check_types_for_compat(
                        lhs_type_id: checked_block.yielded_type.value()
                        rhs_type_id: type_
                        generic_enferences: generic_inferences
                        span: yield_span.value()
                    )
                } else {
                    checked_block.yielded_type = Some(type_)
                }
            }

            checked_block.statements.push(checked_statement)
        }

        if checked_block.yielded_type.has_value() {
             checked_block.yielded_type = Some(.substitute_typevars_in_type(
                 type_id: checked_block.yielded_type.value()
                 generic_inferences
             ))
        }

        return checked_block
    }

    function typecheck_typename(mut this, parsed_type: ParsedType, scope_id: ScopeId, ignore_errors: bool) throws -> TypeId { 
        match parsed_type {
            NamespacedName(name, namespaces, params, span) => {
                mut current_namespace_scope_id = scope_id

                for ns in namespaces.iterator() {
                    let result = .find_namespace_in_scope(scope_id: current_namespace_scope_id, name: ns)

                    if result.has_value() {
                        current_namespace_scope_id = result!.0
                    } else {
                        .error(format("Unknown namespace: '{}'", ns), span)
                        return unknown_type_id()
                    }
                }

                mut generic_args: [TypeId] = []

                for param in params.iterator() {
                    let checked_arg = .typecheck_typename(parsed_type: param, scope_id, ignore_errors)

                    generic_args.push(checked_arg)
                }

                // TODO: add synthetic type_name and generic support

                if generic_args.is_empty() {
                    return .typecheck_typename(parsed_type, scope_id, ignore_errors)
                } else {
                    return .typecheck_generic_resolved_type(name, checked_inner_types: generic_args, scope_id, span)
                }
            }
            Name(name, span) => {
                return match name {
                    "i8" => builtin(BuiltinType::I8)
                    "i16" => builtin(BuiltinType::I16)
                    "i32" => builtin(BuiltinType::I32)
                    "i64" => builtin(BuiltinType::I64)
                    "u8" => builtin(BuiltinType::U8)
                    "u16" => builtin(BuiltinType::U16)
                    "u32" => builtin(BuiltinType::U32)
                    "u64" => builtin(BuiltinType::U64)
                    "f32" => builtin(BuiltinType::F32)
                    "f64" => builtin(BuiltinType::F64)
                    "c_char" => builtin(BuiltinType::CChar)
                    "c_int" => builtin(BuiltinType::CInt)
                    "usize" => builtin(BuiltinType::Usize)
                    "String" => builtin(BuiltinType::String)
                    "bool" => builtin(BuiltinType::Bool)
                    "void" => builtin(BuiltinType::Void)
                    else => {
                        let type_id = .find_type_in_scope(scope_id, name)

                        if type_id.has_value() {
                            return type_id.value()
                        } else {
                            if not ignore_errors {
                                .error(format("Unknown type {}", name), span)
                            }
                            return unknown_type_id()
                        }
                    }
                }
            }
            Empty => {
                return unknown_type_id()
            }
            JaktTuple(types, span) => {
                mut checked_types: [TypeId] = []
                for parsed_type in types.iterator() {
                    checked_types.push(.typecheck_typename(parsed_type, scope_id, ignore_errors))
                }
                let tuple_struct_id = .find_struct_in_prelude("Tuple")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

                return type_id
            }
            JaktArray(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, ignore_errors)

                let array_struct_id = .find_struct_in_prelude("Array")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))

                return type_id
            }
            Dictionary(key, value, span) => {
                let key_type_id = .typecheck_typename(parsed_type: key, scope_id, ignore_errors)
                let value_type_id = .typecheck_typename(parsed_type: value, scope_id, ignore_errors)

                let dict_struct_id = .find_struct_in_prelude("Dictionary")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: dict_struct_id, args: [key_type_id, value_type_id]))

                return type_id
            }
            Set(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, ignore_errors)

                let set_struct_id = .find_struct_in_prelude("Set")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [inner_type_id]))

                return type_id
            }
            Optional(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, ignore_errors)

                let optional_struct_id = .find_struct_in_prelude("Optional")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [inner_type_id]))

                return type_id
            }
            WeakPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, ignore_errors)

                let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: weakptr_struct_id, args: [inner_type_id]))

                return type_id
            }
            RawPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, ignore_errors)

                let type_id = .find_or_add_type_id(Type::RawPtr(id: inner_type_id))

                return type_id
            }
            GenericType(name, generic_parameters, span) => {
                mut checked_inner_types: [TypeId] = []

                for inner_type in generic_parameters.iterator() {
                    let inner_type_id = .typecheck_typename(parsed_type: inner_type, scope_id, ignore_errors)
                    checked_inner_types.push(inner_type_id)
                }

                return .typecheck_generic_resolved_type(name, checked_inner_types, scope_id, span)
            }
        }

        // FIXME: This is unreachable but the generated C++ causes a warning.
        .compiler.panic("should be unreachable")
        return unknown_type_id()
    }

    function typecheck_generic_resolved_type(mut this, name: String, checked_inner_types: [TypeId], scope_id: ScopeId, span: Span) throws -> TypeId {

        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return .find_or_add_type_id(Type::GenericInstance(id: struct_id!, args: checked_inner_types))
        }

        let enum_id = .find_enum_in_scope(scope_id, name)
        if enum_id.has_value() {
            return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id!, args: checked_inner_types))
        }

        .error(format("could not find {}", name), span)
        return unknown_type_id()
    }

    function typecheck_unary_operation(mut this, checked_expr: CheckedExpression, checked_op: CheckedUnaryOperator, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let expr_type_id = expression_type(checked_expr)
        let expr_type = .get_type(expr_type_id)

        match checked_op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                if .is_integer(expr_type_id) {
                    if not .expression_is_mutable(checked_expr) {
                        .error("Increment/decrement of immutable variable", span)
                    }
                } else {
                    .error("Increment/decrement of non-numeric value", span)
                }
            }
            LogicalNot | BitwiseNot => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            TypeCast(cast) => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: cast.type_id())
            }
            Negate => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            Is | IsEnumVariant => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: builtin(BuiltinType::Bool))
            }
            else => {
                todo(format("typecheck_unary_operation: expr:{}, op:{}", checked_expr, checked_op))
            }
        }
        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
    }

    function typecheck_binary_operation(mut this, checked_lhs: CheckedExpression, op: BinaryOperator, checked_rhs: CheckedExpression, scope_id: ScopeId, span: Span) throws -> TypeId {
        let lhs_type_id = expression_type(checked_lhs)
        let rhs_type_id = expression_type(checked_rhs)

        let lhs_span = .expression_span(checked_lhs)
        let rhs_span = .expression_span(checked_rhs)

        mut type_id = expression_type(checked_lhs)

        match op {
            NoneCoalescing | NoneCoalescingAssign => {
                // 1. LHS must be Optional<T>.
                // 2. RHS must be Optional<T> or T.
                // 3. Resulting type is Optional<T> or T, respectively.

                // if an assignment, the LHS must be a mutable variable.
                if op is NoneCoalescingAssign {
                    match checked_lhs {
                        Var(var, span) => {
                            if not var.is_mutable {
                                .error_with_hint(message: "left-hand side of ??= must be a mutable variable", span, hint: "This variable isn't marked as mutable", hint_span: var.definition_span)
                                return unknown_type_id()
                            }
                        }
                        else => {
                            .error(message: "left-hand side of ??= must be a mutable variable", span)
                            return unknown_type_id()
                        }
                    }
                }

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        if id.equals(optional_struct_id) {
                            // Success: LHS is T? and RHS is T?.
                            if lhs_type_id.equals(rhs_type_id) {
                                return lhs_type_id
                            }

                            // Extract T from Optional<T>.
                            let inner_type_id = args[0]

                            if inner_type_id.equals(rhs_type_id) {
                                // Success: LHS is T? and RHS is T.
                                return inner_type_id
                            }
                        } else {
                            .error_with_hint(format(
                                "None coalescing (??) with incompatible types ({} and {})",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            ), span,
                            "Left side of ?? must be an Optional but isn't",
                            lhs_span)
                        }
                    }
                    else => {
                        .error_with_hint(format(
                            "None coalescing (??) with incompatible types ({} and {})",
                            .type_name(lhs_type_id),
                            .type_name(rhs_type_id),
                        ), span,
                        "Left side of ?? must be an Optional but isn't",
                        lhs_span)
                    }
                }

                .error(format(
                    "None coalescing (??) with incompatible types ({} and {})",
                    .type_name(lhs_type_id),
                    .type_name(rhs_type_id),
                ), span)

                return lhs_type_id
            }
            LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Equal | NotEqual => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format("Binary comparison between incompatible types ({} vs {})", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            LogicalAnd | LogicalOr => {
                if not lhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("left side of logical binary operation is not a boolean", lhs_span)
                }

                if not rhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("right side of logical binary operation is not a boolean", rhs_span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            Assign => {
                if not .expression_is_mutable(checked_lhs) {
                    .error("Assignment to immutable variable", span)
                    return lhs_type_id
                }
                match checked_rhs {
                    OptionalNone(span, type_id) => {
                        let lhs_type = .get_type(lhs_type_id)
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        match lhs_type {
                            GenericInstance(id, args) => {
                                if id.equals(optional_struct_id) {
                                    return lhs_type_id
                                }
                            }
                            else => {}
                        }
                    }
                    else => {}
                }

                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format("Assignment between incompatible types ({} and {})", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }
                return result.value_or(lhs_type_id)
            }
            AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign | BitwiseAndAssign | BitwiseOrAssign | BitwiseXorAssign | BitwiseLeftShiftAssign | BitwiseRightShiftAssign => {
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        if id.equals(weak_ptr_struct_id) {
                            let inner_type_id = args[0]
                            match .get_type(inner_type_id) {
                                Type::Struct(struct_id: lhs_struct_id) => {
                                    match .get_type(rhs_type_id) {
                                        Type::Struct(struct_id: rhs_struct_id) => {
                                            if lhs_struct_id.equals(rhs_struct_id) {
                                                return lhs_type_id
                                            }
                                        }
                                        else => {}
                                    }
                                }
                                else => {}
                            }
                        }

                    }
                    else => {}
                }
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format(
                        "Assignment between incompatible types ({} and {})",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ), span)
                }
                if not .expression_is_mutable(checked_lhs) {
                    .error("Assignment to immutable variable", span)
                }
            }
            Add | Subtract | Multiply | Divide | Modulo => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format(
                        "Binary arithmetic operation between incompatible types ({} and {})",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ),
                    span)
                }

                type_id = lhs_type_id
            }
            else => {}
        }

        return type_id
    }

    function typecheck_statement(mut this, anon statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement => match statement {
        Expression(expr, span) => CheckedStatement::Expression(expr: .typecheck_expression(expr, scope_id, safety_mode), span)
        UnsafeBlock(block, span) => CheckedStatement::Block(block: .typecheck_block(block, parent_scope_id: scope_id, safety_mode: SafetyMode::Unsafe), span)
        Yield(expr, span) => CheckedStatement::Yield(expr: .typecheck_expression(expr, scope_id, safety_mode), span)
        Return(expr, span) => .typecheck_return(expr, span, scope_id, safety_mode)
        Block(block, span) => .typecheck_block_statement(parsed_block: block, scope_id, safety_mode, span)
        InlineCpp(block, span) => .typecheck_inline_cpp(block, span, safety_mode)
        Defer(statement, span) => .typecheck_defer(statement, scope_id, safety_mode, span)
        Loop(block, span) => .typecheck_loop(parsed_block: block, scope_id, safety_mode, span)
        Try(stmt, error_name, error_span, catch_block, span) => .typecheck_try(stmt, error_name, error_span, catch_block, scope_id, safety_mode, span)
        Throw(expr, span) => .typecheck_throw(expr, scope_id, safety_mode, span)
        While(condition, block, span) => .typecheck_while(condition, block, scope_id, safety_mode, span)
        Continue(span) => CheckedStatement::Continue(span)
        Break(span) => CheckedStatement::Break(span)
        VarDecl(var, init, span) => .typecheck_var_decl(var, init, scope_id, safety_mode, span)
        If(condition, then_block, else_statement, span) => .typecheck_if(condition, then_block, else_statement, scope_id, safety_mode, span)
        Garbage(span) => CheckedStatement::Garbage(span)
        For(iterator_name, name_span, range, block, span) => .typecheck_for(iterator_name,  name_span, range, block, scope_id, safety_mode, span)
    }

    function typecheck_for(mut this, iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let maybe_span = block.find_yield_span()
        if maybe_span.has_value() {
            .error("a 'for' loop block is not allowed to yield values", maybe_span!)
        }


        // Translate `for x in expr { body }` to
        // block {
        //     let (mutable) _magic = expr
        //     loop {
        //         let x = _magic.next()
        //         if not x.has_value() {
        //             break
        //         }
        //         let iterator_name = x!
        //         body
        //     }
        // }
        //
        // The only restrictions placed on the iterator are such:
        //     1- Must respond to .next(); the mutability of the iterator is inferred from .next()'s signature
        //     2- The result of .next() must be an Optional.

        // TODO: when optional type hint is available, add `None` as the type hint
        let iterable_expr = .typecheck_expression(range, scope_id, safety_mode) 
        mut iterable_should_be_mutable = false


        let iterable_type = .program.get_type(expression_type(iterable_expr))

        match iterable_type {
            TypeVariable => {
                // Since we're not sure, just make it mutable.
                iterable_should_be_mutable = true
            }
            GenericInstance(id, args) | Struct(id) => {
                let struct_ = .get_struct(id)
                let next_method_function_id = .find_function_in_scope(
                    parent_scope_id: struct_.scope_id,
                    function_name: "next"
                    )
                if not next_method_function_id.has_value() {
                    .error("Iterator must have a .next() method", range.span())
                } else {
                    let next_method_function = .get_function(next_method_function_id!)
                    // Check whether we need to make the iteratar mutable
                    if next_method_function.is_mutating() {
                        iterable_should_be_mutable = true
                    }
                }
            }
            else => {
                .error("Iterator must have a .next() method", name_span)
            }
        }


        // FIXME: proper type inference for `None`
        let else_statement: ParsedStatement? = None

        let rewritten_statement = ParsedStatement::Block(
            block: ParsedBlock(
                stmts: [
                    // let (mutable) _magic = expr
                    ParsedStatement::VarDecl(
                        var: ParsedVarDecl(
                            name: "_magic",
                            parsed_type: ParsedType::Empty,
                            is_mutable: iterable_should_be_mutable,
                            span: name_span
                        ),
                        init: range
                        span
                    )
                    // loop {
                    ParsedStatement::Loop(
                        block: ParsedBlock(
                            stmts: [
                                // let _magic_value = _magic.next()
                                ParsedStatement::VarDecl(
                                    var: ParsedVarDecl(
                                        name: "_magic_value",
                                        parsed_type: ParsedType::Empty,
                                        is_mutable: iterable_should_be_mutable,
                                        span: name_span
                                    ),
                                    init: ParsedExpression::MethodCall(
                                        expr: ParsedExpression::Var(
                                            name: "_magic",
                                            span: name_span
                                        ),
                                        call: ParsedCall(
                                            namespace_: [],
                                                name: "next",
                                                args: [],
                                            type_args: []
                                        ),
                                        span: name_span
                                    )
                                    span
                                ),
                                // if not _magic_value.has_value() {
                                ParsedStatement::If(
                                    condition: ParsedExpression::UnaryOp(
                                        expr: ParsedExpression::MethodCall(
                                            expr: ParsedExpression::Var(
                                                name: "_magic_value",
                                                span: name_span
                                            ),
                                            call: ParsedCall(
                                                namespace_: [],
                                                name: "has_value",
                                                args: [],
                                                type_args: []
                                            )
                                            span: name_span
                                        ),
                                        op: UnaryOperator::LogicalNot,
                                        span: name_span
                                    ),
                                    then_block: ParsedBlock(
                                        stmts: [
                                            // break
                                            ParsedStatement::Break(span)
                                        ]
                                    ),
                                    else_statement
                                    span
                                ),
                            // let iterator_name = _magic_value!
                            ParsedStatement::VarDecl(
                                var: ParsedVarDecl(
                                    name: iterator_name,
                                    parsed_type: ParsedType::Empty,
                                    // FIXME: loop variable mutability should be independent
                                    // of iterable mutability
                                    is_mutable: iterable_should_be_mutable,
                                    span: name_span
                                    ),
                                    init: ParsedExpression::ForcedUnwrap(
                                        expr: ParsedExpression::Var(
                                            name: "_magic_value",
                                            span: name_span
                                        )
                                        span: name_span
                                    )
                                    span
                            ),
                            ParsedStatement::Block(block, span)
                            ]
                        )
                        span
                    )
                ]
            )
            span
        )

        return .typecheck_statement(rewritten_statement, scope_id, safety_mode)
    }

    function typecheck_if(mut this, condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression(condition, scope_id, safety_mode)
        if not expression_type(checked_condition).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(then_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("An if block is not allowed to yield values", then_block.find_yield_span()!)
        }

        mut checked_else: CheckedStatement? = None
        if else_statement.has_value() {
            checked_else = .typecheck_statement(else_statement!, scope_id, safety_mode)
        }
        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else, span)
    }

    function typecheck_var_decl(mut this, var: ParsedVarDecl, init: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut lhs_type_id = .typecheck_typename(parsed_type: var.parsed_type, scope_id, ignore_errors: false)
        mut checked_expr = .typecheck_expression(expr: init, scope_id, safety_mode)
        let rhs_type_id = expression_type(checked_expr)

        if lhs_type_id.equals(unknown_type_id()) and not rhs_type_id.equals(unknown_type_id()) {
            lhs_type_id = rhs_type_id
        }

        let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type: lhs_type_id, checked_rhs: checked_expr, span: init.span())
        if promoted_rhs.has_value() {
            checked_expr = promoted_rhs!
        }

        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let optional_struct_id = .find_struct_in_prelude("Optional")

        let lhs_type = .get_type(lhs_type_id)

        match lhs_type {
            GenericInstance(id, args) => {
                if id.equals(weak_ptr_struct_id) {
                    if not var.is_mutable {
                        .error("Weak reference must be mutable", var.span)
                    }

                    if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                        .error(format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                    }
                }
                if id.equals(optional_struct_id) {
                    if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                        .error(format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                    }
                }
            }
            else => {
                if lhs_type.is_builtin() {
                    let number_constant = checked_expr.to_number_constant(program: .program)

                    mut is_rhs_zero = false
                    if number_constant.has_value() {
                        is_rhs_zero = match number_constant! {
                            Signed(value) => value == 0
                            Unsigned(value) => value == 0
                            Floating(value) => value == 0.0
                        }
                    }

                    if not (.is_numeric(lhs_type_id) and is_rhs_zero) and (.is_integer(lhs_type_id) ^ .is_integer(rhs_type_id)) {
                        .error(format("Type mismatch: expected {}, but got {}", .type_name(lhs_type_id), .type_name(rhs_type_id)), .expression_span(checked_expr))
                        return CheckedStatement::Garbage(span)
                    }
                }
            }
        }

        let checked_var = CheckedVariable(
            name: var.name
            type_id: lhs_type_id
            is_mutable: var.is_mutable
            definition_span: var.span
            visibility: Visibility::Public
        )

        // TODO: dump type hints

        mut module = .current_module()
        let var_id = module.add_variable(checked_var)
        .add_var_to_scope(scope_id, name: var.name, var_id, span: checked_var.definition_span)
        return CheckedStatement::VarDecl(var_id, init: checked_expr, span)
    }

    function typecheck_while(mut this, condition: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression(condition, scope_id, safety_mode)
        if not expression_type(checked_condition).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A while block is not allowed to yield values", block.find_yield_span()!)
        }

        return CheckedStatement::While(condition: checked_condition, block: checked_block, span)
    }

    function typecheck_try(mut this, stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true)
        let checked_stmt = .typecheck_statement(stmt, scope_id, safety_mode)
        let error_struct_id = .find_struct_in_prelude("Error")
        let error_decl = CheckedVariable(
            name: error_name
            type_id: unknown_type_id()
            is_mutable: false
            definition_span: error_span
            visibility: Visibility::Public
        )
        mut module = .current_module()
        let error_id = module.add_variable(name: error_decl)

        let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
        .add_var_to_scope(scope_id: catch_scope_id, name: error_name, var_id: error_id, span: error_span)
        let checked_catch_block = .typecheck_block(catch_block, parent_scope_id: catch_scope_id, safety_mode)

        return CheckedStatement::Try(stmt: checked_stmt, error_name, catch_block: checked_catch_block, span)
    }

    function typecheck_throw(mut this, expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {

        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)

        let error_type_id = .find_type_in_prelude("Error")
        if not expression_type(checked_expr).equals(error_type_id) {
            .error("throw expression does not produce an error", expr.span())
        }

        let scope = .get_scope(scope_id)
        if not scope.can_throw {
            .error("Throw statment needs to be in a try statement or a function marked as throws", expr.span())
        }

        return CheckedStatement::Throw(expr: checked_expr, span)
    }

    function typecheck_loop(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A loop block is not allowed to yield values", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Loop(block: checked_block, span)
    }

    function typecheck_defer(mut this, statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let was_inside_defer = .inside_defer
        .inside_defer = true
        defer .inside_defer = was_inside_defer
        let checked_statement = .typecheck_statement(statement, scope_id, safety_mode)
        match checked_statement {
            Block(block) => {
                if block.yielded_type.has_value() {
                    .error("yield inside defer is meaningless", span)
                }
            }
            else => { }
        }
        return CheckedStatement::Defer(statement: checked_statement, span)
    }

    function typecheck_block_statement(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A block used as a statement cannot yield values, as the value cannot be observed in any way", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Block(block: checked_block, span)
    }

    function typecheck_inline_cpp(mut this, block: ParsedBlock, span: Span, safety_mode: SafetyMode) throws -> CheckedStatement {
        if safety_mode is Safe {
            .error("Use of inline cpp block outside of unsafe block", span)
        }

        mut strings: [String] = []
        for statement in block.stmts.iterator() {
            match statement {
                ParsedStatement::Expression(expr) => {
                    match expr {
                        ParsedExpression::QuotedString(val, span) => {
                            strings.push(val)
                        }
                        else => .error("Expected block of strings", span)
                    }
                }
                else => {
                    .error("Expected block of strings", span)
                }
            }
        }

        return CheckedStatement::InlineCpp(lines: strings, span)
    }

    function typecheck_return(mut this, expr: ParsedExpression?, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        if .inside_defer {
            .error("return is not allowed inside defer", span)
        }
        if not expr.has_value() {
            let none_expr: CheckedExpression? = None
            return CheckedStatement::Return(val: none_expr, span)
        }
        let checked_expr = .typecheck_expression(expr!, scope_id, safety_mode)
        return CheckedStatement::Return(val: checked_expr, span)
    }

    function typecheck_indexed_struct(mut this, expr: ParsedExpression, field: String, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
        let checked_expr_type_id = expression_type(checked_expr)
        let checked_expr_type = .get_type(checked_expr_type_id)

        let struct_id = match checked_expr_type {
            Type::GenericInstance(id) => id
            Type::Struct(struct_id) => struct_id
            else => {
                .compiler.panic(format("typecheck_indexed_struct: {}", checked_expr_type))
                // FIXME: This is unreachable
                yield StructId(module: ModuleId(id: 0), id: 0)
            }
        }
        let structure = .get_struct(struct_id)
        for member_id in structure.fields.iterator() {
            let member = .get_variable(member_id)

            if member.name == field {
                let resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                // FIXME: Unify with type
                .check_member_access(accessor: scope_id, accessee: structure.scope_id, member, span)
                return CheckedExpression::IndexedStruct(expr: checked_expr, index: field, span, type_id: resolved_type_id)
            }
        }

        // FIXME: Unify with type
        return CheckedExpression::IndexedStruct(expr: checked_expr, index: field, span, type_id: checked_expr_type_id)
    }

    function check_member_access(mut this, accessor: ScopeId, accessee: ScopeId, member: CheckedVariable, span: Span) throws {
        match member.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    .error(format("Can't access variable {} from scope {}, because it is marked private", member.name, .get_scope(accessor).namespace_name), span)
                }
            }
            Restricted(whitelist, span) => {
                .check_restricted_access(accessor, accessee_kind: "variable", accessee, name: member.name, whitelist, span)
            }
            else => {}
        }
    }

    function check_method_access(mut this, accessor: ScopeId, accessee: ScopeId, method: CheckedFunction, span: Span) throws {
        match method.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    .error(format("Can't access function {} from scope {}, because it is marked private", method.name, .get_scope(accessor).namespace_name), span)
                }
            }
            Restricted(whitelist, span) => {
                .check_restricted_access(accessor, accessee_kind: "function", accessee, name: method.name, whitelist, span)
            }
            else => {}
        }
    }

    function check_restricted_access(mut this, accessor: ScopeId, accessee_kind: String, accessee: ScopeId, name: String, whitelist: [ParsedType], span: Span) throws {
        if not .current_struct_type_id.has_value() {
            .error(format("Can't access {} {} from scope {}, because {} is not in the restricted whitelist", accessee_kind, name, .get_scope(accessor).namespace_name, .get_scope(accessor).namespace_name), span)
            return
        }
        let own_type_id = .current_struct_type_id!
        let type = .get_type(own_type_id)
        match type {
            Struct(id) => {
                mut was_whitelisted = false
                for whitelisted_type in whitelist.iterator() {
                    let type_id = .typecheck_typename(parsed_type: whitelisted_type, scope_id: accessee, ignore_errors: false)
                    // FIXME: Handle typecheck failure
                    if type_id.equals(own_type_id) {
                        // FIXME: A naked `return` would be nicer here
                        was_whitelisted = true
                        break
                    }
                }
                if not was_whitelisted {
                    .error(format("Can't access {} {} from scope {}, because it is not in the restricted whitelist", accessee_kind, name, .get_scope(accessor).namespace_name), span)
                }
            }
            else => {
                .error(format("Can't access {} {} from scope {}, because it is not in the restricted whitelist", accessee_kind, name, .get_scope(accessor).namespace_name), span)
            }
        }
    }

    function typecheck_expression(mut this, anon expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression => match expr {
        IndexedStruct(expr, field, span) => .typecheck_indexed_struct(expr, field, scope_id, safety_mode, span)
        Boolean(val, span) => CheckedExpression::Boolean(val, span)
        NumericConstant(val, span) => {
            // FIXME: better constant support
            yield match val {
                I8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val), span, type_id: builtin(BuiltinType::I8))
                I16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val), span, type_id: builtin(BuiltinType::I16))
                I32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val), span, type_id: builtin(BuiltinType::I32))
                I64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
                U8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val), span, type_id: builtin(BuiltinType::U8))
                U16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val), span, type_id: builtin(BuiltinType::U16))
                U32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val), span, type_id: builtin(BuiltinType::U32))
                U64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
                USize(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val), span, type_id: builtin(BuiltinType::U64))
            }
        }
        SingleQuotedString(val, span) => CheckedExpression::CharacterConstant(val, span)
        SingleQuotedByteString(val, span) => CheckedExpression::ByteConstant(val, span)
        QuotedString(val, span) => CheckedExpression::QuotedString(val, span)
        Call(call, span) => {
            let none_expr: CheckedExpression? = None
            let parent_id: StructOrEnumId? = None
            yield .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: none_expr, parent_id, safety_mode, must_be_enum_constructor: false)
        }
        MethodCall(expr, call, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let checked_expr_type_id = expression_type(checked_expr)

            let parent_id = match .get_type(checked_expr_type_id) {
                Struct(id) => StructOrEnumId::Struct(id)
                Enum(id) => StructOrEnumId::Enum(id)
                JaktString => StructOrEnumId::Struct(.find_struct_in_prelude("String"))
                GenericInstance(id) => StructOrEnumId::Struct(id)
                GenericEnumInstance(id) => StructOrEnumId::Enum(id)
                else => {
                    panic(format("Method call on unsupported base {}", .get_type(checked_expr_type_id)))
                    yield StructOrEnumId::Struct(StructId(module: ModuleId(id: 0), id: 0))
                }
            }

            let checked_call_expr = .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: checked_expr, parent_id, safety_mode, must_be_enum_constructor: false)
            let type_id = expression_type(checked_call_expr)
            yield match checked_call_expr {
                Call(call) => {
                    let result_type = call.return_type
                    yield CheckedExpression::MethodCall(expr: checked_expr, call, span, type_id: result_type)
                }
                else => {
                    panic("typecheck_call should return `CheckedExpression::Call()`")
                    yield CheckedExpression::Garbage(span)
                }
            }

            yield .typecheck_generic_arguments_method_call(
                checked_expr
                call
                scope_id
                span
                safety_mode
            )
        }
        Range(from, to, span) => {
            let checked_from = .typecheck_expression(from, scope_id, safety_mode)
            let checked_to = .typecheck_expression(to, scope_id, safety_mode)

            let from_type = expression_type(checked_from)
            let to_type = expression_type(checked_to)

            let from_span = .expression_span(checked_from)
            let to_span = .expression_span(checked_to)

            let type_id = .unify(lhs: from_type, lhs_span: from_span, rhs: to_type, rhs_span: from_span) ?? unknown_type_id()

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id)
        }
        UnaryOp(expr, op, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let checked_op = match op {
                PreIncrement => CheckedUnaryOperator::PreIncrement
                PostIncrement => CheckedUnaryOperator::PostIncrement
                PreDecrement => CheckedUnaryOperator::PreDecrement
                PostDecrement => CheckedUnaryOperator::PostDecrement
                Negate => CheckedUnaryOperator::Negate
                Dereference => CheckedUnaryOperator::Dereference
                RawAddress => CheckedUnaryOperator::RawAddress
                LogicalNot => CheckedUnaryOperator::LogicalNot
                BitwiseNot => CheckedUnaryOperator::BitwiseNot
                TypeCast(cast) => {
                    let type_id = .typecheck_typename(parsed_type: cast.parsed_type(), scope_id, ignore_errors: false)
                    let checked_cast = match cast {
                        Fallible => CheckedTypeCast::Fallible(type_id)
                        Infallible => CheckedTypeCast::Infallible(type_id)
                    }
                    yield CheckedUnaryOperator::TypeCast(checked_cast)
                }
                Is(unchecked_type) => {
                    let type_id = .typecheck_typename(parsed_type: unchecked_type, scope_id, ignore_errors: true)
                    mut operator_is = CheckedUnaryOperator::Is(type_id)
                    if type_id.equals(unknown_type_id()) {
                        match unchecked_type {
                            ParsedType::Name(name) => {
                                // Let's assume it's an enum variant
                                let expr_type_id = expression_type(checked_expr)
                                match .get_type(expr_type_id) {
                                    Type::Enum(enum_id) => {
                                        let enum_ = .get_enum(enum_id)
                                        mut exists = false
                                        for variant in enum_.variants.iterator() {
                                            exists = match variant {
                                                StructLike(name: var_name) | Typed(name: var_name) | Untyped(name: var_name) => var_name == name
                                                else => false
                                            }
                                            if exists {
                                                operator_is = CheckedUnaryOperator::IsEnumVariant(name, enum_type_id: expr_type_id)
                                                break
                                            }
                                        }
                                        if not exists {
                                            .error(format("Enum variant '{}' does not exist on '{}'", name, .type_name(expr_type_id)), span)
                                        }
                                    }
                                    else => {
                                        .error(format("Not a valid type name: {}", name), span)
                                    }
                                }
                            }
                            else => {
                                .error("The right-hand side of an `is` operator must be a type name or enum variant", span)
                            }
                        }
                    }
                    yield operator_is
                }
            }
            yield .typecheck_unary_operation(checked_expr, checked_op, span, scope_id, safety_mode)
        }
        BinaryOp(lhs, op, rhs, span) => {
            let checked_lhs = .typecheck_expression(lhs, scope_id, safety_mode)
            mut checked_rhs = .typecheck_expression(rhs, scope_id, safety_mode)

            let lhs_type = expression_type(checked_lhs)

            let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type, checked_rhs, span)
            if promoted_rhs.has_value() {
                checked_rhs = promoted_rhs!
            }

            let output_type = .typecheck_binary_operation(checked_lhs, op, checked_rhs, scope_id, span)

            yield CheckedExpression::BinaryOp(lhs: checked_lhs, op, rhs: checked_rhs, span, type_id: output_type)
        }
        OptionalNone(span) => {
            yield CheckedExpression::OptionalNone(span, type_id: unknown_type_id())
        }
        OptionalSome(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let type_id = expression_type(checked_expr)
            let optional_struct_id = .find_struct_in_prelude("Optional")
            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
            let optional_type_id = .find_or_add_type_id(optional_type)
            yield CheckedExpression::OptionalSome(expr: checked_expr, span, type_id: optional_type_id)
        }
        Var(name, span) => {
            let var = .find_var_in_scope(scope_id, var: name)
            return match var.has_value() { // FIXME: this wants to be a match on Optional instead of boolean
                true => CheckedExpression::Var(var: var!, span)
                else => {
                    .error(format("Variable '{}' not found", name), span)
                    yield CheckedExpression::Garbage(span)
                }
            }
        }
        ForcedUnwrap(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let type = .get_type(expression_type(checked_expr))

            let optional_struct_id = .find_struct_in_prelude("Optional")
            let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

            let type_id: TypeId = match type {
                GenericInstance(id, args) => {
                    mut inner_type_id = unknown_type_id()
                    if  id.equals(optional_struct_id) or id.equals(weakptr_struct_id) {
                        inner_type_id = args[0]
                    } else {
                        .error("Forced unwrap only works on Optional", span)
                    }
                    yield inner_type_id
                }
                else => {
                    .error("Forced unwrap only works on Optional", span)
                    yield TypeId(module: ModuleId(id: 0), id: 0)
                }
            }

            yield CheckedExpression::ForcedUnwrap(expr: checked_expr, span, type_id)
        }
        JaktArray(values, fill_size, span) => {
            mut repeat: CheckedExpression? = None
            if fill_size.has_value() {
                // Check fill size is an integer.
                // TODO: Check fill size is positive when possible.
                let fill_size_value = fill_size.value()
                let fill_size_checked = .typecheck_expression(fill_size_value, scope_id, safety_mode)
                let fill_size_type = expression_type(fill_size_checked)
                if not .is_integer(fill_size_type) {
                    .error(
                        format("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions.", .type_name(fill_size_type)), 
                        fill_size_value.span()
                    )
                }
                repeat = fill_size_checked
            }
            let array_struct_id = .find_struct_in_prelude("Array")
            mut inner_type_id = unknown_type_id()
            mut inferred_type_span: Span? = None

            mut vals: [CheckedExpression] = []
            for value in values.iterator() {
                let checked_expr = .typecheck_expression(value, scope_id, safety_mode)
                let current_value_type_id = expression_type(checked_expr)

                if inner_type_id.equals(unknown_type_id()) {
                    inner_type_id = current_value_type_id
                    inferred_type_span = value.span()
                } else if not inner_type_id.equals(current_value_type_id) {
                    .error_with_hint(
                        format("Type '{}' does not match type '{}' of previous values in array", .type_name(current_value_type_id), .type_name(inner_type_id)),
                        value.span(),
                        format("Array was inferred to store type '{}' here", .type_name(inner_type_id))
                        inferred_type_span!
                    )
                }
                vals.push(checked_expr)
            }

            if inner_type_id.equals(unknown_type_id()) {
                .error("Cannot infer generic type for Array<T>", span)
            }

            let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))
            yield CheckedExpression::JaktArray(vals, repeat, span, type_id, inner_type_id)
        }
        JaktTuple(values, span) => {
            let VOID_TYPE_ID = builtin(BuiltinType::Void)
            mut checked_values: [CheckedExpression] = []
            mut checked_types: [TypeId] = []

            for value in values.iterator() {
                let checked_value= .typecheck_expression(value, scope_id, safety_mode)
                let type_id = expression_type(checked_value)
                if type_id.equals(VOID_TYPE_ID) {
                    .error("Cannot create a tuple that contains a value of type void", value.span())
                }
                checked_types.push(type_id)
                checked_values.push(checked_value)
            }

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

            // FIXME: Unify type

            yield CheckedExpression::JaktTuple(vals: checked_values, span, type_id)
        }
        IndexedExpression(base, index, span) => {
            let checked_base = .typecheck_expression(base, scope_id, safety_mode)
            let checked_index = .typecheck_expression(index, scope_id, safety_mode)

            let array_struct_id = .find_struct_in_prelude("Array")
            let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
            mut expr_type_id = unknown_type_id()

            match .get_type(expression_type(checked_base)) {
                GenericInstance(id, args) => {
                    if id.equals(array_struct_id) {
                        if .is_integer(expression_type(checked_index)) {
                            expr_type_id = args[0]
                        } else {
                            .error("Index is not an integer", span)
                        }
                    } else if id.equals(dictionary_struct_id) {
                        expr_type_id = args[1]
                    }
                }
                else => {
                    .error("Index used on value that cannot be indexed", span)
                }
            }

            yield CheckedExpression::IndexedExpression(expr: checked_base, index: checked_index, span, type_id: expr_type_id)
        }
        IndexedTuple(expr, index, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            mut expr_type_id = unknown_type_id()

            match .get_type(expression_type(checked_expr)) {
                GenericInstance(id, args) => {
                    if id.equals(tuple_struct_id) {
                        if (index >= args.size()){
                            .error("Tuple index past the end of the tuple", span)
                        }
                        expr_type_id = args[index]
                    }
                }
                else => {
                    .error("Tuple index used non-tuple value", span)
                }
            }

            yield CheckedExpression::IndexedTuple(expr: checked_expr, index: index, span, type_id: expr_type_id)
        }
        Garbage(span) => CheckedExpression::Garbage(span)
        NamespacedVar(name, namespace_, span) => {
            mut scopes = [scope_id]
            for ns in namespace_.iterator() {
                let scope = scopes[scopes.size() - 1]
                let ns_in_scope = .find_namespace_in_scope(scope_id: scope, name: ns)
                let enum_in_scope = .find_enum_in_scope(scope_id: scope, name: ns)
                mut next_scope = scope
                if ns_in_scope.has_value() {
                    next_scope = ns_in_scope!.0
                } else if enum_in_scope.has_value() {
                    next_scope = .get_enum(enum_in_scope!).scope_id
                } else {
                    panic(format("Namespace {} not found", ns))
                }
                scopes.push(next_scope)
            }

            let scope = scopes[scopes.size() - 1]

            mut i = 0uz
            let min_length = match scopes.size() <= namespace_.size() {
                true => scopes.size()
                else => namespace_.size()
            }
            mut checked_namespaces: [CheckedNamespace] = []
            while i < min_length {
                checked_namespaces.push(CheckedNamespace(name: namespace_[i], scope_id: scope))
                i++
            }

            let var = .find_var_in_scope(scope_id: scope, var: name)
            yield match var.has_value() {
                true => CheckedExpression::NamespacedVar(namespaces: checked_namespaces, var: var!, span)
                else => {
                    let implicit_constructor_call = ParsedCall(namespace_, name, args: [], type_args: [])
                    let none_expr: CheckedExpression? = None
                    let parent_id: StructOrEnumId? = None
                    let call_expression = .typecheck_call(call: implicit_constructor_call, caller_scope_id: scope_id, span, this_expr: none_expr, parent_id, safety_mode, must_be_enum_constructor: true)
                    let type_id = expression_type(call_expression)
                    let checked_call = match call_expression {
                        Call(call) => call
                        else => {
                            panic("typecheck_call returned something other than a CheckedCall")
                            // FIXME: Unreachable
                            let none_function_id: FunctionId? = None
                            yield CheckedCall(namespace_: [], name: "", args: [], function_id: none_function_id, return_type: builtin(BuiltinType::Void), callee_throws: true)
                        }
                    }
                    yield match .compiler.errors.is_empty() {
                        true => CheckedExpression::Call(call: checked_call, span, type_id)
                        else => {
                            .error(format("Variable {} not found", name), span)
                            yield CheckedExpression::NamespacedVar(
                                namespaces: checked_namespaces,
                                var: CheckedVariable(
                                    name,
                                    type_id: unknown_type_id(),
                                    is_mutable: false,
                                    definition_span: span
                                    visibility: Visibility::Public
                                ),
                                span
                            )
                        }
                    }
                }
            }
        }
        Match(expr, cases, span) => .typecheck_match(expr, cases, span, scope_id, safety_mode)
        JaktDictionary(values, span) => .typecheck_dictionary(values, span, scope_id, safety_mode)
        Set(values, span) => .typecheck_set(values, span, scope_id, safety_mode)
        else => {
            .compiler.panic(format("typechecker needs support for {}", expr))

            yield CheckedExpression::Boolean(val: false, span: Span(start: 0, end: 0))
        }
    }

    function typecheck_set(mut this, values: [ParsedExpression], span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        mut inner_type_id = unknown_type_id()
        mut inner_type_span: Span? = None
        mut output: [CheckedExpression] = []

        let set_struct_id = .find_struct_in_prelude("Set")

        // TODO: type hints

        for value in values.iterator() {
            let checked_value = .typecheck_expression(expr: value, scope_id, safety_mode)
            let current_value_type_id = expression_type(checked_value)
            if inner_type_id.equals(unknown_type_id()) {
                if current_value_type_id.equals(void_type_id()) or current_value_type_id.equals(unknown_type_id()) {
                    .error(
                        "Cannot create a set with values of type void"
                        value.span()
                    )
                }

                inner_type_id = current_value_type_id
                inner_type_span = value.span()
            } else if not inner_type_id.equals(current_value_type_id) {
                let set_type_name = .type_name(inner_type_id)
                .error_with_hint(
                    format(
                        "Type '{}' does not match type '{}' of previous values in set"
                        .type_name(current_value_type_id)
                        set_type_name
                    )
                    value.span()
                    format("Set was inferred to store type '{}' here", set_type_name)
                    inner_type_span!
                )
            }
            output.push(checked_value)
        }

        if inner_type_id.equals(unknown_type_id()) {
            .error("Cannot infer generic type for Set<T>", span)
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: set_struct_id
            args: [inner_type_id]
        ))

        return CheckedExpression::JaktSet(vals: output, span, type_id)
    }

    function typecheck_generic_arguments_method_call(mut this, checked_expr: CheckedExpression, call: ParsedCall, scope_id: ScopeId, span: Span, safety_mode: SafetyMode) throws -> CheckedExpression {
        mut checked_args: [(String, CheckedExpression)] = []
        checked_args.ensure_capacity(call.args.size())
        for call_arg in call.args.iterator() {
            let name: String = call_arg.0
            let expr: ParsedExpression = call_arg.2
            let checked_arg_expr = .typecheck_expression(
                expr
                scope_id
                safety_mode
            )
            let checked_arg: (String, CheckedExpression) = (name, checked_arg_expr)
            checked_args.push(checked_arg)
        }

        let none_function_id: FunctionId? = None // FIXME: use None directly
        return CheckedExpression::MethodCall(
            expr: checked_expr
            call: CheckedCall(
                namespace_: []
                name: call.name
                args: checked_args
                function_id: none_function_id
                return_type: unknown_type_id()
                callee_throws: false
            )
            span
            type_id: unknown_type_id()
        )
    }

    function typecheck_match(mut this, expr: ParsedExpression, cases: [ParsedMatchCase], span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
        let subject_type_id = expression_type(checked_expr)
        let type_to_match_on = .get_type(subject_type_id)
        mut checked_cases: [CheckedMatchCase] = []

        mut generic_inferences: [String: String] = [:] // FIXME: Use correct generic_inferences dictionary
        mut final_result_type: TypeId? = None

        match type_to_match_on {
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                mut seen_catch_all = false
                mut catch_all_span: Span? = None
                mut covered_variants: {String} = {}
                for case_ in cases.iterator() {
                    for pattern in case_.patterns.iterator() {
                        match pattern {
                            EnumVariant(variant_name, variant_arguments, arguments_span) => {
                                mut variant_names = variant_name

                                if variant_names.size() == 1 {
                                    let temp = variant_names[0]
                                    variant_names = [
                                        (enum_.name, variant_names[0].1)
                                        temp
                                    ]
                                }
                                if variant_names.is_empty() {
                                    continue
                                }
                                if variant_names[0].0 != enum_.name {
                                    .error(format("Match case '{}' does not match enum '{}'", variant_names[0].0, enum_.name), variant_names[0].1)
                                    continue
                                }
                                mut i = 0uz
                                mut matched_variant: CheckedEnumVariant? = None
                                mut variant_index: usize? = None
                                for v in enum_.variants.iterator() {
                                    if v.name() == variant_names[1].0 {
                                        matched_variant = v
                                        variant_index = i
                                    }
                                    i++
                                }

                                if not matched_variant.has_value() {
                                    .error(format("Match case '{}' does not match enum '{}'", variant_names[0].0, enum_.name), span)
                                    return CheckedExpression::Match(expr: checked_expr, match_cases: [], span, type_id: unknown_type_id(), all_variants_constant: false)
                                }

                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw)
                                mut module = .current_module()
                                match matched_variant! {
                                    Untyped(name) => {
                                        covered_variants.add(name)
                                        if not variant_arguments.is_empty() {
                                            .error(format("Match case '{}' cannot have arguments", name), span)
                                        }
                                    }
                                    Typed(name, type_id, span) => {
                                        covered_variants.add(name)
                                        if variant_arguments.size() != 1 {
                                            .error("Match case '{}' must have exactly one argument", span)
                                        }

                                        let variant_argument = variant_arguments[0]
                                        let var_id = module.add_variable(CheckedVariable(
                                            name: variant_argument.binding
                                            type_id
                                            is_mutable: false
                                            definition_span: span
                                            visibility: Visibility::Public
                                        ))
                                        .add_var_to_scope(scope_id: new_scope_id, name: variant_argument.binding, var_id, span)
                                    }
                                    StructLike(name, fields) => {
                                        covered_variants.add(name)

                                        mut field_variables: [CheckedVariable] = []
                                        for var_id in fields.iterator() {
                                            field_variables.push(.program.get_variable(var_id))
                                        }
                                        mut seen_names: {String} = {}
                                        for arg in variant_arguments.iterator() {
                                            if not arg.name.has_value() {
                                                mut found_field_name = false
                                                mut field_names: [String] = []
                                                for var in field_variables.iterator() {
                                                    field_names.push(var.name)
                                                    if var.name == arg.binding {
                                                        found_field_name = true
                                                    }
                                                }
                                                if not found_field_name {
                                                    mut unused_field_names: [String] = []
                                                    for field_name in field_names.iterator() {
                                                        if seen_names.contains(field_name) {
                                                            continue
                                                        }
                                                        unused_field_names.push(field_name)
                                                    }
                                                    .error_with_hint(
                                                        "Match case argument '{}' for struct-like enum variant cannot be anon"
                                                        arg.span
                                                        format("Available arguments are: {}\n", join(unused_field_names, separator: ", "))
                                                        arg.span
                                                    )
                                                    continue
                                                }
                                            }
                                            let arg_name = arg.name ?? arg.binding
                                            if seen_names.contains(arg_name) {
                                                .error(format("match case argument '{}' is already defined", arg_name), arg.span)
                                                continue
                                            }
                                            seen_names.add(arg_name)
                                            mut matched_field_variable: CheckedVariable? = None
                                            for var in field_variables.iterator() {
                                                if var.name == arg_name {
                                                    matched_field_variable = var
                                                }
                                            }

                                            match matched_field_variable.has_value() {
                                                true => {
                                                    let substituted_type_id = .substitute_typevars_in_type(type_id: matched_field_variable!.type_id, generic_inferences: [:])
                                                    let matched_span = matched_field_variable!.definition_span
                                                    // FIXME: dump type hints

                                                   let var_id = module.add_variable(CheckedVariable(
                                                        name: arg_name
                                                        type_id: substituted_type_id
                                                        is_mutable: false
                                                        definition_span: matched_span
                                                        visibility: Visibility::Public
                                                    ))
                                                    .add_var_to_scope(scope_id: new_scope_id, name: arg_name, var_id, span)
                                                }
                                                else => {
                                                    .error(format("Match case argument '{}' does not exist in struct-like enum variant '{}'", arg_name, name), arg.span)
                                                }
                                            }
                                        }
                                    }
                                    else => {
                                        todo(format("implement {} match case for matched variant", matched_variant))
                                    }
                                }

                                let checked_tuple = .typecheck_match_body(body: case_.body, scope_id: new_scope_id, safety_mode, generic_inferences, final_result_type, span: case_.marker_span)
                                let checked_body = checked_tuple.0
                                final_result_type = checked_tuple.1

                                let checked_match_case = CheckedMatchCase::EnumVariant(
                                    name: variant_names[1].0,
                                    args: variant_arguments,
                                    subject_type_id,
                                    index: variant_index!,
                                    scope_id: new_scope_id,
                                    body: checked_body,
                                    marker_span: matched_variant!.span()
                                )
                                checked_cases.push(checked_match_case)
                            }
                            CatchAll => {
                                if seen_catch_all {
                                    .error(
                                        "Multiple catch-all cases in match are not allowed"
                                        case_.marker_span
                                    )
                                } else {
                                    seen_catch_all = true
                                    catch_all_span = case_.marker_span
                                }
                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw)
                                let checked_tuple = .typecheck_match_body(body: case_.body, scope_id: new_scope_id, safety_mode, generic_inferences, final_result_type, span: case_.marker_span)
                                let checked_body = checked_tuple.0
                                final_result_type = checked_tuple.1

                                let checked_match_case = CheckedMatchCase::CatchAll(
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                            else => {}
                        }
                    }
                }

            }
            Void => {
                .error("Can't match on 'void' type", .expression_span(checked_expr))
            }
            else => {
                mut is_enum_match = false
                mut is_value_match = false
                mut seen_catch_all = false

                mut all_variants_constant = true

                for case_ in cases.iterator() {
                    for pattern in case_.patterns.iterator() {
                        match pattern {
                            EnumVariant(variant_name, variant_arguments, arguments_span) => {
                                mut variant_names = variant_name

                                if is_value_match {
                                    .error(
                                        "Cannot have an enum match case in a match expression containing value matches"
                                        case_.marker_span
                                    )
                                }

                                if variant_names.size() == 0 {
                                    panic("typecheck_match - else - EnumVariant - variant_names.size() == 0")
                                }

                                is_enum_match = true

                                // We don't know what the enum type is, but we have the type var for it, so generate a generic enum match.
                                // note that this will be fully checked when this match expression is actually instantiated.

                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw)
                                let checked_tuple = .typecheck_match_body(body: case_.body, scope_id: new_scope_id, safety_mode, generic_inferences, final_result_type, span: case_.marker_span)
                                let checked_body = checked_tuple.0
                                final_result_type = checked_tuple.1

                                let checked_match_case = CheckedMatchCase::EnumVariant(
                                    name: variant_names[variant_names.size() - 1].0
                                    args: variant_arguments
                                    subject_type_id
                                    index: 0
                                    scope_id: new_scope_id
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                            CatchAll => {
                                if seen_catch_all {
                                    .error(
                                        "Cannot have multiple catch-all match cases"
                                        case_.marker_span
                                    )
                                }
                                seen_catch_all = true

                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw)
                                let checked_tuple = .typecheck_match_body(body: case_.body, scope_id: new_scope_id, safety_mode, generic_inferences, final_result_type, span: case_.marker_span)
                                let checked_body = checked_tuple.0
                                final_result_type = checked_tuple.1

                                let checked_match_case = CheckedMatchCase::CatchAll(
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                            Expression(expr) => {
                                if is_enum_match {
                                    .error(
                                        "Cannot have a value match case in a match expression containing enum matches"
                                        case_.marker_span
                                    )
                                }
                                is_value_match = true

                                let checked_expression = .typecheck_expression(expr, scope_id, safety_mode)

                                if not checked_expression.to_number_constant(program: .program).has_value() {
                                    all_variants_constant = false
                                }

                                // FIXME: In the future, we should really make this a "does it satisfy some trait" check.
                                //        For now, we just check that the types are equal.
                                .check_types_for_compat(
                                    lhs_type_id: expression_type(checked_expression)
                                    rhs_type_id: subject_type_id
                                    generic_inferences: [:] // FIXME: use correct generic inferences
                                    span: case_.marker_span
                                )

                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw)
                                let checked_tuple = .typecheck_match_body(body: case_.body, scope_id: new_scope_id, safety_mode, generic_inferences, final_result_type, span: case_.marker_span)
                                let checked_body = checked_tuple.0
                                final_result_type = checked_tuple.1

                                let checked_match_case = CheckedMatchCase::Expression(
                                    expression: checked_expression
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                        }
                    }
                }

                if is_value_match and not seen_catch_all {
                    .error(
                        "match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"
                        span
                    )
                }
            }
        }

        return CheckedExpression::Match(expr: checked_expr, match_cases: checked_cases, span, type_id: final_result_type ?? void_type_id(), all_variants_constant: true)
    }

    function typecheck_match_body(mut this, body: ParsedMatchBody, scope_id: ScopeId, safety_mode: SafetyMode, generic_inferences: [String: String], final_result_type: TypeId?, span: Span) throws -> (CheckedMatchBody, TypeId) {
        mut result_type = final_result_type
        let checked_match_body = match body {
            Block(block) => {
                let checked_block = .typecheck_block(parsed_block: block, parent_scope_id: scope_id, safety_mode)

                // FIXME: Check that this is not the wrong way around
                if not checked_block.definitely_returns {
                    let block_type_id = checked_block.yielded_type ?? builtin(BuiltinType::Void)
                    let yield_span = block.find_yield_span() ?? span

                    if result_type.has_value() {
                        .check_types_for_compat(
                            lhs_type_id: result_type!
                            rhs_type_id: block_type_id
                            generic_inferences
                            span: yield_span
                        )
                    } else {
                        result_type = block_type_id
                    }
                }

                mut final_body: CheckedMatchBody? = None
                if checked_block.yielded_type.has_value() {
                    final_body = CheckedMatchBody::Expression(CheckedExpression::Block(
                        block: checked_block
                        span
                        type_id: checked_block.yielded_type!
                    ))
                } else {
                    final_body = CheckedMatchBody::Block(checked_block)
                }

                yield final_body!
            }
            Expression(expr) => {
                let checked_expression = .typecheck_expression(expr, scope_id, safety_mode)
                if result_type.has_value() {
                    .check_types_for_compat(
                        lhs_type_id: result_type!
                        rhs_type_id: expression_type(checked_expression)
                        generic_inferences
                        span
                    )
                } else {
                    result_type = expression_type(checked_expression)
                }

                yield CheckedMatchBody::Expression(checked_expression)
            }
        }
        return (checked_match_body, result_type ?? unknown_type_id())
    }

    function typecheck_dictionary(mut this, values: [(ParsedExpression, ParsedExpression)], span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
        mut checked_kv_pairs: [(CheckedExpression, CheckedExpression)] = []
        mut key_type_id = unknown_type_id()
        mut key_type_span: Span? = None
        mut value_type_id = unknown_type_id()
        mut value_type_span: Span? = None

        // TODO: hint type logic

        for kv_pair in values.iterator() {
            let key = kv_pair.0
            let value = kv_pair.1
            let checked_key = .typecheck_expression(key, scope_id, safety_mode)
            let current_key_type_id = expression_type(checked_key)

            let checked_value = .typecheck_expression(value, scope_id, safety_mode)
            let current_value_type_id = expression_type(checked_value)
            let VOID_TYPE_ID = builtin(BuiltinType::Void)

            if key_type_id.equals(unknown_type_id()) and value_type_id.equals(unknown_type_id()) {
                if current_key_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with keys of type void", span: key.span())
                }
                if current_value_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with values of type void", span: value.span())
                }
                key_type_id = current_key_type_id
                key_type_span = Some(key.span())
                value_type_id = current_value_type_id
                value_type_span = Some(value.span())
            } else {
                if not key_type_id.equals(current_key_type_id) {
                    let key_type_name = .type_name(key_type_id)
                    let current_key_type_name = .type_name(current_key_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous keys in dictionary", current_key_type_name, key_type_name)
                        span: key.span()
                        hint: format("Dictionary was inferred to store keys of type '{}' here", key_type_name)
                        span: key_type_span!
                    )
                }
                if not value_type_id.equals(current_value_type_id) {
                    let value_type_name = .type_name(value_type_id)
                    let current_value_type_name = .type_name(current_value_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous values in dictionary", current_value_type_name, value_type_name)
                        span: value.span()
                        hint: format("Dictionary was inferred to store values of type '{}' here", value_type_name)
                        span: value_type_span!
                    )
                }
            }
            checked_kv_pairs.push((checked_key, checked_value))
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: dictionary_struct_id,
            args: [key_type_id, value_type_id]
        ))

        // TODO: unify type with hint type

        return CheckedExpression::JaktDictionary(
            vals: checked_kv_pairs
            span
            type_id
        )
    }

    function resolve_call(mut this, call: ParsedCall, namespaces: [ResolvedNamespace], span: Span, scope_id: ScopeId, must_be_enum_constructor: bool) throws -> FunctionId? {
        mut callee: FunctionId? = None
        mut current_scope_id = scope_id

        for namespace_index in 0..call.namespace_.size() {
            let scope_name = call.namespace_[namespace_index]
            let maybe_ns_scope = .find_namespace_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_ns_scope.has_value() {
                let scope_id = maybe_ns_scope!.0
                let is_import = maybe_ns_scope!.1
                if is_import {
                    namespaces[namespace_index].name = .program.modules[scope_id.module_id.id].name
                }
                current_scope_id = scope_id
                continue
            }
            let maybe_struct_scope = .find_struct_in_scope(scope_id, name: scope_name)
            if maybe_struct_scope.has_value() {
                let structure = .get_struct(maybe_struct_scope!)
                current_scope_id = structure.scope_id
                continue
            }
            let maybe_enum_scope = .find_enum_in_scope(scope_id, name: scope_name)
            if maybe_enum_scope.has_value() {
                let enum_ = .get_enum(maybe_enum_scope!)
                current_scope_id = enum_.scope_id
                continue
            }

            .error(format("Not a namespace, enum, class, or struct: {}", join(call.namespace_, separator: "::")), span)
        }

        // 1. Look for a function with this name.
        let maybe_function_id = .find_function_in_scope(parent_scope_id: current_scope_id, function_name: call.name)
        if maybe_function_id.has_value() {
            let function_id = maybe_function_id!
            if not must_be_enum_constructor or .get_function(function_id).type is ImplicitEnumConstructor {
                return function_id
            }
        }

        if must_be_enum_constructor {
            .error(format("No such enum constructor {}", call.name), span)
            return callee
        }

        // 2. Look for a struct, class or enum constructor with this name.
        let maybe_struct_id = .find_struct_in_scope(scope_id: current_scope_id, name: call.name)
        if maybe_struct_id.has_value() {
            let struct_id = maybe_struct_id!
            let structure = .get_struct(struct_id)
            let maybe_function_id = .find_function_in_scope(parent_scope_id: structure.scope_id, function_name: call.name)
            if maybe_function_id.has_value() {
                return maybe_function_id!
            }
            return callee
        }

        .error(format("Call to unknown function: {}", call.name), span)

        return None
    }

    function typecheck_call(mut this, call: ParsedCall, caller_scope_id: ScopeId, span: Span, this_expr: CheckedExpression?, parent_id: StructOrEnumId?, safety_mode: SafetyMode, must_be_enum_constructor: bool) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = builtin(BuiltinType::Void)
        mut callee_throws = false
        mut resolved_namespaces: [ResolvedNamespace] = []
        mut resolved_function_id: FunctionId? = None
        mut maybe_this_type_id: TypeId? = None
        for name in call.namespace_.iterator() {
            let generic_parameters: [TypeId]? = None
            resolved_namespaces.push(ResolvedNamespace(name, generic_parameters))
        }

        let callee_scope_id = match parent_id.has_value() {
            true => match parent_id! {
                Struct(id) => .get_struct(id).scope_id
                Enum(id) => .get_enum(id).scope_id
            }
            else => caller_scope_id
        }

        match call.name {
            "print" | "println" | "eprintln" | "format" => {
                for arg in call.args.iterator() {
                    let checked_arg = .typecheck_expression(expr: arg.2, scope_id: caller_scope_id, safety_mode)

                    args.push((call.name, checked_arg))
                }
                
                if call.name == "format" {
                    return_type = builtin(BuiltinType::String)
                    callee_throws = true
                }
            }
            else => {
                resolved_function_id = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id: callee_scope_id, must_be_enum_constructor)
                if not resolved_function_id.has_value() {
                    return CheckedExpression::Call(call: CheckedCall(namespace_: resolved_namespaces, name: call.name, args, function_id: resolved_function_id, return_type, callee_throws), span, type_id: return_type)
                }

                let function_id = resolved_function_id!
                let callee = .get_function(function_id)
                callee_throws = callee.can_throw
                return_type = callee.return_type_id

                let scope_containing_callee = .get_scope(callee.function_scope_id).parent!

                .check_method_access(accessor: caller_scope_id, accessee: scope_containing_callee, method: callee, span)

                // If this is a method, let's also add the types we know from our `this` pointer.
                if this_expr.has_value() {
                    let type_id = expression_type(this_expr!)
                    maybe_this_type_id = type_id
                    let param_type = .get_type(type_id)

                    // FIXME: Handle generics

                    if callee.is_static() {
                        .error("Cannot call static method on an instance of an object", span)
                    }

                    if callee.is_mutating() and not .expression_is_mutable(this_expr!) {
                        .error("Cannot call mutating method on an immutable object instance", span)
                    }
                }

                // This will be 0 for functions or 1 for instance methods, because of the `this` ptr
                let arg_offset = match this_expr.has_value() {
                    true => 1uz
                    else => 0uz
                }

                if callee.params.size() != (call.args.size() + arg_offset) {
                    .error("Wrong number of arguments", span)
                }

                for i in 0..call.args.size() {
                    if i == callee.params.size() {
                        break
                    }

                    let parsed_label_and_arg = call.args[i]
                    let param = callee.params[i]

                    if param.requires_label {
                        .validate_argument_label(param, label: parsed_label_and_arg.0, span: parsed_label_and_arg.1, expr: parsed_label_and_arg.2)
                    }
                    mut checked_arg = .typecheck_expression(expr: parsed_label_and_arg.2, scope_id: caller_scope_id, safety_mode)

                    let promoted_arg = .try_to_promote_constant_expr_to_type(lhs_type: param.variable.type_id, checked_rhs: checked_arg, span)
                    checked_arg = promoted_arg ?? checked_arg

                    // FIXME: It's super awkward that we have to pass "generic_inferences" here:
                    .check_types_for_compat(lhs_type_id: param.variable.type_id, rhs_type_id: expression_type(checked_arg), generic_inferences: ["":""], span)

                    args.push((call.name, checked_arg))
                }
            }
        }

        if callee_throws and not .get_scope(caller_scope_id).can_throw {
            .error("Call to function that may throw needs to be in a try statement or a function marked as throws", span)
        }

        return CheckedExpression::Call(call: CheckedCall(namespace_: resolved_namespaces, name: call.name, args, function_id: resolved_function_id, return_type, callee_throws), span, type_id: return_type)
    }

    function resolve_type_var(this, type_var_type_id: TypeId, scope_id: ScopeId) throws -> TypeId {
        mut current_type_id = type_var_type_id

        loop {
            let type_var_type = .get_type(current_type_id)
            match type_var_type {
                Type::TypeVariable(type_name) => {
                    let maybe_found_type_id = .find_type_in_scope(scope_id, name: type_name)
                    if maybe_found_type_id.has_value() {
                        let found_type_id = maybe_found_type_id.value()
                        if found_type_id.equals(current_type_id) {
                            return current_type_id
                        }
                        current_type_id = found_type_id
                    } else {
                        return current_type_id
                    }
                } else => {
                    return current_type_id
                }
            }
        }
        return current_type_id
    }

    function validate_argument_label(mut this, param: CheckedParameter, label: String, span: Span, expr: ParsedExpression) throws -> bool {
        if label == param.variable.name {
            return true
        }
        match expr {
            Var(name, span) => {
                if name == param.variable.name {
                    return true
                }
                .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", name, param.variable.name), span)
            }
            else => {}
        }
        .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", label, param.variable.name), span)
        return false
    }
}
