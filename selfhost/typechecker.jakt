import error { JaktError }
import parser { BinaryOperator, DefinitionLinkage, FunctionLinkage,
                DefinitionType, ParsedBlock, ParsedCall, ParsedExpression,
                ParsedFunction, ParsedNamespace, ParsedType, ParsedStatement,
                ParsedVarDecl, RecordType }
import utility { panic, todo, Span }

enum SafetyMode {
    Safe
    Unsafe
}

struct ModuleId {
    id: usize
}

struct VarId {
    module: ModuleId
    id: usize
}

struct FunctionId {
    module: ModuleId
    id: usize
}

struct StructId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: StructId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct EnumId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: EnumId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct TypeId {
    module: ModuleId
    id: usize

    function equals(this, anon rhs: TypeId) -> bool {
        return this.module.id == rhs.module.id and this.id == rhs.id
    }
}

struct InferenceId {
    id: usize

    function equals(this, anon rhs: InferenceId) -> bool {
        // FIXME: this should do follow the inference id
        // to see what the type is being inferred to be,
        // and check if both types are equal
        return this.id == rhs.id
    }
}

struct ScopeId {
    module: ModuleId
    id: usize
}

enum BuiltinType: usize {
    Void = 0
    Bool = 1
    U8 = 2
    U16 = 3
    U32 = 4
    U64 = 5
    I8 = 6
    I16 = 7
    I32 = 8
    I64 = 9
    F32 = 10
    F64 = 11
    Usize = 12
    String = 13
    CChar = 14
    CString = 15
    CInt = 16
}

boxed enum Type {
    Void
    Bool
    U8
    U16
    U32
    U64
    I8
    I16
    I32
    I64
    F32
    F64
    Usize
    JaktString
    CChar
    CInt
    CString
    TypeVariable(String)
    GenericInstance(id: StructId, args: [TypeId])
    GenericEnumInstance(id: EnumId, args: [TypeId])
    Struct(StructId)
    Enum(EnumId)
    Inference(InferenceId)
    RawPtr(TypeId)

    function equals(this, anon rhs: Type) -> bool {
        if this is Void and rhs is Void {
            return true
        } else if this is Bool and rhs is Bool {
            return true
        } else if this is U8 and rhs is U8 {
            return true
        } else if this is U16 and rhs is U16 {
            return true
        } else if this is U32 and rhs is U32 {
            return true
        } else if this is U64 and rhs is U64 {
            return true
        } else if this is I8 and rhs is I8 {
            return true
        } else if this is I16 and rhs is I16 {
            return true
        } else if this is I32 and rhs is I32 {
            return true
        } else if this is I64 and rhs is I64 {
            return true
        } else if this is F32 and rhs is F32 {
            return true
        } else if this is F64 and rhs is F64 {
            return true
        } else if this is Usize and rhs is Usize {
            return true
        } else if this is JaktString and rhs is JaktString {
            return true
        } else if this is CChar and rhs is CChar {
            return true
        } else if this is CInt and rhs is CInt {
            return true
        } else if this is CString and rhs is CString {
            return true
        } else {
            match this {
                TypeVariable(lhs_name) => {
                    match rhs {
                        TypeVariable(rhs_name) => {
                            return lhs_name == rhs_name
                        }
                        else => {
                            return false
                        }
                    }
                }
                GenericInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                GenericEnumInstance(id: lhs_id, args: lhs_args) => {
                    match rhs {
                        GenericEnumInstance(id: rhs_id, args: rhs_args) => {
                            if lhs_id.equals(rhs_id) and lhs_args.size() == rhs_args.size() {
                                mut idx = 0uz

                                while idx < lhs_args.size() {
                                    if lhs_args[idx].equals(rhs_args[idx]) {
                                        return false
                                    }
                                    idx++
                                }
                                return true
                            }
                            return false
                        }
                        else => {
                            return false
                        }
                    }
                    return false
                }
                Struct(lhs_id) => {
                    match rhs {
                        Struct(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                Enum(lhs_id) => {
                    match rhs {
                        Enum(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                Inference(lhs_id) => {
                    match rhs {
                        Inference(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                RawPtr(lhs_id) => {
                    match rhs {
                        RawPtr(rhs_id) => {
                            return lhs_id.equals(rhs_id)
                        }
                        else => {
                            return false
                        }
                    }
                }
                else => {
                    return false
                }
            }
            return false
        }
    }

    function is_builtin(this) -> bool => match this {
        Void | Bool | U8 | U16 | U32 | U64 | I8 | I16 | I32 | I64 | F32 | F64 | Usize | JaktString | CChar | CInt | CString => true
        else => false
    }

    function get_bits(this) -> i64 => match this {
        U8 | I8 | CChar => 8
        U16 | I16 => 16
        U32 | I32 | CInt => 32
        U64 | I64 | Usize => 64
        F32 => 32
        F64 => 64
        else => 0
    }

    function is_signed(this) -> bool => match this {
        I8 | I16 | I32 | I64 | CChar | CInt => true
        U8 | U16 | U32 | U64 | Usize => false
        F32 | F64 => true
        else => false
    }

    function min(this) -> i64 => match this {
        CChar => -128
        CInt => -2147483648
        I8 => -128
        I16 => -32768
        I32 => -2147483648
        I64 => -9223372036854775807 - 1
        U8 | U16 | U32 | U64 | Usize => 0
        else => 0
    }

    function max(this) -> u64 => match this {
        CChar => 127u64
        CInt => 2147483647u64
        I8 => 127u64
        I16 => 32767u64
        I32 => 2147483647u64
        I64 => 9223372036854775807u64
        U8 => 255u64
        U16 => 65535u64
        U32 => 4294967295u64
        U64 => 18446744073709551615u64
        // FIXME: Don't assume that usize is 64-bit
        Usize => 18446744073709551615u64
        else => 0u64
    }
}

class Scope {
    public namespace_name: String?
    public vars: [String: VarId]
    public structs: [String: StructId]
    public functions: [String: FunctionId]
    public enums: [String: EnumId]
    public types: [String: TypeId]
    public imports: [String: (ModuleId, Span)]
    public parent: ScopeId?
    public children: [ScopeId]
    public can_throw: bool
}

class Module {
    public id: ModuleId
    public name: String
    public functions: [CheckedFunction]
    public structures: [CheckedStruct]
    public enums: [CheckedEnum]
    public scopes: [Scope]
    public types: [Type]
    public variables: [CheckedVariable]
    public imports: [ModuleId]

    public is_root: bool

    public function new_type_variable(mut this) throws -> TypeId {
        let new_id = .types.size()

        .types.push(Type::TypeVariable(format("T{}", new_id)))

        return TypeId(module: .id, id: new_id)
    }

    public function add_function(mut this, checked_function: CheckedFunction) throws -> FunctionId {
        let new_id = .functions.size()

        .functions.push(checked_function)

        return FunctionId(module: .id, id: new_id)
    }

    public function add_variable(mut this, anon checked_variable: CheckedVariable) throws -> VarId {
        let new_id = .variables.size()

        .variables.push(checked_variable)

        return VarId(module: .id, id: new_id)
    }
}

struct CheckedNamespace {
    name: String
    scope: ScopeId
}

class CheckedFunction {
    public name: String
    public return_type_id: TypeId
    public params: [CheckedParameter]
    public block: CheckedBlock
    public can_throw: bool
    public linkage: FunctionLinkage
    public function_scope_id: ScopeId

    public function is_static(this) -> bool {
        if .params.size() < 1 {
            return true
        }

        return .params[0].variable.name != "this"
    }

    public function is_mutating(this) -> bool {
        if .params.size() < 1 {
            return false
        }

        let first_param_variable = .params[0].variable

        return first_param_variable.name == "this" and first_param_variable.is_mutable
    }
}

struct CheckedParameter {
    requires_label: bool
    variable: CheckedVariable
}

struct CheckedVariable {
    name: String
    type_id: TypeId
    is_mutable: bool
    definition_span: Span
}

struct CheckedVarDecl {
    name: String
    is_mutable: bool
    span: Span
    type_id: TypeId
}

struct CheckedBlock {
    statements: [CheckedStatement]
    scope_id: ScopeId
    definitely_returns: bool
    yielded_type: TypeId?
}

struct CheckedStruct {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    fields: [VarId]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    type_id: TypeId
}

struct CheckedEnum {
    name: String
    name_span: Span
    generic_parameters: [TypeId]
    variants: [CheckedEnumVariant]
    scope_id: ScopeId
    definition_linkage: DefinitionLinkage
    record_type: RecordType
    underlying_type_id: TypeId
    type_id: TypeId
}

enum CheckedEnumVariant {
    Untyped(name: String, span: Span)
    Typed(name: String, type_id: TypeId, span: Span)
    WithValue(name: String, expr: CheckedExpression, span: Span)
    StructLike(name: String, fields: [VarId], span: Span)
}

boxed enum CheckedStatement {
    Expression(CheckedExpression)
    Defer(CheckedStatement)
    VarDecl(var_id: VarId, init: CheckedExpression)
    If(guard: CheckedExpression, then_block: CheckedBlock, else_statement: CheckedStatement?)
    Block(CheckedBlock)
    Loop(CheckedBlock)
    While(guard: CheckedExpression, block: CheckedBlock)
    Return(CheckedExpression?)
    Break
    Continue
    Throw(CheckedExpression)
    Yield(CheckedExpression)
    Try(stmt: CheckedStatement, error_name: String, catch_block: CheckedBlock)
    InlineCpp([String])
    Garbage
}

enum NumberConstant {
    Signed(i64)
    Unsigned(u64)
    Floating(f64)

    function can_fit_number(this, type_id: TypeId, program: CheckedProgram) -> bool {
        let type_ = program.get_type(type_id)

        return match this {
            Signed(value) => match type_ {
                I64 => true
                U64 | Usize => value >= 0
                else => program.is_integer(type_id) and value >= type_.min() and value <= (type_.max() as! i64)
            }
            Unsigned(value) => match type_ {
                U64 | Usize => true
                else => program.is_integer(type_id) and value <= type_.max()
            }
            Floating(value) => match type_ {
                F32 => {
                    todo("Implement casting f32 to f64")
                    yield false
                }
                F64 => true
                else => false
            }
        }
    }
}
// FIXME: Make this a member function of NumberConstant.
//        Right now we cannot do that as the compiler does not know the CheckedNumericConstant
//        constructors when we use them in a member function (https://github.com/SerenityOS/jakt/issues/677).
function promote(anon num_const: NumberConstant, type_id: TypeId, program: CheckedProgram) -> CheckedNumericConstant? {
    if not num_const.can_fit_number(type_id, program) {
        return None
    }

    let bits = program.get_bits(type_id)
    let is_signed = program.is_signed(type_id)
    let new_constant = match num_const {
        Signed(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value as! u64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Unsigned(value) => match is_signed {
            false => match bits {
                8 => CheckedNumericConstant::U8(value as! u8)
                16 => CheckedNumericConstant::U16(value as! u16)
                32 => CheckedNumericConstant::U32(value as! u32)
                64 => CheckedNumericConstant::U64(value)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => match bits {
                8 => CheckedNumericConstant::I8(value as! i8)
                16 => CheckedNumericConstant::I16(value as! i16)
                32 => CheckedNumericConstant::I32(value as! i32)
                64 => CheckedNumericConstant::I64(value as! i64)
                else => {
                    panic("Numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
        }
        Floating(value) => match is_signed {
            true => match bits {
                32 => {
                    todo("Add conversion from f64 to f32")
                    yield CheckedNumericConstant::I64(0)
                }
                64 => CheckedNumericConstant::F64(value)
                else => {
                    panic("Floating numeric constants can only be 8, 16, 32, or 64 bits long")
                    yield CheckedNumericConstant::I64(0)
                }
            }
            else => {
                panic("Floating numeric constant cannot be unsigned")
                yield CheckedNumericConstant::I64(0)
            }
        }
    }

    return new_constant
}

enum CheckedNumericConstant {
    I8(i8)
    I16(i16)
    I32(i32)
    I64(i64)
    U8(u8)
    U16(u16)
    U32(u32)
    U64(u64)
    USize(u64)
    F32(f32)
    F64(f64)

    // FIXME: make this into a FAMF (fat arrow match function) once we can yield `None` out of the match (https://github.com/SerenityOS/jakt/issues/669)
    //          or once we can cast f32 to f64
    function number_constant(this) -> NumberConstant? {
        match this {
            I8(value) => { return NumberConstant::Signed(value as! i64) }
            I16(value) => { return NumberConstant::Signed(value as! i64) }
            I32(value) => { return NumberConstant::Signed(value as! i64) }
            I64(value) => { return NumberConstant::Signed(value as! i64) }
            U8(value) => { return NumberConstant::Unsigned(value as! u64) }
            U16(value) => { return NumberConstant::Unsigned(value as! u64) }
            U32(value) => { return NumberConstant::Unsigned(value as! u64) }
            U64(value) => { return NumberConstant::Unsigned(value as! u64) }
            USize(value) => { return NumberConstant::Unsigned(value as! u64) }

            // FIXME: add a case for F32 once we can cast f32 to f64

            F64(value) => { return NumberConstant::Floating(value) }
            else => {}
        }

        return None
    }
}

enum CheckedTypeCast {
    Fallible(TypeId)
    Infallible(TypeId)
}

enum CheckedUnaryOperator {
    PreIncrement
    PostIncrement
    PreDecrement
    PostDecrement
    Negate
    Dereference
    RawAddress
    LogicalNot
    BitwiseNot
    TypeCast(CheckedTypeCast)
    Is(TypeId)
    IsEnumVariant(String)
}

boxed enum CheckedExpression {
    Boolean(val: bool, span: Span)
    NumericConstant(val: CheckedNumericConstant, span: Span, type_id: TypeId)
    QuotedString(val: String, span: Span)
    ByteConstant(val: String, span: Span)
    CharacterConstant(val: String, span: Span)
    UnaryOp(expr: CheckedExpression, op: CheckedUnaryOperator, span: Span, type_id: TypeId)
    BinaryOp(lhs: CheckedExpression, op: BinaryOperator, rhs: CheckedExpression, span: Span, type_id: TypeId)
    JaktTuple(vals: [CheckedExpression], span: Span, type_id: TypeId)
    Range(from: CheckedExpression, to: CheckedExpression, span: Span, type_id: TypeId)
    JaktArray(vals: [CheckedExpression], repeat: CheckedExpression?, span: Span, type_id: TypeId)
    JaktDictionary(vals: [(CheckedExpression, CheckedExpression)], span: Span, type_id: TypeId)
    JaktSet(vals: [CheckedExpression], span: Span, type_id: TypeId)
    IndexedExpression(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedDictionary(expr: CheckedExpression, index: CheckedExpression, span: Span, type_id: TypeId)
    IndexedTuple(expr: CheckedExpression, index: usize, span: Span, type_id: TypeId)
    IndexedStruct(expr: CheckedExpression, index: String, span: Span, type_id: TypeId)
    Call(call: CheckedCall, span: Span, type_id: TypeId)
    MethodCall(expr: CheckedExpression, call: CheckedCall, span: Span, type_id: TypeId)
    NamespacedVar(namespaces: [CheckedNamespace], var: CheckedVariable, span: Span)
    Var(var: CheckedVariable, span: Span)
    OptionalNone(span: Span, type_id: TypeId)
    OptionalSome(expr: CheckedExpression, span: Span, type_id: TypeId)
    ForcedUnwrap(expr: CheckedExpression, span: Span, type_id: TypeId)
    Block(block: CheckedBlock, span: Span, type_id: TypeId)
    Garbage(Span)

    // FIXME: rewrite this into a FAMF once we can yield None out of a match (https://github.com/SerenityOS/jakt/issues/669)
    function to_number_constant(this, program: CheckedProgram) -> NumberConstant? {
        match this {
            NumericConstant(val, span, type_id) => { return val.number_constant() }
            UnaryOp(expr, op, span, type_id) => {
                if not program.is_integer(type_id) and not program.is_floating(type_id) {
                    return None
                }
                match expr {
                    NumericConstant(val, span: span_, type_id: type_id_) => { return val.number_constant() }
                    else => {}
                }
            }
            else => {}
        }

        return None
    }
}

struct ResolvedNamespace {
    name: String
    generic_parameters: [TypeId]?
}

struct CheckedCall {
    namespace_: [ResolvedNamespace]
    name: String,
    args: [(String, CheckedExpression)]
    function_id: FunctionId?
    return_type: TypeId
    callee_throws: bool
}


function builtin(anon builtin: BuiltinType) -> TypeId {
    return TypeId(module: ModuleId(id: 0), id: builtin as! usize)
}

// This is the "result" object produced by type-checking.
class CheckedProgram {
    public modules: [Module]

    public function get_module(this, anon id: ModuleId) -> Module => .modules[id.id]
    public function get_function(this, anon id: FunctionId) -> CheckedFunction => .modules[id.module.id].functions[id.id]
    public function get_variable(this, anon id: VarId) -> CheckedVariable => .modules[id.module.id].variables[id.id]
    public function get_type(this, anon id: TypeId) -> Type => .modules[id.module.id].types[id.id]
    public function get_enum(this, anon id: EnumId) -> CheckedEnum => .modules[id.module.id].enums[id.id]
    public function get_struct(this, anon id: StructId) -> CheckedStruct => .modules[id.module.id].structures[id.id]
    public function get_scope(this, anon id: ScopeId) -> Scope => .modules[id.module.id].scopes[id.id]

    public function is_integer(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | CInt | CChar => true
            else => false
        }
    }

    public function is_floating(this, anon type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        return match type {
            F32 | F64 => true
            else => false
        }
    }

    public function is_numeric(this, anon type_id: TypeId) -> bool {
        return .is_integer(type_id) or .is_floating(type_id)
    }

    public function get_bits(this, anon type_id: TypeId) => .get_type(type_id).get_bits()

    public function is_signed(this, anon type_id: TypeId) => .get_type(type_id).is_signed()
}

struct Typechecker {
    program: CheckedProgram
    inferences: [TypeId]
    current_module_id: ModuleId
    inside_defer: bool
    errors: [JaktError]

    function typecheck(parsed_namespace: ParsedNamespace, errors: [JaktError]) throws -> CheckedProgram {
        let root_module_id = ModuleId(id: 0)
        let module = Module(
            id: root_module_id,
            name: parsed_namespace.name ?? "Root Module",
            functions: [],
            structures: [],
            enums: [],
            scopes: [],
            types: [
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
                Type::CString,
            ],
            variables: [],
            imports: [],
            is_root: true,
        )

        mut typechecker = Typechecker(
            program: CheckedProgram(modules: [module]),
            inferences: [],
            current_module_id: root_module_id,
            inside_defer: false
            errors
        )

        typechecker.typecheck_module(parsed_namespace, scope_id: ScopeId(module: root_module_id, id: 0))

        return typechecker.program
    }

    function get_function(this, anon id: FunctionId) => .program.get_function(id)
    function get_variable(this, anon id: VarId) => .program.get_variable(id)
    function get_type(this, anon id: TypeId) => .program.get_type(id)
    function get_enum(this, anon id: EnumId) => .program.get_enum(id)
    function get_struct(this, anon id: StructId) => .program.get_struct(id)
    function get_scope(this, anon id: ScopeId) => .program.get_scope(id)

    function current_module(this) => .program.get_module(.current_module_id)

    function error(mut this, anon message: String, anon span: Span) throws {
        .errors.push(JaktError::Message(message, span))
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        .errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
    }

    function is_integer(this, anon type_id: TypeId) => .program.is_integer(type_id)
    function is_floating(this, anon type_id: TypeId) => .program.is_floating(type_id)
    function is_numeric(this, anon type_id: TypeId) => .program.is_numeric(type_id)

    function create_scope(mut this, parent_scope_id: ScopeId, can_throw: bool) throws -> ScopeId {
        let scope = Scope(
            namespace_name: ""
            vars: [:]
            structs: [:]
            functions: [:]
            enums: [:]
            types: [:]
            imports: [:]
            parent: parent_scope_id
            children: []
            can_throw
        )

        .program.modules[.current_module_id.id].scopes.push(scope)

        return ScopeId(module: .current_module_id, id: .program.modules[.current_module_id.id].scopes.size() - 1)
    }

    function new_inference(mut this) throws -> TypeId {
        let new_type_var = .program.modules[.current_module_id.id].new_type_variable()

        .inferences.push(new_type_var)

        let inference_id = .inferences.size() - 1

        .program.modules[.current_module_id.id].types.push(Type::Inference(InferenceId(id: inference_id)))

        let new_type_id = .program.modules[.current_module_id.id].types.size() - 1

        return TypeId(module: .current_module_id, id: new_type_id)
    }

    function find_struct_in_prelude(this, anon name: String) throws -> StructId {
        // FIXME: Remove this short-circuit once we actually start parsing the prelude!
        return StructId(module: ModuleId(id: 0), id: 0)

        // start at the prelude scope id
        for entry in .get_scope(ScopeId(module: ModuleId(id: 0), id: 0)).structs.iterator() {
            if entry.0 == name {
                return entry.1
            }
        }
        panic(format("internal error: {} builtin definition not found" name))
        return StructId(module: ModuleId(id: 0), id: 0)
    }

    function try_to_promote_constant_expr_to_type(mut this, lhs_type: TypeId, checked_rhs: CheckedExpression, span: Span) throws -> CheckedExpression? {
        if not .is_integer(lhs_type) {
            return None
        }

        let rhs_constant_opt = checked_rhs.to_number_constant(program: .program)
        if not rhs_constant_opt.has_value() {
            return None
        }
        let rhs_constant = rhs_constant_opt!

        let result = promote(rhs_constant, type_id: lhs_type, program: .program)
        if not result.has_value() {
            .error("Integer promotion failed", span)
            return None
        }
        let new_constant = result!

        return CheckedExpression::NumericConstant(val: new_constant, span, type_id: lhs_type)
    }

    function type_name(this, anon type_id: TypeId) throws -> String {
        let type = .get_type(type_id)

        return match type {
            Void => "void"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            F32 => "f32"
            F64 => "f64"
            Usize => "usize"
            CChar => "c_char"
            CInt => "c_int"
            Bool => "bool"
            JaktString => "String"
            else => match type {
                Enum(id) => .get_enum(id).name
                Struct(id) => .get_struct(id).name
                GenericEnumInstance(id, args) => {
                    mut output = format("enum {}", .get_enum(id).name)

                    output += "<"
                    mut first = true
                    for arg in args.iterator() {
                        if not first {
                            output += ", "
                        } else {
                            first = false
                        }

                        output += .type_name(arg)
                    }

                    output += ">"

                    yield output
                }
                else => "TODO"
            }
        }
    }

    function expression_type(this, anon expr: CheckedExpression) -> TypeId => match expr {
        Boolean => builtin(BuiltinType::Bool)
        NumericConstant(type_id) => type_id
        QuotedString => builtin(BuiltinType::String)
        ByteConstant => builtin(BuiltinType::U8)
        CharacterConstant => builtin(BuiltinType::CChar)
        UnaryOp(type_id) => type_id
        BinaryOp(type_id) => type_id
        JaktTuple(type_id) => type_id
        Range(type_id) => type_id
        JaktArray(type_id) => type_id
        JaktDictionary(type_id) => type_id
        JaktSet(type_id) => type_id
        IndexedExpression(type_id) => type_id
        IndexedDictionary(type_id) => type_id
        IndexedTuple(type_id) => type_id
        IndexedStruct(type_id) => type_id
        Call(type_id) => type_id
        MethodCall(type_id) => type_id
        NamespacedVar(var) => var.type_id
        Var(var) => var.type_id
        OptionalNone(type_id) => type_id
        OptionalSome(type_id) => type_id
        ForcedUnwrap(type_id) => type_id
        Block(type_id) => type_id
        Garbage => builtin(BuiltinType::Void)
    }

    // FIXME: not a method of expression because of https://github.com/SerenityOS/jakt/issues/527
    function expression_span(this, anon expr: CheckedExpression) -> Span => match expr {
        Boolean(span) => span
        NumericConstant(span) => span
        QuotedString(span) => span
        ByteConstant(span) => span
        CharacterConstant(span) => span
        UnaryOp(span) => span
        BinaryOp(span) => span
        JaktTuple(span) => span
        Range(span) => span
        JaktArray(span) => span
        JaktDictionary(span) => span
        JaktSet(span) => span
        IndexedExpression(span) => span
        IndexedDictionary(span) => span
        IndexedTuple(span) => span
        IndexedStruct(span) => span
        Call(span) => span
        MethodCall(span) => span
        NamespacedVar(span) => span
        Var(span) => span
        OptionalNone(span) => span
        OptionalSome(span) => span
        ForcedUnwrap(span) => span
        Block(span) => span
        Garbage(span) => span
    }

    function expression_is_mutable(this, anon expr: CheckedExpression) -> bool => match expr {
        Var(var) => var.is_mutable
        IndexedStruct(expr) => .expression_is_mutable(expr)
        IndexedExpression(expr) => .expression_is_mutable(expr)
        IndexedTuple(expr) => .expression_is_mutable(expr)
        IndexedDictionary(expr) => .expression_is_mutable(expr)
        ForcedUnwrap(expr) => .expression_is_mutable(expr)
        else => false
    }

    function unify(mut this, lhs: TypeId, lhs_span: Span, rhs: TypeId, rhs_span: Span) throws -> TypeId? {
        // FIXME: Add more unification logic
        if lhs.id != rhs.id {
            .error("types incompatible ", rhs_span)
            return None
        } else {
            return lhs
        }
    }

    function find_or_add_type_id(mut this, anon type: Type) throws -> TypeId {
        let module = .program.modules[.current_module_id.id]
        let module_id = module.id

        mut idx = 0uz
        for item in module.types.iterator() {
            if item.equals(type) {
                return TypeId(module: module_id, id: idx)
            }
            ++idx
        }

        idx = 0uz
        for item in .program.modules[0].types.iterator() {
            if item.equals(type) {
                return TypeId(module: .program.modules[0].id, id: idx)
            }
            ++idx
        }

        .program.modules[.current_module_id.id].types.push(type)

        return TypeId(module: module_id, id: .program.modules[.current_module_id.id].types.size() - 1)
    }

    function find_type_in_scope(this, scope_id: ScopeId, name: String) -> TypeId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)

            for type in scope.types.iterator() {
                if type.0 == name {
                    return type.1
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    // Find the namespace in the current scope, or one of its parents,
    // and whether the found scope was an import.
    function find_namespace_in_scope(this, scope_id: ScopeId, name: String) -> (ScopeId, bool)? {
        mut current = scope_id;

        loop {
            let scope = .get_scope(current)

            for child in scope.children.iterator() {
                let child_scope = .get_scope(child)
                if child_scope.namespace_name.has_value() {
                    if name == child_scope.namespace_name.value() {
                        return (current, false)
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        // if we do not find it then check imports
        let module_id = current.module

        for imp in .get_scope(ScopeId(module: module_id, id: 0)).imports.iterator() {
            if name == imp.0 {
                let value = imp.1
                return (ScopeId(module: value.0, id: 0), true)
            }
        }

        return None
    }

    function add_function_to_scope(mut this, parent_scope_id: ScopeId, name: String, function_id: FunctionId, span: Span) throws -> bool {
        mut scope = .get_scope(id: parent_scope_id)
        for existing_function in scope.functions.iterator() {
            if name == existing_function.0 {
                // FIXME: Show hint of the original definition, once we store the name span.
                .error(format("Redefinition of function ‘{}’", name), span)
                return false
            }
        }
        scope.functions.set(key: name, value: function_id)
        return true
    }

    function add_var_to_scope(mut this, scope_id: ScopeId, name: String, var_id: VarId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        for existing_var in scope.vars.iterator() {
            if name == existing_var.0 {
                // FIXME: Show hint of the original definition, once we store the name span.
                .error(format("Redefinition of variable ‘{}’", name), span)
            }
        }
        scope.vars.set(key: name, value: var_id)
        return true
    }
    
    function find_function_in_scope(this, parent_scope_id: ScopeId, function_name: String) -> FunctionId? {
        mut scope_id = Some(parent_scope_id)
        while scope_id.has_value() {
            let scope = .get_scope(id: scope_id!)
            for s in scope.functions.iterator() {
                if s.0 == function_name {
                    return Some(s.1)
                }
            }
            scope_id = scope.parent
        }

        return None
    }

    function typecheck_module(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        .typecheck_namespace_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_declarations(parsed_namespace, scope_id)
    }

    function typecheck_namespace_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function_predecl(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_namespace_declarations(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function(parsed_function: fun, parent_scope_id: scope_id)
        }
    }

    function typecheck_function_predecl(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        let function_scope_id = .create_scope(parent_scope_id, can_throw: parsed_function.can_throw)
        let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: parsed_function.can_throw)
        let module_id = .current_module_id.id

        // TODO: Make this true if it's a method of a generic class/struct.
        let is_generic = not parsed_function.generic_parameters.is_empty()

        let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)
        let none_type_id: TypeId? = None

        mut checked_function = CheckedFunction(
            name: parsed_function.name,
            return_type_id: UNKNOWN_TYPE_ID,
            params: [],
            block: CheckedBlock(
                statements: []
                scope_id: block_scope_id
                definitely_returns: false
                yielded_type: none_type_id
            )
            can_throw: parsed_function.can_throw,
            linkage: parsed_function.linkage,
            function_scope_id,
        )
        // FIXME: We can't return a `mut Foo` from a function right now, but assigning anything to a `mut` variable makes it mutable.
        //        AKA, working around one bug with another bug. :^)
        mut current_module = .current_module()
        let function_id = current_module.add_function(checked_function)
        let checked_function_scope_id = checked_function.function_scope_id

        // TODO: Check generic parameters

        for parameter in parsed_function.params.iterator() {
            let type_id = .typecheck_typename(parsed_type: parameter.variable.parsed_type, scope_id: checked_function_scope_id)

            let variable = CheckedVariable(
                name: parameter.variable.name
                type_id
                is_mutable: parameter.variable.is_mutable
                definition_span: parameter.variable.span
            )

            let checked_parameter = CheckedParameter(
                requires_label: parameter.requires_label
                variable
            )

            checked_function.params.push(checked_parameter)
        }

        checked_function.return_type_id = .typecheck_typename(parsed_type: parsed_function.return_type, scope_id: checked_function_scope_id)

        .add_function_to_scope(parent_scope_id, name: parsed_function.name, function_id, span: parsed_function.name_span)
    }

    function typecheck_jakt_main(mut this, parsed_function: ParsedFunction) throws {
        let param_type_error = "Main function must take a single array of strings as its parameter"
        if parsed_function.params.size() > 1 {
            .error(param_type_error, parsed_function.name_span)
        }

        if not parsed_function.params.is_empty() {
            match parsed_function.params[0].variable.parsed_type {
                ParsedType::JaktArray(inner, span) => {
                    match inner {
                        ParsedType::Name(name, span) => {
                            if (name != "String") {
                                .error(param_type_error, span)
                            }
                        }
                        else => {
                            .error(param_type_error, span)
                        }
                    }
                }
                else => {
                    .error(param_type_error, parsed_function.name_span)
                }
            }
        }

        let return_type_error = "Main function must return c_int"
        match parsed_function.return_type {
            ParsedType::Empty => {}
            ParsedType::Name(name, span) => {
                if name != "c_int" {
                    .error(return_type_error, span)
                }
            }
            else => {
                .error(return_type_error, parsed_function.return_type_span)
            }
        }
    }

    function typecheck_function(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        if not parsed_function.generic_parameters.is_empty() and not parsed_function.must_instantiate {
            return
        } 

        // FIXME: Optional.expect("...") would be nicer here.
        let function_id = .find_function_in_scope(parent_scope_id, function_name: parsed_function.name)
        if not function_id.has_value() {
            panic("Internal error: missing previously defined function")
        }
        if parsed_function.name == "main" {
            .typecheck_jakt_main(parsed_function)
        }
        mut checked_function = .get_function(function_id!)
        let function_scope_id = checked_function.function_scope_id
        let function_linkage = checked_function.linkage

        mut param_vars: [CheckedVariable] = []

        for param in checked_function.params.iterator() {
            param_vars.push(param.variable)
        }

        for variable in param_vars.iterator() {
            mut module = .current_module()
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // TODO: Resolve concreete types

        // TODO: Typecheck function block
        checked_function.block = .typecheck_block(parsed_function.block, parent_scope_id: function_scope_id, safety_mode: SafetyMode::Safe)

        // TODO: Typecheck return type a second time to resolve generics

        // TODO: Infer return type if necessary

        // TODO: Report if control reaches end of non-void function

        // TODO: Assign checked block and return type to checked_function
    }

    function typecheck_block(mut this, anon parsed_block: ParsedBlock, parent_scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedBlock {
        let parent_throws = .get_scope(parent_scope_id).can_throw
        let block_scope_id = .create_scope(parent_scope_id, can_throw: parent_throws)
        let none_type_id: TypeId? = None
        mut checked_block = CheckedBlock(
            statements: []
            scope_id: block_scope_id
            definitely_returns: false
            yielded_type: none_type_id
        )

        for parsed_statement in parsed_block.stmts.iterator() {
            checked_block.statements.push(.typecheck_statement(parsed_statement, scope_id: block_scope_id, safety_mode))
        }

        return checked_block
    }

    function typecheck_typename(mut this, parsed_type: ParsedType, scope_id: ScopeId) throws -> TypeId { 
        match parsed_type {
            NamespacedName(name, namespaces, params, span) => {
                mut current_namespace_scope_id = scope_id

                for ns in namespaces.iterator() {
                    let result = .find_namespace_in_scope(scope_id: current_namespace_scope_id, name: ns)

                    if result.has_value() {
                        current_namespace_scope_id = result!.0
                    } else {
                        .error(format("Unknown namespace: '{}'", ns), span)
                        return .new_inference()
                    }
                }

                mut generic_args: [TypeId] = []

                for param in params.iterator() {
                    let checked_arg = .typecheck_typename(parsed_type: param, scope_id)

                    generic_args.push(checked_arg)
                }

                // TODO: add synthetic type_name and generic support

                return .typecheck_typename(parsed_type, scope_id)
            }
            Name(name, span) => {
                return match name {
                    "i8" => builtin(BuiltinType::I8)
                    "i16" => builtin(BuiltinType::I16)
                    "i32" => builtin(BuiltinType::I32)
                    "i64" => builtin(BuiltinType::I64)
                    "u8" => builtin(BuiltinType::U8)
                    "u16" => builtin(BuiltinType::U16)
                    "u32" => builtin(BuiltinType::U32)
                    "u64" => builtin(BuiltinType::U64)
                    "f32" => builtin(BuiltinType::F32)
                    "f64" => builtin(BuiltinType::F64)
                    "c_char" => builtin(BuiltinType::CChar)
                    "c_int" => builtin(BuiltinType::CInt)
                    "usize" => builtin(BuiltinType::Usize)
                    "String" => builtin(BuiltinType::String)
                    "bool" => builtin(BuiltinType::Bool)
                    "void" => builtin(BuiltinType::Void)
                    else => {
                        let type_id = .find_type_in_scope(scope_id, name)

                        if type_id.has_value() {
                            return type_id.value()
                        } else {
                            .error(format("Unknown type ‘{}’", name), span)
                            return .new_inference()
                        }
                    }
                }
            }
            Empty => {
                return .new_inference()
            }
            JaktTuple(types, span) => {
                mut checked_types: [TypeId] = []
                for parsed_type in types.iterator() {
                    checked_types.push(.typecheck_typename(parsed_type, scope_id))
                }
                let tuple_struct_id = .find_struct_in_prelude("Tuple")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

                return type_id
            }
            JaktArray(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let array_struct_id = .find_struct_in_prelude("Array")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))

                return type_id
            }
            Dictionary(key, value, span) => {
                let key_type_id = .typecheck_typename(parsed_type: key, scope_id)
                let value_type_id = .typecheck_typename(parsed_type: value, scope_id)

                let dict_struct_id = .find_struct_in_prelude("Dictionary")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: dict_struct_id, args: [key_type_id, value_type_id]))

                return type_id
            }
            Set(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let set_struct_id = .find_struct_in_prelude("Set")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [inner_type_id]))

                return type_id
            }
            Optional(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let optional_struct_id = .find_struct_in_prelude("Optional")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [inner_type_id]))

                return type_id
            }
            WeakPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

                let type_id = .find_or_add_type_id(Type::GenericInstance(id: weakptr_struct_id, args: [inner_type_id]))

                return type_id
            }
            RawPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id)

                let type_id = .find_or_add_type_id(Type::RawPtr(id: inner_type_id))

                return type_id
            }
            GenericType(name, generic_parameters, span) => {
                mut checked_inner_types: [TypeId] = []

                for inner_type in generic_parameters.iterator() {
                    let inner_type_id = .typecheck_typename(parsed_type, scope_id)
                    checked_inner_types.push(inner_type_id)
                }
                // FIXME: add support for "GenericResolvedType", though the Rust version
                // puts this in the parser even though it should be in the typechecker
                // as the parser doesn't have a concept of type ids
                return .new_inference()
            }
        }
        // FIXME: This is unreachable but the generated C++ causes a warning.
        panic("should be unreachable")
        return .new_inference()
    }

    function typecheck_binary_operation(mut this, checked_lhs: CheckedExpression, op: BinaryOperator, checked_rhs: CheckedExpression, scope_id: ScopeId, span: Span) throws -> TypeId {
        let lhs_type_id = .expression_type(checked_lhs)
        let rhs_type_id = .expression_type(checked_rhs)

        let lhs_span = .expression_span(checked_lhs)
        let rhs_span = .expression_span(checked_rhs)

        mut type_id = .expression_type(checked_lhs)

        match op {
            NoneCoalescing | NoneCoalescingAssign => {
                // 1. LHS must be Optional<T>.
                // 2. RHS must be Optional<T> or T.
                // 3. Resulting type is Optional<T> or T, respectively.

                // if an assignment, the LHS must be a mutable variable.
                if op is NoneCoalescingAssign {
                    match checked_lhs {
                        Var(var, span) => {
                            if not var.is_mutable {
                                .error_with_hint(message: "left-hand side of ??= must be a mutable variable", span, hint: "This variable isn't marked as mutable", hint_span: var.definition_span)
                                return .new_inference()
                            }
                        }
                        else => {
                            .error(message: "left-hand side of ??= must be a mutable variable", span)
                            return .new_inference()
                        }
                    }
                }

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        if id.equals(optional_struct_id) {
                            // Success: LHS is T? and RHS is T?.
                            if lhs_type_id.equals(rhs_type_id) {
                                return lhs_type_id
                            }

                            // Extract T from Optional<T>.
                            let inner_type_id = args[0]

                            if inner_type_id.equals(rhs_type_id) {
                                // Success: LHS is T? and RHS is T.
                                return inner_type_id
                            }
                        } else {
                            .error_with_hint(format(
                                "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            ), span,
                            "Left side of ?? must be an Optional but isn't",
                            lhs_span)
                        }
                    }
                    else => {
                        .error_with_hint(format(
                            "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                            .type_name(lhs_type_id),
                            .type_name(rhs_type_id),
                        ), span,
                        "Left side of ?? must be an Optional but isn't",
                        lhs_span)
                    }
                }

                .error(format(
                    "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                    .type_name(lhs_type_id),
                    .type_name(rhs_type_id),
                ), span)

                return lhs_type_id
            }
            LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Equal | NotEqual => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format("Binary comparison between incompatible types ({} vs {})", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            LogicalAnd | LogicalOr => {
                if not lhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("left side of logical binary operation is not a boolean", lhs_span)
                }

                if not rhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("right side of logical binary operation is not a boolean", rhs_span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            Assign => {
                if not .expression_is_mutable(checked_lhs) {
                    .error("assignment to immutable variable", span)
                    return lhs_type_id
                }
                match checked_rhs {
                    OptionalNone(span, type_id) => {
                        let lhs_type = .get_type(lhs_type_id)
                        let optional_struct_id = .find_struct_in_prelude("Optional")

                        match lhs_type {
                            GenericInstance(id, args) => {
                                if id.equals(optional_struct_id) {
                                    return lhs_type_id
                                }
                            }
                            else => {}
                        }
                    }
                    else => {}
                }

                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format("Assignment between incompatible types (‘{}’ and ‘{}’)", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }
                return result.value_or(lhs_type_id)
            }
            AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign | BitwiseAndAssign | BitwiseOrAssign | BitwiseXorAssign | BitwiseLeftShiftAssign | BitwiseRightShiftAssign => {
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                match .get_type(lhs_type_id) {
                    GenericInstance(id, args) => {
                        if id.equals(weak_ptr_struct_id) {
                            let inner_type_id = args[0]
                            match .get_type(inner_type_id) {
                                Type::Struct(struct_id: lhs_struct_id) => {
                                    match .get_type(rhs_type_id) {
                                        Type::Struct(struct_id: rhs_struct_id) => {
                                            if lhs_struct_id.equals(rhs_struct_id) {
                                                return lhs_type_id
                                            }
                                        }
                                        else => {}
                                    }
                                }
                                else => {}
                            }
                        }

                        if not lhs_type_id.equals(rhs_type_id) {
                            .error(format(
                                "Assignment between incompatible types (‘{}’ and ‘{}’)",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            ), span)
                        }

                        if not .expression_is_mutable(checked_lhs) {
                            .error("Assignment to immutbale variable", span)
                        }
                    }
                    else => {}
                }
            }
            Add | Subtract | Multiply | Divide | Modulo => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format(
                        "Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ),
                    span)
                }

                type_id = lhs_type_id
            }
            else => {}
        }

        return type_id
    }

    function typecheck_statement(mut this, anon statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement => match statement {
        Expression(expr) => CheckedStatement::Expression(expr: .typecheck_expression(expr, scope_id, safety_mode))
        UnsafeBlock(parsed_block) => CheckedStatement::Block(.typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode: SafetyMode::Unsafe))
        Yield(expr) => CheckedStatement::Yield(.typecheck_expression(expr, scope_id, safety_mode))
        Return(expr) => .typecheck_return(expr, scope_id, safety_mode)
        Block(parsed_block) => .typecheck_block_statement(parsed_block, scope_id, safety_mode)
        InlineCpp(block, span) => .typecheck_inline_cpp(block, span, safety_mode)
        Defer(statement, span) => .typecheck_defer(statement, scope_id, safety_mode, span)
        Loop(parsed_block) => .typecheck_loop(parsed_block, scope_id, safety_mode)
        Try(stmt, error_name, error_span, catch_block) => .typecheck_try(stmt, error_name, error_span, catch_block, scope_id, safety_mode)
        While(guard, block) => .typecheck_while(guard, block, scope_id, safety_mode)
        Continue => CheckedStatement::Continue
        Break => CheckedStatement::Break
        VarDecl(var, init) => .typecheck_var_decl(var, init, scope_id, safety_mode)
        If(condition, then_block, else_statement) => .typecheck_if(condition, then_block, else_statement, scope_id, safety_mode)
        Garbage => CheckedStatement::Garbage
        else => {
            todo(format("typecheck_statement else: {}", statement))
            yield CheckedStatement::Garbage
        }
    }

    function typecheck_if(mut this, condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_guard = .typecheck_expression(condition, scope_id, safety_mode)
        if not .expression_type(checked_guard).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(then_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("An ‘if’ block is not allowed to yield values", then_block.find_yield_span()!)
        }

        mut checked_else: CheckedStatement? = None
        match else_statement.has_value() {
            true => {
                checked_else = .typecheck_statement(else_statement!, scope_id, safety_mode)
            }
            else => {}
        }
        return CheckedStatement::If(guard: checked_guard, then_block: checked_block, else_statement: checked_else)
    }

    function typecheck_var_decl(mut this, var: ParsedVarDecl, init: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        mut lhs = .typecheck_typename(parsed_type: var.parsed_type, scope_id)
        mut checked_expr = .typecheck_expression(expr: init, scope_id, safety_mode)
        let rhs = .expression_type(checked_expr)
        let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)

        if lhs.equals(UNKNOWN_TYPE_ID) and not rhs.equals(UNKNOWN_TYPE_ID) {
            lhs = rhs
        }

        let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type: lhs, checked_rhs: checked_expr, span: init.span())
        if promoted_rhs.has_value() {
            checked_expr = promoted_rhs!
        }

        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let optional_struct_id = .find_struct_in_prelude("Optional")

        let lhs_type = .get_type(lhs)

        match lhs_type {
            GenericInstance(id, args) => {
                if id.equals(weak_ptr_struct_id) {
                    if not var.is_mutable {
                        .error("Weak reference must be mutable", var.span)
                    }

                    if not lhs.equals(rhs) and not args[0].equals(rhs) and not rhs.equals(UNKNOWN_TYPE_ID) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs), .type_name(rhs)), .expression_span(checked_expr))
                    }
                }
                if id.equals(optional_struct_id) {
                    if not lhs.equals(rhs) and not args[0].equals(rhs) and not rhs.equals(UNKNOWN_TYPE_ID) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs), .type_name(rhs)), .expression_span(checked_expr))
                    }
                }
            }
            else => {
                if lhs_type.is_builtin() {
                    let number_constant = checked_expr.to_number_constant(program: .program)

                    mut is_rhs_zero = false
                    if number_constant.has_value() {
                        is_rhs_zero = match number_constant! {
                            Signed(value) => value == 0
                            Unsigned(value) => value == 0
                            Floating(value) => value == 0.0
                        }
                    }

                    if not (.is_numeric(lhs) and is_rhs_zero) and (.is_integer(lhs) ^ .is_integer(rhs)) {
                        .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs), .type_name(rhs)), .expression_span(checked_expr))
                        return CheckedStatement::Garbage
                    }
                }
            }
        }

        let checked_var = CheckedVariable(
            name: var.name
            type_id: lhs
            is_mutable: var.is_mutable
            definition_span: var.span
        )

        // TODO: dump type hints

        mut module = .current_module()
        let var_id = module.add_variable(checked_var)
        .add_var_to_scope(scope_id, name: var.name, var_id, span: checked_var.definition_span)
        return CheckedStatement::VarDecl(var_id, init: checked_expr)
    }

    function typecheck_while(mut this, guard: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_guard = .typecheck_expression(guard, scope_id, safety_mode)
        if not .expression_type(checked_guard).equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", guard.span())
        }

        let checked_block = .typecheck_block(block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘while’ block is not allowed to yield values", block.find_yield_span()!)
        }

        return CheckedStatement::While(guard: checked_guard, block: checked_block)
    }

    function typecheck_try(mut this, stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true)
        let checked_stmt = .typecheck_statement(stmt, scope_id, safety_mode)
        let error_struct_id = .find_struct_in_prelude("Error")
        let error_decl = CheckedVariable(
            name: error_name
            type_id: UNKNOWN_TYPE_ID
            is_mutable: false
            definition_span: error_span
        )
        mut module = .current_module()
        let error_id = module.add_variable(name: error_decl)

        let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false)
        .add_var_to_scope(scope_id: catch_scope_id, name: error_name, var_id: error_id, span: error_span)
        let checked_catch_block = .typecheck_block(catch_block, parent_scope_id: catch_scope_id, safety_mode)

        return CheckedStatement::Try(stmt: checked_stmt, error_name, catch_block: checked_catch_block)
    }

    function typecheck_loop(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘loop’ block is not allowed to yield values", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Loop(checked_block)
    }

    function typecheck_defer(mut this, statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let was_inside_defer = .inside_defer
        .inside_defer = true
        defer .inside_defer = was_inside_defer
        let checked_statement = .typecheck_statement(statement, scope_id, safety_mode)
        match checked_statement {
            Block(block) => {
                if block.yielded_type.has_value() {
                    .error("‘yield’ inside ‘defer’ is meaningless", span)
                }
            }
            else => { }
        }
        return CheckedStatement::Defer(checked_statement)
    }

    function typecheck_block_statement(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A block used as a statement cannot yield values, as the value cannot be observed in any way", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Block(checked_block)
    }

    function typecheck_inline_cpp(mut this, block: ParsedBlock, span: Span, safety_mode: SafetyMode) throws -> CheckedStatement {

            match safety_mode {
                Safe => .error("Use of inline cpp block outside of unsafe block", span)
                else => {}
            }

            mut strings: [String] = []
            for statement in block.stmts.iterator() {
                match statement {
                    ParsedStatement::Expression(expression) => {
                        match expression {
                            ParsedExpression::QuotedString(val, span) => {
                                strings.push(val)
                            }
                            else => .error("Expected block of strings", span)
                        }
                    }
                    else => {
                        .error("Expected block of strings", span)
                    }
                }
            }

            return CheckedStatement::InlineCpp(strings)
    }

    function typecheck_return(mut this, expr: ParsedExpression?, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        if not expr.has_value() {
            let none_expr: CheckedExpression? = None
            return CheckedStatement::Return(none_expr)
        }
        let checked_expr = .typecheck_expression(expr!, scope_id, safety_mode)
        return CheckedStatement::Return(checked_expr)
    }

    function typecheck_expression(mut this, anon expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression => match expr {
        Boolean(val, span) => CheckedExpression::Boolean(val, span)
        NumericConstant(val, span) => {
            // FIXME: better constant support
            yield match val {
                I8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val), span, type_id: builtin(BuiltinType::I8))
                I16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val), span, type_id: builtin(BuiltinType::I16))
                I32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val), span, type_id: builtin(BuiltinType::I32))
                I64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
                U8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val), span, type_id: builtin(BuiltinType::U8))
                U16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val), span, type_id: builtin(BuiltinType::U16))
                U32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val), span, type_id: builtin(BuiltinType::U32))
                U64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
                USize(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val), span, type_id: builtin(BuiltinType::U64))
            }
        }
        QuotedString(val, span) => CheckedExpression::QuotedString(val, span)
        Call(call, span) => .typecheck_call(call, scope_id, span, safety_mode)
        Range(from, to, span) => {
            let checked_from = .typecheck_expression(from, scope_id, safety_mode)
            let checked_to = .typecheck_expression(to, scope_id, safety_mode)

            let from_type = .expression_type(checked_from)
            let to_type = .expression_type(checked_to)

            let from_span = .expression_span(checked_from)
            let to_span = .expression_span(checked_to)

            let UNKNOWN_TYPE_ID = TypeId(module: ModuleId(id: 0), id: 0)
            let type_id = .unify(lhs: from_type, lhs_span: from_span, rhs: to_type, rhs_span: from_span) ?? UNKNOWN_TYPE_ID

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id)
        }
        BinaryOp(lhs, op, rhs, span) => {
            let checked_lhs = .typecheck_expression(lhs, scope_id, safety_mode)
            mut checked_rhs = .typecheck_expression(rhs, scope_id, safety_mode)

            let lhs_type = .expression_type(checked_lhs)

            let promoted_rhs = .try_to_promote_constant_expr_to_type(lhs_type, checked_rhs, span)
            if promoted_rhs.has_value() {
                checked_rhs = promoted_rhs!
            }

            let output_type = .typecheck_binary_operation(checked_lhs, op, checked_rhs, scope_id, span)

            yield CheckedExpression::BinaryOp(lhs: checked_lhs, op, rhs: checked_rhs, span, type_id: output_type)
        }
        OptionalNone(span) => CheckedExpression::OptionalNone(span, type_id: .new_inference())
        OptionalSome(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode)
            let type_id = .expression_type(checked_expr)
            let optional_struct_id = .find_struct_in_prelude("Optional")
            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
            let optional_type_id = .find_or_add_type_id(optional_type)
            yield CheckedExpression::OptionalSome(expr: checked_expr, span, type_id: optional_type_id)
        }
        Var(name, span) => {
            let var = .find_var_in_scope(scope_id, var: name)
            return match var.has_value() { // FIXME: this wants to be a match on Optional instead of boolean
                true => CheckedExpression::Var(var: var!, span)
                else => {
                    .error(format("Variable '{}' not found", name), span)
                    yield CheckedExpression::Garbage(span)
                }
            }
        }
        else => {
            panic("not complete")

            yield CheckedExpression::Boolean(val: false, span: Span(start: 0, end: 0))
        }
    }

    function find_var_in_scope(mut this, scope_id: ScopeId, var: String) -> CheckedVariable? {
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            for existing_var in scope.vars.iterator() {
                if existing_var.0 == var {
                    return .program.get_variable(existing_var.1)
                }
            }
            if not scope.parent.has_value() {
                break
            }
            current_scope_id = scope.parent!
        }
        return None
    }

    function typecheck_call(mut this, call: ParsedCall, scope_id: ScopeId, span: Span, safety_mode: SafetyMode) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = builtin(BuiltinType::Void)
        mut callee_throws = false

        match call.name {
            "print" | "println" | "eprintln" | "format" => {
                for arg in call.args.iterator() {
                    let checked_arg = .typecheck_expression(expr: arg.1, scope_id, safety_mode)

                    args.push((call.name, checked_arg))
                }
            }
            else => {
                for arg in call.args.iterator() {

                    // FIXME: Check argument labels

                    // FIXME: Check argument count

                    let checked_arg = .typecheck_expression(expr: arg.1, scope_id, safety_mode)

                    args.push((call.name, checked_arg))
                }
            }
        }

        let none_function_id: FunctionId? = None
        return CheckedExpression::Call(call: CheckedCall(namespace_: [], name: call.name, args, function_id: none_function_id, return_type, callee_throws), span, type_id: return_type)
    }
}
