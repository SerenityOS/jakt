// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
// Copyright (c) 2022, Jesús Lapastora <cyber.gsuscode@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause

import error { JaktError, print_error }
import lexer { Lexer }
import parser { Parser, BinaryOperator, DefinitionLinkage, UnaryOperator,
                FunctionLinkage, FunctionType, NumericConstant, ParsedBlock, ParsedCall,
                ParsedExpression, ParsedFunction, ParsedNamespace, ParsedModuleImport,
                ParsedExternImport, ParsedType, ParsedStatement, ParsedVarDecl, RecordType,
                ParsedRecord, ParsedField, TypeCast, EnumVariantPatternArgument,
                ParsedMatchBody, ParsedMatchCase, Visibility, ParsedParameter, ParsedCapture,
                ParsedMethod, ParsedTrait }
import types {
    BlockControlFlow, BuiltinType, CheckedBlock, CheckedCall, CheckedCapture, CheckedEnum, CheckedEnumVariant,
    CheckedEnumVariantBinding, CheckedExpression, CheckedFunction, CheckedField, FunctionGenerics, CheckedMatchBody, CheckedMatchCase,
    CheckedNamespace, CheckedNumericConstant, CheckedParameter, CheckedProgram, CheckedStatement, CheckedStruct,
    CheckedTypeCast, CheckedUnaryOperator, CheckedVariable, CheckedVisibility, EnumId, FieldRecord, FunctionGenericParameter, CheckedTrait,
    FunctionId, LoadedModule, Module, ModuleId, NumberConstant, ResolvedNamespace, SafetyMode, Scope, ScopeId, StructId,
    GenericInferences, StructOrEnumId, Type, TypeId, TraitId, VarId, Value, MaybeResolvedScope,
    builtin, never_type_id, unknown_type_id, void_type_id,
}
import types
import utility { FileId, Span, escape_for_quotes, join, panic, todo }
import path { Path }
import compiler { Compiler }
import interpreter { Interpreter, InterpreterScope, ExecutionResult, value_to_checked_expression }

struct Typechecker {
    compiler: Compiler
    program: CheckedProgram
    current_module_id: ModuleId
    current_struct_type_id: TypeId?
    current_function_id: FunctionId?
    inside_defer: bool
    checkidx: usize
    ignore_errors: bool
    dump_type_hints: bool
    dump_try_hints: bool
    lambda_count: u64
    generic_inferences: GenericInferences

    function type_name(this, anon type_id: TypeId) throws => .program.type_name(type_id)

    function dump_type_hint(this, type_id: TypeId, span: Span) throws {
        println("{{\"type\":\"hint\",\"file_id\":{},\"position\":{},\"typename\":\"{}\"}}"
                span.file_id.id, span.end, .type_name(type_id))
    }

    function dump_try_hint( this, span: Span) throws {
        println("{{\"type\":\"try\",\"file_id\":{},\"position\":{}}}"
                span.file_id.id, span.start)
    }

    function typecheck(mut compiler: Compiler, parsed_namespace: ParsedNamespace) throws -> CheckedProgram {

        let input_file = compiler.current_file

        if not input_file.has_value() {
            compiler.panic("trying to typecheck a non-existant file")
        }

        let placeholder_module_id = ModuleId(id: 0)

        mut typechecker = Typechecker(
            compiler
            program: CheckedProgram(compiler, modules: [], loaded_modules: [:]),
            current_module_id: placeholder_module_id,
            current_struct_type_id: TypeId::none()
            current_function_id: None
            inside_defer: false
            checkidx: 0uz
            ignore_errors: false
            dump_type_hints: compiler.dump_type_hints
            dump_try_hints: compiler.dump_try_hints
            lambda_count: 0
            generic_inferences: GenericInferences(values: [:])
        )

        typechecker.include_prelude()

        let root_module_name = "Root Module"
        let root_module_id = typechecker.create_module(name: root_module_name, is_root: true)
        typechecker.current_module_id = root_module_id
        compiler.set_current_file(input_file!)
        typechecker.program.set_loaded_module(
            module_name: root_module_name
            loaded_module: LoadedModule(
                module_id: root_module_id
                file_id: input_file!
            )
        )

        let PRELUDE_SCOPE_ID: ScopeId = typechecker.prelude_scope_id()
        let root_scope_id = typechecker.create_scope(parent_scope_id: PRELUDE_SCOPE_ID, can_throw: false, debug_name: "root")
        typechecker.typecheck_module(parsed_namespace, scope_id: root_scope_id)

        return typechecker.program
    }

    function get_function(this, anon id: FunctionId) => .program.get_function(id)
    function get_variable(this, anon id: VarId) => .program.get_variable(id)
    function get_type(this, anon id: TypeId) => .program.get_type(id)
    function get_enum(this, anon id: EnumId) => .program.get_enum(id)
    function get_struct(this, anon id: StructId) => .program.get_struct(id)
    function get_scope(this, anon id: ScopeId) throws => .program.get_scope(id)
    function find_var_in_scope(this, scope_id: ScopeId, var: String) throws -> CheckedVariable? => .program.find_var_in_scope(scope_id, var)

    function lookup_struct_field(this, struct_id: StructId, name: String) throws -> FieldRecord? {
        mut chain: [StructId] = []
        mut current = Some(struct_id)

        chain.push(current!)

        while current.has_value() {
            let parent = .get_struct(current!).super_struct_id
            if parent.has_value() {
                chain.push(parent!)
            }
            current = parent
        }

        for current_struct_id in chain.iterator() {
            for field in .get_struct(current_struct_id).fields.iterator() {
                let variable = .get_variable(field.variable_id)
                if variable.name == name {
                    return FieldRecord(struct_id: current_struct_id, field_id: field.variable_id)
                }
            }
        }

        return None
    }

    function find_comptime_binding_in_scope(this, scope_id: ScopeId, anon name: String) throws -> Value? => .program.find_comptime_binding_in_scope(scope_id, name)

    function get_root_path(this) throws -> Path {
        let root_module = .program.get_loaded_module("Root Module")
        if root_module.has_value() {
            let file_id = root_module!.file_id
            return .compiler.get_file_path(file_id)!
        }

        return Path::from_string(".")
    }
    function prelude_scope_id(this) -> ScopeId => .program.prelude_scope_id()
    function root_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 1), id: 0)

    function current_module(this) => .program.get_module(.current_module_id)

    public function scope_can_access(this, accessor: ScopeId, accessee: ScopeId) throws -> bool {
        if accessor.equals(accessee) {
            return true
        }
        mut accessor_scope = .get_scope(accessor)
        while accessor_scope.parent.has_value() {
            let parent = accessor_scope.parent!
            if parent.equals(accessee) {
                return true
            }
            accessor_scope = .get_scope(parent)
        }
        return false
    }

    function error(mut this, anon message: String, anon span: Span) throws {
        if not .ignore_errors {
            .compiler.errors.push(JaktError::Message(message, span))
        }
    }

    function error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) throws {
        if not .ignore_errors {
            .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
        }
    }

    function is_integer(this, anon type_id: TypeId) => .program.is_integer(type_id)
    function is_floating(this, anon type_id: TypeId) => .program.is_floating(type_id)
    function is_numeric(this, anon type_id: TypeId) => .program.is_numeric(type_id)

    function create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool, debug_name: String) throws -> ScopeId => .program.create_scope(parent_scope_id, can_throw, debug_name, module_id: .current_module_id)

    function create_module(mut this, name: String, is_root: bool, path: String? = None) throws -> ModuleId {
        let new_id = .program.modules.size()
        let module_id = ModuleId(id: new_id)
        let module = Module(
            id: module_id,
            name: name,
            functions: [],
            structures: [],
            enums: [],
            scopes: [],
            types: [ // FIXME: use general builtin types array
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
                Type::Unknown,
                Type::Never
            ],
            traits: [],
            variables: [],
            imports: [],
            resolved_import_path: path ?? .compiler.current_file_path()!.to_string(),
            is_root: is_root,
        )
        .program.modules.push(module)

        return module_id
    }

    private comptime get_prelude_contents() throws -> [u8] {
        // FIXME: Don't hardcode the relative runtime path.
        mut file = File::open_for_reading("../runtime/prelude.jakt")
        return file.read_all()
    }

    function include_prelude(mut this) throws {
        let module_name = "__prelude__"
        let file_name = Path::from_string(module_name)
        let file_contents = get_prelude_contents()

        let old_file_id = .compiler.current_file
        let old_file_contents = .compiler.current_file_contents
        defer {
            .compiler.current_file = old_file_id
            .compiler.current_file_contents = old_file_contents
        }

        let file_id = .compiler.get_file_id_or_register(file_name)

        // We manually set the compiler's current_file and current_file_contents fields here
        // for now, because this is a special case.

        .compiler.current_file = file_id
        .compiler.current_file_contents = file_contents

        // we are using the root module (so it doesn't have to be optional)
        let prelude_module_id = .create_module(name: module_name, is_root: false)
        .current_module_id = prelude_module_id
        .program.set_loaded_module(
            module_name
            loaded_module: LoadedModule(
                module_id: prelude_module_id
                file_id
         ))

        let prelude_scope_id = .create_scope(
            parent_scope_id: None
            can_throw: false
            debug_name: "prelude"
        )

        let tokens = Lexer::lex(compiler: .compiler)

        if .compiler.dump_lexer {
            for token in tokens.iterator() {
                println("token: {}", token)
            }
        }

        let parsed_namespace = Parser::parse(compiler: .compiler, tokens)

        if .compiler.dump_parser {
            println("{:#}", parsed_namespace)
        }

        .compiler.dbg_println(format("before typechecking parsed prelude, modules ‘{}’", .program.modules))
        .typecheck_module(
            parsed_namespace
            scope_id: prelude_scope_id
        )
    }

    function lex_and_parse_file_contents(mut this, file_id: FileId) throws -> ParsedNamespace? {
        let old_file_state = .compiler.current_file_state()

        if not .compiler.set_current_file(file_id) {
            return None
        }
        defer .compiler.restore_file_state(old_file_state)

        let tokens = Lexer::lex(compiler: .compiler)

        if .compiler.dump_lexer {
            for token in tokens.iterator() {
                println("token: {}", token)
            }
        }

        let parsed_namespace = Parser::parse(compiler: .compiler, tokens)

        if .compiler.dump_parser {
            println("{:#}", parsed_namespace)
        }

        return parsed_namespace
    }

    function find_struct_in_prelude(this, anon name: String) throws -> StructId =>
        .program.find_struct_in_prelude(name)

    function find_type_in_prelude(this, anon name: String) throws -> TypeId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let type_id = .find_type_in_scope(scope_id, name)
        if type_id.has_value() {
            return type_id.value()
        }
        .compiler.panic(format("internal error: {} builtin definition not found", name))
    }

    function unify(mut this, lhs: TypeId, lhs_span: Span, rhs: TypeId, rhs_span: Span) throws -> TypeId? {
        if not .check_types_for_compat(lhs_type_id: lhs, rhs_type_id: rhs, generic_inferences: &mut .generic_inferences, span: lhs_span) {
            return None
        }

        return .substitute_typevars_in_type(type_id: lhs, generic_inferences: .generic_inferences)
    }

    function unify_with_type(mut this, found_type: TypeId, expected_type: TypeId?, span: Span) throws -> TypeId {
        if not expected_type.has_value() {
            return found_type
        }
        if expected_type!.equals(unknown_type_id()) {
            return found_type
        }
        if .check_types_for_compat(lhs_type_id: expected_type!, rhs_type_id: found_type, generic_inferences: &mut .generic_inferences, span) {
            return found_type
        }

        return .substitute_typevars_in_type(type_id: found_type, generic_inferences: .generic_inferences)
    }

    function find_or_add_type_id(mut this, anon type: Type) throws -> TypeId => .program.find_or_add_type_id(type, module_id: .current_module_id)

    function find_type_in_scope(this, scope_id: ScopeId, name: String) throws -> TypeId? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_type = scope.types.get(name)
            if maybe_type.has_value() {
                return maybe_type
            }
            for child_id in scope.children.iterator() {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    let maybe_type = child_scope.types.get(name)
                    if maybe_type.has_value() {
                        return maybe_type
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }

    function find_type_scope(this, scope_id: ScopeId, name: String) throws -> (TypeId, ScopeId)? {
        mut current = scope_id

        loop {
            let scope = .get_scope(current)
            let maybe_type = scope.types.get(name)
            if maybe_type.has_value() {
                return (maybe_type!, current)
            }
            for child_id in scope.children.iterator() {
                let child_scope = .get_scope(id: child_id)
                if not child_scope.namespace_name.has_value() {
                    let maybe_type = child_scope.types.get(name)
                    if maybe_type.has_value() {
                        return (maybe_type!, child_id)
                    }
                }
            }

            if scope.parent.has_value() {
                current = scope.parent.value()
            } else {
                break
            }
        }

        return None
    }


    // Find the namespace in the current scope, or one of its parents,
    // and whether the found scope was an import.
    function find_namespace_in_scope(this, scope_id: ScopeId, name: String) throws -> (ScopeId, bool)? {
        return .program.find_namespace_in_scope(scope_id, name)
    }

    function add_struct_to_scope(mut this, scope_id: ScopeId, name: String, struct_id: StructId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_scope_id = scope.structs.get(name)
        if maybe_scope_id.has_value() {
            let existing_struct_id = maybe_scope_id!
            let definition_span = .get_struct(existing_struct_id).name_span
            .error_with_hint(
                format("redefinition of struct/class {}", name)
                span
                format("struct/class {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.structs.set(key: name, value: struct_id)
        return true
    }

    function add_enum_to_scope(mut this, scope_id: ScopeId, name: String, enum_id: EnumId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_enum_id = scope.enums.get(name)
        if maybe_enum_id.has_value() {
            let existing_enum_id = maybe_enum_id!
            let definition_span = .get_enum(existing_enum_id).name_span

            .error_with_hint(
                format("redefinition of enum {}", name)
                span
                format("enum {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.enums.set(key: name, value: enum_id)
        return true
    }

    function add_type_to_scope(mut this, scope_id: ScopeId, type_name: String, type_id: TypeId, span: Span) throws -> bool {
        mut scope = .get_scope(id: scope_id)
        let found_type_id = scope.types.get(type_name)
        if found_type_id.has_value() and not found_type_id!.equals(type_id) {
            // FIXME: Show hint of the original definition, once we store the name span.
            .error(
                format("Redefinition of type ‘{}’", type_name)
                span
            )
            return false
        }
        scope.types.set(key: type_name, value: type_id)
        return true
    }

    function add_function_to_scope(mut this, parent_scope_id: ScopeId, name: String, function_id: FunctionId, span: Span) throws -> bool {
        mut scope = .get_scope(id: parent_scope_id)
        for existing_function in scope.functions.iterator() {
            if name == existing_function.0 {
                let function_ = .get_function(existing_function.1)
                .error_with_hint(message: format("Redefinition of function ‘{}’", name), span, hint: "previous definition here", hint_span: function_.name_span)
                return false
            }
        }
        scope.functions.set(key: name, value: function_id)
        return true
    }

    function add_var_to_scope(mut this, scope_id: ScopeId, name: String, var_id: VarId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        for existing_var in scope.vars.iterator() {
            if name == existing_var.0 {
                let variable_ = .get_variable(existing_var.1)
                .error_with_hint(message: format("Redefinition of variable ‘{}’", name), span, hint: "previous definition here", hint_span: variable_.definition_span)
            }
        }
        scope.vars.set(key: name, value: var_id)
        return true
    }

    function add_comptime_binding_to_scope(mut this, scope_id: ScopeId, name: String, value: Value, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        for existing in scope.comptime_bindings.iterator() {
            if name == existing.0 {
                .error_with_hint(
                    message: format("Redefinition of comptime variable ‘{}’", name)
                    span
                    hint: "previous definition here"
                    hint_span: existing.1.span)
            }
        }
        scope.comptime_bindings.set(key: name, value)
        return true
    }

    function find_function_in_scope(this, parent_scope_id: ScopeId, function_name: String) throws -> FunctionId? {
        return .program.find_function_in_scope(parent_scope_id, function_name)
    }

    function find_struct_in_scope(this, scope_id: ScopeId, name: String) throws -> StructId? =>
        .program.find_struct_in_scope(scope_id, name)

    function typecheck_module(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        .typecheck_namespace_imports(parsed_namespace, scope_id)
        .typecheck_namespace_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_fields(parsed_namespace, scope_id)
        .typecheck_namespace_constructors(parsed_namespace, scope_id)
        .typecheck_namespace_function_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_declarations(parsed_namespace, scope_id)
    }

    function typecheck_visibility(mut this, visibility: Visibility, scope_id: ScopeId) throws -> CheckedVisibility {
        return match visibility {
            Private => CheckedVisibility::Private
            Public => CheckedVisibility::Public
            Restricted(whitelist, span) => {
                mut restricted_scopes: [MaybeResolvedScope] = []
                for entry in whitelist.iterator() {
                    mut parent_scope = MaybeResolvedScope::Resolved(scope_id)
                    for ns in entry.namespace_.iterator() {
                        parent_scope = MaybeResolvedScope::Unresolved(parent_scope, relative_name: ns)
                    }

                    mut unresolved = MaybeResolvedScope::Unresolved(
                        parent_scope
                        relative_name: entry.name
                    )

                    restricted_scopes.push(unresolved.try_resolve(program: .program))
                }

                yield CheckedVisibility::Restricted(scopes: restricted_scopes, span)
            }
        }
    }

    function typecheck_namespace_fields(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_fields(parsed_namespace: child_namespace,
                scope_id: child_namespace_scope_id)
        }
        for record in parsed_namespace.records.iterator() {
            if record.record_type is Struct or record.record_type is Class {
                let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                if not struct_id.has_value() {
                    .compiler.panic("can't find previously added struct")
                }
                .typecheck_struct_fields(record, struct_id: struct_id!)
            }
        }
    }

    function typecheck_struct_fields(mut this, record: ParsedRecord, struct_id: StructId) throws {
        mut structure = .get_struct(struct_id)

        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let parsed_fields = match record.record_type {
            Struct(fields) => fields
            Class(fields) => fields
            else => {
                .compiler.panic("typecheck_struct_fields cannot handle non-structs")
            }
        }

        for unchecked_member in parsed_fields.iterator() {
            let parsed_var_decl = unchecked_member.var_decl
            let checked_member_type = .typecheck_typename(parsed_type: parsed_var_decl.parsed_type, scope_id: checked_struct_scope_id, name: parsed_var_decl.name)

            .check_that_type_doesnt_contain_reference(type_id: checked_member_type, span: parsed_var_decl.parsed_type.span())

            mut module = .current_module()
            let variable_id = module.add_variable(checked_variable: CheckedVariable(
                name: parsed_var_decl.name
                type_id: checked_member_type
                is_mutable: parsed_var_decl.is_mutable
                definition_span: parsed_var_decl.span
                type_span: None
                visibility: .typecheck_visibility(visibility: unchecked_member.visibility, scope_id: checked_struct_scope_id)
            ))
            mut default_value: CheckedExpression? = None
            if unchecked_member.default_value.has_value() {
                default_value = .typecheck_expression(
                    unchecked_member.default_value!,
                    scope_id: checked_struct_scope_id,
                    safety_mode: SafetyMode::Safe,
                    type_hint: None
                )
            }
            structure.fields.push(CheckedField(variable_id, default_value))
        }
    }

    function typecheck_module_import(mut this, anon import_: ParsedModuleImport, scope_id: ScopeId) throws {
        // load the module if not present
        // FIXME: use match
        let module_names_and_spans = match import_.module_name {
            Literal(name, span) => Some([(name, span)])
            Comptime(expression) => {
                mut interpreter = Interpreter::create(compiler: .compiler, program: .program, spans: [])
                mut eval_scope = InterpreterScope::from_runtime_scope(scope_id, program: .program)
                let exec_scope = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "comptime-import")

                let result = interpreter.execute_expression(
                    expr: .typecheck_expression(
                        expr: expression
                        scope_id: exec_scope
                        safety_mode: SafetyMode::Safe,
                        type_hint: None
                    )
                    scope: eval_scope
                )
                yield match result {
                    Return | Yield | Continue | Break => {
                        .error_with_hint(
                            message: "module name must evalute to a string literal or an array of strings"
                            span: expression.span()
                            hint: "this expression evaluates to an invalid value"
                            hint_span: expression.span()
                        )
                        yield None
                    }
                    Throw(error) => {
                        .error_with_hint(
                            message: "module name must evalute to a string literal or an array of strings"
                            span: expression.span()
                            hint: format("this expression threw an error: {}", error)
                            hint_span: expression.span()
                        )
                        yield None
                    }
                    JustValue(value) => match value.impl {
                        JaktString(string) => Some([(string, value.span)])
                        JaktArray(values) => {
                            if values.is_empty() {
                                .error_with_hint(
                                    message: "module name must evalute to a string literal or an array of strings"
                                    span: expression.span()
                                    hint: "this expression evaluates to an empty array"
                                    hint_span: expression.span()
                                )
                            }

                            mut result: [(String, Span)] = []
                            for value in values.iterator() {
                                match value.impl {
                                    JaktString(string) => result.push((string, value.span))
                                    else => {
                                        .error_with_hint(
                                            message: "module name must evalute to a string literal or an array of strings"
                                            span: value.span
                                            hint: "this expression evaluates to an invalid value"
                                            hint_span: value.span
                                        )
                                    }
                                }
                            }
                            yield Some(result)
                        }
                        else => {
                            .error_with_hint(
                                message: "module name must evalute to a string literal"
                                span: expression.span()
                                hint: "this expression evaluates to a non-string value"
                                hint_span: expression.span()
                            )
                            yield None
                        }
                    }
                }
            }
        }

        if not module_names_and_spans.has_value() { return }

        mut module_name_and_span: (String, Span)? = None
        mut names: [String] = []
        for name_and_span in module_names_and_spans!.iterator() {
            names.push(name_and_span.0)

            mut maybe_loaded_module = .program.get_loaded_module(name_and_span.0)
            if not maybe_loaded_module.has_value() {
                let maybe_file_name = .compiler.search_for_path(name_and_span.0)
                let file_name = match maybe_file_name.has_value() {
                    true => maybe_file_name!
                    else => .get_root_path().parent().join(name_and_span.0).replace_extension("jakt")
                }
                if File::exists(file_name.to_string()) {
                    module_name_and_span = name_and_span
                    break
                }
            } else {
                module_name_and_span = name_and_span
                break
            }
        }

        if not module_name_and_span.has_value() {
            .error(
                message: format("No module in module set {{{}}} was found", join(names, separator: ", "))
                span: import_.module_name.span()
            )
            return
        }

        let (module_name, module_span) = module_name_and_span!

        mut imported_module_id = ModuleId(id: 0)
        mut maybe_loaded_module = .program.get_loaded_module(module_name)
        if not maybe_loaded_module.has_value() {
            let maybe_file_name = .compiler.search_for_path(module_name)
            let file_name = match maybe_file_name.has_value() {
                true => maybe_file_name!
                else => .get_root_path().parent().join(module_name).replace_extension("jakt")
            }

            let file_id = .compiler.get_file_id_or_register(file_name)

            let parsed_namespace = .lex_and_parse_file_contents(file_id)

            if not parsed_namespace.has_value() {
                .error(
                    format("Module '{}' not found", module_name)
                    module_span
                )
                return
            }

            let original_current_module_id = .current_module_id

            let sanitized_module_name = module_name.replace(replace: ":", with: "_")
            imported_module_id = .create_module(name: sanitized_module_name, is_root: false, path: file_name.to_string())
            .program.set_loaded_module(
                module_name: sanitized_module_name
                loaded_module: LoadedModule(
                    module_id: imported_module_id
                    file_id
                ))

            .current_module_id = imported_module_id

            let imported_scope_id = .create_scope(parent_scope_id: .root_scope_id(), can_throw: false, debug_name: format("module({})", sanitized_module_name))
            .typecheck_module(parsed_namespace: parsed_namespace!, scope_id: imported_scope_id)

            .current_module_id = original_current_module_id
        } else {
            imported_module_id = maybe_loaded_module!.module_id
        }

        mut current_module_imports = .current_module().imports
        current_module_imports.push(imported_module_id)

        if import_.import_list.is_empty() {
            // import everything into scope
            mut scope_imports = .get_scope(scope_id).imports
            mut import_name = module_name
            if import_.alias_name.has_value() {
                import_name = import_.alias_name!.literal_name()
            }
            scope_imports.set(
                key: import_name
                value: imported_module_id) // FIXME: Add span and should this be alias span if there is an alias?
        } else {
            let import_scope_id = ScopeId(module_id: imported_module_id, id: 0)
            for imported_name in import_.import_list.iterator() {
                mut found = false
                // if it is a function, add function to scope
                let maybe_function_id = .find_function_in_scope(
                    parent_scope_id: import_scope_id
                    function_name: imported_name.literal_name()
                )
                    if maybe_function_id.has_value() {
                        found = true
                        // NOTE: what should we do if this returns false? error is already created in the function itself and rust compiler goes on
                        .add_function_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.literal_name()
                            function_id: maybe_function_id!
                            span: imported_name.span()
                        )
                    }

                // if it is an enum, add enum to scope
                let maybe_enum_id = .program.find_enum_in_scope(
                    scope_id: import_scope_id
                    name: imported_name.literal_name()
                )
                    if maybe_enum_id.has_value() {
                        found = true
                        // NOTE: what should we do if this returns false? error is already created in the enum itself and rust compiler goes on
                        .add_enum_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.literal_name()
                            enum_id: maybe_enum_id!
                            span: imported_name.span()
                        )
                    }

                // if it is a type, add type to scope
                let maybe_type_id = .find_type_in_scope(
                    scope_id: import_scope_id
                    name: imported_name.literal_name()
                )
                    if maybe_type_id.has_value() {
                        found = true
                        // NOTE: what should we do if this returns false? error is already created in the type itself and rust compiler goes on
                        .add_type_to_scope(
                            parent_scope_id: scope_id
                            type_name: imported_name.literal_name()
                            type_id: maybe_type_id!
                            span: imported_name.span()
                        )
                    }

                // if it is a struct, add struct to scope
                let maybe_struct_id = .find_struct_in_scope(
                    scope_id: import_scope_id
                    name: imported_name.literal_name()
                )
                    if maybe_struct_id.has_value() {
                        found = true
                        // NOTE: what should we do if this returns false? error is already created in the struct itself and rust compiler goes on
                        .add_struct_to_scope(
                            parent_scope_id: scope_id
                            name: imported_name.literal_name()
                            struct_id: maybe_struct_id!
                            span: imported_name.span()
                        )
                    }

                if not found {
                    .error(
                        format("Imported name '{}' not found in module '{}'", imported_name.literal_name(), module_name)
                        imported_name.span()
                    )
                }
            }
        }
    }

    function typecheck_extern_import(mut this, anon import_: ParsedExternImport, scope_id: ScopeId) throws {
        for f in import_.assigned_namespace.functions.iterator() {
            if not f.linkage is External {
                .error("Expected all functions in an `import extern` to be be external", f.name_span)
            }

            if import_.is_c and not f.generic_parameters.is_empty() {
                .error_with_hint(
                    format("imported function '{}' is declared to have C linkage, but is generic",f.name)
                    f.name_span
                    "this function may not be generic"
                    f.name_span)
            }

            if not f.block.stmts.is_empty() {
                .error("imported extern function is not allowed to have a body"
                        f.name_span)
            }
        }

        for record in import_.assigned_namespace.records.iterator() {
            if not record.definition_linkage is External {
                .error("Expected all records in an `import extern` to be external"
                        record.name_span)
            }
            if import_.is_c and not record.generic_parameters.is_empty() {
                .error_with_hint(
                    format("imported {} '{}' is declared to have C linkage, but is generic",
                        record.record_type.record_type_name()
                        record.name)
                    record.name_span,
                    format("this {} may not be generic", record.record_type.record_type_name())
                    record.name_span)
            }
        }
    }

    function typecheck_namespace_imports(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for module_import in parsed_namespace.module_imports.iterator() {
            .typecheck_module_import(module_import, scope_id)
        }

        for extern_import in parsed_namespace.extern_imports.iterator() {
            .typecheck_extern_import(extern_import, scope_id)
        }
    }

    function typecheck_namespace_constructors(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_constructors(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id)
        }
        for record in parsed_namespace.records.iterator() {
            match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        .compiler.panic("can't find previously added struct")
                    }
                    .typecheck_struct_constructor(parsed_record: record, struct_id: struct_id!, scope_id)
                }
                SumEnum | ValueEnum => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        .compiler.panic("can't find previously added enum")
                    }
                    .typecheck_enum_constructor(parsed_record: record, enum_id: enum_id!, parent_scope_id: scope_id)
                }
                else => {}
            }
        }
    }

    function typecheck_namespace_function_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_function_predecl(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id)
        }

        for fun in parsed_namespace.functions.iterator() {
            .typecheck_function_predecl(parsed_function: fun, parent_scope_id: scope_id, this_arg_type_id: None)
        }
    }

    function typecheck_namespace_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let module_struct_len = .current_module().structures.size()
        let module_enum_len = .current_module().enums.size()

        // 1. Initialize structs
        mut struct_index: usize = 0
        mut enum_index: usize = 0
        for parsed_record in parsed_namespace.records.iterator() {
            match parsed_record.record_type {
                Struct | Class => { .typecheck_struct_predecl_initial(parsed_record, struct_index: struct_index++, module_struct_len, scope_id) }
                SumEnum | ValueEnum => { .typecheck_enum_predecl_initial(parsed_record, enum_index: enum_index++, module_enum_len, scope_id) }
                Garbage => {
                    // NOTE: We've already emitted a parse error about this, no need for a separate type error.
                }
            }
        }

        // 2. Typecheck subnamespaces
        for namespace_ in parsed_namespace.namespaces.iterator() {
            // Find all predeclarations in namespaces that are children of this namespace
            mut debug_name = "namespace("
            if namespace_.name.has_value() {
                debug_name += namespace_.name!
            } else {
                debug_name += "unnamed-namespace"
            }
            debug_name += ")"
            let namespace_scope_id = .create_scope(
                parent_scope_id: scope_id
                can_throw: false
                debug_name)
            mut child_scope = .get_scope(namespace_scope_id)
            child_scope.namespace_name = namespace_.name
            child_scope.import_path_if_extern = namespace_.import_path_if_extern
            child_scope.before_extern_include = namespace_.generating_import_extern_before_include
            child_scope.after_extern_include = namespace_.generating_import_extern_after_include

            mut parent_scope = .get_scope(scope_id)
            parent_scope.children.push(namespace_scope_id)
            .typecheck_namespace_predecl(parsed_namespace: namespace_, scope_id: namespace_scope_id)
        }

        // 3. Register traits
        for parsed_trait in parsed_namespace.traits.iterator() {
            .typecheck_trait_predecl(parsed_trait, scope_id)
        }

        // 4. Typecheck struct predeclaration
        struct_index = 0
        enum_index = 0
        for parsed_record in parsed_namespace.records.iterator() {
            let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
            match parsed_record.record_type {
                Struct | Class => {
                    .typecheck_struct_predecl(parsed_record, struct_id, scope_id)
                    struct_index++
                }
                SumEnum | ValueEnum => {
                    let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
                    .typecheck_enum_predecl(parsed_record, enum_id, scope_id)
                    enum_index++
                }
                Garbage => {
                    // NOTE: The parser has already complained about this, so we can just ignore it.
                }
            }
        }
    }

    function typecheck_trait_predecl(mut this, parsed_trait: ParsedTrait, scope_id: ScopeId) throws {
        mut checked_trait = CheckedTrait(
            name: parsed_trait.name,
            name_span: parsed_trait.name_span,
            methods: [:])

        let trait_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("trait({})", parsed_trait.name))

        // even though traits aren't types per-se, they represent the type that would implement the trait. So they have a type ID.
        let trait_id = TraitId(
            module: .current_module_id
            id: .program.modules[.current_module_id.id].traits.size())



        let trait_type_id = .find_or_add_type_id(Type::Trait(trait_id))

        // register the trait
        mut scope = .get_scope(scope_id)
        scope.types.set(parsed_trait.name, trait_type_id)

        for parsed_function in parsed_trait.methods.iterator() {
            let method_scope_id = .create_scope(parent_scope_id: trait_scope_id, can_throw: parsed_function.can_throw, debug_name: format("trait-method({}::{})", parsed_trait.name, parsed_function.name))

            let function_id = .program.get_module(.current_module_id).next_function_id()

            // even though traits aren't types per-se, they act like a generic variable, since
            // they represent the type that implements said trait
            .typecheck_function_predecl(parsed_function, parent_scope_id: trait_scope_id, this_arg_type_id: None)

            checked_trait.methods.set(parsed_function.name, function_id)

        }

        .program.modules[.current_module_id.id].traits.push(checked_trait)

    }

    function typecheck_enum_predecl_initial(mut this, parsed_record: ParsedRecord, enum_index: usize, module_enum_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
        mut module = .current_module()
        module.types.push(Type::Enum(enum_id))

        let enum_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: enum_type_id, span: parsed_record.name_span)

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }
        // Add a placeholder entry, this will be replaced later.
        module.enums.push(CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            fields: []
            scope_id: .prelude_scope_id()
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id: enum_type_id
            type_id: enum_type_id
            is_boxed
        ))
    }

    function typecheck_enum_predecl(mut this, parsed_record: ParsedRecord, enum_id: EnumId, scope_id: ScopeId) throws {
        let enum_type_id = .find_or_add_type_id(type: Type::Enum(enum_id))

        let enum_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("enum({})", parsed_record.name))

        .add_enum_to_scope(scope_id, name: parsed_record.name, enum_id, span: parsed_record.name_span)

        let underlying_type_id = match parsed_record.record_type {
            ValueEnum(underlying_type) => .typecheck_typename(parsed_type: underlying_type, scope_id, name: None)
            else => builtin(BuiltinType::Void)
        }

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }

        mut checked_fields: [CheckedField] = []
        mut seen_fields: {String} = {}
        if parsed_record.record_type is SumEnum(fields) {
            for field in fields.iterator() {
                let var_decl = field.var_decl
                if seen_fields.contains(var_decl.name) {
                    .error(format("Field '{}' is defined more than once", var_decl.name), var_decl.span)
                    continue
                }
                seen_fields.add(var_decl.name)
                let type_id = .typecheck_typename(parsed_type: var_decl.parsed_type, scope_id: enum_scope_id, name: var_decl.name)
                let checked_var = CheckedVariable(
                    name: var_decl.name
                    type_id
                    is_mutable: var_decl.is_mutable
                    definition_span: var_decl.span
                    type_span: var_decl.parsed_type.span()
                    visibility: .typecheck_visibility(visibility: field.visibility, scope_id: enum_scope_id)
                )
                mut default_value: CheckedExpression? = None
                if field.default_value.has_value() {
                    default_value = .typecheck_expression(
                        expr: field.default_value!
                        scope_id: enum_scope_id
                        safety_mode: SafetyMode::Safe
                        type_hint: type_id
                    )
                }

                if .dump_type_hints and var_decl.parsed_type is Empty {
                    .dump_type_hint(type_id, span: var_decl.span)
                }

                mut module = .current_module()
                let variable_id = module.add_variable(checked_var)
                checked_fields.push(CheckedField(variable_id, default_value))
            }
        }

        mut module = .current_module()
        module.enums[enum_id.id] = CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            variants: []
            fields: checked_fields
            scope_id: enum_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id
            type_id: enum_type_id
            is_boxed
        )

        mut generic_parameters: [TypeId] = module.enums[enum_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: enum_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        let is_extern = parsed_record.definition_linkage is External
        for method in parsed_record.methods.iterator() {
            let func = method.parsed_function
            let method_scope_id = .create_scope(
                parent_scope_id: enum_scope_id
                can_throw: func.can_throw
                debug_name: format("method({}::{})", parsed_record.name, func.name)
            )
            let block_scope_id = .create_scope(
                parent_scope_id: method_scope_id
                can_throw: func.can_throw
                debug_name: format("method-block({}::{})", parsed_record.name, func.name)
            )

            let is_generic = not parsed_record.generic_parameters.is_empty() or not func.generic_parameters.is_empty()

            mut checked_function = CheckedFunction(
                name: func.name
                name_span: func.name_span
                visibility: .typecheck_visibility(visibility: method.visibility, scope_id: enum_scope_id)
                return_type_id: unknown_type_id()
                return_type_span: None
                params: []
                generics: FunctionGenerics(
                    base_scope_id: method_scope_id
                    base_params: []
                    params: []
                    specializations: []
                )
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    control_flow: BlockControlFlow::MayReturn
                    yielded_type: TypeId::none()
                    yielded_none: false
                )
                can_throw: func.can_throw
                type: func.type
                linkage: func.linkage
                function_scope_id: method_scope_id
                struct_id: None
                is_instantiated: not is_generic or is_extern
                parsed_function: func
                is_comptime: func.is_comptime
                is_virtual: false
                is_override: false
            )

            let function_id = module.add_function(checked_function)
            mut generic_parameters: [FunctionGenericParameter] = []

            for generic_parameter in func.generic_parameters.iterator() {
                module.types.push(Type::TypeVariable(generic_parameter.name))
                let type_var_type_id = TypeId(
                    module: .current_module_id
                    id: .current_module().types.size() - 1
                )

                generic_parameters.push(FunctionGenericParameter::Parameter(
                    type_id: type_var_type_id
                ))

                if not func.must_instantiate {
                    .add_type_to_scope(
                        scope_id: method_scope_id,
                        type_name: generic_parameter.name,
                        type_id: type_var_type_id,
                        span: generic_parameter.span,
                    )
                }
            }

            checked_function.generics.params = generic_parameters

            for param in func.params.iterator() {
                if param.variable.name == "this" {
                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: enum_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: None
                        visibility: CheckedVisibility::Public
                    )

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value: None
                    ))
                } else {
                    let param_type = .typecheck_typename(parsed_type: param.variable.parsed_type, scope_id: method_scope_id, name: param.variable.name)

                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: param_type
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: param.variable.parsed_type.span()
                        visibility: CheckedVisibility::Public
                    )

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value: None
                    ))
                }
            }

            .add_function_to_scope(
                parent_scope_id: enum_scope_id
                name: func.name
                function_id
                span: parsed_record.name_span
            )

            let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: method_scope_id, name: None)
            checked_function.return_type_id = function_return_type_id
        }
    }

    function struct_inheritance_chain(this, struct_id: StructId) throws -> [StructId] {
        mut chain: [StructId] = []
        mut current = Some(struct_id)

        chain.push(current!)

        while current.has_value() {
            let parent = .get_struct(current!).super_struct_id
            if parent.has_value() {
                chain.push(parent!)
            }
            current = parent
        }

        mut reverse_chain: [StructId] = []
        for i in 0..chain.size() {
            reverse_chain.push(chain[chain.size() - 1 - i])
        }
        return reverse_chain
    }

    function typecheck_struct_constructor(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {
        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let struct_ = .get_struct(struct_id)

        let constructor_id = .find_function_in_scope(parent_scope_id: struct_.scope_id, function_name: parsed_record.name)
        if constructor_id.has_value() {
            if parsed_record.record_type is Class and parsed_record.definition_linkage is External {
                // XXX: The parser always sets the linkage type of an extern class'
                //      constructor to External, but we actually want to call the
                //      class' ::create function, just like we do with a
                //      ImplicitConstructor class.
                mut func = .get_function(constructor_id!)
                func.linkage = FunctionLinkage::External
            }
        } else if not parsed_record.definition_linkage is External {
            // No constructor found, so let's make one

            let constructor_can_throw = parsed_record.record_type is Class
            let function_scope_id = .create_scope(parent_scope_id: struct_.scope_id, can_throw: constructor_can_throw, debug_name: format("generated-constructor({})", parsed_record.name))
            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: constructor_can_throw, debug_name: format("generated-constructor-block({})", parsed_record.name))

            mut checked_constructor = CheckedFunction(
                name: parsed_record.name
                name_span: parsed_record.name_span
                visibility: CheckedVisibility::Public
                return_type_id: struct_type_id
                return_type_span: None
                params: []
                generics: FunctionGenerics(
                    base_scope_id: function_scope_id
                    base_params: []
                    params: []
                    specializations: []
                )
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    control_flow: BlockControlFlow::MayReturn
                    yielded_type: TypeId::none()
                    yielded_none: false
                )
                can_throw: constructor_can_throw
                type: FunctionType::ImplicitConstructor
                linkage: FunctionLinkage::Internal
                function_scope_id
                struct_id
                is_instantiated: true
                parsed_function: None
                is_comptime: false
                is_virtual: false
                is_override: false
            )

            // Internal constructor
            mut module = .current_module()
            let function_id = module.add_function(checked_function: checked_constructor)

            let inheritance_chain = .struct_inheritance_chain(struct_id)

            mut func = module.functions.last()!
            for field_struct_id in inheritance_chain.iterator() {
                for field in .get_struct(field_struct_id).fields.iterator() {
                    let variable = .get_variable(field.variable_id)
                    func.add_param(CheckedParameter(
                        requires_label: true
                        variable: variable
                        default_value: field.default_value
                    ))
                }
            }

            // Add constructor to the struct's scope
            .add_function_to_scope(
                parent_scope_id: struct_.scope_id
                name: parsed_record.name
                function_id: function_id
                span: parsed_record.name_span
            )
        }

        .current_struct_type_id = None
    }

    function is_class(this, anon type_id: TypeId) -> bool {
        guard .get_type(type_id) is Struct(struct_id) else {
            return false
        }
        return .get_struct(struct_id).record_type is Class
    }

    function is_struct(this, anon type_id: TypeId) -> bool {
        guard .get_type(type_id) is Struct(struct_id) else {
            return false
        }
        return .get_struct(struct_id).record_type is Struct
    }

    function typecheck_struct_predecl(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {
        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: true)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let struct_scope_id = .current_module().structures[struct_id.id].scope_id

        .add_struct_to_scope(scope_id, name: parsed_record.name, struct_id, span: parsed_record.name_span)

        mut super_struct_id: StructId? = None

        match parsed_record.record_type {
            Class(super_type: super_parsed_type) => match super_parsed_type.has_value() {
                true => {
                    let super_type_id = .typecheck_typename(parsed_type: super_parsed_type!, scope_id, name: None)
                    let super_type = .get_type(super_type_id)
                    
                    if super_type is Struct(struct_id) {
                        super_struct_id = struct_id
                    } else {
                        .error("Class can only inherit from another class", super_parsed_type!.span())
                    }
                }
                else => {}
            }
            Struct(super_type: super_parsed_type) => match super_parsed_type.has_value() {
                true => {
                    let super_type_id = .typecheck_typename(parsed_type: super_parsed_type!, scope_id, name: None)
                    let super_type = .get_type(super_type_id)
                    
                    if super_type is Struct(struct_id) {
                        super_struct_id = struct_id
                    } else {
                        .error("Struct can only inherit from another struct", super_parsed_type!.span())
                    }
                }
                else => {}
            }
            else => {
                panic("Expected Struct or Class in typecheck_struct_predecl")
            }
        }

        mut module = .current_module()
        module.structures[struct_id.id] = CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: struct_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
            super_struct_id
        )

        mut generic_parameters: [TypeId] = module.structures[struct_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters.iterator() {
            module.types.push(Type::TypeVariable(gen_parameter.name))

            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size() - 1
            )

            generic_parameters.push(parameter_type_id)

            .add_type_to_scope(scope_id: struct_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        let is_extern = parsed_record.definition_linkage is External
        for method in parsed_record.methods.iterator() {
            let func = method.parsed_function

            let method_scope_id = .create_scope(parent_scope_id: struct_scope_id, can_throw: func.can_throw, debug_name: format("method({}::{})", parsed_record.name, func.name))
            let block_scope_id = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw, debug_name: format("method-block({}::{})", parsed_record.name, func.name))

            let is_generic = not parsed_record.generic_parameters.is_empty() or not func.generic_parameters.is_empty()

            mut checked_function = CheckedFunction(
                name: func.name
                name_span: func.name_span
                visibility: .typecheck_visibility(visibility: method.visibility, scope_id: struct_scope_id)
                return_type_id: unknown_type_id()
                return_type_span: func.return_type_span
                params: []
                generics: FunctionGenerics(
                    base_scope_id: method_scope_id
                    base_params: []
                    params: []
                    specializations: []
                )
                block: CheckedBlock(
                    statements: []
                    scope_id: block_scope_id
                    control_flow: BlockControlFlow::MayReturn
                    yielded_type: TypeId::none()
                    yielded_none: false
                )
                can_throw: func.can_throw
                type: func.type
                linkage: func.linkage
                function_scope_id: method_scope_id
                struct_id
                is_instantiated: not is_generic or is_extern
                parsed_function: method.parsed_function
                is_comptime: method.parsed_function.is_comptime
                is_virtual: method.is_virtual
                is_override: method.is_override
            )

            let function_id = module.add_function(checked_function)
            let previous_index = .current_function_id
            .current_function_id = function_id

            mut check_scope: ScopeId? = None
            if is_generic {
                check_scope = .create_scope(parent_scope_id: method_scope_id, can_throw: func.can_throw, debug_name: format("method-checking({}::{})", parsed_record.name, func.name))
            }

            for gen_parameter in func.generic_parameters.iterator() {
                module.types.push(Type::TypeVariable(gen_parameter.name))
                let type_var_type_id = TypeId(
                    module: .current_module_id
                    id: .current_module().types.size() - 1
                )

                checked_function.generics.params.push(FunctionGenericParameter::Parameter(type_var_type_id))
                .add_type_to_scope(scope_id: method_scope_id, type_name: gen_parameter.name, type_id: type_var_type_id, span: gen_parameter.span)
            }

            for param in func.params.iterator() {
                if param.variable.name == "this" {
                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: struct_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: None
                        visibility: CheckedVisibility::Public
                    )

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value: None
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                } else {
                    let param_type = .typecheck_typename(parsed_type: param.variable.parsed_type, scope_id: method_scope_id, name: param.variable.name)

                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: param_type
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: param.variable.parsed_type.span()
                        visibility: CheckedVisibility::Public
                    )

                    mut checked_default_value: CheckedExpression? = None
                    if param.default_argument.has_value() {
                        //FIXME: Get the real safety mode from somewhere, right now it assumes it is safe
                        mut checked_default_value_expr = .typecheck_expression(param.default_argument!, scope_id, safety_mode: SafetyMode::Safe, type_hint: param_type)
                        
                        if checked_default_value_expr is OptionalNone(span: expr_span) {
                            checked_default_value_expr = CheckedExpression::OptionalNone(span: expr_span, type_id: param_type)
                        }
                        
                        let default_value_type_id = checked_default_value_expr.type()
                        checked_default_value = checked_default_value_expr
                        .check_types_for_compat(
                            lhs_type_id: param_type
                            rhs_type_id: default_value_type_id
                            generic_inferences: &mut .generic_inferences
                            span: param.span
                        )
                    }

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value: checked_default_value
                    ))

                    if check_scope.has_value() {
                        let var_id = module.add_variable(checked_variable)
                        .add_var_to_scope(scope_id: check_scope!, name: param.variable.name, var_id, span: param.variable.span)
                    }
                }
            }

            if checked_function.is_virtual and checked_function.is_static() {
                .error("Functions cannot be both virtual and static", checked_function.name_span)
            }
            if checked_function.is_override and checked_function.is_static() {
                .error("Functions cannot be both override and static", checked_function.name_span)
            }

            .add_function_to_scope(
                parent_scope_id: struct_scope_id
                name: func.name
                function_id: function_id
                span: parsed_record.name_span
            )

            let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: method_scope_id, name: None)
            checked_function.return_type_id = function_return_type_id

            if is_generic {
                if not check_scope.has_value() {
                    .compiler.panic("Generic method with generic parameters must have a check scope")
                }

                let old_ignore_errors = .ignore_errors
                .ignore_errors = true
                let block = .typecheck_block(parsed_block: func.block, parent_scope_id: check_scope!, safety_mode: SafetyMode::Safe)
                .ignore_errors = old_ignore_errors

                mut return_type_id: TypeId = builtin(BuiltinType::Void)
                if function_return_type_id.equals(unknown_type_id()) {
                    if not block.statements.is_empty() {
                        if block.statements.last()! is Return(val) and val.has_value() {
                            return_type_id = .resolve_type_var(type_var_type_id: val!.type(), scope_id: method_scope_id)
                        }
                    }
                } else {
                    return_type_id = .resolve_type_var(type_var_type_id: function_return_type_id, scope_id)
                }

                checked_function.block = block
                checked_function.return_type_id = return_type_id
            }

            module.functions[function_id.id] = checked_function
            .current_function_id = previous_index
        }

        module.structures[struct_id.id].generic_parameters = generic_parameters

        .current_struct_type_id = None
    }

    function typecheck_struct_predecl_initial(mut this, parsed_record: ParsedRecord, struct_index: usize, module_struct_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
        mut module = .current_module()
        module.types.push(Type::Struct(struct_id))

        let struct_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: struct_type_id, span: parsed_record.name_span)

        let struct_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("struct({})", parsed_record.name))

        // Add a placeholder entry, this will be replaced later.
        module.structures.push(CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            generic_parameters: []
            fields: []
            scope_id: struct_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
            super_struct_id: None
        ))
    }

    function typecheck_namespace_declarations(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_declarations(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id)
        }

        for record in parsed_namespace.records.iterator() {
            match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        .compiler.panic("can't find struct that has been previous added")
                    }
                    .typecheck_struct(record, struct_id: struct_id!, parent_scope_id: scope_id)
                }
                SumEnum | ValueEnum => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        .compiler.panic("can't find enum that has been previous added")
                    }
                    .typecheck_enum(record, enum_id: enum_id!, parent_scope_id: scope_id)
                }
                else => {}
            }
        }

        for fun in parsed_namespace.functions.iterator() {
            .current_function_id = .find_function_in_scope(parent_scope_id: scope_id, function_name: fun.name)
            .typecheck_function(parsed_function: fun, parent_scope_id: scope_id)
            .current_function_id = None
        }
    }

    function typecheck_enum_constructor(mut this, record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        mut next_constant_value = 0u64
        mut seen_names: {String} = {}

        mut enum_ = .get_enum(enum_id)

        mut common_seen_fields: {String} = {}
        mut common_fields: [VarId] = []
        mut common_params: [CheckedParameter] = []
        for field in enum_.fields.iterator() {
            let variable = .get_variable(field.variable_id)
            common_params.push(CheckedParameter(
                requires_label: true,
                variable,
                default_value: field.default_value))

            common_seen_fields.add(variable.name)
            common_fields.push(field.variable_id)
        }

        match record.record_type {
            ValueEnum(underlying_type, variants) => {
                let underlying_type_id = .typecheck_typename(parsed_type: underlying_type, scope_id: parent_scope_id, name: None)
                mut module = .current_module()
                for variant in variants.iterator() {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                    } else {
                        seen_names.add(variant.name)

                        let expr = match variant.value.has_value() {
                            true => {
                                let value_expression = .cast_to_underlying(variant.value!, scope_id: parent_scope_id, parsed_type: underlying_type)
                                let number_constant = value_expression.to_number_constant(program: .program)
                                match number_constant.has_value() {
                                    true => {
                                        next_constant_value = match number_constant! {
                                            Signed(val) => (val + 1) as! u64
                                            Unsigned(val) => val + 1
                                            Floating(val) => {
                                                todo("Implement floats")
                                                yield 0u64
                                            }
                                        }
                                    }
                                    else => {
                                        .error(format("Enum variant '{}' in enum '{}' has a non-constant value: {}", variant.name, enum_.name, value_expression), variant.span)
                                    }
                                }
                                yield value_expression
                            }
                            else => .cast_to_underlying(
                                expr: ParsedExpression::NumericConstant(val: NumericConstant::U64(next_constant_value++), span: variant.span)
                                scope_id: parent_scope_id
                                parsed_type: underlying_type
                            )
                        }

                        enum_.variants.push(CheckedEnumVariant::WithValue(enum_id, name: variant.name, expr, span: variant.span))
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant.name
                            type_id: enum_.type_id
                            is_mutable: false
                            definition_span: variant.span
                            type_span: None
                            visibility: CheckedVisibility::Public
                        ))
                        .add_var_to_scope(scope_id: enum_.scope_id, name: variant.name, var_id, span: variant.span)
                    }
                }
            }
            SumEnum(is_boxed, variants) => {
                mut module = .current_module()
                for variant in variants.iterator() {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                        continue
                    }
                    seen_names.add(variant.name)
                    let is_structlike = variant.params.has_value() and variant.params!.size() > 0 and variant.params![0].name != ""
                    let is_typed = variant.params.has_value() and variant.params!.size() == 1 and variant.params![0].name == ""

                    if is_structlike {
                        mut seen_fields: {String} = {}
                        for name in common_seen_fields.iterator() {
                            seen_fields.add(name)
                        }

                        mut params: [CheckedParameter] = []
                        for param in common_params.iterator() {
                            params.push(param)
                        }

                        mut fields: [VarId] = []
                        for field in common_fields.iterator() {
                            fields.push(field)
                        }

                        for param in variant.params!.iterator() {
                            if seen_fields.contains(param.name) {
                                .error(format("Enum variant '{}' has a member named '{}' more than once", variant.name, param.name), param.span)
                                continue
                            }
                            seen_fields.add(param.name)
                            let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, name: param.name)
                            let checked_var = CheckedVariable(
                                name: param.name
                                type_id
                                is_mutable: param.is_mutable
                                definition_span: param.span
                                type_span: None
                                visibility: CheckedVisibility::Public
                            )
                            params.push(CheckedParameter(requires_label: true, variable: checked_var, default_value: None))

                            if .dump_type_hints and param.parsed_type is Empty {
                                .dump_type_hint(type_id, span: param.span)
                            }

                            mut module = .current_module()
                            let var_id = module.add_variable(checked_var)
                            fields.push(var_id)
                        }
                        enum_.variants.push(CheckedEnumVariant::StructLike(enum_id, name: variant.name, fields, span: variant.span))
                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                    params: []
                                    specializations: []
                                )
                                block: CheckedBlock(
                                    statements: []
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::MayReturn
                                    yielded_type: TypeId::none()
                                    yielded_none: false
                                ),
                                can_throw: can_function_throw
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    } else if is_typed {
                        mut params: [CheckedParameter] = []
                        for param in common_params.iterator() {
                            params.push(param)
                        }

                        let param = variant.params![0]
                        let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, name: param.name)
                        enum_.variants.push(CheckedEnumVariant::Typed(enum_id, name: variant.name, type_id, span: variant.span))

                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let variable = CheckedVariable(
                                name: "value"
                                type_id
                                is_mutable: false
                                definition_span: param.span
                                type_span: None
                                visibility: CheckedVisibility::Public
                            )
                            params.push(CheckedParameter(requires_label: false, variable, default_value: None))

                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                    params: []
                                    specializations: []
                                )
                                block: CheckedBlock(
                                    statements: [],
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::AlwaysReturns
                                    yielded_type: TypeId::none()
                                    yielded_none: false
                                ),
                                can_throw: can_function_throw
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    } else {
                        mut params: [CheckedParameter] = []
                        for param in common_params.iterator() {
                            params.push(param)
                        }

                        enum_.variants.push(CheckedEnumVariant::Untyped(enum_id, name: variant.name, span: variant.span))
                        let maybe_enum_variant_constructor = .find_function_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let can_function_throw = is_boxed
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: can_function_throw, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                    params: []
                                    specializations: []
                                )
                                block: CheckedBlock(
                                    statements: []
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::AlwaysReturns
                                    yielded_type: TypeId::none()
                                    yielded_none: false
                                ),
                                can_throw: can_function_throw
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(parent_scope_id: enum_.scope_id, name: variant.name, function_id, span: variant.span)
                        }
                    }
                }
            }
            else => {}
        }
    }

    function typecheck_enum(mut this, record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        for method in record.methods.iterator() {
            .typecheck_method(
                func: method.parsed_function
                parent_id: StructOrEnumId::Enum(enum_id)
            )
        }
    }

    function cast_to_underlying(mut this, anon expr: ParsedExpression, scope_id: ScopeId, parsed_type: ParsedType) throws -> CheckedExpression {
        let cast_expression = ParsedExpression::UnaryOp(expr, op: UnaryOperator::TypeCast(TypeCast::Infallible(parsed_type)), span: expr.span())
        return .typecheck_expression(cast_expression, scope_id, safety_mode: SafetyMode::Safe, type_hint: None)
    }

    function typecheck_struct(mut this, record: ParsedRecord, struct_id: StructId, parent_scope_id: ScopeId) throws {
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))

        .current_struct_type_id = struct_type_id

        mut all_virtuals: [String: CheckedFunction] = [:]
        mut super_struct_id = .get_struct(struct_id).super_struct_id
        while super_struct_id.has_value() {
            let super_struct = .get_struct(super_struct_id!)
            let scope = .get_scope(super_struct.scope_id)
            for function_tuple in scope.functions.iterator() {
                let function_ = .get_function(function_tuple.1)
                if function_.is_virtual {
                    all_virtuals[function_.name] = function_
                }
            }
            super_struct_id = super_struct.super_struct_id
        }

        for method in record.methods.iterator() {
            if method.is_override {
                if not all_virtuals.contains(method.parsed_function.name) {
                    .error("Missing virtual for override", method.parsed_function.name_span)
                }
            } else if all_virtuals.contains(method.parsed_function.name) {
                .error("Missing override keyword on function that is virtual", method.parsed_function.name_span)
            }
            .typecheck_method(func: method.parsed_function, parent_id: StructOrEnumId::Struct(struct_id))
        }

        .current_struct_type_id = None
    }

    function typecheck_method(mut this, func: ParsedFunction, parent_id: StructOrEnumId) throws {
        mut parent_generic_parameters: [TypeId] = []
        mut scope_id = .prelude_scope_id()
        mut definition_linkage = DefinitionLinkage::Internal

        match parent_id {
            Struct(struct_id) => {
                mut structure = .get_struct(struct_id)
                parent_generic_parameters = structure.generic_parameters
                scope_id = structure.scope_id
                definition_linkage = structure.definition_linkage
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                definition_linkage = enum_.definition_linkage
                scope_id = enum_.scope_id
                parent_generic_parameters = enum_.generic_parameters
            }
        }

        if (not func.generic_parameters.is_empty() or not parent_generic_parameters.is_empty()) and not func.must_instantiate {
            return
        }

        let structure_scope_id = scope_id
        let structure_linkage = definition_linkage

        let method_id = .find_function_in_scope(parent_scope_id: structure_scope_id, function_name: func.name)
        if not method_id.has_value() {
            .compiler.panic("we just pushed the checked function, but it's not present")
        }

        mut checked_function = .get_function(method_id!)
        let function_scope_id = checked_function.function_scope_id

        mut module = .current_module()
        for param in checked_function.params.iterator() {
            let variable = param.variable
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Set current function index before a block type check so that
        // method return type is checked against its implementation
        .current_function_id = method_id

        let VOID_TYPE_ID = builtin(BuiltinType::Void)

        let block = .typecheck_block(parsed_block: func.block, parent_scope_id: function_scope_id, safety_mode: SafetyMode::Safe)
        let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: function_scope_id, name: None)

        mut return_type_id = function_return_type_id
        if function_return_type_id.equals(unknown_type_id()) and not block.statements.is_empty() {
            // If the return type is unknown, and the function starts with a return statement,
            // we infer the return type from its expression.
            if block.statements[0] is Return(val) and val.has_value() {
                return_type_id = val!.type()
            } else {
                return_type_id = VOID_TYPE_ID
            }
        } else if function_return_type_id.equals(unknown_type_id()) {
            return_type_id = VOID_TYPE_ID
        }

        if not structure_linkage is External and not return_type_id.equals(VOID_TYPE_ID) and not block.control_flow.always_transfers_control() {
            // FIXME: Use better span
            if return_type_id.equals(never_type_id()) and not block.control_flow.never_returns() {
                .error("Control reaches end of never-returning function", func.name_span)
            } else if not block.control_flow.never_returns() {
                .error("Control reaches end of non-void function", func.name_span)
            }
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function typecheck_parameter(mut this, parameter: ParsedParameter, scope_id: ScopeId, first: bool, this_arg_type_id: TypeId?, check_scope: ScopeId?) throws -> CheckedParameter {
        mut type_id = .typecheck_typename(parsed_type: parameter.variable.parsed_type, scope_id, name: parameter.variable.name)

        if first and parameter.variable.name == "this" {
            if this_arg_type_id.has_value() {
                type_id = this_arg_type_id!
            }
        }

        let variable = CheckedVariable(
            name: parameter.variable.name
            type_id
            is_mutable: parameter.variable.is_mutable
            definition_span: parameter.variable.span
            type_span: None
            visibility: CheckedVisibility::Public
        )

        mut checked_default_value: CheckedExpression? = None
        if parameter.default_argument.has_value() {
            //FIXME: Get the real safety mode from somewhere, right now it assumes it is safe
            mut checked_default_value_expr = .typecheck_expression(parameter.default_argument!, scope_id, safety_mode: SafetyMode::Safe, type_hint: type_id)
            
            if checked_default_value_expr is OptionalNone(span: expr_span) {
                checked_default_value_expr = CheckedExpression::OptionalNone(span: expr_span, type_id)
            }
            
            let default_value_type_id = checked_default_value_expr.type()
            checked_default_value = checked_default_value_expr
            if not .check_types_for_compat(
                lhs_type_id: type_id
                rhs_type_id: default_value_type_id
                generic_inferences: &mut .generic_inferences
                span: checked_default_value_expr.span()
            ) {
                checked_default_value = None
            }
        }

        let checked_parameter = CheckedParameter(
            requires_label: parameter.requires_label
            variable
            default_value: checked_default_value
        )

        if check_scope.has_value() {
            mut module = .current_module()
            let var_id = module.add_variable(variable)
            .add_var_to_scope(
                scope_id: check_scope!,
                name: parameter.variable.name,
                variable: var_id,
                span: parameter.variable.span,
            )
        }

        return checked_parameter
    }

    function typecheck_function_predecl(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId, this_arg_type_id: TypeId?, mut generics: FunctionGenerics? = None) throws {
        let function_scope_id = .create_scope(parent_scope_id, can_throw: parsed_function.can_throw, debug_name: format("function({})", parsed_function.name))
        let scope_debug_name = format("function-block({})", parsed_function.name)
        let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: parsed_function.can_throw, debug_name: scope_debug_name)
        let module_id = .current_module_id.id

        mut base_definition = false
        if not generics.has_value() {
            generics = FunctionGenerics(
                base_scope_id: function_scope_id
                base_params: []
                params: []
                specializations: []
            )

            base_definition = true
        }

        let is_generic_function = not parsed_function.generic_parameters.is_empty()
        let is_generic = is_generic_function or (this_arg_type_id.has_value() and .get_type(this_arg_type_id!) is GenericInstance)

        mut checked_function = CheckedFunction(
            name: parsed_function.name
            name_span: parsed_function.name_span
            visibility: .typecheck_visibility(visibility: parsed_function.visibility, scope_id: parent_scope_id)
            return_type_id: unknown_type_id()
            return_type_span: parsed_function.return_type_span
            params: []
            generics: generics!
            block: CheckedBlock(
                statements: []
                scope_id: block_scope_id
                control_flow: BlockControlFlow::MayReturn
                yielded_type: TypeId::none()
                yielded_none: false
            )
            can_throw: parsed_function.can_throw
            type: FunctionType::Normal
            linkage: parsed_function.linkage
            function_scope_id
            struct_id: None
            is_instantiated: not is_generic or not base_definition
            parsed_function
            is_comptime: parsed_function.is_comptime
            is_virtual: false
            is_override: false
        )

        // FIXME: We can't return a `mut Foo` from a function right now, but assigning anything to a `mut` variable makes it mutable.
        //        AKA, working around one bug with another bug. :^)
        mut current_module = .current_module()
        let function_id = current_module.add_function(checked_function)
        let checked_function_scope_id = checked_function.function_scope_id

        let external_linkage = parsed_function.linkage is External

        let check_scope = match is_generic {
            true => Some(.create_scope(parent_scope_id, can_throw: parsed_function.can_throw, debug_name: scope_debug_name))
            else => None
        }

        // Check generic parameters
        mut i = 0
        for generic_parameter in parsed_function.generic_parameters.iterator() {
            mut type_var_type_id = TypeId(
                module: current_module.id
                id: current_module.types.size()
            )

            if base_definition {
                current_module.types.push(Type::TypeVariable(generic_parameter.name))
                checked_function.generics.params.push(FunctionGenericParameter::Parameter(type_var_type_id))
            } else if checked_function.generics.params[i] is Parameter(var_type_id) {
                type_var_type_id = var_type_id
            }

            if not parsed_function.must_instantiate or external_linkage {
                .add_type_to_scope(
                    scope_id: checked_function_scope_id
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }

            if check_scope.has_value() {
                .add_type_to_scope(
                    scope_id: check_scope!
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }

            i++
        }

        // Check parameters
        mut first = true
        mut module = .current_module()
        for parameter in parsed_function.params.iterator() {
            let checked_param = .typecheck_parameter(parameter, scope_id: checked_function_scope_id, first, this_arg_type_id, check_scope)

            checked_function.params.push(checked_param)
            if base_definition {
                checked_function.generics.base_params.push(checked_param)
            }

            first = false
        }

        // Check return type
        mut function_return_type_id = .typecheck_typename(parsed_type: parsed_function.return_type, scope_id: checked_function_scope_id, name: None)
        if not parsed_function.is_fat_arrow and parsed_function.return_type is Empty {
            function_return_type_id = void_type_id()
        }

        checked_function.return_type_id = function_return_type_id

        .check_that_type_doesnt_contain_reference(type_id: function_return_type_id, span: parsed_function.return_type_span)

        if not parsed_function.generic_parameters.is_empty() {
            let old_ignore_errors = .ignore_errors
            .ignore_errors = true
            let block = .typecheck_block(
                parsed_block: parsed_function.block,
                parent_scope_id: check_scope!,
                safety_mode: SafetyMode::Safe
            )
            .ignore_errors = old_ignore_errors

            let return_type_id = match function_return_type_id.equals(unknown_type_id()) {
                true => .infer_function_return_type(block)
                else => .resolve_type_var(type_var_type_id: function_return_type_id, scope_id: parent_scope_id)
            }

            checked_function.block = block
            checked_function.return_type_id = return_type_id
        }

        .add_function_to_scope(parent_scope_id, name: parsed_function.name, function_id, span: parsed_function.name_span)
    }

    function check_that_type_doesnt_contain_reference(mut this, type_id: TypeId, span: Span) throws {
        let type = .get_type(type_id)

        // FIXME: Check for any type that contains a reference as a generic parameter, etc.
        let contains_reference = match type {
            Reference | MutableReference => true
            else => false
        }

        if contains_reference {
            .error(
                format(
                    "Reference type ‘{}’ not usable in this context"
                    .type_name(type_id)
                )
                span
            )
        }
    }

    function typecheck_and_specialize_generic_function(mut this, function_id: FunctionId, generic_arguments: [TypeId], parent_scope_id: ScopeId, this_type_id: TypeId?, generic_substitutions: GenericInferences) throws {
        mut checked_function = .get_function(function_id)
        checked_function.generics.specializations.push(generic_arguments)

        mut module = .current_module()

        let function_id = module.next_function_id()
        if not checked_function.parsed_function.has_value() {
            return
        }
        mut parsed_function = checked_function.to_parsed_function()
        let scope_id = .create_scope(parent_scope_id: checked_function.generics.base_scope_id, can_throw: parsed_function.can_throw, debug_name: format("function-specialization({})", parsed_function.name))

        if parsed_function.generic_parameters.size() != generic_arguments.size() {
            .error(
                format("Generic function {} expects {} generic arguments, but {} were given",
                    parsed_function.name, parsed_function.generic_parameters.size(), generic_arguments.size()
                )
                parsed_function.name_span
            )
        }

        let span = parsed_function.name_span
        for substitution in generic_substitutions.iterator() {
            if .get_type(TypeId::from_string(substitution.0)) is TypeVariable(type_name) {
                .add_type_to_scope(scope_id, type_name, type_id: TypeId::from_string(substitution.1), span)
            }
        }

        parsed_function.must_instantiate = true
        checked_function.is_instantiated = true

        .current_function_id = Some(function_id)
        .typecheck_function_predecl(parsed_function, parent_scope_id: scope_id, this_arg_type_id: this_type_id, generics: checked_function.generics)
        .typecheck_function(parsed_function, parent_scope_id: scope_id)
        .current_function_id = None

        checked_function.function_scope_id = scope_id
    }

    function typecheck_jakt_main(mut this, parsed_function: ParsedFunction) throws {
        let param_type_error = "Main function must take a single array of strings as its parameter"
        if parsed_function.params.size() > 1 {
            .error(param_type_error, parsed_function.name_span)
        }

        if not parsed_function.params.is_empty() {
            if parsed_function.params[0].variable.parsed_type is JaktArray(inner, span) {
                if inner is Name(name, span) {
                    if (name != "String") {
                        .error(param_type_error, span)
                    }
                } else {
                    .error(param_type_error, span)
                }
            } else {
                .error(param_type_error, parsed_function.name_span)
            }
        }

        let return_type_error = "Main function must return c_int"
        match parsed_function.return_type {
            ParsedType::Empty => {}
            ParsedType::Name(name, span) => {
                if name != "c_int" {
                    .error(return_type_error, span)
                }
            }
            else => {
                .error(return_type_error, parsed_function.return_type_span)
            }
        }
    }

    function infer_function_return_type(this, block: CheckedBlock) -> TypeId {
        if block.statements.is_empty() {
            return void_type_id()
        }
        if block.statements.last()! is Return(val) and val.has_value() {
            return val!.type()
        }
        return void_type_id()
    }

    function typecheck_function(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        if not parsed_function.generic_parameters.is_empty() and not parsed_function.must_instantiate {
            return
        }

        // FIXME: Optional.expect("...") would be nicer here.
        let function_id = .find_function_in_scope(parent_scope_id, function_name: parsed_function.name)
        if not function_id.has_value() {
            .compiler.panic("Internal error: missing previously defined function")
        }
        if parsed_function.name == "main" {
            .typecheck_jakt_main(parsed_function)
        }

        mut checked_function = .get_function(function_id!)
        let function_scope_id = checked_function.function_scope_id
        let function_linkage = checked_function.linkage

        mut param_vars: [CheckedVariable] = []
        mut module = .current_module()
        for param in checked_function.params.iterator() {
            let variable = param.variable
            param_vars.push(variable)

            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        // Resolve concrete types
        mut function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
            name: None
        )

        if not parsed_function.is_fat_arrow and parsed_function.return_type is Empty and parsed_function.name != "main" {
            function_return_type_id = void_type_id()
        }

        checked_function.return_type_id = function_return_type_id

        if function_return_type_id.equals(never_type_id()) {
            // Allow noreturn functions to call throwing functions, they'll just be forced to crash.
            mut scope = .get_scope(function_scope_id)
            scope.can_throw = true
        }

        let block = .typecheck_block(
            parsed_function.block
            parent_scope_id: function_scope_id
            safety_mode: SafetyMode::Safe
        )

        if block.yielded_type.has_value() {
            .error_with_hint("Functions are not allowed to yield values", parsed_function.block.find_yield_span()!,
                            "You might want to return instead", parsed_function.block.find_yield_keyword_span()!)
        }

        // Typecheck return type a second time to resolve generics
        function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
            name: None
        )

        // Infer return type if necessary
        // If the return type is unknown, and the function starts with a return statement,
        // we infer the return type from its expression.
        let UNKNOWN_TYPE_ID = unknown_type_id()
        let VOID_TYPE_ID = void_type_id()
        mut return_type_id = VOID_TYPE_ID
        if function_return_type_id.equals(UNKNOWN_TYPE_ID) {
            return_type_id = .infer_function_return_type(block)
        } else {
            return_type_id = .resolve_type_var(
                type_var_type_id: function_return_type_id,
                scope_id: function_scope_id
            )
        }

        let external_linkage = function_linkage is External

        if not external_linkage and not return_type_id.equals(VOID_TYPE_ID) and not block.control_flow.always_transfers_control() {
            // FIXME: Use better span
            if return_type_id.equals(never_type_id()) and not block.control_flow.never_returns() {
                .error("Control reaches end of never-returning function", parsed_function.name_span)
            } else if not block.control_flow.never_returns() {
                .error("Control reaches end of non-void function", parsed_function.name_span)
            }
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
    }

    function statement_control_flow(this, anon statement: CheckedStatement) -> BlockControlFlow => match statement {
        Return => BlockControlFlow::AlwaysReturns
        Throw => BlockControlFlow::AlwaysReturns
        Break => BlockControlFlow::AlwaysTransfersControl(might_break: true)
        Continue => BlockControlFlow::AlwaysTransfersControl(might_break: false)
        Yield(expr) => expr.control_flow().updated(BlockControlFlow::AlwaysTransfersControl(might_break: false))
        If(condition, then_block, else_statement) => match condition {
            Boolean(val) => match val {
                true => then_block.control_flow
                else => match else_statement.has_value() {
                    true => .statement_control_flow(else_statement!)
                    else => BlockControlFlow::MayReturn
                }
            }
            // Note that a missing 'else' branch produces a partial result.
            else => match then_block.control_flow {
                NeverReturns => .maybe_statement_control_flow(else_statement, then_block.control_flow)
                AlwaysReturns => match .maybe_statement_control_flow(else_statement, then_block.control_flow) {
                    NeverReturns | AlwaysReturns => BlockControlFlow::AlwaysReturns
                    MayReturn => BlockControlFlow::MayReturn
                    AlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
                    PartialNeverReturns(might_break) => BlockControlFlow::PartialNeverReturns(might_break)
                    PartialAlwaysReturns(might_break) => BlockControlFlow::PartialAlwaysReturns(might_break)
                    PartialAlwaysTransfersControl(might_break) => BlockControlFlow::PartialAlwaysTransfersControl(might_break)
                }
                MayReturn => BlockControlFlow::MayReturn
                PartialNeverReturns | PartialAlwaysReturns | PartialAlwaysTransfersControl | AlwaysTransfersControl => .maybe_statement_control_flow(else_statement, then_block.control_flow)
            }
        }
        Block(block) => block.control_flow
        // FIXME: While could use more information here.
        While(block) => match block.control_flow {
            AlwaysTransfersControl => BlockControlFlow::MayReturn
            NeverReturns => BlockControlFlow::NeverReturns
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            else => BlockControlFlow::MayReturn
        }
        Loop(block) => match block.control_flow {
            AlwaysTransfersControl(might_break) => match might_break {
                false => BlockControlFlow::AlwaysTransfersControl(might_break)
                else => BlockControlFlow::MayReturn
            }
            NeverReturns => BlockControlFlow::NeverReturns
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            MayReturn => BlockControlFlow::MayReturn
            else => match block.control_flow.may_break() {
                true => BlockControlFlow::MayReturn
                // Loop will always continue, so upgrade partial results to full ones
                else => match block.control_flow {
                    PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
                    PartialNeverReturns => BlockControlFlow::NeverReturns
                    PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
                    else => BlockControlFlow::MayReturn // unreachable, logically.
                }
            }
        }
        Expression(expr) => expr.control_flow()
        else => BlockControlFlow::MayReturn
    }

    function maybe_statement_control_flow(this, anon statement: CheckedStatement?, anon other_branch: BlockControlFlow) -> BlockControlFlow => match statement.has_value() {
        true => .statement_control_flow(statement!)
        else => other_branch.partial()
    }

    // FIXME: Use [TypeId: TypeID] without TypeId.to_string()/TypeId::from_string() workaround
    function check_types_for_compat(mut this, lhs_type_id: TypeId, rhs_type_id: TypeId, generic_inferences: &mut GenericInferences, span: Span) throws -> bool {
        if lhs_type_id.equals(rhs_type_id)
            or lhs_type_id.equals(unknown_type_id())
            or rhs_type_id.equals(unknown_type_id()) {

            return true
        }

        let lhs_type = .get_type(lhs_type_id)
        let rhs_type = .get_type(rhs_type_id)

        let lhs_type_id_string = lhs_type_id.to_string()
        let rhs_type_id_string = rhs_type_id.to_string()

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let array_struct_id = .find_struct_in_prelude("Array")

        match lhs_type {
            TypeVariable => {
                // If the call expects a generic type variable, let's see if we've already seen it
                mut seen_type_id_string = generic_inferences.get(lhs_type_id_string)
                if seen_type_id_string.has_value() {
                    let seen_type_id = TypeId::from_string(seen_type_id_string!)
                    if .get_type(seen_type_id) is TypeVariable {
                        return .check_types_for_compat(
                            lhs_type_id: seen_type_id
                            rhs_type_id: lhs_type_id
                            generic_inferences
                            span)
                    }
                    // We've seen this type variable assigned something before
                    // we should error if it's incompatible.
                    if seen_type_id_string.value() != rhs_type_id_string {
                        .error(
                            format(
                                "Type mismatch: expected ‘{}’, but got ‘{}’"
                                .type_name(seen_type_id)
                                .type_name(rhs_type_id)
                            )
                            span
                        )
                        return false
                    }
                } else {
                    generic_inferences.set(key: lhs_type_id_string, value: rhs_type_id_string)
                }
            }
            GenericEnumInstance(id: lhs_enum_id, args: lhs_args) => {
                if rhs_type is GenericEnumInstance(id: rhs_enum_id, args: rhs_args) {
                    if lhs_enum_id.equals(rhs_enum_id) {
                        let lhs_enum = .get_enum(lhs_enum_id)
                        guard lhs_args.size() == rhs_args.size() else {
                            .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < lhs_args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_args[idx]
                                rhs_type_id: rhs_args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Function(params: lhs_params, can_throw: lhs_can_throw, return_type_id: lhs_return_type_id) => {
                guard rhs_type is Function(params: rhs_params, can_throw: rhs_can_throw, return_type_id: rhs_return_type_id) else {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }

                if not (lhs_can_throw == rhs_can_throw) {
                    let lhs_throw = match lhs_can_throw {
                        true => "Yes"
                        else => "No"
                    }

                    let rhs_throw = match rhs_can_throw {
                        true => "Yes"
                        else => "No"
                    }

                    .error(
                        format("Function can throw mismatch: expected ‘{}’, but got ‘{}’", lhs_throw, rhs_throw)
                        span
                    )
                }

                if not (lhs_params.size() == rhs_params.size()) {
                    .error(
                        format("Function parameter count mismatch: expected ‘{}’, but got ‘{}’", lhs_params.size(), rhs_params.size())
                        span
                    )
                    return false
                }

                if not .check_types_for_compat(
                    lhs_type_id: lhs_return_type_id
                    rhs_type_id: rhs_return_type_id
                    generic_inferences
                    span
                ) {
                    .error_with_hint(
                        format("Function type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                        format("The return types differ: expected ‘{}’, but got ‘{}’", .type_name(lhs_return_type_id), .type_name(rhs_return_type_id))
                        hint_span: span
                    )
                    return false
                }

                for i in ..lhs_params.size() {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_params[i]
                        rhs_type_id: rhs_params[i]
                        generic_inferences
                        span
                    ) {
                        .error_with_hint(
                            format("Function type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                            format("The parameter types differ at argument {}: expected ‘{}’, but got ‘{}’", (i + 1), .type_name(lhs_params[i]), .type_name(rhs_params[i]))
                            hint_span: span
                        )
                        return false
                    }
                }
            }
            GenericInstance(id, args) => {
                let lhs_struct_id = id
                let lhs_args = args

                // If lhs is T? or weak T? and rhs is T, skip type compat check
                if (lhs_struct_id.equals(optional_struct_id)) or
                    (lhs_struct_id.equals(weakptr_struct_id)) {
                    if lhs_args.size() > 0 {
                        if (lhs_args[0].equals(rhs_type_id)) {
                            return true
                        }
                    }
                }

                if rhs_type is GenericInstance(id, args) {
                    let rhs_struct_id = id

                    if lhs_struct_id.equals(rhs_struct_id) {
                        let rhs_args = args
                        let lhs_struct = .get_struct(lhs_struct_id)
                        guard lhs_args.size() == rhs_args.size() else {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_args[idx]
                                rhs_type_id: rhs_args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }
                    } else if (lhs_struct_id.equals(array_struct_id)) {
                        let array_value_type_id = args[0]
                        if (array_value_type_id.equals(unknown_type_id())) {
                            return true
                        }
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    } else {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Enum(enum_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }

                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        if enum_id.equals(id) {
                            let lhs_enum = .get_enum(enum_id)
                            if args.size() != lhs_enum.generic_parameters.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_enum.generic_parameters[idx]
                                    rhs_type_id: args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    TypeVariable => {
                        let seen_type_id_string = generic_inferences.get(rhs_type_id_string)
                        if seen_type_id_string.has_value() {
                            if seen_type_id_string.value() != lhs_type_id_string {
                                .error(
                                    format(
                                        "Type mismatch: expected ‘{}’, but got ‘{}’"
                                        .type_name(lhs_type_id)
                                        .type_name(TypeId::from_string(seen_type_id_string.value()))
                                    )
                                    span
                                )
                                return false
                            }
                        } else {
                            generic_inferences.set(key: lhs_type_id_string, value: rhs_type_id_string)
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Struct(lhs_struct_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }

                match rhs_type {
                    GenericInstance(id, args) => {
                        if not lhs_struct_id.equals(id) {
                            .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                            return false
                        }

                        let lhs_struct = .get_struct(lhs_struct_id)
                        if args.size() != lhs_struct.generic_parameters.size() {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_struct.generic_parameters[idx]
                                rhs_type_id: args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }

                    }
                    TypeVariable => {
                        // If the call expects a generic type variable, let's see if we've already seen it
                        let seen_type_id_string = generic_inferences.get(rhs_type_id_string)
                        if seen_type_id_string.has_value() {
                            // We've seen this type variable assigned something before
                            // we should error if it's incompatible.

                            if seen_type_id_string.value() != lhs_type_id_string {
                                .error(
                                    format(
                                        "Type mismatch: expected ‘{}’, but got ‘{}’"
                                        .type_name(TypeId::from_string(seen_type_id_string.value()))
                                        .type_name(rhs_type_id)
                                    )
                                    span
                                )
                                return false
                            }
                        } else {
                            generic_inferences.set(key: lhs_type_id_string, value: rhs_type_id_string)
                        }
                    }
                    else => {
                        let rhs_type = .get_type(rhs_type_id)
                        if .is_subclass_of(ancestor_type_id: lhs_type_id, child_type_id: rhs_type_id) {
                            return true
                        }
                        
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            RawPtr(lhs_rawptr_type_id) => {
                if lhs_rawptr_type_id.equals(rhs_type_id) {
                    return true
                }

                if rhs_type is RawPtr(rhs_rawptr_type_id) {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_rawptr_type_id
                        rhs_type_id: rhs_rawptr_type_id
                        generic_inferences
                        span
                    ) {
                        // FIXME: maybe emit secondary error?
                        return false
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Reference(lhs_inner_type_id) => {
                if rhs_type is Reference(rhs_inner_type_id) {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_inner_type_id
                        rhs_type_id: rhs_inner_type_id
                        generic_inferences
                        span
                    ) {
                        // FIXME: maybe emit secondary error?
                        return false
                    }
                }
            }
            else => {
                if generic_inferences.map(rhs_type_id_string) != generic_inferences.map(lhs_type_id_string) {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
        }

        return true
    }

    function is_subclass_of(this, ancestor_type_id: TypeId, child_type_id: TypeId) -> bool {
        let ancestor_type = .get_type(ancestor_type_id)
        let child_type = .get_type(child_type_id)

        guard ancestor_type is Struct(ancestor_struct_id) else { return false }
        guard child_type is Struct(child_struct_id) else { return false }

        mut ancestor_struct = .get_struct(ancestor_struct_id)

        mut current_struct_id = child_struct_id

        loop {
            let current_struct = .get_struct(current_struct_id)
            if current_struct.super_struct_id.has_value() {
                if ancestor_struct_id.equals(current_struct.super_struct_id!) {
                    return true
                }
                current_struct_id = current_struct.super_struct_id!
            } else {
                return false
            }
        }

        return false
    }

    function substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: GenericInferences) throws -> TypeId => .program.substitute_typevars_in_type(type_id, generic_inferences, module_id: .current_module_id)

    function typecheck_block(mut this, anon parsed_block: ParsedBlock, parent_scope_id: ScopeId, safety_mode: SafetyMode, yield_type_hint: TypeId? = None) throws -> CheckedBlock {
        let parent_throws = .get_scope(parent_scope_id).can_throw
        let block_scope_id = .create_scope(parent_scope_id, can_throw: parent_throws, debug_name: "block")
        mut checked_block = CheckedBlock(
            statements: []
            scope_id: block_scope_id
            control_flow: BlockControlFlow::MayReturn
            yielded_type: TypeId::none()
            yielded_none: false
        )
        for parsed_statement in parsed_block.stmts.iterator() {
            if not checked_block.control_flow.is_reachable() {
                .error("Unreachable code", parsed_statement.span())
            }

            let checked_statement = .typecheck_statement(
                statement: parsed_statement
                scope_id: block_scope_id
                safety_mode
                type_hint: yield_type_hint
            )
            checked_block.control_flow = checked_block.control_flow.updated(.statement_control_flow(checked_statement))

            let yield_span: Span? = match parsed_statement {
                ParsedStatement::Yield(expr) => Some(expr.span())
                ParsedStatement::Guard(expr) => Some(expr.span())
                else => None
            }
            let checked_yield_expression: CheckedExpression? = match checked_statement {
                CheckedStatement::Yield(expr) => Some(expr)
                else => None
            }

            if yield_span.has_value() and checked_yield_expression.has_value() {
                let type_var_type_id = checked_yield_expression!.type()
                let type_ = .resolve_type_var(type_var_type_id , scope_id: block_scope_id)

                if checked_yield_expression! is OptionalNone {
                    checked_block.yielded_none = true
                }

                if checked_block.yielded_type.has_value() {
                    // TODO check types for compat
                    .check_types_for_compat(
                        lhs_type_id: checked_block.yielded_type.value()
                        rhs_type_id: type_
                        generic_inferences: &mut .generic_inferences
                        span: yield_span.value()
                    )
                } else {
                    checked_block.yielded_type = Some(type_)
                }
            }

            checked_block.statements.push(checked_statement)
        }

        if checked_block.yielded_type.has_value() {
            checked_block.yielded_type = Some(.substitute_typevars_in_type(
                type_id: checked_block.yielded_type.value()
                generic_inferences: .generic_inferences
            ))
        }

        return checked_block
    }

    function typecheck_typename(mut this, parsed_type: ParsedType, scope_id: ScopeId, name: String?) throws -> TypeId => match parsed_type {
        Reference(inner) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)
            yield .find_or_add_type_id(Type::Reference(id: inner_type_id))
        }
        MutableReference(inner) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)
            yield .find_or_add_type_id(Type::MutableReference(id: inner_type_id))
        }
        NamespacedName(name, namespaces, params, span) => {
            mut current_namespace_scope_id = scope_id

            for ns in namespaces.iterator() {
                let result = .find_namespace_in_scope(scope_id: current_namespace_scope_id, name: ns)

                if result.has_value() {
                    current_namespace_scope_id = result!.0
                } else {
                    .error(format("Unknown namespace: '{}'", ns), span)
                    return unknown_type_id()
                }
            }

            mut generic_args: [TypeId] = []

            for param in params.iterator() {
                let checked_arg = .typecheck_typename(parsed_type: param, scope_id, name)

                generic_args.push(checked_arg)
            }

            mut type_id: TypeId? = None
            if generic_args.is_empty() {
                let synthetic_typename = ParsedType::Name(name, span)
                // TODO: add and generic support
                type_id = .typecheck_typename(parsed_type: synthetic_typename, scope_id: current_namespace_scope_id, name)
            } else {
                type_id = .typecheck_generic_resolved_type(name, checked_inner_types: generic_args, scope_id: current_namespace_scope_id, span)
            }

            yield type_id!
        }
        Name(name, span) => {
            let maybe_type_and_scope = .find_type_scope(scope_id, name)
            if maybe_type_and_scope.has_value() {
                if not maybe_type_and_scope!.1.equals(.prelude_scope_id()) {
                    return maybe_type_and_scope!.0
                }
            }

            yield match name {
                "i8" => builtin(BuiltinType::I8)
                "i16" => builtin(BuiltinType::I16)
                "i32" => builtin(BuiltinType::I32)
                "i64" => builtin(BuiltinType::I64)
                "u8" => builtin(BuiltinType::U8)
                "u16" => builtin(BuiltinType::U16)
                "u32" => builtin(BuiltinType::U32)
                "u64" => builtin(BuiltinType::U64)
                "f32" => builtin(BuiltinType::F32)
                "f64" => builtin(BuiltinType::F64)
                "c_char" => builtin(BuiltinType::CChar)
                "c_int" => builtin(BuiltinType::CInt)
                "usize" => builtin(BuiltinType::Usize)
                "String" => builtin(BuiltinType::JaktString)
                "bool" => builtin(BuiltinType::Bool)
                "void" => builtin(BuiltinType::Void)
                "never" => builtin(BuiltinType::Never)
                else => {
                    if maybe_type_and_scope.has_value() {
                        return maybe_type_and_scope!.0
                    }

                    .error(format("Unknown type ‘{}’", name), span)
                    yield unknown_type_id()
                }
            }
        }
        Empty => {
            yield unknown_type_id()
        }
        JaktTuple(types, span) => {
            mut checked_types: [TypeId] = []
            for parsed_type in types.iterator() {
                checked_types.push(.typecheck_typename(parsed_type, scope_id, name))
            }
            let tuple_struct_id = .find_struct_in_prelude("Tuple")

            yield .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))
        }
        JaktArray(inner, span) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

            let array_struct_id = .find_struct_in_prelude("Array")

            yield .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))
        }
        Dictionary(key, value, span) => {
            let key_type_id = .typecheck_typename(parsed_type: key, scope_id, name)
            let value_type_id = .typecheck_typename(parsed_type: value, scope_id, name)

            let dict_struct_id = .find_struct_in_prelude("Dictionary")

            yield .find_or_add_type_id(Type::GenericInstance(id: dict_struct_id, args: [key_type_id, value_type_id]))
        }
        Set(inner, span) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

            let set_struct_id = .find_struct_in_prelude("Set")

            yield .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [inner_type_id]))
        }
        Optional(inner, span) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

            let optional_struct_id = .find_struct_in_prelude("Optional")

            yield .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [inner_type_id]))
        }
        WeakPtr(inner, span) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

            let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

            yield .find_or_add_type_id(Type::GenericInstance(id: weakptr_struct_id, args: [inner_type_id]))
        }
        RawPtr(inner, span) => {
            let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

            yield .find_or_add_type_id(Type::RawPtr(id: inner_type_id))
        }
        GenericType(name, generic_parameters, span) => {
            mut checked_inner_types: [TypeId] = []

            for inner_type in generic_parameters.iterator() {
                let inner_type_id = .typecheck_typename(parsed_type: inner_type, scope_id, name)
                checked_inner_types.push(inner_type_id)
            }

            yield .typecheck_generic_resolved_type(name, checked_inner_types, scope_id, span)
        }
        Function(params, can_throw, return_type, span) => {
            let function_name = match name.has_value() {
                true => name!
                else => (try format("lambda{}", .lambda_count++)) ?? ""
            }

            mut checked_params: [CheckedParameter] = []
            mut first = true

            let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
            defer {
                .generic_inferences.restore(old_generic_inferences)
            }

            for param in params.iterator() {
                checked_params.push(.typecheck_parameter(parameter: param, scope_id, first, this_arg_type_id: None, check_scope: None))
                first = false
            }

            let checked_function = CheckedFunction(
                name: function_name
                name_span: span
                visibility: CheckedVisibility::Public
                return_type_id: .typecheck_typename(parsed_type: return_type, scope_id, name: None)
                return_type_span: return_type.span()
                params: checked_params
                generics: FunctionGenerics(
                    base_scope_id: scope_id
                    base_params: checked_params
                    params: []
                    specializations: []
                )
                block: CheckedBlock(
                    statements: []
                    scope_id
                    control_flow: BlockControlFlow::MayReturn
                    yielded_type: None
                    yielded_none: false
                )
                can_throw
                type: FunctionType::Expression
                linkage: FunctionLinkage::Internal
                function_scope_id: scope_id
                struct_id: None
                is_instantiated: true
                parsed_function: None
                is_comptime: false
                is_virtual: false
                is_override: false
            )
            mut module = .current_module()
            let function_id = module.add_function(checked_function)

            mut param_type_ids: [TypeId] = []
            for param in checked_function.params.iterator() {
                param_type_ids.push(param.variable.type_id)
            }

            yield .find_or_add_type_id(Type::Function(
                params: param_type_ids
                can_throw
                return_type_id: checked_function.return_type_id
                pseudo_function_id: function_id
            ))
        }
    }

    function typecheck_generic_resolved_type(mut this, name: String, checked_inner_types: [TypeId], scope_id: ScopeId, span: Span) throws -> TypeId {
        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            return .find_or_add_type_id(Type::GenericInstance(id: struct_id!, args: checked_inner_types))
        }

        let enum_id = .program.find_enum_in_scope(scope_id, name)
        if enum_id.has_value() {
            return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id!, args: checked_inner_types))
        }

        .error(format("could not find {}", name), span)
        return unknown_type_id()
    }

    function typecheck_unary_operation(mut this, checked_expr: CheckedExpression, checked_op: CheckedUnaryOperator, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let expr_type_id = checked_expr.type()
        let expr_type = .get_type(expr_type_id)

        match checked_op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                if .is_integer(expr_type_id) {
                    if not checked_expr.is_mutable(program: .program) {
                        .error("Increment/decrement of immutable variable", span)
                    }
                } else {
                    .error("Increment/decrement of non-numeric value", span)
                }
            }
            LogicalNot | BitwiseNot => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            TypeCast(cast) => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: cast.type_id())
            }
            Negate => {
                return .typecheck_unary_negate(expr: checked_expr, span, type_id: expr_type_id)
            }
            Is | IsEnumVariant => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: builtin(BuiltinType::Bool))
            }
            RawAddress => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::RawPtr(expr_type_id)))
            }
            Reference => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::Reference(expr_type_id)))
            }
            MutableReference => {
                if not checked_expr.is_mutable(program: .program) {
                    .error("Cannot make mutable reference to immutable value", span)
                }
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::MutableReference(expr_type_id)))
            }
            Dereference => {
                match expr_type {
                    RawPtr(type_id) => {
                        if safety_mode is Safe {
                            .error("Dereference of raw pointer outside of unsafe block", span)
                        }
                        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id)
                    }
                    Reference(type_id) | MutableReference(type_id) => {
                        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id)
                    }
                    else => {
                        .error(format("Dereference of a non-pointer type ‘{}’", .type_name(expr_type_id)), span)
                    }
                }
            }
        }
        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
    }

    function typecheck_unary_negate(mut this, expr: CheckedExpression, span: Span, type_id: TypeId) throws -> CheckedExpression {
        if not .program.is_integer(type_id) or .program.is_signed(type_id) {
            return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
        }

        // Flipping the sign on a small enough unsigned constant is fine. We'll change the type to the signed variant.
        let flipped_sign_type = .get_type(type_id).flip_signedness()

        let constant = match expr {
            NumericConstant(val) => val
            else => {
                return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
            }
        }

        let number = constant.number_constant()!
        let raw_number = number.to_usize()
        let max_signed = Type::I64.max() as! usize;
        mut negated_number = 0;
        if raw_number == max_signed + 1 {
            negated_number = Type::I64.min()
        }
        if raw_number <= max_signed {
            negated_number = 0 - (raw_number as! i64)
        }
        let negated_number_constant = NumberConstant::Signed(negated_number as! i64)

        if raw_number > (max_signed + 1) or not negated_number_constant.can_fit_number(type_id: flipped_sign_type, program: .program) {
            .error(
                format(
                    "Negative literal -{} too small for type ‘{}’"
                    raw_number
                    .type_name(flipped_sign_type)
                )
                span
            )
            return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
        }

        let new_constant = match .get_type(flipped_sign_type) {
            I8 => CheckedNumericConstant::I8(negated_number as! i8)
            I16 => CheckedNumericConstant::I16(negated_number as! i16)
            I32 => CheckedNumericConstant::I32(negated_number as! i32)
            I64 => CheckedNumericConstant::I64(negated_number as! i64)
            else => {
                panic("Unreachable")
            }
        }

        return CheckedExpression::UnaryOp(expr: CheckedExpression::NumericConstant(val: new_constant, span, type_id), op: CheckedUnaryOperator::Negate, span, type_id: flipped_sign_type)
    }

    function typecheck_binary_operation(mut this, checked_lhs: CheckedExpression, op: BinaryOperator, checked_rhs: CheckedExpression, scope_id: ScopeId, span: Span) throws -> TypeId {
        let lhs_type_id = checked_lhs.type()
        let rhs_type_id = checked_rhs.type()

        let lhs_span = checked_lhs.span()
        let rhs_span = checked_rhs.span()

        mut type_id = checked_lhs.type()

        match op {
            NoneCoalescing | NoneCoalescingAssign => {
                // 1. LHS must be Optional<T>.
                // 2. RHS must be Optional<T> or T.
                // 3. Resulting type is Optional<T> or T, respectively.

                // if an assignment, the LHS must be a mutable variable.
                if op is NoneCoalescingAssign {
                    if checked_lhs is Var(var, span) {
                        if not var.is_mutable {
                            .error_with_hint(message: "left-hand side of ??= must be a mutable variable", span, hint: "This variable isn't marked as mutable", hint_span: var.definition_span)
                            return unknown_type_id()
                        }
                    } else {
                        .error(message: "left-hand side of ??= must be a mutable variable", span)
                        return unknown_type_id()
                    }
                }

                if .get_type(lhs_type_id) is GenericInstance(id, args)
                    and id.equals(.find_struct_in_prelude("Optional")) {
                    // Success: LHS is T? and RHS is T?.
                    if lhs_type_id.equals(rhs_type_id) {
                        return lhs_type_id
                    }

                    // Extract T from Optional<T>.
                    let inner_type_id = args[0]

                    if inner_type_id.equals(rhs_type_id) {
                        // Success: LHS is T? and RHS is T.
                        return inner_type_id
                    }
                } else {
                    .error_with_hint(format(
                        "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ), span,
                    "Left side of ?? must be an Optional but isn't",
                    lhs_span)
                }

                .error(format(
                    "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                    .type_name(lhs_type_id),
                    .type_name(rhs_type_id),
                ), span)

                return lhs_type_id
            }
            LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Equal | NotEqual => {
                if not lhs_type_id.equals(rhs_type_id) {
                    .error(format("Binary comparison between incompatible types ({} vs {})", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            LogicalAnd | LogicalOr => {
                if not lhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("left side of logical binary operation is not a boolean", lhs_span)
                }

                if not rhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("right side of logical binary operation is not a boolean", rhs_span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            Assign => {
                if not checked_lhs.is_mutable(program: .program) {
                    .error("Assignment to immutable variable", checked_lhs.span())
                    return lhs_type_id
                }
                if checked_rhs is OptionalNone(span, type_id) {
                    if .get_type(lhs_type_id) is GenericInstance(id, args) {
                        if id.equals(.find_struct_in_prelude("Optional")) {
                            return lhs_type_id
                        } else if not id.equals(.find_struct_in_prelude("WeakPtr")) {
                            .error("Cannot assign None to a non-optional type", span)
                        }
                    } else {
                        .error("Cannot assign None to a non-optional type", span)
                    }
                }

                let lhs_type = .get_type(lhs_type_id)
                if lhs_type is GenericInstance(id, args) {
                    if .program.get_struct(id).name == "Optional" and checked_rhs.type().equals(args[0]) {
                        return lhs_type_id
                    }
                    if .program.get_struct(id).name == "WeakPtr" and checked_rhs.type().equals(args[0]) {
                        return lhs_type_id
                    }
                }

                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format("Assignment between incompatible types (‘{}’ and ‘{}’)", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }
                return result.value_or(lhs_type_id)
            }
            AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign | BitwiseAndAssign | BitwiseOrAssign | BitwiseXorAssign | BitwiseLeftShiftAssign | BitwiseRightShiftAssign => {
                let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")

                if .get_type(lhs_type_id) is GenericInstance(id, args)
                    and id.equals(weak_ptr_struct_id)
                    and .get_type(args[0]) is Struct(struct_id: lhs_struct_id)
                    and .get_type(rhs_type_id) is Struct(struct_id: rhs_struct_id)
                    and lhs_struct_id.equals(rhs_struct_id) {
                    return lhs_type_id
                }
                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format(
                        "Assignment between incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ), span)
                }
                if not checked_lhs.is_mutable(program: .program) {
                    .error("Assignment to immutable variable", checked_lhs.span())
                }
            }
            Add | Subtract | Multiply | Divide | Modulo => {
                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format(
                        "Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ),
                    span)
                }

                type_id = lhs_type_id
            }
            else => {}
        }

        return type_id
    }

    function typecheck_statement(mut this, anon statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId? = None) throws -> CheckedStatement => match statement {
        Expression(expr, span) => CheckedStatement::Expression(expr: .typecheck_expression(expr, scope_id, safety_mode, type_hint: TypeId::none()), span)
        UnsafeBlock(block, span) => CheckedStatement::Block(block: .typecheck_block(block, parent_scope_id: scope_id, safety_mode: SafetyMode::Unsafe), span)
        Yield(expr, span) => CheckedStatement::Yield(expr: .typecheck_expression(expr, scope_id, safety_mode, type_hint: type_hint), span)
        Return(expr, span) => .typecheck_return(expr, span, scope_id, safety_mode)
        Block(block, span) => .typecheck_block_statement(parsed_block: block, scope_id, safety_mode, span)
        InlineCpp(block, span) => .typecheck_inline_cpp(block, span, safety_mode)
        Defer(statement, span) => .typecheck_defer(statement, scope_id, safety_mode, span)
        Loop(block, span) => .typecheck_loop(parsed_block: block, scope_id, safety_mode, span)
        Throw(expr, span) => .typecheck_throw(expr, scope_id, safety_mode, span)
        While(condition, block, span) => .typecheck_while(condition, block, scope_id, safety_mode, span)
        Continue(span) => CheckedStatement::Continue(span)
        Break(span) => CheckedStatement::Break(span)
        VarDecl(var, init, span) => .typecheck_var_decl(var, init, scope_id, safety_mode, span)
        DestructuringAssignment(vars, var_decl, span) => .typecheck_destructuring_assignment(vars, var_decl, scope_id, safety_mode, span)
        If(condition, then_block, else_statement, span) => .typecheck_if(condition, then_block, else_statement, scope_id, safety_mode, span)
        Garbage(span) => CheckedStatement::Garbage(span)
        For(iterator_name, name_span, range, block, span) => .typecheck_for(iterator_name,  name_span, range, block, scope_id, safety_mode, span)
        Guard(expr, else_block, remaining_code, span) => .typecheck_guard(expr, else_block, remaining_code, scope_id, safety_mode, span)
    }

    function typecheck_guard(mut this, expr: ParsedExpression, else_block: ParsedBlock, remaining_code: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut seen_scope_exit = false
        for statement in else_block.stmts.iterator() {
            match statement {
                Break | Continue | Return | Throw => {
                    seen_scope_exit = true
                    break
                }
                else => {}
            }
        }

        // Ensure that we don't use any bindings we shouldn't have access to
        let checked_else_block = .typecheck_block(block: else_block, parent_scope_id: scope_id, safety_mode)

        if not seen_scope_exit and checked_else_block.control_flow.may_return() {
            .error("Else block of guard must either `return`, `break`, `continue`, or `throw`", span) // FIXME: better span?
        }

        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(condition: expr, acc: None, then_block: remaining_code, else_statement: ParsedStatement::Block(block: else_block, span), span)
        let checked_condition = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: None, span)
        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", new_condition.span())
        }

        let checked_block = .typecheck_block(new_then_block!, parent_scope_id: scope_id, safety_mode)
        mut checked_else: CheckedStatement? = None
        if new_else_statement.has_value() {
            checked_else = .typecheck_statement(new_else_statement!, scope_id, safety_mode)
        }

        if checked_block.yielded_type.has_value() {
            return CheckedStatement::Yield(
                expr: CheckedExpression::Match(
                    expr: checked_condition,
                    match_cases: [
                        CheckedMatchCase::Expression(
                            expression: CheckedExpression::Boolean(val: true, span)
                            body: CheckedMatchBody::Expression(CheckedExpression::Block(block: checked_block, span, type_id: checked_block.yielded_type!))
                            marker_span: span
                        ),
                        CheckedMatchCase::CatchAll(
                            has_arguments: false
                            body: CheckedMatchBody::Block(checked_else_block)
                            marker_span: span
                        )
                    ]
                    span
                    type_id: checked_block.yielded_type!
                    all_variants_constant: false
                ),
                span
            )
        }

        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else, span)
    }

    function typecheck_for(mut this, iterator_name: String, name_span: Span, range: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let maybe_span = block.find_yield_span()
        if maybe_span.has_value() {
            .error("a 'for' loop block is not allowed to yield values", maybe_span!)
        }

        // Translate `for x in expr { body }` to
        // block {
        //     let (mutable) _magic = expr
        //     loop {
        //         let x = _magic.next()
        //         if not x.has_value() {
        //             break
        //         }
        //         let iterator_name = x!
        //         body
        //     }
        // }
        //
        // The only restrictions placed on the iterator are such:
        //     1- Must respond to .next(); the mutability of the iterator is inferred from .next()'s signature
        //     2- The result of .next() must be an Optional.

        let iterable_expr = .typecheck_expression(range, scope_id, safety_mode, type_hint: None)
        mut iterable_should_be_mutable = false

        let iterable_type = .program.get_type(iterable_expr.type())

        match iterable_type {
            TypeVariable => {
                // Since we're not sure, just make it mutable.
                iterable_should_be_mutable = true
            }
            GenericInstance(id, args) | Struct(id) => {
                let struct_ = .get_struct(id)
                let next_method_function_id = .find_function_in_scope(
                    parent_scope_id: struct_.scope_id,
                    function_name: "next"
                    )
                if not next_method_function_id.has_value() {
                    .error("Iterator must have a .next() method", range.span())
                } else {
                    let next_method_function = .get_function(next_method_function_id!)
                    // Check whether we need to make the iteratar mutable
                    if next_method_function.is_mutating() {
                        iterable_should_be_mutable = true
                    }
                }
            }
            else => {
                .error("Iterator must have a .next() method", name_span)
            }
        }

        let rewritten_statement = ParsedStatement::Block(
            block: ParsedBlock(
                stmts: [
                    // let (mutable) _magic = expr
                    ParsedStatement::VarDecl(
                        var: ParsedVarDecl(
                            name: "_magic",
                            parsed_type: ParsedType::Empty,
                            is_mutable: iterable_should_be_mutable,
                            inlay_span: None,
                            span: name_span
                        ),
                        init: range
                        span
                    )
                    // loop {
                    ParsedStatement::Loop(
                        block: ParsedBlock(
                            stmts: [
                                // let _magic_value = _magic.next()
                                ParsedStatement::VarDecl(
                                    var: ParsedVarDecl(
                                        name: "_magic_value",
                                        parsed_type: ParsedType::Empty,
                                        is_mutable: iterable_should_be_mutable,
                                        inlay_span: None,
                                        span: name_span
                                    ),
                                    init: ParsedExpression::MethodCall(
                                        expr: ParsedExpression::Var(
                                            name: "_magic",
                                            span: name_span
                                        ),
                                        call: ParsedCall(
                                            namespace_: [],
                                                name: "next",
                                                args: [],
                                            type_args: []
                                        ),
                                        is_optional: false
                                        span: name_span
                                    )
                                    span
                                ),
                                // if not _magic_value.has_value() {
                                ParsedStatement::If(
                                    condition: ParsedExpression::UnaryOp(
                                        expr: ParsedExpression::MethodCall(
                                            expr: ParsedExpression::Var(
                                                name: "_magic_value",
                                                span: name_span
                                            ),
                                            call: ParsedCall(
                                                namespace_: [],
                                                name: "has_value",
                                                args: [],
                                                type_args: []
                                            )
                                            is_optional: false
                                            span: name_span
                                        ),
                                        op: UnaryOperator::LogicalNot,
                                        span: name_span
                                    ),
                                    then_block: ParsedBlock(
                                        stmts: [
                                            // break
                                            ParsedStatement::Break(span)
                                        ]
                                    ),
                                    else_statement: None
                                    span
                                ),
                            // let iterator_name = _magic_value!
                            ParsedStatement::VarDecl(
                                var: ParsedVarDecl(
                                    name: iterator_name,
                                    parsed_type: ParsedType::Empty,
                                    // FIXME: loop variable mutability should be independent
                                    // of iterable mutability
                                    is_mutable: iterable_should_be_mutable,
                                    inlay_span: name_span,
                                    span: name_span
                                    ),
                                    init: ParsedExpression::ForcedUnwrap(
                                        expr: ParsedExpression::Var(
                                            name: "_magic_value",
                                            span: name_span
                                        )
                                        span: name_span
                                    )
                                    span
                            ),
                            ParsedStatement::Block(block, span)
                            ]
                        )
                        span
                    )
                ]
            )
            span
        )

        return .typecheck_statement(rewritten_statement, scope_id, safety_mode)
    }

    function expand_context_for_bindings(mut this, condition: ParsedExpression, acc: ParsedExpression?, then_block: ParsedBlock?, else_statement: ParsedStatement?, span: Span) throws -> (ParsedExpression, ParsedBlock?, ParsedStatement?) {
        match condition {
            BinaryOp(lhs, op, rhs) => {
                if op is LogicalAnd {
                    let (rhs_condition, rhs_then_block, rhs_else_statement) = .expand_context_for_bindings(condition: rhs, acc, then_block, else_statement, span)
                    mut accumulated_condition = rhs_condition
                    return .expand_context_for_bindings(condition: lhs, acc: accumulated_condition, then_block: rhs_then_block, else_statement: rhs_else_statement, span)
                }
            }
            UnaryOp(expr, op) => {
                match op {
                    IsEnumVariant(inner, bindings) => {
                        let unary_op_single_condition = ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(inner), span)
                        mut outer_if_stmts: [ParsedStatement] = []
                        for binding in bindings.iterator() {
                            let var = ParsedVarDecl(
                                name: binding.binding
                                parsed_type: ParsedType::Empty
                                is_mutable: false
                                inlay_span: None
                                span: binding.span
                            )
                            let enum_variant_arg = ParsedExpression::EnumVariantArg(expr, arg: binding, enum_variant: inner, span)
                            outer_if_stmts.push(ParsedStatement::VarDecl(var, init: enum_variant_arg, span))
                        }
                        mut inner_condition = condition
                        if then_block.has_value() {
                            if acc.has_value() {
                                inner_condition = acc!
                                outer_if_stmts.push(ParsedStatement::If(condition: inner_condition, then_block: then_block!, else_statement, span))
                            } else {
                                for stmt in then_block!.stmts.iterator() {
                                    outer_if_stmts.push(stmt)
                                }
                            }
                        }

                        let new_then_block = ParsedBlock(stmts: outer_if_stmts)
                        return .expand_context_for_bindings(condition: unary_op_single_condition, acc: None, then_block: new_then_block, else_statement, span)
                        
                    }
                    else => {}
                }
            }
            else => {}
        }
        mut base_condition = condition
        if acc.has_value() {
            base_condition = ParsedExpression::BinaryOp(lhs: condition, op: BinaryOperator::LogicalAnd, rhs: acc!, span)
        }
        return (base_condition, then_block, else_statement)
    }

    function typecheck_if(mut this, condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(condition, acc: None, then_block, else_statement, span)
        let checked_condition = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: None, span)

        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", new_condition.span())
        }

        let checked_block = .typecheck_block(new_then_block!, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("An 'if' block is not allowed to yield values", new_then_block!.find_yield_span()!)
        }

        mut checked_else: CheckedStatement? = None
        if new_else_statement.has_value() {
            checked_else = .typecheck_statement(new_else_statement!, scope_id, safety_mode)
        }
        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else, span)
    }

    function typecheck_destructuring_assignment(mut this, vars: [ParsedVarDecl], var_decl: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut var_decls: [CheckedStatement] = []
        let checked_tuple_var_decl = .typecheck_statement(statement: var_decl, scope_id, safety_mode)
        mut expr_type_id: TypeId = unknown_type_id()
        mut tuple_var_id = VarId(module: ModuleId(id: 0), id: 0)
        if checked_tuple_var_decl is VarDecl(var_id, init) {
            expr_type_id = init.type()
            tuple_var_id = var_id
        } else {
            .error("Destructuting assignment should be a variable declaration", span)
        }

        mut inner_types: [TypeId] = []
        let tuple_type = .get_type(expr_type_id)
        if tuple_type is GenericInstance(args) {
            inner_types = args
        } else {
            .error("Tuple Type should be Generic Instance", span)
        }
        let tuple_variable = .program.get_variable(tuple_var_id)
        if vars.size() == inner_types.size() {
            for i in 0..vars.size() {
                mut new_var = vars[i]
                new_var.parsed_type = ParsedType::Name(name: .type_name(inner_types[i]), span)
                let init = ParsedExpression::IndexedTuple(
                    expr: ParsedExpression::Var(name: tuple_variable.name, span)
                    index: i
                    is_optional: false
                    span)
                var_decls.push(.typecheck_var_decl(var: vars[i], init, scope_id, safety_mode, span))
            }
        } else {
            .error("Tuple inner types sould have same size as tuple members", span)
        }

        return CheckedStatement::DestructuringAssignment(vars: var_decls, var_decl: checked_tuple_var_decl, span)
    }

    function typecheck_var_decl(mut this, var: ParsedVarDecl, init: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut lhs_type_id = .typecheck_typename(parsed_type: var.parsed_type, scope_id, name: var.name)
        mut checked_expr = .typecheck_expression(expr: init, scope_id, safety_mode, type_hint: lhs_type_id)
        let rhs_type_id = checked_expr.type()

        if rhs_type_id.equals(void_type_id()) {
            .error("Cannot assign `void` to a variable", checked_expr.span())
        }

        if lhs_type_id.equals(unknown_type_id()) and not rhs_type_id.equals(unknown_type_id()) {
            lhs_type_id = rhs_type_id
        }

        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let optional_struct_id = .find_struct_in_prelude("Optional")

        let lhs_type = .get_type(lhs_type_id)

        .check_that_type_doesnt_contain_reference(type_id: lhs_type_id, span)
        
        if checked_expr is OptionalNone(span, type_id) {
            if lhs_type is GenericInstance(id, args) {
                if not (id.equals(optional_struct_id) or id.equals(weak_ptr_struct_id)) {
                    .error("Cannot assign None to a non-optional type", span)
                }
            } else {
                .error("Cannot assign None to a non-optional type", span)
            }
        }

        if lhs_type is GenericInstance(id, args) {
            if id.equals(weak_ptr_struct_id) {
                if not var.is_mutable {
                    .error("Weak reference must be mutable", var.span)
                }
                if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            } else if id.equals(optional_struct_id) {
                if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            } else {
                if not lhs_type_id.equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            }
        } else if lhs_type.is_builtin() {
            let number_constant = checked_expr.to_number_constant(program: .program)

            mut is_rhs_zero = false
            if number_constant.has_value() {
                is_rhs_zero = match number_constant! {
                    Signed(value) => value == 0
                    Unsigned(value) => value == 0
                    Floating(value) => value == 0.0
                }
            }

            if not (.is_numeric(lhs_type_id) and is_rhs_zero) and (.is_integer(lhs_type_id) ^ .is_integer(rhs_type_id)) {
                .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                return CheckedStatement::Garbage(span)
            }
        } else {
            if not lhs_type_id.equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
            }
        }

        let checked_var = CheckedVariable(
            name: var.name
            type_id: lhs_type_id
            is_mutable: var.is_mutable
            definition_span: var.span
            type_span: None
            visibility: CheckedVisibility::Public
        )

        if .dump_type_hints and var.inlay_span.has_value() {
            .dump_type_hint(type_id: lhs_type_id, span: var.inlay_span!)
        }

        mut module = .current_module()
        let var_id = module.add_variable(checked_var)
        .add_var_to_scope(scope_id, name: var.name, var_id, span: checked_var.definition_span)

        return CheckedStatement::VarDecl(var_id, init: checked_expr, span)
    }

    function typecheck_while(mut this, condition: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression_and_dereference_if_needed(condition, scope_id, safety_mode, type_hint: None, span)
        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘while’ block is not allowed to yield values", block.find_yield_span()!)
        }

        return CheckedStatement::While(condition: checked_condition, block: checked_block, span)
    }

    function typecheck_try_block(mut this, stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "try")
        let checked_stmt = .typecheck_statement(stmt, scope_id: try_scope_id, safety_mode)
        let error_struct_id = .find_struct_in_prelude("Error")
        let error_decl = CheckedVariable(
            name: error_name
            type_id: .get_struct(error_struct_id).type_id
            is_mutable: false
            definition_span: error_span
            type_span: None
            visibility: CheckedVisibility::Public
        )
        mut module = .current_module()
        let error_id = module.add_variable(name: error_decl)

        let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "catch")
        .add_var_to_scope(scope_id: catch_scope_id, name: error_name, var_id: error_id, span: error_span)
        let checked_catch_block = .typecheck_block(catch_block, parent_scope_id: catch_scope_id, safety_mode)

        if checked_catch_block.yielded_type.has_value() {
            .error("A ‘catch’ block as part of a try block is not allowed to yield values", catch_block.find_yield_span()!)
        }

        return CheckedExpression::TryBlock(stmt: checked_stmt, catch_block: checked_catch_block, error_name, error_span, span, type_id: void_type_id())
    }

    function typecheck_try(mut this, expr: ParsedExpression, catch_block: ParsedBlock?, catch_name: String?, scope_id: ScopeId, safety_mode: SafetyMode, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint)
        let error_struct_id = .find_struct_in_prelude("Error")
        mut module = .current_module()
        mut checked_catch_block: CheckedBlock? = None
        let expression_type_id = checked_expr.type()

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let optional_type = Type::GenericInstance(id: optional_struct_id, args: [expression_type_id])
        let optional_type_id = .find_or_add_type_id(optional_type)
        mut type_id = optional_type_id

        if catch_block.has_value() {
            let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "catch")
            if catch_name.has_value() {
                let error_struct_id = .find_struct_in_prelude("Error")
                let error_decl = CheckedVariable(
                    name: catch_name!
                    type_id: .get_struct(error_struct_id).type_id
                    is_mutable: false
                    definition_span: span
                    type_span: None
                    visibility: CheckedVisibility::Public
                )
                mut module = .current_module()
                let error_id = module.add_variable(name: error_decl)
                .add_var_to_scope(scope_id: catch_scope_id, name: catch_name!, var_id: error_id, span)
            }

            let block = .typecheck_block(catch_block!, parent_scope_id: catch_scope_id, safety_mode)
            if block.control_flow.always_transfers_control() or block.yielded_type.has_value() {
                if not (block.yielded_type ?? expression_type_id).equals(expression_type_id) {
                    .error_with_hint(
                        message: format("Expected a value of type ‘{}’, but got ‘{}’", .type_name(expression_type_id), .type_name(block.yielded_type!)),
                        span
                        hint: format("Expression 'catch' block must either yield the same type as the expression it is catching, or yield nothing"),
                        hint_span: span
                    )
                } else {
                    type_id = block.yielded_type ?? expression_type_id
                }
            }
            checked_catch_block = block
        }

        return CheckedExpression::Try(expr: checked_expr, catch_block: checked_catch_block, catch_name, span, type_id, inner_type_id: expression_type_id)
    }

    function typecheck_throw(mut this, expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)

        let error_type_id = .find_type_in_prelude("Error")
        if not checked_expr.type().equals(error_type_id) {
            .error("throw expression does not produce an error", expr.span())
        }

        let scope = .get_scope(scope_id)
        if not scope.can_throw {
            .error("Throw statement needs to be in a try statement or a function marked as throws", expr.span())
        }

        return CheckedStatement::Throw(expr: checked_expr, span)
    }

    function typecheck_loop(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘loop’ block is not allowed to yield values", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Loop(block: checked_block, span)
    }

    function typecheck_defer(mut this, statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let was_inside_defer = .inside_defer
        .inside_defer = true
        defer .inside_defer = was_inside_defer
        let checked_statement = .typecheck_statement(statement, scope_id, safety_mode)
        if checked_statement is Block(block) and block.yielded_type.has_value() {
            .error("‘yield’ inside ‘defer’ is meaningless", span)
        }
        return CheckedStatement::Defer(statement: checked_statement, span)
    }

    function typecheck_block_statement(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A block used as a statement cannot yield values, as the value cannot be observed in any way", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Block(block: checked_block, span)
    }

    function typecheck_inline_cpp(mut this, block: ParsedBlock, span: Span, safety_mode: SafetyMode) throws -> CheckedStatement {
        if safety_mode is Safe {
            .error("Use of inline cpp block outside of unsafe block", span)
        }

        mut strings: [String] = []
        for statement in block.stmts.iterator() {
            if statement is Expression(expr)
                and expr is QuotedString(val, span) {
                strings.push(val)
            } else {
                .error("Expected block of strings", span)
            }
        }

        return CheckedStatement::InlineCpp(lines: strings, span)
    }

    function typecheck_return(mut this, expr: ParsedExpression?, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        if .inside_defer {
            .error("‘return’ is not allowed inside ‘defer’", span)
        }
        if not expr.has_value() {
            if .current_function_id.has_value() {
                let current_function = .get_function(.current_function_id!)
                let return_type = .get_type(current_function.return_type_id)
                if (not return_type is Void) and (not return_type is Unknown) {
                    .error_with_hint(format("’return’ with no value in function ’{}’ returning ’{}’",
                                            current_function.name,
                                            .type_name(current_function.return_type_id)),
                                    span,
                                    format("Add return value of type ’{}’ here", .type_name(current_function.return_type_id)), span)
                }
            }
            return CheckedStatement::Return(val: None, span)
        }

        if not (.current_function_id.has_value() and .get_function(.current_function_id!).is_comptime) and expr! is Function {
            .error("Returning a function is not currently supported", span)
        }

        mut type_hint: TypeId? = None
        if .current_function_id.has_value() {
            type_hint = Some(.get_function(.current_function_id!).return_type_id)
        }

        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(condition: expr!, acc: None, then_block: None, else_statement: None, span)
        let checked_expr = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint, span)

        return CheckedStatement::Return(val: checked_expr, span)
    }

    function typecheck_expression_and_dereference_if_needed(mut this, anon expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?, span: Span) throws -> CheckedExpression {
        mut checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint)
        match .get_type(checked_expr.type()) {
            Reference(type_id) | MutableReference(type_id) => {
                checked_expr = CheckedExpression::UnaryOp(
                    expr: checked_expr
                    op: CheckedUnaryOperator::Dereference
                    span: span
                    type_id
                )
            }
            else => {}
        }

        return checked_expr
    }

    function typecheck_indexed_struct(mut this, expr: ParsedExpression, field_name: String, scope_id: ScopeId, is_optional: bool, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
        let checked_expr_type_id = checked_expr.type()
        let checked_expr_type = .get_type(checked_expr_type_id)
        let optional_struct_id = .find_struct_in_prelude("Optional")
        match checked_expr_type {
            Type::GenericInstance(id, args) => {
                mut type_id = checked_expr_type_id

                if is_optional {
                    if not id.equals(optional_struct_id) {
                        .error("Optional chaining is only allowed on optional types", span)
                        return CheckedExpression::IndexedStruct(
                            expr: checked_expr
                            index: field_name
                            span
                            is_optional
                            type_id: unknown_type_id())
                    }

                    type_id = args[0]
                }

                match .get_type(type_id) {
                    GenericInstance(id: struct_id) | Struct(struct_id) => {
                        let structure = .get_struct(struct_id)
                        for field in structure.fields.iterator() {
                            let member = .get_variable(field.variable_id)

                            if member.name == field_name {
                                mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                                if is_optional {
                                    resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                                }
                                // FIXME: Unify with type
                                .check_member_access(accessor: scope_id, accessee: structure.scope_id, member, span)
                                return CheckedExpression::IndexedStruct(
                                    expr: checked_expr
                                    index: field_name
                                    span
                                    is_optional
                                    type_id: resolved_type_id)
                            }
                        }

                        .error(format("unknown member of struct: {}.{}", structure.name, field_name), span)
                    }
                    GenericEnumInstance(id: enum_id) | Enum(enum_id) => {
                        let enum_ = .get_enum(enum_id)
                        for field in enum_.fields.iterator() {
                            let member = .get_variable(field.variable_id)

                            if member.name == field_name {
                                mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                                if is_optional {
                                    resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                                }
                                // FIXME: Unify with type
                                .check_member_access(accessor: scope_id, accessee: enum_.scope_id, member, span)
                                return CheckedExpression::IndexedCommonEnumMember(
                                    expr: checked_expr
                                    index: field_name
                                    span
                                    is_optional
                                    type_id: resolved_type_id)
                            }
                        }

                        .error(format("unknown common member of enum: {}.{}", enum_.name, field_name), span)
                    }
                    else => .error(format("Member field access on value of non-struct type ‘{}’", .type_name(checked_expr_type_id)), span)
                }
            }
            Type::Struct(struct_id) => {
                if is_optional {
                    .error("Optional chaining is not allowed on non-optional types", span)
                }

                let structure = .get_struct(struct_id)

                let field_record = .lookup_struct_field(struct_id, name: field_name)
                if field_record.has_value() {
                    let member = .get_variable(field_record!.field_id)
                    let resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                    // FIXME: Unify with type
                    .check_member_access(accessor: scope_id, accessee: .get_struct(field_record!.struct_id).scope_id, member, span)
                    return CheckedExpression::IndexedStruct(
                        expr: checked_expr
                        index: field_name
                        span
                        is_optional
                        type_id: resolved_type_id)
                }

                .error(format("unknown member of struct: {}.{}", structure.name, field_name), span)
            }
            Type::GenericEnumInstance(id: enum_id) | Type::Enum(enum_id) => {
                if is_optional {
                    .error("Optional chaining is not allowed on non-optional types", span)
                }

                let enum_ = .get_enum(enum_id)
                for field in enum_.fields.iterator() {
                    let member = .get_variable(field.variable_id)

                    if member.name == field_name {
                        mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                        if is_optional {
                            resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                        }
                        // FIXME: Unify with type
                        .check_member_access(accessor: scope_id, accessee: enum_.scope_id, member, span)
                        return CheckedExpression::IndexedCommonEnumMember(
                            expr: checked_expr
                            index: field_name
                            span
                            is_optional
                            type_id: resolved_type_id)
                    }
                }

                .error(format("unknown common member of enum: {}.{}", enum_.name, field_name), span)
            }
            else => .error(format("Member field access on value of non-struct type ‘{}’", .type_name(checked_expr_type_id)), span)
        }

        // FIXME: Unify with type
        return CheckedExpression::IndexedStruct(
            expr: checked_expr
            index: field_name
            span
            is_optional
            type_id: unknown_type_id())
    }

    function typecheck_indexed_tuple(mut this, expr: ParsedExpression, index: usize, scope_id: ScopeId, is_optional: bool, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)

        let tuple_struct_id = .find_struct_in_prelude("Tuple")
        let optional_struct_id = .find_struct_in_prelude("Optional")
        mut expr_type_id = unknown_type_id()

        if .get_type(checked_expr.type()) is GenericInstance(id, args) {
            if id.equals(tuple_struct_id) {
                if is_optional {
                    .error("Optional chaining is not allowed on a non-optional tuple type", span)
                }
                if (index >= args.size()){
                    .error("Tuple index past the end of the tuple", span)
                } else {
                    expr_type_id = args[index]
                }
            } else if is_optional and id.equals(optional_struct_id) {
                let inner_type_id = args[0]
                if .get_type(inner_type_id) is GenericInstance(id, args) {
                    if id.equals(tuple_struct_id) {
                        if (index >= args.size()){
                            .error("Optional-chained tuple index past the end of the tuple", span)
                        } else {
                            expr_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [args[index]]))
                        }
                    }
                } else {
                    .error("Optional-chained tuple index used on non-tuple value", span)
                }
            }
        } else if is_optional {
            .error("Optional-chained tuple index used on non-tuple value", span)
        } else {
            .error("Tuple index used on non-tuple value", span)
        }

        return CheckedExpression::IndexedTuple(
            expr: checked_expr
            index: index
            span
            is_optional
            type_id: expr_type_id)
    }

    function check_member_access(mut this, accessor: ScopeId, accessee: ScopeId, member: CheckedVariable, span: Span) throws {
        match member.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    .error(format("Can't access field ‘{}’, because it is marked private", member.name), span)
                }
            }
            Restricted(scopes) => {
                .check_restricted_access(accessor, accessee_kind: "field", accessee, name: member.name, whitelist: scopes, span)
            }
            else => {}
        }
    }

    function check_method_access(mut this, accessor: ScopeId, accessee: ScopeId, method: CheckedFunction, span: Span) throws {
        match method.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    if not method.type is Normal {
                        .error_with_hint(format("Can't access constructor ‘{}’, because it is marked private", method.name)
                            span
                            hint: "Private constructors are created if any fields are private"
                            span
                        )
                    } else {
                        .error(format("Can't access method ‘{}’, because it is marked private", method.name), span)
                    }
                }
            }
            Restricted(scopes) => {
                .check_restricted_access(accessor, accessee_kind: "function", accessee, name: method.name, whitelist: scopes, span)
            }
            else => {}
        }
    }

    function check_restricted_access(mut this, accessor: ScopeId, accessee_kind: String, accessee: ScopeId, name: String, whitelist: [MaybeResolvedScope], span: Span) throws -> bool {
        let most_specific_active_scope_id = match .current_function_id.has_value() {
            true => .get_function(.current_function_id!).function_scope_id
            else => {
                if not .current_struct_type_id.has_value() {
                    .error(
                        format(
                            "Can't access {0} ‘{1}’ from this global scope, because ‘{1}’ restricts access to it"
                            accessee_kind
                            name
                        )
                        span
                    )
                    return false
                }
                yield match .get_type(.current_struct_type_id!) {
                    Struct(id) => .get_struct(id).scope_id
                    else => {
                        panic(format("Internal error: current_struct_type_id is not a struct", span))
                    }
                }
            }
        }

        for scope in whitelist.iterator() {
            let resolved_scope = scope.try_resolve(program: .program)
            guard resolved_scope is Resolved(scope_id) else {
                continue
            }

            if .scope_can_access(accessor: most_specific_active_scope_id, accessee: scope_id) {
                return true
            }
        }

        let scope = .get_scope(most_specific_active_scope_id)
        .error(
            format(
                "Cannot access {} ‘{}’ from this scope"
                accessee_kind
                name
            )
            span
        )
        return false
    }

    function infer_signed_int(mut this, val: i64, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        mut expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
        if type_hint.has_value() {
            let hint = type_hint!

            if hint.equals(builtin(BuiltinType::I8)) {
                let builtin_typeid = builtin(BuiltinType::I8)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val as! i8), span, type_id: builtin(BuiltinType::I8))
                }
            } else if hint.equals(builtin(BuiltinType::I16)) {
                let builtin_typeid = builtin(BuiltinType::I16)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val as! i16), span, type_id: builtin(BuiltinType::I16))
                }
            } else if hint.equals(builtin(BuiltinType::I32)) {
                let builtin_typeid = builtin(BuiltinType::I32)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                        .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val as! i32), span, type_id: builtin(BuiltinType::I32))
                }
            } else if hint.equals(builtin(BuiltinType::U8)) {
                let builtin_typeid = builtin(BuiltinType::U8)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                        .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::U8))
                }
            } else if hint.equals(builtin(BuiltinType::U16)) {
                let builtin_typeid = builtin(BuiltinType::U16)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val as! u16), span, type_id: builtin(BuiltinType::U16))
                }
            } else if hint.equals(builtin(BuiltinType::U32)) {
                let builtin_typeid = builtin(BuiltinType::U32)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val as! u32), span, type_id: builtin(BuiltinType::U32))
                }
            } else if hint.equals(builtin(BuiltinType::U64)) {
                let builtin_typeid = builtin(BuiltinType::Usize)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val as! u64), span, type_id: builtin(BuiltinType::U64))
                }
            } else if hint.equals(builtin(BuiltinType::Usize)) {
                let builtin_typeid = builtin(BuiltinType::Usize)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::Usize))
                }
            } else if hint.equals(builtin(BuiltinType::CInt)) {
                let builtin_typeid = builtin(BuiltinType::CInt)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::CInt))
                }
            } else if hint.equals(builtin(BuiltinType::CChar)) {
                let builtin_typeid = builtin(BuiltinType::CChar)
                let type_ = .get_type(builtin_typeid)
                if val < 0 or val > 255 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::CChar))
                }
            }
        }
        return expr
    }

    function infer_unsigned_int(mut this, val: u64, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        mut expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
        if type_hint.has_value() {
            let hint = type_hint!

            if hint.equals(builtin(BuiltinType::I8)) {
                let builtin_typeid = builtin(BuiltinType::I8)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val as! i8), span, type_id: builtin(BuiltinType::I8))
                }
            } else if hint.equals(builtin(BuiltinType::I16)) {
                let builtin_typeid = builtin(BuiltinType::I16)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val as! i16), span, type_id: builtin(BuiltinType::I16))
                }
            } else if hint.equals(builtin(BuiltinType::I32)) {
                let builtin_typeid = builtin(BuiltinType::I32)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val as! i32), span, type_id: builtin(BuiltinType::I32))
                }
            } else if hint.equals(builtin(BuiltinType::U8)) {
                let builtin_typeid = builtin(BuiltinType::U8)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::U8))
                }
            } else if hint.equals(builtin(BuiltinType::U16)) {
                let builtin_typeid = builtin(BuiltinType::U16)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val as! u16), span, type_id: builtin(BuiltinType::U16))
                }
            } else if hint.equals(builtin(BuiltinType::U32)) {
                let builtin_typeid = builtin(BuiltinType::U32)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val as! u32), span, type_id: builtin(BuiltinType::U32))
                }
            } else if hint.equals(builtin(BuiltinType::U64)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val as! u64), span, type_id: builtin(BuiltinType::U64))
            } else if hint.equals(builtin(BuiltinType::Usize)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::Usize))
            } else if hint.equals(builtin(BuiltinType::CInt)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::CInt))
            } else if hint.equals(builtin(BuiltinType::CChar)) {
                let builtin_typeid = builtin(BuiltinType::CChar)
                let type_ = .get_type(builtin_typeid)
                if val > 255 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::CChar))
                }
            }
        }
        return expr
    }

    function typecheck_expression(mut this, anon expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression => match expr {
        IndexedStruct(expr, field_name, span, is_optional) => .typecheck_indexed_struct(expr, field_name, scope_id, is_optional, safety_mode, span)
        Boolean(val, span) => CheckedExpression::Boolean(val, span)
        NumericConstant(val, span) => {
            mut type_hint_unwrapped = type_hint
            if type_hint.has_value() and .get_type(type_hint!) is GenericInstance(id, args) {
                let optional_struct_id = .find_struct_in_prelude("Optional")
                if id.equals(optional_struct_id) {
                    type_hint_unwrapped = args[0]
                }
            }

            yield match val {
                I8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val), span, type_id: builtin(BuiltinType::I8))
                I16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val), span, type_id: builtin(BuiltinType::I16))
                I32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val), span, type_id: builtin(BuiltinType::I32))
                I64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
                U8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val), span, type_id: builtin(BuiltinType::U8))
                U16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val), span, type_id: builtin(BuiltinType::U16))
                U32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val), span, type_id: builtin(BuiltinType::U32))
                U64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
                USize(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val), span, type_id: builtin(BuiltinType::Usize))
                F32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F32(val), span, type_id: builtin(BuiltinType::F32))
                F64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F64(val), span, type_id: builtin(BuiltinType::F64))
                UnknownSigned(val) => .infer_signed_int(val, span, type_hint: type_hint_unwrapped)
                UnknownUnsigned(val) => .infer_unsigned_int(val, span, type_hint: type_hint_unwrapped)
            }
        }
        SingleQuotedString(val, span) => CheckedExpression::CharacterConstant(val, span)
        SingleQuotedByteString(val, span) => CheckedExpression::ByteConstant(val, span)
        QuotedString(val, span) => {
            if .dump_try_hints {
                .dump_try_hint(span)
            }
        
            .unify_with_type(found_type: builtin(BuiltinType::JaktString), expected_type: type_hint, rhs_span: span)
            yield CheckedExpression::QuotedString(val, span)
        }
        Call(call, span) => {
            yield .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: None, parent_id: None, safety_mode, type_hint, must_be_enum_constructor: false)
        }
        MethodCall(expr, call, span, is_optional) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            let checked_expr_type_id = checked_expr.type()
            mut found_optional = false

            let parent_id = match .get_type(checked_expr_type_id) {
                Struct(id) => Some(StructOrEnumId::Struct(id))
                Enum(id) => Some(StructOrEnumId::Enum(id))
                JaktString => Some(StructOrEnumId::Struct(.find_struct_in_prelude("String")))
                GenericInstance(id, args) => {
                    yield match is_optional {
                        true => {
                            let optional_struct_id = .find_struct_in_prelude("Optional")
                            mut struct_id: StructOrEnumId? = None
                            if not id.equals(optional_struct_id) {
                                .error(format("Can't use ‘{}’ as an optional type in optional chained call", .get_struct(id).name), span)
                            } else {
                                found_optional = true
                                struct_id = match .get_type(args[0]) {
                                    Struct(struct_id) | GenericInstance(id: struct_id) => StructOrEnumId::Struct(struct_id)
                                    Enum(id) | GenericEnumInstance(id) => StructOrEnumId::Enum(id)
                                    else => {
                                        .error("Can't use non-struct type as an optional type in optional chained call", span)
                                        found_optional = false
                                        yield StructOrEnumId::Struct(optional_struct_id)
                                    }
                                }
                            }

                            yield Some(struct_id ?? StructOrEnumId::Struct(optional_struct_id))
                        }
                        else => Some(StructOrEnumId::Struct(id))
                    }
                }
                GenericEnumInstance(id) => Some(StructOrEnumId::Enum(id))
                else => {
                    .error(message: format("no methods available on value (type: {})", .type_name(type_id: checked_expr_type_id)), span: checked_expr.span())
                    let none: StructOrEnumId? = None

                    yield none
                }
            }

            if is_optional and not found_optional {
                .error(message: format("Optional chain mismatch: expected optional chain, found {}", .type_name(type_id: checked_expr_type_id)), span: checked_expr.span())
            }

            let checked_call_expr = .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: checked_expr, parent_id, safety_mode, type_hint, must_be_enum_constructor: false)
            let type_id = checked_call_expr.type()
            yield match checked_call_expr {
                Call(call) => {
                    mut result_type = call.return_type
                    if is_optional {
                        let optional_struct_id = .find_struct_in_prelude("Optional")
                        result_type = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [result_type]))
                    }
                    yield CheckedExpression::MethodCall(
                        expr: checked_expr
                        call
                        span
                        is_optional
                        type_id: result_type)
                }
                else => {
                    .compiler.panic("typecheck_call should return `CheckedExpression::Call()`")
                }
            }
        }
        Range(from, to, span) => {
            mut checked_from: CheckedExpression? = None
            mut from_type: TypeId? = None;
            mut from_span = span

            if from.has_value() and not from! is NumericConstant(val: UnknownSigned) and not from! is NumericConstant(val: UnknownUnsigned) {
                checked_from = .typecheck_expression(from!, scope_id, safety_mode, type_hint: None)
                from_type = checked_from!.type()
                from_span = checked_from!.span()
            }

            mut checked_to: CheckedExpression? = None
            mut to_type = unknown_type_id();
            mut to_span = span

            if to.has_value() {
                checked_to = .typecheck_expression(to!, scope_id, safety_mode, type_hint: from_type)
                to_type = checked_to!.type()
                to_span = checked_to!.span()
            }

            if from.has_value() and (from! is NumericConstant(val: UnknownSigned) or from! is NumericConstant(val: UnknownUnsigned)) {
                // recheck the first value with the hint we get from the rhs
                checked_from = .typecheck_expression(from!, scope_id, safety_mode, type_hint: to_type)
                from_type = checked_from!.type()
                from_span = checked_from!.span()
            }

            mut values_type_id: TypeId? = None
            if from.has_value() and to.has_value() {
                values_type_id = .unify(lhs: from_type!, lhs_span: from_span, rhs: to_type, rhs_span: from_span)
                if not values_type_id.has_value() {
                    .error("Range values differ in types", span)
                }
            } else if from.has_value() {
                values_type_id = from_type
            } else if to.has_value() {
                values_type_id = to_type
            }

            let range_struct_id = .find_struct_in_prelude("Range")
            let range_type = Type::GenericInstance(
                id: range_struct_id,
                args: [values_type_id.value_or(builtin(BuiltinType::I64))]
            )

            let type_id = .find_or_add_type_id(range_type)

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id)
        }
        UnaryOp(expr, op, span) => {
            let checked_expr = match op {
                Dereference => .typecheck_expression(expr, scope_id, safety_mode, type_hint: None)
                else => .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            }

            let checked_op = match op {
                PreIncrement => CheckedUnaryOperator::PreIncrement
                PostIncrement => CheckedUnaryOperator::PostIncrement
                PreDecrement => CheckedUnaryOperator::PreDecrement
                PostDecrement => CheckedUnaryOperator::PostDecrement
                Negate => CheckedUnaryOperator::Negate
                Dereference => CheckedUnaryOperator::Dereference
                RawAddress => CheckedUnaryOperator::RawAddress
                Reference => CheckedUnaryOperator::Reference
                MutableReference => CheckedUnaryOperator::MutableReference
                LogicalNot => CheckedUnaryOperator::LogicalNot
                BitwiseNot => CheckedUnaryOperator::BitwiseNot
                TypeCast(cast) => {
                    let type_id = .typecheck_typename(parsed_type: cast.parsed_type(), scope_id, name: None)
                    let checked_cast = match cast {
                        Fallible => {
                            let optional_struct_id = .find_struct_in_prelude("Optional")
                            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
                            let optional_type_id = .find_or_add_type_id(optional_type)
                            yield CheckedTypeCast::Fallible(optional_type_id)
                        }
                        Infallible => CheckedTypeCast::Infallible(type_id)
                    }
                    yield CheckedUnaryOperator::TypeCast(checked_cast)
                }
                Is(unchecked_type) => {
                    let old_ignore_errors = .ignore_errors
                    .ignore_errors = true
                    let type_id = .typecheck_typename(parsed_type: unchecked_type, scope_id, name: None)
                    .ignore_errors = old_ignore_errors

                    mut operator_is = CheckedUnaryOperator::Is(type_id)
                    if unchecked_type is Name(name) {
                        // Let's assume it's an enum variant
                        let expr_type_id = checked_expr.type()
                        if .get_type(expr_type_id) is Enum(enum_id) {
                            let enum_ = .get_enum(enum_id)
                            mut exists = false
                            for variant in enum_.variants.iterator() {
                                exists = match variant {
                                    StructLike(name: var_name) | Typed(name: var_name) | Untyped(name: var_name) => var_name == name
                                    else => false
                                }
                                if exists {
                                    operator_is = CheckedUnaryOperator::IsEnumVariant(enum_variant: variant, bindings: [], type_id: expr_type_id)
                                    break
                                }
                            }
                            if not exists and type_id.equals(unknown_type_id()) {
                                .error(format("Enum variant {} does not exist on {}", name, .type_name(expr_type_id)), span)
                            }
                        } else if type_id.equals(unknown_type_id()) {
                            .error(format("Unknown type or invalid type name: {}", name), span)
                        }
                    } else {
                        .error("The right-hand side of an `is` operator must be a type name or enum variant", span)
                    }

                    yield operator_is
                }
                IsEnumVariant(inner, bindings) => .typecheck_is_enum_variant(checked_expr, inner, bindings, scope_id)
            }
            yield .typecheck_unary_operation(checked_expr, checked_op, span, scope_id, safety_mode)
        }
        BinaryOp(lhs, op, rhs, span) => {
            mut checked_lhs: CheckedExpression? = None
            mut checked_rhs: CheckedExpression? = None
            if lhs is NumericConstant(val: UnknownSigned) or lhs is NumericConstant(val: UnknownUnsigned) {
                // If we have a constant on the lhs, infer starting the the right:
                checked_rhs = .typecheck_expression_and_dereference_if_needed(rhs, scope_id, safety_mode, type_hint: None, span)
                let hint = checked_rhs!.type()

                checked_lhs = .typecheck_expression_and_dereference_if_needed(lhs, scope_id, safety_mode, type_hint: hint, span)
            } else {
                checked_lhs = .typecheck_expression_and_dereference_if_needed(lhs, scope_id, safety_mode, type_hint: None, span)
                let hint = checked_lhs!.type()

                checked_rhs = .typecheck_expression_and_dereference_if_needed(rhs, scope_id, safety_mode, type_hint: hint, span)
            }

            let output_type = .typecheck_binary_operation(checked_lhs: checked_lhs!, op, checked_rhs: checked_rhs!, scope_id, span)

            yield CheckedExpression::BinaryOp(lhs: checked_lhs!, op, rhs: checked_rhs!, span, type_id: output_type)
        }
        OptionalNone(span) => {
            mut type_hint_unwrapped = type_hint
            if type_hint.has_value() and .get_type(type_hint!) is GenericInstance(id, args) {
                let optional_struct_id = .find_struct_in_prelude("Optional")
                if id.equals(optional_struct_id) {
                    type_hint_unwrapped = args[0]
                }
            }

            yield CheckedExpression::OptionalNone(span, type_id: type_hint_unwrapped ?? unknown_type_id())
        }
        OptionalSome(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: None)
            let type_id = checked_expr.type()
            let optional_struct_id = .find_struct_in_prelude("Optional")
            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
            let optional_type_id = .find_or_add_type_id(optional_type)
            yield CheckedExpression::OptionalSome(expr: checked_expr, span, type_id: optional_type_id)
        }
        Var(name, span) => {
            let var = .find_var_in_scope(scope_id, var: name)
            return match var.has_value() { // FIXME: this wants to be a match on Optional instead of boolean
                true => CheckedExpression::Var(var: var!, span)
                else => {
                    .error(format("Variable '{}' not found", name), span)
                    yield CheckedExpression::Var(
                        var: CheckedVariable(
                            name,
                            type_id: type_hint.value_or(unknown_type_id()),
                            is_mutable: false,
                            definition_span: span,
                            type_span: None
                            visibility: CheckedVisibility::Public),
                        span
                    )
                }
            }
        }
        ForcedUnwrap(expr, span) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            let type = .get_type(checked_expr.type())

            let optional_struct_id = .find_struct_in_prelude("Optional")
            let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

            let type_id: TypeId = match type {
                GenericInstance(id, args) => {
                    mut inner_type_id = unknown_type_id()
                    if  id.equals(optional_struct_id) or id.equals(weakptr_struct_id) {
                        inner_type_id = args[0]
                    } else {
                        .error("Forced unwrap only works on Optional", span)
                    }
                    yield inner_type_id
                }
                else => {
                    .error("Forced unwrap only works on Optional", span)
                    yield unknown_type_id()
                }
            }

            yield CheckedExpression::ForcedUnwrap(expr: checked_expr, span, type_id)
        }
        JaktArray(values, fill_size, span) => .typecheck_array(scope_id, values, fill_size, span, safety_mode, type_hint)
        JaktTuple(values, span) => {
            let VOID_TYPE_ID = builtin(BuiltinType::Void)
            mut checked_values: [CheckedExpression] = []
            mut checked_types: [TypeId] = []

            for value in values.iterator() {
                let checked_value= .typecheck_expression(value, scope_id, safety_mode, type_hint: None)
                let type_id = checked_value.type()
                if type_id.equals(VOID_TYPE_ID) {
                    .error("Cannot create a tuple that contains a value of type void", value.span())
                }
                checked_types.push(type_id)
                checked_values.push(checked_value)
            }

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

            // FIXME: Unify type

            if type_hint.has_value() {
                .check_types_for_compat(
                    lhs_type_id: type_hint!
                    rhs_type_id: type_id
                    generic_inferences: &mut .generic_inferences
                    span
                )
            }

            yield CheckedExpression::JaktTuple(vals: checked_values, span, type_id)
        }
        IndexedExpression(base, index, span) => {
            let checked_base = .typecheck_expression_and_dereference_if_needed(base, scope_id, safety_mode, type_hint: None, span)
            let checked_index = .typecheck_expression_and_dereference_if_needed(index, scope_id, safety_mode, type_hint: None, span)

            yield match .get_type(checked_base.type()) {
                GenericInstance(id, args) => {
                    let array_struct_id = .find_struct_in_prelude("Array")
                    let array_slice_struct_id = .find_struct_in_prelude("ArraySlice")
                    let dictionary_struct_id = .find_struct_in_prelude("Dictionary")

                    mut result = CheckedExpression::Garbage(span)
                    if id.equals(array_struct_id) or id.equals(array_slice_struct_id) {
                        if .is_integer(checked_index.type()) or checked_index is Range {
                            let type_id = match checked_index {
                                Range => {
                                    let array_slice_struct_id = .find_struct_in_prelude("ArraySlice")

                                    yield .find_or_add_type_id(Type::GenericInstance(id: array_slice_struct_id, args))
                                } else => args[0]
                            }

                            result = CheckedExpression::IndexedExpression(expr: checked_base, index: checked_index, span, type_id: type_id)
                        } else {
                            .error("Index must be an integer or a range", span)
                        }
                    } else if id.equals(dictionary_struct_id) {
                        result = CheckedExpression::IndexedDictionary(expr: checked_base, index: checked_index, span, type_id: args[1])
                    }
                    yield result
                }
                else => {
                    .error("Index used on value that cannot be indexed", span)
                    yield CheckedExpression::Garbage(span)
                }
            }
        }
        IndexedTuple(expr, index, is_optional, span) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            let optional_struct_id = .find_struct_in_prelude("Optional")
            mut expr_type_id = unknown_type_id()

            if .get_type(checked_expr.type()) is GenericInstance(id, args) {
                if id.equals(tuple_struct_id) {
                    if is_optional {
                        .error("Optional chaining is not allowed on a non-optional tuple type", span)
                    }
                    if (index >= args.size()){
                        .error("Tuple index past the end of the tuple", span)
                    } else {
                        expr_type_id = args[index]
                    }
                } else if is_optional and id.equals(optional_struct_id) {
                    let inner_type_id = args[0]
                    if .get_type(inner_type_id) is GenericInstance(id, args) {
                        if id.equals(tuple_struct_id) {
                            if (index >= args.size()){
                                .error("Optional-chained tuple index past the end of the tuple", span)
                            } else {
                                expr_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [args[index]]))
                            }
                        }
                    } else {
                        .error("Optional-chained tuple index used on non-tuple value", span)
                    }
                }
            } else if is_optional {
                .error("Optional-chained tuple index used on non-tuple value", span)
            } else {
                .error("Tuple index used on non-tuple value", span)
            }

            yield CheckedExpression::IndexedTuple(
                expr: checked_expr
                index: index
                span
                is_optional
                type_id: expr_type_id)
        }
        Garbage(span) => CheckedExpression::Garbage(span)
        NamespacedVar(name, namespace_, span) => .typecheck_namespaced_var_or_simple_enum_constructor_call(name, namespace_, scope_id, safety_mode, type_hint, span)
        Match(expr, cases, marker_span) => .typecheck_match(expr, cases, span: marker_span, scope_id, safety_mode, type_hint)
        EnumVariantArg(expr: inner_expr, arg, enum_variant, span) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(inner_expr, scope_id, safety_mode, type_hint: None, span)
            mut checked_binding = CheckedEnumVariantBinding(name: "", binding: "", type_id: unknown_type_id(), span)
            mut checked_enum_variant: CheckedEnumVariant? = None
            match enum_variant {
                NamespacedName(name: variant_name, span) | Name(name: variant_name, span) => match .get_type(checked_expr.type()) {
                    Type::Enum(enum_id) => {
                        let enum_ = .get_enum(enum_id)
                        let variant = .get_enum_variant(enum_, variant_name)
                        if variant.has_value() {
                            checked_enum_variant = variant
                            let checked_bindings = .typecheck_enum_variant_bindings(variant: variant!, bindings: [arg], span)
                            if checked_bindings.has_value() {
                                let bindings = checked_bindings!
                                checked_binding = bindings[0]
                            }
                        } else {
                            .error(format("Enum variant {} does not exist", variant_name), span)
                        }
                    }
                    else => {
                        .error(format("Unknown type or invalid type name: {}", variant_name), span)
                    }
                }
                else => {}
            }
            mut output = CheckedExpression::Garbage(span)
            if checked_enum_variant.has_value() {
                output = CheckedExpression::EnumVariantArg(expr: checked_expr, arg: checked_binding, enum_variant: checked_enum_variant!, span)
            }
            yield output
        }
        JaktDictionary(values, span) => .typecheck_dictionary(values, span, scope_id, safety_mode, type_hint)
        Set(values, span) => .typecheck_set(values, span, scope_id, safety_mode, type_hint)
        Function(captures, params, can_throw, is_fat_arrow, return_type, block, span) => .typecheck_lambda(captures, params, can_throw, is_fat_arrow, return_type, block, span, scope_id, safety_mode)
        Try(expr, catch_block, catch_name, span) => .typecheck_try(expr, catch_block, catch_name, scope_id, safety_mode, span, type_hint)
        TryBlock(stmt, catch_block, error_name, error_span, span) => .typecheck_try_block(stmt, error_name, error_span, catch_block, scope_id, safety_mode, span)
        Operator => {
            .compiler.panic("idk how to handle this thing")
        }
    }

    function typecheck_is_enum_variant(mut this, checked_expr: CheckedExpression, inner: ParsedType, bindings: [EnumVariantPatternArgument], scope_id: ScopeId) throws -> CheckedUnaryOperator {
        let old_ignore_errors = .ignore_errors
        .ignore_errors = true
        let type_id = .typecheck_typename(parsed_type: inner, scope_id, name: None)
        .ignore_errors = old_ignore_errors
        mut checked_op = CheckedUnaryOperator::Is(type_id)
        let expr_type_id = checked_expr.type()
        match inner {
            NamespacedName(name: variant_name, span) | Name(name: variant_name, span) => {
                guard .get_type(expr_type_id) is Enum(enum_id) else {
                    .error(format("Unknown type or invalid type name: {}", variant_name), span)
                    return checked_op
                }
                let enum_ = .get_enum(enum_id)
                let variant = .get_enum_variant(enum_, variant_name)
                guard variant.has_value() else {
                    .error(format("Enum variant {} does not exist on {}", variant_name, .type_name(type_id)), span)
                    return checked_op
                }
                let checked_enum_variant_bindings = .typecheck_enum_variant_bindings(variant: variant!, bindings, span)
                checked_op = CheckedUnaryOperator::IsEnumVariant(
                    enum_variant: variant!,
                    bindings: checked_enum_variant_bindings!,
                    type_id: expr_type_id
                )
            }
            else => {}
        }
        return checked_op
    }

    function get_enum_variant(mut this, enum_: CheckedEnum, variant_name: String) throws -> CheckedEnumVariant? {
        for variant in enum_.variants.iterator() {
            if variant.name() == variant_name {
                return variant
            }
        }
        return None
    }

    function typecheck_enum_variant_bindings(mut this, variant: CheckedEnumVariant, bindings: [EnumVariantPatternArgument], span: Span) throws -> [CheckedEnumVariantBinding]? {
        if variant is Typed(type_id) {
            if bindings.size() != 1 {
                .error(format("Enum variant ‘{}’ must have exactly one argument", variant.name()), span)
                return None
            }
            return [CheckedEnumVariantBinding(name: None, binding: bindings[0].binding, type_id, span)]
        }

        guard variant is StructLike(fields) else {
            return None
        }
        mut checked_vars: [CheckedVariable] = []
        mut checked_enum_variant_bindings: [CheckedEnumVariantBinding] = []
        for field in fields.iterator() {
            checked_vars.push(.get_variable(field))
        }
        for binding in bindings.iterator() {
            for var in checked_vars.iterator() {
                let binding_name = binding.name ?? binding.binding
                let type_id = var.type_id
                if binding_name == var.name {
                    checked_enum_variant_bindings.push(CheckedEnumVariantBinding(name: binding.name, binding: binding.binding, type_id, span))
                    break
                }
            }
        }
        if checked_enum_variant_bindings.size() > 0 {
            return checked_enum_variant_bindings
        }
        return None
    }

    function typecheck_lambda(mut this, captures: [ParsedCapture], params: [ParsedParameter], can_throw: bool, is_fat_arrow: bool, return_type: ParsedType, block: ParsedBlock, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedExpression {
        let synthetic_type = ParsedType::Function(
            params
            can_throw
            return_type
            span
        )

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        mut type_id = .typecheck_typename(parsed_type: synthetic_type, scope_id, name: None)
        mut (return_type_id, pseudo_function_id) = match .get_type(type_id) {
            Function(return_type_id, pseudo_function_id) => (return_type_id, pseudo_function_id)
            else => {
                .compiler.panic("Expected the just-checked function to be of a function type")
            }
        }
        
        let lambda_scope_id = .create_scope(parent_scope_id: scope_id, can_throw, debug_name: "lambda")
        mut checked_captures: [CheckedCapture] = []
        for capture in captures.iterator() {
            if .find_var_in_scope(scope_id, var: capture.name()).has_value() {
                checked_captures.push(match capture {
                    ByValue(name, span) => CheckedCapture::ByValue(name, span)
                    ByReference(name, span) => CheckedCapture::ByReference(name, span)
                    ByMutableReference(name, span) => CheckedCapture::ByMutableReference(name, span)
                })
            } else {
                .error(format("Variable '{}' not found", capture.name()), span)
            }
        }

        mut module = .current_module()
        mut checked_params: [CheckedParameter] = []
        mut first = true
        for param in params.iterator() {
            let checked_param = .typecheck_parameter(parameter: param, scope_id, first, this_arg_type_id: None, check_scope: None)
            checked_params.push(checked_param)
            let var_id = module.add_variable(checked_param.variable)
            .add_var_to_scope(scope_id: lambda_scope_id, name: checked_param.variable.name, var_id, span: checked_param.variable.definition_span)

            first = false
        }

        let previous_function_id = .current_function_id
        .current_function_id = pseudo_function_id
        defer {
            .current_function_id = previous_function_id
        }

        let checked_block = .typecheck_block(parsed_block: block, parent_scope_id: lambda_scope_id, safety_mode)

        if return_type_id.equals(unknown_type_id()) {
            mut return_type_updated = false
            if not is_fat_arrow and return_type is Empty {
                return_type_id = void_type_id()
                return_type_updated = true
            } else if is_fat_arrow and 
                not checked_block.statements.is_empty() and
                checked_block.statements.last()! is Return(val) and 
                val.has_value() {
                return_type_id = .resolve_type_var(type_var_type_id: val!.type(), scope_id: lambda_scope_id)
                return_type_updated = true
            }

            if return_type_updated {
                type_id = match .get_type(type_id) {
                    Function(params, can_throw, pseudo_function_id) => .find_or_add_type_id(Type::Function(
                        params
                        can_throw
                        return_type_id
                        pseudo_function_id
                    ))
                    else => {
                        .compiler.panic("Expected the just-checked function to be of a function type")
                    }
                }
            }
        }

        return CheckedExpression::Function(
            captures: checked_captures
            params: checked_params
            can_throw
            return_type_id
            block: checked_block
            span
            type_id
            pseudo_function_id
        )
    }

    function typecheck_namespaced_var_or_simple_enum_constructor_call(mut this, name: String, namespace_: [String], scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?, span: Span) throws -> CheckedExpression {
        mut scopes = [scope_id]
        for ns in namespace_.iterator() {
            let scope = scopes[scopes.size() - 1]
            let ns_in_scope = .find_namespace_in_scope(scope_id: scope, name: ns)
            let enum_in_scope = .program.find_enum_in_scope(scope_id: scope, name: ns)
            mut next_scope = scope
            if ns_in_scope.has_value() {
                next_scope = ns_in_scope!.0
            } else if enum_in_scope.has_value() {
                next_scope = .get_enum(enum_in_scope!).scope_id
            } else {
                .error(format("Namespace ‘{}’ not found", ns), span)
            }
            scopes.push(next_scope)
        }

        let scope = scopes.last()!

        mut i = 0uz
        let min_length = match scopes.size() <= namespace_.size() {
            true => scopes.size()
            else => namespace_.size()
        }
        mut checked_namespaces: [CheckedNamespace] = []
        while i < min_length {
            checked_namespaces.push(CheckedNamespace(name: namespace_[i], scope_id: scope))
            i++
        }

        let var = .find_var_in_scope(scope_id: scope, var: name)
        if var.has_value() {
            return CheckedExpression::NamespacedVar(namespaces: checked_namespaces, var: var!, span)
        }

        let implicit_constructor_call = ParsedCall(namespace_, name, args: [], type_args: [])
        let call_expression = .typecheck_call(call: implicit_constructor_call, caller_scope_id: scope_id, span, this_expr: None, parent_id: None, safety_mode, type_hint, must_be_enum_constructor: true)
        let type_id = call_expression.type()
        let call = match call_expression {
            Call(call) => call
            else => {
                .compiler.panic("typecheck_call returned something other than a CheckedCall")
            }
        }
        if call.function_id.has_value() {
            return CheckedExpression::Call(call, span, type_id)
        }
        .error(format("Variable '{}' not found", name), span)
        return CheckedExpression::NamespacedVar(
            namespaces: checked_namespaces,
            var: CheckedVariable(
                name,
                type_id: unknown_type_id(),
                is_mutable: false,
                definition_span: span
                type_span: None
                visibility: CheckedVisibility::Public
            ),
            span
        )
    }

    function typecheck_array(mut this, scope_id: ScopeId, values: [ParsedExpression], fill_size: ParsedExpression?, span: Span, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        if .dump_try_hints {
            .dump_try_hint(span)
        }
        if not .get_scope(scope_id).can_throw {
            let message = "Array initialization inside non-throwing scope"
            if .current_function_id.has_value() {
                let current_function = .get_function(.current_function_id!)
                .error_with_hint(
                    message
                    span
                    format("Add `throws` keyword to function {}", current_function.name),
                    current_function.name_span)
            } else {
                .error(message, span)
            }
        }
        mut repeat: CheckedExpression? = None
        if fill_size.has_value() {
            // Check fill size is an integer.
            // TODO: Check fill size is positive when possible.
            let fill_size_value = fill_size.value()
            let fill_size_checked = .typecheck_expression_and_dereference_if_needed(fill_size_value, scope_id, safety_mode, type_hint: None, span)
            let fill_size_type = fill_size_checked.type()
            if not .is_integer(fill_size_type) {
                .error(
                    format("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions.", .type_name(fill_size_type)),
                    fill_size_value.span()
                )
            }
            repeat = fill_size_checked
        }
        let array_struct_id = .find_struct_in_prelude("Array")
        mut inner_type_id = unknown_type_id()
        mut inferred_type_span: Span? = None

        mut inner_hint: TypeId? = None
        if type_hint.has_value() {
            if .get_type(type_hint!) is GenericInstance(id, args) and id.equals(array_struct_id) {
                inner_hint = Some(args[0])
            }
        }

        mut vals: [CheckedExpression] = []
        for value in values.iterator() {
            let checked_expr = .typecheck_expression(value, scope_id, safety_mode, type_hint: inner_hint)
            let current_value_type_id = checked_expr.type()
            if current_value_type_id.equals(void_type_id()) {
                .error("Cannot create an array with values of type void\n", span)
            }

            if inner_type_id.equals(unknown_type_id()) {
                inner_type_id = current_value_type_id
                inferred_type_span = value.span()
            } else if not inner_type_id.equals(current_value_type_id) {
                .error_with_hint(
                    format("Type '{}' does not match type '{}' of previous values in array", .type_name(current_value_type_id), .type_name(inner_type_id)),
                    value.span(),
                    format("Array was inferred to store type '{}' here", .type_name(inner_type_id))
                    inferred_type_span!
                )
            }
            vals.push(checked_expr)
        }

        if inner_type_id.equals(unknown_type_id()) {
            if inner_hint.has_value() {
                inner_type_id = inner_hint!
            } else if type_hint.has_value() and type_hint!.equals(unknown_type_id()) {
                .error("Cannot infer generic type for Array<T>", span)
            }
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))

        if type_hint.has_value() {
            .check_types_for_compat(
                lhs_type_id: type_hint!
                rhs_type_id: type_id
                generic_inferences: &mut .generic_inferences
                span
            )
        }

        return CheckedExpression::JaktArray(vals, repeat, span, type_id, inner_type_id)
    }

    function typecheck_set(mut this, values: [ParsedExpression], span: Span, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        if .dump_try_hints {
            .dump_try_hint(span)
        }
        if not .get_scope(scope_id).can_throw {
            .error("Set initialization needs to be in a try statement or a function marked as throws", span)
        }
        mut inner_type_id = unknown_type_id()
        mut inner_type_span: Span? = None
        mut output: [CheckedExpression] = []

        let set_struct_id = .find_struct_in_prelude("Set")

        // TODO: type hints
        mut inner_hint: TypeId? = None

        for value in values.iterator() {
            let checked_value = .typecheck_expression(expr: value, scope_id, safety_mode, type_hint: inner_hint)
            let current_value_type_id = checked_value.type()
            if inner_type_id.equals(unknown_type_id()) {
                if current_value_type_id.equals(void_type_id()) or current_value_type_id.equals(unknown_type_id()) {
                    .error(
                        "Cannot create a set with values of type void"
                        value.span()
                    )
                }

                inner_type_id = current_value_type_id
                inner_type_span = value.span()
            } else if not inner_type_id.equals(current_value_type_id) {
                let set_type_name = .type_name(inner_type_id)
                .error_with_hint(
                    format(
                        "Type '{}' does not match type '{}' of previous values in set"
                        .type_name(current_value_type_id)
                        set_type_name
                    )
                    value.span()
                    format("Set was inferred to store type '{}' here", set_type_name)
                    inner_type_span!
                )
            }
            output.push(checked_value)
        }

        if inner_type_id.equals(unknown_type_id()) and type_hint.has_value() and not type_hint!.equals(unknown_type_id()) {
            if .get_type(type_hint!) is GenericInstance(id, args) and id.equals(set_struct_id) {
                inner_type_id = args[0]
            } else {
                panic("expected Set struct")
            }
        }

        if inner_type_id.equals(unknown_type_id()) {
            .error("Cannot infer generic type for Set<T>", span)
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: set_struct_id
            args: [inner_type_id]
        ))

        return CheckedExpression::JaktSet(vals: output, span, type_id, inner_type_id)
    }

    function typecheck_generic_arguments_method_call(mut this, checked_expr: CheckedExpression, call: ParsedCall, scope_id: ScopeId, span: Span, is_optional: bool, safety_mode: SafetyMode) throws -> CheckedExpression {
        mut checked_args: [(String, CheckedExpression)] = []
        checked_args.ensure_capacity(call.args.size())
        for (name, _, expr) in call.args.iterator() {
            let checked_arg_expr = .typecheck_expression(
                expr
                scope_id
                safety_mode
                type_hint: None
            )
            checked_args.push((name, checked_arg_expr))
        }

        mut checked_type_args: [TypeId] = []
        for type_arg in call.type_args.iterator() {
            checked_type_args.push(.typecheck_typename(parsed_type: type_arg, scope_id, name: None))
        }

        return CheckedExpression::MethodCall(
            expr: checked_expr
            call: CheckedCall(
                namespace_: []
                name: call.name
                args: checked_args
                type_args: checked_type_args
                function_id: None
                return_type: unknown_type_id()
                callee_throws: false
            )
            span
            is_optional
            type_id: unknown_type_id()
        )
    }

    function typecheck_match_variant(mut this, case_: ParsedMatchCase, subject_type_id: TypeId, variant_index: usize, final_result_type: TypeId?, variant: CheckedEnumVariant, variant_arguments: [EnumVariantPatternArgument], arguments_span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> (String?, CheckedMatchCase, TypeId?) {
        mut covered_name: String? = None

        let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: format("catch-enum-variant({})", variant.name()))
        mut module = .current_module()
        match variant {
            Untyped(name) => {
                covered_name = name

                if not variant_arguments.is_empty() {
                    .error(format("Match case '{}' cannot have arguments", name), arguments_span)
                }
            }
            Typed(name, type_id, span) => {
                covered_name = name

                if not variant_arguments.is_empty() {
                    if variant_arguments.size() != 1 {
                        .error(format("Match case ‘{}’ must have exactly one argument", name), span)
                    } else {
                        let variant_argument = variant_arguments[0]
                        let variable_type_id = .substitute_typevars_in_type(
                            type_id
                            generic_inferences: .generic_inferences
                        )
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant_argument.binding
                            type_id: variable_type_id
                            is_mutable: false
                            definition_span: span
                            type_span: None
                            visibility: CheckedVisibility::Public
                        ))
                        .add_var_to_scope(scope_id: new_scope_id, name: variant_argument.binding, var_id, span)
                    }
                }
            }
            StructLike(name, fields) => {
                covered_name = name

                mut field_variables: [CheckedVariable] = []
                for var_id in fields.iterator() {
                    field_variables.push(.program.get_variable(var_id))
                }
                mut seen_names: {String} = {}
                for arg in variant_arguments.iterator() {
                    if not arg.name.has_value() {
                        mut found_field_name = false
                        mut field_names: [String] = []
                        for var in field_variables.iterator() {
                            field_names.push(var.name)
                            if var.name == arg.binding {
                                found_field_name = true
                            }
                        }
                        if not found_field_name {
                            mut unused_field_names: [String] = []
                            for field_name in field_names.iterator() {
                                if seen_names.contains(field_name) {
                                    continue
                                }
                                unused_field_names.push(field_name)
                            }
                            .error_with_hint(
                                format("Match case argument '{}' for struct-like enum variant '{}' cannot be anon", arg.binding, name)
                                arg.span
                                format("Available arguments for '{}' are: {}\n", name, join(unused_field_names, separator: ", "))
                                arg.span
                            )
                            continue
                        }
                    }
                    let arg_name = arg.name ?? arg.binding
                    if seen_names.contains(arg_name) {
                        .error(format("Match case argument '{}' is already defined", arg_name), arg.span)
                        continue
                    }
                    seen_names.add(arg_name)
                    mut matched_field_variable: CheckedVariable? = None
                    for var in field_variables.iterator() {
                        if var.name == arg_name {
                            matched_field_variable = var
                        }
                    }

                    match matched_field_variable.has_value() {
                        true => {
                            let substituted_type_id = .substitute_typevars_in_type(type_id: matched_field_variable!.type_id, generic_inferences: .generic_inferences)
                            let matched_span = matched_field_variable!.definition_span
                            if .dump_type_hints {
                                .dump_type_hint(type_id: matched_field_variable!.type_id, span: arg.span)
                            }

                            let var_id = module.add_variable(CheckedVariable(
                                name: arg.binding
                                type_id: substituted_type_id
                                is_mutable: false
                                definition_span: matched_span
                                type_span: None
                                visibility: CheckedVisibility::Public
                            ))
                            .add_var_to_scope(scope_id: new_scope_id, name: arg.binding, var_id, span: matched_span)
                        }
                        else => {
                            .error(format("Match case argument '{}' does not exist in struct-like enum variant '{}'", arg_name, name), arg.span)
                        }
                    }
                }
            }
            else => {
                todo(format("implement {} match case for matched variant", variant.name()))
            }
        }

        let (checked_body, result_type) = .typecheck_match_body(
            body: case_.body
            scope_id: new_scope_id
            safety_mode
            generic_inferences: &mut .generic_inferences
            final_result_type
            span: case_.marker_span
        )

        let checked_match_case = CheckedMatchCase::EnumVariant(
            name: variant.name()
            args: variant_arguments
            subject_type_id
            index: variant_index
            scope_id: new_scope_id
            body: checked_body
            marker_span: case_.marker_span
        )

        return (covered_name, checked_match_case, result_type)
    }

    function typecheck_match(mut this, expr: ParsedExpression, cases: [ParsedMatchCase], span: Span, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
        let subject_type_id = checked_expr.type()
        let type_to_match_on = .get_type(subject_type_id)
        mut checked_cases: [CheckedMatchCase] = []

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        mut final_result_type: TypeId? = None
        if type_hint.has_value() and not type_hint!.equals(unknown_type_id()) and not .get_type(type_hint!) is TypeVariable {
            final_result_type = type_hint
        }

        if type_to_match_on is GenericEnumInstance(id, args) {
            let enum_ = .get_enum(id)
            for i in 0..enum_.generic_parameters.size() {
                let generic = enum_.generic_parameters[i].to_string()
                let argument_type = args[i].to_string()
                if generic != argument_type {
                    .generic_inferences.set(generic, argument_type)
                }
            }
        }

        match type_to_match_on {
            Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                let enum_ = .get_enum(enum_id)
                mut seen_catch_all = false
                mut expanded_catch_all = false
                mut catch_all_span: Span? = None
                mut covered_variants: {String} = {}

                let case_count = cases.size()
                mut current_case_index = 0uz
                for case_ in cases.iterator() {
                    for pattern in case_.patterns.iterator() {
                        match pattern {
                            EnumVariant(variant_names, variant_arguments, arguments_span) => {
                                mut variant_names_ = variant_names

                                if variant_names_.size() == 1 {
                                    let temp = variant_names_[0]
                                    variant_names_ = [
                                        (enum_.name, variant_names_[0].1)
                                        temp
                                    ]
                                }

                                if variant_names_.is_empty() {
                                    continue
                                }

                                if variant_names_[0].0 != enum_.name {
                                    .error(format("Match case '{}' does not match enum '{}'", variant_names_[0].0, enum_.name), variant_names_[0].1)
                                    continue
                                }

                                mut i = 0uz
                                mut matched_variant: CheckedEnumVariant? = None
                                mut variant_index: usize? = None
                                for v in enum_.variants.iterator() {
                                    if v.name() == variant_names_[1].0 {
                                        matched_variant = v
                                        variant_index = i
                                    }
                                    i++
                                }

                                if not matched_variant.has_value() {
                                    .error(format("Enum '{}' does not contain a variant named '{}'", enum_.name, variant_names_[1].0), case_.marker_span)

                                    return CheckedExpression::Match(expr: checked_expr, match_cases: [], span, type_id: unknown_type_id(), all_variants_constant: false)
                                }

                                let (covered_name, checked_match_case, result_type) = .typecheck_match_variant(
                                    case_
                                    subject_type_id
                                    variant_index: variant_index!
                                    final_result_type
                                    variant: matched_variant!
                                    variant_arguments
                                    arguments_span
                                    scope_id
                                    safety_mode
                                )
                                if covered_name.has_value() {
                                    covered_variants.add(covered_name!)
                                }

                                final_result_type = result_type

                                checked_cases.push(checked_match_case)
                            }
                            CatchAll(variant_arguments, arguments_span) => {
                                if current_case_index != case_count - 1 {
                                    .error("Match else case is only allowed as the last case", case_.marker_span)
                                }

                                if seen_catch_all {
                                    .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                } else {
                                    seen_catch_all = true
                                }

                                if variant_arguments.size() > 0 {
                                    mut variant_index = 0uz
                                    for variant in enum_.variants.iterator() {
                                        if not covered_variants.contains(variant.name()) {
                                            expanded_catch_all = true

                                            let (covered_name, checked_match_case, result_type) = .typecheck_match_variant(
                                                case_
                                                subject_type_id
                                                variant_index
                                                final_result_type
                                                variant
                                                variant_arguments
                                                arguments_span
                                                scope_id
                                                safety_mode
                                            )
                                            if covered_name.has_value() {
                                                covered_variants.add(covered_name!)
                                            }

                                            final_result_type = result_type

                                            checked_cases.push(checked_match_case)
                                        }

                                        variant_index++
                                    }
                                } else {
                                    let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: "catch-all")
                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    let checked_match_case = CheckedMatchCase::CatchAll(
                                        has_arguments: false
                                        body: checked_body
                                        marker_span: case_.marker_span
                                    )

                                    checked_cases.push(checked_match_case)
                                }
                            }
                            else => {}
                        }
                    }

                    current_case_index++
                }

                mut enum_variant_names: [String] = []
                mut missing_variants: [String] = []

                for variant in enum_.variants.iterator() {
                    enum_variant_names.push(variant.name())
                }

                for variant in enum_variant_names.iterator() {
                    if not covered_variants.contains(variant) {
                        missing_variants.push(variant)
                    }
                }

                if missing_variants.size() > 0 {
                    if not seen_catch_all {
                        .error(format("Match expression is not exhaustive, missing variants are: {}", join(missing_variants, separator: ", ")), span)
                    }
                } else if seen_catch_all and not expanded_catch_all {
                    .error("All variants are covered, but an irrefutable pattern is also present", span)
                }
            }
            Void => {
                .error("Can't match on 'void' type", checked_expr.span())
            }
            else => {
                mut is_enum_match = false
                mut is_value_match = false
                mut seen_catch_all = false

                mut all_variants_constant = true

                let case_count = cases.size()
                mut current_case_index = 0uz
                for case_ in cases.iterator() {
                    for pattern in case_.patterns.iterator() {
                        match pattern {
                            EnumVariant(variant_names, variant_arguments, arguments_span) => {
                                if is_value_match {
                                    .error(
                                        "Cannot have an enum match case in a match expression containing value matches"
                                        case_.marker_span
                                    )
                                }

                                if variant_names.size() == 0 {
                                    .compiler.panic("typecheck_match - else - EnumVariant - variant_names.size() == 0")
                                }

                                is_enum_match = true

                                // We don't know what the enum type is, but we have the type var for it, so generate a generic enum match.
                                // note that this will be fully checked when this match expression is actually instantiated.
                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: format("catch-enum-variant({})", variant_names))
                                let (checked_body, result_type) = .typecheck_match_body(
                                    body: case_.body
                                    scope_id: new_scope_id
                                    safety_mode
                                    generic_inferences: &mut .generic_inferences
                                    final_result_type
                                    span: case_.marker_span
                                )
                                final_result_type = result_type

                                let checked_match_case = CheckedMatchCase::EnumVariant(
                                    name: variant_names.last()!.0
                                    args: variant_arguments
                                    subject_type_id
                                    index: 0
                                    scope_id: new_scope_id
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                            CatchAll(variant_arguments) => {
                                if current_case_index != case_count - 1 {
                                    .error("Match else case is only allowed as the last case", case_.marker_span)
                                }

                                if seen_catch_all {
                                    .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                } else {
                                    seen_catch_all = true
                                }

                                // FIXME: bindings shouldn't be allowed for generic else but we can't just put an error here as the generic version
                                // is typechecked with ignore errors
                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: "catch-all")
                                let (checked_body, result_type) = .typecheck_match_body(
                                    body: case_.body
                                    scope_id: new_scope_id
                                    safety_mode
                                    generic_inferences: &mut .generic_inferences
                                    final_result_type
                                    span: case_.marker_span
                                )
                                final_result_type = result_type

                                let checked_match_case = CheckedMatchCase::CatchAll(
                                    has_arguments: variant_arguments.size() != 0
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )

                                checked_cases.push(checked_match_case)
                            }
                            Expression(expr) => {
                                if is_enum_match {
                                    .error(
                                        "Cannot have a value match case in a match expression containing enum matches"
                                        case_.marker_span
                                    )
                                }
                                is_value_match = true

                                let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(condition: expr, acc: None, then_block: None, else_statement: None, span)
                                let checked_expression = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: Some(subject_type_id), span)

                                if not checked_expression.to_number_constant(program: .program).has_value() {
                                    all_variants_constant = false
                                }

                                mut expression_type = checked_expression.type()

                                if checked_expression is Range(from, to) {
                                    guard from.has_value() or to.has_value() else {
                                        .error(
                                            "There has to be at least a 'from', or a 'to' in a range expression"
                                            expr.span()
                                        )
                                        continue
                                    }
                                    if from.has_value() {
                                        expression_type = from!.type()
                                    } else if to.has_value() {
                                        expression_type = to!.type()
                                    }
                                }

                                // FIXME: In the future, we should really make this a "does it satisfy some trait" check.
                                //        For now, we just check that the types are equal.
                                .check_types_for_compat(
                                    lhs_type_id: expression_type
                                    rhs_type_id: subject_type_id
                                    generic_inferences: &mut .generic_inferences
                                    span: case_.marker_span
                                )

                                let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: format("catch-expression({})", expr))
                                let (checked_body, result_type) = .typecheck_match_body(
                                    body: case_.body
                                    scope_id: new_scope_id
                                    safety_mode
                                    generic_inferences: &mut .generic_inferences
                                    final_result_type
                                    span: case_.marker_span
                                )
                                final_result_type = result_type

                                let checked_match_case = CheckedMatchCase::Expression(
                                    expression: checked_expression
                                    body: checked_body
                                    marker_span: case_.marker_span
                                )
                                checked_cases.push(checked_match_case)
                            }
                            else => {}
                        }
                    }

                    current_case_index++
                }

                if is_value_match and not seen_catch_all {
                    .error(
                        "match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"
                        span
                    )
                }
            }
        }

        return CheckedExpression::Match(expr: checked_expr, match_cases: checked_cases, span, type_id: final_result_type ?? void_type_id(), all_variants_constant: true)
    }

    function typecheck_match_body(mut this, body: ParsedMatchBody, scope_id: ScopeId, safety_mode: SafetyMode, generic_inferences: &mut GenericInferences, final_result_type: TypeId?, span: Span) throws -> (CheckedMatchBody, TypeId?) {
        mut result_type = final_result_type
        let checked_match_body = match body {
            Block(block) => {
                let checked_block = .typecheck_block(parsed_block: block, parent_scope_id: scope_id, safety_mode, yield_type_hint: final_result_type)

                if checked_block.control_flow.may_return() or checked_block.yielded_type.has_value() {
                    let block_type_id = checked_block.yielded_type ?? void_type_id()
                    let yield_span = block.find_yield_span() ?? span

                    if result_type.has_value() {
                        .check_types_for_compat(
                            lhs_type_id: result_type!
                            rhs_type_id: block_type_id
                            generic_inferences
                            span: yield_span
                        )
                    } else {
                        result_type = block_type_id
                    }
                }

                mut final_body: CheckedMatchBody? = None
                if checked_block.yielded_type.has_value() and not checked_block.control_flow.never_returns() {
                    final_body = CheckedMatchBody::Expression(CheckedExpression::Block(
                        block: checked_block
                        span
                        type_id: checked_block.yielded_type!
                    ))
                } else {
                    final_body = CheckedMatchBody::Block(checked_block)
                }

                yield final_body!
            }
            Expression(expr) => {
                let checked_expression = .typecheck_expression(expr, scope_id, safety_mode, type_hint: result_type)
                if result_type.has_value() {
                    .check_types_for_compat(
                        lhs_type_id: result_type!
                        rhs_type_id: checked_expression.type()
                        generic_inferences
                        span
                    )
                } else {
                    result_type = checked_expression.type()
                }

                yield CheckedMatchBody::Expression(checked_expression)
            }
        }
        return (checked_match_body, result_type)
    }

    function typecheck_dictionary(mut this, values: [(ParsedExpression, ParsedExpression)], span: Span, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        if .dump_try_hints {
            .dump_try_hint(span)
        }
        let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
        mut checked_kv_pairs: [(CheckedExpression, CheckedExpression)] = []
        mut key_type_id = unknown_type_id()
        mut key_type_span: Span? = None
        mut value_type_id = unknown_type_id()
        mut value_type_span: Span? = None

        mut key_hint: TypeId? = None
        mut value_hint: TypeId? = None
        if type_hint.has_value()
            and .get_type(type_hint!) is GenericInstance(id, args)
            and id.equals(dictionary_struct_id) {
            key_hint = args[0]
            value_hint = args[1]
        }

        for (key, value) in values.iterator() {
            let checked_key = .typecheck_expression(key, scope_id, safety_mode, type_hint: key_hint)
            let current_key_type_id = checked_key.type()

            let checked_value = .typecheck_expression(value, scope_id, safety_mode, type_hint: value_hint)
            let current_value_type_id = checked_value.type()
            let VOID_TYPE_ID = builtin(BuiltinType::Void)

            if key_type_id.equals(unknown_type_id()) and value_type_id.equals(unknown_type_id()) {
                if current_key_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with keys of type void", span: key.span())
                }
                if current_value_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with values of type void", span: value.span())
                }
                key_type_id = current_key_type_id
                key_type_span = Some(key.span())
                value_type_id = current_value_type_id
                value_type_span = Some(value.span())
            } else {
                if not key_type_id.equals(current_key_type_id) {
                    let key_type_name = .type_name(key_type_id)
                    let current_key_type_name = .type_name(current_key_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous keys in dictionary", current_key_type_name, key_type_name)
                        span: key.span()
                        hint: format("Dictionary was inferred to store keys of type '{}' here", key_type_name)
                        span: key_type_span!
                    )
                }
                if not value_type_id.equals(current_value_type_id) {
                    let value_type_name = .type_name(value_type_id)
                    let current_value_type_name = .type_name(current_value_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous values in dictionary", current_value_type_name, value_type_name)
                        span: value.span()
                        hint: format("Dictionary was inferred to store values of type '{}' here", value_type_name)
                        span: value_type_span!
                    )
                }
            }
            checked_kv_pairs.push((checked_key, checked_value))
        }

        if key_type_id.equals(unknown_type_id()) {
            if key_hint.has_value() {
                key_type_id = key_hint!
            } else {
                .error("Cannot infer key type for Dictionary<K, V>", span)
            }
        }

        if value_type_id.equals(unknown_type_id()) {
            if value_hint.has_value() {
                value_type_id = value_hint!
            } else {
                .error("Cannot infer value type for Dictionary", span)
            }
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: dictionary_struct_id,
            args: [key_type_id, value_type_id]
        ))

        // TODO: unify type with hint type

        return CheckedExpression::JaktDictionary(
            vals: checked_kv_pairs
            span
            type_id
            key_type_id
            value_type_id
        )
    }

    function resolve_call(mut this, call: ParsedCall, mut namespaces: [ResolvedNamespace], span: Span, scope_id: ScopeId, must_be_enum_constructor: bool, ignore_errors: bool) throws -> FunctionId? {
        mut callee: FunctionId? = None
        mut current_scope_id = scope_id

        for namespace_index in 0..call.namespace_.size() {
            let scope_name = call.namespace_[namespace_index]
            let maybe_ns_scope = .find_namespace_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_ns_scope.has_value() {
                let (scope_id, is_import) = maybe_ns_scope!
                if is_import {
                    namespaces[namespace_index].name = .program.modules[scope_id.module_id.id].name
                }
                current_scope_id = scope_id
                continue
            }
            let maybe_struct_scope = .find_struct_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_struct_scope.has_value() {
                let structure = .get_struct(maybe_struct_scope!)
                current_scope_id = structure.scope_id
                continue
            }
            let maybe_enum_scope = .program.find_enum_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_enum_scope.has_value() {
                let enum_ = .get_enum(maybe_enum_scope!)
                current_scope_id = enum_.scope_id
                continue
            }

            .error(format("Not a namespace, enum, class, or struct: ‘{}’", join(call.namespace_, separator: "::")), span)
        }

        // 1. Look for a variable in the current scope with this name.
        let maybe_var = .find_var_in_scope(scope_id: current_scope_id, var: call.name)
        if maybe_var.has_value()  {
            let inner_type = match .get_type(maybe_var!.type_id) {
                Reference(type_id) | MutableReference(type_id) => type_id
                else => maybe_var!.type_id
            }

            if .get_type(inner_type) is Function(pseudo_function_id) {
                return pseudo_function_id
            }
        }

        // 2. Look for a function with this name.
        let maybe_function_id = .find_function_in_scope(parent_scope_id: current_scope_id, function_name: call.name)
        if maybe_function_id.has_value() {
            let function_id = maybe_function_id!
            if not must_be_enum_constructor or .get_function(function_id).type is ImplicitEnumConstructor {
                return function_id
            }
        }

        if must_be_enum_constructor {
            .error(format("No such enum constructor ‘{}’", call.name), span)
            return callee
        }

        // 3. Look for a struct, class or enum constructor with this name.
        let maybe_struct_id = .find_struct_in_scope(scope_id: current_scope_id, name: call.name)
        if maybe_struct_id.has_value() {
            let struct_id = maybe_struct_id!
            let structure = .get_struct(struct_id)
            let maybe_function_id = .find_function_in_scope(parent_scope_id: structure.scope_id, function_name: call.name)
            if maybe_function_id.has_value() {
                return maybe_function_id!
            }
            return callee
        }

        if not ignore_errors {
            .error(format("Call to unknown function: ‘{}’", call.name), span)
        }

        return None
    }

    function typecheck_call(mut this, call: ParsedCall, caller_scope_id: ScopeId, span: Span, this_expr: CheckedExpression?, parent_id: StructOrEnumId?, safety_mode: SafetyMode, mut type_hint: TypeId?, must_be_enum_constructor: bool) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = builtin(BuiltinType::Void)
        mut generic_arguments: [TypeId] = []
        mut callee_throws = false
        mut resolved_namespaces: [ResolvedNamespace] = []
        mut resolved_function_id: FunctionId? = None
        mut maybe_this_type_id: TypeId? = None
        mut generic_checked_function_to_instantiate: FunctionId? = None

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        for name in call.namespace_.iterator() {
            resolved_namespaces.push(ResolvedNamespace(name, generic_parameters: None))
        }

        let callee_scope_id = match parent_id.has_value() {
            true => match parent_id! {
                Struct(id) => {
                    mut struct_ = .get_struct(id)
                    mut scope_id = struct_.scope_id
                    while not resolved_function_id.has_value() {
                        resolved_function_id = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor, ignore_errors: true)
                        if resolved_function_id.has_value() {
                            break
                        }
                        if struct_.super_struct_id.has_value() {
                            let parent_struct_id = struct_.super_struct_id!
                            struct_ = .get_struct(parent_struct_id)
                            scope_id = struct_.scope_id
                        } else {
                            .error(format("Could not find ‘{}’", call.name), span)
                            break
                        }
                    }
                    yield scope_id
                }
                Enum(id) => {
                    let scope_id = .get_enum(id).scope_id
                    resolved_function_id = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor, ignore_errors: false)
                    yield scope_id
                }
            }
            else => {
                match call.name {
                    "print" | "println" | "eprintln" | "eprint" | "format" => {}
                    else => {
                        resolved_function_id = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id: caller_scope_id, must_be_enum_constructor, ignore_errors: false)
                    }
                }
                yield caller_scope_id
            }
        }

        match call.name {
            "print" | "println" | "eprintln" | "eprint" | "format" => {
                for arg in call.args.iterator() {
                    let checked_arg = .typecheck_expression(expr: arg.2, scope_id: caller_scope_id, safety_mode, type_hint: None)

                    args.push((call.name, checked_arg))
                }

                if call.name == "format" {
                    return_type = builtin(BuiltinType::JaktString)
                    callee_throws = true
                }
            }
            else => {
                if not resolved_function_id.has_value() {
                    mut checked_type_args: [TypeId] = []
                    for type_arg in call.type_args.iterator() {
                        checked_type_args.push(.typecheck_typename(parsed_type: type_arg, scope_id: caller_scope_id, name: None))
                    }

                    for arg in call.args.iterator() {
                        let checked_arg = .typecheck_expression(expr: arg.2, scope_id: caller_scope_id, safety_mode, type_hint: None)

                        args.push((call.name, checked_arg))
                    }

                    return CheckedExpression::Call(
                        call: CheckedCall(
                            namespace_: resolved_namespaces,
                            name: call.name,
                            args,
                            type_args: checked_type_args,
                            function_id: resolved_function_id,
                            return_type,
                            callee_throws
                        ),
                        span,
                        type_id: return_type
                    )
                }

                let function_id = resolved_function_id!
                let callee = .get_function(function_id)

                if callee.is_instantiated {
                    .generic_inferences.perform_checkpoint(reset: true)
                }

                callee_throws = callee.can_throw
                return_type = callee.return_type_id
                let scope_containing_callee = .get_scope(callee.function_scope_id).parent!

                if callee.type is ImplicitConstructor {
                    let struct_ = .get_struct(callee.struct_id!)
                    .check_implicit_constructor_argument_access(caller_scope_id, call, struct_)
                } else {
                    .check_method_access(accessor: caller_scope_id, accessee: scope_containing_callee, method: callee, span)
                }

                // If the user gave us explicit type arguments, let's use them in our substitutions
                mut type_arg_index = 0uz
                for parsed_type in call.type_args.iterator() {
                    let checked_type = .typecheck_typename(parsed_type, scope_id: caller_scope_id, name: None)
                    if callee.generics.params.size() <= type_arg_index {
                        .error("Trying to access generic parameter out of bounds", parsed_type.span())
                        continue
                    }

                    // Find the associated type variable for this parameter, we'll use it in substitution
                    let typevar_type_id = match callee.generics.params[type_arg_index] {
                        InferenceGuide(id)
                        | Parameter(id) => id
                    }

                    if not typevar_type_id.equals(checked_type) {
                        .generic_inferences.set(typevar_type_id.to_string(), checked_type.to_string())
                    }

                    type_arg_index += 1
                }
                
                // This will be 0 for functions or 1 for instance methods, because of the `this` ptr
                mut arg_offset = 0uz

                // If this is a method, let's also add the types we know from our `this` pointer.
                if this_expr.has_value() {
                    let type_id = this_expr!.type()
                    maybe_this_type_id = type_id
                    let param_type = .get_type(type_id)

                    if param_type is GenericInstance(id, args) {
                        let structure = .get_struct(id)
                        for i in 0..structure.generic_parameters.size() {
                            if structure.generic_parameters[i].equals(args[i]) {
                                continue
                            }

                            .generic_inferences.set(
                                structure.generic_parameters[i].to_string()
                                args[i].to_string()
                            )
                        }
                    }

                    if callee.is_static() {
                        .error("Cannot call static method on an instance of an object", span)
                    } else {
                        arg_offset = 1uz
                    }

                    if callee.is_mutating() and not this_expr!.is_mutable(program: .program) {
                        .error("Cannot call mutating method on an immutable object instance", span)
                    }
                } else if not callee.is_static() {
                    .error_with_hint(
                        "Cannot call an instance method statically"
                        span
                        "Add a dot before the method name to call an instance method"
                        span
                    )
                }

                mut resolved_args: [(String, Span, CheckedExpression)] = .resolve_default_params(params: callee.generics.base_params, args: call.args, scope_id: caller_scope_id, safety_mode, arg_offset, span)

                if callee.generics.base_params.size() == resolved_args.size() + arg_offset {
                    for i in 0..callee.generics.base_params.size()-arg_offset {
                        let (name, span, checked_arg) = resolved_args[i]

                        .check_types_for_compat(
                            lhs_type_id: callee.generics.base_params[i+arg_offset].variable.type_id
                            rhs_type_id: checked_arg.type()
                            generic_inferences: &mut .generic_inferences
                            span: checked_arg.span()
                        )

                        args.push((call.name, checked_arg))
                    }
                }

                // We've now seen all the arguments and should be able to substitute the return type, if it's contains a
                // type variable. For the moment, we'll just checked to see if it's a type variable.
                // FIXME: `unknown_type_id()` and `None` are really the same thing. Can we remove `unknown_type_id()`?
                if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                    let old_ignore_errors = .ignore_errors
                    .ignore_errors = true
                    .check_types_for_compat(
                        lhs_type_id: return_type
                        rhs_type_id: type_hint!
                        generic_inferences: &mut .generic_inferences
                        span
                    )
                    .ignore_errors = old_ignore_errors
                }
                return_type = .substitute_typevars_in_type(type_id: return_type, generic_inferences: .generic_inferences)

                if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                    let old_ignore_errors = .ignore_errors
                    if callee.is_instantiated {
                        // If this is a possible respecialization of a generic function that is the child of a specialized version of that function
                        // allow an error here, if it is not a respecialization we will recheck
                        .ignore_errors = true
                    }
                    .check_types_for_compat(
                        lhs_type_id: type_hint!
                        rhs_type_id: return_type
                        generic_inferences: &mut .generic_inferences
                        span
                    )
                    .ignore_errors = old_ignore_errors
                }

                for generic_typevar in callee.generics.params.iterator() {
                    if generic_typevar is Parameter(id) {
                        let substitution = .generic_inferences.get(id.to_string())
                        if substitution.has_value() {
                            generic_arguments.push(TypeId::from_string(substitution!))
                        } else {
                            .error("Not all generic parameters have known types", span)
                        }
                    }
                }

                if not callee.is_instantiated or (not callee.linkage is External and not callee.generics.is_specialized_for_types(types: generic_arguments)) {
                    generic_checked_function_to_instantiate = Some(function_id)
                } else if callee.is_instantiated {
                    if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                        .check_types_for_compat(
                            lhs_type_id: type_hint!
                            rhs_type_id: return_type
                            generic_inferences: &mut .generic_inferences
                            span
                        )
                    }
                }
            }
        }

        return_type = .substitute_typevars_in_type(
            type_id: return_type,
            generic_inferences: .generic_inferences,
        )

        if callee_throws and not .get_scope(caller_scope_id).can_throw {
            .error("Call to function that may throw needs to be in a try statement or a function marked as throws", span)
        }

        if generic_checked_function_to_instantiate.has_value() {
            // Clear the generic parameters and typecheck in the fully specialized scope.
            if maybe_this_type_id.has_value() {
                maybe_this_type_id = .substitute_typevars_in_type(type_id: maybe_this_type_id!, generic_inferences: .generic_inferences)
            }

            .typecheck_and_specialize_generic_function(
                function_id: generic_checked_function_to_instantiate!
                generic_arguments,
                parent_scope_id: callee_scope_id,
                this_type_id: maybe_this_type_id,
                generic_substitutions: .generic_inferences
            )
        }

        if .dump_try_hints and callee_throws {
            .dump_try_hint(span)
        }

        let function_call = CheckedCall(
            namespace_: resolved_namespaces
            name: call.name
            args
            type_args: generic_arguments
            function_id: resolved_function_id
            return_type
            callee_throws
        )
        let checked_call = CheckedExpression::Call(
            call: function_call
            span
            type_id: return_type
        )

        let in_comptime_function = .current_function_id.has_value() and .get_function(.current_function_id.value()).is_comptime

        if not in_comptime_function and resolved_function_id.has_value() and .get_function(resolved_function_id!).is_comptime {
            let resolved_function = .get_function(resolved_function_id!)
            mut interpreter = Interpreter::create(compiler: .compiler, program: .program, spans: [])
            let function_ = .program.get_function(generic_checked_function_to_instantiate ?? resolved_function_id!)
            mut call_args: [Value] = []
            mut this_argument: Value? = None
            mut eval_scope = InterpreterScope::from_runtime_scope(scope_id: caller_scope_id, program: .program)

            for entry in .generic_inferences.iterator() {
                let (key, value) = entry
                eval_scope.type_bindings.set(key, TypeId::from_string(value))
            }

            if this_expr.has_value() {
                try {
                    let evaluated_this = interpreter.execute_expression(
                        expr: this_expr!
                        scope: eval_scope)

                    if evaluated_this is JustValue(value) {
                        this_argument = value
                    } else if evaluated_this is Throw(value) {
                        .error(
                            format("Error executing this expression (evaluation threw {})", value),
                            this_expr!.span())
                    } else {
                        .error(
                            "Invalid this expression",
                            this_expr!.span())
                    }
                } catch {
                    .error("Error executing this expression", this_expr!.span())
                }
            }

            for argument in args.iterator() {
                let value = try interpreter.execute_expression(
                    expr: argument.1,
                    scope: eval_scope
                ) catch {
                    .error("Error in argument", span)
                    continue
                }

                if value is Throw {
                    .error(
                        format("Compiletime call failed: {}", value)
                        argument.1.span()
                    )
                    break
                }

                let evaluated_value = match value {
                    Return(x) | JustValue(x) => x
                    else => {
                        throw Error::from_errno(69) // unreachable
                    }
                }

                call_args.push(evaluated_value)
            }


            mut type_bindings: [String:TypeId] = [:]
            for i in 0uz..resolved_function.generics.params.size() {
                let param = resolved_function.generics.params[i]

                type_bindings.set(
                    param.type_id().to_string()
                    function_call.type_args[i]
                )
            }

            mut result: ExecutionResult? = None
            mut invocation_scope = InterpreterScope::create(type_bindings)
            try {
                result = interpreter.execute(
                    function_to_run: resolved_function_id!
                    namespace_: resolved_namespaces
                    this_argument: this_argument
                    arguments: call_args
                    call_span: span
                    invocation_scope
                )
            } catch error {
                .error(format("Compiletime call failed: {}", error), span)
                return checked_call
            }

            return match result! {
                Return(x) => value_to_checked_expression(x, interpreter)
                Throw(x) => {
                    .error(
                        format("Compiletime call failed: {}", x)
                        span
                    )
                    yield checked_call
                }
            }
        }

        return checked_call
    }

    function check_implicit_constructor_argument_access(mut this, caller_scope_id: ScopeId, call: ParsedCall, struct_: CheckedStruct)  throws {
        if not .scope_can_access(accessor:caller_scope_id, accessee:struct_.scope_id) {
            for arg in call.args.iterator() {
                for field in struct_.fields.iterator() {
                    let variable = .get_variable(field.variable_id)
                    if (variable.name == arg.0 and variable.visibility is Private) {
                        .error(format("Can't access field '{}' when calling implicit constructor of '{}' because it is marked private", variable.name, struct_.name), arg.1)
                        return
                    }
                }
            }
        }
    }

    function resolve_default_params(mut this, params: [CheckedParameter], args: [(String, Span, ParsedExpression)], scope_id: ScopeId, safety_mode: SafetyMode, arg_offset: usize, span: Span) throws -> [(String, Span, CheckedExpression)] {
        mut params_with_default_value = 0uz

        for param in params.iterator() {
            if param.default_value.has_value() {
                params_with_default_value++
            }
        }

        guard args.size() >= params.size() - arg_offset - params_with_default_value and args.size() <= params.size() - arg_offset else {
            .error("Wrong number of arguments", span)
            return []
        }

        mut consumed_arg = 0uz
        mut resolved_args: [(String, Span, CheckedExpression)] = []

        for i in arg_offset..params.size() {
            let param = params[i]
            mut maybe_checked_expr: CheckedExpression? = None
            if not param.requires_label {
                guard args.size() > consumed_arg else {
                    .error(format("Missing argument for function parameter {}", param.variable.name), span)
                    continue
                }

                let (name, span, expr) = args[consumed_arg]
                maybe_checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: param.variable.type_id)
                consumed_arg++
            } else {
                maybe_checked_expr = param.default_value

                if args.size() > consumed_arg {
                    let (name, span, expr) = args[consumed_arg]
                    
                    if .validate_argument_label(param, label: name, span, expr, default_value: maybe_checked_expr) {
                        maybe_checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: param.variable.type_id)
                        consumed_arg++
                    }
                }
            }
            
            if maybe_checked_expr.has_value() {
                mut checked_arg = maybe_checked_expr!
                resolved_args.push((param.variable.name, span, checked_arg))
            }
        }

        return resolved_args
    }

    function resolve_type_var(this, type_var_type_id: TypeId, scope_id: ScopeId) throws -> TypeId {
        mut current_type_id = type_var_type_id

        loop {
            let type_var_type = .get_type(current_type_id)
            if type_var_type is TypeVariable(type_name) {
                let maybe_found_type_id = .find_type_in_scope(scope_id, name: type_name)
                if maybe_found_type_id.has_value() {
                    let found_type_id = maybe_found_type_id.value()
                    if found_type_id.equals(current_type_id) {
                        return current_type_id
                    }
                    current_type_id = found_type_id
                } else {
                    return current_type_id
                }
            } else {
                return current_type_id
            }
        }
        return current_type_id
    }

    function validate_argument_label(mut this, param: CheckedParameter, label: String, span: Span, expr: ParsedExpression, default_value: CheckedExpression?) throws -> bool {
        if label == param.variable.name {
            return true
        }
        match expr {
            Var(name, span) => {
                if name == param.variable.name {
                    return true
                }
                if not default_value.has_value() {
                    .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", name, param.variable.name), span)
                }
                return false
            }
            UnaryOp(expr, op) => {
                if op is Reference or op is MutableReference or op is Dereference {
                    if expr is Var(name, span) {
                        if name == param.variable.name {
                            return true
                        }
                        if not default_value.has_value() {
                            .error(format("Wrong parameter name in argument label (got ‘{}’, expected ‘{}’)", name, param.variable.name), span)
                        }
                        return false
                    }
                }
            }
            else => {}
        }
        if not default_value.has_value() {
            .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", label, param.variable.name), span)
        }
        return false
    }
}
