// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
// Copyright (c) 2022, Kyle Lanmon <kyle.lanmon@gmail.com>
// Copyright (c) 2022, Adler Oliveira <adler.rs.oliveira@gmail.com>
// Copyright (c) 2022, Jesús Lapastora <cyber.gsuscode@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause

import error { JaktError, print_error }
import lexer { Lexer }
import parser {
    BinaryOperator, DefinitionLinkage, EnumVariantPatternArgument, FunctionLinkage, FunctionType, ImportList, ImportName
    IncludeAction, NumericConstant, ParsedAlias, ParsedBlock, ParsedCall, ParsedCapture, ParsedExpression
    ParsedExternImport, ParsedExternalTraitImplementation, ParsedField, ParsedFunction, ParsedGenericParameter
    ParsedMatchBody, ParsedMatchCase, ParsedMethod, ParsedModuleImport, ParsedName, ParsedNameWithGenericParameters
    ParsedNamespace, ParsedParameter, ParsedPatternDefault, ParsedRecord, ParsedStatement, ParsedTrait, ParsedType
    ParsedTypeQualifiers, ParsedVarDecl, Parser, RecordType, TypeCast, UnaryOperator, Visibility
}
import types {
    BlockControlFlow, BuiltinType, CheckedBlock, CheckedCall, CheckedCapture, CheckedEnum, CheckedEnumVariant
    CheckedEnumVariantBinding, CheckedExpression, CheckedField, CheckedFunction, CheckedGenericParameter
    CheckedMatchBody, CheckedMatchCase, CheckedNamespace, CheckedNumericConstant, CheckedParameter, CheckedProgram
    CheckedQualifiers, CheckedStatement, CheckedStringLiteral, CheckedStruct, CheckedTrait, CheckedTypeCast
    CheckedUnaryOperator, CheckedVariable, CheckedVisibility, ClassInstanceRebind, EnumId, FieldRecord
    FunctionGenericParameter, FunctionGenerics, FunctionId, GenericInferences, IterationDecision, LoadedModule
    MaybeResolvedScope, Module, ModuleId, NumberConstant, OperatorTraitImplementation, ResolvedNamespace, SafetyMode
    Scope, ScopeId, SpecializedType, StringLiteral, StructId, StructLikeId, TraitId, Type, TypeId, Value, VarId
    builtin, comptime_format_impl, never_type_id, unknown_type_id, void_type_id
}
import types
import utility { FileId, Span, add_arrays, escape_for_quotes, join, panic, todo, map, write_to_file }
import jakt::path { Path, get_path_separator }
import compiler { Compiler }
import interpreter { Interpreter, InterpreterScope, ExecutionResult, value_to_checked_expression }

import cpp_import::common { choose_processor, CppImportErrors }
import choose_processor() { CppImportProcessor }

import jakt::platform { platform_module }
import platform_module("jakt::platform::fs")

enum FunctionMatchResult {
    MatchSuccess(args: [CheckedExpression], maybe_this_type_id: TypeId?, used_generic_inferences: [TypeId:TypeId], specificity: i64)
    MatchError(errors: [JaktError])
}

struct TraitImplementationDescriptor {
    trait_id: TraitId
    trait_name: String
    implemented_type_args: [TypeId]
}

struct ImportRestrictions {
    functions: bool = false
    structs: bool = false
    enums: bool = false
    types: bool = false
    traits: bool = false
    namespaces: bool = false

    fn all() -> ImportRestrictions => ImportRestrictions(
        functions: true
        structs: true
        enums: true
        types: true
        traits: true
        namespaces: true
    )
}

enum NumericOrStringValue {
    StringValue(String)
    SignedNumericValue(i64)
    UnsignedNumericValue(u64)
}

// [foo:[1,2], bar:[4,5]] -> [foo:1,bar:4], [foo:1,bar:5], [foo:2,bar:4], [foo:2,bar:5]
// [K:[V]] -> [K:V]
struct InternalDictionaryProduct<K, V> implements(Iterable<[K:V]>) {
    dict: [K:[V]]
    current: [K:V]
    current_index: [K:usize]
    done: bool = false

    fn next(mut this) -> [K:V]? {
        if .done {
            return None
        }

        mut next: [K:V] = [:]
        for key in .dict.keys() {
            let value = .dict[key][.current_index[key]]
            next[key] = value
        }

        .current = next

        for (key, values) in .dict {
            let index = .current_index[key]
            if index + 1 < values.size() {
                .current_index[key] = index + 1
                return next
            }
            .current_index[key] = 0
        }

        .done = true
        return next
    }
}

// FIXME: Can't put this inside the struct, this function being generic causes
//        the compiler to emit no generic parameters for the struct, which makes C++ angry
//        and making it *not* generic makes the compiler emit no generic parameters at all.
//        This is a compiler bug.
fn create_internal_dictionary_product<R, S>(dict: [R:[S]]) -> InternalDictionaryProduct<R, S> {
    mut current_index: [R:usize] = [:]
    for (key, _) in dict {
        current_index[key] = 0
    }
    let current: [R:S] = [:]
    return InternalDictionaryProduct(dict, current, current_index)
}

struct Typechecker {
    compiler: Compiler
    program: CheckedProgram
    current_module_id: ModuleId
    current_struct_type_id: TypeId?
    current_function_id: FunctionId?
    inside_defer: bool
    checkidx: usize
    ignore_errors: bool
    dump_type_hints: bool
    dump_try_hints: bool
    lambda_count: u64
    generic_inferences: GenericInferences
    self_type_id: TypeId? = None
    root_module_name: String
    in_comptime_function_call: bool = false
    had_an_error: bool = false
    cpp_import_cache: [String:ScopeId]
    cpp_import_processor: CppImportProcessor? = None

    fn set_self_type_id(mut this, anon type_id: TypeId) {
        if .get_type(type_id) is Struct(struct_id) and .get_struct(struct_id).implements_type is Some(replacement_type_id) {
            .self_type_id = replacement_type_id
        } else {
            .self_type_id = type_id
        }
    }

    fn type_name(this, anon type_id: TypeId, debug_mode: bool = false) throws -> String {
        mut id = type_id
        if .program.get_type(id) is Self and .self_type_id.has_value() {
            id = .self_type_id!
        }
        return .program.type_name(id, debug_mode)
    }

    fn dump_type_hint(this, type_id: TypeId, span: Span) throws {
        println("{{\"type\":\"hint\",\"file_id\":{},\"position\":{},\"typename\":\"{}\"}}"
                span.file_id.id, span.end, .type_name(type_id))
    }

    fn dump_try_hint( this, span: Span) {
        println("{{\"type\":\"try\",\"file_id\":{},\"position\":{}}}"
                span.file_id.id, span.start)
    }

    fn typecheck(mut compiler: Compiler, parsed_namespace: ParsedNamespace) throws -> Typechecker {

        let input_file = compiler.current_file

        if not input_file.has_value() {
            compiler.panic("trying to typecheck a non-existent file")
        }

        let true_module_name = compiler.files[input_file!.id].basename(strip_extension: true)

        let placeholder_module_id = ModuleId(id: 0)
        let root_module_name = compiler.current_file_path()!.basename(strip_extension: true)

        mut typechecker = Typechecker(
            compiler
            program: CheckedProgram(compiler),
            current_module_id: placeholder_module_id,
            current_struct_type_id: TypeId::none()
            current_function_id: None
            inside_defer: false
            checkidx: 0uz
            ignore_errors: false
            dump_type_hints: compiler.dump_type_hints
            dump_try_hints: compiler.dump_try_hints
            lambda_count: 0
            generic_inferences: GenericInferences(values: [:])
            root_module_name
            cpp_import_cache: [:]
        )

        typechecker.include_prelude()


        let root_module_id = typechecker.create_module(name: root_module_name, is_root: true)
        typechecker.current_module_id = root_module_id
        compiler.set_current_file(input_file!)

        let loaded_module = LoadedModule(
            module_id: root_module_id
            file_id: input_file!
        )
        typechecker.program.set_loaded_module(
            module_name: true_module_name
            loaded_module
        )

        let PRELUDE_SCOPE_ID: ScopeId = typechecker.prelude_scope_id()
        let root_scope_id = typechecker.create_scope(parent_scope_id: PRELUDE_SCOPE_ID, can_throw: false, debug_name: "root", for_block: false)
        typechecker.typecheck_module_import(
            import_: ParsedModuleImport(
                module_name: ImportName::Literal(
                    name: "jakt::prelude::prelude"
                    span: Span(file_id: FileId(id: 0), start: 0, end: 0)
                ),
                alias_name: None
                import_list: ImportList::All
                relative_path: false
                parent_path_count: 0
            )
            scope_id: root_scope_id
        )

        for (_, struct_id) in typechecker.program.modules[0].builtin_implementation_structs {
            let struct_ = typechecker.get_struct(struct_id)
            typechecker.typecheck_entity_trait_implementations_predecl(
                scope_id: struct_.scope_id
                type_id: struct_.type_id
                trait_implementations: struct_.trait_implementations
                name: struct_.name
                name_span: struct_.name_span
            )
        }

        for (_, struct_id) in typechecker.program.modules[0].builtin_implementation_structs {
            let struct_ = typechecker.get_struct(struct_id)
            typechecker.typecheck_entity_trait_implementations(
                scope_id: struct_.scope_id
                type_id: struct_.type_id
                trait_implementations: struct_.trait_implementations
                name: struct_.name
                name_span: struct_.name_span
            )
        }

        typechecker.typecheck_module(parsed_namespace, scope_id: root_scope_id)

        return typechecker
    }

    fn get_function(this, anon id: FunctionId) -> CheckedFunction => .program.get_function(id)
    fn get_variable(this, anon id: VarId) -> CheckedVariable => .program.get_variable(id)
    fn get_trait(this, anon id: TraitId) -> CheckedTrait => .program.get_trait(id)
    fn get_type(this, anon id: TypeId) -> Type => .program.get_type(id)
    fn get_enum(this, anon id: EnumId) -> CheckedEnum => .program.get_enum(id)
    fn get_struct(this, anon id: StructId) -> CheckedStruct => .program.get_struct(id)
    fn get_scope(this, anon id: ScopeId) -> Scope => .program.get_scope(id)
    fn find_var_in_scope(
        this
        scope_id: ScopeId
        var: String
        root_scope_id: ScopeId? = None
    ) throws -> CheckedVariable? => .program.find_var_in_scope(scope_id, var, root_scope_id)

    fn lookup_struct_field(this, struct_id: StructId, name: String) -> FieldRecord? {
        mut chain: [StructId] = []
        mut current = Some(struct_id)

        chain.push(current!)

        while current.has_value() {
            let parent = .get_struct(current!).super_struct_id
            if parent.has_value() {
                chain.push(parent!)
            }
            current = parent
        }

        for current_struct_id in chain {
            for field in .get_struct(current_struct_id).fields {
                let variable = .get_variable(field.variable_id)
                if variable.name == name {
                    return FieldRecord(struct_id: current_struct_id, field_id: field.variable_id)
                }
            }
        }

        return None
    }

    fn find_comptime_binding_in_scope(this, scope_id: ScopeId, anon name: String) throws -> Value? => .program.find_comptime_binding_in_scope(scope_id, name)

    fn get_root_path(this) -> Path {
        let root_module = .program.get_loaded_module(.root_module_name)
        if root_module.has_value() {
            let file_id = root_module!.file_id
            return .compiler.get_file_path(file_id)!
        }

        return Path::from_string(".")
    }
    fn prelude_scope_id(this) -> ScopeId => .program.prelude_scope_id()
    fn root_scope_id(this) -> ScopeId => ScopeId(module_id: ModuleId(id: 1), id: 0)

    fn current_module(this) -> Module => .program.get_module(.current_module_id)

    public fn scope_can_access(this, accessor: ScopeId, accessee: ScopeId) -> bool {
        if accessor.equals(accessee) {
            return true
        }
        mut accessor_scope = .get_scope(accessor)
        while accessor_scope.parent.has_value() {
            let parent = accessor_scope.parent!
            if parent.equals(accessee) {
                return true
            }
            accessor_scope = .get_scope(parent)
        }
        return false
    }

    fn error(mut this, anon message: String, anon span: Span) {
        .had_an_error = true
        if not .ignore_errors {
            .compiler.errors.push(JaktError::Message(message, span))
        } else {
            .had_an_error = true
        }
    }

    fn error_with_hint(mut this, anon message: String, anon span: Span, anon hint: String, anon hint_span: Span) {
        if not .ignore_errors {
            .compiler.errors.push(JaktError::MessageWithHint(message, span, hint, hint_span))
        } else {
            .had_an_error = true
        }
    }

    fn is_integer(this, anon type_id: TypeId) -> bool => .program.is_integer(type_id)
    fn is_floating(this, anon type_id: TypeId) -> bool => .program.is_floating(type_id)
    fn is_numeric(this, anon type_id: TypeId) -> bool => .program.is_numeric(type_id)

    fn create_scope(mut this, parent_scope_id: ScopeId?, can_throw: bool, debug_name: String, for_block: bool = true) -> ScopeId => .program.create_scope(parent_scope_id, can_throw, debug_name, module_id: .current_module_id, for_block)

    fn create_module(mut this, name: String, is_root: bool, path: String? = None) -> ModuleId {
        let new_id = .program.modules.size()
        let module_id = ModuleId(id: new_id)
        let module = Module(
            id: module_id,
            name: name,
            types: [ // FIXME: use general builtin types array
                Type::Void,
                Type::Bool,
                Type::U8,
                Type::U16,
                Type::U32,
                Type::U64,
                Type::I8,
                Type::I16,
                Type::I32,
                Type::I64,
                Type::F32,
                Type::F64,
                Type::Usize,
                Type::JaktString,
                Type::CChar,
                Type::CInt,
                Type::Unknown,
                Type::Never
            ],
            resolved_import_path: path ?? .compiler.current_file_path()!.to_string(),
            is_root: is_root,
        )
        .program.modules.push(module)

        return module_id
    }

    private comptime get_prelude_contents() throws -> [u8] {
        // FIXME: Don't hardcode the relative runtime path.
        mut file = File::open_for_reading("../runtime/prelude.jakt")
        return file.read_all()
    }

    fn include_prelude(mut this) throws {
        let module_name = "__prelude__"
        let file_name = Path::from_string(module_name)
        let file_contents = get_prelude_contents()

        let old_file_id = .compiler.current_file
        let old_file_contents = .compiler.current_file_contents
        defer {
            .compiler.current_file = old_file_id
            .compiler.current_file_contents = old_file_contents
        }

        let file_id = .compiler.get_file_id_or_register(file_name)

        // We manually set the compiler's current_file and current_file_contents fields here
        // for now, because this is a special case.

        .compiler.current_file = file_id
        .compiler.current_file_contents = file_contents

        // we are using the root module (so it doesn't have to be optional)
        let prelude_module_id = .create_module(name: module_name, is_root: false)
        .current_module_id = prelude_module_id
        .program.set_loaded_module(
            module_name
            loaded_module: LoadedModule(
                module_id: prelude_module_id
                file_id
         ))

        let prelude_scope_id = .create_scope(
            parent_scope_id: None
            can_throw: false
            debug_name: "prelude"
            for_block: false
        )

        let tokens = Lexer::lex(compiler: .compiler)

        if .compiler.dump_lexer {
            for token in tokens {
                println("token: {}", token)
            }
        }

        let parsed_namespace = Parser::parse(compiler: .compiler, tokens)

        if .compiler.dump_parser {
            println("{:#}", parsed_namespace)
        }

        .compiler.dbg_println(format("before typechecking parsed prelude, modules ‘{}’", .program.modules))
        .typecheck_module(
            parsed_namespace
            scope_id: prelude_scope_id
        )
    }

    fn lex_and_parse_file_contents(mut this, file_id: FileId) throws -> ParsedNamespace? {
        let old_file_state = .compiler.current_file_state()

        if not .compiler.set_current_file(file_id) {
            return None
        }
        defer .compiler.restore_file_state(old_file_state)

        let tokens = Lexer::lex(compiler: .compiler)

        if .compiler.dump_lexer {
            for token in tokens {
                println("token: {}", token)
            }
        }

        let parsed_namespace = Parser::parse(compiler: .compiler, tokens)

        if .compiler.dump_parser {
            println("{:#}", parsed_namespace)
        }

        return parsed_namespace
    }

    fn find_struct_in_prelude(this, anon name: String) throws -> StructId =>
        .program.find_struct_in_prelude(name)

    fn prelude_struct_type_named(mut this, anon name: String) throws -> TypeId {
        let struct_id = .find_struct_in_prelude(name)
        let type = Type::Struct(struct_id)
        return .find_or_add_type_id(type)
    }

    fn find_type_in_prelude(this, anon name: String) throws -> TypeId {
        // start at the prelude scope id
        let scope_id = .prelude_scope_id()
        let type_id = .find_type_in_scope(scope_id, name)
        if type_id.has_value() {
            return type_id.value()
        }
        .compiler.panic(format("internal error: {} builtin definition not found", name))
    }

    fn unify(mut this, lhs: TypeId, lhs_span: Span, rhs: TypeId, rhs_span: Span) throws -> TypeId? {
        if not .check_types_for_compat(lhs_type_id: lhs, rhs_type_id: rhs, generic_inferences: &mut .generic_inferences, span: lhs_span) {
            return None
        }

        return .substitute_typevars_in_type(type_id: lhs, generic_inferences: .generic_inferences)
    }

    fn unify_with_type(mut this, found_type: TypeId, expected_type: TypeId?, span: Span) throws -> TypeId {
        if not expected_type.has_value() {
            return found_type
        }
        if expected_type!.equals(unknown_type_id()) {
            return found_type
        }
        if .check_types_for_compat(lhs_type_id: expected_type!, rhs_type_id: found_type, generic_inferences: &mut .generic_inferences, span) {
            return found_type
        }

        return .substitute_typevars_in_type(type_id: found_type, generic_inferences: .generic_inferences)
    }

    fn find_or_add_type_id(mut this, anon type: Type) -> TypeId => .program.find_or_add_type_id(type, module_id: .current_module_id)

    fn find_type_in_scope(this, scope_id: ScopeId, name: String) throws -> TypeId? {
        return .program.find_type_in_scope(scope_id, name)
    }

    fn find_trait_in_scope(this, scope_id: ScopeId, name: String) throws -> TraitId? {
        return .program.find_trait_in_scope(scope_id, name)
    }

    fn find_singular_trait_implementation(
        mut this
        type_id: TypeId
        trait_name: String
        scope_id: ScopeId
        span: Span
        filter_for_generics: [TypeId]? = None
    ) throws -> TraitImplementationDescriptor? {
        let trait_id = .find_trait_in_scope(scope_id, name: trait_name)
        if not trait_id.has_value() {
            return None
        }

        let trait_impls = .find_all_implementations_of_trait(type_id, trait_id: trait_id!, filter_for_generics)
        if trait_impls.is_empty() {
            return None
        }

        if trait_impls.size() > 1 {
            .error(
                message: format("type ‘{}’ implements trait ‘{}’ more than once, but a singular implementation is allowed", .type_name(type_id), trait_name)
                span
            )
        }

        return TraitImplementationDescriptor(
            trait_id: trait_id!
            trait_name
            implemented_type_args: trait_impls[0]
        )
    }

    fn find_any_singular_trait_implementation(
        mut this
        type_id: TypeId
        trait_names: [String]
        scope_id: ScopeId
        span: Span
        filter_for_generics: [TypeId]? = None
    ) throws -> TraitImplementationDescriptor? {
        for trait_name in trait_names {
            let maybe_impl = .find_singular_trait_implementation(type_id, trait_name, scope_id, span, filter_for_generics)
            if maybe_impl.has_value() {
                return maybe_impl
            }
        }

        return None
    }

    fn find_type_scope(this, scope_id: ScopeId, name: String) throws -> (TypeId, ScopeId)? {
        return .program.find_type_scope(scope_id, name)
    }


    // Find the namespace in the current scope, or one of its parents,
    // and whether the found scope was an import.
    fn find_namespace_in_scope(this, scope_id: ScopeId, name: String, treat_aliases_as_imports: bool = false, root_scope: ScopeId? = None) throws -> (ScopeId, bool)? {
        return .program.find_namespace_in_scope(scope_id, name, treat_aliases_as_imports, root_scope)
    }

    fn add_struct_to_scope(mut this, scope_id: ScopeId, name: String, struct_id: StructId, span: Span) throws -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_scope_id = scope.structs.get(name)
        if maybe_scope_id.has_value() {
            if .get_scope(scope_id).is_from_generated_code {
                return false
            }

            let existing_struct_id = maybe_scope_id!
            let definition_span = .get_struct(existing_struct_id).name_span
            .error_with_hint(
                format("redefinition of struct/class {}", name)
                span
                format("struct/class {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.structs.set(key: name, value: struct_id)
        return true
    }

    fn add_enum_to_scope(mut this, scope_id: ScopeId, name: String, enum_id: EnumId, span: Span) -> bool {
        mut scope = .get_scope(scope_id)
        let maybe_enum_id = scope.enums.get(name)
        if maybe_enum_id.has_value() {
            if .get_scope(scope_id).is_from_generated_code {
                return false
            }

            let existing_enum_id = maybe_enum_id!
            let definition_span = .get_enum(existing_enum_id).name_span

            .error_with_hint(
                format("redefinition of enum {}", name)
                span
                format("enum {} was first defined here", name)
                definition_span
            )
            return false
        }
        scope.enums.set(key: name, value: enum_id)
        return true
    }

    fn add_type_to_scope(mut this, scope_id: ScopeId, type_name: String, type_id: TypeId, span: Span) throws -> bool {
        mut scope = .get_scope(id: scope_id)
        let found_type_id = scope.types.get(type_name)
        if found_type_id.has_value() and not found_type_id!.equals(type_id) {
            // FIXME: Show hint of the original definition, once we store the name span.
            if .get_scope(scope_id).is_from_generated_code {
                return false
            }

            .error(
                format(
                    "Redefinition of type ‘{}’ (duplicate: {} in {})",
                    type_name
                    .type_name(found_type_id!, debug_mode: true)
                    .debug_description_of(scope_id)
                )
                span
            )

            .generic_inferences.debug_description(program: &.program)

            return false
        }

        scope.types.set(key: type_name, value: type_id)
        return true
    }

    fn add_trait_to_scope(mut this, scope_id: ScopeId, trait_name: String, trait_id: TraitId, span: Span) throws -> bool {
        mut scope = .get_scope(id: scope_id)
        let found_trait_id = scope.traits.get(trait_name)
        if found_trait_id.has_value() and not found_trait_id!.equals(trait_id) {
            .error(
                format("Redefinition of trait ‘{}’", trait_name)
                span
            )
            return false
        }
        scope.traits.set(key: trait_name, value: trait_id)
        return true
    }

    fn add_function_to_scope(mut this, parent_scope_id: ScopeId, name: String, overload_set: [FunctionId], span: Span) -> bool {
        mut scope = .get_scope(id: parent_scope_id)

        if scope.functions.contains(name) {
            let existing_function_binding = scope.functions[name]

            for function_id in overload_set {
                let function_to_add = .get_function(function_id)
                for existing_function_id in existing_function_binding {
                    let existing_function = .get_function(existing_function_id)
                    if function_to_add.signature_matches(existing_function) {
                        if .get_scope(parent_scope_id).is_from_generated_code {
                            continue
                        }
                        .error_with_hint(
                            format("Redefinition of function ‘{}’.", function_to_add.name)
                            function_to_add.parsed_function!.name_span
                            "Previous definition is here"
                            existing_function.parsed_function!.name_span
                        )
                    }
                }

                scope.functions[name].push(function_id)
            }
        } else {
            scope.functions.set(key: name, value: overload_set)
        }

        .program.set_owner_scope_if_needed(parent_scope_id, overload_set, span)
        return true
    }

    fn add_var_to_scope(mut this, scope_id: ScopeId, name: String, var_id: VarId, span: Span) -> bool {
        mut scope = .get_scope(scope_id)
        let existing_var = scope.vars.get(name)
        if existing_var.has_value() {
            let variable_ = .get_variable(existing_var!)
            .error_with_hint(message: format("Redefinition of variable ‘{}’", name), span, hint: "previous definition here", hint_span: variable_.definition_span)
        }
        scope.vars.set(key: name, value: var_id)
        .program.set_owner_scope_if_needed(parent_scope_id: scope_id, var_id)
        return true
    }

    fn add_comptime_binding_to_scope(mut this, scope_id: ScopeId, name: String, value: Value, span: Span) -> bool {
        mut scope = .get_scope(scope_id)
        let existing_binding = scope.comptime_bindings.get(name)
        if existing_binding.has_value() {
            .error_with_hint(
                message: format("Redefinition of comptime variable ‘{}’", name)
                span
                hint: "previous definition here"
                hint_span: existing_binding!.span)
        }
        scope.comptime_bindings.set(key: name, value)
        return true
    }

    fn find_functions_with_name_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        root_scope_id: ScopeId? = None
    ) throws -> [FunctionId]? {
        return .program.find_functions_with_name_in_scope(parent_scope_id, function_name, root_scope_id)
    }

    fn find_scoped_functions_with_name_in_scope(
        this
        parent_scope_id: ScopeId
        function_name: String
        root_scope_id: ScopeId? = None
    ) throws -> ([FunctionId], ScopeId)? {
        return .program.find_scoped_functions_with_name_in_scope(parent_scope_id, function_name, root_scope_id)
    }

    fn find_function_matching_signature_in_scope(this, parent_scope_id: ScopeId, prototype: ParsedFunction) throws -> FunctionId? {
        let function_name  = prototype.name
        let candidate_ids = .program.find_functions_with_name_in_scope(parent_scope_id, function_name)
        if candidate_ids.has_value() {
            for candidate_id in candidate_ids!.iterator() {
                let candidate = .get_function(candidate_id)
                if candidate.parsed_function.has_value() and candidate.parsed_function!.equals(prototype) {
                    return candidate_id
                }
            }
        }
        return None
    }

    fn find_function_matching_trait_implementation_in_scope(
        mut this
        self_type_id: TypeId
        parent_scope_id: ScopeId
        function_name: String
        trait_descriptor: &TraitImplementationDescriptor
    ) throws -> FunctionId? {
        let trait_ = .get_trait(trait_descriptor.trait_id)
        guard trait_.requirements is Methods(methods) else {
            return None
        }

        guard methods.contains(function_name) else {
            return None
        }

        guard .program.find_functions_with_name_in_scope(parent_scope_id, function_name) is Some(candidate_ids) else {
            return None
        }


        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        .generic_inferences.set_all(keys: trait_.generic_parameters, values: trait_descriptor.implemented_type_args)

        let expected_function = .get_function(methods[function_name])
        for candidate_id in candidate_ids {
            let candidate = .get_function(candidate_id)
            if .signatures_match(self_type_id, candidate, expected_function).0 {
                return candidate_id
            }
        }

        return None
    }

    fn find_struct_in_scope(this, scope_id: ScopeId, name: String, root_scope: ScopeId? = None) throws -> StructId? =>
        .program.find_struct_in_scope(scope_id, name, root_scope)

    fn unwrap_type_from_optional_if_needed(this, type: Type) throws -> Type {
        let optional_struct_id = .find_struct_in_prelude("Optional")

        if type is GenericInstance(id, args) and id.equals(optional_struct_id) {
            return .get_type(args[0])
        }

        return type
    }

    fn get_type_ids_from_type_hint_if_struct_ids_match(this, type_hint: TypeId?, expected_struct_id: StructId) throws -> [TypeId]? {
        if not type_hint.has_value() {
            return None
        }

        if .unwrap_type_from_optional_if_needed(type: .get_type(type_hint!)) is GenericInstance(id, args) and id.equals(expected_struct_id) {
            return args
        }

        return None
    }

    fn typecheck_module(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        .typecheck_namespace_imports(parsed_namespace, scope_id)
        .typecheck_namespace_predecl(parsed_namespace, scope_id)
        .typecheck_namespace_methods_predecl(parsed_namespace, scope_id, comptime_pass: true, generic_pass: false)
        .typecheck_namespace_methods_predecl(parsed_namespace, scope_id, comptime_pass: false, generic_pass: false)
        .typecheck_namespace_methods_predecl(parsed_namespace, scope_id, comptime_pass: true, generic_pass: true)
        .typecheck_namespace_methods_predecl(parsed_namespace, scope_id, comptime_pass: false, generic_pass: true)
        .typecheck_namespace_aliases(parsed_namespace, scope_id, allow: ImportRestrictions(structs: true, enums: true, types: true, traits: true, namespaces: true))
        .typecheck_namespace_fields(parsed_namespace, scope_id)
        .typecheck_namespace_constructors(parsed_namespace, scope_id)
        .typecheck_namespace_function_predecl(parsed_namespace, scope_id, comptime_pass: true, generic_pass: false)
        .typecheck_namespace_function_predecl(parsed_namespace, scope_id, comptime_pass: false, generic_pass: false)
        .typecheck_namespace_function_predecl(parsed_namespace, scope_id, comptime_pass: true, generic_pass: true)
        .typecheck_namespace_function_predecl(parsed_namespace, scope_id, comptime_pass: false, generic_pass: true)
        .typecheck_namespace_aliases(parsed_namespace, scope_id, allow: ImportRestrictions(functions: true))
        .typecheck_namespace_declarations(parsed_namespace, scope_id, comptime_pass: true, generic_pass: false)
        .typecheck_namespace_declarations(parsed_namespace, scope_id, comptime_pass: true, generic_pass: true)
        .typecheck_namespace_declarations(parsed_namespace, scope_id, comptime_pass: false, generic_pass: false)
        .typecheck_namespace_declarations(parsed_namespace, scope_id, comptime_pass: false, generic_pass: true)
    }

    fn typecheck_visibility(mut this, visibility: Visibility, scope_id: ScopeId) throws -> CheckedVisibility {
        return match visibility {
            Private => CheckedVisibility::Private
            Public => CheckedVisibility::Public
            Restricted(whitelist, span) => {
                mut restricted_scopes: [MaybeResolvedScope] = []
                for entry in whitelist {
                    mut parent_scope = MaybeResolvedScope::Resolved(scope_id)
                    for ns in entry.namespace_ {
                        parent_scope = MaybeResolvedScope::Unresolved(parent_scope, relative_name: ns)
                    }

                    mut unresolved = MaybeResolvedScope::Unresolved(
                        parent_scope
                        relative_name: entry.name
                    )

                    restricted_scopes.push(unresolved.try_resolve(program: .program))
                }

                yield CheckedVisibility::Restricted(scopes: restricted_scopes, span)
            }
        }
    }

    fn typecheck_namespace_fields(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_fields(parsed_namespace: child_namespace,
                scope_id: child_namespace_scope_id)
        }

        // Check the forall chunks
        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_fields(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                    )
                }
            }
        }

        mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (record, scope_id) = records_to_process.dequeue()
            let id = match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        .compiler.panic("can't find previously added struct")
                    }
                    .typecheck_struct_fields(record, struct_id: struct_id!)
                    yield StructLikeId::Struct(struct_id!)
                }
                ValueEnum | SumEnum => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        .compiler.panic("can't find previously added enum")
                    }
                    yield StructLikeId::Enum(enum_id!)
                }
                else => {
                    continue
                }
            }
            for nested_record in record.nested_records {
                .warn_about_unimplemented_nested_record(nested_record)
                records_to_process.enqueue((nested_record, id.scope_id(&.program)))
            }
        }
    }

    fn warn_about_unimplemented_nested_record(mut this, anon record: ParsedRecord) throws {
        if record.definition_linkage is Internal {
            .error(
                "Only external nested types are currently supported"
                record.name_span
            )
        }
    }

    fn typecheck_struct_fields(mut this, record: ParsedRecord, struct_id: StructId) throws {
        mut structure = .get_struct(struct_id)

        let checked_struct_scope_id = .get_struct(struct_id).scope_id
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let old_self_type_id = .self_type_id
        .set_self_type_id(struct_type_id)
        defer .self_type_id = old_self_type_id

        let parsed_fields = match record.record_type {
            Struct(fields) => fields
            Class(fields) => fields
            else => {
                .compiler.panic("typecheck_struct_fields cannot handle non-structs")
            }
        }

        let in_generated_code = .get_scope(structure.scope_id).is_from_generated_code

        for unchecked_member in parsed_fields {
            let parsed_var_decl = unchecked_member.var_decl
            let checked_member_type = .typecheck_typename(parsed_type: parsed_var_decl.parsed_type, scope_id: checked_struct_scope_id, name: parsed_var_decl.name)

            if not in_generated_code {
                .check_that_type_doesnt_contain_reference(type_id: checked_member_type, span: parsed_var_decl.parsed_type.span())
            }

            mut module = .current_module()
            let variable_id = module.add_variable(checked_variable: CheckedVariable(
                name: parsed_var_decl.name
                type_id: checked_member_type
                is_mutable: parsed_var_decl.is_mutable
                definition_span: parsed_var_decl.span
                type_span: None
                visibility: .typecheck_visibility(visibility: unchecked_member.visibility, scope_id: checked_struct_scope_id)
                external_name: parsed_var_decl.external_name
            ))

            let default_value_expression = match unchecked_member.default_value.has_value() {
                true => Some(unchecked_member.default_value!, checked_struct_scope_id)
                false => None
            }

            structure.fields.push(CheckedField(variable_id, default_value_expression))

        }
    }

    fn typecheck_module_import(mut this, anon import_: ParsedModuleImport, scope_id: ScopeId) throws {
        // load the module if not present
        let module_names_and_spans = match import_.module_name {
            Literal(name, span) => Some([(name, span)])
            Comptime(expression) => {
                mut interpreter = .interpreter()
                mut eval_scope = InterpreterScope::from_runtime_scope(scope_id, program: .program)
                let exec_scope = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "comptime-import")

                let result = interpreter.execute_expression(
                    expr: .typecheck_expression(
                        expr: expression
                        scope_id: exec_scope
                        safety_mode: SafetyMode::Safe,
                        type_hint: None
                    )
                    scope: eval_scope
                )
                yield match result {
                    Return | Yield | Continue | Break => {
                        .error_with_hint(
                            message: "module name must evaluate to a string literal or an array of strings"
                            span: expression.span()
                            hint: "this expression evaluates to an invalid value"
                            hint_span: expression.span()
                        )
                        yield None
                    }
                    Throw(error) => {
                        .error_with_hint(
                            message: "module name must evaluate to a string literal or an array of strings"
                            span: expression.span()
                            hint: format("this expression threw an error: {}", error)
                            hint_span: expression.span()
                        )
                        yield None
                    }
                    JustValue(value) => match value.impl {
                        JaktString(string) => Some([(string, value.span)])
                        JaktArray(values) => {
                            if values.is_empty() {
                                .error_with_hint(
                                    message: "module name must evaluate to a string literal or an array of strings"
                                    span: expression.span()
                                    hint: "this expression evaluates to an empty array"
                                    hint_span: expression.span()
                                )
                            }

                            mut result: [(String, Span)] = []
                            for value in values {
                                match value.impl {
                                    JaktString(string) => result.push((string, value.span))
                                    else => {
                                        .error_with_hint(
                                            message: "module name must evaluate to a string literal or an array of strings"
                                            span: value.span
                                            hint: "this expression evaluates to an invalid value"
                                            hint_span: value.span
                                        )
                                    }
                                }
                            }
                            yield Some(result)
                        }
                        else => {
                            .error_with_hint(
                                message: "module name must evaluate to a string literal"
                                span: expression.span()
                                hint: "this expression evaluates to a non-string value"
                                hint_span: expression.span()
                            )
                            yield None
                        }
                    }
                }
            }
        }

        if not module_names_and_spans.has_value() { return }
        let parent_path_count = import_.parent_path_count
        let import_is_relative = import_.relative_path

        mut module_name_and_span: (String, Span)? = None
        mut names: [String] = []
        for name_and_span in module_names_and_spans! {
            names.push(name_and_span.0)

            mut maybe_loaded_module = .program.get_loaded_module(name_and_span.0)
            if not maybe_loaded_module.has_value() {
                let maybe_file_name = .compiler.search_for_path(input_module_name: name_and_span.0, relative_import: import_is_relative, parent_path_count: parent_path_count)
                let file_name = match maybe_file_name.has_value() {
                    true => maybe_file_name!
                    false => .get_root_path().parent().join(name_and_span.0).replace_extension("jakt")
                }
                if File::exists(file_name.to_string()) {
                    module_name_and_span = name_and_span
                    break
                }
            } else {
                module_name_and_span = name_and_span
                break
            }
        }

        if not module_name_and_span.has_value() {
            .error(
                message: format("No module in module set {{{}}} was found", join(names, separator: ", "))
                span: import_.module_name.span()
            )
            return
        }

        let (module_name, module_span) = module_name_and_span!

        let sanitized_module_name = module_name.replace(replace: ":", with: "_")

        mut imported_module_id = ModuleId(id: 0)
        mut maybe_loaded_module = .program.get_loaded_module(sanitized_module_name)
        if not maybe_loaded_module.has_value() {
            let maybe_file_name = .compiler.search_for_path(input_module_name: module_name, relative_import: import_is_relative, parent_path_count: parent_path_count)
            let file_name = match maybe_file_name.has_value() {
                true => maybe_file_name!
                false => .get_root_path().parent().join(module_name).replace_extension("jakt")
            }

            let file_id = .compiler.get_file_id_or_register(file_name)

            let parsed_namespace = .lex_and_parse_file_contents(file_id)

            if not parsed_namespace.has_value() {
                .error(
                    format("Module '{}' not found", module_name)
                    module_span
                )
                return
            }

            let original_current_module_id = .current_module_id
            imported_module_id = .create_module(name: sanitized_module_name, is_root: false, path: file_name.to_string())
            .program.set_loaded_module(
                module_name: sanitized_module_name
                loaded_module: LoadedModule(
                    module_id: imported_module_id
                    file_id
                ))

            .current_module_id = imported_module_id

            let imported_scope_id = .create_scope(
                parent_scope_id: .root_scope_id()
                can_throw: false
                debug_name: format("module({})", sanitized_module_name)
                for_block: false
            )

            mut imported_scope = .get_scope(imported_scope_id)
            imported_scope.namespace_name = sanitized_module_name
            imported_scope.is_from_generated_code = parsed_namespace!.is_generated_code

            .typecheck_module(parsed_namespace: parsed_namespace!, scope_id: imported_scope_id)

            .current_module_id = original_current_module_id
        } else {
            imported_module_id = maybe_loaded_module!.module_id
        }

        mut current_module_imports = .current_module().imports
        current_module_imports.push(imported_module_id)

        if import_.import_list.is_empty() {
            // import everything into scope
            mut scope_imports = .get_scope(scope_id).imports
            mut import_name = module_name
            if import_.alias_name.has_value() {
                import_name = import_.alias_name!.literal_name()
            }
            scope_imports.set(
                key: import_name
                value: imported_module_id) // FIXME: Add span and should this be alias span if there is an alias?
        } else if import_.import_list is All {
            let import_scope = .get_scope(ScopeId(module_id: imported_module_id, id: 0))
            for (name, var_id) in import_scope.vars {
                .add_var_to_scope(
                    scope_id
                    name
                    var_id
                    span: import_.module_name.span()
                )
            }
            for (name, value) in import_scope.comptime_bindings {
                .add_comptime_binding_to_scope(
                    scope_id
                    name
                    value
                    span: import_.module_name.span()
                )
            }
            for (name, struct_id) in import_scope.structs {
                .add_struct_to_scope(
                    scope_id
                    name
                    struct_id
                    span: import_.module_name.span()
                )
            }
            for (name, overload_set) in import_scope.functions {
                .add_function_to_scope(
                    parent_scope_id: scope_id
                    name
                    overload_set
                    span: import_.module_name.span()
                )
            }
            for (name, enum_id) in import_scope.enums {
                .add_enum_to_scope(
                    scope_id
                    name
                    enum_id
                    span: import_.module_name.span()
                )
            }
            for (name, type_id) in import_scope.types {
                .add_type_to_scope(
                    scope_id
                    type_name: name
                    type_id
                    span: import_.module_name.span()
                )
            }
            for (name, trait_id) in import_scope.traits {
                .add_trait_to_scope(
                    scope_id
                    trait_name: name
                    trait_id
                    span: import_.module_name.span()
                )
            }
        } else if import_.import_list is List(names) {
            let import_scope_id = ScopeId(module_id: imported_module_id, id: 0)
            for imported_name in names {
                let found = .find_and_import_name_from_scope(
                    from_name: imported_name.literal_name()
                    from_span: imported_name.span()
                    to_name: imported_name.literal_name()
                    to_span: imported_name.span()
                    from_scope_id: import_scope_id
                    into_scope_id: scope_id
                )
                if not found {
                    .error(
                        format("Imported name '{}' not found in module '{}'", imported_name.literal_name(), module_name)
                        imported_name.span()
                    )
                }
            }
        }
    }

    fn find_and_import_name_from_scope(
        mut this
        from_name: String
        from_span: Span
        to_name: String
        to_span: Span
        from_scope_id: ScopeId
        into_scope_id: ScopeId
        allow: ImportRestrictions = ImportRestrictions::all()
    ) throws -> bool {
        mut found = false

        // if it is a function, add function to scope
        if allow.functions {
            let maybe_overload_set = .find_functions_with_name_in_scope(
                parent_scope_id: from_scope_id
                function_name: from_name
            )
            if maybe_overload_set.has_value() {
                found = true
                .add_function_to_scope(
                    parent_scope_id: into_scope_id
                    name: to_name
                    overload_set: maybe_overload_set!
                    span: to_span
                )
            }
        }

        // if it is an enum, add enum to scope
        if allow.enums {
            let maybe_enum_id = .program.find_enum_in_scope(
                scope_id: from_scope_id
                name: from_name
            )
            if maybe_enum_id.has_value() {
                found = true
                .add_enum_to_scope(
                    scope_id: into_scope_id
                    name: to_name
                    enum_id: maybe_enum_id!
                    span: to_span
                )
            }
        }

        if allow.types {
            // if it is a type, add type to scope
            let maybe_type_id = .find_type_in_scope(
                scope_id: from_scope_id
                name: from_name
            )
            if maybe_type_id.has_value() {
                found = true
                .add_type_to_scope(
                    scope_id: into_scope_id
                    type_name: to_name
                    type_id: maybe_type_id!
                    span: to_span
                )
            }
        }

        if allow.structs {
            // if it is a struct, add struct to scope
            let maybe_struct_id = .find_struct_in_scope(
                scope_id: from_scope_id
                name: from_name
            )
            if maybe_struct_id.has_value() {
                found = true
                .add_struct_to_scope(
                    scope_id: into_scope_id
                    name: to_name
                    struct_id: maybe_struct_id!
                    span: to_span
                )
            }
        }

        if allow.traits {
            // if it is a trait, add it to the scope
            let maybe_trait_id = .find_trait_in_scope(
                scope_id: from_scope_id
                name: from_name
            )
            if maybe_trait_id.has_value() {
                found = true
                .add_trait_to_scope(
                    scope_id: into_scope_id
                    trait_name: to_name
                    trait_id: maybe_trait_id!
                    span: to_span
                )
            }
        }

        if allow.namespaces {
            let maybe_scope_id = .find_namespace_in_scope(scope_id: from_scope_id, name: from_name)
            if maybe_scope_id.has_value() {
                found = true
                mut scope = .get_scope(into_scope_id)
                scope.aliases.set(to_name, maybe_scope_id!.0)
            }
        }

        return found
    }

    fn cache_or_process_cpp_import(
        mut this
        import_path: Path
        scope_id: ScopeId
        is_c: bool
        defines: [String:String]
    ) throws -> ScopeId {
        if not .cpp_import_processor.has_value() {
            .cpp_import_processor = CppImportProcessor::create()
        }

        mut module = .program.get_module(scope_id.module_id)

        let result_scope_id = .cpp_import_processor!.process_cpp_import(program: &mut .program, import_path, scope_id, is_c, defines)

        return result_scope_id
    }

    fn typecheck_extern_import(mut this, anon import_: ParsedExternImport, scope_id: ScopeId) throws {
        for f in import_.assigned_namespace.functions {
            if not f.linkage is External {
                .error("Expected all functions in an `import extern` to be be external", f.name_span)
            }

            if import_.is_c and not f.generic_parameters.is_empty() {
                .error_with_hint(
                    format("imported function '{}' is declared to have C linkage, but is generic", f.name)
                    f.name_span
                    "this function may not be generic"
                    f.name_span)
            }

            if not f.block.stmts.is_empty() {
                .error("imported extern function is not allowed to have a body"
                        f.name_span)
            }
        }

        for record in import_.assigned_namespace.records {
            if not record.definition_linkage is External {
                .error("Expected all records in an `import extern` to be external"
                        record.name_span)
            }
            if import_.is_c and not record.generic_parameters.is_empty() {
                .error_with_hint(
                    format("imported {} '{}' is declared to have C linkage, but is generic",
                        record.record_type.record_type_name()
                        record.name)
                    record.name_span,
                    format("this {} may not be generic", record.record_type.record_type_name())
                    record.name_span)
            }
        }
    }

    fn typecheck_namespace_imports(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        for module_import in parsed_namespace.module_imports {
            .typecheck_module_import(module_import, scope_id)
        }

        mut coalesced_imports: [ParsedExternImport] = []

        for extern_import in parsed_namespace.extern_imports {
            if not extern_import.should_auto_import {
                continue
            }

            let path = extern_import.get_path()
            let existing_scope = .cpp_import_cache.get(path)
            if existing_scope.has_value() {
                let import_scope_id = existing_scope!
                // Anonymous namespace to ensure imported symbols don't clash with prelude symbols.
                // (unless the imported namespace is actually named)
                mut scope = .get_scope(scope_id)
                scope.resolution_mixins.push(import_scope_id)
                if extern_import.assigned_namespace.name.has_value() {
                    .get_scope(import_scope_id).namespace_name = extern_import.assigned_namespace.name!
                    .get_scope(import_scope_id).external_name = ExternalName::Plain("") // global ns
                }
                continue
            }

            coalesced_imports.push(extern_import)
        }

        if not coalesced_imports.is_empty() {
            let child_scope_id = .create_scope(
                parent_scope_id: .root_scope_id() // See the NOTE in `typecheck_namespace_predecl' about extern imports
                can_throw: false
                debug_name: "coalesced-extern-imports"
                for_block: false
            )
            {
                // mut child_scope = .get_scope(child_scope_id)
                // child_scope.resolution_mixins.push(scope_id)
                // Anonymous namespace to ensure imported symbols don't clash with prelude symbols.
                // (unless the imported namespace is actually named)
                mut scope = .get_scope(scope_id)
                scope.resolution_mixins.push(child_scope_id)
            }
            .typecheck_auto_extern_imports(coalesced_imports, child_scope_id)
        }

        for extern_import in parsed_namespace.extern_imports {
            if not extern_import.should_auto_import {
                .typecheck_extern_import(extern_import, scope_id)
            }
        }
    }

    fn typecheck_auto_extern_imports(mut this, anon imports: [ParsedExternImport], anon child_scope_id) throws {
        if imports.is_empty() {
            return
        }

        mut builder = StringBuilder::create()
        mut path_name_builder = StringBuilder::create()
        builder.append("#pragma once\n")

        for import_ in imports {
            path_name_builder.append("_")
            path_name_builder.append(Path::from_string(import_.get_path()).basename(strip_extension: true))

            for action in import_.before_include {
                match action {
                    Define(name, value) => builder.append(format("#define {} {}\n", name, value))
                    Undefine(name) => builder.append(format("#undef {}\n", name))
                }
            }
            if import_.is_c {
                builder.append("extern \"C\" {\n")
            }
            builder.append(format("#include <{}>\n", import_.get_path()))
            if import_.is_c {
                builder.append("}\n")
            }
            for action in import_.after_include {
                match action {
                    Define(name, value) => builder.append(format("#define {} {}\n", name, value))
                    Undefine(name) => builder.append(format("#undef {}\n", name))
                }
            }
        }

        let contents = builder.to_string()
        let filename = format("jakt_autogen_{}.h", path_name_builder.to_string().hash())
        let output = .compiler.binary_dir.absolute().join(filename)

        write_to_file(data: contents, output_filename: output.to_string())

        let import_scope_id = try .cache_or_process_cpp_import(
            import_path: output
            scope_id: child_scope_id
            is_c: false
            defines: [:]
        ) catch e {
            // FIXME: StringView::equals()
            if String::from_string_literal(e.string()) == String::from_string_literal(CppImportErrors::path_not_found()) {
                // FIXME: Which one?
                for import_ in imports {
                    .error_with_hint(
                        format("Could not find imported extern file '{}'", import_.get_path())
                        import_.assigned_namespace.name_span!
                        "make sure the file exists and is in the include path"
                        import_.assigned_namespace.name_span!
                    )
                }
                return
            } else {
                throw e
            }
        }

        for import_ in imports {
            .cpp_import_cache.set(import_.get_path(), import_scope_id)
        }
    }

    fn typecheck_namespace_constructors(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_constructors(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id)
        }

        // Check the forall chunks
        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_constructors(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                    )
                }
            }
        }

        mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (record, scope_id) = records_to_process.dequeue()
            let id = match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        .compiler.panic("can't find previously added struct")
                    }
                    .typecheck_struct_constructor(parsed_record: record, struct_id: struct_id!, scope_id)
                    yield StructLikeId::Struct(struct_id!)
                }
                SumEnum | ValueEnum => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        .compiler.panic("can't find previously added enum")
                    }
                    .typecheck_enum_constructor(parsed_record: record, enum_id: enum_id!, parent_scope_id: scope_id)
                    yield StructLikeId::Enum(enum_id!)
                }
                else => {
                    continue
                }
            }
            for nested_record in record.nested_records {
                .warn_about_unimplemented_nested_record(nested_record)
                records_to_process.enqueue((nested_record, id.scope_id(&.program)))
            }
        }
    }

    fn typecheck_namespace_aliases(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId, allow: ImportRestrictions) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_aliases(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id, allow)
        }

        // Check the forall chunks
        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_aliases(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                        allow
                    )
                }
            }
        }

        for alias in parsed_namespace.aliases {
            .typecheck_alias(alias, scope_id, allow)
        }
    }

    fn typecheck_alias(mut this, alias: ParsedAlias, scope_id: ScopeId, allow: ImportRestrictions) throws {
        let aliased_name = match alias.alias_name.has_value() {
            true => alias.alias_name!
            else => {
                let name = alias.target.last()!
                if not name.generic_parameters.is_empty() {
                    .error_with_hint(
                        format("Cannot alias a generic instance of a type to the type itself")
                        name.name_span
                        format("Add an alias name here: 'as <name>'")
                        name.name_span // FIXME: Point to the end of the name
                    )
                }
                yield ParsedName(name: name.name, span: name.name_span)
            }
        }

        // Resolve the aliased type up to the last entry
        mut resolved_scope_id = scope_id
        mut alias_path: [ResolvedNamespace] = []
        for i in 0..(alias.target.size() - 1) {
            let namespace_ = .find_namespace_in_scope(scope_id: resolved_scope_id, name: alias.target[i].name)
            if not namespace_.has_value() {
                .error(
                    format("Unknown namespace '{}'", alias.target[i].name)
                    alias.target[i].name_span
                )
                return
            }
            resolved_scope_id = namespace_!.0
            alias_path.push(ResolvedNamespace(name: alias.target[i].name, generic_parameters: None))
        }

        mut scope = .get_scope(scope_id)
        let alias_scope_id = match scope.alias_scope.has_value() {
            true => scope.alias_scope!
            false => {
                let new_scope_id = .create_scope(
                    parent_scope_id: scope_id
                    can_throw: false
                    debug_name: format("alias-scope({})", scope.debug_name)
                    for_block: false
                )
                mut new_scope = .get_scope(new_scope_id)
                new_scope.alias_path = alias_path
                .get_scope(scope_id).children.push(new_scope_id)
                yield new_scope_id
            }
        }

        // FIXME: Error if one or both of the typecheck_alias() calls for a given alias fail
        .find_and_import_name_from_scope(
            from_name: alias.target.last()!.name
            from_span: alias.target.last()!.name_span
            to_name: aliased_name.name
            to_span: aliased_name.span
            from_scope_id: resolved_scope_id
            into_scope_id: alias_scope_id
            allow
        )
    }

    fn typecheck_namespace_function_predecl(
        mut this
        parsed_namespace: ParsedNamespace
        scope_id: ScopeId
        comptime_pass: bool
        generic_pass: bool
    ) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_function_predecl(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id, comptime_pass, generic_pass)
        }

        for fun in parsed_namespace.functions {
            if fun.is_comptime == comptime_pass and generic_pass == not fun.generic_parameters.is_empty() {
                .typecheck_function_predecl(parsed_function: fun, parent_scope_id: scope_id, this_arg_type_id: None)
            }
        }

        mut module = .current_module()

        mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (record, scope_id) = records_to_process.dequeue()
            let record_scope_id = match record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                    if not struct_id.has_value() {
                        continue
                    }
                    yield .get_struct(struct_id!).scope_id
                }
                else => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                    if not enum_id.has_value() {
                        continue
                    }
                    yield .get_enum(enum_id!).scope_id
                }
            }
            for nested_record in record.nested_records {
                .warn_about_unimplemented_nested_record(nested_record)
                records_to_process.enqueue((nested_record, record_scope_id))
            }

            for method in record.methods {
                if method.parsed_function.is_comptime != comptime_pass {
                    continue
                }

                if generic_pass == not method.parsed_function.generic_parameters.is_empty() {
                    continue
                }

                if not record.generic_parameters.is_empty() or not method.parsed_function.generic_parameters.is_empty() {
                    mut func = .get_function(
                        .find_function_matching_signature_in_scope(parent_scope_id: record_scope_id, prototype: method.parsed_function)!
                    )
                    let method_scope_id = func.function_scope_id

                    let check_scope = .create_scope(
                        parent_scope_id: method_scope_id
                        can_throw: func.can_throw
                        debug_name: format("method-checking({}::{})", record.name, func.name)
                    )

                    for param in func.params {
                        .add_var_to_scope(
                            scope_id: check_scope
                            name: param.variable.name
                            var_id: module.add_variable(param.variable)
                            span: param.variable.definition_span
                        )
                    }

                    let old_ignore_errors = .ignore_errors
                    .ignore_errors = true
                    let block = .typecheck_block(
                        parsed_block: method.parsed_function.block
                        parent_scope_id: check_scope
                        safety_mode: SafetyMode::Safe
                    )
                    .ignore_errors = old_ignore_errors
                    .had_an_error = false

                    let function_return_type_id = func.return_type_id

                    mut return_type_id: TypeId = builtin(BuiltinType::Void)
                    if function_return_type_id.equals(unknown_type_id()) {
                        if not block.statements.is_empty() {
                            if block.statements.last()! is Return(val) and val.has_value() {
                                return_type_id = .resolve_type_var(type_var_type_id: val!.type(), scope_id: method_scope_id)
                            }
                        }
                    } else {
                        return_type_id = .resolve_type_var(type_var_type_id: function_return_type_id, scope_id)
                    }

                    func.block = block
                    func.return_type_id = return_type_id
                }
            }
        }

        // Check the forall chunks
        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_function_predecl(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                        comptime_pass
                        generic_pass
                    )
                }
            }
        }
    }

    fn typecheck_namespace_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId) throws {
        let module_struct_len = .current_module().structures.size()
        let module_enum_len = .current_module().enums.size()

        // 1. Initialize structs
        mut struct_index: usize = 0
        mut enum_index: usize = 0
        mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (parsed_record, scope_id) = records_to_process.dequeue()
            let id = match parsed_record.record_type {
                Struct | Class => {
                    .typecheck_struct_predecl_initial(parsed_record, struct_index: struct_index++, module_struct_len, scope_id)
                    yield StructLikeId::Struct(StructId(module: scope_id.module_id, id: struct_index - 1))
                }
                SumEnum | ValueEnum => {
                    .typecheck_enum_predecl_initial(parsed_record, enum_index: enum_index++, module_enum_len, scope_id)
                    yield StructLikeId::Enum(EnumId(module: scope_id.module_id, id: enum_index - 1))
                }
                Garbage => {
                    // NOTE: We've already emitted a parse error about this, no need for a separate type error.
                    continue
                }
            }
            for record in parsed_record.nested_records {
                records_to_process.enqueue((record, id.scope_id(&.program)))
            }
        }

        // 2. Typecheck subnamespaces
        for namespace_ in parsed_namespace.namespaces {
            // Find all predeclarations in namespaces that are children of this namespace
            mut debug_name = "namespace("
            if namespace_.name.has_value() {
                debug_name += namespace_.name!
            } else {
                debug_name += "unnamed-namespace"
            }
            debug_name += ")"

            mut existing_scope_id = match namespace_.name.has_value() {
                true => .find_namespace_in_scope(scope_id: scope_id, name: namespace_.name!)?.0
                false => None
            }

            mut namespace_scope_id = existing_scope_id
            if not existing_scope_id.has_value() {
                if namespace_.import_path_if_extern.has_value() {
                    debug_name += " (extern "
                    debug_name += namespace_.import_path_if_extern!
                    debug_name += ")"
                }

                // Note: The back link formed by parent_scope_id and the forward link formed by scope.children
                //       do not necessarily link exactly two distinct scopes together, while that is the case for
                //       regular scope relationships, scopes created by extern imports all have the same global back link
                //       while they're children of their respective modules at the same time.
                let parent_scope_id = match namespace_.import_path_if_extern.has_value() {
                    true => ScopeId(module_id: ModuleId(id: 1), id: 0)
                    else => scope_id
                }

                let child_scope_id = .create_scope(
                    parent_scope_id
                    can_throw: false
                    debug_name
                    for_block: false
                )
                mut child_scope = .get_scope(child_scope_id)

                child_scope.namespace_name = namespace_.name
                child_scope.import_path_if_extern = namespace_.import_path_if_extern
                child_scope.before_extern_include = namespace_.generating_import_extern_before_include
                child_scope.after_extern_include = namespace_.generating_import_extern_after_include
                child_scope.is_from_generated_code = child_scope.is_from_generated_code or namespace_.is_generated_code

                // Make sure the imported ns can see the "logical" parent ns.
                if namespace_.import_path_if_extern.has_value() {
                    child_scope.resolution_mixins.push(scope_id)
                }

                namespace_scope_id = child_scope_id
            }

            mut parent_scope = .get_scope(scope_id)
            parent_scope.children.push(namespace_scope_id!)
            .typecheck_namespace_predecl(parsed_namespace: namespace_, scope_id: namespace_scope_id!)
        }

        // 3. Register traits
        for parsed_trait in parsed_namespace.traits {
            .typecheck_trait_predecl(parsed_trait, scope_id)
        }

        // 5. Typecheck struct predeclaration
        struct_index = 0
        enum_index = 0
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (parsed_record, scope_id) = records_to_process.dequeue()
            let id = match parsed_record.record_type {
                Struct | Class => {
                    let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
                    .typecheck_struct_predecl(parsed_record, struct_id, scope_id)
                    struct_index++
                    yield .get_struct(struct_id).scope_id
                }
                SumEnum | ValueEnum => {
                    let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
                    .typecheck_enum_predecl(parsed_record, enum_id, scope_id)
                    enum_index++
                    yield .get_enum(enum_id).scope_id
                }
                Garbage => {
                    // NOTE: The parser has already complained about this, so we can just ignore it.
                    continue
                }
            }
            for record in parsed_record.nested_records {
                records_to_process.enqueue((record, id))
            }
        }

        // 6. Resolve external trait implementations
        for default_pass in [false, true] {
            for implementation in parsed_namespace.external_trait_implementations {
                let for_type = .typecheck_typename(parsed_type: implementation.for_type, scope_id, name: None)

                let old_self_type_id = .self_type_id
                .set_self_type_id(for_type)
                defer .self_type_id = old_self_type_id

                mut type = .get_type(for_type)
                if type.is_builtin() {
                    type = .get_type(.get_struct(
                        .program.builtin_implementation_struct(builtin: type.as_builtin_type(), for_module: .program.prelude_module_id())
                    ).type_id)
                }
                match type {
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        mut struct_ = .get_struct(struct_id)
                        .resolve_external_trait_implementations(
                            implementation
                            entity_scope_id: struct_.scope_id
                            trait_implementations: &mut struct_.trait_implementations
                            for_type
                            scope_id
                            default_pass
                        )
                    }
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        mut enum_ = .get_enum(enum_id)
                        .resolve_external_trait_implementations(
                            implementation
                            entity_scope_id: enum_.scope_id
                            trait_implementations: &mut enum_.trait_implementations
                            for_type
                            scope_id
                            default_pass
                        )
                    }
                    else => {
                        if not default_pass {
                            .error(
                                format("Cannot implement traits for type '{}'", .type_name(for_type)),
                                implementation.for_type.span()
                            )
                        }
                    }
                }
            }
        }

        // 4. Resolve default trait implementations
        for parsed_trait in parsed_namespace.traits {
            let trait_id = .find_trait_in_scope(scope_id, name: parsed_trait.name)
            guard trait_id.has_value() else {
                .compiler.panic("can't find trait that has been previous added")
            }
            .typecheck_trait(parsed_trait, trait_id: trait_id!, scope_id, comptime_pass: true)
        }

        // 7. Resolve forall chunks
        for (chunk_parameters, chunk_namespace) in parsed_namespace.forall_chunks {
            let resolved_parameters = .typecheck_forall_chunk_parameters(chunk_parameters, scope_id)
            mut resolved_chunk = ResolvedForallChunk(
                parameters: resolved_parameters
                parsed_namespace: chunk_namespace
                generated_scopes: []
            )

            mut all_types = create_internal_dictionary_product(dict: resolved_parameters)
            for parameters in all_types {
                mut debug_name_builder = StringBuilder::create()
                debug_name_builder.append("forall<")
                mut first = true
                for (name, value) in parameters {
                    if first { first = false } else { debug_name_builder.append(", ") }
                    debug_name_builder.append(name)
                    debug_name_builder.append("=")
                    debug_name_builder.append(.type_name(value.1))
                }
                debug_name_builder.append("> namespace")

                let namespace_scope_id = .create_scope(
                    parent_scope_id: scope_id
                    can_throw: false
                    debug_name: debug_name_builder.to_string()
                    for_block: false
                )

                for (name, value) in parameters {
                    .add_type_to_scope(
                        scope_id: namespace_scope_id
                        type_name: name
                        type_id: value.1
                        span: value.0
                    )
                }

                mut parent_scope = .get_scope(scope_id)
                parent_scope.children.push(namespace_scope_id)
                parent_scope.resolution_mixins.push(namespace_scope_id)

                .typecheck_namespace_predecl(parsed_namespace: chunk_namespace, scope_id: namespace_scope_id)
                resolved_chunk.generated_scopes.push(namespace_scope_id)
            }

            mut scope = .get_scope(scope_id)
            if scope.resolved_forall_chunks is None {
                scope.resolved_forall_chunks = []
            }
            scope.resolved_forall_chunks!.push(resolved_chunk)
        }
    }

    fn typecheck_forall_chunk_parameters(mut this, chunk_parameters: [ParsedGenericParameter], scope_id: ScopeId) throws -> [String:[(Span, TypeId)]] {
        mut named_requirements: [(String, Span, [TraitId])] = []
        for parameter in chunk_parameters {
            guard parameter.requires_list is Some(requires_list) and not requires_list.is_empty() else {
                .error_with_hint(
                    format("forall type '{}' is not allowed to be unconditional", parameter.name),
                    parameter.span
                    "Try adding a 'requires' clause to the this type"
                    parameter.span
                )
                continue
            }

            mut trait_implementations: [TypeId] = []
            mut trait_requirements: [TraitId] = []

            .fill_trait_requirements(
                names: requires_list
                &mut trait_requirements
                &mut trait_implementations
                scope_id
            )

            if trait_requirements.is_empty() {
                // We've already reported an error for this
                continue
            }

            named_requirements.push((parameter.name, parameter.span, trait_requirements))
        }

        let old_ignore_errors = .ignore_errors
        defer .ignore_errors = old_ignore_errors

        mut results: [String:[(Span, TypeId)]] = [:]
        let module = .current_module()
        for (name, span, traits) in named_requirements {
            for type_index in 0..module.types.size() {
                mut type_id = TypeId(module: module.id, id: type_index)
                .ignore_errors = true
                .check_type_argument_requirements(
                    generic_argument: type_id
                    constraints: traits
                    arg_span: span
                )
                let matches = not .had_an_error
                .had_an_error = false
                .ignore_errors = false

                if not matches { continue }

                let type = .get_type(type_id)
                if type.is_builtin() { type_id = builtin(type.as_builtin_type()) }

                if results.contains(name) {
                    results[name].push((span, type_id))
                } else {
                    results[name] = [(span, type_id)]
                }
            }
        }

        return results
    }

    fn typecheck_namespace_methods_predecl(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId, comptime_pass: bool, generic_pass: bool) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_methods_predecl(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id, comptime_pass, generic_pass)
        }

        mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
        for parsed_record in parsed_namespace.records {
            records_to_process.enqueue((parsed_record, scope_id))
        }

        while not records_to_process.is_empty() {
            let (parsed_record, scope_id) = records_to_process.dequeue()

            let record_scope_id = match parsed_record.record_type {
                Struct | Class => {
                    let struct_id = .find_struct_in_scope(scope_id, name: parsed_record.name)
                    if not struct_id.has_value() {
                        continue
                    }
                    let struct_scope_id = .get_struct(struct_id!).scope_id
                    .typecheck_struct_methods_predecl(
                        parsed_record
                        struct_id: struct_id!
                        scope_id: struct_scope_id
                        comptime_pass
                        generic_pass
                    )
                    yield struct_scope_id
                }
                SumEnum | ValueEnum => {
                    let enum_id = .program.find_enum_in_scope(scope_id, name: parsed_record.name)
                    if not enum_id.has_value() {
                        continue
                    }
                    let enum_scope_id = .get_enum(enum_id!).scope_id
                    .typecheck_enum_methods_predecl(
                        parsed_record
                        enum_id: enum_id!
                        scope_id: enum_scope_id
                        comptime_pass
                        generic_pass
                    )
                    yield enum_scope_id
                }
                Garbage => {
                    continue
                }
            }

            for record in parsed_record.nested_records {
                records_to_process.enqueue((record, record_scope_id))
            }
        }

        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_methods_predecl(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                        comptime_pass
                        generic_pass
                    )
                }
            }
        }
    }

    fn resolve_external_trait_implementations(
        mut this
        implementation: ParsedExternalTraitImplementation
        entity_scope_id: ScopeId
        trait_implementations: &mut [String:[(TraitId, [TypeId])]]
        for_type: TypeId
        scope_id: ScopeId
        default_pass: bool
    ) throws {
        if default_pass {
            let impls = .fill_trait_implementation_list(
                implementation.traits
                &mut trait_implementations
                scope_id: entity_scope_id
                trait_name_scope_id_override: scope_id
            )

            mut index = 0uz
            for trait_name in implementation.traits {
                defer index += 1

                let trait_id = .find_trait_in_scope(scope_id, name: trait_name.name)
                guard trait_id.has_value() else { continue }

                let trait_ = .get_trait(trait_id!)
                guard trait_.requirements is Methods(methods) else {
                    continue
                }

                let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
                defer {
                    .generic_inferences.restore(old_generic_inferences)
                }

                .generic_inferences.set_all(keys: trait_.generic_parameters, values: impls[index].1)

                for (name, function_id) in methods {
                    let function = &mut .program.modules[function_id.module.id].functions[function_id.id]
                    if function.block.statements.is_empty() {
                        continue
                    }

                    let inferences = .generic_inferences
                    function.map_types(&fn[inferences](anon type_id: TypeId) throws -> TypeId {
                        return inferences.map(type_id)
                    })

                    mut ids = .find_functions_with_name_in_scope(
                        parent_scope_id: entity_scope_id
                        function_name: name
                    )

                    if not ids.has_value() {
                        .add_function_to_scope(
                            parent_scope_id: entity_scope_id
                            name: name
                            overload_set: [function_id]
                            span: trait_name.name_span
                        )
                    }
                }
            }
        } else {
            for method in implementation.methods {
                mut this_arg_type_id: TypeId? = None
                if (method.parsed_function.params.first()?.variable?.name ?? "") == "this" {
                    this_arg_type_id = match .get_type(for_type) {
                        Struct(id) => {
                            let struct_ = .get_struct(id)
                            mut type = for_type
                            if not struct_.generic_parameters.is_empty() {
                                mut type_arguments: [TypeId] = []
                                for param in struct_.generic_parameters {
                                    type_arguments.push(param.type_id)
                                }
                                type = .find_or_add_type_id(Type::GenericInstance(id, args: type_arguments))
                            }
                            yield type
                        }
                        Enum(id) => {
                            let enum_ = .get_enum(id)
                            mut type = for_type
                            if not enum_.generic_parameters.is_empty() {
                                mut type_arguments: [TypeId] = []
                                for param in enum_.generic_parameters {
                                    type_arguments.push(param.type_id)
                                }
                                type = .find_or_add_type_id(Type::GenericEnumInstance(id, args: type_arguments))
                            }
                            yield type
                        }
                        else => for_type
                    }
                }

                .typecheck_function_predecl(
                    parsed_function: method.parsed_function
                    parent_scope_id: entity_scope_id
                    this_arg_type_id
                    scope_mixin: scope_id
                )
            }
        }
    }

    fn typecheck_trait_predecl(mut this, parsed_trait: ParsedTrait, scope_id: ScopeId) throws {
        let trait_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("trait({})", parsed_trait.name), for_block: false)
        .add_type_to_scope(
            scope_id: trait_scope_id
            type_name: "Self"
            type_id: .find_or_add_type_id(Type::Self)
            span: parsed_trait.name_span
        )

        mut checked_trait = CheckedTrait(
            name: parsed_trait.name
            name_span: parsed_trait.name_span
            requirements: match parsed_trait.requirements {
                Methods => CheckedTraitRequirements::Methods([:])
                else => CheckedTraitRequirements::Nothing
            }
            generic_parameters: []
            scope_id: trait_scope_id
        )

        mut module = .current_module()

        // even though traits aren't types per-se, they represent the type that would implement the trait. So they have a type ID.
        let trait_id = TraitId(module: .current_module_id, id: .program.modules[.current_module_id.id].traits.size())
        let trait_type_id = .find_or_add_type_id(Type::Trait(trait_id))

        .program.modules[.current_module_id.id].traits.push(checked_trait)


        let old_self_type_id = .self_type_id
        .set_self_type_id(trait_type_id)
        defer .self_type_id = old_self_type_id

        // register the trait
        mut scope = .get_scope(scope_id)
        .add_type_to_scope(
            scope_id
            type_name: parsed_trait.name
            type_id: trait_type_id
            span: parsed_trait.name_span
        )
        .add_trait_to_scope(
            scope_id
            trait_name: parsed_trait.name
            trait_id
            span: parsed_trait.name_span
        )

        mut trait_scope = .get_scope(trait_scope_id)
        trait_scope.relevant_type_id = trait_type_id

        mut generic_parameters: [CheckedGenericParameter] = module.traits[trait_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_trait.generic_parameters.size())

        for gen_parameter in parsed_trait.generic_parameters {
            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size()
            )

            mut trait_implementations: [TypeId] = []
            mut parameter = CheckedGenericParameter::make(parameter_type_id, span: gen_parameter.span)
            module.types.push(Type::TypeVariable(name: gen_parameter.name, trait_implementations, gen_parameter.is_value))

            if gen_parameter.requires_list.has_value() {
                .fill_trait_requirements(
                    names: gen_parameter.requires_list!,
                    trait_requirements: &mut parameter.constraints,
                    &mut trait_implementations
                    scope_id
                )
            }

            generic_parameters.push(parameter)

            .add_type_to_scope(
                scope_id: trait_scope_id
                type_name: gen_parameter.name
                type_id: parameter_type_id
                span: gen_parameter.span
            )
        }

        let synthetic_struct_id = StructId(
            module: .current_module_id
            id: .program.modules[.current_module_id.id].structures.size()
        )
        module.structures.push(CheckedStruct(
            name: parsed_trait.name
            name_span: parsed_trait.name_span
            generic_parameters
            scope_id: trait_scope_id
            definition_linkage: DefinitionLinkage::External
            record_type: RecordType::Struct(fields: [], super_type: None)
            type_id: trait_type_id
            super_struct_id: None
        ))
        let struct_type_id = .find_or_add_type_id(Type::Struct(synthetic_struct_id))

        guard parsed_trait.requirements is Methods(methods) else {
            return
        }

        guard checked_trait.requirements is Methods(&mut checked_methods) else {
            // unreachable
            abort()
        }
        mut mutable_checked_methods = checked_methods

        for parsed_function in methods {
            let method_scope_id = .create_scope(
                parent_scope_id: trait_scope_id
                can_throw: parsed_function.can_throw
                debug_name: format("trait-method({}::{})", parsed_trait.name, parsed_function.name)
            )

            let function_id = .program.get_module(.current_module_id).next_function_id()

            // even though traits aren't types per-se, they act like a generic variable, since
            // they represent the type that implements said trait
            mut this_arg_type_id: TypeId? = None
            if not parsed_function.params.is_empty() and parsed_function.params.first()!.variable.name == "this" {
                this_arg_type_id = struct_type_id
            }

            .typecheck_function_predecl(
                parsed_function
                parent_scope_id: trait_scope_id
                this_arg_type_id
            )

            mutable_checked_methods.set(parsed_function.name, function_id)
        }
    }

    fn typecheck_trait(mut this, parsed_trait: ParsedTrait, trait_id: TraitId, scope_id: ScopeId, comptime_pass: bool = false) throws {
        mut checked_trait = .program.modules[trait_id.module.id].traits[trait_id.id]

        let old_self_type_id = .self_type_id
        .set_self_type_id(.find_or_add_type_id(Type::Trait(trait_id)))
        defer .self_type_id = old_self_type_id

        match parsed_trait.requirements {
            ComptimeExpression(expression) => {
                if comptime_pass {
                    let checked_expression = .typecheck_expression(
                        expr: expression
                        scope_id: checked_trait.scope_id
                        safety_mode: SafetyMode::Safe
                        type_hint: builtin(BuiltinType::Bool)
                    )

                    checked_trait.requirements = CheckedTraitRequirements::ComptimeExpression(checked_expression)
                }
            }
            else => {}
        }
    }

    fn typecheck_enum_predecl_initial(mut this, parsed_record: ParsedRecord, enum_index: usize, module_enum_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let enum_id = EnumId(module: .current_module_id, id: enum_index + module_enum_len)
        mut module = .current_module()
        module.types.push(Type::Enum(enum_id))

        let enum_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: enum_type_id, span: parsed_record.name_span)

        let old_self_type_id = .self_type_id
        .set_self_type_id(enum_type_id)
        defer .self_type_id = old_self_type_id

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }
        // Add a placeholder entry, this will be replaced later.
        module.enums.push(CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            scope_id: .prelude_scope_id()
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id: enum_type_id
            type_id: enum_type_id
            is_boxed
        ))
    }

    fn typecheck_enum_predecl(mut this, parsed_record: ParsedRecord, enum_id: EnumId, scope_id: ScopeId) throws {
        let enum_type_id = .find_or_add_type_id(type: Type::Enum(enum_id))

        let old_self_type_id = .self_type_id
        .set_self_type_id(enum_type_id)
        defer .self_type_id = old_self_type_id

        let enum_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("enum({})", parsed_record.name), for_block: false)
        mut scope = .get_scope(enum_scope_id)
        scope.namespace_name = parsed_record.name
        scope.relevant_type_id = enum_type_id

        .add_enum_to_scope(scope_id, name: parsed_record.name, enum_id, span: parsed_record.name_span)

        let underlying_type_id = match parsed_record.record_type {
            ValueEnum(underlying_type) => .typecheck_typename(parsed_type: underlying_type, scope_id, name: None)
            else => builtin(BuiltinType::Void)
        }

        let is_boxed = match parsed_record.record_type {
            SumEnum(is_boxed) => is_boxed
            else => false
        }

        mut checked_fields: [CheckedField] = []
        mut seen_fields: {String} = {}
        if parsed_record.record_type is SumEnum(fields) {
            for field in fields {
                let var_decl = field.var_decl
                if seen_fields.contains(var_decl.name) {
                    .error(format("Field '{}' is defined more than once", var_decl.name), var_decl.span)
                    continue
                }
                seen_fields.add(var_decl.name)
                let type_id = .typecheck_typename(parsed_type: var_decl.parsed_type, scope_id: enum_scope_id, name: var_decl.name)
                let checked_var = CheckedVariable(
                    name: var_decl.name
                    type_id
                    is_mutable: var_decl.is_mutable
                    definition_span: var_decl.span
                    type_span: var_decl.parsed_type.span()
                    visibility: .typecheck_visibility(visibility: field.visibility, scope_id: enum_scope_id)
                    external_name: var_decl.external_name
                )

                if .dump_type_hints and var_decl.parsed_type is Empty {
                    .dump_type_hint(type_id, span: var_decl.span)
                }

                mut module = .current_module()
                let variable_id = module.add_variable(checked_var)

                let default_value_expression = match field.default_value.has_value() {
                    true => Some(field.default_value!, enum_scope_id)
                    false => None
                }
                checked_fields.push(CheckedField(variable_id, default_value_expression))
            }
        }

        mut module = .current_module()
        module.enums[enum_id.id] = CheckedEnum(
            name: parsed_record.name
            name_span: parsed_record.name_span
            fields: checked_fields
            scope_id: enum_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            underlying_type_id
            type_id: enum_type_id
            is_boxed
        )

        mut generic_parameters: [CheckedGenericParameter] = module.enums[enum_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters {
            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size()
            )

            mut checked_param = CheckedGenericParameter::make(parameter_type_id, span: gen_parameter.span)

            mut trait_implementations: [TypeId] = []
            module.types.push(Type::TypeVariable(name: gen_parameter.name, trait_implementations, is_value: gen_parameter.is_value))

            if gen_parameter.requires_list.has_value() {
                .fill_trait_requirements(
                    names: gen_parameter.requires_list!,
                    trait_requirements: &mut checked_param.constraints,
                    &mut trait_implementations
                    scope_id
                )
            }

            generic_parameters.push(checked_param)

            .add_type_to_scope(scope_id: enum_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        if parsed_record.implements_list.has_value() {
            .fill_trait_implementation_list(
                parsed_record.implements_list!
                &mut module.enums[enum_id.id].trait_implementations
                scope_id: enum_scope_id
            )
        }
    }

    fn typecheck_enum_methods_predecl(
        mut this
        parsed_record: ParsedRecord
        enum_id: EnumId
        scope_id: ScopeId
        comptime_pass: bool
        generic_pass: bool
    ) throws {
        mut module = .current_module()
        let enum_type_id = .get_enum(enum_id).type_id
        let is_extern = parsed_record.definition_linkage is External
        for method in parsed_record.methods {
            let func = method.parsed_function
            if func.is_comptime != comptime_pass {
                continue
            }
            if generic_pass != not func.generic_parameters.is_empty() {
                continue
            }

            let method_scope_id = .create_scope(
                parent_scope_id: scope_id
                can_throw: func.can_throw
                debug_name: format("method({}::{})", parsed_record.name, func.name)
            )
            let block_scope_id = .create_scope(
                parent_scope_id: method_scope_id
                can_throw: func.can_throw
                debug_name: format("method-block({}::{})", parsed_record.name, func.name)
            )

            let is_generic = not parsed_record.generic_parameters.is_empty() or not func.generic_parameters.is_empty()
            mut has_varargs = method.parsed_function.has_varargs
            if has_varargs and method.parsed_function.linkage is Internal {
                .error(
                    "Only external functions are allowed to be declared using varargs"
                    method.parsed_function.name_span
                )
                has_varargs = false
            }

            mut checked_function = CheckedFunction(
                name: func.name
                name_span: func.name_span
                visibility: .typecheck_visibility(visibility: method.visibility, scope_id: scope_id)
                return_type_id: unknown_type_id()
                return_type_span: None
                params: []
                generics: FunctionGenerics(
                    base_scope_id: method_scope_id
                )
                block: CheckedBlock(
                    scope_id: block_scope_id
                    control_flow: BlockControlFlow::MayReturn
                )
                can_throw: func.can_throw
                type: func.type
                linkage: func.linkage
                function_scope_id: method_scope_id
                struct_id: None
                is_instantiated: not is_generic or is_extern
                parsed_function: func
                is_comptime: func.is_comptime
                is_virtual: false
                is_override: false
                is_unsafe: func.is_unsafe
                has_varargs
            )

            let function_id = module.add_function(checked_function)
            mut generic_parameters: [FunctionGenericParameter] = []

            for generic_parameter in func.generic_parameters {
                let type_var_type_id = TypeId(
                    module: .current_module_id
                    id: .current_module().types.size()
                )

                mut parameter = FunctionGenericParameter::parameter(type_var_type_id, span: generic_parameter.span)

                mut trait_implementations: [TypeId] = []
                module.types.push(
                    Type::TypeVariable(name: generic_parameter.name, trait_implementations, is_value: generic_parameter.is_value)
                )

                if generic_parameter.requires_list.has_value() {
                    .fill_trait_requirements(
                        names: generic_parameter.requires_list!,
                        trait_requirements: &mut parameter.checked_parameter.constraints,
                        &mut trait_implementations,
                        scope_id
                    )
                }

                generic_parameters.push(parameter)

                if not func.must_instantiate {
                    .add_type_to_scope(
                        scope_id: method_scope_id,
                        type_name: generic_parameter.name,
                        type_id: type_var_type_id,
                        span: generic_parameter.span,
                    )
                }
            }

            checked_function.generics.params = generic_parameters

            for param in func.params {
                if param.variable.name == "this" {
                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: enum_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: None
                        visibility: CheckedVisibility::Public
                    )

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value_expression: None
                    ))
                } else {
                    let param_type = .typecheck_typename(parsed_type: param.variable.parsed_type, scope_id: method_scope_id, name: param.variable.name)

                    let checked_variable = CheckedVariable(
                        name: param.variable.name
                        type_id: param_type
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.span
                        type_span: param.variable.parsed_type.span()
                        visibility: CheckedVisibility::Public
                    )

                    checked_function.add_param(CheckedParameter(
                        requires_label: param.requires_label
                        variable: checked_variable
                        default_value_expression: match param.default_argument.has_value() {
                            true => (param.default_argument!, method_scope_id)
                            false => None
                        }
                    ))
                }
            }

            .add_function_to_scope(
                parent_scope_id: scope_id
                name: func.name
                overload_set: [function_id]
                span: parsed_record.name_span
            )

            let function_return_type_id = .typecheck_typename(parsed_type: func.return_type, scope_id: method_scope_id, name: None)
            checked_function.return_type_id = function_return_type_id
        }
    }

    fn struct_inheritance_chain(this, struct_id: StructId) -> [StructId] {
        mut chain: [StructId] = []
        mut current = Some(struct_id)

        chain.push(current!)

        while current.has_value() {
            let parent = .get_struct(current!).super_struct_id
            if parent.has_value() {
                chain.push(parent!)
            }
            current = parent
        }

        mut reverse_chain: [StructId] = []
        for i in 0..chain.size() {
            reverse_chain.push(chain[chain.size() - 1 - i])
        }
        return reverse_chain
    }

    fn struct_inherits_from(
        this
        struct_id: StructId
        super_struct_id: StructId
        struct_inheritance_chain: [StructId]? = None
    ) -> bool {
        let chain = struct_inheritance_chain ?? .struct_inheritance_chain(struct_id)
        for id in chain {
            if id == super_struct_id {
                return true
            }
        }
        return false
    }

    fn typecheck_struct_constructor(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {
        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let old_self_type_id = .self_type_id
        .set_self_type_id(struct_type_id)
        defer .self_type_id = old_self_type_id

        let struct_ = .get_struct(struct_id)

        let constructor_ids = .find_functions_with_name_in_scope(parent_scope_id: struct_.scope_id, function_name: parsed_record.name)
        if constructor_ids.has_value() {
            if parsed_record.record_type is Class and parsed_record.definition_linkage is External {
                // XXX: The parser always sets the linkage type of an extern class'
                //      constructor to External, but we actually want to call the
                //      class' ::create function, just like we do with a
                //      ImplicitConstructor class.
                for constructor_id in constructor_ids!.iterator() {
                    mut func = .get_function(constructor_id)
                    func.linkage = FunctionLinkage::External
                }
            }
        } else if not parsed_record.definition_linkage is External {
            // No constructor found, so let's make one

            let function_scope_id = .create_scope(parent_scope_id: struct_.scope_id, can_throw: false, debug_name: format("generated-constructor({})", parsed_record.name))
            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: false, debug_name: format("generated-constructor-block({})", parsed_record.name))

            let inheritance_chain = .struct_inheritance_chain(struct_id)
            mut constructor_parameters: [CheckedParameter] = []

            let parent_index_in_chain = match inheritance_chain.size() >= 2 {
                true => inheritance_chain.size() - 2
                false => 0
            }
            for parent_struct_id in inheritance_chain[parent_index_in_chain..] {
                let parent_struct = .get_struct(parent_struct_id)
                let scope = .get_scope(parent_struct.scope_id)
                let parent_constructors = scope.functions.get(parent_struct.name)
                if parent_constructors.has_value() {
                    let id = parent_constructors![0]
                    let ctor = .get_function(id)
                    constructor_parameters.push_values(&ctor.params)
                } else {
                    for field in .get_struct(parent_struct_id).fields {
                        let variable = .get_variable(field.variable_id)
                        constructor_parameters.push(CheckedParameter(
                            requires_label: true
                            variable: variable
                            default_value_expression: field.default_value_expression
                        ))
                    }
                }
            }

            mut checked_constructor = CheckedFunction(
                name: parsed_record.name
                name_span: parsed_record.name_span
                visibility: CheckedVisibility::Public
                return_type_id: struct_type_id
                return_type_span: None
                params: constructor_parameters
                generics: FunctionGenerics(
                    base_scope_id: function_scope_id
                    base_params: constructor_parameters
                )
                block: CheckedBlock(
                    scope_id: block_scope_id
                    control_flow: BlockControlFlow::MayReturn
                )
                can_throw: false
                type: FunctionType::ImplicitConstructor
                linkage: FunctionLinkage::Internal
                function_scope_id
                struct_id
                is_instantiated: true
                parsed_function: None
                is_comptime: false
                is_virtual: false
                is_override: false
                is_unsafe: false
                external_name: parsed_record.external_name
            )

            // Internal constructor
            mut module = .current_module()
            let function_id = module.add_function(checked_function: checked_constructor)

            // Add constructor to the struct's scope
            .add_function_to_scope(
                parent_scope_id: struct_.scope_id
                name: parsed_record.name
                overload_set: [function_id]
                span: parsed_record.name_span
            )
        }

        .current_struct_type_id = None
    }

    fn is_class(this, anon type_id: TypeId) -> bool {
        guard .get_type(type_id) is Struct(struct_id) else {
            return false
        }
        return .get_struct(struct_id).record_type is Class
    }

    fn is_struct(this, anon type_id: TypeId) -> bool {
        guard .get_type(type_id) is Struct(struct_id) else {
            return false
        }
        return .get_struct(struct_id).record_type is Struct
    }

    fn fill_trait_implementation_list(
        mut this
        anon parsed_impl_list: [ParsedNameWithGenericParameters]
        anon trait_implementations: &mut [String:[(TraitId, [TypeId])]]
        scope_id: ScopeId
        trait_name_scope_id_override: ScopeId? = None
    ) throws -> [(TraitId, [TypeId])] {
        mut result: [(TraitId, [TypeId])] = []
        mut type_scope = scope_id

        if trait_name_scope_id_override is Some(id) {
            let aliased_scope_id = .create_scope(
                parent_scope_id: id
                can_throw: false
                debug_name: format(
                    "trait-alias-mixin({})"
                    .get_scope(id).debug_name
                )
                for_block: false
            )
            mut scope = .get_scope(scope_id)
            scope.resolution_mixins.push(aliased_scope_id)
        }

        let trait_name_scope_id = trait_name_scope_id_override ?? scope_id
        // register the traits that this record is supposed to implement.
        for trait_name in parsed_impl_list {
            // look for the trait.
            let maybe_type_id = .find_type_in_scope(scope_id: trait_name_scope_id, name: trait_name.name)
            guard maybe_type_id.has_value() else {
                .error(format("Cannot find trait ‘{}’", trait_name.name), trait_name.name_span)
                continue
            }

            guard .get_type(maybe_type_id!) is Trait(trait_id) else {
                .error(format("Expected ‘{}’ to be a trait", trait_name.name), trait_name.name_span)
                continue
            }

            mut generic_arguments: [TypeId] = []
            for argument in trait_name.generic_parameters {
                let argument_type_id = .typecheck_typename(parsed_type: argument, scope_id: type_scope, name: None)
                generic_arguments.push(argument_type_id)
            }

            mut existing_list = trait_implementations.get(trait_name.name)
            if existing_list.has_value() {
                mut found = false
                for (id, args) in existing_list! {
                    guard id.equals(trait_id) else {
                        continue
                    }
                    if args.size() != generic_arguments.size() {
                        continue
                    }
                    for i in 0..args.size() {
                        guard args[i].equals(generic_arguments[i]) else {
                            continue
                        }
                    }

                    found = true
                    break
                }
                if not found {
                    existing_list!.push((trait_id, generic_arguments))
                }
            } else {
                trait_implementations.set(trait_name.name, [(trait_id, generic_arguments)])
            }

            result.push((trait_id, generic_arguments))
        }

        return result
    }

    fn specialize_trait(mut this, trait_id: TraitId, generic_parameters: [TypeId]) throws {
        let trait_ = .get_trait(trait_id)
        if trait_.generic_parameters.is_empty() {
            return
        }

        let old_self_type_id = .self_type_id
        .set_self_type_id(.find_or_add_type_id(Type::GenericTraitInstance(id: trait_id, args: generic_parameters)))
        defer .self_type_id = old_self_type_id


        for i in 0..trait_.generic_parameters.size() {
            let parameter = trait_.generic_parameters[i]
            let type = generic_parameters[i]
            .check_types_for_compat(
                lhs_type_id: parameter.type_id
                rhs_type_id: type
                generic_inferences: &mut .generic_inferences
                span: parameter.span
            )
        }
    }

    fn typecheck_struct_predecl(mut this, parsed_record: ParsedRecord, struct_id: StructId, scope_id: ScopeId) throws {
        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: true)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let old_self_type_id = .self_type_id
        .set_self_type_id(struct_type_id)
        defer .self_type_id = old_self_type_id

        let struct_scope_id = .current_module().structures[struct_id.id].scope_id

        .add_struct_to_scope(scope_id, name: parsed_record.name, struct_id, span: parsed_record.name_span)

        mut super_struct_id: StructId? = None

        match parsed_record.record_type {
            Class(super_type: super_parsed_type) => match super_parsed_type.has_value() {
                true => {
                    let super_type_id = .typecheck_typename(parsed_type: super_parsed_type!, scope_id, name: None)
                    let super_type = .get_type(super_type_id)

                    if super_type is Struct(struct_id) {
                        super_struct_id = struct_id
                    } else {
                        .error("Class can only inherit from another class", super_parsed_type!.span())
                    }
                }
                false => {}
            }
            Struct(super_type: super_parsed_type) => match super_parsed_type.has_value() {
                true => {
                    let super_type_id = .typecheck_typename(parsed_type: super_parsed_type!, scope_id, name: None)
                    let super_type = .get_type(super_type_id)

                    if super_type is Struct(struct_id) {
                        super_struct_id = struct_id
                    } else {
                        .error("Struct can only inherit from another struct", super_parsed_type!.span())
                    }
                }
                false => {}
            }
            else => {
                panic("Expected Struct or Class in typecheck_struct_predecl")
            }
        }

        mut module = .current_module()
        module.structures[struct_id.id] = CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            scope_id: struct_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
            super_struct_id
            external_name: parsed_record.external_name
        )

        mut generic_parameters: [CheckedGenericParameter] = module.structures[struct_id.id].generic_parameters
        generic_parameters.ensure_capacity(parsed_record.generic_parameters.size())

        for gen_parameter in parsed_record.generic_parameters {
            let parameter_type_id = TypeId(
                module: .current_module_id
                id: .current_module().types.size()
            )

            mut parameter = CheckedGenericParameter::make(parameter_type_id, span: gen_parameter.span)
            mut trait_implementations: [TypeId] = []
            module.types.push(Type::TypeVariable(name: gen_parameter.name, trait_implementations, is_value: gen_parameter.is_value))

            if gen_parameter.requires_list.has_value() {
                .fill_trait_requirements(
                    names: gen_parameter.requires_list!,
                    trait_requirements: &mut parameter.constraints,
                    &mut trait_implementations,
                    scope_id
                )
            }


            generic_parameters.push(parameter)

            .add_type_to_scope(scope_id: struct_scope_id, type_name: gen_parameter.name, type_id: parameter_type_id, span: gen_parameter.span)
        }

        let is_extern = parsed_record.definition_linkage is External

        module.structures[struct_id.id].generic_parameters = generic_parameters

        .current_struct_type_id = None
    }

    fn typecheck_struct_methods_predecl(
        mut this
        parsed_record: ParsedRecord
        struct_id: StructId
        scope_id: ScopeId
        comptime_pass: bool
        generic_pass: bool
    ) throws {
        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: true)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        let struct_type_id = .find_or_add_type_id(type: Type::Struct(struct_id))
        .current_struct_type_id = struct_type_id

        let old_self_type_id = .self_type_id
        .set_self_type_id(struct_type_id)
        defer .self_type_id = old_self_type_id

        let struct_scope_id = .current_module().structures[struct_id.id].scope_id

        mut module = .current_module()

        for method in parsed_record.methods {
            if method.parsed_function.is_comptime != comptime_pass {
                continue
            }

            if generic_pass != not method.parsed_function.generic_parameters.is_empty() {
                continue
            }

            let function_id = .typecheck_function_predecl(parsed_function: method.parsed_function, parent_scope_id: struct_scope_id, this_arg_type_id: struct_type_id)
            mut checked_function = .get_function(function_id)

            checked_function.is_override = method.is_override
            checked_function.is_virtual = method.is_virtual
            checked_function.visibility = .typecheck_visibility(visibility: method.visibility, scope_id: struct_scope_id)

            if checked_function.is_virtual and checked_function.is_static() {
                .error("Functions cannot be both virtual and static", checked_function.name_span)
            }

            if checked_function.is_override and checked_function.is_static() {
                .error("Functions cannot be both override and static", checked_function.name_span)
            }
        }

        if not comptime_pass and parsed_record.implements_list.has_value() {
            .fill_trait_implementation_list(
                parsed_record.implements_list!
                &mut module.structures[struct_id.id].trait_implementations
                scope_id: struct_scope_id
            )

            for implements_entry in parsed_record.implements_list! {
                let trait_id = .find_trait_in_scope(scope_id, name: implements_entry.name)
                guard trait_id.has_value() else { continue }
                let trait_ = .program.modules[trait_id!.module.id].traits[trait_id!.id]
                guard trait_.requirements is Methods(methods) else {
                    continue
                }

                for (name, function_id) in methods {
                    if .find_functions_with_name_in_scope(parent_scope_id: struct_scope_id, function_name: name).has_value() {
                        continue
                    }

                    let function = .program.modules[function_id.module.id].functions[function_id.id]

                    if function.block.statements.is_empty() {
                        continue
                    }

                    .add_function_to_scope(
                        parent_scope_id: struct_scope_id
                        name: name
                        overload_set: [function_id]
                        span: implements_entry.name_span
                    )
                }
            }
        }
    }

    fn typecheck_struct_predecl_initial(mut this, parsed_record: ParsedRecord, struct_index: usize, module_struct_len: usize, scope_id: ScopeId) throws {
        let module_id = .current_module_id
        let struct_id = StructId(module: .current_module_id, id: struct_index + module_struct_len)
        mut module = .current_module()
        module.types.push(Type::Struct(struct_id))

        let struct_type_id = TypeId(module: module_id, id: .current_module().types.size() - 1)
        .add_type_to_scope(scope_id, type_name: parsed_record.name, type_id: struct_type_id, span: parsed_record.name_span)

        let struct_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: false, debug_name: format("struct({})", parsed_record.name), for_block: false)
        mut scope = .get_scope(struct_scope_id)

        scope.namespace_name = parsed_record.name
        scope.external_name = parsed_record.external_name
        scope.relevant_type_id = struct_type_id

        // Add a placeholder entry, this will be replaced later.
        module.structures.push(CheckedStruct(
            name: parsed_record.name
            name_span: parsed_record.name_span
            scope_id: struct_scope_id
            definition_linkage: parsed_record.definition_linkage
            record_type: parsed_record.record_type
            type_id: struct_type_id
            external_name: parsed_record.external_name
        ))

        match parsed_record.record_type {
            Struct(fields) | Class(fields) => {
                let field_names_and_spans = map(
                    input: fields
                    mapper: &fn(item: ParsedField) -> (String, Span) =>
                        (item.var_decl.name, item.var_decl.span)
                )
                let method_names_and_spans = map(
                    input: parsed_record.methods
                    mapper: &fn(item: ParsedMethod) -> (String, Span) =>
                        (item.parsed_function.name,item.parsed_function.name_span)
                )
                for x in field_names_and_spans {
                    for y in method_names_and_spans {
                        if x.0 == y.0 {
                            .error_with_hint(
                                format(
                                    "Can't have a member variable and member function both named `{}`"
                                    x.0
                                )
                                Span::last(x.1, y.1)
                                format(
                                    "`{}` is first defined here"
                                    x.0
                                )
                                Span::first(x.1, y.1)
                            )
                        }
                    }
                }
            }
            else => {}
        }
    }

    fn typecheck_entity_trait_implementations_predecl(
        mut this
        scope_id: ScopeId
        type_id: TypeId
        trait_implementations: [String:[(TraitId, [TypeId])]]
        name: String
        name_span: Span
    ) throws {
        for (trait_name, trait_ids_and_generic_params) in trait_implementations {
            for trait_id_and_generic_params in trait_ids_and_generic_params {
                let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
                defer .generic_inferences.restore(old_generic_inferences)

                let (trait_id, generic_params) = trait_id_and_generic_params
                let trait_ = .get_trait(trait_id)
                if trait_.generic_parameters.size() != generic_params.size() {
                    .error(
                        format(
                            "Trait ‘{}’ expects {} generic parameters, but {} were given"
                            trait_name
                            trait_.generic_parameters.size()
                            generic_params.size()
                        )
                        trait_.name_span
                    )
                    continue
                }

                .specialize_trait(trait_id, generic_parameters: generic_params)

                guard trait_.requirements is Methods(methods) else {
                    continue
                }

                .generic_inferences.set_all(keys: trait_.generic_parameters, values: generic_params)

                for (method_name, method_function_id) in methods {
                    let method = .get_function(method_function_id)
                    if not method.parsed_function.has_value() or method.parsed_function!.block.stmts.is_empty() {
                        continue
                    }

                    let f = .find_functions_with_name_in_scope(
                        parent_scope_id: scope_id
                        function_name: method_name
                    )
                    if f.has_value() {
                        continue
                    }

                    mut mixin_scope_id: ScopeId? = None
                    if not trait_.generic_parameters.is_empty() {
                        let id = .program.create_scope(
                            parent_scope_id: None
                            can_throw: false
                            debug_name: format("trait({}).generic-mixin", trait_.name)
                            module_id: scope_id.module_id
                            for_block: false
                        )

                        for i in 0..trait_.generic_parameters.size() {
                            let generic_param = trait_.generic_parameters[i]
                            let generic_param_type = generic_params[i]

                            guard .get_type(generic_param.type_id) is TypeVariable(name, is_value) else {
                                continue
                            }

                            .add_type_to_scope(
                                scope_id: id
                                type_name: name
                                type_id: generic_param_type
                                span: generic_param.span
                            )

                            if is_value and .get_type(generic_param_type) is Const(value) {
                                .add_comptime_binding_to_scope(
                                    scope_id: id
                                    name
                                    value
                                    span: generic_param.span
                                )
                            }

                            mixin_scope_id = id
                        }
                    }

                    .typecheck_function_predecl(
                        parsed_function: method.parsed_function!
                        parent_scope_id: scope_id
                        this_arg_type_id: type_id
                        scope_mixin: mixin_scope_id
                    )
                }
            }
        }
    }

    fn typecheck_entity_trait_implementations(
        mut this
        scope_id: ScopeId
        type_id: TypeId
        trait_implementations: [String:[(TraitId, [TypeId])]]
        name: String
        name_span: Span
    ) throws {
        mut checks = TraitImplCheck::make()

        checks.ensure_capacity(trait_implementations.size())

        for (trait_name, trait_ids_and_generic_params) in trait_implementations {
            for trait_id_and_generic_params in trait_ids_and_generic_params {
                checks.register_trait(
                    trait_type_id: .find_or_add_type_id(
                        Type::GenericTraitInstance(id: trait_id_and_generic_params.0, args: trait_id_and_generic_params.1)
                    )
                    trait_name
                    requirements: .program.get_trait(trait_id_and_generic_params.0).requirements
                )
            }
        }

        for (trait_name, trait_ids_and_generic_params) in trait_implementations {
            for trait_id_and_generic_params in trait_ids_and_generic_params {
                let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
                defer .generic_inferences.restore(old_generic_inferences)

                let (trait_id, generic_params) = trait_id_and_generic_params
                let trait_ = .get_trait(trait_id)
                if trait_.generic_parameters.size() != generic_params.size() {
                    .error(
                        format(
                            "Trait ‘{}’ expects {} generic parameters, but {} were given"
                            trait_name
                            trait_.generic_parameters.size()
                            generic_params.size()
                        )
                        trait_.name_span
                    )
                    continue
                }

                .specialize_trait(trait_id, generic_parameters: generic_params)

                guard trait_.requirements is Methods(methods) else {
                    continue
                }

                .generic_inferences.set_all(keys: trait_.generic_parameters, values: generic_params)

                for (method_name, method_function_id) in methods {
                    let method = .get_function(method_function_id)
                    if not method.parsed_function.has_value() or method.parsed_function!.block.stmts.is_empty() {
                        continue
                    }

                    let ids = .find_functions_with_name_in_scope(
                        parent_scope_id: scope_id
                        function_name: method_name
                    )

                    mut this_function: FunctionId? = None
                    if ids.has_value() {
                        for id in ids! {
                            if .get_function(id).parsed_function?.id == method.parsed_function?.id {
                                this_function = id
                                break
                            }
                        }
                        if not this_function.has_value() {
                            continue
                        }
                    }

                    if this_function.has_value() and .get_function(this_function!).is_fully_checked {
                        continue
                    }

                    .typecheck_function(
                        parsed_function: method.parsed_function!
                        parent_scope_id: scope_id
                    )
                }
            }
        }

        let scope = .get_scope(scope_id)
        for (name, overload_set) in scope.functions {
            for function_id in overload_set {
                checks.register_method(
                    self_type_id: type_id,
                    method_name: name,
                    method_id: function_id,
                    typechecker: &mut this
                )
            }
        }

        checks.throw_errors(record_decl_span: name_span, typechecker: &mut this)
    }

    fn typecheck_namespace_trait_implementations_predecl(mut this, scope_id: ScopeId) throws {
        let scope = .get_scope(scope_id)

        for child in scope.children {
            .typecheck_namespace_trait_implementations_predecl(scope_id: child)
        }

        for (_, struct_id) in scope.structs {
            let struct_ = .get_struct(struct_id)
            .typecheck_entity_trait_implementations_predecl(
                scope_id: struct_.scope_id
                type_id: struct_.type_id
                trait_implementations: struct_.trait_implementations
                name: struct_.name
                name_span: struct_.name_span
            )
        }
    }

    fn typecheck_namespace_trait_implementations(mut this, scope_id: ScopeId) throws {
        let scope = .get_scope(scope_id)

        for child in scope.children {
            .typecheck_namespace_trait_implementations(scope_id: child)
        }

        for (_, struct_id) in scope.structs {
            let struct_ = .get_struct(struct_id)
            if struct_.trait_implementations.is_empty() { continue }

            .typecheck_entity_trait_implementations(
                scope_id: struct_.scope_id
                type_id: struct_.type_id
                trait_implementations: struct_.trait_implementations
                name: struct_.name
                name_span: struct_.name_span
            )
        }
    }

    fn typecheck_namespace_declarations(mut this, parsed_namespace: ParsedNamespace, scope_id: ScopeId, comptime_pass: bool, generic_pass: bool) throws {
        let children = .get_scope(id: scope_id).children
        for i in 0..parsed_namespace.namespaces.size() {
            let child_namespace = parsed_namespace.namespaces[i]
            let child_namespace_scope_id = children[i]
            .typecheck_namespace_declarations(parsed_namespace: child_namespace, scope_id: child_namespace_scope_id, comptime_pass, generic_pass)
        }

        // Check the forall chunks
        if .get_scope(scope_id).resolved_forall_chunks is Some(chunks) {
            for chunk in chunks {
                mut all_types = create_internal_dictionary_product(dict: chunk.parameters)
                mut i = 0uz
                for stuff in all_types {
                    defer i += 1

                    .typecheck_namespace_declarations(
                        parsed_namespace: chunk.parsed_namespace
                        scope_id: chunk.generated_scopes[i]
                        comptime_pass
                        generic_pass
                    )
                }
            }
        }

        if not comptime_pass and not generic_pass {
            mut records_to_process: Queue<(ParsedRecord, ScopeId)> = Queue()
            for parsed_record in parsed_namespace.records {
                records_to_process.enqueue((parsed_record, scope_id))
            }

            while not records_to_process.is_empty() {
                let (record, scope_id) = records_to_process.dequeue()
                let id = match record.record_type {
                    Struct | Class => {
                        let struct_id = .find_struct_in_scope(scope_id, name: record.name)
                        if not struct_id.has_value() {
                            .compiler.panic("can't find struct that has been previous added")
                        }
                        .typecheck_struct(record, struct_id: struct_id!, parent_scope_id: scope_id)
                        yield StructLikeId::Struct(struct_id!)
                    }
                    SumEnum | ValueEnum => {
                        let enum_id = .program.find_enum_in_scope(scope_id, name: record.name)
                        if not enum_id.has_value() {
                            .compiler.panic("can't find enum that has been previous added")
                        }
                        .typecheck_enum(record, enum_id: enum_id!, parent_scope_id: scope_id)
                        yield StructLikeId::Enum(enum_id!)
                    }
                    else => {
                        continue
                    }
                }

                for nested_record in record.nested_records {
                    .warn_about_unimplemented_nested_record(nested_record)
                    records_to_process.enqueue((nested_record, id.scope_id(&.program)))
                }
            }

            for parsed_trait in parsed_namespace.traits {
                let trait_id = .find_trait_in_scope(scope_id, name: parsed_trait.name)
                guard trait_id.has_value() else {
                    .compiler.panic("can't find trait that has been previous added")
                }
                .typecheck_trait(parsed_trait, trait_id: trait_id!, scope_id)
            }

            .typecheck_namespace_trait_implementations_predecl(scope_id)
        }

        for fun in parsed_namespace.functions.iterator() {
            if fun.is_comptime == comptime_pass and generic_pass == not fun.generic_parameters.is_empty() {
                .typecheck_function(parsed_function: fun, parent_scope_id: scope_id)
            }
        }

        if not comptime_pass and not generic_pass {
            for implementation in parsed_namespace.external_trait_implementations {
                mut for_type = .typecheck_typename(parsed_type: implementation.for_type, scope_id, name: None)
                let type = .get_type(for_type)
                if type.is_builtin() {
                    let struct_id = .program.builtin_implementation_struct(
                        builtin: type.as_builtin_type()
                        for_module: .program.prelude_module_id()
                    )
                    for_type = .find_or_add_type_id(Type::Struct(struct_id))
                }
                match .get_type(for_type) {
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        mut struct_ = .get_struct(struct_id)
                        for method in implementation.methods {
                            if (method.parsed_function.params.first()?.variable?.name ?? "") == "this" {
                                .typecheck_method(
                                    func: method.parsed_function
                                    parent_id: StructLikeId::Struct(struct_id)
                                )
                            } else {
                                .typecheck_function(
                                    parsed_function: method.parsed_function
                                    parent_scope_id: struct_.scope_id
                                )
                            }
                        }
                    }
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        mut enum_ = .get_enum(enum_id)
                        for method in implementation.methods {
                            if (method.parsed_function.params.first()?.variable?.name ?? "") == "this" {
                                .typecheck_method(
                                    func: method.parsed_function
                                    parent_id: StructLikeId::Enum(enum_id)
                                )
                            } else {
                                .typecheck_function(
                                    parsed_function: method.parsed_function
                                    parent_scope_id: enum_.scope_id
                                )
                            }
                        }
                    }
                    else => { }
                }
            }
        }

        if not comptime_pass and not generic_pass {
            .typecheck_namespace_trait_implementations(scope_id)
        }
    }

    fn typecheck_enum_constructor(mut this, parsed_record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        mut next_constant_value = 0u64
        mut seen_names: {String} = {}

        mut enum_ = .get_enum(enum_id)

        let old_self_type_id = .self_type_id
        .set_self_type_id(enum_.type_id)
        defer .self_type_id = old_self_type_id

        mut common_seen_fields: {String} = {}
        mut common_fields: [VarId] = []
        mut common_params: [CheckedParameter] = []
        for field in enum_.fields {
            let variable = .get_variable(field.variable_id)
            common_params.push(CheckedParameter(
                requires_label: true,
                variable,
                default_value_expression: field.default_value_expression
            ))

            common_seen_fields.add(variable.name)
            common_fields.push(field.variable_id)
        }

        match parsed_record.record_type {
            ValueEnum(underlying_type, variants) => {
                let underlying_type_id = .typecheck_typename(parsed_type: underlying_type, scope_id: parent_scope_id, name: None)
                mut module = .current_module()
                for variant in variants {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                    } else {
                        seen_names.add(variant.name)

                        let expr = match variant.value.has_value() {
                            true => {
                                let value_expression = .cast_to_underlying(variant.value!, scope_id: parent_scope_id, parsed_type: underlying_type)
                                let number_constant = value_expression.to_number_constant(program: .program)
                                match number_constant.has_value() {
                                    true => {
                                        next_constant_value = match number_constant! {
                                            Signed(val) => (val + 1) as! u64
                                            Unsigned(val) => val + 1
                                            Floating(val) => {
                                                todo("Implement floats")
                                            }
                                        }
                                    }
                                    else => {
                                        .error(format("Enum variant '{}' in enum '{}' has a non-constant value: {}", variant.name, enum_.name, value_expression), variant.span)
                                    }
                                }
                                yield value_expression
                            }
                            false => .cast_to_underlying(
                                expr: ParsedExpression::NumericConstant(val: NumericConstant::U64(next_constant_value++), span: variant.span)
                                scope_id: parent_scope_id
                                parsed_type: underlying_type
                            )
                        }

                        enum_.variants.push(CheckedEnumVariant::WithValue(enum_id, name: variant.name, expr, span: variant.span))
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant.name
                            type_id: enum_.type_id
                            is_mutable: false
                            definition_span: variant.span
                            type_span: None
                            visibility: CheckedVisibility::Public
                        ))
                        .add_var_to_scope(scope_id: enum_.scope_id, name: variant.name, var_id, span: variant.span)
                    }
                }
            }
            SumEnum(is_boxed, variants) => {
                mut module = .current_module()
                for variant in variants {
                    if seen_names.contains(variant.name) {
                        .error(format("Enum variant '{}' is defined more than once", variant.name), variant.span)
                        continue
                    }
                    seen_names.add(variant.name)
                    let is_structlike = variant.params.has_value() and variant.params!.size() > 0 and variant.params![0].name != ""
                    let is_typed = variant.params.has_value() and variant.params!.size() == 1 and variant.params![0].name == ""

                    if is_structlike {
                        mut seen_fields: {String} = {}
                        for name in common_seen_fields {
                            seen_fields.add(name)
                        }

                        mut params: [CheckedParameter] = []
                        for param in common_params {
                            params.push(param)
                        }

                        mut fields: [VarId] = []
                        for field in common_fields {
                            fields.push(field)
                        }

                        if (variant.params is Some(variant_params) and variant.default_values is Some(variant_default_values)) {
                            for i in 0..variant_params.size() {
                                let param = variant_params[i]
                                let default_value = variant_default_values[i]

                                if seen_fields.contains(param.name) {
                                    .error(format("Enum variant '{}' has a member named '{}' more than once", variant.name, param.name), param.span)
                                    continue
                                }
                                seen_fields.add(param.name)
                                let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, name: param.name)
                                let checked_var = CheckedVariable(
                                    name: param.name
                                    type_id
                                    is_mutable: param.is_mutable
                                    definition_span: param.span
                                    type_span: None
                                    visibility: CheckedVisibility::Public
                                )

                                params.push(CheckedParameter(
                                    requires_label: true
                                    variable: checked_var
                                    default_value_expression: match default_value.has_value() {
                                        true => (default_value!, enum_.scope_id)
                                        false => None
                                    }
                                ))

                                if .dump_type_hints and param.parsed_type is Empty {
                                    .dump_type_hint(type_id, span: param.span)
                                }

                                mut module = .current_module()
                                let var_id = module.add_variable(checked_var)
                                fields.push(var_id)
                            }
                        }
                        enum_.variants.push(CheckedEnumVariant::StructLike(enum_id, name: variant.name, fields, span: variant.span))
                        let maybe_enum_variant_constructor = .find_functions_with_name_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: false, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: false, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                )
                                block: CheckedBlock(
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::MayReturn
                                ),
                                can_throw: false
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                                is_unsafe: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(
                                parent_scope_id: enum_.scope_id,
                                name: variant.name,
                                overload_set: [function_id],
                                span: variant.span
                            )
                        }
                    } else if is_typed {
                        mut params: [CheckedParameter] = []
                        for param in common_params {
                            params.push(param)
                        }

                        let param = variant.params![0]
                        let type_id = .typecheck_typename(parsed_type: param.parsed_type, scope_id: enum_.scope_id, name: param.name)
                        enum_.variants.push(CheckedEnumVariant::Typed(enum_id, name: variant.name, type_id, span: variant.span))

                        let maybe_enum_variant_constructor = .find_functions_with_name_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: false, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: false, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let variable = CheckedVariable(
                                name: "value"
                                type_id
                                is_mutable: false
                                definition_span: param.span
                                type_span: None
                                visibility: CheckedVisibility::Public
                            )
                            params.push(
                                CheckedParameter(requires_label: false, variable, default_value_expression: None)
                            )

                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                )
                                block: CheckedBlock(
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::AlwaysReturns
                                ),
                                can_throw: false
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                                is_unsafe: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(
                                parent_scope_id: enum_.scope_id,
                                name: variant.name,
                                overload_set: [function_id],
                                span: variant.span
                            )
                        }
                    } else {
                        mut params: [CheckedParameter] = []
                        for param in common_params {
                            params.push(param)
                        }

                        enum_.variants.push(CheckedEnumVariant::Untyped(enum_id, name: variant.name, span: variant.span))
                        let maybe_enum_variant_constructor = .find_functions_with_name_in_scope(parent_scope_id: enum_.scope_id, function_name: variant.name)
                        if not maybe_enum_variant_constructor.has_value() {
                            let function_scope_id = .create_scope(parent_scope_id, can_throw: false, debug_name: format("enum-variant-constructor({}::{})", enum_.name, variant.name))
                            let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: false, debug_name: format("enum-variant-constructor-block({}::{})", enum_.name, variant.name))
                            let checked_function = CheckedFunction(
                                name: variant.name
                                name_span: variant.span
                                visibility: CheckedVisibility::Public
                                return_type_id: .find_or_add_type_id(Type::Enum(enum_id))
                                return_type_span: None
                                params
                                generics: FunctionGenerics(
                                    base_scope_id: function_scope_id
                                    base_params: params
                                )
                                block: CheckedBlock(
                                    scope_id: block_scope_id
                                    control_flow: BlockControlFlow::AlwaysReturns
                                ),
                                can_throw: false
                                type: FunctionType::ImplicitEnumConstructor
                                linkage: FunctionLinkage::Internal
                                function_scope_id
                                struct_id: None
                                is_instantiated: true
                                parsed_function: None
                                is_comptime: false
                                is_virtual: false
                                is_override: false
                                is_unsafe: false
                            )
                            let function_id = module.add_function(checked_function)
                            .add_function_to_scope(
                                parent_scope_id: enum_.scope_id,
                                name: variant.name,
                                overload_set: [function_id],
                                span: variant.span
                            )
                        }
                    }
                }
            }
            else => {}
        }
    }

    fn typecheck_enum(mut this, record: ParsedRecord, enum_id: EnumId, parent_scope_id: ScopeId) throws {
        let old_self_type_id = .self_type_id
        .set_self_type_id(.get_enum(enum_id).type_id)
        defer .self_type_id = old_self_type_id

        for method in record.methods {
            .typecheck_method(
                func: method.parsed_function
                parent_id: StructLikeId::Enum(enum_id)
            )
        }
    }

    fn cast_to_underlying(mut this, anon expr: ParsedExpression, scope_id: ScopeId, parsed_type: ParsedType) throws -> CheckedExpression {
        let cast_expression = ParsedExpression::UnaryOp(expr, op: UnaryOperator::TypeCast(TypeCast::Infallible(parsed_type)), span: expr.span())
        return .typecheck_expression(cast_expression, scope_id, safety_mode: SafetyMode::Safe, type_hint: None)
    }

    fn typecheck_struct(mut this, record: ParsedRecord, struct_id: StructId, parent_scope_id: ScopeId) throws {
        let struct_type_id = .find_or_add_type_id(Type::Struct(struct_id))

        .current_struct_type_id = struct_type_id

        let old_self_type_id = .self_type_id
        .set_self_type_id(struct_type_id)
        defer .self_type_id = old_self_type_id

        mut all_virtuals: [String: [CheckedFunction]] = [:]
        mut super_struct_id = .get_struct(struct_id).super_struct_id
        while super_struct_id.has_value() {
            let super_struct = .get_struct(super_struct_id!)
            let scope = .get_scope(super_struct.scope_id)
            for (_, overload_set) in scope.functions {
                for function_id in overload_set {
                    let function = .get_function(function_id)
                    if function.is_virtual {
                        if not all_virtuals.contains(function.name) {
                            all_virtuals[function.name] = [function]
                        }else {
                            all_virtuals[function.name].push(function)
                        }
                    }
                }
            }
            super_struct_id = super_struct.super_struct_id
        }

        for method in record.methods {
            .typecheck_override(
                method: method
                parent_scope_id: .get_struct(struct_id).scope_id
                all_virtuals: all_virtuals
            )
            .typecheck_method(func: method.parsed_function, parent_id: StructLikeId::Struct(struct_id))
        }

        .current_struct_type_id = None
    }

    fn typecheck_override(mut this, method: ParsedMethod, parent_scope_id: ScopeId, all_virtuals: [String: [CheckedFunction]]) throws {
        guard method.is_override else {
            if all_virtuals.contains(method.parsed_function.name) {
                .error("Missing override keyword on function that is virtual", method.parsed_function.name_span)
            }
            return
        }

        mut overrides = all_virtuals.get(method.parsed_function.name)
        guard overrides.has_value() else {
            .error("Missing virtual for override", method.parsed_function.name_span)
            return
        }

        let override_target: CheckedFunction? = overrides!.pop()
        guard override_target.has_value() else {
            .error("Missing virtual for override", method.parsed_function.name_span)
            return
        }

        let method_id = .find_function_matching_signature_in_scope(
            parent_scope_id: parent_scope_id,
            prototype: method.parsed_function
        )
        let method_function = .get_function(method_id!)

        if not method_function.return_type_id.equals(override_target!.return_type_id) {
            .error(
                "Override function return type does not match virtual function",
                method_function.return_type_span ?? method_function.name_span
            )
        }

        if method_function.can_throw != override_target!.can_throw {
            .error(
                "Override function throwability does not match virtual function",
                method_function.name_span
            )
        }

        if method_function.params.size() != override_target!.params.size() {
            .error(
                "Override function parameters do not match virtual function",
                method_function.name_span
            )
            return
        }

        for param_index in 0..method_function.params.size() {
            let method_param = method_function.params[param_index]
            let virtual_param = override_target!.params[param_index]

            if virtual_param.variable.is_mutable != method_param.variable.is_mutable {
                .error(
                    "Override function parameter mutability does not match virtual function",
                    method_param.variable.definition_span
                )
            }

            if param_index == 0 and method_param.variable.name == "this" {
                continue
            }

            if not method_param.variable.type_id.equals(virtual_param.variable.type_id) {
                .error(
                    "Override function parameter type does not match virtual function",
                    method_param.variable.type_span ?? method_param.variable.definition_span
                )
            }
        }
    }

    fn typecheck_method(mut this, func: ParsedFunction, parent_id: StructLikeId) throws -> FunctionId? {
        mut parent_generic_parameters: [CheckedGenericParameter] = []
        mut parent_scope_id = .prelude_scope_id()
        mut parent_definition_linkage = DefinitionLinkage::Internal

        match parent_id {
            Struct(struct_id) => {
                mut structure = .get_struct(struct_id)
                parent_scope_id = structure.scope_id
                parent_definition_linkage = structure.definition_linkage
                parent_generic_parameters = structure.generic_parameters
            }
            Enum(enum_id) => {
                let enum_ = .get_enum(enum_id)
                parent_scope_id = enum_.scope_id
                parent_definition_linkage = enum_.definition_linkage
                parent_generic_parameters = enum_.generic_parameters
            }
            Trait(trait_id) => {
                let trait_ = .get_trait(trait_id)
                parent_scope_id = trait_.scope_id
                parent_definition_linkage = DefinitionLinkage::Internal
                parent_generic_parameters = trait_.generic_parameters
            }
        }

        if (not func.generic_parameters.is_empty()) and not func.must_instantiate {
            return None
        }

        let method_id = .find_function_matching_signature_in_scope(parent_scope_id, prototype: func)
        guard method_id.has_value() else {
            .compiler.panic(format("Previously defined function {} not found in scope {}", func.name, parent_scope_id))
        }

        .typecheck_function(parsed_function: func, parent_scope_id)

        return method_id!
    }

    fn typecheck_parameter(mut this, parameter: ParsedParameter, scope_id: ScopeId, first: bool, this_arg_type_id: TypeId?, check_scope: ScopeId?) throws -> CheckedParameter {
        mut type_id = .typecheck_typename(parsed_type: parameter.variable.parsed_type, scope_id, name: parameter.variable.name)

        if first and parameter.variable.name == "this" {
            if this_arg_type_id.has_value() {
                type_id = this_arg_type_id!
            }
        }

        if .get_type(type_id).qualifiers.is_immutable {
            // A parameter type cannot be immutable (the binding can be immutable though)
            type_id = .with_qualifiers(qualifiers: CheckedQualifiers(is_immutable: false), type_id)
            // If the binding *isn't* immutable, raise an error.
            if parameter.variable.is_mutable {
                .error("Cannot have a mutable binding to an immutable parameter", parameter.variable.span)
            }
        }

        let variable = CheckedVariable(
            name: parameter.variable.name
            type_id
            is_mutable: parameter.variable.is_mutable
            definition_span: parameter.variable.span
            type_span: None
            visibility: CheckedVisibility::Public
        )

        let checked_parameter = CheckedParameter(
            requires_label: parameter.requires_label
            variable
            default_value_expression: match parameter.default_argument.has_value() {
                true => (parameter.default_argument!, scope_id)
                false => None
            }
        )

        if check_scope.has_value() {
            mut module = .current_module()
            let var_id = module.add_variable(variable)
            .add_var_to_scope(
                scope_id: check_scope!,
                name: parameter.variable.name,
                var_id,
                span: parameter.variable.span,
            )
        }

        return checked_parameter
    }

    fn fill_trait_requirements(
        mut this
        names: [ParsedNameWithGenericParameters]
        trait_requirements: &mut [TraitId]
        trait_implementations: &mut [TypeId]
        scope_id: ScopeId
    ) throws {
        trait_requirements.ensure_capacity(names.size())
        for name in names {
            mut type_id = .find_type_in_scope(scope_id, name: name.name)
            guard type_id.has_value() else {
                .error(format("Couldn't find trait ‘{}’", name.name), name.name_span)
                continue
            }

            guard .get_type(type_id!) is Trait(trait_id) else {
                .error(format("Requirement ‘{}’ is not a trait", name.name), name.name_span)
                continue
            }

            if not name.generic_parameters.is_empty() {
                mut generic_arguments: [TypeId] = []
                for argument in name.generic_parameters {
                    generic_arguments.push(.typecheck_typename(parsed_type: argument, scope_id: scope_id, name: None))
                }

                let final_type = Type::GenericTraitInstance(id: trait_id, args: generic_arguments)
                type_id = .find_or_add_type_id(final_type)
            }

            trait_implementations.push(type_id!)

            trait_requirements.push(trait_id)
        }
    }

    fn typecheck_function_predecl(
        mut this
        parsed_function: ParsedFunction
        parent_scope_id: ScopeId
        this_arg_type_id: TypeId?
        mut generics: FunctionGenerics? = None
        scope_mixin: ScopeId? = None
    ) throws -> FunctionId {
        let function_scope_id = .create_scope(parent_scope_id, can_throw: parsed_function.can_throw, debug_name: format("fn({})", parsed_function.name))
        if scope_mixin.has_value() {
            mut function_scope = .get_scope(function_scope_id)
            function_scope.resolution_mixins.push(scope_mixin!)
        }

        let scope_debug_name = format("function-block({})", parsed_function.name)
        let block_scope_id = .create_scope(parent_scope_id: function_scope_id, can_throw: parsed_function.can_throw, debug_name: scope_debug_name)
        let module_id = .current_module_id.id

        mut base_definition = false
        if not generics.has_value() {
            generics = FunctionGenerics(
                base_scope_id: function_scope_id
            )

            base_definition = true
        }

        let is_generic_function = not parsed_function.generic_parameters.is_empty()
        let is_generic = is_generic_function or (this_arg_type_id.has_value() and .get_type(this_arg_type_id!) is GenericInstance)

        mut has_varargs = parsed_function.has_varargs
        if has_varargs and parsed_function.linkage is Internal {
            .error(
                "Only external functions are allowed to be declared using varargs"
                parsed_function.name_span
            )
            has_varargs = false
        }

        mut checked_function = CheckedFunction(
            name: parsed_function.name
            name_span: parsed_function.name_span
            visibility: .typecheck_visibility(visibility: parsed_function.visibility, scope_id: parent_scope_id)
            return_type_id: unknown_type_id()
            return_type_span: parsed_function.return_type_span
            params: []
            generics: generics!
            block: CheckedBlock(
                scope_id: block_scope_id
                control_flow: BlockControlFlow::MayReturn
            )
            can_throw: parsed_function.can_throw
            type: parsed_function.type
            linkage: parsed_function.linkage
            function_scope_id
            struct_id: None
            is_instantiated: not is_generic or not base_definition
            parsed_function
            is_comptime: parsed_function.is_comptime
            is_virtual: false
            is_override: false
            is_unsafe: parsed_function.is_unsafe
            has_varargs
            external_name: parsed_function.external_name
            deprecated_message: parsed_function.deprecated_message
            force_inline: parsed_function.force_inline
        )

        // FIXME: We can't return a `mut Foo` from a function right now, but assigning anything to a `mut` variable makes it mutable.
        //        AKA, working around one bug with another bug. :^)
        mut current_module = .current_module()
        let function_id = current_module.add_function(checked_function)
        let checked_function_scope_id = checked_function.function_scope_id

        let external_linkage = parsed_function.linkage is External

        let check_scope = match is_generic or parsed_function.return_type is Empty {
            true => Some(.create_scope(parent_scope_id, can_throw: parsed_function.can_throw, debug_name: scope_debug_name))
            else => None
        }

        // Check generic parameters
        mut i = 0
        for generic_parameter in parsed_function.generic_parameters {
            mut type_var_type_id = TypeId(
                module: current_module.id
                id: current_module.types.size()
            )

            if base_definition {
                mut parameter = FunctionGenericParameter::parameter(type_var_type_id, span: generic_parameter.span)
                mut trait_implementations: [TypeId] = []
                current_module.types.push(
                    Type::TypeVariable(name: generic_parameter.name, trait_implementations, is_value: generic_parameter.is_value)
                )
                if generic_parameter.requires_list.has_value() {
                    .fill_trait_requirements(
                        names: generic_parameter.requires_list!,
                        trait_requirements: &mut parameter.checked_parameter.constraints,
                        &mut trait_implementations,
                        scope_id: parent_scope_id
                    )
                }
                checked_function.generics.params.push(parameter)
            } else if checked_function.generics.params[i].kind is Parameter {
                type_var_type_id = checked_function.generics.params[i].type_id()
            }

            if not parsed_function.must_instantiate or external_linkage {
                .add_type_to_scope(
                    scope_id: checked_function_scope_id
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }

            if check_scope.has_value() {
                .add_type_to_scope(
                    scope_id: check_scope!
                    type_name: generic_parameter.name
                    type_id: type_var_type_id
                    span: generic_parameter.span
                )
            }

            i++
        }

        // Check parameters
        mut first = true
        mut module = .current_module()
        for parameter in parsed_function.params {
            let checked_param = .typecheck_parameter(parameter, scope_id: checked_function_scope_id, first, this_arg_type_id, check_scope)

            checked_function.params.push(checked_param)
            if base_definition {
                checked_function.generics.base_params.push(checked_param)
            }

            first = false
        }

        if parsed_function.stores_arguments.has_value() {
            for (index, _) in parsed_function.stores_arguments! {
                if index >= checked_function.params.size() {
                    .compiler.panic("stores_argument() index out of bounds")
                }

                match .get_type(checked_function.params[index].variable.type_id) {
                    Reference | MutableReference => {}
                    else => {
                        .error_with_hint(
                            "This parameter is not a reference",
                            checked_function.params[index].variable.definition_span
                            "stores_argument() may only be used to declare reference lifetime requirements"
                            checked_function.params[index].variable.definition_span
                        )
                    }
                }
            }
        }

        checked_function.stores_arguments = parsed_function.stores_arguments

        // Check return type
        mut function_return_type_id = .typecheck_typename(parsed_type: parsed_function.return_type, scope_id: checked_function_scope_id, name: None)
        if parsed_function.return_type is Empty {
            if parsed_function.is_fat_arrow {
                let old_ignore_errors = .ignore_errors
                .ignore_errors = true
                .had_an_error = false
                let block = .typecheck_block(
                    parsed_block: parsed_function.block,
                    parent_scope_id: check_scope!,
                    safety_mode: SafetyMode::Safe
                )
                if .had_an_error {
                    function_return_type_id = void_type_id()
                    .ignore_errors = false // If we're here, the code can never be "correct"
                    .error_with_hint(
                        "Can't infer the return type of this function"
                        parsed_function.return_type_span
                        "Try adding an explicit return type to the function here"
                        parsed_function.return_type_span
                    )
                } else {
                    function_return_type_id = .infer_function_return_type(block)
                }

                .ignore_errors = old_ignore_errors
                .had_an_error = false
            } else {
                function_return_type_id = void_type_id()
            }
        }

        checked_function.return_type_id = function_return_type_id

        if not .get_scope(parent_scope_id).is_from_generated_code {
            .check_that_type_doesnt_contain_reference(type_id: function_return_type_id, span: parsed_function.return_type_span)
        }

        if not parsed_function.generic_parameters.is_empty() and function_return_type_id.equals(unknown_type_id()) {
            let old_ignore_errors = .ignore_errors
            .ignore_errors = true
            let block = .typecheck_block(
                parsed_block: parsed_function.block,
                parent_scope_id: check_scope!,
                safety_mode: SafetyMode::Safe
            )
            .ignore_errors = old_ignore_errors
            .had_an_error = false

            let return_type_id = match function_return_type_id.equals(unknown_type_id()) {
                true => .infer_function_return_type(block)
                false => .resolve_type_var(type_var_type_id: function_return_type_id, scope_id: parent_scope_id)
            }

            checked_function.block = block
            checked_function.return_type_id = return_type_id
        }

        .add_function_to_scope(
            parent_scope_id,
            name: parsed_function.name,
            overload_set: [function_id],
            span: parsed_function.name_span
        )

        return function_id
    }

    fn check_that_type_doesnt_contain_reference(mut this, type_id: TypeId, span: Span) throws {
        if .type_contains_reference(type_id) {
            .error(
                format(
                    "Reference type ‘{}’ not usable in this context"
                    .type_name(type_id)
                )
                span
            )
        }
    }

    fn type_contains_reference(mut this, type_id: TypeId) -> bool {
        let type = .get_type(type_id)

        // FIXME: Check for any type that contains a reference as a generic parameter, etc.
        return match type {
            Reference | MutableReference => true
            else => false
        }
    }

    fn check_type_argument_requirements(mut this, generic_argument: TypeId, constraints: [TraitId], arg_span: Span) throws {
        // if the parameter has no trait requirements, then it's OK
        guard not constraints.is_empty() else {
            return
        }

        // only structs or enums can implement traits
        let type = .get_type(generic_argument)
        let (implemented_traits, decl_span) = match type {
            GenericEnumInstance(id) | Enum(id) => (.get_enum(id).trait_implementations, .get_enum(id).name_span)
            GenericInstance(id) | Struct(id) => (.get_struct(id).trait_implementations, .get_struct(id).name_span)
            else => match type.is_builtin() {
                true => {
                    let struct_id = .program.builtin_implementation_struct(
                        builtin: type.as_builtin_type()
                        for_module: .program.prelude_module_id()
                    )
                    yield (.get_struct(struct_id).trait_implementations, .get_struct(struct_id).name_span)
                }
                false => {
                    .error(
                        format(
                            "Cannot use ‘{}’ here as only enums, structs and classes can implement the required traits",
                            .type_name(generic_argument)
                        )
                        arg_span
                    )
                    // NOTE: C++ rejects the 'return {}' because it cannot get a matching constructor
                    unsafe { cpp {
                        "return ErrorOr<void>{};"
                    } }

                    // unreachable
                    abort()
                }
            }
        }

        for constraint in constraints {
            let trait_ = .program.get_trait(constraint)
            match trait_.requirements {
                Nothing | Methods => {
                    let trait_name = trait_.name
                    let implemented_trait = implemented_traits.get(trait_name)
                    // FIXME: Check generic arguments too.
                    if not implemented_trait.has_value() or not (implemented_trait!.first()?.0?.equals(constraint) ?? false) {
                        .error_with_hint(
                            format("Cannot use ‘{}’ here as it doesn't implement the trait ‘{}’",
                                .type_name(generic_argument), trait_name)
                            arg_span,
                            "Consider implementing the required trait for this type",
                        decl_span)
                    }
                }
                ComptimeExpression(expr) => {
                    mut interpreter = .interpreter()
                    mut scope = InterpreterScope::create(
                        type_bindings: [
                            .find_or_add_type_id(Type::Self): generic_argument
                        ]
                    )
                    let result = try interpreter.execute_expression(expr, scope)
                    mut meets_requirement = false
                    if result.has_value() {
                        meets_requirement = match result! {
                            JustValue(value) => match value.impl {
                                Bool(x) => x
                                else => {
                                    .error(
                                        format(
                                            "Invalid result type for comptime requirements in trait ‘{}’, expected ‘bool’ but got ‘{}’"
                                            trait_.name
                                            value.impl
                                        )
                                        arg_span
                                    )
                                    yield false
                                }
                            }
                            else => {
                                .error(
                                    format(
                                        "Invalid result type for comptime requirements in trait ‘{}’, expected ‘bool’ but got ‘{}’"
                                        trait_.name
                                        result
                                    )
                                    arg_span
                                )
                                yield false
                            }
                        }
                    }

                    if not meets_requirement {
                        .error(
                            format(
                                "Cannot use ‘{}’ here as it doesn't meet the comptime requirements for ‘{}’"
                                .type_name(generic_argument)
                                trait_.name
                            )
                            arg_span
                        )
                    }
                }
            }
        }
    }

    fn typecheck_and_specialize_generic_function(
        mut this
        function_id: FunctionId
        generic_arguments: [TypeId]
        parent_scope_id: ScopeId
        this_type_id: TypeId?
        generic_substitutions: GenericInferences
        type_args: [ParsedType]
        call_span: Span
        args: [(String, CheckedExpression)]?
    ) throws -> FunctionId {
        mut checked_function = .get_function(function_id)

        if not checked_function.parsed_function.has_value() {
            return function_id
        }

        let specialization_index = checked_function.generics.specializations.size()
        checked_function.generics.specializations.push(generic_arguments)

        let old_module_id = .current_module_id
        defer .current_module_id = old_module_id

        .current_module_id = checked_function.function_scope_id.module_id

        mut module = .current_module()

        let new_function_id = module.next_function_id()
        mut parsed_function = checked_function.to_parsed_function()
        mut arg_names = ""
        for arg in generic_arguments {
            if not arg_names.is_empty() {
                arg_names += ", "
            }
            arg_names += .type_name(arg)
        }
        let scope_id = .create_scope(
            parent_scope_id: checked_function.generics.base_scope_id
            can_throw: parsed_function.can_throw
            debug_name: format("function-specialization({}<{}>)", parsed_function.name, arg_names)
        )

        if parsed_function.generic_parameters.size() != generic_arguments.size() {
            .error(
                format("Generic function {} expects {} generic arguments, but {} were given",
                    parsed_function.name, parsed_function.generic_parameters.size(), generic_arguments.size()
                )
                parsed_function.name_span
            )
        }

        // NOTE: In the case where the calling function has type errors, we may not have sufficient information to
        //       check this generic call. If that's the case, we bail out here and let the previous errors bubble
        //       out to the user.
        guard parsed_function.generic_parameters.size() <= generic_arguments.size()
            and parsed_function.generic_parameters.size() <= checked_function.generics.params.size() else {
            return function_id
        }

        for i in 0..parsed_function.generic_parameters.size() {
            mut arg_span = call_span
            if type_args.size() > i {
                arg_span = type_args[i].span()
            }
            if generic_arguments.size() > i {
                .check_type_argument_requirements(
                    generic_argument: generic_arguments[i],
                    constraints: checked_function.generics.params[i].checked_parameter.constraints,
                    arg_span)
            }
        }

        let span = parsed_function.name_span
        if this_type_id.has_value() {
            let p: [CheckedGenericParameter] = []
            let a: [TypeId] = []

            let (params, args) = match .get_type(this_type_id!) {
                GenericInstance(id, args) => (.get_struct(id).generic_parameters, args)
                GenericEnumInstance(id, args) => (.get_enum(id).generic_parameters, args)
                else => (p, a)
            }

            for i in 0..params.size() {
                let param = params[i]
                let arg = generic_substitutions.map(args[i])
                guard .get_type(param.type_id) is TypeVariable(name: type_name) else { continue }

                let dependent_scope_id: ScopeId? = match .get_type(param.type_id) {
                    GenericInstance(id: struct_id) | Struct(struct_id) => .get_struct(struct_id).scope_id
                    GenericEnumInstance(id: enum_id) | Enum(enum_id) => .get_enum(enum_id).scope_id
                    GenericTraitInstance(id: trait_id) | Trait(trait_id) => .get_trait(trait_id).scope_id
                    else => None
                }

                .add_type_to_scope(scope_id, type_name, type_id: arg, span)
                if dependent_scope_id.has_value() {
                    mut scope = .get_scope(scope_id)
                    scope.aliases.set(type_name, dependent_scope_id!)
                }
            }
        }
        for generic_parameter in checked_function.generics.params {
            let parameter_type_id = generic_parameter.checked_parameter.type_id
            let mapped = generic_substitutions.get(parameter_type_id)
            guard mapped.has_value() else { continue }
            let type_id = mapped!
            guard .get_type(parameter_type_id) is TypeVariable(name: type_name, is_value) else { continue }

            let dependent_scope_id: ScopeId? = match .get_type(parameter_type_id) {
                GenericInstance(id: struct_id) | Struct(struct_id) => .get_struct(struct_id).scope_id
                GenericEnumInstance(id: enum_id) | Enum(enum_id) => .get_enum(enum_id).scope_id
                GenericTraitInstance(id: trait_id) | Trait(trait_id) => .get_trait(trait_id).scope_id
                else => None
            }
            .add_type_to_scope(scope_id, type_name, type_id, span)

            mut scope = .get_scope(scope_id)
            if is_value and .get_type(type_id) is Const(value) {
                scope.comptime_bindings[type_name] = value
                let checked_var = CheckedVariable(
                    name: type_name
                    type_id: value.impl.type_id(&mut .program)
                    is_mutable: false
                    definition_span: value.span
                    type_span: None
                    visibility: CheckedVisibility::Public
                )
                scope.vars[type_name] = module.add_variable(checked_var)
            }

            if dependent_scope_id.has_value() {
                mut scope = .get_scope(scope_id)
                scope.aliases.set(type_name, dependent_scope_id!)
            }
        }

        parsed_function.must_instantiate = true
        checked_function.is_instantiated = true

        let previous_function_id = .current_function_id
        .current_function_id = Some(new_function_id)
        .typecheck_function_predecl(parsed_function, parent_scope_id: scope_id, this_arg_type_id: this_type_id, generics: checked_function.generics)
        .typecheck_function(parsed_function, parent_scope_id: scope_id)
        .current_function_id = previous_function_id

        mut base_scope = .get_scope(.get_scope(checked_function.generics.base_scope_id).parent!)
        base_scope.functions.get(checked_function.name)!.push(new_function_id)

        mut function = .get_function(new_function_id)
        function.specialization_index = specialization_index

        return new_function_id
    }

    fn typecheck_jakt_main(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        let param_type_error = "Main function must take a single array of strings as its parameter"

        let func_ids = .find_functions_with_name_in_scope(parent_scope_id, function_name: "main")
        if func_ids!.size() > 1 {
            .error("Function 'main' declared multiple times.", parsed_function.name_span)
        }

        if parsed_function.params.size() > 1 {
            .error(param_type_error, parsed_function.name_span)
        }

        if not parsed_function.params.is_empty() {
            if parsed_function.params[0].variable.parsed_type is JaktArray(inner, span) {
                if inner is Name(name, span) {
                    if (name != "String") {
                        .error(param_type_error, span)
                    }
                } else {
                    .error(param_type_error, span)
                }
            } else {
                .error(param_type_error, parsed_function.name_span)
            }
        }

        let return_type_error = "Main function must return c_int"
        match parsed_function.return_type {
            ParsedType::Empty => {}
            ParsedType::Name(name, span) => {
                if name != "c_int" {
                    .error(return_type_error, span)
                }
            }
            else => {
                .error(return_type_error, parsed_function.return_type_span)
            }
        }
    }

    fn infer_function_return_type(this, block: CheckedBlock) -> TypeId {
        if block.statements.is_empty() {
            return void_type_id()
        }
        if block.statements.last()! is Return(val) and val.has_value() {
            return val!.type()
        }
        return void_type_id()
    }

    fn typecheck_function(mut this, parsed_function: ParsedFunction, parent_scope_id: ScopeId) throws {
        let in_comptime_function_call = .in_comptime_function_call
        defer .in_comptime_function_call = in_comptime_function_call
        .in_comptime_function_call = parsed_function.is_comptime

        if not parsed_function.generic_parameters.is_empty() and not parsed_function.must_instantiate {
            return
        }

        let function_id = .find_function_matching_signature_in_scope(parent_scope_id, prototype: parsed_function)

        guard function_id.has_value() else {
            .compiler.panic(format("Previously defined function {} not found in scope {}", parsed_function.name, parent_scope_id))
        }

        .current_function_id = function_id!

        if parsed_function.name == "main" {
            .typecheck_jakt_main(parsed_function, parent_scope_id)
        }

        mut checked_function = .get_function(function_id!)
        let function_scope_id = checked_function.function_scope_id
        let function_linkage = checked_function.linkage

        if checked_function.is_fully_checked {
            if not .get_scope(parent_scope_id).is_from_generated_code {
                .error_with_hint(
                    format("Function ‘{}’ is already defined", parsed_function.name)
                    parsed_function.name_span
                    "Try removing this definition"
                    checked_function.parsed_function!.name_span
                )
            }
            return
        }

        defer checked_function.is_fully_checked = true

        mut module = .current_module()
        for param in checked_function.params {
            let variable = param.variable
            let var_id = module.add_variable(variable)
            .add_var_to_scope(scope_id: function_scope_id, name: variable.name, var_id, span: variable.definition_span)
        }

        mut function_return_type_id = .typecheck_typename(
            parsed_type: parsed_function.return_type
            scope_id: function_scope_id
            name: None
        )

        // If return type is not specified, default return type of non fat arrow functions is void
        if not parsed_function.is_fat_arrow and parsed_function.return_type is Empty and parsed_function.name != "main" {
            function_return_type_id = void_type_id()
        }

        if function_return_type_id.equals(never_type_id()) {
            // Allow noreturn functions to call throwing functions, they'll just be forced to crash.
            mut scope = .get_scope(function_scope_id)
            scope.can_throw = true
        }

        let block = .typecheck_block(
            parsed_function.block
            parent_scope_id: function_scope_id
            safety_mode: SafetyMode::Safe
        )

        if block.yielded_type.has_value() {
            .error_with_hint("Functions are not allowed to yield values", parsed_function.block.find_yield_span()!,
                            "You might want to return instead", parsed_function.block.find_yield_keyword_span()!)
        }

        // Infer return type if necessary
        // If the return type is unknown we infer the return type from its expression.
        let return_type_id = match function_return_type_id.equals(unknown_type_id()) {
            true => .infer_function_return_type(block)
            else => .resolve_type_var(type_var_type_id: function_return_type_id, scope_id: function_scope_id)
        }

        if not function_linkage is External and not return_type_id.equals(void_type_id()) and not block.control_flow.always_transfers_control() {
            // FIXME: Use better span
            if return_type_id.equals(never_type_id()) and not block.control_flow.never_returns() {
                .error("Control reaches end of never-returning function", parsed_function.name_span)
            } else if not block.control_flow.never_returns() and not parsed_function.is_jakt_main {
                .error("Control reaches end of non-void function", parsed_function.name_span)
            }
        }

        checked_function.block = block
        checked_function.return_type_id = return_type_id
        .current_function_id = None
    }

    fn statement_control_flow(this, anon statement: CheckedStatement) -> BlockControlFlow => match statement {
        Return => BlockControlFlow::AlwaysReturns
        Throw => BlockControlFlow::AlwaysReturns
        Break => BlockControlFlow::AlwaysTransfersControl(might_break: true)
        Continue => BlockControlFlow::AlwaysTransfersControl(might_break: false)
        Yield(expr) => expr.control_flow().updated(BlockControlFlow::AlwaysTransfersControl(might_break: false))
        If(condition, then_block, else_statement) => match condition {
            Boolean(val) => match val {
                true => then_block.control_flow
                false => match else_statement.has_value() {
                    true => .statement_control_flow(else_statement!)
                    false => BlockControlFlow::MayReturn
                }
            }
            // Note that a missing 'else' branch produces a partial result.
            else => then_block.control_flow.branch_unify_with(.maybe_statement_control_flow(else_statement, then_block.control_flow))
        }
        Block(block) => block.control_flow
        // Note that 'while' blocks, which conditions are not always true,
        // similarly to 'if's with a missing 'else' branch, produce a partial result.
        // But also: every 'break' and 'continue' inside of it, does not apply to the outer blocks,
        // and without a need for that info, Partials can just get degraded to the MayReturn.
        While(condition, block) => match condition {
            Boolean(val) => match val {
                true => match block.control_flow {
                    AlwaysReturns => BlockControlFlow::AlwaysReturns
                    NeverReturns => BlockControlFlow::NeverReturns
                    else => BlockControlFlow::MayReturn
                }
                else => BlockControlFlow::MayReturn
            }
            else => BlockControlFlow::MayReturn
        }
        Loop(block) => match block.control_flow {
            AlwaysTransfersControl(might_break) => match might_break {
                false => BlockControlFlow::AlwaysTransfersControl(might_break)
                true => BlockControlFlow::MayReturn
            }
            NeverReturns => BlockControlFlow::NeverReturns
            AlwaysReturns => BlockControlFlow::AlwaysReturns
            MayReturn => BlockControlFlow::MayReturn
            else => match block.control_flow.may_break() {
                true => BlockControlFlow::MayReturn
                // Loop will always continue, so upgrade partial results to full ones
                false => match block.control_flow {
                    PartialAlwaysReturns => BlockControlFlow::AlwaysReturns
                    PartialNeverReturns => BlockControlFlow::NeverReturns
                    PartialAlwaysTransfersControl(might_break) => BlockControlFlow::AlwaysTransfersControl(might_break)
                    else => BlockControlFlow::MayReturn // unreachable, logically.
                }
            }
        }
        Expression(expr) => expr.control_flow()
        else => BlockControlFlow::MayReturn
    }

    fn maybe_statement_control_flow(this, anon statement: CheckedStatement?, anon other_branch: BlockControlFlow) -> BlockControlFlow => match statement.has_value() {
        true => .statement_control_flow(statement!)
        false => other_branch.partial()
    }

    fn check_types_for_compat(
        mut this
        lhs_type_id: TypeId
        rhs_type_id: TypeId
        generic_inferences: &mut GenericInferences
        span: Span
    ) throws -> bool {
        if lhs_type_id.equals(rhs_type_id)
            or lhs_type_id.equals(unknown_type_id())
            or rhs_type_id.equals(unknown_type_id()) {

            return true
        }

        let lhs_type = .get_type(lhs_type_id)
        let rhs_type = .get_type(rhs_type_id)

        if lhs_type.qualifiers.is_immutable and not rhs_type.qualifiers.is_immutable {
            // Permit this, passing a mutable value to an immutable parameter is fine.
            return .check_types_for_compat(
                lhs_type_id
                rhs_type_id: .with_qualifiers(qualifiers: lhs_type.qualifiers, rhs_type_id)
                generic_inferences
                span
            )
        }

        if lhs_type.is_builtin() and
            rhs_type.is_builtin() and
            lhs_type.as_builtin_type().id() == rhs_type.as_builtin_type().id() {

            return true
        }

        if lhs_type is Self {
            guard not .self_type_id.has_value() else {
                return .check_types_for_compat(
                    lhs_type_id: .self_type_id!
                    rhs_type_id
                    generic_inferences
                    span
                )
            }
            .error(
                "Invalid use of the 'Self' type"
                span
            )
        }

        if rhs_type is Self {
            guard not .self_type_id.has_value() else {
                return .check_types_for_compat(
                    lhs_type_id
                    rhs_type_id: .self_type_id!
                    generic_inferences
                    span
                )
            }
            .error(
                "Invalid use of the 'Self' type"
                span
            )
        }

        if rhs_type is TypeVariable and not lhs_type is TypeVariable {
            // Swap them around so that we can always assume that the LHS is a TypeVariable
            return .check_types_for_compat(
                lhs_type_id: rhs_type_id
                rhs_type_id: lhs_type_id
                generic_inferences
                span
            )
        }

        if rhs_type is Const(rhs) and lhs_type is Const(lhs) {
            if rhs.impl.equals(lhs.impl) {
                return true
            }

            let interpreter = .interpreter()
            .error(
                format(
                    "Literal type value mismatch: expected '{}', found '{}'"
                    comptime_format_impl(
                        format_string: "{}"
                        arguments: [lhs][..]
                        program: &.program
                    )
                    comptime_format_impl(
                        format_string: "{}"
                        arguments: [rhs][..]
                        program: &.program
                    )
                )
                span
            )
            return false
        }

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let array_struct_id = .find_struct_in_prelude("Array")

        match lhs_type {
            TypeVariable => {
				// Unpack one layer of inference at a time
                let maybe_resolved_inference = generic_inferences.get(lhs_type_id)
                if maybe_resolved_inference is Some(resolved_inference) {
					return .check_types_for_compat(
						lhs_type_id: resolved_inference
						rhs_type_id
						generic_inferences
						span
					)
                } else {
                    generic_inferences.set(key: lhs_type_id, value: rhs_type_id)
                }
            }
            Dependent(namespace_type, name) => {
                if rhs_type is Dependent(namespace_type: rhs_namespace_type, name: rhs_name) {
                    .check_types_for_compat(
                        lhs_type_id: namespace_type
                        rhs_type_id: rhs_namespace_type
                        generic_inferences
                        span
                    )

                    if name != rhs_name {
                        .error(
                            format("Type mismatch: mismatched names for dependent types: ‘{}’ and ‘{}’", name, rhs_name)
                            span
                        )
                        return false
                    }
                }

                // Can't compare a dependent type to a non-dependent type at this stage, so just assume it's fine
            }
            GenericEnumInstance(id: lhs_enum_id, args: lhs_args) => {
                if rhs_type is GenericEnumInstance(id: rhs_enum_id, args: rhs_args) {
                    if lhs_enum_id.equals(rhs_enum_id) {
                        let lhs_enum = .get_enum(lhs_enum_id)
                        guard lhs_args.size() == rhs_args.size() else {
                            .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < lhs_args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_args[idx]
                                rhs_type_id: rhs_args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Function(params: lhs_params, can_throw: lhs_can_throw, return_type_id: lhs_return_type_id) => {
                guard rhs_type is Function(params: rhs_params, can_throw: rhs_can_throw, return_type_id: rhs_return_type_id) else {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }

                if not (lhs_can_throw == rhs_can_throw) {
                    let lhs_throw = match lhs_can_throw {
                        true => "Yes"
                        else => "No"
                    }

                    let rhs_throw = match rhs_can_throw {
                        true => "Yes"
                        false => "No"
                    }

                    .error(
                        format("Function can throw mismatch: expected ‘{}’, but got ‘{}’", lhs_throw, rhs_throw)
                        span
                    )
                }

                if not (lhs_params.size() == rhs_params.size()) {
                    .error(
                        format("Function parameter count mismatch: expected ‘{}’, but got ‘{}’", lhs_params.size(), rhs_params.size())
                        span
                    )
                    return false
                }

                if not .check_types_for_compat(
                    lhs_type_id: lhs_return_type_id
                    rhs_type_id: rhs_return_type_id
                    generic_inferences
                    span
                ) {
                    .error_with_hint(
                        format("Function type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                        format("The return types differ: expected ‘{}’, but got ‘{}’", .type_name(lhs_return_type_id), .type_name(rhs_return_type_id))
                        hint_span: span
                    )
                    return false
                }

                for i in ..lhs_params.size() {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_params[i]
                        rhs_type_id: rhs_params[i]
                        generic_inferences
                        span
                    ) {
                        .error_with_hint(
                            format("Function type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                            format("The parameter types differ at argument {}: expected ‘{}’, but got ‘{}’", (i + 1), .type_name(lhs_params[i]), .type_name(rhs_params[i]))
                            hint_span: span
                        )
                        return false
                    }
                }
            }
            GenericInstance(id, args) => {
                let lhs_struct_id = id
                mut lhs_args = args

                // If lhs is T? or weak T and rhs is T, skip type compat check
                if (lhs_struct_id.equals(optional_struct_id)) or
                    (lhs_struct_id.equals(weakptr_struct_id)) {
                    if lhs_args.size() > 0 {
                        if (lhs_args[0].equals(rhs_type_id)) {
                            return true
                        }
                    }
                }

                if rhs_type is GenericInstance(id, args) {
                    let rhs_struct_id = id

                    if lhs_struct_id.equals(rhs_struct_id) {
                        mut rhs_args = args
                        let lhs_struct = .get_struct(lhs_struct_id)
                        if lhs_struct.generic_parameter_defaults is Some(defaults) {
                            if lhs_args.size() < defaults.size() {
                                mut new_args = lhs_args[..].to_array()
                                mut idx = lhs_args.size()
                                while idx < defaults.size() and defaults[idx].has_value() {
                                    new_args.push(defaults[idx]!)
                                    ++idx
                                }
                                lhs_args = new_args
                            }
                            if rhs_args.size() < defaults.size() {
                                mut new_args = rhs_args[..].to_array()
                                mut idx = rhs_args.size()
                                while idx < defaults.size() and defaults[idx].has_value() {
                                    new_args.push(defaults[idx]!)
                                    ++idx
                                }
                                rhs_args = new_args
                            }
                        }

                        guard lhs_args.size() == rhs_args.size() else {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_args[idx]
                                rhs_type_id: rhs_args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }
                    } else if (lhs_struct_id.equals(array_struct_id)) {
                        let array_value_type_id = args[0]
                        if (array_value_type_id.equals(unknown_type_id())) {
                            return true
                        }
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    } else {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Enum(enum_id) => {
                if lhs_type_id.equals(rhs_type_id) {
                    return true
                }

                match rhs_type {
                    GenericEnumInstance(id, args) => {
                        if enum_id.equals(id) {
                            let lhs_enum = .get_enum(enum_id)
                            if args.size() != lhs_enum.generic_parameters.size() {
                                .error(format("mismatched number of generic parameters for {}", lhs_enum.name), span)
                                return false
                            }

                            mut idx: usize = 0
                            while idx < args.size() {
                                if not .check_types_for_compat(
                                    lhs_type_id: lhs_enum.generic_parameters[idx].type_id
                                    rhs_type_id: args[idx]
                                    generic_inferences
                                    span
                                ) {
                                    // FIXME: maybe emit secondary error?
                                    return false
                                }
                                ++idx
                            }
                        }
                    }
                    TypeVariable => {
                        let maybe_seen_type_id = generic_inferences.get(rhs_type_id)
                        if maybe_seen_type_id.has_value() {
                            if maybe_seen_type_id! != lhs_type_id {
                                .error(
                                    format(
                                        "Type mismatch: expected ‘{}’, but got ‘{}’"
                                        .type_name(lhs_type_id)
                                        .type_name(maybe_seen_type_id.value())
                                    )
                                    span
                                )
                                return false
                            }
                        } else {
                            generic_inferences.set(key: lhs_type_id, value: rhs_type_id)
                        }
                    }
                    else => {
                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            Struct(lhs_struct_id) => {
                if lhs_type_id.equals(rhs_type_id) or .is_subclass_of(ancestor_type_id: rhs_type_id, child_type_id: lhs_type_id) {
                    return true
                }

                match rhs_type {
                    GenericInstance(id, args) => {
                        if not lhs_struct_id.equals(id) {
                            .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                            return false
                        }

                        let lhs_struct = .get_struct(lhs_struct_id)
                        if args.size() != lhs_struct.generic_parameters.size() {
                            .error(format("mismatched number of generic parameters for {}", lhs_struct.name), span)
                            return false
                        }

                        mut idx: usize = 0
                        while idx < args.size() {
                            if not .check_types_for_compat(
                                lhs_type_id: lhs_struct.generic_parameters[idx].type_id
                                rhs_type_id: args[idx]
                                generic_inferences
                                span
                            ) {
                                // FIXME: maybe emit secondary error?
                                return false
                            }
                            ++idx
                        }
                    }
                    TypeVariable => {
                        // If the call expects a generic type variable, let's see if we've already seen it
                        let seen_type_id = generic_inferences.get(rhs_type_id)
                        if seen_type_id.has_value() {
                            // We've seen this type variable assigned something before
                            // we should error if it's incompatible.

                            if seen_type_id.value() != lhs_type_id {
                                .error(
                                    format(
                                        "Type mismatch: expected ‘{}’, but got ‘{}’"
                                        .type_name(seen_type_id.value())
                                        .type_name(rhs_type_id)
                                    )
                                    span
                                )
                                return false
                            }
                        } else {
                            generic_inferences.set(key: lhs_type_id, value: rhs_type_id)
                        }
                    }
                    else => {
                        if .is_subclass_of(ancestor_type_id: lhs_type_id, child_type_id: rhs_type_id) {
                            return true
                        }

                        if not rhs_type_id.equals(lhs_type_id) {
                            .error(
                                format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                                span
                            )
                            return false
                        }
                    }
                }
            }
            RawPtr(lhs_rawptr_type_id) => {
                if lhs_rawptr_type_id.equals(rhs_type_id) {
                    return true
                }

                if rhs_type is RawPtr(rhs_rawptr_type_id) {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_rawptr_type_id
                        rhs_type_id: rhs_rawptr_type_id
                        generic_inferences
                        span
                    ) {
                        // FIXME: maybe emit secondary error?
                        return false
                    }
                } else {
                    if not rhs_type_id.equals(lhs_type_id) {
                        .error(
                            format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                            span
                        )
                        return false
                    }
                }
            }
            Reference(lhs_inner_type_id) => {
                if rhs_type is Reference(rhs_inner_type_id) {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_inner_type_id
                        rhs_type_id: rhs_inner_type_id
                        generic_inferences
                        span
                    ) {
                        // FIXME: maybe emit secondary error?
                        return false
                    }
                } else {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
            MutableReference(lhs_inner_type_id) => {
                if rhs_type is MutableReference(rhs_inner_type_id) {
                    if not .check_types_for_compat(
                        lhs_type_id: lhs_inner_type_id
                        rhs_type_id: rhs_inner_type_id
                        generic_inferences
                        span
                    ) {
                        // FIXME: maybe emit secondary error?
                        return false
                    }
                } else {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
            else => {
                if generic_inferences.map(rhs_type_id) != generic_inferences.map(lhs_type_id) {
                    .error(
                        format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id))
                        span
                    )
                    return false
                }
            }
        }

        return true
    }

    fn is_subclass_of(this, ancestor_type_id: TypeId, child_type_id: TypeId) -> bool {
        let ancestor_type = .get_type(ancestor_type_id)
        let child_type = .get_type(child_type_id)

        guard ancestor_type is Struct(ancestor_struct_id) else { return false }
        guard child_type is Struct(child_struct_id) else { return false }

        mut ancestor_struct = .get_struct(ancestor_struct_id)

        mut current_struct_id = child_struct_id

        loop {
            let current_struct = .get_struct(current_struct_id)
            if current_struct.super_struct_id.has_value() {
                if ancestor_struct_id.equals(current_struct.super_struct_id!) {
                    return true
                }
                current_struct_id = current_struct.super_struct_id!
            } else {
                return false
            }
        }

        return false
    }

    fn substitute_typevars_in_type(mut this, type_id: TypeId , generic_inferences: GenericInferences) throws -> TypeId => .program.substitute_typevars_in_type(type_id, generic_inferences, module_id: .current_module_id)

    fn typecheck_block(mut this, anon parsed_block: ParsedBlock, parent_scope_id: ScopeId, safety_mode: SafetyMode, yield_type_hint: TypeId? = None) throws -> CheckedBlock {
        let parent_throws = .get_scope(parent_scope_id).can_throw
        let block_scope_id = .create_scope(parent_scope_id, can_throw: parent_throws, debug_name: "block")
        mut checked_block = CheckedBlock(
            scope_id: block_scope_id
            control_flow: BlockControlFlow::MayReturn
        )
        for parsed_statement in parsed_block.stmts {
            if not checked_block.control_flow.is_reachable() {
                .error("Unreachable code", parsed_statement.span())
            }

            let checked_statement = .typecheck_statement(
                statement: parsed_statement
                scope_id: block_scope_id
                safety_mode
                type_hint: yield_type_hint
            )
            checked_block.control_flow = checked_block.control_flow.updated(.statement_control_flow(checked_statement))

            let yield_span: Span? = match parsed_statement {
                ParsedStatement::Yield(expr) => Some(expr.span())
                ParsedStatement::Guard(expr) => Some(expr.span())
                else => None
            }
            let checked_yield_expression: CheckedExpression? = match checked_statement {
                CheckedStatement::Yield(expr) => Some(expr)
                else => None
            }

            if yield_span.has_value() and checked_yield_expression.has_value() {
                let type_var_type_id = checked_yield_expression!.type()
                let type_ = .resolve_type_var(type_var_type_id , scope_id: block_scope_id)

                if checked_yield_expression! is OptionalNone {
                    checked_block.yielded_none = true
                }

                if checked_block.yielded_type.has_value() {
                    // TODO check types for compat
                    .check_types_for_compat(
                        lhs_type_id: checked_block.yielded_type.value()
                        rhs_type_id: type_
                        generic_inferences: &mut .generic_inferences
                        span: yield_span.value()
                    )
                } else {
                    checked_block.yielded_type = Some(type_)
                }
            }

            checked_block.statements.push(checked_statement)
        }

        if checked_block.yielded_type.has_value() {
            checked_block.yielded_type = Some(.substitute_typevars_in_type(
                type_id: checked_block.yielded_type.value()
                generic_inferences: .generic_inferences
            ))
        }

        return checked_block
    }

    fn debug_description_of(this, anon scope_id: ScopeId) -> String {
        mut ss: [String] = []
        mut current_scope_id = scope_id
        loop {
            let scope = .get_scope(current_scope_id)
            let d = format("{} (named {})", scope.debug_name, scope.namespace_name)
            ss.insert(before_index: 0, value: d)
            if scope.parent.has_value() {
                current_scope_id = scope.parent!
            } else {
                break
            }
        }

        return join(ss, separator: " -> ")
    }

    fn typecheck_type_qualifiers(this, anon qualifiers: ParsedTypeQualifiers?) -> CheckedQualifiers {
        guard qualifiers is Some(q) else { return CheckedQualifiers(is_immutable: false) }

        // Ignore the 'mut' qualifier, as that's the default for now.
        return CheckedQualifiers(
            is_immutable: q.is_immutable
        )
    }

    fn typecheck_typename(mut this, parsed_type: ParsedType, scope_id: ScopeId, name: String?) throws -> TypeId {
        let output = match parsed_type {
            DependentType(base, name: dependent_name) => {
                let base_type = .typecheck_typename(parsed_type: base, scope_id, name)
                let type_id = .find_or_add_type_id(Type::Dependent(namespace_type: base_type, name: dependent_name))
                yield .substitute_typevars_in_type(type_id, generic_inferences: .generic_inferences)
            }
            Const(expr) => {
                let checked_expr = .typecheck_expression(
                    expr
                    scope_id
                    safety_mode: SafetyMode::Safe
                    type_hint: None
                )
                mut interpreter = .interpreter()
                mut scope = InterpreterScope::from_runtime_scope(scope_id, program: .program)
                let value = try interpreter.execute_expression(expr: checked_expr, scope)
                if value.has_value() and value! is JustValue(resolved_value) {
                    return .find_or_add_type_id(Type::Const(resolved_value))
                }

                .error("Could not evaluate const expression", expr.span())
                return .find_or_add_type_id(Type::Unknown)
            }
            Reference(inner) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)
                yield .find_or_add_type_id(Type::Reference(inner_type_id))
            }
            MutableReference(inner) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)
                yield .find_or_add_type_id(Type::MutableReference(inner_type_id))
            }
            NamespacedName(name, namespaces, params, span) => {
                mut current_namespace_scope_id = scope_id

                for ns in namespaces {
                    let result = .find_namespace_in_scope(scope_id: current_namespace_scope_id, name: ns)

                    if result.has_value() {
                        current_namespace_scope_id = result!.0
                    } else {
                        .error(format("Unknown namespace: '{}'", ns), span)
                        return unknown_type_id()
                    }
                }

                mut generic_args: [TypeId] = []

                for param in params {
                    let checked_arg = .typecheck_typename(parsed_type: param, scope_id, name)

                    generic_args.push(checked_arg)
                }

                mut type_id: TypeId? = None
                if generic_args.is_empty() {
                    let synthetic_typename = ParsedType::Name(qualifiers: parsed_type.qualifiers, name, span)
                    // TODO: add and generic support
                    type_id = .typecheck_typename(parsed_type: synthetic_typename, scope_id: current_namespace_scope_id, name)
                } else {
                    type_id = .typecheck_generic_resolved_type(name, checked_inner_types: generic_args, scope_id: current_namespace_scope_id, span)
                }

                yield type_id!
            }
            Name(name, span) => {
                let maybe_type_and_scope = .find_type_scope(scope_id, name)
                if maybe_type_and_scope.has_value() {
                    if not maybe_type_and_scope!.1.equals(.prelude_scope_id()) {
                        return .with_qualifiers(qualifiers: .typecheck_type_qualifiers(parsed_type.qualifiers), maybe_type_and_scope!.0)
                    }
                }

                yield match name {
                    "i8" => builtin(BuiltinType::I8)
                    "i16" => builtin(BuiltinType::I16)
                    "i32" => builtin(BuiltinType::I32)
                    "i64" => builtin(BuiltinType::I64)
                    "u8" => builtin(BuiltinType::U8)
                    "u16" => builtin(BuiltinType::U16)
                    "u32" => builtin(BuiltinType::U32)
                    "u64" => builtin(BuiltinType::U64)
                    "f32" => builtin(BuiltinType::F32)
                    "f64" => builtin(BuiltinType::F64)
                    "c_char" => builtin(BuiltinType::CChar)
                    "c_int" => builtin(BuiltinType::CInt)
                    "usize" => builtin(BuiltinType::Usize)
                    "bool" => builtin(BuiltinType::Bool)
                    "void" => builtin(BuiltinType::Void)
                    "never" => builtin(BuiltinType::Never)
                    else => {
                        if maybe_type_and_scope.has_value() {
                            return maybe_type_and_scope!.0
                        }

                        if .get_scope(scope_id).is_from_generated_code and name == "unknown" {
                            return builtin(BuiltinType::Unknown)
                        }

                        .error(format("Unknown type ‘{}’ in scope {}", name, .debug_description_of(scope_id)), span)
                        yield unknown_type_id()
                    }
                }
            }
            Empty => {
                yield unknown_type_id()
            }
            JaktTuple(types, span) => {
                mut checked_types: [TypeId] = []
                for parsed_type in types {
                    checked_types.push(.typecheck_typename(parsed_type, scope_id, name))
                }
                let tuple_struct_id = .find_struct_in_prelude("Tuple")

                yield .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))
            }
            JaktArray(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

                let array_struct_id = .find_struct_in_prelude("Array")

                yield .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))
            }
            Dictionary(key, value, span) => {
                let key_type_id = .typecheck_typename(parsed_type: key, scope_id, name)
                let value_type_id = .typecheck_typename(parsed_type: value, scope_id, name)

                let dict_struct_id = .find_struct_in_prelude("Dictionary")

                // Make sure the key implements Hashable and Equal<itself>
                .ensure_type_implements_trait(
                    type_id: key_type_id
                    trait_name: "Hashable"
                    scope_id
                    span
                )
                .ensure_type_implements_trait(
                    type_id: key_type_id
                    trait_name: "Equal"
                    filter_for_generics: [key_type_id]
                    scope_id
                    span
                )

                yield .find_or_add_type_id(Type::GenericInstance(id: dict_struct_id, args: [key_type_id, value_type_id]))
            }
            Set(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

                let set_struct_id = .find_struct_in_prelude("Set")

                // Make sure the value implements Hashable and Equal<itself>
                .ensure_type_implements_trait(
                    type_id: inner_type_id
                    trait_name: "Hashable"
                    scope_id
                    span
                )
                .ensure_type_implements_trait(
                    type_id: inner_type_id
                    trait_name: "Equal"
                    filter_for_generics: [inner_type_id]
                    scope_id
                    span
                )

                yield .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [inner_type_id]))
            }
            Optional(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

                let optional_struct_id = .find_struct_in_prelude("Optional")

                yield .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [inner_type_id]))
            }
            WeakPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

                let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

                yield .find_or_add_type_id(Type::GenericInstance(id: weakptr_struct_id, args: [inner_type_id]))
            }
            RawPtr(inner, span) => {
                let inner_type_id = .typecheck_typename(parsed_type: inner, scope_id, name)

                yield .find_or_add_type_id(Type::RawPtr(inner_type_id))
            }
            GenericType(name, generic_parameters, span) => {
                mut checked_inner_types: [TypeId] = []

                for inner_type in generic_parameters {
                    let inner_type_id = .typecheck_typename(parsed_type: inner_type, scope_id, name)
                    checked_inner_types.push(inner_type_id)
                }

                yield .typecheck_generic_resolved_type(name, checked_inner_types, scope_id, span)
            }
            Function(params, can_throw, return_type, span) => {
                let function_name = match name.has_value() {
                    true => name!
                    else => (try format("lambda{}", .lambda_count++)) ?? ""
                }

                mut checked_params: [CheckedParameter] = []
                mut first = true

                let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
                defer {
                    .generic_inferences.restore(old_generic_inferences)
                }

                for param in params {
                    checked_params.push(.typecheck_parameter(parameter: param, scope_id, first, this_arg_type_id: None, check_scope: None))
                    first = false
                }

                let checked_function = CheckedFunction(
                    name: function_name
                    name_span: span
                    visibility: CheckedVisibility::Public
                    return_type_id: .typecheck_typename(parsed_type: return_type, scope_id, name: None)
                    return_type_span: return_type.span()
                    params: checked_params
                    generics: FunctionGenerics(
                        base_scope_id: scope_id
                        base_params: checked_params
                    )
                    block: CheckedBlock(
                        scope_id
                        control_flow: BlockControlFlow::MayReturn
                    )
                    can_throw
                    type: FunctionType::Expression
                    linkage: FunctionLinkage::Internal
                    function_scope_id: scope_id
                    struct_id: None
                    is_instantiated: true
                    parsed_function: None
                    is_comptime: false
                    is_virtual: false
                    is_override: false
                    is_unsafe: false
                )
                mut module = .current_module()
                let function_id = module.add_function(checked_function)

                mut param_type_ids: [TypeId] = []
                for param in checked_function.params {
                    param_type_ids.push(param.variable.type_id)
                }

                yield .find_or_add_type_id(Type::Function(
                    params: param_type_ids
                    can_throw
                    return_type_id: checked_function.return_type_id
                    pseudo_function_id: function_id
                ))
            }
        }

        let qualifiers = .typecheck_type_qualifiers(parsed_type.qualifiers)
        return .with_qualifiers(qualifiers, output)
    }

    fn with_qualifiers(
        mut this
        qualifiers: CheckedQualifiers
        anon type_id: TypeId
    ) -> TypeId {
        return .program.apply_qualifiers_to_type(qualifiers, type_id)
    }

    fn ensure_type_implements_trait(
        mut this
        type_id: TypeId
        trait_name: String
        filter_for_generics: [TypeId]? = None
        scope_id: ScopeId
        span: Span
    ) throws {
        if .get_type(type_id) is TypeVariable {
            return
        }

        let implementation = .find_any_singular_trait_implementation(
            type_id
            trait_names: [trait_name]
            scope_id
            span
            filter_for_generics
        )
        if not implementation.has_value() {
            .error(
                format("Type ‘{}’ does not implement trait ‘{}’", .type_name(type_id), trait_name)
                span
            )
        }
    }

    fn find_explicitly_specialized_type_in_scope(
        mut this
        scope_id: ScopeId
        name: String
        arguments: [TypeId]
        span: Span
    ) throws -> TypeId? {
        mut matching_types: [SpecializedType] = []
        .program.for_each_scope_accessible_unqualified_from_scope(
            scope_id
            &fn[
                &mut matching_types
                &name
                &arguments
                &span
                this
            ](scope_id: ScopeId, name_override: String?, is_alias: bool) throws -> IterationDecision<bool> {
                let scope = .get_scope(scope_id)
                if not scope.explicitly_specialized_types.contains(name) {
                    return IterationDecision::Continue
                }

                let specialized_type = scope.explicitly_specialized_types[name]
                let checkpoint = .generic_inferences.perform_checkpoint(reset: false)
                defer .generic_inferences.restore(checkpoint)

                mut is_okay = true
                for i in 0..specialized_type.arguments.size() {
                    if arguments.size() <= i {
                        break
                    }
                    let given_arg = arguments[i]
                    let specialized_arg = specialized_type.arguments[i]

                    let old_ignore_errors = .ignore_errors
                    defer .ignore_errors = old_ignore_errors
                    .ignore_errors = true

                    if not .check_types_for_compat(
                        lhs_type_id: specialized_arg
                        rhs_type_id: given_arg
                        generic_inferences: &mut .generic_inferences
                        span
                    ) {
                        is_okay = false
                        break
                    }
                }

                if is_okay { matching_types.push(specialized_type) }
                return IterationDecision::Continue
            }
        )

        mut result: TypeId? = None
        mut chosen_specialization: SpecializedType? = None
        mut max_seen_specificity = 0
        for specialization in matching_types {
            mut total_specificity = 0
            for arg in specialization.arguments {
                total_specificity += .get_type(arg).specificity(program: .program)
            }
            if total_specificity > max_seen_specificity {
                max_seen_specificity = total_specificity
                result = specialization.type_id
                chosen_specialization = specialization
            }
        }

        if chosen_specialization.has_value() {
            if StructLikeId::from_type_id(result!, &.program) is Some(struct_like_id) {
                .generic_inferences.set_all(
                    keys: struct_like_id.generic_parameters_as_checked(program: &.program)
                    values: chosen_specialization!.arguments
                )
            }
        }
        return result
    }

    fn typecheck_generic_resolved_type(
        mut this
        name: String
        checked_inner_types: [TypeId]
        scope_id: ScopeId
        span: Span
    ) throws -> TypeId {
        let explicitly_specialized_type = .find_explicitly_specialized_type_in_scope(
            scope_id
            name
            arguments: checked_inner_types
            span
        )
        if explicitly_specialized_type.has_value() {
            return StructLikeId::from_type_id(explicitly_specialized_type!, program: &.program)!.specialized_by(
                arguments: checked_inner_types
                program: &mut .program
                module_id: .current_module().id
            )
        }

        let struct_id = .find_struct_in_scope(scope_id, name)
        if struct_id.has_value() {
            let struct_ = .get_struct(struct_id!)
            mut effective_inner_types = checked_inner_types[..].to_array()
            if struct_.generic_parameter_defaults is Some(defaults) {
                for i in effective_inner_types.size()..defaults.size() {
                    if defaults[i] is Some(default_) {
                        effective_inner_types.push(default_)
                    } else {
                        break
                    }
                }
            }

            return .find_or_add_type_id(Type::GenericInstance(id: struct_id!, args: effective_inner_types))
        }

        let enum_id = .program.find_enum_in_scope(scope_id, name)
        if enum_id.has_value() {
            return .find_or_add_type_id(Type::GenericEnumInstance(id: enum_id!, args: checked_inner_types))
        }

        let trait_id = .program.find_trait_in_scope(scope_id, name)
        if trait_id.has_value() {
            return .find_or_add_type_id(Type::GenericTraitInstance(id: trait_id!, args: checked_inner_types))
        }

        .error(format("could not find {}", name), span)
        return unknown_type_id()
    }

    fn typecheck_unary_operation(
        mut this
        checked_expr: CheckedExpression
        checked_op: CheckedUnaryOperator
        span: Span
        scope_id: ScopeId
        safety_mode: SafetyMode
    ) throws -> CheckedExpression {
        let expr_type_id = checked_expr.type()
        let expr_type = .get_type(expr_type_id)

        match checked_op {
            PreIncrement | PostIncrement | PreDecrement | PostDecrement => {
                if .is_integer(expr_type_id) {
                    if not checked_expr.is_mutable(program: .program) {
                        .error("Increment/decrement of immutable variable", span)
                    }
                } else {
                    .error("Increment/decrement of non-numeric value", span)
                }
            }
            LogicalNot => {
                if not .check_types_for_compat(
                    lhs_type_id: builtin(BuiltinType::Bool)
                    rhs_type_id: checked_expr.type()
                    generic_inferences: &mut .generic_inferences
                    span) {
                    .error("Cannot use a logical Not on a value of non-boolean type", span)
                }

                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            BitwiseNot => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
            }
            TypeCast(cast) => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: cast.type_id())
            }
            Negate => {
                return .typecheck_unary_negate(expr: checked_expr, span, type_id: expr_type_id)
            }
            Is | IsEnumVariant | IsSome | IsNone => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: builtin(BuiltinType::Bool))
            }
            Sizeof => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: builtin(BuiltinType::Usize))
            }
            RawAddress => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::RawPtr(expr_type_id)))
            }
            Reference => {
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::Reference(expr_type_id)))
            }
            MutableReference => {
                if not checked_expr.is_mutable(program: .program) {
                    .error("Cannot make mutable reference to immutable value", span)
                }
                return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: .find_or_add_type_id(Type::MutableReference(expr_type_id)))
            }
            Dereference => {
                match expr_type {
                    RawPtr(type_id) => {
                        if safety_mode is Safe {
                            .error("Dereference of raw pointer outside of unsafe block", span)
                        }
                        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id)
                    }
                    Reference(type_id) | MutableReference(type_id) => {
                        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id)
                    }
                    else => {
                        .error(format("Dereference of a non-pointer type ‘{}’", .type_name(expr_type_id)), span)
                    }
                }
            }
        }
        return CheckedExpression::UnaryOp(expr: checked_expr, op: checked_op, span, type_id: expr_type_id)
    }

    fn typecheck_unary_negate(mut this, expr: CheckedExpression, span: Span, type_id: TypeId) throws -> CheckedExpression {
        if not .program.is_integer(type_id) or .program.is_signed(type_id) {
            return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
        }

        // Flipping the sign on a small enough unsigned constant is fine. We'll change the type to the signed variant.
        let flipped_sign_type = .get_type(type_id).flip_signedness()

        let constant = match expr {
            NumericConstant(val) => val
            else => {
                return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
            }
        }

        let number = constant.number_constant()!
        let raw_number = number.to_usize()
        let max_signed = Type::I64.max() as! usize;
        mut negated_number = 0;
        if raw_number == max_signed + 1 {
            negated_number = Type::I64.min()
        }
        if raw_number <= max_signed {
            negated_number = 0 - (raw_number as! i64)
        }
        let negated_number_constant = NumberConstant::Signed(negated_number as! i64)

        if raw_number > (max_signed + 1) or not negated_number_constant.can_fit_number(type_id: flipped_sign_type, program: .program) {
            .error(
                format(
                    "Negative literal -{} too small for type ‘{}’"
                    raw_number
                    .type_name(flipped_sign_type)
                )
                span
            )
            return CheckedExpression::UnaryOp(expr, op: CheckedUnaryOperator::Negate, span, type_id)
        }

        let new_constant = match .get_type(flipped_sign_type) {
            I8 => CheckedNumericConstant::I8(negated_number as! i8)
            I16 => CheckedNumericConstant::I16(negated_number as! i16)
            I32 => CheckedNumericConstant::I32(negated_number as! i32)
            I64 => CheckedNumericConstant::I64(negated_number as! i64)
            else => {
                panic("Unreachable")
            }
        }

        return CheckedExpression::UnaryOp(expr: CheckedExpression::NumericConstant(val: new_constant, span, type_id), op: CheckedUnaryOperator::Negate, span, type_id: flipped_sign_type)
    }

    fn typecheck_binary_operation(
        mut this
        checked_lhs: CheckedExpression
        op: BinaryOperator
        checked_rhs: CheckedExpression
        scope_id: ScopeId
        span: Span
    ) throws -> (CheckedBinaryOperator, TypeId) {
        let lhs_type_id = checked_lhs.type()
        let rhs_type_id = checked_rhs.type()

        let lhs_span = checked_lhs.span()
        let rhs_span = checked_rhs.span()

        mut type_id = checked_lhs.type()

        let scope = .get_scope(scope_id)

        mut checked_operator = CheckedBinaryOperator(
            op
            trait_implementation: None
        )

        match op {
            NoneCoalescing | NoneCoalescingAssign => {
                // 1. LHS must be Optional<T>.
                // 2. RHS must be Optional<T> or T.
                // 3. Resulting type is Optional<T> or T, respectively.

                // if an assignment, the LHS must be a mutable variable.
                if op is NoneCoalescingAssign {
                    if checked_lhs is Var(var, span) {
                        if not var.is_mutable {
                            .error_with_hint(message: "left-hand side of ??= must be a mutable variable", span, hint: "This variable isn't marked as mutable", hint_span: var.definition_span)
                            return (checked_operator, unknown_type_id())
                        }
                    } else {
                        .error(message: "left-hand side of ??= must be a mutable variable", span)
                        return (checked_operator, unknown_type_id())
                    }
                }

                if .get_type(lhs_type_id) is GenericInstance(id, args)
                    and id.equals(.find_struct_in_prelude("Optional")) {
                    // Success: LHS is T? and RHS is T?.
                    if lhs_type_id.equals(rhs_type_id) {
                        return (checked_operator, lhs_type_id)
                    }

                    // Extract T from Optional<T>.
                    let inner_type_id = args[0]

                    if inner_type_id.equals(rhs_type_id) {
                        // Success: LHS is T? and RHS is T.
                        return (checked_operator, inner_type_id)
                    }
                } else {
                    .error_with_hint(format(
                        "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                        .type_name(lhs_type_id),
                        .type_name(rhs_type_id),
                    ), span,
                    "Left side of ?? must be an Optional but isn't",
                    lhs_span)
                }

                .error(format(
                    "None coalescing (??) with incompatible types (‘{}’ and ‘{}’)",
                    .type_name(lhs_type_id),
                    .type_name(rhs_type_id),
                ), span)

                return (checked_operator, lhs_type_id)
            }
            LogicalAnd | LogicalOr => {
                if not lhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("left side of logical binary operation is not a boolean", lhs_span)
                }

                if not rhs_type_id.equals(builtin(BuiltinType::Bool)) {
                    .error("right side of logical binary operation is not a boolean", rhs_span)
                }

                type_id = builtin(BuiltinType::Bool)
            }
            Assign => {
                if not checked_lhs.is_mutable(program: .program) {
                    .error("Assignment to immutable variable", checked_lhs.span())
                    return (checked_operator, lhs_type_id)
                }
                if checked_rhs is OptionalNone(span, type_id) {
                    if .get_type(lhs_type_id) is GenericInstance(id, args) {
                        if id.equals(.find_struct_in_prelude("Optional")) {
                            return (checked_operator, lhs_type_id)
                        }
                        if not id.equals(.find_struct_in_prelude("WeakPtr")) {
                            .error("Cannot assign None to a non-optional type", span)
                        }
                    } else {
                        .error("Cannot assign None to a non-optional type", span)
                    }
                }

                let lhs_type = .unwrap_type_from_optional_if_needed(type: .get_type(lhs_type_id))
                if lhs_type is GenericInstance(id, args)
                    and .program.get_struct(id).name == "WeakPtr"
                    and not lhs_type_id.equals(rhs_type_id)
                {
                    // Try to handle assignment to `weak T` from `T`
                    let unified_type = .unify(lhs: args[0], lhs_span, rhs: checked_rhs.type(), rhs_span)
                    if unified_type.has_value() {
                        return (checked_operator, unified_type!)
                    }
                }

                let effective_lhs_type_id = .find_or_add_type_id(lhs_type)

                let result = .unify(lhs: rhs_type_id, lhs_span: rhs_span, rhs: effective_lhs_type_id, rhs_span: lhs_span)
                if not result.has_value() {
                    .error(format("Assignment between incompatible types (‘{}’ and ‘{}’)", .type_name(lhs_type_id), .type_name(rhs_type_id)), span)
                }
                return (checked_operator, result.value_or(lhs_type_id))
            }
            AddAssign | SubtractAssign | MultiplyAssign | DivideAssign | ModuloAssign | BitwiseAndAssign
            | BitwiseOrAssign | BitwiseXorAssign | BitwiseLeftShiftAssign | BitwiseRightShiftAssign
            | Add | Subtract | Multiply | Divide | Modulo | LessThan | LessThanOrEqual | GreaterThan
            | GreaterThanOrEqual | Equal | NotEqual => {
                let empty_array: [String] = []
                let (trait_names, is_assignment) = match op {
                    Add => (["Add", "ThrowingAdd"], false)
                    Subtract => (["Subtract", "ThrowingSubtract"], false)
                    Multiply => (["Multiply", "ThrowingMultiply"], false)
                    Divide => (["Divide", "ThrowingDivide"], false)
                    Modulo => (["Modulo", "ThrowingModulo"], false)
                    LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual => (["Compare", "ThrowingCompare"], false)
                    Equal | NotEqual => (["Equal", "ThrowingEqual"], false)
                    AddAssign => (["AddAssign", "ThrowingAddAssign"], true)
                    SubtractAssign => (["SubtractAssign", "ThrowingSubtractAssign"], true)
                    MultiplyAssign => (["MultiplyAssign", "ThrowingMultiplyAssign"], true)
                    DivideAssign => (["DivideAssign", "ThrowingDivideAssign"], true)
                    ModuloAssign => (["ModuloAssign", "ThrowingModuloAssign"], true)
                    BitwiseAndAssign => (["BitwiseAndAssign", "ThrowingBitwiseAndAssign"], true)
                    BitwiseOrAssign => (["BitwiseOrAssign", "ThrowingBitwiseOrAssign"], true)
                    BitwiseXorAssign => (["BitwiseXorAssign", "ThrowingBitwiseXorAssign"], true)
                    BitwiseLeftShiftAssign => (["BitwiseLeftShiftAssign", "ThrowingBitwiseLeftShiftAssign"], true)
                    BitwiseRightShiftAssign => (["BitwiseRightShiftAssign", "ThrowingBitwiseRightShiftAssign"], true)
                    else => (empty_array, false)
                }
                let function_name = match op {
                    Add => "add"
                    Subtract => "subtract"
                    Multiply => "multiply"
                    Divide => "divide"
                    Modulo => "modulo"
                    LessThan => "less_than"
                    LessThanOrEqual => "less_than_or_equal"
                    GreaterThan => "greater_than"
                    GreaterThanOrEqual => "greater_than_or_equal"
                    Equal => "equals"
                    NotEqual => "not_equals"
                    AddAssign => "add_assign"
                    SubtractAssign => "subtract_assign"
                    MultiplyAssign => "multiply_assign"
                    DivideAssign => "divide_assign"
                    ModuloAssign => "modulo_assign"
                    BitwiseAndAssign => "bitwise_and_assign"
                    BitwiseOrAssign => "bitwise_or_assign"
                    BitwiseXorAssign => "bitwise_xor_assign"
                    BitwiseLeftShiftAssign => "bitwise_left_shift_assign"
                    BitwiseRightShiftAssign => "bitwise_right_shift_assign"
                    else => ""
                }

                // Check for an implementation of trait 'Add<rhs_type_id, ...>' (or 'ThrowingAdd<rhs_type_id, ...>') on lhs_type_id.
                let add_trait_implementation = .find_any_singular_trait_implementation(
                    type_id: lhs_type_id
                    trait_names
                    scope_id
                    span: lhs_span
                    filter_for_generics: [rhs_type_id]
                )

                if add_trait_implementation is Some(implementation) {
                    if implementation.trait_name.starts_with("Throwing") and not scope.can_throw {
                        .error("Call to function that may throw needs to be in a try statement or a function marked as throws", span)
                    }

                    let (parent_id, _) = .struct_like_id_from_type_id(
                        type_id: lhs_type_id
                        scope_id
                        span
                        for_optional_chain: false
                        treat_string_as_builtin: true
                    )
                    let implementation_function_id = .find_function_matching_trait_implementation_in_scope(
                        self_type_id: lhs_type_id
                        parent_scope_id: parent_id?.scope_id(&.program) ?? scope_id
                        function_name
                        trait_descriptor: &implementation
                    )

                    if implementation_function_id.has_value() {
                        let implementation_function = .get_function(implementation_function_id!)
                        // Make sure the mutability of the lhs matches `this' in the implementation.
                        if implementation_function.is_mutating() and not checked_lhs.is_mutable(program: .program) {
                            if is_assignment {
                                .error("Assignment to immutable variable", span)
                            } else {
                                .error("Cannot call mutating function on an immutable object instance", span)
                            }
                        }
                        type_id = implementation_function.return_type_id

                        mut call_expression = CheckedCall(
                            namespace_: []
                            name: function_name
                            args: [("", checked_rhs)]
                            type_args: []
                            function_id: implementation_function_id
                            return_type: type_id
                            callee_throws: implementation_function.can_throw
                            external_name: implementation_function.external_name
                            force_inline: implementation_function.force_inline
                        )
                        checked_operator.trait_implementation = OperatorTraitImplementation(
                            trait_id: implementation.trait_id
                            trait_generic_arguments: implementation.implemented_type_args
                            call_expression
                        )
                    } else {
                        .error(
                            format(
                                "Failed to find an implementation of '{}' (trait {}) in type {} ({})",
                                function_name
                                implementation.trait_name
                                .type_name(lhs_type_id)
                                .get_scope(parent_id!.scope_id(&.program)).debug_name
                            ),
                            lhs_span
                        )
                        type_id = unknown_type_id()
                    }
                // FIXME: We should be able to generically implement traits on e.g. `raw T`
                //        but until we add that, let's add a small escape hatch here.
                } else if not is_assignment and
                    .get_type(lhs_type_id) is RawPtr(lhs_deref_type_id) and
                    .get_type(rhs_type_id) is RawPtr(rhs_deref_type_id) and
                    lhs_deref_type_id.equals(rhs_deref_type_id) {

                    type_id = builtin(BuiltinType::Bool)
                } else {
                    if .get_type(lhs_type_id) is TypeVariable(trait_implementations) and trait_implementations.is_empty() {
                        // YOLO Generics Mode: We'll worry about this later.
                    } else {
                        .error_with_hint(
                            format(
                                "Binary arithmetic operation between incompatible types (‘{}’ and ‘{}’)",
                                .type_name(lhs_type_id),
                                .type_name(rhs_type_id),
                            )
                            span
                            format(
                                "Consider implementing ‘(Throwing){}<{}, ...>’ for the type of this expression (‘{}’)"
                                trait_names[0]
                                .type_name(rhs_type_id)
                                .type_name(lhs_type_id)
                            )
                            lhs_span
                        )
                    }
                }
            }
            else => {}
        }

        return (checked_operator, type_id)
    }

    fn typecheck_statement(mut this, anon statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId? = None) throws -> CheckedStatement => match statement {
        Expression(expr, span) => CheckedStatement::Expression(expr: .typecheck_expression(expr, scope_id, safety_mode, type_hint: TypeId::none()), span)
        UnsafeBlock(block, span) => CheckedStatement::Block(block: .typecheck_block(block, parent_scope_id: scope_id, safety_mode: SafetyMode::Unsafe), span)
        Yield(expr, span) => CheckedStatement::Yield(expr: .typecheck_expression(expr, scope_id, safety_mode, type_hint: type_hint), span)
        Return(expr, span) => .typecheck_return(expr, span, scope_id, safety_mode)
        Block(block, span) => .typecheck_block_statement(parsed_block: block, scope_id, safety_mode, span)
        InlineCpp(block, span) => .typecheck_inline_cpp(block, span, safety_mode)
        Defer(statement, span) => .typecheck_defer(statement, scope_id, safety_mode, span)
        Loop(block, span) => .typecheck_loop(parsed_block: block, scope_id, safety_mode, span)
        Throw(expr, span) => .typecheck_throw(expr, scope_id, safety_mode, span)
        While(condition, block, span) => .typecheck_while(condition, block, scope_id, safety_mode, span)
        Continue(span) => CheckedStatement::Continue(span)
        Break(span) => CheckedStatement::Break(span)
        VarDecl(var, init, span) => .typecheck_var_decl(var, init, scope_id, safety_mode, span)
        DestructuringAssignment(vars, var_decl, span) => .typecheck_destructuring_assignment(vars, var_decl, scope_id, safety_mode, span)
        If(condition, then_block, else_statement, span) => .typecheck_if(condition, then_block, else_statement, scope_id, safety_mode, span)
        Garbage(span) => CheckedStatement::Garbage(span)
        For(iterator_name, name_span, is_destructuring, range, block, span) => .typecheck_for(iterator_name, name_span, is_destructuring, range, block, scope_id, safety_mode, span)
        Guard(expr, else_block, remaining_code, span) => .typecheck_guard(expr, else_block, remaining_code, scope_id, safety_mode, span)
    }

    fn typecheck_guard(mut this, expr: ParsedExpression, else_block: ParsedBlock, remaining_code: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut seen_scope_exit = false
        for statement in else_block.stmts {
            match statement {
                Break | Continue | Return | Throw => {
                    seen_scope_exit = true
                    break
                }
                else => {}
            }
        }

        // Ensure that we don't use any bindings we shouldn't have access to
        let checked_else_block = .typecheck_block(else_block, parent_scope_id: scope_id, safety_mode)

        if not seen_scope_exit and checked_else_block.control_flow.may_return() {
            .error("Else block of guard must either `return`, `break`, `continue`, or `throw`", span) // FIXME: better span?
        }

        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(
            condition: expr
            acc: None
            then_block: remaining_code
            else_statement: ParsedStatement::Block(block: else_block, span)
            scope_id
            span
        )
        let checked_condition = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: None, span)
        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", new_condition.span())
        }

        let checked_block = .typecheck_block(new_then_block!, parent_scope_id: scope_id, safety_mode)
        mut checked_else: CheckedStatement? = None
        if new_else_statement.has_value() {
            checked_else = .typecheck_statement(new_else_statement!, scope_id, safety_mode)
        }

        if checked_block.yielded_type.has_value() {
            return CheckedStatement::Yield(
                expr: CheckedExpression::Match(
                    expr: checked_condition,
                    match_cases: [
                        CheckedMatchCase::Expression(
                            defaults: []
                            expression: CheckedExpression::Boolean(val: true, span)
                            body: CheckedMatchBody::Expression(CheckedExpression::Block(block: checked_block, span, type_id: checked_block.yielded_type!))
                            marker_span: span
                        ),
                        CheckedMatchCase::CatchAll(
                            defaults: []
                            has_arguments: false
                            body: CheckedMatchBody::Block(checked_else_block)
                            marker_span: span
                        )
                    ]
                    span
                    type_id: checked_block.yielded_type!
                    all_variants_constant: false
                ),
                span
            )
        }

        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else, span)
    }

    fn typecheck_for(
        mut this
        iterator_name: String
        name_span: Span
        is_destructuring: bool
        range: ParsedExpression
        block: ParsedBlock
        scope_id: ScopeId
        safety_mode: SafetyMode
        span: Span
    ) throws -> CheckedStatement {
        let maybe_span = block.find_yield_span()
        if maybe_span.has_value() {
            .error("a 'for' loop block is not allowed to yield values", maybe_span!)
        }

        // Translate `for x in expr { body }` to
        // block {
        //     let (mutable) _magic = expr (.iterator() if needed)
        //     loop {
        //         let x = _magic.next()
        //         if not x.has_value() {
        //             break
        //         }
        //         let iterator_name = x!
        //         body
        //     }
        // }
        //
        // The iterator type must implement the Iterable (or ThrowingIterable) trait,
        // failing that, if it implements the IntoIterator (or IntoThrowingIterable) trait, we will automatically call the `.iterator()` method
        // and use the result as our iterable.

        mut iterable_expr = .typecheck_expression_and_dereference_if_needed(range, scope_id, safety_mode, type_hint: None, span)
        mut resolved_iterable_result_type = unknown_type_id()

        mut expression_to_iterate = range

        let iterable_trait_implementation = .find_any_singular_trait_implementation(
            type_id: iterable_expr.type()
            trait_names: ["Iterable", "ThrowingIterable"]
            scope_id
            span: iterable_expr.span()
        )

        if not iterable_trait_implementation.has_value() {
            let into_iterator_trait_implementation = .find_any_singular_trait_implementation(
                type_id: iterable_expr.type()
                trait_names: ["IntoIterator", "IntoThrowingIterator"]
                scope_id
                span: iterable_expr.span()
            )

            if not into_iterator_trait_implementation.has_value() {
                .error_with_hint(
                    "Iterable expression is not iterable", range.span(),
                    format(
                        "Consider implementing (Throwing)Iterable<T> or Into(Throwing)Iterator<T> for the type of this expression (‘{}’)"
                        .type_name(iterable_expr.type())
                    ), range.span()
                )
            } else {
                resolved_iterable_result_type = into_iterator_trait_implementation!.implemented_type_args[0]
                // We need to call the `.iterator()` method on the iterable
                expression_to_iterate = ParsedExpression::MethodCall(
                    expr: range
                    call: ParsedCall(
                        namespace_: []
                        name: "iterator"
                        args: []
                        type_args: []
                    )
                    is_optional: false
                    span: name_span
                )
            }
        } else {
            resolved_iterable_result_type = iterable_trait_implementation!.implemented_type_args[0]
        }

        // let iterable_expr = .typecheck_expression(range, scope_id, safety_mode, type_hint: None)
        // mut iterable_should_be_mutable = false

        // let iterable_type = .program.get_type(iterable_expr.type())

        // match iterable_type {
        //     TypeVariable => {
        //         // Since we're not sure, just make it mutable.
        //         iterable_should_be_mutable = true
        //     }
        //     GenericInstance(id, args) | Struct(id) => {
        //         let struct_ = .get_struct(id)
        //         let next_method_function_id = .find_function_in_scope(
        //             parent_scope_id: struct_.scope_id,
        //             function_name: "next"
        //             )
        //         if not next_method_function_id.has_value() {
        //             .error("Iterator must have a .next() method", range.span())
        //         } else {
        //             let next_method_function = .get_function(next_method_function_id!)
        //             // Check whether we need to make the iteratar mutable
        //             if next_method_function.is_mutating() {
        //                 iterable_should_be_mutable = true
        //             }
        //         }
        //     }
        //     else => {
        //         .error("Iterator must have a .next() method", name_span)
        //     }
        // }

        let rewritten_statement = ParsedStatement::Block(
            block: ParsedBlock(
                stmts: [
                    // let (mutable) _magic = expr
                    ParsedStatement::VarDecl(
                        var: ParsedVarDecl(
                            name: "_magic",
                            parsed_type: ParsedType::Empty,
                            is_mutable: true,
                            inlay_span: None,
                            span: name_span
                        ),
                        init: expression_to_iterate
                        span
                    )
                    // loop {
                    ParsedStatement::Loop(
                        block: ParsedBlock(
                            stmts: [
                                // let _magic_value = _magic.next()
                                ParsedStatement::VarDecl(
                                    var: ParsedVarDecl(
                                        name: "_magic_value",
                                        parsed_type: ParsedType::Empty,
                                        // FIXME: Figure out whether the loop variable should be mutable
                                        is_mutable: false,
                                        inlay_span: None,
                                        span: name_span
                                    ),
                                    init: ParsedExpression::MethodCall(
                                        expr: ParsedExpression::Var(
                                            name: "_magic",
                                            span: name_span
                                        ),
                                        call: ParsedCall(
                                            namespace_: [],
                                            name: "next",
                                            args: [],
                                            type_args: []
                                        ),
                                        is_optional: false
                                        span: name_span
                                    )
                                    span
                                ),
                                // if not _magic_value.has_value() {
                                ParsedStatement::If(
                                    condition: ParsedExpression::UnaryOp(
                                        expr: ParsedExpression::MethodCall(
                                            expr: ParsedExpression::Var(
                                                name: "_magic_value",
                                                span: name_span
                                            ),
                                            call: ParsedCall(
                                                namespace_: [],
                                                name: "has_value",
                                                args: [],
                                                type_args: []
                                            )
                                            is_optional: false
                                            span: name_span
                                        ),
                                        op: UnaryOperator::LogicalNot,
                                        span: name_span
                                    ),
                                    then_block: ParsedBlock(
                                        stmts: [
                                            // break
                                            ParsedStatement::Break(span)
                                        ]
                                    ),
                                    else_statement: None
                                    span
                                ),
                            // let iterator_name = _magic_value!
                            ParsedStatement::VarDecl(
                                var: ParsedVarDecl(
                                    name: iterator_name,
                                    parsed_type: ParsedType::Empty,
                                    // FIXME: loop variable mutability should be independent
                                    // of iterable mutability
                                    is_mutable: true,
                                    inlay_span: match is_destructuring {
                                        // No need for a type hint on the tuple as a whole when destructuring,
                                        // as each of its constituents already gets one.
                                        true => None
                                        false => name_span
                                    },
                                    span: name_span
                                ),
                                init: ParsedExpression::ForcedUnwrap(
                                    expr: ParsedExpression::Var(
                                        name: "_magic_value",
                                        span: name_span
                                    )
                                    span: name_span
                                )
                                span
                            ),
                            ParsedStatement::Block(block, span)
                            ]
                        )
                        span
                    )
                ]
            )
            span
        )

        return .typecheck_statement(rewritten_statement, scope_id, safety_mode)
    }

    fn expand_context_for_bindings(
        mut this
        condition: ParsedExpression
        acc: ParsedExpression?
        then_block: ParsedBlock?
        else_statement: ParsedStatement?
        scope_id: ScopeId
        span: Span
    ) throws -> (ParsedExpression, ParsedBlock?, ParsedStatement?) {
        match condition {
            BinaryOp(lhs, op, rhs) => {
                if op is LogicalAnd {
                    let (rhs_condition, rhs_then_block, rhs_else_statement) = .expand_context_for_bindings(
                        condition: rhs
                        acc
                        then_block
                        else_statement
                        scope_id
                        span
                    )
                    mut accumulated_condition = rhs_condition
                    return .expand_context_for_bindings(
                        condition: lhs
                        acc: accumulated_condition
                        then_block: rhs_then_block
                        else_statement: rhs_else_statement
                        scope_id
                        span
                    )
                }
            }
            UnaryOp(expr, op) => {
                if op is IsEnumVariant(inner, bindings) {
                    let unary_op_single_condition = ParsedExpression::UnaryOp(expr, op: UnaryOperator::Is(inner), span)
                    mut outer_if_stmts: [ParsedStatement] = []

                    let ignore_errors_state = .ignore_errors
                    .ignore_errors = true
                    let pre_checked_unary_op = .typecheck_expression(
                        unary_op_single_condition,
                        scope_id,
                        safety_mode: SafetyMode::Safe,
                        type_hint: None
                    )
                    .ignore_errors = ignore_errors_state

                    for binding in bindings {
                        let var = ParsedVarDecl(
                            name: binding.binding
                            parsed_type: ParsedType::Empty
                            is_mutable: false
                            inlay_span: None
                            span: binding.span
                        )
                        if pre_checked_unary_op is UnaryOp(op) and op is IsSome {
                            let init = ParsedExpression::ForcedUnwrap(expr, span)
                            outer_if_stmts.push(ParsedStatement::VarDecl(var, init, span))
                        } else {
                            let enum_variant_arg = ParsedExpression::EnumVariantArg(expr, arg: binding, enum_variant: inner, span)
                            outer_if_stmts.push(ParsedStatement::VarDecl(var, init: enum_variant_arg, span))
                        }
                    }
                    mut inner_condition = condition
                    if then_block.has_value() {
                        if acc.has_value() {
                            inner_condition = acc!
                            outer_if_stmts.push(
                                ParsedStatement::If(condition: inner_condition, then_block: then_block!, else_statement, span)
                            )
                        } else {
                            outer_if_stmts.push_values(&then_block!.stmts)
                        }
                    }

                    let new_then_block = ParsedBlock(stmts: outer_if_stmts)
                    return .expand_context_for_bindings(
                        condition: unary_op_single_condition
                        acc: None
                        then_block: new_then_block
                        else_statement
                        scope_id
                        span
                    )
                }
            }
            else => {}
        }
        mut base_condition = condition
        if acc.has_value() {
            base_condition = ParsedExpression::BinaryOp(lhs: condition, op: BinaryOperator::LogicalAnd, rhs: acc!, span)
        }
        return (base_condition, then_block, else_statement)
    }

    fn typecheck_if(mut this, condition: ParsedExpression, then_block: ParsedBlock, else_statement: ParsedStatement?, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(
            condition
            acc: None
            then_block
            else_statement
            scope_id
            span
        )
        let checked_condition = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: None, span)

        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", new_condition.span())
        }

        let checked_block = .typecheck_block(new_then_block!, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("An 'if' block is not allowed to yield values", new_then_block!.find_yield_span()!)
        }

        mut checked_else: CheckedStatement? = None
        if new_else_statement.has_value() {
            checked_else = .typecheck_statement(new_else_statement!, scope_id, safety_mode)
        }
        return CheckedStatement::If(condition: checked_condition, then_block: checked_block, else_statement: checked_else, span)
    }

    fn typecheck_destructuring_assignment(mut this, vars: [ParsedVarDecl], var_decl: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut var_decls: [CheckedStatement] = []
        let checked_tuple_var_decl = .typecheck_statement(statement: var_decl, scope_id, safety_mode)
        mut expr_type_id: TypeId = unknown_type_id()
        mut tuple_var_id = VarId(module: ModuleId(id: 0), id: 0)
        if checked_tuple_var_decl is VarDecl(var_id, init) {
            expr_type_id = init.type()
            tuple_var_id = var_id
        } else {
            .error("Destructuting assignment should be a variable declaration", span)
        }

        mut inner_types: [TypeId] = []
        let tuple_type = .get_type(expr_type_id)
        if tuple_type is GenericInstance(args) {
            inner_types = args
        } else {
            .error("Tuple Type should be Generic Instance", span)
        }
        let tuple_variable = .program.get_variable(tuple_var_id)
        if vars.size() == inner_types.size() {
            for i in 0..vars.size() {
                mut new_var = vars[i]
                new_var.parsed_type = ParsedType::Name(name: .type_name(inner_types[i]), span)
                let init = ParsedExpression::IndexedTuple(
                    expr: ParsedExpression::Var(name: tuple_variable.name, span)
                    index: i
                    is_optional: false
                    span)
                var_decls.push(.typecheck_var_decl(var: vars[i], init, scope_id, safety_mode, span))
            }
        } else {
            .error("Tuple inner types sould have same size as tuple members", span)
        }

        return CheckedStatement::DestructuringAssignment(vars: var_decls, var_decl: checked_tuple_var_decl, span)
    }

    fn interpreter(mut this) -> Interpreter => Interpreter::create(
        compiler: .compiler
        program: .program
        typecheck_functions: TypecheckFunctions(
            block: fn[this](
                parsed_block: ParsedBlock
                parent_scope_id: ScopeId
                safety_mode: SafetyMode
                yield_type_hint: TypeId?
                containing_function_id: FunctionId? = None
            ) throws -> CheckedBlock {
                let previous_function_id = .current_function_id
                .current_function_id = containing_function_id
                defer {
                    .current_function_id = previous_function_id
                }

                return .typecheck_block(parsed_block, parent_scope_id, safety_mode, yield_type_hint)
            }

            register_function: fn[this](
                function: CheckedFunction
            ) throws -> FunctionId {
                mut module = .current_module()
                let id = module.next_function_id()
                module.functions.push(function)
                return id
            }
        )
        spans: []
    )

    fn scope_lifetime_subsumes(this, anon larger: ScopeId?, anon smaller: ScopeId?) -> bool {
        if not larger.has_value() {
            return false
        }

        if not smaller.has_value() {
            return true
        }

        let larger_id = larger!
        let smaller_id = smaller!

        // If the scopes are equal, the smaller one is not a subscope.
        if larger_id.equals(smaller_id) {
            return false
        }

        // Go through the parent chain of the smaller scope, if 'larger' is a
        // equal to or a child of the parent, assume the smaller one is a
        // subscope.
        mut scope_id = .program.get_scope(smaller_id).parent
        while(scope_id.has_value()) {
            if scope_id!.equals(larger_id) {
                return true
            }

            let scope = .program.get_scope(scope_id!)
            for child_scope_id in scope.children {
                if child_scope_id.equals(larger_id) {
                    return true
                }
            }

            scope_id = scope.parent
        }

        return false
    }

    fn scope_lifetime_union(this, anon first: ScopeId?, anon second: ScopeId?) -> ScopeId? {
        // If one is immediate, the union is also immediate:
        if not first.has_value() or not second.has_value() {
            return None
        }

        let first_id = first!
        let second_id = second!

        // Fast path: if one is root, the union is the other
        if first_id.equals(.root_scope_id()) {
            return second_id
        }
        if second_id.equals(.root_scope_id()) {
            return first_id
        }

        // Go through first's parent chain and check if it's a direct child of second
        {
            mut scope_id = Some(first_id)
            while scope_id.has_value() {
                if scope_id!.equals(second_id) {
                    return first_id
                }
                scope_id = .get_scope(scope_id!).parent
            }
        }

        // Go through second's parent chain and check if it's a direct child of first
        {
            mut scope_id = Some(second_id)
            while scope_id.has_value() {
                if scope_id!.equals(first_id) {
                    return second_id
                }
                scope_id = .get_scope(scope_id!).parent
            }
        }

        // First and second are diverging lifetimes, we can't really do anything about that.
        return None
    }

    fn required_scope_id_in_hierarchy_for(mut this, anon expr: CheckedExpression, current_scope_id: ScopeId) throws -> (ScopeId?, CheckedExpression) => match expr {
        Boolean
        | NumericConstant
        | QuotedString
        | ByteConstant
        | CharacterConstant
        | CCharacterConstant
        | Reflect
        => (.root_scope_id(), expr)
        // Immediate values, let's not have lifetime extension for now.
        BinaryOp => (None, expr)
        UnaryOp(op, expr) => match op {
            PreIncrement | PreDecrement => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
            // NOTE: This should be the scope of whatever the pointer points to,
            // but we don't have that information, so just use the scope of the pointer - the referenced object will
            // outlive the pointer anyway.
            Dereference => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
            Reference | MutableReference => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
            TypeCast => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
            else => (None, expr)
        }
        JaktArray(vals) | JaktTuple(vals) | JaktSet(vals) => {
            mut final_scope_id: ScopeId? = None
            for val in vals {
                final_scope_id = .scope_lifetime_union(
                    final_scope_id
                    .required_scope_id_in_hierarchy_for(val, current_scope_id).0
                )
            }
            yield (final_scope_id, expr)
        }
        JaktDictionary(vals) => {
            mut final_scope_id: ScopeId? = None
            for (key, val) in vals {
                final_scope_id = .scope_lifetime_union(
                    final_scope_id
                    .scope_lifetime_union(
                        .required_scope_id_in_hierarchy_for(key, current_scope_id).0
                        .required_scope_id_in_hierarchy_for(val, current_scope_id).0
                    )
                )
            }
            yield (final_scope_id, expr)
        }
        Range => (None, expr)
        IndexedExpression(expr)
        | IndexedDictionary(expr)
        | IndexedTuple(expr)
        | IndexedStruct(expr)
        | IndexedCommonEnumMember(expr)
        | ComptimeIndex(expr)
        => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
        // FIXME: Actually look into the match and figure out the lifetimes.
        Match => (None, expr)
        // FIXME: Implement this
        EnumVariantArg => (None, expr)
        Call => (None, expr)
        // FIXME: This assumes far too much, the returned value might not even be a reference to the internals of the object.
        //        but the absolute smallest guaranteed lifetime for something returned from a member function is the lifetime of the object (for now).
        MethodCall(expr) => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
        Var(var) | NamespacedVar(var) => (var.owner_scope ?? current_scope_id, expr) // If the variable doesn't have an owner yet, we're in the process of defining it.
        OptionalNone => (None, expr)
        OptionalSome => (None, expr)
        ForcedUnwrap(expr) => .required_scope_id_in_hierarchy_for(expr, current_scope_id)
        Block => (None, expr) // Blocks can't yield values (for now)
        Function(captures) | DependentFunction(captures) => {
            mut final_scope_id: ScopeId? = None
            for capture in captures {
                mut scope_id: ScopeId? = None
                // FIXME: We should actually figure out what "all" means by looking at the function's body when making the function.
                if capture is ByMutableReference or capture is ByReference {
                    let scope_id = .find_var_in_scope(scope_id: current_scope_id, var: capture.name)?.owner_scope
                }
                final_scope_id = .scope_lifetime_union(final_scope_id, scope_id)
            }
            yield (final_scope_id, expr)
        }
        // FIXME: Check what the expression actually returns, also check the catch block (if one exists)
        Try => (None, expr)
        TryBlock => (None, expr)
        Garbage => (None, expr)
    }

    fn typecheck_var_decl(mut this, var: ParsedVarDecl, init: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        mut lhs_type_id = .typecheck_typename(parsed_type: var.parsed_type, scope_id, name: var.name)
        mut checked_expr = .typecheck_expression(expr: init, scope_id, safety_mode, type_hint: lhs_type_id)
        let rhs_type_id = checked_expr.type()

        if rhs_type_id.equals(void_type_id()) {
            .error("Cannot assign `void` to a variable", checked_expr.span())
        }

        if .get_type(lhs_type_id).qualifiers.is_immutable {
            // A parameter type cannot be immutable (the binding can be immutable though)
            lhs_type_id = .with_qualifiers(qualifiers: CheckedQualifiers(is_immutable: false), lhs_type_id)
            // If the binding *isn't* immutable, raise an error.
            if var.is_mutable {
                .error("Cannot have a mutable binding to an immutable object", var.span)
            }
        }

        if lhs_type_id.equals(unknown_type_id()) and not rhs_type_id.equals(unknown_type_id()) {
            lhs_type_id = rhs_type_id
        }

        let weak_ptr_struct_id = .find_struct_in_prelude("WeakPtr")
        let optional_struct_id = .find_struct_in_prelude("Optional")


        if .type_contains_reference(type_id: lhs_type_id) {
            // If the variable type is a reference, we need to make sure that this scope does not outlive the reference.
            let (init_scope_id, cause_expr) = .required_scope_id_in_hierarchy_for(checked_expr, current_scope_id: scope_id)
            if .scope_lifetime_subsumes(scope_id, init_scope_id) {
                .error_with_hint(
                    "Cannot assign a reference to a variable that outlives the reference"
                    checked_expr.span()
                    "Limited by this expression's lifetime"
                    cause_expr.span()
                )
            }
        }

        let lhs_type = .get_type(lhs_type_id)
        if checked_expr is OptionalNone(span, type_id) {
            if lhs_type is GenericInstance(id, args) {
                if not (id.equals(optional_struct_id) or id.equals(weak_ptr_struct_id)) {
                    .error("Cannot assign None to a non-optional type", span)
                }
            } else {
                .error("Cannot assign None to a non-optional type", span)
            }
        }

        if lhs_type is GenericInstance(id, args) {
            if id.equals(weak_ptr_struct_id) {
                if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id())
                   and not .is_subclass_of(ancestor_type_id: args[0], child_type_id: rhs_type_id) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            } else if id.equals(optional_struct_id) {
                if not lhs_type_id.equals(rhs_type_id) and not args[0].equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id())
                   and not .is_subclass_of(ancestor_type_id: args[0], child_type_id: rhs_type_id) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            } else {
                if not lhs_type_id.equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id()) {
                    .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                }
            }
        } else if lhs_type.is_builtin() {
            let number_constant = checked_expr.to_number_constant(program: .program)

            mut is_rhs_zero = false
            if number_constant.has_value() {
                is_rhs_zero = match number_constant! {
                    Signed(value) => value == 0
                    Unsigned(value) => value == 0
                    Floating(value) => value == 0.0
                }
            }

            if not (.is_numeric(lhs_type_id) and is_rhs_zero) and (.is_integer(lhs_type_id) ^ .is_integer(rhs_type_id)) {
                .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
                return CheckedStatement::Garbage(span)
            }
        } else {
            if not lhs_type_id.equals(rhs_type_id) and not rhs_type_id.equals(unknown_type_id())
               and not .is_subclass_of(ancestor_type_id: lhs_type_id, child_type_id: rhs_type_id) {
                .error(format("Type mismatch: expected ‘{}’, but got ‘{}’", .type_name(lhs_type_id), .type_name(rhs_type_id)), checked_expr.span())
            }
        }

        let checked_var = CheckedVariable(
            name: var.name
            type_id: lhs_type_id
            is_mutable: var.is_mutable
            definition_span: var.span
            type_span: None
            visibility: CheckedVisibility::Public
        )

        if .dump_type_hints and var.inlay_span.has_value() {
            .dump_type_hint(type_id: lhs_type_id, span: var.inlay_span!)
        }

        mut module = .current_module()
        let var_id = module.add_variable(checked_var)
        .add_var_to_scope(scope_id, name: var.name, var_id, span: checked_var.definition_span)

        return CheckedStatement::VarDecl(var_id, init: checked_expr, span)
    }

    fn typecheck_while(mut this, condition: ParsedExpression, block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_condition = .typecheck_expression_and_dereference_if_needed(condition, scope_id, safety_mode, type_hint: None, span)
        if not checked_condition.type().equals(builtin(BuiltinType::Bool)) {
            .error("Condition must be a boolean expression", condition.span())
        }

        let checked_block = .typecheck_block(block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘while’ block is not allowed to yield values", block.find_yield_span()!)
        }

        return CheckedStatement::While(condition: checked_condition, block: checked_block, span)
    }

    fn typecheck_try_block(mut this, stmt: ParsedStatement, error_name: String, error_span: Span, catch_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "try")
        let checked_stmt = .typecheck_statement(stmt, scope_id: try_scope_id, safety_mode)
        let error_struct_id = .find_struct_in_prelude("Error")
        let error_decl = CheckedVariable(
            name: error_name
            type_id: .get_struct(error_struct_id).type_id
            is_mutable: false
            definition_span: error_span
            type_span: None
            visibility: CheckedVisibility::Public
        )
        mut module = .current_module()
        let error_id = module.add_variable(error_decl)

        let parent_scope = .get_scope(scope_id)
        let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: parent_scope.can_throw, debug_name: "catch")
        .add_var_to_scope(scope_id: catch_scope_id, name: error_name, var_id: error_id, span: error_span)
        let checked_catch_block = .typecheck_block(catch_block, parent_scope_id: catch_scope_id, safety_mode)

        if checked_catch_block.yielded_type.has_value() {
            .error("A ‘catch’ block as part of a try block is not allowed to yield values", catch_block.find_yield_span()!)
        }

        return CheckedExpression::TryBlock(stmt: checked_stmt, catch_block: checked_catch_block, error_name, error_span, span, type_id: void_type_id())
    }

    fn typecheck_try(mut this, expr: ParsedExpression, catch_block: ParsedBlock?, catch_span: Span?, catch_name: String?, scope_id: ScopeId, safety_mode: SafetyMode, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        let try_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: true, debug_name: "try")
        let checked_expr = .typecheck_expression(expr, scope_id: try_scope_id, safety_mode, type_hint)
        let error_struct_id = .find_struct_in_prelude("Error")
        mut module = .current_module()
        mut checked_catch_block: CheckedBlock? = None
        let expression_type_id = checked_expr.type()

        let optional_struct_id = .find_struct_in_prelude("Optional")
        let optional_type = Type::GenericInstance(id: optional_struct_id, args: [expression_type_id])
        let optional_type_id = .find_or_add_type_id(optional_type)
        mut type_id = optional_type_id

        if catch_block.has_value() {
            let parent_scope = .get_scope(scope_id)
            let catch_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: parent_scope.can_throw, debug_name: "catch")
            if catch_name.has_value() {
                let error_struct_id = .find_struct_in_prelude("Error")
                let error_decl = CheckedVariable(
                    name: catch_name!
                    type_id: .get_struct(error_struct_id).type_id
                    is_mutable: false
                    definition_span: span
                    type_span: None
                    visibility: CheckedVisibility::Public
                )
                mut module = .current_module()
                let error_id = module.add_variable(error_decl)
                .add_var_to_scope(scope_id: catch_scope_id, name: catch_name!, var_id: error_id, span)
            }

            let block = .typecheck_block(catch_block!, parent_scope_id: catch_scope_id, safety_mode)
            if block.control_flow.always_transfers_control() or block.yielded_type.has_value() {
                if not (block.yielded_type ?? expression_type_id).equals(expression_type_id) {
                    .error_with_hint(
                        message: format("Expected a value of type ‘{}’, but got ‘{}’", .type_name(expression_type_id), .type_name(block.yielded_type!)),
                        span
                        hint: format("Expression 'catch' block must either yield the same type as the expression it is catching, or yield nothing"),
                        hint_span: span
                    )
                } else {
                    type_id = block.yielded_type ?? expression_type_id
                }
            } else {
                if not expression_type_id.equals(builtin(BuiltinType::Void)) {
                    .error(message: "In a try expression that returns a value, 'catch' block must either yield a value or transfer control flow", span: catch_span ?? span)
                }
            }
            checked_catch_block = block
        }

        return CheckedExpression::Try(expr: checked_expr, catch_block: checked_catch_block, catch_span, catch_name, span, type_id, inner_type_id: expression_type_id)
    }

    fn typecheck_throw(mut this, expr: ParsedExpression, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)

        let error_type_id = .find_type_in_prelude("Error")
        if not checked_expr.type().equals(error_type_id) {
            .error("throw expression does not produce an error", expr.span())
        }

        let scope = .get_scope(scope_id)
        if not scope.can_throw {
            .error("Throw statement needs to be in a try statement or a function marked as throws", expr.span())
        }

        return CheckedStatement::Throw(expr: checked_expr, span)
    }

    fn typecheck_loop(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A ‘loop’ block is not allowed to yield values", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Loop(block: checked_block, span)
    }

    fn typecheck_defer(mut this, statement: ParsedStatement, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let was_inside_defer = .inside_defer
        .inside_defer = true
        defer .inside_defer = was_inside_defer
        let checked_statement = .typecheck_statement(statement, scope_id, safety_mode)
        if checked_statement is Block(block) and block.yielded_type.has_value() {
            .error("‘yield’ inside ‘defer’ is meaningless", span)
        }
        return CheckedStatement::Defer(statement: checked_statement, span)
    }

    fn typecheck_block_statement(mut this, parsed_block: ParsedBlock, scope_id: ScopeId, safety_mode: SafetyMode, span: Span) throws -> CheckedStatement {
        let checked_block = .typecheck_block(parsed_block, parent_scope_id: scope_id, safety_mode)
        if checked_block.yielded_type.has_value() {
            .error("A block used as a statement cannot yield values, as the value cannot be observed in any way", parsed_block.find_yield_span()!)
        }
        return CheckedStatement::Block(block: checked_block, span)
    }

    fn typecheck_inline_cpp(mut this, block: ParsedBlock, span: Span, safety_mode: SafetyMode) throws -> CheckedStatement {
        if safety_mode is Safe {
            .error("Use of inline cpp block outside of unsafe block", span)
        }

        mut strings: [String] = []
        for statement in block.stmts {
            if statement is Expression(expr)
                and expr is QuotedString(val, span) {
                strings.push(val)
            } else {
                .error("Expected block of strings", span)
            }
        }

        return CheckedStatement::InlineCpp(lines: strings, span)
    }

    fn typecheck_return(mut this, expr: ParsedExpression?, span: Span, scope_id: ScopeId, safety_mode: SafetyMode) throws -> CheckedStatement {
        if .inside_defer {
            .error("‘return’ is not allowed inside ‘defer’", span)
        }
        if not expr.has_value() {
            if .current_function_id.has_value() {
                let current_function = .get_function(.current_function_id!)
                let return_type = .get_type(current_function.return_type_id)
                if (not return_type is Void) and (not return_type is Unknown) {
                    .error_with_hint(format("’return’ with no value in function ’{}’ returning ’{}’",
                                            current_function.name,
                                            .type_name(current_function.return_type_id)),
                                    span,
                                    format("Add return value of type ’{}’ here", .type_name(current_function.return_type_id)), span)
                }
            }
            return CheckedStatement::Return(val: None, span)
        }

        if not (.current_function_id.has_value() and .get_function(.current_function_id!).is_comptime) and expr! is Function {
            .error("Returning a function is not currently supported", span)
        }

        mut type_hint: TypeId? = None
        if .current_function_id.has_value() {
            type_hint = Some(.get_function(.current_function_id!).return_type_id)
        }

        let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(
            condition: expr!
            acc: None
            then_block: None
            else_statement: None
            scope_id
            span
        )
        let checked_expr = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint, span)

        if type_hint.has_value() {
            if checked_expr is OptionalNone(span) {
                if .get_type(type_hint!) is GenericInstance(id, args) {
                    if not id.equals(.find_struct_in_prelude("Optional")) and not id.equals(.find_struct_in_prelude("WeakPtr")) {
                        .error("Cannot assign None to a non-optional type", span)
                    }
                } else {
                    .error("Cannot assign None to a non-optional type", span)
                }
            }

            .unify_with_type(found_type: checked_expr.type(), expected_type: type_hint!, span)
        }

        return CheckedStatement::Return(val: checked_expr, span)
    }

    fn dereference_if_needed(mut this, anon checked_expr: CheckedExpression, span: Span) throws -> CheckedExpression {
        return match .get_type(checked_expr.type()) {
            Reference(type_id) | MutableReference(type_id) => CheckedExpression::UnaryOp(
                expr: checked_expr
                op: CheckedUnaryOperator::Dereference
                span: span
                type_id
            )
            else => checked_expr
        }
    }

    fn typecheck_expression_and_dereference_if_needed(
        mut this
        anon expr: ParsedExpression
        scope_id: ScopeId
        safety_mode: SafetyMode
        type_hint: TypeId?
        span: Span
    ) throws -> CheckedExpression {
        mut checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint)
        return .dereference_if_needed(checked_expr, span)
    }

    fn map_generic_arguments(mut this, type_id: TypeId, args: [TypeId]) {
        match .get_type(type_id) {
            GenericInstance(id, args) => {
                let struct_ = .get_struct(id)
                .generic_inferences.set_all(
                    keys: struct_.generic_parameters
                    values: args
                )
            }
            GenericEnumInstance(id, args) => {
                let enum_ = .get_enum(id)
                .generic_inferences.set_all(
                    keys: enum_.generic_parameters
                    values: args
                )
            }
            GenericTraitInstance(id, args) => {
                let trait_ = .get_trait(id)
                .generic_inferences.set_all(
                    keys: trait_.generic_parameters
                    values: args
                )
            }
            else => {
            }
        }
    }

    fn typecheck_indexed_struct(mut this, expr: ParsedExpression, field_name: String, scope_id: ScopeId, is_optional: bool, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
        let checked_expr_type_id = checked_expr.type()
        let checked_expr_type = .get_type(checked_expr_type_id)
        let optional_struct_id = .find_struct_in_prelude("Optional")

        match checked_expr_type {
            Type::GenericInstance(id, args) => {
                mut type_id = checked_expr_type_id

                if is_optional {
                    if not id.equals(optional_struct_id) {
                        .error("Optional chaining is only allowed on optional types", span)
                        return CheckedExpression::IndexedStruct(
                            expr: checked_expr
                            name: field_name
                            index: None
                            span
                            is_optional
                            type_id: unknown_type_id())
                    }

                    type_id = args[0]
                }

                let type = .get_type(type_id)
                let checkpoint = .generic_inferences.perform_checkpoint(reset: false)
                defer .generic_inferences.restore(checkpoint)

                .map_generic_arguments(type_id, args)

                match type {
                    GenericInstance(id: struct_id) | Struct(struct_id) => {
                        let structure = .get_struct(struct_id)
                        for field in structure.fields {
                            let member = .get_variable(field.variable_id)

                            if member.name == field_name {
                                mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                                if is_optional {
                                    resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                                }
                                // FIXME: Unify with type
                                .check_member_access(accessor: scope_id, accessee: structure.scope_id, member, span)
                                return CheckedExpression::IndexedStruct(
                                    expr: checked_expr
                                    name: field_name
                                    index: field.variable_id
                                    span
                                    is_optional
                                    type_id: resolved_type_id)
                            }
                        }

                        .error(format("unknown member of struct: {}.{}", structure.name, field_name), span)
                    }
                    GenericEnumInstance(id: enum_id) | Enum(enum_id) => {
                        let enum_ = .get_enum(enum_id)
                        for field in enum_.fields {
                            let member = .get_variable(field.variable_id)

                            if member.name == field_name {
                                mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                                if is_optional {
                                    resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                                }
                                // FIXME: Unify with type
                                .check_member_access(accessor: scope_id, accessee: enum_.scope_id, member, span)
                                return CheckedExpression::IndexedCommonEnumMember(
                                    expr: checked_expr
                                    index: field_name
                                    span
                                    is_optional
                                    type_id: resolved_type_id)
                            }
                        }

                        .error(format("unknown common member of enum: {}.{}", enum_.name, field_name), span)
                    }
                    else => .error(format("Member field access on value of non-struct type ‘{}’", .type_name(checked_expr_type_id)), span)
                }
            }
            Type::Struct(struct_id) => {
                if is_optional {
                    .error("Optional chaining is not allowed on non-optional types", span)
                }

                let structure = .get_struct(struct_id)

                let field_record = .lookup_struct_field(struct_id, name: field_name)
                if field_record.has_value() {
                    let member = .get_variable(field_record!.field_id)
                    let resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                    // FIXME: Unify with type
                    .check_member_access(accessor: scope_id, accessee: .get_struct(field_record!.struct_id).scope_id, member, span)
                    return CheckedExpression::IndexedStruct(
                        expr: checked_expr
                        name: field_name
                        index: field_record!.field_id
                        span
                        is_optional
                        type_id: resolved_type_id)
                }
                .error(format("unknown member of struct: {}.{}", structure.name, field_name), span)
            }
            Type::GenericEnumInstance(id: enum_id, args) | Type::Enum(enum_id) default(args: [TypeId] = []) => {
                if is_optional {
                    .error("Optional chaining is not allowed on non-optional types", span)
                }

                let checkpoint = .generic_inferences.perform_checkpoint(reset: false)
                defer .generic_inferences.restore(checkpoint)

                .map_generic_arguments(type_id: checked_expr_type_id, args)

                let enum_ = .get_enum(enum_id)
                for field in enum_.fields {
                    let member = .get_variable(field.variable_id)

                    if member.name == field_name {
                        mut resolved_type_id = .resolve_type_var(type_var_type_id: member.type_id, scope_id)
                        if is_optional {
                            resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                        }
                        // FIXME: Unify with type
                        .check_member_access(accessor: scope_id, accessee: enum_.scope_id, member, span)
                        return CheckedExpression::IndexedCommonEnumMember(
                            expr: checked_expr
                            index: field_name
                            span
                            is_optional
                            type_id: resolved_type_id)
                    }
                }

                .error(format("unknown common member of enum: {}.{}", enum_.name, field_name), span)
            }
            else => .error(format("Member field access on value of non-struct type ‘{}’", .type_name(checked_expr_type_id)), span)
        }

        // FIXME: Unify with type
        return CheckedExpression::IndexedStruct(
            expr: checked_expr
            name: field_name
            index: None
            span
            is_optional
            type_id: unknown_type_id())
    }

    fn typecheck_indexed_tuple(mut this, expr: ParsedExpression, index: usize, scope_id: ScopeId, is_optional: bool, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)

        let tuple_struct_id = .find_struct_in_prelude("Tuple")
        let optional_struct_id = .find_struct_in_prelude("Optional")
        mut expr_type_id = unknown_type_id()

        if .get_type(checked_expr.type()) is GenericInstance(id, args) {
            if id.equals(tuple_struct_id) {
                if is_optional {
                    .error("Optional chaining is not allowed on a non-optional tuple type", span)
                }
                if (index >= args.size()){
                    .error("Tuple index past the end of the tuple", span)
                } else {
                    expr_type_id = args[index]
                }
            } else if is_optional and id.equals(optional_struct_id) {
                let inner_type_id = args[0]
                if .get_type(inner_type_id) is GenericInstance(id, args) {
                    if id.equals(tuple_struct_id) {
                        if (index >= args.size()){
                            .error("Optional-chained tuple index past the end of the tuple", span)
                        } else {
                            expr_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [args[index]]))
                        }
                    }
                } else {
                    .error("Optional-chained tuple index used on non-tuple value", span)
                }
            }
        } else if is_optional {
            .error("Optional-chained tuple index used on non-tuple value", span)
        } else {
            .error("Tuple index used on non-tuple value", span)
        }

        return CheckedExpression::IndexedTuple(
            expr: checked_expr
            index: index
            span
            is_optional
            type_id: expr_type_id)
    }

    fn typecheck_comptime_index(mut this, expr: ParsedExpression, index: ParsedExpression, scope_id: ScopeId, is_optional: bool, safety_mode: SafetyMode, span: Span) throws -> CheckedExpression {
        let checked_index = .typecheck_expression(index, scope_id, safety_mode, type_hint: None)
        mut interpreter = .interpreter()
        mut scope = InterpreterScope::from_runtime_scope(scope_id, program: .program)

        let index_result = try interpreter.execute_expression(expr: checked_index, scope) catch error {
            eprintln("Error while evaluating comptime index: {}", error)
            // We can't run this yet, do it later.
            return CheckedExpression::ComptimeIndex(
                expr: .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
                index: checked_index
                is_optional
                span
            )
        }

        let index_constant = match index_result {
            JustValue(value) => match value.impl {
                JaktString(val) => NumericOrStringValue::StringValue(val)
                U8(val) | U16(val) | U32(val) | U64(val) | USize(val) => NumericOrStringValue::UnsignedNumericValue(val as! u64)
                I8(val) | I16(val) | I32(val) | I64(val) => NumericOrStringValue::SignedNumericValue(val as! i64)
                else => {
                    .error(format("Index expression evaluation failed: expected numeric or string type, found {}", value.impl), span)
                    return CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
                }
            }
            else => {
                .error(format("Index expression evaluation returned an invalid object {}", index_result), span)
                return CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
            }
        }

        return match index_constant {
            StringValue(val) => .typecheck_indexed_struct(expr, field_name: val, scope_id, is_optional, safety_mode, span)
            UnsignedNumericValue(val) | SignedNumericValue(val) => .typecheck_indexed_tuple(expr, index: val as! usize, scope_id, is_optional, safety_mode, span)
        }
    }

    fn check_member_access(mut this, accessor: ScopeId, accessee: ScopeId, member: CheckedVariable, span: Span) throws {
        match member.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    .error(format("Can't access field ‘{}’, because it is marked private", member.name), span)
                }
            }
            Restricted(scopes) => {
                .check_restricted_access(accessor, accessee_kind: "field", accessee, name: member.name, whitelist: scopes, span)
            }
            else => {}
        }
    }

    fn check_method_access(mut this, accessor: ScopeId, accessee: ScopeId, method: CheckedFunction, span: Span) throws {
        match method.visibility {
            Private => {
                if not .scope_can_access(accessor, accessee) {
                    if not method.type is Normal {
                        .error_with_hint(format("Can't access constructor ‘{}’, because it is marked private", method.name)
                            span
                            hint: "Private constructors are created if any fields are private"
                            span
                        )
                    } else {
                        .error(format("Can't access method ‘{}’, because it is marked private", method.name), span)
                    }
                }
            }
            Restricted(scopes) => {
                .check_restricted_access(accessor, accessee_kind: "function", accessee, name: method.name, whitelist: scopes, span)
            }
            else => {}
        }
    }

    fn check_restricted_access(mut this, accessor: ScopeId, accessee_kind: String, accessee: ScopeId, name: String, whitelist: [MaybeResolvedScope], span: Span) throws -> bool {
        let most_specific_active_scope_id = match .current_function_id.has_value() {
            true => .get_function(.current_function_id!).function_scope_id
            else => {
                if not .current_struct_type_id.has_value() {
                    .error(
                        format(
                            "Can't access {0} ‘{1}’ from this global scope, because ‘{1}’ restricts access to it"
                            accessee_kind
                            name
                        )
                        span
                    )
                    return false
                }
                yield match .get_type(.current_struct_type_id!) {
                    Struct(id) => .get_struct(id).scope_id
                    else => {
                        panic(format("Internal error: current_struct_type_id is not a struct", span))
                    }
                }
            }
        }

        for scope in whitelist {
            let resolved_scope = scope.try_resolve(program: .program)
            guard resolved_scope is Resolved(scope_id) else {
                continue
            }

            if .scope_can_access(accessor: most_specific_active_scope_id, accessee: scope_id) {
                return true
            }
        }

        let scope = .get_scope(most_specific_active_scope_id)
        .error(
            format(
                "Cannot access {} ‘{}’ from this scope"
                accessee_kind
                name
            )
            span
        )
        return false
    }

    fn infer_signed_int(mut this, val: i64, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        mut expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
        if type_hint.has_value() {
            let hint = type_hint!

            if hint.equals(builtin(BuiltinType::I8)) {
                let builtin_typeid = builtin(BuiltinType::I8)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val as! i8), span, type_id: builtin(BuiltinType::I8))
                }
            } else if hint.equals(builtin(BuiltinType::I16)) {
                let builtin_typeid = builtin(BuiltinType::I16)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val as! i16), span, type_id: builtin(BuiltinType::I16))
                }
            } else if hint.equals(builtin(BuiltinType::I32)) {
                let builtin_typeid = builtin(BuiltinType::I32)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                        .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val as! i32), span, type_id: builtin(BuiltinType::I32))
                }
            } else if hint.equals(builtin(BuiltinType::U8)) {
                let builtin_typeid = builtin(BuiltinType::U8)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                        .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::U8))
                }
            } else if hint.equals(builtin(BuiltinType::U16)) {
                let builtin_typeid = builtin(BuiltinType::U16)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val as! u16), span, type_id: builtin(BuiltinType::U16))
                }
            } else if hint.equals(builtin(BuiltinType::U32)) {
                let builtin_typeid = builtin(BuiltinType::U32)
                let type_ = .get_type(builtin_typeid)
                if val < type_.min() or val > (type_.max() as! i64) {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val as! u32), span, type_id: builtin(BuiltinType::U32))
                }
            } else if hint.equals(builtin(BuiltinType::U64)) {
                let builtin_typeid = builtin(BuiltinType::Usize)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val as! u64), span, type_id: builtin(BuiltinType::U64))
                }
            } else if hint.equals(builtin(BuiltinType::Usize)) {
                let builtin_typeid = builtin(BuiltinType::Usize)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::Usize))
                }
            } else if hint.equals(builtin(BuiltinType::CInt)) {
                let builtin_typeid = builtin(BuiltinType::CInt)
                let type_ = .get_type(builtin_typeid)
                if val < 0 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val as! i32), span, type_id: builtin(BuiltinType::CInt))
                }
            } else if hint.equals(builtin(BuiltinType::CChar)) {
                let builtin_typeid = builtin(BuiltinType::CChar)
                let type_ = .get_type(builtin_typeid)
                if val < 0 or val > 255 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::CChar))
                }
            }
        }
        return expr
    }

    fn infer_unsigned_int(mut this, val: u64, span: Span, type_hint: TypeId?) throws -> CheckedExpression {
        mut expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
        if type_hint.has_value() {
            let hint = type_hint!

            if hint.equals(builtin(BuiltinType::I8)) {
                let builtin_typeid = builtin(BuiltinType::I8)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val as! i8), span, type_id: builtin(BuiltinType::I8))
                }
            } else if hint.equals(builtin(BuiltinType::I16)) {
                let builtin_typeid = builtin(BuiltinType::I16)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val as! i16), span, type_id: builtin(BuiltinType::I16))
                }
            } else if hint.equals(builtin(BuiltinType::I32)) {
                let builtin_typeid = builtin(BuiltinType::I32)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val as! i32), span, type_id: builtin(BuiltinType::I32))
                }
            } else if hint.equals(builtin(BuiltinType::U8)) {
                let builtin_typeid = builtin(BuiltinType::U8)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::U8))
                }
            } else if hint.equals(builtin(BuiltinType::U16)) {
                let builtin_typeid = builtin(BuiltinType::U16)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val as! u16), span, type_id: builtin(BuiltinType::U16))
                }
            } else if hint.equals(builtin(BuiltinType::U32)) {
                let builtin_typeid = builtin(BuiltinType::U32)
                let type_ = .get_type(builtin_typeid)
                if type_.max() < val {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val as! u32), span, type_id: builtin(BuiltinType::U32))
                }
            } else if hint.equals(builtin(BuiltinType::U64)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val as! u64), span, type_id: builtin(BuiltinType::U64))
            } else if hint.equals(builtin(BuiltinType::Usize)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::Usize))
            } else if hint.equals(builtin(BuiltinType::CInt)) {
                expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val as! u64), span, type_id: builtin(BuiltinType::CInt))
            } else if hint.equals(builtin(BuiltinType::CChar)) {
                let builtin_typeid = builtin(BuiltinType::CChar)
                let type_ = .get_type(builtin_typeid)
                if val > 255 {
                    .error_with_hint("Integer promotion failed", span, format("Cannot fit value into range [{}, {}] of type {}.", type_.min(), type_.max(), .type_name(builtin_typeid)), span)
                } else {
                    expr = CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val as! u8), span, type_id: builtin(BuiltinType::CChar))
                }
            }
        }
        return expr
    }

    fn strip_optional_from_type(mut this, anon type_id: TypeId) throws -> TypeId => match .get_type(type_id) {
        GenericInstance(id, args) => {
            if id.equals(.find_struct_in_prelude(name: "Optional")) {
                return args[0]
            }
            yield type_id
        }
        else => type_id
    }

    fn final_type_resolution_form(this, anon type_id: TypeId, anon scope_id: ScopeId) throws -> TypeId {
        let mapped_type_id = .resolve_type_var(type_var_type_id: type_id, scope_id)
        if .get_type(mapped_type_id) is Self and .self_type_id.has_value() {
            return .self_type_id!
        }

        return mapped_type_id
    }

    fn struct_like_id_from_type_id(
        mut this
        type_id: TypeId
        scope_id: ScopeId
        span: Span
        for_optional_chain: bool = false
        treat_string_as_builtin: bool = false
    ) throws -> (StructLikeId?, bool) {
        let type = .get_type(type_id)
        mut found_optional = false
        let parent_id: StructLikeId? = match type {
            Struct(id) => Some(StructLikeId::Struct(id))
            Enum(id) => Some(StructLikeId::Enum(id))
            JaktString => match treat_string_as_builtin {
                true => StructLikeId::Struct(.program.builtin_implementation_struct(
                    builtin: type.as_builtin_type()
                    for_module: .program.prelude_module_id()
                ))
                false => Some(StructLikeId::Struct(.find_struct_in_prelude("String")))
            }
            GenericInstance(id, args) => {
                yield match for_optional_chain {
                    true => {
                        let optional_struct_id = .find_struct_in_prelude("Optional")
                        mut struct_id: StructLikeId? = None
                        if not id.equals(optional_struct_id) {
                            .error(
                                format("Can't use ‘{}’ as an optional type in optional chained call", .get_struct(id).name)
                                span
                            )
                        } else {
                            found_optional = true
                            struct_id = match .get_type(args[0]) {
                                Struct(struct_id) | GenericInstance(id: struct_id) => StructLikeId::Struct(struct_id)
                                Enum(id) | GenericEnumInstance(id) => StructLikeId::Enum(id)
                                else => {
                                    .error("Can't use non-struct type as an optional type in optional chained call", span)
                                    found_optional = false
                                    yield StructLikeId::Struct(optional_struct_id)
                                }
                            }
                        }

                        yield Some(struct_id ?? StructLikeId::Struct(optional_struct_id))
                    }
                    false => Some(StructLikeId::Struct(generic_arguments: args, id))
                }
            }
            GenericEnumInstance(id, args) => Some(StructLikeId::Enum(generic_arguments: args, id))
            Trait(id) => Some(StructLikeId::Trait(id))
            GenericTraitInstance(id, args) => Some(StructLikeId::Trait(generic_arguments: args, id))
            TypeVariable(trait_implementations) => match trait_implementations.size() {
                0 => None
                // FIXME: Use all of the bounds instead of just the first one.
                else => match .get_type(trait_implementations[0]) {
                    Trait(id) => Some(StructLikeId::Trait(id))
                    GenericTraitInstance(id, args) => Some(StructLikeId::Trait(generic_arguments: args, id))
                    else => None
                }
            }
            else => match type.is_builtin() {
                true => StructLikeId::Struct(.program.builtin_implementation_struct(
                    builtin: type.as_builtin_type()
                    for_module: .program.prelude_module_id()
                ))
                else => {
                    .error(
                        message: format(
                            "no methods available on value (type: {} {})"
                            .get_type(type_id).constructor_name()
                            .type_name(type_id)
                        )
                        span
                    )

                    yield None
                }
            }
        }

        return (parent_id, found_optional)
    }

    fn typecheck_expression(
        mut this
        anon expr: ParsedExpression
        scope_id: ScopeId
        safety_mode: SafetyMode
        type_hint: TypeId?
    ) throws -> CheckedExpression => match expr {
        IndexedStruct(expr, field_name, span, is_optional) => .typecheck_indexed_struct(expr, field_name, scope_id, is_optional, safety_mode, span)
        ComptimeIndex(expr, index, span, is_optional) => .typecheck_comptime_index(expr, index, scope_id, is_optional, safety_mode, span)
        Boolean(val, span) => {
            .unify_with_type(found_type: builtin(BuiltinType::Bool), expected_type: type_hint, span)
            yield CheckedExpression::Boolean(val, span)
        }
        NumericConstant(val, span) => {
            mut type_hint_unwrapped = type_hint
            if type_hint.has_value() and .get_type(type_hint!) is GenericInstance(id, args) {
                let optional_struct_id = .find_struct_in_prelude("Optional")
                if id.equals(optional_struct_id) {
                    type_hint_unwrapped = args[0]
                }
            }

            yield match val {
                I8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(val), span, type_id: builtin(BuiltinType::I8))
                I16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(val), span, type_id: builtin(BuiltinType::I16))
                I32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(val), span, type_id: builtin(BuiltinType::I32))
                I64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(val), span, type_id: builtin(BuiltinType::I64))
                U8(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(val), span, type_id: builtin(BuiltinType::U8))
                U16(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(val), span, type_id: builtin(BuiltinType::U16))
                U32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(val), span, type_id: builtin(BuiltinType::U32))
                U64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(val), span, type_id: builtin(BuiltinType::U64))
                USize(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(val), span, type_id: builtin(BuiltinType::Usize))
                F32(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F32(val), span, type_id: builtin(BuiltinType::F32))
                F64(val) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F64(val), span, type_id: builtin(BuiltinType::F64))
                UnknownSigned(val) => .infer_signed_int(val, span, type_hint: type_hint_unwrapped)
                UnknownUnsigned(val) => .infer_unsigned_int(val, span, type_hint: type_hint_unwrapped)
            }
        }
        SingleQuotedString(val, prefix, span) => match prefix ?? "" {
            "" => CheckedExpression::CharacterConstant(val, span)
            "b" => CheckedExpression::ByteConstant(val, span)
            "c" => CheckedExpression::CCharacterConstant(val, span)
            else => {
                .compiler.panic(format("Unknown string prefix {}", prefix))
            }
        }
        QuotedString(val, span) => {
            yield match type_hint.has_value() and not type_hint!.equals(unknown_type_id()) {
                true => {
                    mut type_id = .strip_optional_from_type(.generic_inferences.map(type_hint!))
                    let prelude_string_type_id = .prelude_struct_type_named("String")
                    let prelude_string_view_type_id = .prelude_struct_type_named("StringView")
                    mut may_throw = false
                    if not type_id.equals(prelude_string_type_id) and not type_id.equals(prelude_string_view_type_id) {
                        if .get_type(type_id).is_concrete() {
                            let trait_implementation = .find_any_singular_trait_implementation(
                                type_id
                                trait_names: ["FromStringLiteral", "ThrowingFromStringLiteral"]
                                scope_id
                                span
                            )
                            if not trait_implementation.has_value() {
                                .error_with_hint(
                                    format("Type {} cannot be used as an overloaded string literal type", .type_name(type_id, debug_mode: true)),
                                    span,
                                    format("Consider implementing the FromStringLiteral trait for {}", .type_name(type_id)),
                                    span
                                )
                                type_id = prelude_string_type_id
                            } else {
                                may_throw = trait_implementation!.trait_name == "ThrowingFromStringLiteral"
                            }
                        } else if not .get_type(type_id).is_concrete() {
                            type_id = .prelude_struct_type_named("String")
                        }
                    }

                    .unify(
                        lhs: type_hint!
                        lhs_span: span
                        rhs: type_id
                        rhs_span: span
                    )

                    if may_throw and not .get_scope(scope_id).can_throw {
                        .error("Operation that may throw needs to be in a try statement or a function marked as throws", span)
                    }

                    yield CheckedExpression::QuotedString(
                        val: CheckedStringLiteral(
                            value: StringLiteral::Static(val)
                            type_id
                            may_throw
                        )
                        span
                    )
                }
                else => {
                    yield CheckedExpression::QuotedString(
                        val: CheckedStringLiteral(
                            value: StringLiteral::Static(val)
                            type_id: .prelude_struct_type_named("String")
                            may_throw: false
                        )
                        span
                    )
                }
            }
        }
        Call(call, span) => {
            yield .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: None, parent_id: None, safety_mode, type_hint, must_be_enum_constructor: false)
        }
        MethodCall(expr, call, span, is_optional) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            let checked_expr_type_id = checked_expr.type()

            let final_type_id = .final_type_resolution_form(checked_expr_type_id, scope_id)
            let type = .get_type(final_type_id)
            let (parent_id, found_optional) = .struct_like_id_from_type_id(
                type_id: final_type_id
                scope_id
                span
                for_optional_chain: is_optional
            )

            if is_optional and not found_optional {
                .error(message: format("Optional chain mismatch: expected optional chain, found {}", .type_name(type_id: checked_expr_type_id)), span: checked_expr.span())
            }

            let checked_call_expr = .typecheck_call(call, caller_scope_id: scope_id, span, this_expr: checked_expr, parent_id, safety_mode, type_hint, must_be_enum_constructor: false)
            let type_id = checked_call_expr.type()
            yield match checked_call_expr {
                Call(call) => {
                    mut result_type = call.return_type
                    if is_optional {
                        let optional_struct_id = .find_struct_in_prelude("Optional")
                        result_type = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [result_type]))
                    }
                    yield CheckedExpression::MethodCall(
                        expr: checked_expr
                        call
                        span
                        is_optional
                        type_id: result_type)
                }
                else => {
                    .compiler.panic("typecheck_call should return `CheckedExpression::Call()`")
                }
            }
        }
        Range(from, to, span) => {
            mut checked_from: CheckedExpression? = None
            mut from_type: TypeId? = None;
            mut from_span = span

            if from.has_value() and not from! is NumericConstant(val: UnknownSigned) and not from! is NumericConstant(val: UnknownUnsigned) {
                checked_from = .typecheck_expression(from!, scope_id, safety_mode, type_hint: None)
                from_type = checked_from!.type()
                from_span = checked_from!.span()
            }

            mut checked_to: CheckedExpression? = None
            mut to_type = unknown_type_id();
            mut to_span = span

            if to.has_value() {
                checked_to = .typecheck_expression(to!, scope_id, safety_mode, type_hint: from_type)
                to_type = checked_to!.type()
                to_span = checked_to!.span()
            }

            if from.has_value() and (from! is NumericConstant(val: UnknownSigned) or from! is NumericConstant(val: UnknownUnsigned)) {
                // recheck the first value with the hint we get from the rhs
                checked_from = .typecheck_expression(from!, scope_id, safety_mode, type_hint: to_type)
                from_type = checked_from!.type()
                from_span = checked_from!.span()
            }

            mut values_type_id: TypeId? = None
            if from.has_value() and to.has_value() {
                values_type_id = .unify(lhs: from_type!, lhs_span: from_span, rhs: to_type, rhs_span: from_span)
                if not values_type_id.has_value() {
                    .error("Range values differ in types", span)
                }
            } else if from.has_value() {
                values_type_id = from_type
            } else if to.has_value() {
                values_type_id = to_type
            }

            let range_struct_id = .find_struct_in_prelude("Range")
            let range_type = Type::GenericInstance(
                id: range_struct_id,
                args: [values_type_id.value_or(builtin(BuiltinType::I64))]
            )

            let type_id = .find_or_add_type_id(range_type)

            yield CheckedExpression::Range(from: checked_from, to: checked_to, span, type_id)
        }
        Reflect(type, span) => {
            let reflected_type_enum_id = match .program.find_reflected_primitive(primitive: "Type") {
                Enum(id) => id
                else => {
                    .compiler.panic("unreachable")
                }
            }

            let reflected_type = .typecheck_typename(parsed_type: type, scope_id, name: None)
            yield CheckedExpression::Reflect(
                type: reflected_type
                span
                type_id: .find_or_add_type_id(Type::Enum(reflected_type_enum_id)))
        }
        UnaryOp(expr, op, span) => {
            let checked_expr = match op {
                Dereference => .typecheck_expression(expr, scope_id, safety_mode, type_hint: None)
                Negate => .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint, span)
                else => .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            }

            let checked_op = match op {
                PreIncrement => CheckedUnaryOperator::PreIncrement
                PostIncrement => CheckedUnaryOperator::PostIncrement
                PreDecrement => CheckedUnaryOperator::PreDecrement
                PostDecrement => CheckedUnaryOperator::PostDecrement
                Negate => CheckedUnaryOperator::Negate
                Dereference => CheckedUnaryOperator::Dereference
                RawAddress => CheckedUnaryOperator::RawAddress
                Reference => CheckedUnaryOperator::Reference
                MutableReference => CheckedUnaryOperator::MutableReference
                LogicalNot => CheckedUnaryOperator::LogicalNot
                BitwiseNot => CheckedUnaryOperator::BitwiseNot
                TypeCast(cast) => {
                    let type_id = .typecheck_typename(parsed_type: cast.parsed_type(), scope_id, name: None)
                    let checked_cast = match cast {
                        Fallible => {
                            let optional_struct_id = .find_struct_in_prelude("Optional")
                            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
                            let optional_type_id = .find_or_add_type_id(optional_type)
                            yield CheckedTypeCast::Fallible(optional_type_id)
                        }
                        Infallible => CheckedTypeCast::Infallible(type_id)
                    }
                    yield CheckedUnaryOperator::TypeCast(checked_cast)
                }
                Sizeof(unchecked_type) => {
                    let type_id = .typecheck_typename(parsed_type: unchecked_type, scope_id, name: None)
                    yield CheckedUnaryOperator::Sizeof(type_id)
                }
                Is(unchecked_type) => {
                    let old_ignore_errors = .ignore_errors
                    .ignore_errors = true
                    let type_id = .typecheck_typename(parsed_type: unchecked_type, scope_id, name: None)
                    .ignore_errors = old_ignore_errors
                    .had_an_error = false

                    mut operator_is = CheckedUnaryOperator::Is(type_id)
                    if unchecked_type is Name(name) {
                        // Let's assume it's an enum variant
                        let expr_type_id = checked_expr.type()
                        if .get_type(expr_type_id) is Enum(enum_id) {
                            let enum_ = .get_enum(enum_id)
                            mut exists = false
                            for variant in enum_.variants {
                                exists = match variant {
                                    StructLike(name: var_name)
                                    | Typed(name: var_name)
                                    | Untyped(name: var_name)
                                    | WithValue(name: var_name) => var_name == name
                                }
                                if exists {
                                    operator_is = CheckedUnaryOperator::IsEnumVariant(
                                        enum_variant: variant,
                                        bindings: [],
                                        type_id: expr_type_id
                                    )
                                    break
                                }
                            }
                            if not exists and type_id.equals(unknown_type_id()) {
                                .error(
                                    format("Enum variant {} does not exist on {}", name, .type_name(expr_type_id)),
                                    span
                                )
                            }
                        } else if name == "Some" or name == "None" {
                            let optional_struct_id = .find_struct_in_prelude("Optional")
                            let checked_expr_type = .get_type(checked_expr.type())

                            if not checked_expr_type is GenericInstance(id: optional_struct_id) {
                                .error(
                                    format(
                                        "The left-hand side of an `is {}` statement must have a {} variant",
                                        name,
                                        name
                                    ),
                                    checked_expr.span()
                                )
                            }

                            operator_is = match name {
                                "Some" => CheckedUnaryOperator::IsSome
                                "None" => CheckedUnaryOperator::IsNone
                                else => { panic("unreachable") }
                            }
                        } else if type_id.equals(unknown_type_id()) {
                            .error(format("Unknown type or invalid type name: {}", name), span)
                        }
                    } else {
                        .error("The right-hand side of an `is` operator must be a type name or enum variant", span)
                    }

                    yield operator_is
                }
                IsEnumVariant(inner, bindings) => .typecheck_is_enum_variant(checked_expr, inner, bindings, scope_id)
            }
            yield .typecheck_unary_operation(checked_expr, checked_op, span, scope_id, safety_mode)
        }
        BinaryOp(lhs, op, rhs, span) => {
            mut original_checked_lhs: CheckedExpression? = None
            mut original_checked_rhs: CheckedExpression? = None
            mut checked_lhs: CheckedExpression? = None
            mut checked_rhs: CheckedExpression? = None
            if lhs is NumericConstant(val) and (val is UnknownSigned or val is UnknownUnsigned) {
                // If we have a constant on the lhs, infer starting the the right:
                original_checked_rhs = .typecheck_expression(rhs, scope_id, safety_mode, type_hint: None)
                checked_rhs = .dereference_if_needed(original_checked_rhs!, span)
                let hint = checked_rhs!.type()

                original_checked_lhs = .typecheck_expression(lhs, scope_id, safety_mode, type_hint: hint)
                checked_lhs = .dereference_if_needed(original_checked_lhs!, span)
            } else {
                original_checked_lhs = .typecheck_expression(lhs, scope_id, safety_mode, type_hint: None)
                checked_lhs = .dereference_if_needed(original_checked_lhs!, span)
                let hint = checked_lhs!.type()

                original_checked_rhs = .typecheck_expression(rhs, scope_id, safety_mode, type_hint: hint)
                checked_rhs = .dereference_if_needed(original_checked_rhs!, span)
            }

            if .type_contains_reference(type_id: original_checked_lhs!.type())
                and rhs is UnaryOp(op)
                and (op is Reference or op is MutableReference) {

                .error_with_hint(
                    "Attempt to rebind a reference will result in write-through"
                    span
                    "This reference will be immediately dereferenced and then assigned"
                    rhs.span()
                )
            }

            let (checked_operator, output_type) = .typecheck_binary_operation(
                checked_lhs: checked_lhs!
                op
                checked_rhs: checked_rhs!
                scope_id
                span
            )

            yield CheckedExpression::BinaryOp(lhs: checked_lhs!, op: checked_operator, rhs: checked_rhs!, span, type_id: output_type)
        }
        OptionalNone(span) => {
            mut type_hint_unwrapped = type_hint
            if type_hint.has_value() and .get_type(type_hint!) is GenericInstance(id, args) {
                let optional_struct_id = .find_struct_in_prelude("Optional")
                if id.equals(optional_struct_id) {
                    type_hint_unwrapped = args[0]
                }
            }

            yield CheckedExpression::OptionalNone(span, type_id: type_hint_unwrapped ?? unknown_type_id())
        }
        OptionalSome(expr, span) => {
            let checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: None)
            let type_id = checked_expr.type()
            let optional_struct_id = .find_struct_in_prelude("Optional")
            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [type_id])
            let optional_type_id = .find_or_add_type_id(optional_type)
            yield CheckedExpression::OptionalSome(expr: checked_expr, span, type_id: optional_type_id)
        }
        Var(name, span) => {
            let var = .find_var_in_scope(scope_id, var: name)
            return match var.has_value() { // FIXME: this wants to be a match on Optional instead of boolean
                true => CheckedExpression::Var(var: var!, span)
                else => {
                    .error(format("Variable '{}' not found", name), span)
                    yield CheckedExpression::Var(
                        var: CheckedVariable(
                            name,
                            type_id: type_hint.value_or(unknown_type_id()),
                            is_mutable: false,
                            definition_span: span,
                            type_span: None
                            visibility: CheckedVisibility::Public),
                        span
                    )
                }
            }
        }
        ForcedUnwrap(expr, span) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
            let type = .get_type(checked_expr.type())

            let optional_struct_id = .find_struct_in_prelude("Optional")
            let weakptr_struct_id = .find_struct_in_prelude("WeakPtr")

            let type_id: TypeId = match type {
                GenericInstance(id, args) => {
                    mut inner_type_id = unknown_type_id()
                    if  id.equals(optional_struct_id) or id.equals(weakptr_struct_id) {
                        inner_type_id = args[0]
                    } else {
                        .error("Forced unwrap only works on Optional", span)
                    }
                    yield inner_type_id
                }
                else => {
                    .error("Forced unwrap only works on Optional", span)
                    yield unknown_type_id()
                }
            }

            yield CheckedExpression::ForcedUnwrap(expr: checked_expr, span, type_id)
        }
        JaktArray(values, fill_size, span) => .typecheck_array(scope_id, values, fill_size, span, safety_mode, type_hint)
        JaktTuple(values, span) => {
            let VOID_TYPE_ID = builtin(BuiltinType::Void)
            mut checked_values: [CheckedExpression] = []
            mut checked_types: [TypeId] = []

            let optional_struct_id = .find_struct_in_prelude("Optional")

            for value in values {
                let checked_value = .typecheck_expression(value, scope_id, safety_mode, type_hint: None)
                let type_id = checked_value.type()
                if type_id.equals(VOID_TYPE_ID) {
                    .error("Cannot create a tuple that contains a value of type void", value.span())
                }
                checked_types.push(type_id)
                checked_values.push(checked_value)
            }

            // if a type is Optional wrap the value in Some() if it isn't already
            if type_hint.has_value() and .get_type(type_hint!) is GenericInstance(id, args) and checked_types.size() == args.size() {
                for i in 0..args.size() {
                    mut value_type = checked_types[i]
                    let unified = .unify(lhs: args[i], lhs_span: span, rhs: value_type, rhs_span: span)
                    if unified.has_value() {
                        mut type_optional = false
                        if .get_type(unified!) is GenericInstance(id) and id.equals(optional_struct_id) {
                            type_optional = true
                        }

                        mut value_optional = false
                        if .get_type(value_type) is GenericInstance(id) and id.equals(optional_struct_id) {
                            value_optional = true
                        }

                        checked_types[i] = unified!

                        if type_optional and not value_optional and not checked_values[i] is OptionalSome {
                            if checked_values[i] is OptionalNone and .get_type(unified!) is GenericInstance(id, args) {
                                value_type = args[0]
                            }

                            let optional_type = Type::GenericInstance(id: optional_struct_id, args: [value_type])
                            let optional_type_id = .find_or_add_type_id(optional_type)
                            checked_values[i] = CheckedExpression::OptionalSome(expr: checked_values[i], span, type_id: optional_type_id)
                        }
                    }
                }
            }

            let tuple_struct_id = .find_struct_in_prelude("Tuple")
            let type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: checked_types))

            if type_hint.has_value() {
                .check_types_for_compat(
                    lhs_type_id: type_hint!
                    rhs_type_id: type_id
                    generic_inferences: &mut .generic_inferences
                    span
                )
            }

            yield CheckedExpression::JaktTuple(vals: checked_values, span, type_id)
        }
        IndexedExpression(base, index, span) => {
            let checked_base = .typecheck_expression_and_dereference_if_needed(base, scope_id, safety_mode, type_hint: None, span)
            let checked_index = .typecheck_expression_and_dereference_if_needed(index, scope_id, safety_mode, type_hint: None, span)

            yield match .get_type(checked_base.type()) {
                GenericInstance(id, args) => {
                    let array_struct_id = .find_struct_in_prelude("Array")
                    let array_slice_struct_id = .find_struct_in_prelude("ArraySlice")
                    let dictionary_struct_id = .find_struct_in_prelude("Dictionary")

                    mut result = CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
                    if id.equals(array_struct_id) or id.equals(array_slice_struct_id) {
                        if .is_integer(checked_index.type()) or checked_index is Range {
                            let type_id = match checked_index {
                                Range => {
                                    let array_slice_struct_id = .find_struct_in_prelude("ArraySlice")

                                    yield .find_or_add_type_id(Type::GenericInstance(id: array_slice_struct_id, args))
                                } else => args[0]
                            }

                            result = CheckedExpression::IndexedExpression(expr: checked_base, index: checked_index, span, type_id: type_id)
                        } else {
                            .error("Index must be an integer or a range", span)
                        }
                    } else if id.equals(dictionary_struct_id) {
                        result = CheckedExpression::IndexedDictionary(expr: checked_base, index: checked_index, span, type_id: args[1])
                    }
                    yield result
                }
                else => {
                    .error("Index used on value that cannot be indexed", span)
                    yield CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
                }
            }
        }
        IndexedTuple(expr, index, is_optional, span) => .typecheck_indexed_tuple(expr, index, scope_id, is_optional, safety_mode, span)
        Garbage(span) => CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
        NamespacedVar(name, namespace_, span) => .typecheck_namespaced_var_or_simple_enum_constructor_call(name, namespace_, scope_id, safety_mode, type_hint, span)
        Match(expr, cases, marker_span) => .typecheck_match(expr, cases, span: marker_span, scope_id, safety_mode, type_hint)
        EnumVariantArg(expr: inner_expr, arg, enum_variant, span) => {
            let checked_expr = .typecheck_expression_and_dereference_if_needed(inner_expr, scope_id, safety_mode, type_hint: None, span)
            mut checked_binding = CheckedEnumVariantBinding(name: "", binding: "", type_id: unknown_type_id(), span)
            mut checked_enum_variant: CheckedEnumVariant? = None
            match enum_variant {
                NamespacedName(name: variant_name, span) | Name(name: variant_name, span) => match .get_type(checked_expr.type()) {
                    Type::Enum(enum_id) => {
                        let enum_ = .get_enum(enum_id)
                        let variant = .get_enum_variant(enum_, variant_name)
                        if variant.has_value() {
                            checked_enum_variant = variant
                            let checked_bindings = .typecheck_enum_variant_bindings(variant: variant!, bindings: [arg], span)
                            if checked_bindings.has_value() {
                                let bindings = checked_bindings!
                                checked_binding = bindings[0]
                            }
                        } else {
                            .error(format("Enum variant {} does not exist", variant_name), span)
                        }
                    }
                    else => {
                        .error(format("Unknown type or invalid type name: {}", variant_name), span)
                    }
                }
                else => {}
            }
            mut output = CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
            if checked_enum_variant.has_value() {
                output = CheckedExpression::EnumVariantArg(expr: checked_expr, arg: checked_binding, enum_variant: checked_enum_variant!, span)
            }
            yield output
        }
        JaktDictionary(values, span) => .typecheck_dictionary(values, span, scope_id, safety_mode, type_hint)
        Set(values, span) => .typecheck_set(values, span, scope_id, safety_mode, type_hint)
        Function(captures, params, can_throw, is_fat_arrow, return_type, block, span) => .typecheck_lambda(captures, params, can_throw, is_fat_arrow, return_type, block, span, scope_id, safety_mode)
        Try(expr, catch_block, catch_span, catch_name, span) => .typecheck_try(expr, catch_block, catch_span, catch_name, scope_id, safety_mode, span, type_hint)
        TryBlock(stmt, catch_block, error_name, error_span, span) => .typecheck_try_block(stmt, error_name, error_span, catch_block, scope_id, safety_mode, span)
        Unsafe(expr) => .typecheck_expression(expr, scope_id, safety_mode: SafetyMode::Unsafe, type_hint)
        Operator => {
            .compiler.panic("idk how to handle this thing")
        }
    }

    fn typecheck_is_enum_variant(mut this, checked_expr: CheckedExpression, inner: ParsedType, bindings: [EnumVariantPatternArgument], scope_id: ScopeId) throws -> CheckedUnaryOperator {
        let old_ignore_errors = .ignore_errors
        .ignore_errors = true
        let type_id = .typecheck_typename(parsed_type: inner, scope_id, name: None)
        .ignore_errors = old_ignore_errors
        .had_an_error = false

        mut checked_op = CheckedUnaryOperator::Is(type_id)
        let expr_type_id = checked_expr.type()
        match inner {
            NamespacedName(name: variant_name, span) | Name(name: variant_name, span) => {
                guard .get_type(expr_type_id) is Enum(enum_id) else {
                    .error(format("Unknown type or invalid type name: {}", variant_name), span)
                    return checked_op
                }
                let enum_ = .get_enum(enum_id)
                let variant = .get_enum_variant(enum_, variant_name)
                guard variant.has_value() else {
                    .error(format("Enum variant {} does not exist on {}", variant_name, .type_name(type_id)), span)
                    return checked_op
                }
                let checked_enum_variant_bindings = .typecheck_enum_variant_bindings(variant: variant!, bindings, span)
                checked_op = CheckedUnaryOperator::IsEnumVariant(
                    enum_variant: variant!,
                    bindings: checked_enum_variant_bindings!,
                    type_id: expr_type_id
                )
            }
            else => {}
        }
        return checked_op
    }

    fn get_enum_variant(mut this, enum_: CheckedEnum, variant_name: String) -> CheckedEnumVariant? {
        for variant in enum_.variants {
            if variant.name() == variant_name {
                return variant
            }
        }
        return None
    }

    fn typecheck_enum_variant_bindings(mut this, variant: CheckedEnumVariant, bindings: [EnumVariantPatternArgument], span: Span) throws -> [CheckedEnumVariantBinding]? {
        if variant is Typed(type_id) {
            if bindings.size() != 1 {
                .error(format("Enum variant ‘{}’ must have exactly one argument", variant.name()), span)
                return None
            }
            if .dump_type_hints {
                .dump_type_hint(type_id, span: bindings[0].span)
            }
            return [CheckedEnumVariantBinding(name: None, binding: bindings[0].binding, type_id, span)]
        }

        guard variant is StructLike(fields) else {
            return None
        }
        mut checked_vars: [CheckedVariable] = []
        mut checked_enum_variant_bindings: [CheckedEnumVariantBinding] = []
        for field in fields {
            checked_vars.push(.get_variable(field))
        }
        for binding in bindings {
            mut found = false
            for var in checked_vars {
                let binding_name = binding.name ?? binding.binding
                let type_id = var.type_id
                if binding_name == var.name {
                    if .dump_type_hints {
                        .dump_type_hint(type_id, span: binding.span)
                    }
                    checked_enum_variant_bindings.push(CheckedEnumVariantBinding(name: binding.name, binding: binding.binding, type_id, span))
                    found = true
                    break
                }
            }
            if not found {
                .error(
                    format(
                        "Enum variant ‘{}’ doesn't have field with name ‘{}’"
                        variant.name()
                        binding.name_in_enum()
                    )
                    binding.name_in_enum_span()
                )
            }
        }
        if checked_enum_variant_bindings.size() > 0 {
            return checked_enum_variant_bindings
        }
        return None
    }

    fn typecheck_lambda(
        mut this
        captures: [ParsedCapture]
        params: [ParsedParameter]
        can_throw: bool
        is_fat_arrow: bool
        return_type: ParsedType
        block: ParsedBlock
        span: Span
        scope_id: ScopeId
        safety_mode: SafetyMode
    ) throws -> CheckedExpression {
        let synthetic_type = ParsedType::Function(
            params
            can_throw
            return_type
            span
        )

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        mut type_id = .typecheck_typename(parsed_type: synthetic_type, scope_id, name: None)
        mut (return_type_id, pseudo_function_id) = match .get_type(type_id) {
            Function(return_type_id, pseudo_function_id) => (return_type_id, pseudo_function_id)
            else => {
                .compiler.panic("Expected the just-checked function to be of a function type")
            }
        }

        mut module = .current_module()

        mut effective_namespace_parent_scope_id = scope_id
        mut effective_namespace_parent_scope = .get_scope(scope_id)
        while effective_namespace_parent_scope.is_block_scope {
            effective_namespace_parent_scope_id = effective_namespace_parent_scope.parent!
            effective_namespace_parent_scope = .get_scope(effective_namespace_parent_scope_id)
        }

        mut lambda_scope_id = .create_scope(parent_scope_id: effective_namespace_parent_scope_id, can_throw, debug_name: "lambda")
        mut is_capturing_everything = false
        mut checked_captures: [CheckedCapture] = []
        mut has_dependent_capture = false
        for capture in captures {
            if capture is AllByReference {
                checked_captures.push(CheckedCapture::AllByReference(name: "", span: capture.span))
                if not is_capturing_everything {
                    is_capturing_everything = true
                    // Switch the lambda scope to point to the local block instead.
                    lambda_scope_id = .create_scope(parent_scope_id: scope_id, can_throw, debug_name: "lambda")
                }
            } else if .find_var_in_scope(scope_id, var: capture.name).has_value() {
                let name = capture.name
                let span = capture.span
                checked_captures.push(match capture {
                    ByValue => CheckedCapture::ByValue(name, span)
                    ByReference => CheckedCapture::ByReference(name, span)
                    ByMutableReference => CheckedCapture::ByMutableReference(name, span)
                    ByComptimeDependency => {
                        has_dependent_capture = true
                        if not .in_comptime_function_call {
                            .error(
                                format("Comptime dependency capture ‘{}’ is only allowed in comptime function calls", name),
                                span
                            )
                        }
                        yield CheckedCapture::ByComptimeDependency(name, span)
                    }
                    AllByReference => {
                        .compiler.panic("AllByReference capture should not be looked up by name")
                    }
                })
                if not is_capturing_everything {
                    let var = .find_var_in_scope(scope_id, var: capture.name)!
                    let is_this = var.name == "this"
                    let var_id = module.add_variable(CheckedVariable(
                        name
                        type_id: var.type_id
                        is_mutable: var.is_mutable and (is_this or capture is ByReference or capture is ByMutableReference)
                        definition_span: var.definition_span
                        type_span: var.type_span
                        visibility: var.visibility
                        owner_scope: var.owner_scope
                    ))
                    .add_var_to_scope(scope_id: lambda_scope_id, name, var_id, span)
                }
            } else {
                .error(format("Variable '{}' not found", capture.name), span)
            }
        }

        // if we're not capturing everything, transfer over the types from the parent scopes
        if not is_capturing_everything {
            mut current_scope_id = scope_id
            mut lambda_scope = .get_scope(lambda_scope_id)
            while not current_scope_id.equals(effective_namespace_parent_scope_id) {
                let current_scope = .get_scope(current_scope_id)
                lambda_scope.resolution_mixins.push(current_scope_id)
                current_scope_id = current_scope.parent!
            }
        }

        mut checked_params: [CheckedParameter] = []
        mut first = true
        for param in params {
            let checked_param = .typecheck_parameter(parameter: param, scope_id, first, this_arg_type_id: None, check_scope: None)
            checked_params.push(checked_param)
            let var_id = module.add_variable(checked_param.variable)
            .add_var_to_scope(scope_id: lambda_scope_id, name: checked_param.variable.name, var_id, span: checked_param.variable.definition_span)

            first = false
        }

        let previous_function_id = .current_function_id
        .current_function_id = pseudo_function_id
        defer {
            .current_function_id = previous_function_id
        }

        if has_dependent_capture {
            return CheckedExpression::DependentFunction(
                captures: checked_captures
                params: checked_params
                can_throw
                return_type_id
                block: block
                span
                type_id
                pseudo_function_id
                scope_id: lambda_scope_id
            )
        }

        let checked_block = .typecheck_block(parsed_block: block, parent_scope_id: lambda_scope_id, safety_mode)

        if return_type_id.equals(unknown_type_id()) {
            mut return_type_updated = false
            if not is_fat_arrow and return_type is Empty {
                return_type_id = void_type_id()
                return_type_updated = true
            } else if is_fat_arrow and
                not checked_block.statements.is_empty() and
                checked_block.statements.last()! is Return(val) and
                val.has_value() {
                return_type_id = .resolve_type_var(type_var_type_id: val!.type(), scope_id: lambda_scope_id)
                return_type_updated = true
            }

            if return_type_updated {
                type_id = match .get_type(type_id) {
                    Function(params, can_throw, pseudo_function_id) => .find_or_add_type_id(Type::Function(
                        params
                        can_throw
                        return_type_id
                        pseudo_function_id
                    ))
                    else => {
                        .compiler.panic("Expected the just-checked function to be of a function type")
                    }
                }
            }
        }

        return CheckedExpression::Function(
            captures: checked_captures
            params: checked_params
            can_throw
            return_type_id
            block: checked_block
            span
            type_id
            pseudo_function_id
            scope_id: lambda_scope_id
        )
    }

    fn typecheck_namespaced_var_or_simple_enum_constructor_call(
        mut this
        name: String
        namespace_: [String]
        scope_id: ScopeId
        safety_mode: SafetyMode
        type_hint: TypeId?
        span: Span
    ) throws -> CheckedExpression {
        mut scopes = [scope_id]
        for ns in namespace_ {
            let scope = scopes[scopes.size() - 1]
            let ns_in_scope = .find_namespace_in_scope(scope_id: scope, name: ns)
            let enum_in_scope = .program.find_enum_in_scope(scope_id: scope, name: ns)
            mut next_scope = scope
            if ns_in_scope.has_value() {
                next_scope = ns_in_scope!.0
            } else if enum_in_scope.has_value() {
                next_scope = .get_enum(enum_in_scope!).scope_id
            } else {
                .error(format("Namespace ‘{}’ not found", ns), span)
            }
            scopes.push(next_scope)
        }

        let scope = scopes.last()!

        mut i = 0uz
        let min_length = match scopes.size() <= namespace_.size() {
            true => scopes.size()
            else => namespace_.size()
        }
        mut checked_namespaces: [CheckedNamespace] = []
        while i < min_length {
            checked_namespaces.push(CheckedNamespace(name: namespace_[i], scope))
            i++
        }

        let var = .find_var_in_scope(scope_id: scope, var: name)
        if var.has_value() {
            return CheckedExpression::NamespacedVar(namespaces: checked_namespaces, var: var!, span)
        }

        let implicit_constructor_call = ParsedCall(namespace_, name, args: [], type_args: [])
        let call_expression = .typecheck_call(call: implicit_constructor_call, caller_scope_id: scope_id, span, this_expr: None, parent_id: None, safety_mode, type_hint, must_be_enum_constructor: true)
        let type_id = call_expression.type()
        let call = match call_expression {
            Call(call) => call
            else => {
                .compiler.panic("typecheck_call returned something other than a CheckedCall")
            }
        }
        if call.function_id.has_value() {
            return CheckedExpression::Call(call, span, type_id)
        }
        .error(format("Variable '{}' not found", name), span)
        return CheckedExpression::NamespacedVar(
            namespaces: checked_namespaces,
            var: CheckedVariable(
                name,
                type_id: unknown_type_id(),
                is_mutable: false,
                definition_span: span
                type_span: None
                visibility: CheckedVisibility::Public
            ),
            span
        )
    }

    fn typecheck_array(mut this, scope_id: ScopeId, values: [ParsedExpression], fill_size: ParsedExpression?, span: Span, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        mut repeat: CheckedExpression? = None
        if fill_size.has_value() {
            // Check fill size is an integer.
            // TODO: Check fill size is positive when possible.
            let fill_size_value = fill_size.value()
            let fill_size_checked = .typecheck_expression_and_dereference_if_needed(fill_size_value, scope_id, safety_mode, type_hint: None, span)
            let fill_size_type = fill_size_checked.type()
            if not .is_integer(fill_size_type) {
                .error(
                    format("Type '{}' is not convertible to an integer. Only integer values can be array fill size expressions.", .type_name(fill_size_type)),
                    fill_size_value.span()
                )
            }
            repeat = fill_size_checked
        }
        let array_struct_id = .find_struct_in_prelude("Array")
        mut inner_type_id = unknown_type_id()
        mut inferred_type_span: Span? = None

        mut inner_hint: TypeId? = None
        let type_hint_ids: [TypeId]? = .get_type_ids_from_type_hint_if_struct_ids_match(type_hint, expected_struct_id: array_struct_id)
        if type_hint_ids.has_value() {
            inner_hint = type_hint_ids![0]
        }

        mut vals: [CheckedExpression] = []
        for value in values {
            let checked_expr = .typecheck_expression(value, scope_id, safety_mode, type_hint: inner_hint)
            let current_value_type_id = checked_expr.type()
            if current_value_type_id.equals(void_type_id()) {
                .error("Cannot create an array with values of type void\n", span)
            }

            if inner_type_id.equals(unknown_type_id()) {
                inner_type_id = current_value_type_id
                inferred_type_span = value.span()
            } else if not inner_type_id.equals(current_value_type_id) {
                .error_with_hint(
                    format("Type '{}' does not match type '{}' of previous values in array", .type_name(current_value_type_id), .type_name(inner_type_id)),
                    value.span(),
                    format("Array was inferred to store type '{}' here", .type_name(inner_type_id))
                    inferred_type_span!
                )
            }
            vals.push(checked_expr)
        }

        if inner_type_id.equals(unknown_type_id()) {
            if inner_hint.has_value() {
                inner_type_id = inner_hint!
            } else if type_hint.has_value() and type_hint!.equals(unknown_type_id()) {
                .error("Cannot infer generic type for Array<T>", span)
            }
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [inner_type_id]))

        if type_hint.has_value() {
            .check_types_for_compat(
                lhs_type_id: type_hint!
                rhs_type_id: type_id
                generic_inferences: &mut .generic_inferences
                span
            )
        }

        return CheckedExpression::JaktArray(vals, repeat, span, type_id, inner_type_id)
    }

    fn typecheck_set(mut this, values: [ParsedExpression], span: Span, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        mut inner_type_id = unknown_type_id()
        mut inner_type_span: Span? = None
        mut output: [CheckedExpression] = []

        let set_struct_id = .find_struct_in_prelude("Set")

        mut inner_hint: TypeId? = None
        let type_hint_ids: [TypeId]? = .get_type_ids_from_type_hint_if_struct_ids_match(type_hint, expected_struct_id: set_struct_id)
        if type_hint_ids.has_value() {
            inner_hint = type_hint_ids![0]
        }

        for value in values {
            let checked_value = .typecheck_expression(expr: value, scope_id, safety_mode, type_hint: inner_hint)
            let current_value_type_id = checked_value.type()
            if inner_type_id.equals(unknown_type_id()) {
                if current_value_type_id.equals(void_type_id()) or current_value_type_id.equals(unknown_type_id()) {
                    .error(
                        "Cannot create a set with values of type void"
                        value.span()
                    )
                }

                inner_type_id = current_value_type_id
                inner_type_span = value.span()
            } else if not inner_type_id.equals(current_value_type_id) {
                let set_type_name = .type_name(inner_type_id)
                .error_with_hint(
                    format(
                        "Type '{}' does not match type '{}' of previous values in set"
                        .type_name(current_value_type_id)
                        set_type_name
                    )
                    value.span()
                    format("Set was inferred to store type '{}' here", set_type_name)
                    inner_type_span!
                )
            }
            output.push(checked_value)
        }

        if inner_type_id.equals(unknown_type_id()) {
            if inner_hint.has_value() {
                inner_type_id = inner_hint!
            } else {
                .error("Cannot infer generic type for Set<T>", span)
            }
        }

        if not inner_type_id.equals(unknown_type_id()) {
            // Make sure the key implements Hashable and Equal<itself>
            .ensure_type_implements_trait(
                type_id: inner_type_id
                trait_name: "Hashable"
                scope_id
                span
            )
            .ensure_type_implements_trait(
                type_id: inner_type_id
                trait_name: "Equal"
                filter_for_generics: [inner_type_id]
                scope_id
                span
            )
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: set_struct_id
            args: [inner_type_id]
        ))

        return CheckedExpression::JaktSet(vals: output, span, type_id, inner_type_id)
    }

    fn typecheck_generic_arguments_method_call(mut this, checked_expr: CheckedExpression, call: ParsedCall, scope_id: ScopeId, span: Span, is_optional: bool, safety_mode: SafetyMode) throws -> CheckedExpression {
        mut checked_args: [(String, CheckedExpression)] = []
        checked_args.ensure_capacity(call.args.size())
        for (name, _, expr) in call.args {
            let checked_arg_expr = .typecheck_expression(
                expr
                scope_id
                safety_mode
                type_hint: None
            )
            checked_args.push((name, checked_arg_expr))
        }

        mut checked_type_args: [TypeId] = []
        for type_arg in call.type_args {
            checked_type_args.push(.typecheck_typename(parsed_type: type_arg, scope_id, name: None))
        }

        return CheckedExpression::MethodCall(
            expr: checked_expr
            call: CheckedCall(
                namespace_: []
                name: call.name
                args: checked_args
                type_args: checked_type_args
                function_id: None
                return_type: unknown_type_id()
                callee_throws: false
                external_name: None
            )
            span
            is_optional
            type_id: unknown_type_id()
        )
    }

    fn typecheck_match_variant(
        mut this
        case_: ParsedMatchCase
        subject_type_id: TypeId
        variant_index: usize
        final_result_type: TypeId?
        variant: CheckedEnumVariant
        variant_arguments: [EnumVariantPatternArgument]
        default_bindings: [String:ParsedPatternDefault]
        arguments_span: Span
        scope_id: ScopeId
        safety_mode: SafetyMode
    ) throws -> (String?, CheckedMatchCase, TypeId?) {
        mut covered_name: String? = None

        let new_scope_id = .create_scope(
            parent_scope_id: scope_id
            can_throw: .get_scope(scope_id).can_throw
            debug_name: format("catch-enum-variant({})", variant.name())
        )
        mut module = .current_module()
        match variant {
            Untyped(name) => {
                covered_name = name

                if not variant_arguments.is_empty() {
                    .error(format("Match case '{}' cannot have arguments", name), arguments_span)
                }
            }
            Typed(name, type_id, span) => {
                covered_name = name

                if not variant_arguments.is_empty() {
                    if variant_arguments.size() != 1 {
                        .error(format("Match case ‘{}’ must have exactly one argument", name), span)
                    } else {
                        let variant_argument = variant_arguments[0]
                        let variable_type_id = .substitute_typevars_in_type(
                            type_id
                            generic_inferences: .generic_inferences
                        )
                        let var_id = module.add_variable(CheckedVariable(
                            name: variant_argument.binding
                            type_id: variable_type_id
                            is_mutable: variant_argument.is_mutable
                            definition_span: span
                            type_span: None
                            visibility: CheckedVisibility::Public
                        ))
                        .add_var_to_scope(scope_id: new_scope_id, name: variant_argument.binding, var_id, span)
                    }
                }
            }
            StructLike(name, fields) => {
                covered_name = name

                mut field_variables: [CheckedVariable] = []
                for var_id in fields {
                    field_variables.push(.program.get_variable(var_id))
                }
                mut seen_names: {String} = {}
                for arg in variant_arguments {
                    if not arg.name.has_value() {
                        mut found_field_name = false
                        mut field_names: [String] = []
                        for var in field_variables {
                            field_names.push(var.name)
                            if var.name == arg.binding {
                                found_field_name = true
                            }
                        }
                        if not found_field_name {
                            mut unused_field_names: [String] = []
                            for field_name in field_names {
                                if seen_names.contains(field_name) {
                                    continue
                                }
                                unused_field_names.push(field_name)
                            }
                            .error_with_hint(
                                format("Match case argument '{}' for struct-like enum variant '{}' cannot be anon", arg.binding, name)
                                arg.span
                                format("Available arguments for '{}' are: {}\n", name, join(unused_field_names, separator: ", "))
                                arg.span
                            )
                            continue
                        }
                    }
                    let arg_name = arg.name ?? arg.binding
                    if seen_names.contains(arg_name) {
                        .error(format("Match case argument '{}' is already defined", arg_name), arg.span)
                        continue
                    }
                    seen_names.add(arg_name)
                    mut matched_field_variable: CheckedVariable? = None
                    for var in field_variables {
                        if var.name == arg_name {
                            matched_field_variable = var
                        }
                    }

                    if matched_field_variable.has_value() {
                        let substituted_type_id = .substitute_typevars_in_type(type_id: matched_field_variable!.type_id, generic_inferences: .generic_inferences)
                        let matched_span = matched_field_variable!.definition_span
                        if .dump_type_hints {
                            .dump_type_hint(type_id: matched_field_variable!.type_id, span: arg.span)
                        }

                        let var_id = module.add_variable(CheckedVariable(
                            name: arg.binding
                            type_id: substituted_type_id
                            is_mutable: arg.is_mutable
                            definition_span: matched_span
                            type_span: None
                            visibility: CheckedVisibility::Public
                        ))
                        .add_var_to_scope(scope_id: new_scope_id, name: arg.binding, var_id, span: matched_span)
                    } else {
                        .error(format("Match case argument '{}' does not exist in struct-like enum variant '{}'", arg_name, name), arg.span)
                    }
                }
            }
            WithValue(name) => {
                covered_name = name
            }
        }

        mut defaults: [CheckedStatement] = []
        for (_, default_) in default_bindings {
            let checked_var_decl = .typecheck_var_decl(
                var: default_.variable
                init: default_.value
                scope_id: new_scope_id
                safety_mode
                span: default_.variable.span
            )
            defaults.push(checked_var_decl)
        }

        let (checked_body, result_type) = .typecheck_match_body(
            body: case_.body
            scope_id: new_scope_id
            safety_mode
            generic_inferences: &mut .generic_inferences
            final_result_type
            span: case_.marker_span
        )

        let checked_match_case = CheckedMatchCase::EnumVariant(
            defaults
            name: variant.name()
            args: variant_arguments
            subject_type_id
            index: variant_index
            scope_id: new_scope_id
            body: checked_body
            marker_span: case_.marker_span
        )

        return (covered_name, checked_match_case, result_type)
    }

    fn typecheck_match(
        mut this
        expr: ParsedExpression
        cases: [ParsedMatchCase]
        span: Span
        scope_id: ScopeId
        safety_mode: SafetyMode
        type_hint: TypeId?
    ) throws -> CheckedExpression {
        let checked_expr = .typecheck_expression_and_dereference_if_needed(expr, scope_id, safety_mode, type_hint: None, span)
        let subject_type_id = checked_expr.type()
        let type_to_match_on = .get_type(subject_type_id)
        mut checked_cases: [CheckedMatchCase] = []

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer {
            .generic_inferences.restore(old_generic_inferences)
        }

        mut final_result_type: TypeId? = None
        if type_hint.has_value() and not type_hint!.equals(unknown_type_id()) and not .get_type(type_hint!) is TypeVariable {
            final_result_type = type_hint
        }

        if type_to_match_on is GenericEnumInstance(id, args) {
            let enum_ = .get_enum(id)
            for i in 0..enum_.generic_parameters.size() {
                let generic = enum_.generic_parameters[i].type_id
                let argument_type = args[i]
                if generic != argument_type {
                    .generic_inferences.set(generic, argument_type)
                }
            }
        }

        match type_to_match_on {
            Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                let enum_ = .get_enum(enum_id)
                mut seen_catch_all = false
                mut expanded_catch_all = false
                mut catch_all_span: Span? = None
                mut covered_variants: {String} = {}

                let case_count = cases.size()
                mut current_case_index = 0uz
                for case_ in cases {
                    for pattern in case_.patterns {
                        match pattern {
                            EnumVariant(variant_names, variant_arguments, arguments_span) => {
                                mut variant_names_ = variant_names

                                if variant_names_.size() == 1 {
                                    let temp = variant_names_[0]
                                    variant_names_ = [
                                        (enum_.name, variant_names_[0].1)
                                        temp
                                    ]
                                }

                                if variant_names_.is_empty() {
                                    continue
                                }

                                if variant_names_[0].0 != enum_.name {
                                    .error(format("Match case '{}' does not match enum '{}'", variant_names_[0].0, enum_.name), variant_names_[0].1)
                                    continue
                                }

                                mut i = 0uz
                                mut matched_variant: CheckedEnumVariant? = None
                                mut variant_index: usize? = None
                                for v in enum_.variants {
                                    if v.name() == variant_names_[1].0 {
                                        matched_variant = v
                                        variant_index = i
                                    }
                                    i++
                                }

                                if not matched_variant.has_value() {
                                    .error(format("Enum '{}' does not contain a variant named '{}'", enum_.name, variant_names_[1].0), case_.marker_span)

                                    return CheckedExpression::Match(expr: checked_expr, match_cases: [], span, type_id: unknown_type_id(), all_variants_constant: false)
                                }

                                let (covered_name, checked_match_case, result_type) = .typecheck_match_variant(
                                    case_
                                    subject_type_id
                                    variant_index: variant_index!
                                    final_result_type
                                    variant: matched_variant!
                                    variant_arguments
                                    default_bindings: pattern.defaults
                                    arguments_span
                                    scope_id
                                    safety_mode
                                )
                                if covered_name.has_value() {
                                    covered_variants.add(covered_name!)
                                }

                                final_result_type = result_type

                                checked_cases.push(checked_match_case)
                            }
                            CatchAll(variant_arguments, arguments_span) => {
                                if current_case_index != case_count - 1 {
                                    .error("Match else case is only allowed as the last case", case_.marker_span)
                                }

                                if seen_catch_all {
                                    .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                } else {
                                    seen_catch_all = true
                                }

                                if variant_arguments.size() > 0 {
                                    mut variant_index = 0uz
                                    for variant in enum_.variants {
                                        if not covered_variants.contains(variant.name()) {
                                            expanded_catch_all = true

                                            let (covered_name, checked_match_case, result_type) = .typecheck_match_variant(
                                                case_
                                                subject_type_id
                                                variant_index
                                                final_result_type
                                                variant
                                                variant_arguments
                                                default_bindings: pattern.defaults
                                                arguments_span
                                                scope_id
                                                safety_mode
                                            )
                                            if covered_name.has_value() {
                                                covered_variants.add(covered_name!)
                                            }

                                            final_result_type = result_type

                                            checked_cases.push(checked_match_case)
                                        }

                                        variant_index++
                                    }
                                } else {
                                    let new_scope_id = .create_scope(
                                        parent_scope_id: scope_id
                                        can_throw: .get_scope(scope_id).can_throw
                                        debug_name: "catch-all"
                                    )
                                    mut defaults: [CheckedStatement] = []
                                    for (_, default_) in pattern.defaults {
                                        let checked_var_decl = .typecheck_var_decl(
                                            var: default_.variable
                                            init: default_.value
                                            scope_id: new_scope_id
                                            safety_mode
                                            span: default_.variable.span
                                        )
                                        defaults.push(checked_var_decl)
                                    }

                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    let checked_match_case = CheckedMatchCase::CatchAll(
                                        defaults
                                        has_arguments: false
                                        body: checked_body
                                        marker_span: case_.marker_span
                                    )

                                    checked_cases.push(checked_match_case)
                                }
                            }
                            else => {}
                        }
                    }

                    current_case_index++
                }

                mut enum_variant_names: [String] = []
                mut missing_variants: [String] = []

                for variant in enum_.variants {
                    enum_variant_names.push(variant.name())
                }

                for variant in enum_variant_names {
                    if not covered_variants.contains(variant) {
                        missing_variants.push(variant)
                    }
                }

                if missing_variants.size() > 0 {
                    if not seen_catch_all {
                        .error(format("Match expression is not exhaustive, missing variants are: {}", join(missing_variants, separator: ", ")), span)
                    }
                } else if seen_catch_all and not expanded_catch_all {
                    .error("All variants are covered, but an irrefutable pattern is also present", span)
                }
            }
            Void => {
                .error("Can't match on 'void' type", checked_expr.span())
            }
            else => match type_to_match_on.is_boxed(program: .program) {
                true => {
                    let (struct_to_match_on, struct_inheritance_chain) = match type_to_match_on {
                        Struct(id) | GenericInstance(id) => (id, .struct_inheritance_chain(struct_id: id))
                        else => {
                            .compiler.panic("Expected struct or generic instance in inheritance-style match expression")
                        }
                    }
                    mut seen_catch_all = false
                    mut catch_all_matches_original_type = false
                    mut catch_all_marker_span: Span? = None
                    mut covered_cases: {StructId} = {}

                    for case_ in cases {
                        for pattern in case_.patterns {
                            match pattern {
                                EnumVariant(variant_names, variant_arguments, arguments_span) => {
                                    mut names: [String] = []
                                    for name in variant_names {
                                        names.push(name.0)
                                    }

                                    let type = .typecheck_typename(
                                        parsed_type: ParsedType::NamespacedName(
                                            name: names.last()!
                                            namespaces: names[..(names.size() - 1)].to_array()
                                            params: []
                                            span: case_.marker_span
                                        )
                                        scope_id
                                        name: None
                                    )

                                    if seen_catch_all {
                                        .error_with_hint(
                                            "This case is unreachable because a catch-all case is present before it"
                                            case_.marker_span
                                            match catch_all_matches_original_type {
                                                true => "Catch-all case matching the original subject type seen here"
                                                false => "Catch-all case seen here"
                                            }
                                            catch_all_marker_span!
                                        )
                                    }

                                    let check_cover_overlap = fn[this, &type, &case_, &covered_cases](anon id: StructId) throws {
                                        for covered_case in covered_cases {
                                            // If a supertype of this case has already been covered, then this case will never match
                                            if .struct_inherits_from(
                                                    struct_id: id
                                                    super_struct_id: covered_case
                                                ) {
                                                .error_with_hint(
                                                    format(
                                                        "Type ‘{}’ used as a match case at this position is redundant"
                                                        .type_name(type)
                                                    )
                                                    case_.marker_span
                                                    format(
                                                        "Type ‘{}’ (a supertype of ‘{}’) has been covered by a case above"
                                                        .get_struct(covered_case).name
                                                        .type_name(type)
                                                    )
                                                    case_.marker_span
                                                )
                                            }

                                        }
                                    }

                                    if type == subject_type_id {
                                        if seen_catch_all {
                                            .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                        } else {
                                            seen_catch_all = true
                                            catch_all_marker_span = case_.marker_span
                                            catch_all_matches_original_type = true
                                            check_cover_overlap(struct_to_match_on)
                                        }
                                    } else {
                                        match .get_type(type) {
                                            Struct(id) | GenericInstance(id) => {
                                                if not .struct_inherits_from(
                                                    struct_id: struct_to_match_on
                                                    super_struct_id: id
                                                    struct_inheritance_chain
                                                ) and not .struct_inherits_from(
                                                    struct_id: id
                                                    super_struct_id: struct_to_match_on
                                                ) {
                                                    .error_with_hint(
                                                        format(
                                                            "Type ‘{}’ cannot be used as a match case for ‘{}’"
                                                            .type_name(type)
                                                            .type_name(subject_type_id)
                                                        )
                                                        case_.marker_span
                                                        format(
                                                            "Neither ‘{}’ nor ‘{}’ are super types of the other"
                                                            .type_name(type)
                                                            .type_name(subject_type_id)
                                                        )
                                                        case_.marker_span
                                                    )
                                                } else {
                                                    check_cover_overlap(id)
                                                    covered_cases.add(id)
                                                }
                                            }
                                            else => {
                                                .error(
                                                    format(
                                                        "Type ‘{}’ cannot be used as a match case for ‘{}’"
                                                        .type_name(type)
                                                        .type_name(subject_type_id)
                                                    )
                                                    case_.marker_span
                                                )
                                            }
                                        }
                                    }

                                    let new_scope_id = .create_scope(
                                        parent_scope_id: scope_id
                                        can_throw: .get_scope(scope_id).can_throw
                                        debug_name: format("class-variant({})", names)
                                    )

                                    mut rebind_name: ClassInstanceRebind? = None
                                    if not variant_arguments.is_empty() {
                                        if variant_arguments.size() != 1 {
                                            .error(
                                                "Class instance matches may only have one match argument (the name to rebind to)"
                                                arguments_span
                                            )
                                        }
                                        let arg = variant_arguments[0]
                                        rebind_name = ClassInstanceRebind(
                                            name: arg.name_in_enum()
                                            name_span: arg.name_in_enum_span()
                                            is_mutable: arg.is_mutable
                                            is_reference: arg.is_reference
                                        )

                                        mut module = .current_module()
                                        let variable_id = module.add_variable(checked_variable: CheckedVariable(
                                            name: rebind_name!.name
                                            type_id: type
                                            is_mutable: rebind_name!.is_mutable
                                            definition_span: rebind_name!.name_span
                                            type_span: case_.marker_span
                                            visibility: CheckedVisibility::Public
                                        ))

                                        if rebind_name!.is_mutable and not checked_expr.is_mutable(program: .program) {
                                            .error("Cannot call mutating method on an immutable object instance", span)
                                        }
                                        .add_var_to_scope(
                                            scope_id: new_scope_id
                                            name: rebind_name!.name
                                            var_id: variable_id
                                            span: rebind_name!.name_span
                                        )
                                    }

                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    checked_cases.push(CheckedMatchCase::ClassInstance(
                                        defaults: []
                                        type
                                        body: checked_body
                                        rebind_name
                                        marker_span: case_.marker_span
                                    ))
                                }
                                CatchAll(variant_arguments, arguments_span) => {
                                    if seen_catch_all {
                                        .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                    } else {
                                        seen_catch_all = true
                                        catch_all_marker_span = case_.marker_span

                                        let new_scope_id = .create_scope(
                                            parent_scope_id: scope_id
                                            can_throw: .get_scope(scope_id).can_throw
                                            debug_name: "class-variant(else)"
                                        )

                                        if not variant_arguments.is_empty() {
                                            .error(
                                                "Catch-all cases in class instance matches cannot have arguments"
                                                arguments_span
                                            )
                                        }

                                        let (checked_body, result_type) = .typecheck_match_body(
                                            body: case_.body
                                            scope_id: new_scope_id
                                            safety_mode
                                            generic_inferences: &mut .generic_inferences
                                            final_result_type
                                            span: case_.marker_span
                                        )
                                        final_result_type = result_type

                                        checked_cases.push(CheckedMatchCase::CatchAll(
                                            defaults: []
                                            has_arguments: false
                                            body: checked_body
                                            marker_span: case_.marker_span
                                        ))
                                    }
                                }
                                else => {
                                    .error(
                                        "Only named types and 'else' patterns are allowed in class instance match expressions"
                                        case_.marker_span
                                    )
                                }
                            }
                        }
                    }

                    if not seen_catch_all {
                        // Make sure everything in the inheritance chain is covered
                        mut missing: {String} = {}
                        for struct_id in struct_inheritance_chain {
                            if not covered_cases.contains(struct_id) {
                                let struct_name = .get_struct(struct_id).name
                                missing.add(format("‘{}’", struct_name))
                            }
                        }

                        if not missing.is_empty() {
                            mut builder = StringBuilder::create()
                            builder.append("Missing match cases for ")
                            mut first = true
                            for name in missing {
                                if first { first = false } else { builder.append(", ") }
                                builder.append(name)
                            }

                            .error(
                                builder.to_string()
                                span
                            )
                        }
                    }
                }
                false => {
                    let is_boolean_match = type_to_match_on is Bool
                    mut seen_true = false
                    mut seen_false = false
                    mut catch_all_span: Span? = None

                    mut is_enum_match = false
                    mut is_value_match = false
                    mut seen_catch_all = false

                    mut all_variants_constant = true

                    let case_count = cases.size()
                    mut current_case_index = 0uz
                    for case_ in cases {
                        for pattern in case_.patterns {
                            match pattern {
                                EnumVariant(variant_names, variant_arguments, arguments_span) => {
                                    if is_value_match {
                                        .error(
                                            "Cannot have an enum match case in a match expression containing value matches"
                                            case_.marker_span
                                        )
                                    }

                                    if variant_names.size() == 0 {
                                        .compiler.panic("typecheck_match - else - EnumVariant - variant_names.size() == 0")
                                    }

                                    is_enum_match = true

                                    // We don't know what the enum type is, but we have the type var for it, so generate a generic enum match.
                                    // note that this will be fully checked when this match expression is actually instantiated.
                                    let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: format("catch-enum-variant({})", variant_names))
                                    mut defaults: [CheckedStatement] = []
                                    for (_, default_) in pattern.defaults {
                                        let checked_var_decl = .typecheck_var_decl(
                                            var: default_.variable
                                            init: default_.value
                                            scope_id: new_scope_id
                                            safety_mode
                                            span: default_.variable.span
                                        )
                                        defaults.push(checked_var_decl)
                                    }

                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    let checked_match_case = CheckedMatchCase::EnumVariant(
                                        defaults
                                        name: variant_names.last()!.0
                                        args: variant_arguments
                                        subject_type_id
                                        index: 0
                                        scope_id: new_scope_id
                                        body: checked_body
                                        marker_span: case_.marker_span
                                    )
                                    checked_cases.push(checked_match_case)
                                }
                                CatchAll(variant_arguments) => {
                                    if current_case_index != case_count - 1 {
                                        .error("Match else case is only allowed as the last case", case_.marker_span)
                                    }

                                    catch_all_span = case_.marker_span

                                    if seen_catch_all {
                                        .error("Multiple catch-all cases in match are not allowed", case_.marker_span)
                                    } else {
                                        seen_catch_all = true
                                    }

                                    if variant_arguments.size() != 0 {
                                        let old_ignore_errors = .ignore_errors
                                        .ignore_errors = false
                                        .error("Bindings aren't allowed in a generic else", case_.marker_span)
                                        .ignore_errors = old_ignore_errors
                                        .had_an_error = false
                                    }

                                    let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: "catch-all")
                                    mut defaults: [CheckedStatement] = []
                                    for (_, default_) in pattern.defaults {
                                        let checked_var_decl = .typecheck_var_decl(
                                            var: default_.variable
                                            init: default_.value
                                            scope_id: new_scope_id
                                            safety_mode
                                            span: default_.variable.span
                                        )
                                        defaults.push(checked_var_decl)
                                    }

                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    let checked_match_case = CheckedMatchCase::CatchAll(
                                        defaults
                                        has_arguments: variant_arguments.size() != 0
                                        body: checked_body
                                        marker_span: case_.marker_span
                                    )

                                    checked_cases.push(checked_match_case)
                                }
                                Expression(expr) => {
                                    if is_enum_match {
                                        .error(
                                            "Cannot have a value match case in a match expression containing enum matches"
                                            case_.marker_span
                                        )
                                    }
                                    is_value_match = true

                                    let (new_condition, new_then_block, new_else_statement) = .expand_context_for_bindings(
                                        condition: expr
                                        acc: None
                                        then_block: None
                                        else_statement: None
                                        scope_id
                                        span
                                    )
                                    let checked_expression = .typecheck_expression_and_dereference_if_needed(new_condition, scope_id, safety_mode, type_hint: Some(subject_type_id), span)

                                    if is_boolean_match and checked_expression is Boolean(val) {
                                        if val {
                                            seen_true = true
                                        } else {
                                            seen_false = true
                                        }
                                    }

                                    if not checked_expression.to_number_constant(program: .program).has_value() {
                                        all_variants_constant = false
                                    }

                                    mut expression_type = checked_expression.type()

                                    if checked_expression is Range(from, to) {
                                        guard from.has_value() or to.has_value() else {
                                            .error(
                                                "There has to be at least a 'from', or a 'to' in a range expression"
                                                expr.span()
                                            )
                                            continue
                                        }
                                        if from.has_value() {
                                            expression_type = from!.type()
                                        } else if to.has_value() {
                                            expression_type = to!.type()
                                        }
                                    }

                                    // FIXME: In the future, we should really make this a "does it satisfy some trait" check.
                                    //        For now, we just check that the types are equal.
                                    .check_types_for_compat(
                                        lhs_type_id: expression_type
                                        rhs_type_id: subject_type_id
                                        generic_inferences: &mut .generic_inferences
                                        span: case_.marker_span
                                    )

                                    if not pattern.defaults.is_empty() {
                                        .error("Expression patterns cannot have default bindings", case_.marker_span)
                                    }

                                    let new_scope_id = .create_scope(parent_scope_id: scope_id, can_throw: .get_scope(scope_id).can_throw, debug_name: format("catch-expression({})", expr))
                                    let (checked_body, result_type) = .typecheck_match_body(
                                        body: case_.body
                                        scope_id: new_scope_id
                                        safety_mode
                                        generic_inferences: &mut .generic_inferences
                                        final_result_type
                                        span: case_.marker_span
                                    )
                                    final_result_type = result_type

                                    let checked_match_case = CheckedMatchCase::Expression(
                                        defaults: []
                                        expression: checked_expression
                                        body: checked_body
                                        marker_span: case_.marker_span
                                    )
                                    checked_cases.push(checked_match_case)
                                }
                                else => {}
                            }
                        }

                        current_case_index++
                    }

                    if is_value_match and not (seen_catch_all or (is_boolean_match and seen_true and seen_false)) {
                        .error(
                            "Match expression is not exhaustive, a value match must contain an irrefutable 'else' pattern"
                            span
                        )
                    }

                    if is_value_match and seen_catch_all and is_boolean_match and seen_true and seen_false {
                        .error("All cases are covered, but an irrefutable pattern is also present", catch_all_span!)
                    }
                }
            }
        }

        return CheckedExpression::Match(expr: checked_expr, match_cases: checked_cases, span, type_id: final_result_type ?? void_type_id(), all_variants_constant: true)
    }

    fn typecheck_match_body(mut this, body: ParsedMatchBody, scope_id: ScopeId, safety_mode: SafetyMode, generic_inferences: &mut GenericInferences, final_result_type: TypeId?, span: Span) throws -> (CheckedMatchBody, TypeId?) {
        mut result_type = final_result_type
        let checked_match_body = match body {
            Block(block) => {
                let checked_block = .typecheck_block(parsed_block: block, parent_scope_id: scope_id, safety_mode, yield_type_hint: final_result_type)

                if checked_block.control_flow.may_return() or checked_block.yielded_type.has_value() {
                    let block_type_id = checked_block.yielded_type ?? void_type_id()
                    let yield_span = block.find_yield_span() ?? span

                    if result_type.has_value() {
                        .check_types_for_compat(
                            lhs_type_id: result_type!
                            rhs_type_id: block_type_id
                            generic_inferences
                            span: yield_span
                        )
                    } else {
                        result_type = block_type_id
                    }
                }

                mut final_body: CheckedMatchBody? = None
                if checked_block.yielded_type.has_value() and not checked_block.control_flow.never_returns() {
                    final_body = CheckedMatchBody::Expression(CheckedExpression::Block(
                        block: checked_block
                        span
                        type_id: checked_block.yielded_type!
                    ))
                } else {
                    final_body = CheckedMatchBody::Block(checked_block)
                }

                yield final_body!
            }
            Expression(expr) => {
                let checked_expression = .typecheck_expression(expr, scope_id, safety_mode, type_hint: result_type)
                if result_type.has_value() {
                    .check_types_for_compat(
                        lhs_type_id: result_type!
                        rhs_type_id: checked_expression.type()
                        generic_inferences
                        span
                    )
                } else {
                    result_type = checked_expression.type()
                }

                yield CheckedMatchBody::Expression(checked_expression)
            }
        }
        return (checked_match_body, result_type)
    }

    fn typecheck_dictionary(mut this, values: [(ParsedExpression, ParsedExpression)], span: Span, scope_id: ScopeId, safety_mode: SafetyMode, type_hint: TypeId?) throws -> CheckedExpression {
        let dictionary_struct_id = .find_struct_in_prelude("Dictionary")
        mut checked_kv_pairs: [(CheckedExpression, CheckedExpression)] = []
        mut key_type_id = unknown_type_id()
        mut key_type_span: Span? = None
        mut value_type_id = unknown_type_id()
        mut value_type_span: Span? = None

        mut key_hint: TypeId? = None
        mut value_hint: TypeId? = None
        let type_hint_ids: [TypeId]? = .get_type_ids_from_type_hint_if_struct_ids_match(type_hint, expected_struct_id: dictionary_struct_id)
        if type_hint_ids.has_value() {
            key_hint = type_hint_ids![0]
            value_hint = type_hint_ids![1]
        }

        for (key, value) in values {
            let checked_key = .typecheck_expression(key, scope_id, safety_mode, type_hint: key_hint)
            let current_key_type_id = checked_key.type()

            let checked_value = .typecheck_expression(value, scope_id, safety_mode, type_hint: value_hint)
            let current_value_type_id = checked_value.type()
            let VOID_TYPE_ID = builtin(BuiltinType::Void)

            if key_type_id.equals(unknown_type_id()) and value_type_id.equals(unknown_type_id()) {
                if current_key_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with keys of type void", span: key.span())
                }
                if current_value_type_id.equals(VOID_TYPE_ID) {
                    .error("Can't create a dictionary with values of type void", span: value.span())
                }
                key_type_id = current_key_type_id
                key_type_span = Some(key.span())
                value_type_id = current_value_type_id
                value_type_span = Some(value.span())
            } else {
                if not key_type_id.equals(current_key_type_id) {
                    let key_type_name = .type_name(key_type_id)
                    let current_key_type_name = .type_name(current_key_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous keys in dictionary", current_key_type_name, key_type_name)
                        span: key.span()
                        hint: format("Dictionary was inferred to store keys of type '{}' here", key_type_name)
                        hint_span: key_type_span!
                    )
                }
                if not value_type_id.equals(current_value_type_id) {
                    let value_type_name = .type_name(value_type_id)
                    let current_value_type_name = .type_name(current_value_type_id)
                    .error_with_hint(
                        message: format("Type '{}' does not match type '{}' of previous values in dictionary", current_value_type_name, value_type_name)
                        span: value.span()
                        hint: format("Dictionary was inferred to store values of type '{}' here", value_type_name)
                        hint_span: value_type_span!
                    )
                }
            }
            checked_kv_pairs.push((checked_key, checked_value))
        }

        if key_type_id.equals(unknown_type_id()) {
            if key_hint.has_value() {
                key_type_id = key_hint!
            } else {
                .error("Cannot infer key type for Dictionary<K, V>", span)
            }
        }

        if not key_type_id.equals(unknown_type_id()) {
            // Make sure the key implements Hashable and Equal<itself>
            .ensure_type_implements_trait(
                type_id: key_type_id
                trait_name: "Hashable"
                scope_id
                span
            )
            .ensure_type_implements_trait(
                type_id: key_type_id
                trait_name: "Equal"
                filter_for_generics: [key_type_id]
                scope_id
                span
            )
        }

        if value_type_id.equals(unknown_type_id()) {
            if value_hint.has_value() {
                value_type_id = value_hint!
            } else {
                .error("Cannot infer value type for Dictionary", span)
            }
        }

        let type_id = .find_or_add_type_id(Type::GenericInstance(
            id: dictionary_struct_id,
            args: [key_type_id, value_type_id]
        ))

        // TODO: unify type with hint type

        return CheckedExpression::JaktDictionary(
            vals: checked_kv_pairs
            span
            type_id
            key_type_id
            value_type_id
        )
    }

    fn is_scope_directly_accessible_from(this, scope_id: ScopeId, from_scope_id: ScopeId) throws -> bool {
        return .program.is_scope_directly_accessible_from(check_scope_id: scope_id, scope_id: from_scope_id)
    }

    fn resolve_call(
        mut this
        call: ParsedCall
        mut namespaces: [ResolvedNamespace]
        span: Span
        scope_id: ScopeId
        must_be_enum_constructor: bool
    ) throws -> [FunctionId] {
        mut current_scope_id = scope_id
        mut is_base_ns_alias_or_import: [bool] = [false; namespaces.size()]

        for namespace_index in 0..call.namespace_.size() {
            let scope_name = call.namespace_[namespace_index]
            let maybe_ns_scope = .find_namespace_in_scope(
                scope_id: current_scope_id
                name: scope_name
            )
            if maybe_ns_scope.has_value() {
                let (scope_id, is_import) = maybe_ns_scope!
                if is_import {
                    namespaces[namespace_index].name = .program.modules[scope_id.module_id.id].name
                }
                namespaces[namespace_index].external_name = .get_scope(scope_id).external_name

                is_base_ns_alias_or_import[
                    namespace_index
                ] = .find_namespace_in_scope(
                    scope_id: current_scope_id
                    name: scope_name
                    treat_aliases_as_imports: true
                )!.1

                current_scope_id = scope_id
                continue
            }
            let maybe_struct_scope = .find_struct_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_struct_scope.has_value() {
                let structure = .get_struct(maybe_struct_scope!)
                namespaces[namespace_index].external_name = structure.external_name
                current_scope_id = structure.scope_id
                continue
            }
            let maybe_enum_scope = .program.find_enum_in_scope(scope_id: current_scope_id, name: scope_name)
            if maybe_enum_scope.has_value() {
                let enum_ = .get_enum(maybe_enum_scope!)
                current_scope_id = enum_.scope_id
                continue
            }

            if .generic_inferences.find_and_map(scope_name, &.program) is Some(type_id) {
                match .get_type(type_id) {
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        current_scope_id = .get_enum(enum_id).scope_id
                        continue
                    }
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        current_scope_id = .get_struct(struct_id).scope_id
                        continue
                    }
                    else => {}
                }
            }

            .error(format("Not a namespace, enum, class, or struct: ‘{}’", join(call.namespace_, separator: "::")), span)
        }

        mut initial_scope_id = current_scope_id
        mut owning_scope: ScopeId? = None

        defer {
            mut resolved_namespaces: [ResolvedNamespace] = []
            {
                mut ns_index = 0
                for ns in namespaces {
                    defer ns_index += 1
                    if not is_base_ns_alias_or_import[ns_index] {
                        resolved_namespaces.push(ns)
                    }
                }
            }

            if not owning_scope.has_value() {
                mut aliased_namespaces: [ResolvedNamespace] = []
                loop {
                    let scope = .get_scope(current_scope_id)
                    if scope.alias_path.has_value() {
                        for i in scope.alias_path!.size()..0 {
                            aliased_namespaces.push(scope.alias_path![i - 1])
                        }
                    } else if scope.namespace_name.has_value() {
                        aliased_namespaces.push(
                            ResolvedNamespace(name: scope.namespace_name!, external_name: scope.external_name, generic_parameters: None)
                        )
                    }

                    if .is_scope_directly_accessible_from(scope_id: current_scope_id, from_scope_id: initial_scope_id) {
                        break
                    }

                    let parent = scope.parent
                    if not parent.has_value() {
                        break
                    }
                    current_scope_id = parent!
                }

                for i in aliased_namespaces.size()..0 {
                    resolved_namespaces.push(aliased_namespaces[i - 1])
                }
            }

            namespaces.shrink(size: 0)
            namespaces.push_values(&resolved_namespaces)
        }

        // 1. Look for a variable in the current scope with this name.
        let maybe_var = .find_var_in_scope(scope_id: current_scope_id, var: call.name, root_scope: current_scope_id)
        if maybe_var.has_value()  {
            let inner_type = match .get_type(maybe_var!.type_id) {
                Reference(type_id) | MutableReference(type_id) => type_id
                else => maybe_var!.type_id
            }

            if .get_type(inner_type) is Function(pseudo_function_id) {
                return [pseudo_function_id]
            }
        }

        // 2. Look for a function with this name.
        let maybe_overload_set = .find_scoped_functions_with_name_in_scope(
            parent_scope_id: current_scope_id
            function_name: call.name
            root_scope_id: current_scope_id
        )
        if maybe_overload_set.has_value() {
            let function = .get_function(maybe_overload_set!.0[0])
            if not must_be_enum_constructor or function.type is ImplicitEnumConstructor {
                owning_scope = function.owner_scope
                current_scope_id = maybe_overload_set!.1
                return maybe_overload_set!.0
            }
        }

        if must_be_enum_constructor {
            .error(format("No such enum constructor ‘{}’", call.name), span)
            return []
        }

        // 3. Look for a struct, class or enum constructor with this name.
        let maybe_struct_id = .find_struct_in_scope(
            scope_id: current_scope_id
            name: call.name
            root_scope_id: current_scope_id
        )
        if maybe_struct_id.has_value() {
            let struct_id = maybe_struct_id!
            let structure = .get_struct(struct_id)
            let maybe_function_id = .find_scoped_functions_with_name_in_scope(
                parent_scope_id: structure.scope_id
                function_name: structure.name
                root_scope_id: structure.scope_id
            )
            if maybe_function_id.has_value() {
                owning_scope = .get_function(maybe_function_id!.0[0]).owner_scope
                current_scope_id = maybe_function_id!.1
                return maybe_function_id!.0
            }
        }

        .error(format("Call to unknown function: ‘{}’", call.name), span)
        return []
    }

    fn match_function_and_resolve_args(
        mut this
        call: ParsedCall
        caller_scope_id: ScopeId
        candidate: FunctionId
        safety_mode: SafetyMode
        span: Span
        this_expr: CheckedExpression?
    ) throws -> FunctionMatchResult {
        mut args: [CheckedExpression] = []
        mut maybe_this_type_id: TypeId? = None
        mut argument_errors: [JaktError] = []
        let num_old_compiler_errors = .compiler.errors.size()

        let callee_candidate = .get_function(candidate)
        let scope_containing_callee = .get_scope(callee_candidate.function_scope_id).parent!
        let generic_inference_checkpoint = .generic_inferences.perform_checkpoint(reset: false)

        if callee_candidate.is_instantiated {
            .generic_inferences.perform_checkpoint(reset: true)
        }

        defer {
            .generic_inferences.restore(generic_inference_checkpoint)
        }

        if callee_candidate.type is ImplicitConstructor {
            let struct_ = .get_struct(callee_candidate.struct_id!)
            .check_implicit_constructor_argument_access(caller_scope_id, call, struct_)
        } else {
            .check_method_access(accessor: caller_scope_id, accessee: scope_containing_callee, method: callee_candidate, span)
        }

        // If the user gave us explicit type arguments, let's use them in our substitutions
        mut type_arg_index = 0uz
        for parsed_type in call.type_args {
            let checked_type = .typecheck_typename(parsed_type, scope_id: caller_scope_id, name: None)
            if callee_candidate.generics.params.size() <= type_arg_index {
                .error("Trying to access generic parameter out of bounds", parsed_type.span())
                continue
            }

            // Find the associated type variable for this parameter, we'll use it in substitution
            let typevar_type_id = callee_candidate.generics.params[type_arg_index].type_id()

            if not typevar_type_id.equals(checked_type) {
                .generic_inferences.set(typevar_type_id, checked_type)
            }

            type_arg_index += 1
        }

        // This will be 0 for functions or 1 for instance methods, because of the `this` ptr
        mut arg_offset = 0uz

        // If this is a method, let's also add the types we know from our `this` pointer.
        if this_expr.has_value() {
            let type_id = this_expr!.type()
            maybe_this_type_id = type_id
            let param_type = .get_type(type_id)

            if param_type is GenericInstance(id, args) {
                let structure = .get_struct(id)
                for i in 0..structure.generic_parameters.size() {
                    if structure.generic_parameters[i].type_id.equals(args[i]) {
                        continue
                    }

                    .generic_inferences.set(
                        structure.generic_parameters[i].type_id
                        args[i]
                    )
                }
            }

            if callee_candidate.is_static() {
                .error("Cannot call static method on an instance of an object", span)
            } else {
                arg_offset = 1uz
            }

            if callee_candidate.is_mutating() and not this_expr!.is_mutable(program: .program) {
                .error("Cannot call mutating method on an immutable object instance", span)
            }
        } else if not callee_candidate.is_static() {
            .error_with_hint(
                "Cannot call an instance method statically"
                span
                "Add a dot before the method name to call an instance method"
                span
            )
        }

        mut total_function_specificity = 0

        let resolved_args: [(String, Span, CheckedExpression)] = .resolve_default_params(
            params: callee_candidate.generics.base_params
            has_varargs: callee_candidate.has_varargs
            args: call.args
            scope_id: caller_scope_id
            safety_mode
            arg_offset
            span
        )
        mut params_to_compare: [TypeId] = []
        mut is_specialized_comptime_function = false
        if callee_candidate.is_comptime and callee_candidate.specialization_index is Some(index) {
            params_to_compare = callee_candidate.generics.specializations[index]
            // This is a specialization, so give it a higher specificity if it matches.
            is_specialized_comptime_function = true
        } else {
            params_to_compare.ensure_capacity(callee_candidate.generics.base_params.size())
            for param in callee_candidate.generics.base_params {
                params_to_compare.push(param.variable.type_id)
            }
        }

        if params_to_compare.size() <= resolved_args.size() + arg_offset {
            for i in 0..(params_to_compare.size() - arg_offset) {
                let (name, span, checked_arg) = resolved_args[i]
                let type_to = .get_type(params_to_compare[i+arg_offset])
                total_function_specificity += type_to.specificity(program: .program)

                if is_specialized_comptime_function {
                    .check_types_for_compat(
                        lhs_type_id: callee_candidate.generics.base_params[i + arg_offset].variable.type_id
                        rhs_type_id: checked_arg.type()
                        generic_inferences: &mut .generic_inferences
                        span: checked_arg.span()
                    )
                }
                .check_types_for_compat(
                    lhs_type_id: params_to_compare[i+arg_offset]
                    rhs_type_id: checked_arg.type()
                    generic_inferences: &mut .generic_inferences
                    span: checked_arg.span()
                )
                args.push(checked_arg)
            }

            if params_to_compare.size() < resolved_args.size() + arg_offset and callee_candidate.has_varargs {
                for arg in resolved_args[(params_to_compare.size() - arg_offset)..] {
                    args.push(arg.2)
                }
            }
        }

        let num_match_errors = .compiler.errors.size() - num_old_compiler_errors
        if num_match_errors > 0 {
            for error_index in 0uz..num_match_errors {
                argument_errors.push(.compiler.errors.pop()!)
            }
            return FunctionMatchResult::MatchError(errors: argument_errors)
        }
        let used_inferences = .generic_inferences.perform_checkpoint(reset: false)
        if is_specialized_comptime_function {
            total_function_specificity += 1
            total_function_specificity *= 2
        }

        return FunctionMatchResult::MatchSuccess(
            args
            maybe_this_type_id
            used_generic_inferences: used_inferences
            specificity: total_function_specificity
        )
    }

    fn stringify_function_prototype(mut this, anon function_id: FunctionId) throws -> String {
        let function = .get_function(function_id)
        mut builder = StringBuilder::create()
        builder.append("fn ")
        builder.append(function.name)
        if not function.generics.params.is_empty() {
            builder.append("<")
            mut first = true
            for param in function.generics.params {
                if first { first = false } else { builder.append(", ") }
                builder.append(.type_name(param.type_id()))
            }
            builder.append(">")
        }
        builder.append("(")
        mut first = true
        for param in function.params {
            if first { first = false } else { builder.append(", ") }
            if not param.requires_label {
                builder.append("anon ")
            }
            builder.append(param.variable.name)
            builder.append(": ")
            builder.append(.type_name(param.variable.type_id))
            if param.default_value_expression.has_value() {
                builder.append(" = ...")
            }
        }
        builder.append(")")
        if function.can_throw {
            builder.append(" throws")
        }
        builder.append(" -> ")
        builder.append(.type_name(function.return_type_id))

        if function.specialization_index is Some(index) {
            builder.append(format(" [specialization {}: <", index))
            let type_ids = function.generics.specializations[index]
            for i in 0..type_ids.size() {
                if i != 0 {
                    builder.append(", ")
                }
                builder.append(.type_name(type_ids[i]))
            }
            builder.append(">]")
        }
        return builder.to_string()
    }

    fn typecheck_call(
        mut this
        call: ParsedCall
        caller_scope_id: ScopeId
        span: Span
        this_expr: CheckedExpression?
        parent_id: StructLikeId?
        safety_mode: SafetyMode
        mut type_hint: TypeId?
        must_be_enum_constructor: bool
    ) throws -> CheckedExpression {
        mut args: [(String, CheckedExpression)] = []
        mut return_type = builtin(BuiltinType::Void)
        mut generic_arguments: [TypeId] = []
        mut callee_throws = false
        mut resolved_namespaces: [ResolvedNamespace] = []
        mut resolved_function_id_candidates: [FunctionId] = []
        mut resolved_function_id: FunctionId? = None
        mut maybe_this_type_id: TypeId? = None
        mut generic_checked_function_to_instantiate: FunctionId? = None

        let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
        defer .generic_inferences.restore(old_generic_inferences)

        let is_print_like = call.namespace_.is_empty() and match call.name {
            "print" | "println" | "eprintln" | "eprint" | "format" => true
            else => false
        }

        for name in call.namespace_ {
            resolved_namespaces.push(ResolvedNamespace(name, external_name: None, generic_parameters: None))
        }

        mut callee_scope_id = match parent_id.has_value() {
            true => match parent_id! {
                Struct(id) => {
                    mut struct_ = .get_struct(id)
                    mut scope_id = struct_.scope_id
                    while resolved_function_id_candidates.is_empty() {
                        let old_ignore_errors = .ignore_errors
                        .ignore_errors = true
                        resolved_function_id_candidates = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor)
                        .ignore_errors = old_ignore_errors
                        .had_an_error = false

                        if not resolved_function_id_candidates.is_empty() {
                            break
                        }
                        if struct_.super_struct_id.has_value() {
                            let parent_struct_id = struct_.super_struct_id!
                            struct_ = .get_struct(parent_struct_id)
                            scope_id = struct_.scope_id
                        } else {
                            .error(format("Could not find ‘{}’", call.name), span)
                            break
                        }
                    }
                    yield scope_id
                }
                Enum(id) => {
                    let scope_id = .get_enum(id).scope_id
                    resolved_function_id_candidates = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor)
                    yield scope_id
                }
                Trait(id) => {
                    let scope_id = .get_trait(id).scope_id
                    resolved_function_id_candidates = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id, must_be_enum_constructor)
                    yield scope_id
                }
            }
            else => {
                if not is_print_like {
                    resolved_function_id_candidates = .resolve_call(call, namespaces: resolved_namespaces, span, scope_id: caller_scope_id, must_be_enum_constructor)
                }
                yield caller_scope_id
            }
        }

        mut generic_inferences_from_parent: [TypeId:TypeId] = [:]
        if parent_id.has_value() and parent_id!.generic_arguments.has_value() {
            let arguments = parent_id!.generic_arguments!
            let parameters = parent_id!.generic_parameters(&.program)

            for i in 0..arguments.size() {
                generic_inferences_from_parent.set(parameters[i], arguments[i])
                .generic_inferences.set(parameters[i], arguments[i])
            }
        }

        if is_print_like {
            mut first = true
            for arg in call.args {
                let type_hint = match first {
                    true => {
                        first = false
                        yield Some(.prelude_struct_type_named("StringView"))
                    }
                    false => None
                }

                let checked_arg = .typecheck_expression(expr: arg.2, scope_id: caller_scope_id, safety_mode, type_hint)

                args.push((call.name, checked_arg))
            }

            if call.name == "format" {
                return_type = .prelude_struct_type_named("String")
            }
        } else {
            mut max_found_specificity = -1i64
            mut errors_while_trying_to_find_matching_function: [JaktError] = []
            mut generic_inferences_for_best_match: [TypeId:TypeId] = [:]
            // find the best match i.e. the most specific implementation that matches the signature
            for candidate in resolved_function_id_candidates.iterator() {
                match .match_function_and_resolve_args(call, caller_scope_id, candidate, safety_mode, span, this_expr) {
                    MatchSuccess(
                        args: resolved_args
                        maybe_this_type_id: resolved_this_type_id
                        used_generic_inferences
                        specificity
                    ) => {
                        if specificity > max_found_specificity {
                            resolved_function_id = candidate
                            maybe_this_type_id = resolved_this_type_id
                            max_found_specificity = specificity
                            generic_inferences_for_best_match = used_generic_inferences

                            args = []
                            for resolved_arg in resolved_args.iterator() {
                                args.push((call.name, resolved_arg))
                            }
                        }
                    }
                    MatchError(errors) => {
                        for error in errors.iterator() {
                            errors_while_trying_to_find_matching_function.push(error)
                        }
                        continue
                    }
                }
            }

            if not resolved_function_id.has_value() {
                if not resolved_function_id_candidates.is_empty() {
                    .error("No function with matching signature found.", span)
                    for match_error in errors_while_trying_to_find_matching_function.iterator() {
                        .compiler.errors.push(match_error)
                        if .ignore_errors {
                            .had_an_error = true
                        }
                    }

                    for candidate in resolved_function_id_candidates {
                        .error(
                            format("Candidate: {}", .stringify_function_prototype(candidate))
                            span
                        )
                    }
                }

                mut checked_type_args: [TypeId] = []
                for type_arg in call.type_args {
                    checked_type_args.push(.typecheck_typename(parsed_type: type_arg, scope_id: caller_scope_id, name: None))
                }

                for arg in call.args {
                    let checked_arg = .typecheck_expression(expr: arg.2, scope_id: caller_scope_id, safety_mode, type_hint: None)
                    args.push((call.name, checked_arg))
                }

                return CheckedExpression::Call(
                    generic_inferences: .generic_inferences.perform_checkpoint(reset: false),
                    call: CheckedCall(
                        namespace_: resolved_namespaces,
                        name: call.name,
                        args,
                        type_args: checked_type_args,
                        function_id: None,
                        return_type: builtin(BuiltinType::Unknown),
                        callee_throws
                        external_name: None
                    ),
                    span,
                    type_id: builtin(BuiltinType::Unknown)
                )
            }

            .generic_inferences.restore(generic_inferences_for_best_match)
            .generic_inferences.set_from(generic_inferences_from_parent)
            let callee = .get_function(resolved_function_id!)
            callee_throws = callee.can_throw
            return_type = callee.return_type_id

            if callee.is_unsafe and safety_mode is Safe {
                .error("Cannot call unsafe function in safe context", span)
            }

            // We've now seen all the arguments and should be able to substitute the return type, if it's contains a
            // type variable. For the moment, we'll just checked to see if it's a type variable.
            // FIXME: `unknown_type_id()` and `None` are really the same thing. Can we remove `unknown_type_id()`?
            if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                let old_ignore_errors = .ignore_errors
                .ignore_errors = true
                .check_types_for_compat(
                    lhs_type_id: return_type
                    rhs_type_id: type_hint!
                    generic_inferences: &mut .generic_inferences
                    span
                )
                .ignore_errors = old_ignore_errors
                .had_an_error = false
            }

            return_type = .substitute_typevars_in_type(type_id: return_type, generic_inferences: .generic_inferences)

            if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                let old_ignore_errors = .ignore_errors
                if callee.is_instantiated {
                    // If this is a possible respecialization of a generic function that is the child of a specialized version of that function
                    // allow an error here, if it is not a respecialization we will recheck
                    .ignore_errors = true
                }
                .check_types_for_compat(
                    lhs_type_id: type_hint!
                    rhs_type_id: return_type
                    generic_inferences: &mut .generic_inferences
                    span
                )
                .ignore_errors = old_ignore_errors
                .had_an_error = false
            }

            for generic_typevar in callee.generics.params {
                if generic_typevar.kind is Parameter {
                    let substitution = .generic_inferences.get(generic_typevar.type_id())
                    if substitution.has_value() {
                        generic_arguments.push(substitution!)
                    } else if not .in_comptime_function_call {
                        .error("Not all generic parameters have known types", span)
                    } else {
                        generic_arguments.push(generic_typevar.type_id())
                    }
                }
            }

            if not callee.is_instantiated or (not callee.linkage is External and not callee.generics.is_specialized_for_types(types: generic_arguments)) {
                generic_checked_function_to_instantiate = Some(resolved_function_id!)
            } else if callee.is_instantiated {
                if type_hint.has_value() and not type_hint.value().equals(unknown_type_id()) {
                    .check_types_for_compat(
                        lhs_type_id: type_hint!
                        rhs_type_id: return_type
                        generic_inferences: &mut .generic_inferences
                        span
                    )
                }
            }
        }

        return_type = .substitute_typevars_in_type(
            type_id: return_type,
            generic_inferences: .generic_inferences,
        )

        if callee_throws and not .get_scope(caller_scope_id).can_throw {
            .error("Call to function that may throw needs to be in a try statement or a function marked as throws", span)
        }

        if generic_checked_function_to_instantiate.has_value() {
            // Clear the generic parameters and typecheck in the fully specialized scope.
            if maybe_this_type_id.has_value() {
                maybe_this_type_id = .substitute_typevars_in_type(type_id: maybe_this_type_id!, generic_inferences: .generic_inferences)
            }

            resolved_function_id = .typecheck_and_specialize_generic_function(
                function_id: generic_checked_function_to_instantiate!
                generic_arguments,
                parent_scope_id: callee_scope_id,
                this_type_id: maybe_this_type_id,
                generic_substitutions: .generic_inferences
                type_args: call.type_args,
                call_span: span
                args
            )
        }

        if .dump_try_hints and callee_throws {
            .dump_try_hint(span)
        }

        let external_name = match resolved_function_id.has_value() {
            true => {
                let function = .get_function(resolved_function_id!)
                if function.deprecated_message.has_value() {
                    .error(
                        format("Call to deprecated function: {}", function.deprecated_message!)
                        span
                    )
                }
                yield function.external_name
            }
            false => None
        }

        if resolved_function_id.has_value() {
            let function = .get_function(resolved_function_id!)
            if function.stores_arguments.has_value() {
                let argument_behaviour = function.stores_arguments!
                for (index, level) in argument_behaviour {
                    let resolve_arg = fn[&args, &this_expr, &function](anon index: usize) throws -> CheckedExpression {
                        if function.is_static() {
                            return args[index].1
                        }
                        if index == 0uz {
                            return this_expr!
                        }
                        return args[index - 1].1
                    }

                    let arg_scope_id = .required_scope_id_in_hierarchy_for(resolve_arg(index), current_scope_id: caller_scope_id).0
                    let stored_scope_id = match level {
                        InStaticStorage => Some(.root_scope_id())
                        InObject(argument_index) => .required_scope_id_in_hierarchy_for(resolve_arg(argument_index), current_scope_id: caller_scope_id).0
                    }

                    if .scope_lifetime_subsumes(stored_scope_id, arg_scope_id) {
                        .error(
                            "Cannot pass this argument by reference, it is not guaranteed to outlive the object it will be stored in"
                            resolve_arg(index).span()
                        )
                    }
                }
            }
        }

        let force_inline = match resolved_function_id.has_value() {
            true => .get_function(resolved_function_id!).force_inline
            false => InlineState::Default
        }
        let function_call = CheckedCall(
            namespace_: resolved_namespaces
            name: call.name
            args
            type_args: generic_arguments
            function_id: resolved_function_id
            return_type
            callee_throws
            external_name
            force_inline
        )
        let checked_call = CheckedExpression::Call(
            generic_inferences: .generic_inferences.perform_checkpoint(reset: false),
            call: function_call
            span
            type_id: return_type
        )

        let in_comptime_function = .current_function_id.has_value() and .get_function(.current_function_id.value()).is_comptime

        if not in_comptime_function and resolved_function_id.has_value() and .get_function(resolved_function_id!).is_comptime {
            let resolved_function = .get_function(resolved_function_id!)
            mut interpreter = .interpreter()
            let function = .program.get_function(generic_checked_function_to_instantiate ?? resolved_function_id!)
            mut call_args: [Value] = []
            mut this_argument: Value? = None
            mut eval_scope = InterpreterScope::from_runtime_scope(scope_id: caller_scope_id, program: .program)

            for entry in .generic_inferences.iterator() {
                let (key, value) = entry
                eval_scope.type_bindings.set(key, value)
            }

            if this_expr.has_value() {
                try {
                    let evaluated_this = interpreter.execute_expression(
                        expr: this_expr!
                        scope: eval_scope)

                    if evaluated_this is JustValue(value) {
                        this_argument = value
                    } else if evaluated_this is Throw(value) {
                        .error(
                            format("Error executing this expression (evaluation threw {})", value),
                            this_expr!.span())
                    } else {
                        .error(
                            "Invalid this expression",
                            this_expr!.span())
                    }
                } catch {
                    .error("Error executing this expression", this_expr!.span())
                }
            }

            for argument in args {
                let value = try interpreter.execute_expression(
                    expr: argument.1,
                    scope: eval_scope
                ) catch {
                    .error("Error in argument", span)
                    continue
                }

                if value is Throw {
                    .error(
                        format("Compiletime call failed: {}", value)
                        argument.1.span()
                    )
                    break
                }

                let evaluated_value = match value {
                    Return(x) | JustValue(x) => x
                    else => {
                        throw Error::from_errno(69) // unreachable
                    }
                }

                call_args.push(evaluated_value)
            }


            mut type_bindings: [TypeId:TypeId] = [:]
            for i in 0uz..resolved_function.generics.params.size() {
                let param = resolved_function.generics.params[i]
                if function_call.type_args.size() <= i {
                    .error(
                        format("Missing type argument for generic parameter {}", i)
                        span
                    )
                    break
                }

                type_bindings.set(
                    param.type_id()
                    function_call.type_args[i]
                )
            }

            mut result: ExecutionResult? = None
            mut invocation_scope = InterpreterScope::create(parent_scope: eval_scope, type_bindings)
            try {
                result = interpreter.execute(
                    function_to_run_id: resolved_function_id!
                    namespace_: resolved_namespaces
                    this_argument: this_argument
                    arguments: call_args
                    call_span: span
                    invocation_scope
                )
            } catch error {
                .error(format("Compiletime call failed: {}", error), span)
                return checked_call
            }

            return match result! {
                Return(x) => value_to_checked_expression(x, interpreter)
                Throw(x) => {
                    .error(
                        format("Compiletime call failed: {}", x)
                        x.span
                    )
                    yield checked_call
                }
            }
        }

        return checked_call
    }

    fn check_implicit_constructor_argument_access(mut this, caller_scope_id: ScopeId, call: ParsedCall, struct_: CheckedStruct)  throws {
        if .scope_can_access(accessor:caller_scope_id, accessee:struct_.scope_id) {
            return
        }
        for arg in call.args {
            for field in struct_.fields {
                let variable = .get_variable(field.variable_id)

                let name = .get_argument_name(arg)
                if (variable.name == name and variable.visibility is Private) {
                    .error(format("Can't access field '{}' when calling implicit constructor of '{}' because it is marked private", variable.name, struct_.name), arg.1)
                    return
                }
            }
        }
    }

    fn resolve_default_params(
        mut this
        params: [CheckedParameter]
        has_varargs: bool
        args: [(String, Span, ParsedExpression)]
        scope_id: ScopeId
        safety_mode: SafetyMode
        arg_offset: usize
        span: Span
    ) throws -> [(String, Span, CheckedExpression)] {
        mut params_with_default_value = 0uz

        for param in params {
            if param.default_value_expression.has_value() {
                params_with_default_value++
            }
        }

        let max_number_of_valid_arguments = params.size() - arg_offset
        let min_number_of_valid_arguments = max_number_of_valid_arguments - params_with_default_value

        guard args.size() >= min_number_of_valid_arguments and (args.size() <= max_number_of_valid_arguments or has_varargs) else {
            .error("Wrong number of arguments", span)
            return []
        }

        mut consumed_arg = 0uz
        mut resolved_args: [(String, Span, CheckedExpression)] = []

        for i in arg_offset..params.size() {
            let param = params[i]
            mut maybe_checked_expr: CheckedExpression? = None
            if not param.requires_label {
                if args.size() <= consumed_arg {
                    if not param.default_value_expression.has_value() {
                        .error(format("Missing argument for function parameter {}", param.variable.name), span)
                        continue
                    }
                    if param.default_value_expression is Some(default_value) {
                        // Ensure the default value is typechecked with access to the scope it's declared in.
                        mut scope = .get_scope(scope_id)
                        let (expression, default_scope_id) = default_value
                        scope.resolution_mixins.push(default_scope_id)
                        defer scope.resolution_mixins.pop()
                        maybe_checked_expr = .typecheck_expression(
                            expr: expression
                            scope_id
                            safety_mode
                            type_hint: param.variable.type_id
                        )
                    }
                } else {
                    let (name, span, expr) = args[consumed_arg]

                    // The label is not required, but if it is present regardless, it has to match the parameter name
                    if not name.is_empty() and name != param.variable.name {
                        .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", name, param.variable.name), span)
                    }

                    maybe_checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: param.variable.type_id)
                    consumed_arg++
                }

            } else {
                if param.default_value_expression is Some(default_value) {
                    mut scope = .get_scope(scope_id)
                    let (expression, default_scope_id) = default_value
                    scope.resolution_mixins.push(default_scope_id)
                    defer scope.resolution_mixins.pop()
                    maybe_checked_expr = .typecheck_expression(
                        expr: expression
                        scope_id
                        safety_mode
                        type_hint: param.variable.type_id
                    )
                }

                if args.size() > consumed_arg {
                    let (name, span, expr) = args[consumed_arg]

                    if .validate_argument_label(param, label: name, span, expr, default_value: maybe_checked_expr) {
                        maybe_checked_expr = .typecheck_expression(expr, scope_id, safety_mode, type_hint: param.variable.type_id)
                        consumed_arg++
                    }
                }
            }

            if maybe_checked_expr.has_value() {
                mut checked_arg = maybe_checked_expr!
                resolved_args.push((param.variable.name, span, checked_arg))
            }
        }

        for (name, span, expr) in args[consumed_arg..] {
            resolved_args.push((name, span, .typecheck_expression(expr, scope_id, safety_mode, type_hint: None)))
        }

        return resolved_args
    }

    fn resolve_type_var(this, type_var_type_id: TypeId, scope_id: ScopeId) throws -> TypeId {
        mut current_type_id = type_var_type_id

        loop {
            current_type_id = .generic_inferences.map(current_type_id)
            let type_var_type = .get_type(current_type_id)
            if type_var_type is TypeVariable(name: type_name) {
                let maybe_found_type_id = .find_type_in_scope(scope_id, name: type_name)
                if maybe_found_type_id.has_value() {
                    let found_type_id = maybe_found_type_id.value()
                    if found_type_id.equals(current_type_id) {
                        return current_type_id
                    }
                    current_type_id = found_type_id
                } else {
                    return current_type_id
                }
            } else {
                return current_type_id
            }
        }
        return current_type_id
    }

    fn validate_argument_label(mut this, param: CheckedParameter, label: String, span: Span, expr: ParsedExpression, default_value: CheckedExpression?) -> bool {
        let name = .get_argument_name(arg: (label, span, expr))
        if name == param.variable.name {
            return true
        }

        if not default_value.has_value() {
            if label.is_empty() {
                .error(format("Missing argument label (expected '{}:')", param.variable.name), expr.span())
            } else {
                .error(format("Wrong parameter name in argument label (got '{}', expected '{}')", label, param.variable.name), span)
            }
        }

        return false
    }

    fn get_argument_name(this, arg: (String, Span, ParsedExpression)) -> String {
        if not arg.0.is_empty() {
            return arg.0
        }

        match arg.2 {
            Var(name) => {
                return name
            }
            UnaryOp(expr, op) => {
                if op is Reference or op is MutableReference or op is Dereference {
                    if expr is Var(name) {
                        return name
                    }
                }
            }
            else => {}
        }

        return ""
    }

    fn find_all_implementations_of_trait(
        mut this
        type_id: TypeId
        trait_id: TraitId
        filter_for_generics: [TypeId]? = None
    ) throws -> [[TypeId]] {
        let generics_match = fn[this, &filter_for_generics, &trait_id](anon generics: [TypeId]) throws -> bool {
            let old_generic_inferences = .generic_inferences.perform_checkpoint(reset: false)
            defer .generic_inferences.restore(old_generic_inferences)

            guard filter_for_generics is Some(generics_to_match) else {
                return true
            }

            guard generics.size() >= generics_to_match.size() else {
                return false
            }

            let old_ignore_errors = .ignore_errors
            .ignore_errors = true
            defer {
                .ignore_errors = old_ignore_errors
                .had_an_error = false
            }

            for i in 0..generics_to_match.size() {
                let generic = generics[i]
                let generic_to_match = generics_to_match[i]


                if not .check_types_for_compat(
                    lhs_type_id: generic
                    rhs_type_id: generic_to_match
                    generic_inferences: &mut .generic_inferences
                    span: Span(file_id: FileId(id: 0), start: 0, end: 0) // NOTE: This won't show up anywhere (as the errors are ignored)
                ) {
                    return false
                }
            }

            return true
        }

        mut type = .get_type(type_id)
        if type.is_builtin() {
            type = .get_type(.get_struct(
                .program.builtin_implementation_struct(builtin: type.as_builtin_type(), for_module: .program.prelude_module_id())
            ).type_id)
        }

        return match type {
            Struct(struct_id) default(args: [TypeId] = []) | GenericInstance(id: struct_id, args) => {
                let struct_ = .get_struct(struct_id)
                .generic_inferences.set_all(keys: struct_.generic_parameters, values: args)

                mut implementations: [[TypeId]] = []
                for (_, trait_descriptors) in struct_.trait_implementations {
                    for trait_descriptor in trait_descriptors {
                        if trait_descriptor.0.equals(trait_id) and generics_match(trait_descriptor.1) {
                            implementations.push(trait_descriptor.1)
                        }
                    }
                }
                yield implementations
            }
            Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                let enum_ = .get_enum(enum_id)
                mut implementations: [[TypeId]] = []
                for (_, trait_descriptors) in enum_.trait_implementations {
                    for trait_descriptor in trait_descriptors {
                        if trait_descriptor.0.equals(trait_id) and generics_match(trait_descriptor.1) {
                            implementations.push(trait_descriptor.1)
                        }
                    }
                }
                yield implementations
            }
            Trait(id) => {
                if id.equals(trait_id) and generics_match([]) {
                    return [[]]
                }
                yield []
            }
            GenericTraitInstance(id, args) => {
                if not id.equals(trait_id) or not generics_match(args) {
                    return []
                }
                yield [args]
            }
            else => []
        }
    }

    fn implements_trait(mut this, type_id: TypeId, trait_id: TraitId, generic_arguments: [TypeId]? = None) throws -> bool {
        let has_matching_trait = fn[type_id](
            trait_implementations: [[TypeId]]
            trait_id: TraitId
            passed_generic_arguments: [TypeId]
            typechecker: &mut Typechecker
        ) throws -> bool {
            let old_ignore_errors = typechecker.ignore_errors
            typechecker.ignore_errors = true
            defer {
                typechecker.ignore_errors = old_ignore_errors
                typechecker.had_an_error = false
            }

            mut found = false
            for implemented_generic_arguments in trait_implementations {
                if implemented_generic_arguments.size() != passed_generic_arguments.size() {
                    continue
                }

                mut ok = false
                for i in 0..implemented_generic_arguments.size() {
                    ok = typechecker.check_types_for_compat(
                        lhs_type_id: implemented_generic_arguments[i]
                        rhs_type_id: passed_generic_arguments[i]
                        generic_inferences: &mut typechecker.generic_inferences
                        span: Span(file_id: FileId(id: 0), start: 0, end: 0) // NOTE: This won't show up anywhere (as the errors are ignored)
                    )

                    if not ok { break }
                }

                if not ok { continue }

                found = true
                break
            }

            return found
        }

        let empty: [TypeId] = []
        return has_matching_trait(
            trait_implementations: .find_all_implementations_of_trait(type_id, trait_id)
            trait_id
            passed_generic_arguments: generic_arguments ?? empty
            typechecker: &mut this
        )
    }

    // NOTE: function trait requirements aren't currently taken into account.
    fn signatures_match(
        mut this
        anon self_type_id: TypeId
        anon first: CheckedFunction
        anon second: CheckedFunction
    ) throws -> (bool, [JaktError]) {
        let starting_error_count = .compiler.errors.size()

        let types_match = fn[self_type_id](anon typechecker: &mut Typechecker, anon a: TypeId, anon b: TypeId) throws -> bool {
            let mapped_a = typechecker.generic_inferences.map(a)
            let mapped_b = typechecker.generic_inferences.map(b)

            return match typechecker.get_type(mapped_a) {
                Trait(id) => typechecker.implements_trait(type_id: mapped_b, trait_id: id)
                Self => typechecker.check_types_for_compat(
                    lhs_type_id: self_type_id
                    rhs_type_id: mapped_b
                    generic_inferences: &mut typechecker.generic_inferences
                    span: Span(file_id: FileId(id: 0), start: 0, end: 0) // NOTE: This won't show up anywhere (as the errors are ignored)
                )
                GenericTraitInstance(id, args) => typechecker.implements_trait(type_id: mapped_b, trait_id: id, generic_arguments: args)
                else => typechecker.check_types_for_compat(
                    lhs_type_id: mapped_a
                    rhs_type_id: mapped_b
                    generic_inferences: &mut typechecker.generic_inferences
                    span: Span(file_id: FileId(id: 0), start: 0, end: 0) // NOTE: This won't show up anywhere (as the errors are ignored)
                )
            }
        }

        let result = this.signatures_match_impl(self_type_id, first, second, &types_match)

        let errors = .compiler.errors[starting_error_count..].to_array()
        .compiler.errors = .compiler.errors[..starting_error_count].to_array()

        return (result, errors)
    }

    private fn signatures_match_impl(
        mut this
        anon self_type_id: TypeId
        anon first: CheckedFunction
        anon second: CheckedFunction
        anon types_match: &fn(anon typechecker: &mut Typechecker, anon a: TypeId, anon b: TypeId) throws -> bool
    ) throws -> bool {
        guard types_match(&mut this, first.return_type_id, second.return_type_id) else {
            return false
        }

        guard first.can_throw == second.can_throw else {
            .error(
                message: "Function signatures don't match: one can throw and the other can't",
                span: first.name_span
            )
            return false
        }

        guard first.params.size() == second.params.size() else {
            .error(
                message: "Function signatures don't match: different number of parameters",
                span: first.name_span
            )
            return false
        }

        // both static or both have 'first' parameter
        mut arg_start = 0uz

        if first.is_static() {
            guard second.is_static() else {
                .error(
                    message: "Function signatures don't match: one is static and the other isn't",
                    span: first.name_span
                )
                return false
            }
        } else {
            guard not second.is_static() else {
                .error(
                    message: "Function signatures don't match: one is static and the other isn't",
                    span: first.name_span
                )
                return false
            }

            guard first.is_mutating() == second.is_mutating() else {
                .error(
                    message: "Function signatures don't match: one is mutating and the other isn't",
                    span: first.name_span
                )
                return false
            }
            arg_start = 1uz
        }

        for i in arg_start..first.params.size() {
            guard types_match(&mut this, first.params[i].variable.type_id, second.params[i].variable.type_id) else {
                return false
            }
        }

        return true
    }
}

// NOTE: for some reason using (String, Span) would not compile the generated
// C++, specifically the call to get(). I couldn't track down the error since
// accessing a [String: (String, Span)] dictionary seemed fine in a separate
// test file.
struct AlreadyImplementedFor {
    trait_name: String
    encounter_span: Span
}

// helper struct to implement the checking of trait implementations
struct TraitImplCheck {
    // methods that don't yet have a specified implementation.
    missing_methods: [TypeId:[String:FunctionId]] // typeid -> [method name -> function id]
    // same name, but signature doesn't match.
    unmatched_signatures: [TypeId:[String:(Span, [JaktError])]] // typeid -> [method name -> (span, errors)]
    // same name, signature matches, but isn't marked public.
    private_matching_methods: [TypeId:[String:Span]] // typeid -> [method name -> span]
    // 'Cannot implement method X for trait Y since it already implements Z'
    already_implemented_for: [String:AlreadyImplementedFor] // trait name -> (type name, span)

    fn make() -> TraitImplCheck =>
        TraitImplCheck(
            missing_methods: [:]
            unmatched_signatures: [:]
            private_matching_methods: [:]
            already_implemented_for: [:])

    fn ensure_capacity(mut this, anon count: usize) {
        .missing_methods.ensure_capacity(count)
        .unmatched_signatures.ensure_capacity(count)
        .private_matching_methods.ensure_capacity(count)
        .already_implemented_for.ensure_capacity(count)
    }

    fn register_trait(
        mut this
        trait_type_id: TypeId
        trait_name: String
        requirements: CheckedTraitRequirements
    ) {
        guard requirements is Methods(trait_methods) else {
            return
        }

        .private_matching_methods[trait_type_id] = [:]
        .unmatched_signatures[trait_type_id] = [:]

        mut missing_methods: [String:FunctionId] = [:]
        missing_methods.ensure_capacity(trait_methods.size())


        for (method_name, method_id) in trait_methods {
            missing_methods.set(method_name, method_id)
        }

        .missing_methods.set(trait_type_id, missing_methods)
    }

    fn throw_errors(mut this, record_decl_span: Span, typechecker: &mut Typechecker) throws {
        for (trait_type_id, missing_methods) in .missing_methods {
            let (trait_id, trait_generic_arguments) = match typechecker.get_type(trait_type_id) {
                GenericTraitInstance(id: trait_id, args) | Trait(trait_id) default(args: [TypeId] = []) => (trait_id, args)
                else => {
                    // unreachable
                    abort()
                }
            }

            let trait_name = typechecker.get_trait(trait_id).name

            let unmatched_signatures = .unmatched_signatures[trait_type_id]
            let private_matching_methods = .private_matching_methods[trait_type_id]
            for (method_name, trait_method_id) in missing_methods {
                let already_implemented_for = .already_implemented_for.get(method_name)
                let unmatched_signature = unmatched_signatures.get(method_name)
                let private_matching_method = private_matching_methods.get(method_name)
                if already_implemented_for.has_value() {
                    typechecker.error(
                        format("Cannot implement ‘{}’ for ‘{}’ because it's already implementing ‘{}’",
                            method_name,
                            trait_name,
                            already_implemented_for!.trait_name),
                        already_implemented_for!.encounter_span)
                } else if private_matching_method.has_value() {
                    let span = private_matching_method!
                    typechecker.error_with_hint(
                        format("Implementation of ‘{}’ for trait ‘{}’ is valid but is not public",
                            method_name, trait_name),
                        span,
                        "Consider adding ‘public’ to make the method accessible",
                        span)
                } else {
                    // The user didn't add an implementation for the desired method.
                    // Check if we found an unmatching signature to report that to the user.
                    // Otherwise give them a hint about what the method looks like.
                    let func = typechecker.get_function(trait_method_id)
                    if not func.block.statements.is_empty() {
                        continue
                    }

                    if unmatched_signature.has_value() {
                        let (method_span, errors) = unmatched_signature!

                        typechecker.error_with_hint(
                            format("Missing implementation for method ‘{}’ of trait ‘{}’ on type ‘{}’",
                                method_name, trait_name, typechecker.type_name(trait_type_id)),
                            record_decl_span,
                            "The method is declared here, but its signature doesn't match",
                            method_span)
                        typechecker.compiler.errors.push_values(&errors)
                    } else {
                        let trait_method_span = typechecker.get_function(trait_method_id).name_span
                        typechecker.error_with_hint(
                            format("Missing implementation for method ‘{}’ of trait ‘{}’",
                                method_name, trait_name),
                            record_decl_span,
                            "Consider implementing the method with the signature specified here",
                            trait_method_span)
                    }

                }
            }
        }
    }

    fn register_method(mut this, self_type_id: TypeId, method_name: String, method_id: FunctionId, typechecker: &mut Typechecker) throws {
        let method = typechecker.get_function(method_id)

        // search for a matching method
        for (trait_type_id, methods) in .missing_methods {
            let trait_method_id = methods.get(method_name)

            guard trait_method_id.has_value() else {
                continue
            }
            let trait_method = typechecker.get_function(trait_method_id!)

            let (trait_id, trait_generic_arguments) = match typechecker.get_type(trait_type_id) {
                GenericTraitInstance(id: trait_id, args) | Trait(trait_id) default(args: [TypeId] = []) => (trait_id, args)
                else => {
                    // unreachable
                    abort()
                }
            }
            let trait_ = typechecker.get_trait(trait_id)

            let old_generic_inferences = typechecker.generic_inferences.perform_checkpoint(reset: false)
            defer typechecker.generic_inferences.restore(old_generic_inferences)

            guard trait_.generic_parameters.size() == trait_generic_arguments.size() else {
                .unmatched_signatures[trait_type_id].set(
                    method_name,
                    (
                        method.name_span,
                        [JaktError::Message(
                            message: format("Expected {} generic arguments, but got {}", trait_.generic_parameters.size(), trait_generic_arguments.size())
                            span: method.name_span
                        )]
                    )
                )
                continue
            }

            typechecker.generic_inferences.set_all(keys: trait_.generic_parameters, values: trait_generic_arguments)

            let (matches, errors) = typechecker.signatures_match(self_type_id, trait_method, method)
            guard matches else {
                .unmatched_signatures[trait_type_id].set(
                    method_name,
                    (method.name_span, errors)
                )
                continue
            }

            guard method.visibility is Public else {
                .private_matching_methods[trait_type_id].set(method_name, method.name_span)
                continue
            }

            // since we got here, this means we found the method implementation!
            // Register it as already implemented so that the rest of the traits
            // that needed a similar method know that the method was already implementing
            // one trait.
            .missing_methods[trait_type_id].remove(method_name)
            .already_implemented_for[method_name] = AlreadyImplementedFor(trait_name: trait_.name, encounter_span: method.name_span)
            break
        }
    }

}

fn defines_from(anon actions: [IncludeAction]) throws -> [String:String] {
    mut defines: [String:String] = [:]
    for action in actions {
        if action is Define(name, value) {
            defines.set(name, value)
        }
    }
    return defines
}

fn dump_scope(anon scope_id: ScopeId, anon program: &CheckedProgram, indent: i64 = 0) throws {
    mut scope = program.get_scope(scope_id)
    eprintln("{: >{}}Scope (ns={}) {}", "", indent, scope.namespace_name, scope.debug_name)
    let cindent = indent + 2
    eprintln("{: >{}}Types:", "", cindent)
    for (name, type_id) in scope.types {
        let type = program.get_type(type_id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, program.type_name(type_id, debug_mode: true))
    }
    eprintln("{: >{}}Specializations:", "", cindent)
    for (name, type) in scope.explicitly_specialized_types {
        let type_name = program.type_name(type.type_id, debug_mode: true)
        mut args = ""
        for arg in type.arguments {
            args = args + program.type_name(arg, debug_mode: true) + ", "
        }

        eprintln("{: >{}}{}<{}> = {}", "", cindent + 2, name, args, type_name)
    }
    eprintln("{: >{}}Variables:", "", cindent)
    for (name, var_id) in scope.vars {
        let var = program.get_variable(var_id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, program.type_name(var.type_id, debug_mode: true))
    }
    eprintln("{: >{}}Functions:", "", cindent)
    for (name, ids) in scope.functions {
        eprintln("{: >{}}{}:", "", cindent + 2, name)
        for id in ids {
            let function = program.get_function(id)
            mut args = ""
            for arg in function.params {
                args = args + program.type_name(arg.variable.type_id, debug_mode: true) + ", "
            }

            mut generics = ""
            for generic in function.generics.params {
                generics = generics + program.type_name(generic.type_id(), debug_mode: true) + ", "
            }
            if not generics.is_empty() {
                generics = format("<{}>", generics)
            }

            eprintln("{: >{}}fn{}({}) -> {}", "", cindent + 4, generics, args, program.type_name(function.return_type_id, debug_mode: true))
        }
    }
    eprintln("{: >{}}Structs:", "", cindent)
    for (name, id) in scope.structs {
        let struct_ = program.get_struct(id)
        eprintln("{: >{}}{}@{}: {}", "", cindent + 2, id.id, id.module, struct_.name)
    }
    eprintln("{: >{}}Aliases:", "", cindent)
    for (name, id) in scope.aliases {
        let scope = program.get_scope(id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, scope.debug_name)
    }
    eprintln("{: >{}}Children:", "", cindent)
    for id in scope.children {
        dump_scope(id, program, indent: cindent + 2)
    }
}
