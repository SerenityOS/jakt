import compiler { Compiler }
import lexer { Lexer, Token }

fn concat<T>(anon xs: [T], anon y: T) throws -> [T] {
    mut ys: [T] = []
    ys.push_values(&xs)
    ys.push(y)
    return ys
}

fn init<T>(anon xs: [T]) throws -> [T] => xs[..(xs.size() - 1)].to_array()

fn collapse<T>(anon x: Optional<T>?) -> T? => match x.has_value() {
    true => x!
    false => None
}

enum Entity {
    Struct
    Enum
    Namespace
    Function(arrow: bool, indented: bool)

    fn from_token(token: &Token) -> Entity => match token {
        Struct | Class => Entity::Struct
        Enum => Entity::Enum
        Namespace => Entity::Namespace
        Comptime | Fn => Entity::Function(arrow: false, indented: false)
        else => Entity::Struct
    }
}

enum ExpressionMode {
    OutsideExpression
    BeforeExpressions
    AtExpressionStart
    InExpression
}

enum State {
    Toplevel(
        open_parens: usize
        open_curlies: usize
        open_squares: usize
    )
    Import(is_extern: bool)
    ImportList(emitted_comma: bool)
    EntityDeclaration(
        entity: Entity
        accept_generics: bool
        has_generics: bool
        generic_nesting: usize
    )
    ParameterList(open_parens: usize)
    RestrictionList
    EntityDefinition(entity: Entity)
    StatementContext(
        open_parens: usize
        open_curlies: usize
        open_squares: usize
        arrow_indents: usize
        allow_eol: usize?
        inserted_comma: bool
        expression_mode: ExpressionMode
        dedents_on_open_curly: usize
    )
    MatchPattern(
        open_parens: usize
        allow_multiple: bool
    )
    VariableDeclaration(
        open_parens: usize
    )
    GenericCallTypeParams(open_angles: usize)
    TypeContext(
        open_parens: usize
        open_curlies: usize
        open_squares: usize
        open_angles: usize
        seen_start: bool
    )
    FunctionTypeContext(seen_final_type: bool)

    fn name(this) throws -> String => match this {
        Toplevel => "toplevel"
        Import => "import"
        ImportList => "import list"
        EntityDeclaration => "entity declaration"
        ParameterList => "parameter list"
        RestrictionList => "restriction list"
        EntityDefinition => "entity definition"
        StatementContext => "statement context"
        MatchPattern => "match pattern"
        VariableDeclaration => "variable declaration"
        GenericCallTypeParams => "generic call type params"
        TypeContext(open_parens, open_curlies, open_squares, open_angles, seen_start) => format("type context (p{} c{} s{} a{} s:{})", open_parens, open_curlies, open_squares, open_angles, seen_start)
        FunctionTypeContext => "function type context"
    }
}

struct FormattedToken {
    token: Token
    indent: usize
    trailing_trivia: [u8]
    preceding_trivia: [u8]

    fn debug_text(this) throws -> String => match .token {
        Identifier(name) => format("Identifier: {}", name)
        Eol(comment) => format("Eol: {}", comment ?? ""),
        Eof => "Eof"
        else => .token_text()
    }

    fn token_text(this) throws -> String => match .token {
        SingleQuotedString(quote, prefix) => format("{}'{}'", prefix ?? "", quote)
        QuotedString(quote) => format("\"{}\"", quote)
        Number(prefix, number, suffix) => format("{}{}{}", prefix.to_string(), number, suffix.to_string())
        Identifier(name) => name
        Semicolon => ";"
        Colon => ":"
        ColonColon => "::"
        LParen => "("
        RParen => ")"
        LCurly => "{"
        RCurly => "}"
        LSquare => "["
        RSquare => "]"
        PercentSign => "%"
        Plus => "+"
        Minus => "-"
        Equal => "="
        PlusEqual => "+="
        PlusPlus => "++"
        MinusEqual => "-="
        MinusMinus => "--"
        AsteriskEqual => "*="
        ForwardSlashEqual => "/="
        PercentSignEqual => "%="
        NotEqual => "!="
        DoubleEqual => "=="
        GreaterThan => ">"
        GreaterThanOrEqual => ">="
        LessThan => "<"
        LessThanOrEqual => "<="
        LeftArithmeticShift => "<<<"
        LeftShift => "<<"
        LeftShiftEqual => "<<="
        RightShift => ">>"
        RightArithmeticShift => ">>>"
        RightShiftEqual => ">>="
        Asterisk => "*"
        Ampersand => "&"
        AmpersandEqual => "&="
        AmpersandAmpersand => "&&"
        Pipe => "|"
        PipeEqual => "|="
        PipePipe => "||"
        Caret => "^"
        CaretEqual => "^="
        Dollar => "$"
        Tilde => "~"
        ForwardSlash => "/"
        ExclamationPoint => "!"
        QuestionMark => "?"
        QuestionMarkQuestionMark => "??"
        QuestionMarkQuestionMarkEqual => "??="
        Comma => ","
        Dot => "."
        DotDot => ".."
        Eol => ""
        Eof => ""
        FatArrow => "=>"
        Arrow => "->"
        And => "and"
        Anon => "anon"
        As => "as"
        Boxed => "boxed"
        Break => "break"
        Catch => "catch"
        Class => "class"
        Continue => "continue"
        Cpp => "cpp"
        Defer => "defer"
        Destructor => "destructor"
        Else => "else"
        Enum => "enum"
        Extern => "extern"
        False => "false"
        For => "for"
        Fn => "fn"
        Comptime => "comptime"
        If => "if"
        Import => "import"
        In => "in"
        Is => "is"
        Let => "let"
        Loop => "loop"
        Match => "match"
        Mut => "mut"
        Namespace => "namespace"
        Not => "not"
        Or => "or"
        Private => "private"
        Public => "public"
        Raw => "raw"
        Return => "return"
        Restricted => "restricted"
        Sizeof => "sizeof"
        Struct => "struct"
        This => "this"
        Throw => "throw"
        Throws => "throws"
        True => "true"
        Try => "try"
        Unsafe => "unsafe"
        Weak => "weak"
        While => "while"
        Yield => "yield"
        Guard => "guard"
        Override => "override"
        Virtual => "virtual"
        Implements => "implements"
        Requires => "requires"
        Trait => "trait"
        Reflect => "reflect"
        Garbage => ""
    }
}

struct Stage0 {
    tokens: [Token]
    index: usize
    states: [State]
    indent: usize
    already_seen_enclosure_in_current_line: bool
    dedents_to_skip: [usize]
    debug: bool

    fn create(mut compiler: Compiler, source: [u8], debug: bool) throws -> Stage0 {
        let old_file_contents = compiler.current_file_contents
        compiler.current_file_contents = source
        defer {
            compiler.current_file_contents = old_file_contents
        }

        let tokens = Lexer::lex(compiler)
        return Stage0(
            tokens
            index: 0uz
            states: [State::Toplevel(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
            )]
            indent: 0uz
            already_seen_enclosure_in_current_line: false
            dedents_to_skip: [0uz]
            debug
        )
    }

    fn for_tokens(tokens: [Token], debug: bool) throws -> Stage0 {
        return Stage0(
            tokens
            index: 0uz
            states: [State::Toplevel(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
            )]
            indent: 0uz
            already_seen_enclosure_in_current_line: false
            dedents_to_skip: [0uz]
            debug
        )
    }

    private fn formatted_token(this, anon token: Token) throws -> FormattedToken {
        return FormattedToken(
            token
            indent: .indent
            trailing_trivia: []
            preceding_trivia: []
        )
    }

    private fn formatted_token(this, anon token: Token, trailing_trivia: [u8], preceding_trivia: [u8]) throws -> FormattedToken {
        return FormattedToken(
            token
            indent: .indent
            trailing_trivia
            preceding_trivia
        )
    }

    private fn peek(this, offset: i64 = 0) -> Token {
        let effective_index = match offset {
            0 => .index
            else => (.index as! i64 + offset - 1) as! usize
        }
        if effective_index >= .tokens.size() {
            return Token::Eof(.tokens.last()!.span())
        }

        return .tokens[effective_index]
    }

    private fn line_has_indent(this) -> bool {
        mut offset = 0

        loop {
            let token = .peek(offset)

            if token is LCurly {
                return true
            }

            if token is Eol or token is Eof {
                break
            }

            offset++
        }

        return false
    }

    private fn consume(mut this) -> Token => .tokens[.index++]
    fn state(this) -> State => .states.last()!
    private fn push_state(mut this, anon state: State) throws {
        .states.push(state)
    }
    private fn pop_state(mut this) {
        // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
        let dummy = .states.pop()
    }

    private fn replace_state(mut this, anon state: State) throws {
        // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
        let dummy = .states.pop()
        .states.push(state)
    }

    private fn to_array(anon x: String) throws -> [u8] {
        mut res: [u8] = []
        for i in 0..x.length() {
            res.push(x.byte_at(i))
        }
        return res
    }

    fn formatted_peek(mut this) throws -> FormattedToken? {
        let states_cache = .states[..].to_array()
        let index_cache = .index

        let token = .next_impl(reconsume: true)

        .index = index_cache
        .states = states_cache

        return token
    }

    fn next(mut this) throws -> FormattedToken? {
        return .next_impl(reconsume: false)
        // mut res = .next_impl(reconsume: false)
        // if not res.has_value() { return res }
        // return FormattedToken(
        //     token: res!.token
        //     indent: res!.indent
        //     trailing_trivia: Stage0::to_array(format("<?{}?>", .state().name()))
        //     preceding_trivia: res!.preceding_trivia
        // )
    }

    private fn next_in_toplevel_context(
        mut this
        open_parens: usize
        open_curlies: usize
        open_squares: usize
        token: Token
    ) throws -> FormattedToken? => match token {
        Enum | Class | Struct | Fn | Comptime | Namespace => {
            .push_state(State::EntityDeclaration(
                entity: Entity::from_token(&token)
                accept_generics: not token is Namespace
                has_generics: false
                generic_nesting: 0uz
            ))

            mut trailing_trivia: [u8] = []
            if token is Namespace or not .peek() is LessThan {
                trailing_trivia.push(b' ')
            }

            yield .formatted_token(token, trailing_trivia, preceding_trivia: [])
        }
        LSquare => {
            .replace_state(State::Toplevel(
                open_parens
                open_curlies
                open_squares: open_squares + 1
            ))
            yield .formatted_token(token)
        }
        RSquare => {
            if open_squares == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::Toplevel(
                open_parens
                open_curlies
                open_squares: open_squares - 1
            ))

            yield .formatted_token(token)
        }
        LParen => {
            .replace_state(State::Toplevel(
                open_parens: open_parens + 1
                open_curlies
                open_squares
            ))

            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::Toplevel(
                open_parens: open_parens - 1
                open_curlies
                open_squares
            ))

            yield .formatted_token(token)
        }
        LCurly => {
            .replace_state(State::Toplevel(
                open_parens
                open_curlies: open_curlies + 1
                open_squares
            ))
            yield .formatted_token(token, trailing_trivia: [], preceding_trivia: [b' '])
        }
        RCurly => {
            if open_curlies == 0 {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            .replace_state(State::Toplevel(
                open_parens
                open_curlies: open_curlies - 1
                open_squares
            ))

            yield .formatted_token(token)
        }
        Colon => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: true
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Import => {
            .push_state(State::Import(
                is_extern: .peek() is Extern
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Public | Private | Virtual | Override | Extern | Boxed => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Restricted => {
            .push_state(State::RestrictionList)
            yield .formatted_token(token)
        }
        Comma => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        else => .formatted_token(token)
    }

    private fn next_in_import_context(
        mut this
        is_extern: bool
        token: Token
    ) throws -> FormattedToken? => match token {
        Extern | As => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Identifier => {
            if not is_extern and .peek() is LParen {
                .push_state(State::StatementContext(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                    arrow_indents: 0
                    allow_eol: None
                    inserted_comma: false
                    expression_mode: ExpressionMode::AtExpressionStart
                    dedents_on_open_curly: 0
                ))
                return .formatted_token(token)
            }
            if not is_extern and not .peek() is LCurly and not .peek() is As {
                .pop_state()
            }

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        LCurly => {
            if is_extern {
                .push_state(State::Toplevel(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                ))
            } else {
                .push_state(State::ImportList(emitted_comma: true))
            }

            yield .formatted_token(token)
        }
        RCurly => {
            .pop_state()
            yield .formatted_token(token)
        }
        Comma => {
            yield .formatted_token(
                token
                trailing_trivia: match .peek() {
                    Eol => []
                    else => [b' ']
                }
                preceding_trivia: []
            )
        }
        else => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
    }

    private fn next_in_import_list_context(
        mut this
        emitted_comma: bool
        token: Token
    ) throws -> FormattedToken? => match token {
        RCurly => {
            .pop_state()
            .index--
            return .next_impl(reconsume: true)
        }
        Comma => {
            .replace_state(State::ImportList(emitted_comma: true))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Eol => {
            // Drop Eols, we'll regenerate them if needed.
            return .next()
        }
        else => {
            mut collection: [String] = []
            mut output = ""
            let span = token.span()
            mut local_token = token
            while not local_token is RCurly {
                if local_token is Identifier(name) {
                    collection.push(name)
                }
                local_token = .consume()
            }
            bubble_sort(collection)
            mut first = true
            mut overflow = false
            mut current_len = 0uz
            let indent_amount = 4uz
            for item in collection {
                if (current_len + item.length() + 2) > (120 - indent_amount) {
                    overflow = true
                    output += "\n"
                    for i in 0..indent_amount {
                        output += " "
                    }
                    current_len = indent_amount
                } else if not first {
                    output += ", "
                    current_len += 2
                } else {
                    first = false
                }
                output += item
                current_len += item.length()
            }

            if overflow {
                for i in 0..indent_amount {
                    output = " " + output
                }
                output = "\n" + output
                output += "\n"
            } else {
                output = " " + output + " "
            }

            .pop_state()
            .index--

            yield .formatted_token(Token::Identifier(name: output, span))
        }
    }

    private fn next_in_entity_declaration_context(
        mut this
        entity: Entity
        accept_generics: bool
        has_generics: bool
        generic_nesting: usize
        token: Token
    ) throws -> FormattedToken? => match token {
        LessThan => {
            if accept_generics {
                .replace_state(State::EntityDeclaration(
                    entity
                    accept_generics
                    has_generics: true
                    generic_nesting: generic_nesting + 1
                ))
            }

            yield .formatted_token(token)
        }
        GreaterThan => {
            if accept_generics {
                if generic_nesting > 1 {
                    .replace_state(State::EntityDeclaration(
                        entity
                        accept_generics
                        has_generics
                        generic_nesting: generic_nesting - 1
                    ))
                } else {
                    .replace_state(State::EntityDefinition(entity))
                }
            }

            yield .formatted_token(token)
        }
        Identifier => {
            if generic_nesting == 0 and not .peek() is LessThan and not has_generics {
                .replace_state(State::EntityDefinition(entity))
            }

            yield .formatted_token(token)
        }
        Comma => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        RCurly => {
            .pop_state()
            yield .formatted_token(token)
        }
        Eol => {
            .pop_state()
            yield .formatted_token(token)
        }
        Public | Private | Virtual | Override => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Restricted => {
            .push_state(State::RestrictionList)
            yield .formatted_token(token)
        }
        else => .formatted_token(token)
    }

    private fn next_in_entity_definition_context(
        mut this
        entity: Entity
        indent_change: &mut i64
        token: Token
    ) throws -> FormattedToken? => match entity {
        Enum | Struct | Namespace => match token {
            RCurly => {
                .pop_state()

                yield .formatted_token(
                    token
                    trailing_trivia: []
                    preceding_trivia: match .peek(offset: -1) {
                        Eol | LCurly => []
                        else => [b' ']
                    }
                )
            }
            LCurly => {
                .push_state(State::Toplevel(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                ))
                yield .formatted_token(
                    token
                    trailing_trivia: match .peek() {
                        Eol | RCurly => []
                        else => [b' ']
                    }
                    preceding_trivia: [b' ']
                )
            }
            Colon => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
            Equal => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
            Identifier => .formatted_token(token)
            else => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Function(arrow, indented) => match token {
            FatArrow => {
                let next_is_eol = .peek() is Eol

                .replace_state(State::EntityDefinition(
                    entity: Entity::Function(arrow: true, indented: next_is_eol)
                ))

                if next_is_eol {
                    if not .already_seen_enclosure_in_current_line {
                        .already_seen_enclosure_in_current_line = true
                        .dedents_to_skip.push(0uz)
                    }
                    indent_change += 1
                    .dedents_to_skip[.dedents_to_skip.size() - 1] += 1
                }

                mut eols_allowed: usize = 0
                if next_is_eol {
                    eols_allowed = 1
                }

                .push_state(State::StatementContext(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                    arrow_indents: 0
                    allow_eol: eols_allowed
                    inserted_comma: false
                    expression_mode: ExpressionMode::BeforeExpressions
                    dedents_on_open_curly: 0
                ))

                yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
            }
            Arrow => {
                .push_state(State::TypeContext(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                    open_angles: 0
                    seen_start: false
                ))
                yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
            }
            LParen => {
                .push_state(State::ParameterList(
                    open_parens: 0
                ))
                yield .formatted_token(token)
            }
            RParen => .formatted_token(
                token
                trailing_trivia: match .peek() {
                    Throws => [b' ']
                    else => []
                }
                preceding_trivia: []
            )
            LCurly => {
                .push_state(State::StatementContext(
                    open_parens: 0
                    open_curlies: 0
                    open_squares: 0
                    arrow_indents: 0
                    allow_eol: None
                    inserted_comma: false
                    expression_mode: ExpressionMode::OutsideExpression
                    dedents_on_open_curly: 0
                ))
                yield .formatted_token(token, trailing_trivia: [], preceding_trivia: [b' '])
            }
            RCurly => {
                .pop_state()
                yield .formatted_token(token)
            }
            Eol => {
                if not arrow {
                    // Ignore Eols if not arrow function
                    return .next()
                }

                .pop_state()
                if indented {
                    if .dedents_to_skip.last()! == 1uz {
                        if .dedents_to_skip.size() > 1uz {
                            // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                            let dummy = .dedents_to_skip.pop()
                        }
                        indent_change -= 1
                    } else if .dedents_to_skip.last()! > 0 {
                        .dedents_to_skip[.dedents_to_skip.size() - 1] -= 1
                    }
                }

                yield .formatted_token(token)
            }
            else => .formatted_token(token)
        }
    }

    private fn next_in_statement_context(
        mut this
        open_parens: usize
        open_curlies: usize
        open_squares: usize
        arrow_indents: usize
        allow_eol: usize?
        inserted_comma: bool
        expression_mode: ExpressionMode
        dedents_on_open_curly: usize
        indent_change: &mut i64
        token: Token
    ) throws -> FormattedToken? => match token {
        Let => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::OutsideExpression
                dedents_on_open_curly
            ))

            .push_state(State::VariableDeclaration(
                open_parens: 0
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Mut => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            if expression_mode is OutsideExpression {
                .push_state(State::VariableDeclaration(
                    open_parens: 0
                ))
            }
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Match | For | While | If | Try | Loop | Guard | Defer => {
            let added_indent = match token {
                Match | For | While | If | Guard => {
                    mut indent = 1uz
                    if .line_has_indent() {
                        indent = 0uz
                    }

                    yield indent
                }
                else => 0uz
            }
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly: dedents_on_open_curly + added_indent
            ))
            indent_change += (added_indent as! i64)

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Catch | Else => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::OutsideExpression
                dedents_on_open_curly
            ))

            yield .formatted_token(
                token
                trailing_trivia: match .peek() {
                    Eol | FatArrow | LParen => []
                    else => [b' ']
                }
                preceding_trivia: match .peek(offset: -1) {
                    Eol | Pipe => []
                    else => [b' ']
                }
            )
        }
        Eol => {
            if expression_mode is BeforeExpressions and .peek() is Eol {
                // Ignore repeated Eols
                return .next()
            }

            if (allow_eol.has_value() and allow_eol! == 0)
                and open_parens + open_curlies + open_squares == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            mut new_arrow_indents = arrow_indents
            mut new_allow_eol: usize? = allow_eol
            mut new_expression_mode = ExpressionMode::OutsideExpression
            if expression_mode is BeforeExpressions {
                new_expression_mode = ExpressionMode::BeforeExpressions
            } else {
                if allow_eol.has_value() and allow_eol! > 0 {
                    new_allow_eol = allow_eol! - 1
                }

                if arrow_indents > 0 {
                    if .dedents_to_skip.last()! == 1uz {
                        if .dedents_to_skip.size() > 1uz {
                            // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                            let dummy = .dedents_to_skip.pop()
                        }
                        indent_change -= 1
                    } else if .dedents_to_skip.last()! > 0 {
                        .dedents_to_skip[.dedents_to_skip.size() - 1] -= 1
                    }

                    new_arrow_indents--
                }
            }

            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents: new_arrow_indents
                allow_eol: new_allow_eol
                inserted_comma
                expression_mode: new_expression_mode
                dedents_on_open_curly
            ))
            yield .formatted_token(token)
        }
        Fn => {
            .push_state(State::FunctionTypeContext(
                seen_final_type: false
            ))

            yield .formatted_token(token)
        }
        Comma => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield match .peek() {
                Eol => .formatted_token(token)
                else => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
            }
        }
        Return | Throw | Yield => match .peek() {
            Semicolon | Eol => {
                .replace_state(State::StatementContext(
                    open_parens
                    open_curlies
                    open_squares
                    arrow_indents
                    allow_eol
                    inserted_comma
                    expression_mode: ExpressionMode::OutsideExpression
                    dedents_on_open_curly
                ))
                yield .formatted_token(token)
            }
            else => {
                .replace_state(State::StatementContext(
                    open_parens
                    open_curlies
                    open_squares
                    arrow_indents
                    allow_eol
                    inserted_comma
                    expression_mode: ExpressionMode::AtExpressionStart
                    dedents_on_open_curly
                ))

                yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
            }
        }
        FatArrow => {
            let next_is_eol = .peek() is Eol

            mut new_arrow_indents = arrow_indents
            if next_is_eol {
                if not .already_seen_enclosure_in_current_line {
                    .already_seen_enclosure_in_current_line = true
                    .dedents_to_skip.push(0uz)
                }
                indent_change += 1
                .dedents_to_skip[.dedents_to_skip.size() - 1] += 1
                new_arrow_indents++
            }

            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents: new_arrow_indents
                allow_eol
                inserted_comma
                expression_mode: match .peek() {
                    LCurly => ExpressionMode::OutsideExpression
                    else => ExpressionMode::BeforeExpressions
                }
                dedents_on_open_curly
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        LSquare => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares: open_squares + 1
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))
            yield .formatted_token(token)
        }
        RSquare => {
            if open_squares == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares: open_squares - 1
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield .formatted_token(token)
        }
        LParen => {
            .replace_state(State::StatementContext(
                open_parens: open_parens + 1
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::StatementContext(
                open_parens: open_parens - 1
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::InExpression
                dedents_on_open_curly
            ))

            yield .formatted_token(token)
        }
        LCurly => {
            mut dedented = 0uz
            if dedents_on_open_curly > 0 {
                .indent -= 1
                dedented = 1
            }
            .replace_state(State::StatementContext(
                open_parens
                open_curlies: open_curlies + 1
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly: dedents_on_open_curly - dedented
            ))

            yield .formatted_token(
                token
                trailing_trivia: match expression_mode {
                    AtExpressionStart | BeforeExpressions => []
                    else => match .peek() {
                        Eol | RCurly => []
                        else => [b' ']
                    }
                }
                preceding_trivia: match .peek(offset: -1) {
                    Else | Try | Catch | Equal | FatArrow | Loop | Defer => []
                    else => [b' ']
                }
            )
        }
        RCurly => {
            if open_curlies == 0 {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            .replace_state(State::StatementContext(
                open_parens
                open_curlies: open_curlies - 1
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::InExpression
                dedents_on_open_curly
            ))

            yield .formatted_token(
                token
                trailing_trivia: []
                preceding_trivia: match .peek(offset: -1) {
                    Eol | LCurly => []
                    else => [b' ']
                }
            )
        }
        Not => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Colon => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield .formatted_token(
                token
                trailing_trivia: match .peek() {
                    RSquare => []
                    else => [b' ']
                }
                preceding_trivia: []
            )
        }
        // Shared unary and binary ops
        Minus
        | Asterisk
        | Ampersand
        => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            let trivia: [u8] = match expression_mode {
                InExpression => [b' ']
                else => []
            }
            yield .formatted_token(token, trailing_trivia: trivia, preceding_trivia: trivia)
        }
        // Binary ops
        PercentSign
        | Plus
        | Equal
        | Pipe
        | PlusEqual
        | MinusEqual
        | AsteriskEqual
        | ForwardSlashEqual
        | PercentSignEqual
        | NotEqual
        | DoubleEqual
        | GreaterThan
        | GreaterThanOrEqual
        | LessThan
        | LessThanOrEqual
        | LeftArithmeticShift
        | LeftShift
        | RightShift
        | LeftShiftEqual
        | RightArithmeticShift
        | RightShiftEqual
        | AmpersandEqual
        | PipeEqual
        | Caret
        | CaretEqual
        | ForwardSlash
        | QuestionMarkQuestionMark
        | QuestionMarkQuestionMarkEqual
        | And
        | In
        | Or
        => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        Is => {
            .push_state(State::MatchPattern(
                open_parens: 0
                allow_multiple: false
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        As => .formatted_token(
            token
            trailing_trivia: match .peek() {
                QuestionMark | ExclamationPoint => []
                else => [b' ']
            }
            preceding_trivia: [b' ']
        )
        QuestionMark | ExclamationPoint => match .peek(offset: -1) {
            As => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
            else => .formatted_token(token)
        }
        Identifier | Number => {
            if .peek(offset: -1) is Identifier and not inserted_comma {
                // Insert a fake comma
                .index--
                .replace_state(State::StatementContext(
                    open_parens
                    open_curlies
                    open_squares
                    arrow_indents
                    allow_eol
                    inserted_comma: true
                    expression_mode: ExpressionMode::InExpression
                    dedents_on_open_curly
                ))
                return .formatted_token(token: Token::Comma(token.span()), trailing_trivia: [b' '], preceding_trivia: [])
            }
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma: false
                expression_mode: ExpressionMode::InExpression
                dedents_on_open_curly
            ))

            if .peek() is LParen {
                // This is a call, but we don't need to worry about it, just get out.
                return .formatted_token(token)
            }
            if not .peek() is LessThan {
                return .formatted_token(token)
            }
            // Scan forward, we can't guarantee full detection of generic calls as they need an infinite theoretical lookahead
            // to distinguish between a generic call and just LessThan/GreaterThan.
            // So we just look ahead for a balaned pair of LT/GT, followed immediately by an open paren.
            mut open_angles = 1
            mut lookahead_index = 2
            while open_angles > 0 {
                match .peek(offset: lookahead_index++) {
                    LessThan => { open_angles += 1 }
                    GreaterThan => { open_angles -= 1 }
                    Eol
                    | PercentSign
                    | Plus
                    | Minus
                    | Equal
                    | PlusEqual
                    | MinusEqual
                    | AsteriskEqual
                    | ForwardSlashEqual
                    | PercentSignEqual
                    | NotEqual
                    | DoubleEqual
                    | GreaterThanOrEqual
                    | LessThanOrEqual
                    | LeftArithmeticShift
                    | LeftShift
                    | RightShift
                    | LeftShiftEqual
                    | RightArithmeticShift
                    | RightShiftEqual
                    | Asterisk
                    | AmpersandEqual
                    | Pipe
                    | PipeEqual
                    | Caret
                    | CaretEqual
                    | ForwardSlash
                    | QuestionMarkQuestionMark
                    | QuestionMarkQuestionMarkEqual
                    | And
                    | In
                    | Is
                    | Or => { break }
                    else => {}
                }
            }
            if open_angles == 0 and .peek(offset: lookahead_index) is LParen {
                .push_state(State::GenericCallTypeParams(
                    open_angles: 0
                ))
            }

            yield .formatted_token(token)
        }
        Semicolon => {
            if open_squares == 0 {
                return match .peek() {
                    Eol => .next()
                    else => .formatted_token(Token::Eol(comment: None, span: token.span()))
                }
            }

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Raw => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        else => {
            .replace_state(State::StatementContext(
                open_parens
                open_curlies
                open_squares
                arrow_indents
                allow_eol
                inserted_comma
                expression_mode: ExpressionMode::InExpression
                dedents_on_open_curly
            ))

            yield .formatted_token(token)
        }
    }

    private fn next_in_generic_call_type_params_context(
        mut this
        open_angles: usize
        token: Token
    ) throws -> FormattedToken? => match token {
        LessThan => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))
            yield .formatted_token(token)
        }
        GreaterThan => {
            if open_angles <= 1 {
                .pop_state()
            } else {
                .replace_state(State::GenericCallTypeParams(
                    open_angles: open_angles - 1
                ))
            }

            yield .formatted_token(token)
        }
        Comma => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        else => .formatted_token(token)
    }

    private fn next_in_variable_declaration_context(
        mut this
        open_parens: usize
        token: Token
    ) throws -> FormattedToken? => match token {
        Colon => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        LParen => {
            .replace_state(State::VariableDeclaration(
                open_parens: open_parens + 1
            ))
            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }
            .replace_state(State::VariableDeclaration(
                open_parens: open_parens - 1
            ))
            yield .formatted_token(token)
        }
        Equal => {
            .pop_state()
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        Comma => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        else => .formatted_token(token)
    }

    private fn next_in_restriction_list_context(
        mut this
        token: Token
    ) throws -> FormattedToken? => match token {
        Comma => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        RParen => {
            .pop_state()
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        else => .formatted_token(token)
    }

    private fn next_in_parameter_list_context(
        mut this
        open_parens: usize
        token: Token
    ) throws -> FormattedToken? => match token {
        Anon | Mut => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Colon => {
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Comma => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Equal => {
            .push_state(State::StatementContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                arrow_indents: 0
                allow_eol: 0uz
                inserted_comma: false
                expression_mode: ExpressionMode::AtExpressionStart
                dedents_on_open_curly: 0
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        LParen => {
            .replace_state(State::ParameterList(
                open_parens: open_parens + 1
            ))

            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::ParameterList(
                open_parens: open_parens - 1
            ))

            yield .formatted_token(token)
        }
        else => .formatted_token(token)
    }

    private fn next_in_type_context(
        mut this
        open_parens: usize
        open_curlies: usize
        open_squares: usize
        open_angles: usize
        seen_start: bool
        token: Token
    ) throws -> FormattedToken? => match token {
        LessThan => {
            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles: open_angles + 1
                seen_start
            ))
            yield .formatted_token(token)
        }
        GreaterThan => {
            if open_angles == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles: open_angles - 1
                seen_start
            ))
            yield .formatted_token(token)
        }
        Eol => {
            if open_parens + open_curlies + open_squares + open_angles == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            yield .formatted_token(token)
        }
        LSquare => {
            if seen_start {
                .index--
                .pop_state()
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares: open_squares + 1
                open_angles
                seen_start: true
            ))

            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))

            yield .formatted_token(token)
        }
        RSquare => {
            if open_squares == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares: open_squares - 1
                open_angles
                seen_start
            ))

            yield .formatted_token(token)
        }
        LParen => {
            if seen_start {
                .index--
                .pop_state()
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens: open_parens + 1
                open_curlies
                open_squares
                open_angles
                seen_start: true
            ))

            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))

            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens: open_parens - 1
                open_curlies
                open_squares
                open_angles
                seen_start
            ))

            yield .formatted_token(token)
        }
        LCurly => {
            if seen_start {
                .index--
                .pop_state()
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens
                open_curlies: open_curlies + 1
                open_squares
                open_angles
                seen_start: true
            ))

            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))


            yield .formatted_token(token)
        }
        RCurly => {
            if open_curlies == 0 {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            .replace_state(State::TypeContext(
                open_parens
                open_curlies: open_curlies - 1
                open_squares
                open_angles
                seen_start
            ))

            yield .formatted_token(token)
        }
        Raw | Mut => {
            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles
                seen_start: true
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Ampersand => {
            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles
                seen_start: true
            ))
            yield .formatted_token(token)
        }
        Fn => {
            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles
                seen_start: true
            ))
            .push_state(State::FunctionTypeContext(
                seen_final_type: false
            ))
            yield .formatted_token(token)
        }
        Comma => {
            if open_angles + open_parens == 0 {
                .index--
                .pop_state()
                return .next_impl(reconsume: true)
            }

            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        }
        Identifier => {
            .replace_state(State::TypeContext(
                open_parens
                open_curlies
                open_squares
                open_angles
                seen_start: true
            ))
            yield .formatted_token(token)
        }
        Weak => .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [])
        Equal | Arrow | FatArrow => {
            .pop_state()
            .index--
            return .next_impl(reconsume: true)
        }
        else => .formatted_token(token)
    }

    private fn next_in_function_type_context(
        mut this
        seen_final_type: bool
        token: Token
    ) throws -> FormattedToken? => match token {
        FatArrow | LCurly => {
            .pop_state()
            .index--
            return .next_impl(reconsume: true)
        }
        Arrow => {
            if seen_final_type {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .replace_state(State::FunctionTypeContext(
                seen_final_type: true
            ))
            .push_state(State::TypeContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                open_angles: 0
                seen_start: false
            ))
            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        LParen => {
            if seen_final_type {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            .push_state(State::ParameterList(
                open_parens: 0
            ))
            yield .formatted_token(token)
        }
        RParen => {
            if seen_final_type {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            yield .formatted_token(
                token
                trailing_trivia: match .peek() {
                    Throws => [b' ']
                    else => []
                }
                preceding_trivia: []
            )
        }
        Throws => .formatted_token(token)
        else => {
            if seen_final_type {
                .pop_state()
                .index--
                return .next_impl(reconsume: true)
            }

            yield .formatted_token(token)
        }
    }

    private fn next_in_match_pattern_context(
        mut this
        open_parens: usize
        allow_multiple: bool
        token: Token
    ) throws -> FormattedToken? => match token {
        LParen => {
            .replace_state(State::MatchPattern(
                open_parens: open_parens + 1
                allow_multiple
            ))
            .push_state(State::StatementContext(
                open_parens: 0
                open_curlies: 0
                open_squares: 0
                arrow_indents: 0
                allow_eol: 0
                inserted_comma: false
                expression_mode: ExpressionMode::OutsideExpression
                dedents_on_open_curly: 0
            ))
            yield .formatted_token(token)
        }
        RParen => {
            if open_parens == 0 {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            .replace_state(State::MatchPattern(
                open_parens: open_parens - 1
                allow_multiple
            ))
            yield .formatted_token(token)
        }
        Eol => {
            if not allow_multiple {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            yield .formatted_token(token)
        }
        Identifier => .formatted_token(token)
        Pipe => {
            if not allow_multiple {
                .pop_state()
                .index -= 1
                return .next_impl(reconsume: true)
            }

            yield .formatted_token(token, trailing_trivia: [b' '], preceding_trivia: [b' '])
        }
        else => {
            .pop_state()
            .index -= 1
            return .next_impl(reconsume: true)
        }
    }

    fn next_impl(mut this, reconsume: bool) throws -> FormattedToken? {
        if .index >= .tokens.size() {
            return None
        }

        if .states.is_empty() and .index < .tokens.size() {
            abort()
        }

        mut token = .consume()
        mut indent_change = 0
        if not reconsume {
            if (not .already_seen_enclosure_in_current_line) and (
                token is LParen or token is LCurly or token is LSquare
            ) {
                .already_seen_enclosure_in_current_line = true
                .dedents_to_skip.push(0uz)
                indent_change = 1
            } else if token is Eol {
                .already_seen_enclosure_in_current_line = false
            }

            if token is LParen or token is LCurly or token is LSquare {
                .dedents_to_skip[.dedents_to_skip.size() - 1]++
            }

            if token is RParen or token is RCurly or token is RSquare {
                // Immediately dedent to the previous level instead of deferring the change.
                if .dedents_to_skip.last()! == 1uz {
                    if .dedents_to_skip.size() > 1uz {
                        // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
                        let dummy = .dedents_to_skip.pop()
                    }
                    .indent -= 1
                    .already_seen_enclosure_in_current_line = false
                } else if .dedents_to_skip.last()! > 0 {
                    .dedents_to_skip[.dedents_to_skip.size() - 1] -= 1
                }
            }
        }

        defer {
            if indent_change > 0 {
                .indent += indent_change as! usize
            } else if indent_change < 0 {
                .indent -= (-indent_change) as! usize
            }
        }

        if .debug {
            eprintln()
            eprintln(
                "Token: {} -- Indent: {}",
                FormattedToken(token, indent: 0, trailing_trivia: [], preceding_trivia: []).debug_text(),
                .indent
            )
            for state in .states {
                eprintln("- State: {}", state)
            }
            eprintln()
        }

        return match .state() {
            Toplevel(open_parens, open_curlies, open_squares) => .next_in_toplevel_context(open_parens, open_curlies, open_squares, token)
            Import(is_extern) => .next_in_import_context(is_extern, token)
            ImportList(emitted_comma) => .next_in_import_list_context(emitted_comma, token)
            EntityDeclaration(entity, accept_generics, has_generics, generic_nesting) => .next_in_entity_declaration_context(entity, accept_generics, has_generics, generic_nesting, token)
            EntityDefinition(entity) => .next_in_entity_definition_context(entity, &mut indent_change, token)
            StatementContext(open_parens, open_curlies, open_squares, arrow_indents, allow_eol, inserted_comma, expression_mode, dedents_on_open_curly) => .next_in_statement_context(open_parens, open_curlies, open_squares, arrow_indents, allow_eol, inserted_comma, expression_mode, dedents_on_open_curly, &mut indent_change, token)
            GenericCallTypeParams(open_angles) => .next_in_generic_call_type_params_context(open_angles, token)
            VariableDeclaration(open_parens) => .next_in_variable_declaration_context(open_parens, token)
            RestrictionList => .next_in_restriction_list_context(token)
            ParameterList(open_parens) => .next_in_parameter_list_context(open_parens, token)
            TypeContext(open_parens, open_curlies, open_squares, open_angles, seen_start) => .next_in_type_context(open_parens, open_curlies, open_squares, open_angles, seen_start, token)
            FunctionTypeContext(seen_final_type) => .next_in_function_type_context(seen_final_type, token)
            MatchPattern(open_parens, allow_multiple) => .next_in_match_pattern_context(open_parens, allow_multiple, token)
        }
    }
}

enum BreakablePoint {
    Paren(point: usize, length: usize)
    Curly(point: usize, length: usize)
    Square(point: usize, length: usize)
    Logical(point: usize, length: usize)

    fn point(this) -> usize => match this {
        Paren(point)
        | Curly(point)
        | Square(point)
        | Logical(point)
        => point
    }

    fn length(this) -> usize => match this {
        Paren(length)
        | Curly(length)
        | Square(length)
        | Logical(length)
        => length
    }
}

struct ReflowState {
    token: FormattedToken
    state: State
    enclosures_to_ignore: usize
}

struct Formatter implements(ThrowingIterable<[FormattedToken]>) {
    token_provider: Stage0
    current_line: [ReflowState]
    current_line_length: usize
    max_allowed_line_length: usize
    breakable_points_in_current_line: [BreakablePoint]
    tokens_to_reflow: [ReflowState]
    replace_commas_in_enclosure: [Token?]
    enclosures_to_ignore: usize
    in_condition_expr: bool
    in_condition_expr_indented: bool
    logical_break_indent: usize?
    empty_line_count: usize

    fn for_tokens(tokens: [Token], debug: bool = false, max_allowed_line_length: usize = 120uz) throws -> Formatter {
        let none: Token? = None
        return Formatter(
            token_provider: Stage0::for_tokens(tokens, debug)
            current_line: []
            current_line_length: 0
            max_allowed_line_length
            breakable_points_in_current_line: []
            tokens_to_reflow: []
            replace_commas_in_enclosure: [none]
            enclosures_to_ignore: 0
            in_condition_expr: false
            in_condition_expr_indented: false
            logical_break_indent: None
            empty_line_count: 0
        )
    }

    private fn token_length(this, token: FormattedToken) throws -> usize {
        mut length = token.preceding_trivia.size()
        match token.token {
            Eol(comment) => {
                if comment.has_value() {
                    mut next_char = b' '
                    if comment!.length() != 0 {
                        next_char = comment!.byte_at(0)
                    }
                    let space = match next_char {
                        b' ' | b'\t' | b'/' => 0uz
                        else => 1uz
                    }
                    length += space
                    length += comment!.length()
                }
            }
            else => {
                length += token.token_text().length()
            }
        }
        length += token.trailing_trivia.size()
        return length
    }

    private fn fixup_tokens_to_reflow(mut this) throws {
        if .tokens_to_reflow.is_empty() {
            return
        }

        mut i = 0uz
        mut j = .tokens_to_reflow.size() - 1uz
        while i < j {
            let a = .tokens_to_reflow[i]
            .tokens_to_reflow[i] = .tokens_to_reflow[j]
            .tokens_to_reflow[j] = a

            i += 1
            j -= 1
        }
    }

    private fn to_array(anon s: String) throws -> [u8] {
        mut result: [u8] = []
        for i in 0..s.length() {
            result.push(s.byte_at(i))
        }
        return result
    }

    fn fixup_closing_enclosures(this, line: &mut [ReflowState]) throws {
        if line.is_empty() {
            return
        }

        // No trivia if we start with this token.
        line[0].token.preceding_trivia = []

        mut enclosure_run_length = 0uz
        for i in (line.size() - 1)..0uz {
            match line[i].token.token {
                RParen | RCurly | RSquare => {
                    enclosure_run_length += 1
                }
                else => {
                    for j in 0..enclosure_run_length {
                        line[i - j].token = FormattedToken(
                            token: line[i - j].token.token
                            indent: line[i - enclosure_run_length].token.indent
                            trailing_trivia: line[i - j].token.trailing_trivia
                            preceding_trivia: line[i - j].token.preceding_trivia
                        )
                    }
                    enclosure_run_length = 0
                }
            }
        }
        for j in 0..enclosure_run_length {
            line[j].token = FormattedToken(
                token: line[j].token.token
                indent: line[enclosure_run_length].token.indent
                trailing_trivia: line[j].token.trailing_trivia
                preceding_trivia: line[j].token.preceding_trivia
            )
        }

        // for j in 0..line.size() {
        //     line[j].token.trailing_trivia = Formatter::to_array(format("<?{}?>\n", line[j].state.name()))
        // }
    }

    private fn pick_breaking_point_index(this) -> usize {
        // Leftmost point.
        return 0
    }

    private fn should_ignore_state(anon state: State) -> bool {
        return state is TypeContext or state is VariableDeclaration
    }

    fn peek(mut this) throws -> FormattedToken? {
        mut reflown_token: ReflowState? = None
        if .tokens_to_reflow.size() > 0 {
            reflown_token = .tokens_to_reflow[.tokens_to_reflow.size() - 1]
        }

        return reflown_token?.token ?? .token_provider.formatted_peek()
    }

    fn next(mut this) throws -> [FormattedToken]? {
        let reflown_token = .tokens_to_reflow.pop()
        mut maybe_next_underlying_token = reflown_token?.token ?? .token_provider.next()
        mut current_state = reflown_token?.state ?? .token_provider.state()

        guard maybe_next_underlying_token.has_value() else {
            if .current_line.is_empty() {
                return None
            }
            let line = .current_line
            .current_line = []
            .breakable_points_in_current_line = []
            .current_line_length = 0
            .enclosures_to_ignore = 0
            .in_condition_expr = false
            .in_condition_expr_indented = false
            .logical_break_indent = None
            mut result: [FormattedToken] = []
            for state in line {
                result.push(state.token)
            }

            return result
        }
        mut next_underlying_token = maybe_next_underlying_token!.token
        mut accepted_at_least_one_token = false
        while not next_underlying_token is Eof and not next_underlying_token is Eol {
            let projected_added_length = .token_length(token: maybe_next_underlying_token!)
            if .logical_break_indent.has_value() {
                maybe_next_underlying_token!.indent = .logical_break_indent!
            }

            if .in_condition_expr and next_underlying_token is LCurly or next_underlying_token is Else {
                .in_condition_expr = false
                .in_condition_expr_indented = false
            }

            match next_underlying_token {
                LParen | LCurly | LSquare => {
                    accepted_at_least_one_token = true
                    .current_line.push(ReflowState(
                        token: maybe_next_underlying_token!
                        state: current_state
                        enclosures_to_ignore: .enclosures_to_ignore
                    ))
                    .current_line_length += projected_added_length
                    if not Formatter::should_ignore_state(current_state) {
                        let next_token: FormattedToken? = .peek()

                        mut breakable_point: BreakablePoint? = None
                        if next_token.has_value() {
                            let a = 1
                            breakable_point = match next_underlying_token {
                                LParen => match next_token!.token {
                                    RParen => None
                                    else => BreakablePoint::Paren(point: .current_line.size(), length: .current_line_length)
                                }
                                LCurly => match next_token!.token {
                                    RCurly => None
                                    else => BreakablePoint::Curly(point: .current_line.size(), length: .current_line_length)
                                }
                                LSquare => match next_token!.token {
                                    RSquare => None
                                    else => BreakablePoint::Square(point: .current_line.size(), length: .current_line_length)
                                }
                                else => {
                                    abort() // unreachable
                                }
                            }
                        } else {
                            breakable_point = match next_underlying_token {
                                LParen => BreakablePoint::Paren(point: .current_line.size(), length: .current_line_length)
                                LCurly => BreakablePoint::Curly(point: .current_line.size(), length: .current_line_length)
                                LSquare => BreakablePoint::Square(point: .current_line.size(), length: .current_line_length)
                                else => {
                                    abort() // unreachable
                                }
                            }
                        }

                        if breakable_point.has_value() {
                            .breakable_points_in_current_line.push(breakable_point!)
                        }

                        let none: Token? = None
                        .replace_commas_in_enclosure.push(none)
                    } else {
                        .enclosures_to_ignore += 1
                    }
                }
                RParen | RCurly | RSquare => {
                    mut ignore = false
                    if .enclosures_to_ignore > 0 {
                        .enclosures_to_ignore -= 1
                        ignore = true
                    }

                    if not ignore and not Formatter::should_ignore_state(current_state) {
                        let replacement = collapse(.replace_commas_in_enclosure.pop()) ?? next_underlying_token
                        let new_token = FormattedToken(
                            token: replacement
                            indent: maybe_next_underlying_token!.indent
                            trailing_trivia: maybe_next_underlying_token!.trailing_trivia
                            preceding_trivia: maybe_next_underlying_token!.preceding_trivia
                        )
                        .current_line.push(ReflowState(
                            token: new_token
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: new_token)
                        if replacement is Eol {
                            .tokens_to_reflow.push(ReflowState(
                                token: maybe_next_underlying_token!
                                state: current_state
                                enclosures_to_ignore: .enclosures_to_ignore
                            ))
                            let none: Token? = None
                            .replace_commas_in_enclosure.push(none)
                            break
                        }
                    } else {
                        .current_line.push(ReflowState(
                            token: maybe_next_underlying_token!
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: maybe_next_underlying_token!)
                    }
                    accepted_at_least_one_token = true
                }
                Comma => {
                    accepted_at_least_one_token = true
                    if not Formatter::should_ignore_state(current_state) {
                        let replacement = collapse(.replace_commas_in_enclosure.last()) ?? next_underlying_token
                        let new_token = FormattedToken(
                            token: replacement
                            indent: maybe_next_underlying_token!.indent
                            trailing_trivia: maybe_next_underlying_token!.trailing_trivia
                            preceding_trivia: maybe_next_underlying_token!.preceding_trivia
                        )
                        .current_line.push(ReflowState(
                            token: new_token
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: new_token)

                        if replacement is Eol {
                            break
                        }
                    } else {
                        .current_line.push(ReflowState(
                            token: maybe_next_underlying_token!
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: maybe_next_underlying_token!)
                    }
                }
                else => {
                    let newline = Token::Eol(
                        comment: None
                        span: next_underlying_token.span()
                    )

                    match next_underlying_token {
                        Match | For | While | If | Guard => {
                            .in_condition_expr = true
                            .in_condition_expr_indented = false

                            let next_token: FormattedToken? = .peek()
                            if next_token.has_value() {
                                if next_token!.indent > maybe_next_underlying_token!.indent {
                                    .in_condition_expr_indented = true
                                }
                            }
                        }
                        else => {}
                    }

                    if .logical_break_indent.has_value() and (next_underlying_token is And or next_underlying_token is Or) {
                        .current_line.push(ReflowState(
                            token: maybe_next_underlying_token!
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: maybe_next_underlying_token!)

                        let new_token = FormattedToken(
                            token: newline
                            indent: .logical_break_indent!
                            trailing_trivia: []
                            preceding_trivia: []
                        )
                        .current_line.push(ReflowState(
                            token: new_token
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length += .token_length(token: new_token)

                        break
                    }

                    let real_line_length = .current_line_length + projected_added_length + maybe_next_underlying_token!.indent
                    let most_desirable_breaking_point_index = .pick_breaking_point_index()

                    if accepted_at_least_one_token
                        and real_line_length > .max_allowed_line_length
                        and not .breakable_points_in_current_line.is_empty()
                        and .breakable_points_in_current_line[most_desirable_breaking_point_index].point() < .current_line.size()
                        and not Formatter::should_ignore_state(current_state) {

                        let breakable_point = .breakable_points_in_current_line[most_desirable_breaking_point_index]
                        if not .replace_commas_in_enclosure.is_empty() {
                            .replace_commas_in_enclosure[.replace_commas_in_enclosure.size() - 1] = newline
                        }
                        let point = breakable_point.point()

                        if breakable_point is Logical {
                            if not .logical_break_indent.has_value() {
                                .logical_break_indent = .current_line[point].token.indent
                                if not .in_condition_expr_indented {
                                    .logical_break_indent! += 1
                                }
                            }
                        }

                        .tokens_to_reflow = .current_line[point..].to_array()
                        .tokens_to_reflow.push(ReflowState(
                            token: maybe_next_underlying_token!
                            state: current_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .fixup_tokens_to_reflow()

                        let final_state = .current_line[point].state
                        .enclosures_to_ignore = .current_line[point].enclosures_to_ignore
                        .current_line = .current_line[0..point].to_array()

                        .current_line.push(ReflowState(
                            token: FormattedToken(
                                token: newline
                                indent: maybe_next_underlying_token!.indent
                                trailing_trivia: []
                                preceding_trivia: []
                            )
                            state: final_state
                            enclosures_to_ignore: .enclosures_to_ignore
                        ))
                        .current_line_length = 0
                        break
                    }

                    accepted_at_least_one_token = true
                    .current_line.push(ReflowState(
                        token: maybe_next_underlying_token!
                        state: current_state
                        enclosures_to_ignore: .enclosures_to_ignore
                    ))
                    .current_line_length += projected_added_length

                    if .in_condition_expr and (next_underlying_token is And or next_underlying_token is Or) {
                        .breakable_points_in_current_line.push(
                            BreakablePoint::Logical(point: .current_line.size(), length: .current_line_length)
                        )
                    }
                }
            }

            if .tokens_to_reflow.is_empty() {
                maybe_next_underlying_token = .token_provider.next()
                current_state = .token_provider.state()
            } else {
                let reflown_token = .tokens_to_reflow.pop()
                maybe_next_underlying_token = reflown_token?.token
                current_state = reflown_token?.state ?? current_state
            }

            if not maybe_next_underlying_token.has_value() {
                break
            }

            next_underlying_token = maybe_next_underlying_token!.token
        }

        let allowed_empty_lines_in_state: usize = match current_state {
            TypeContext | ImportList | ParameterList => 0
            Toplevel => 2
            else => 1
        }

        mut line = .current_line
        .current_line = []
        .breakable_points_in_current_line = []
        .current_line_length = 0
        .enclosures_to_ignore = 0
        if not .in_condition_expr {
            .logical_break_indent = None
        }

        if line.is_empty() or not line.last()!.token.token is Eol {
            line.push(ReflowState(
                token: maybe_next_underlying_token!
                state: current_state
                enclosures_to_ignore: .enclosures_to_ignore
            ))
        }

        if line.size() == 1 {
            match line.last()!.token.token {
                Eol(comment) => {
                    if .empty_line_count >= allowed_empty_lines_in_state and not comment.has_value() {
                        // Collapse more than |allowed_empty_lines_in_state| consecutive empty lines.
                        return .next()
                    }

                    if comment.has_value() {
                        .empty_line_count = 0
                    } else {
                        .empty_line_count += 1
                    }
                }
                else => {
                    .empty_line_count = 0
                }
            }
        } else {
            .empty_line_count = 0
        }

        if line.size() > 1 {
            // Drop the trailing trivia of the token before EoL.
            line[line.size() - 2].token.trailing_trivia = []
        }

        // As well as all the trivia of the EoL token itself
        line[line.size() - 1].token.preceding_trivia = []
        line[line.size() - 1].token.trailing_trivia = []

        .fixup_closing_enclosures(&mut line)

        mut result: [FormattedToken] = []
        for state in line {
            result.push(state.token)
        }

        return result
    }
}

fn bubble_sort(anon mut values: [String]) {
    mut i = 0
    while i < values.size() as! i64 - 1 {
        mut j = 0
        while j < (values.size() as! i64) - i - 1 {
            if values[j] > values[j + 1] {
                let tmp = values[j]
                values[j] = values[j + 1]
                values[j + 1] = tmp
            }
            ++j
        }
        ++i
    }
}
