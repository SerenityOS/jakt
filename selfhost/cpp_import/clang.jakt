import types {
    BlockControlFlow, CheckedBlock, CheckedEnum, CheckedEnumVariant, CheckedField, CheckedFunction
    CheckedGenericParameter, CheckedParameter, CheckedProgram, CheckedStruct, CheckedVariable, CheckedVisibility
    DefinitionLinkage, EnumId, ExternalName, FileId, FunctionGenericParameter, FunctionGenericParameterKind
    FunctionGenerics, FunctionLinkage, ModuleId, ScopeId, SpecializedType, StructId, Type, TypeId, Value, ValueImpl
    unknown_type_id
}
import parser {
    FunctionType, ParsedField, ParsedVarDecl, RecordType, ParsedType
}
import compiler { Compiler }
import jakt::path { Path, get_path_separator }
import utility { Span, join }
import cpp_import::common { CppImportErrors, read_all }
import jakt::platform::utility { null }
import jakt::platform { platform_fs }
import platform_fs() { real_path }
import cpp_import::clang_c {
    CXChildVisitResult, CXClientData, CXCursor, CXCursorKind, CXFile, CXIndex, CXSourceLocation, CXString
    CXTranslationUnit, CXTranslationUnit_Flags, CXType, CXTypeKind, CXUnsavedFile, CXToken, CXTokenKind
}
import cpp_import::clang_c {
    clang_CXXMethod_isConst, clang_CXXMethod_isPureVirtual, clang_CXXMethod_isStatic, clang_CXXMethod_isVirtual
    clang_Cursor_Evaluate, clang_Cursor_getNumTemplateArguments, clang_Cursor_getTranslationUnit
    clang_Cursor_isMacroFunctionLike, clang_Cursor_isNull, clang_EvalResult_dispose, clang_EvalResult_getAsDouble
    clang_EvalResult_getAsInt, clang_EvalResult_getAsLongLong, clang_EvalResult_getAsStr
    clang_EvalResult_getAsUnsigned, clang_EvalResult_getKind, clang_EvalResult_isUnsignedInt
    clang_Type_getNamedType, clang_createIndex, clang_createTranslationUnit, clang_disposeIndex, clang_disposeString
    clang_disposeTokens, clang_disposeTranslationUnit, clang_equalCursors, clang_getArgType, clang_getCString
    clang_getCanonicalCursor, clang_getCanonicalType, clang_getCursorDefinition, clang_getCursorExtent
    clang_getCursorKind, clang_getCursorKindSpelling, clang_getCursorLocation, clang_getCursorPrettyPrinted
    clang_getCursorPrintingPolicy, clang_getCursorResultType, clang_getCursorSemanticParent, clang_getCursorSpelling
    clang_getCursorType, clang_getCursorUSR, clang_getEnumDeclIntegerType, clang_getFileName, clang_getNumArgTypes
    clang_getPointeeType, clang_getResultType, clang_getSpecializedCursorTemplate, clang_getSpellingLocation
    clang_getTemplateCursorKind, clang_getTokenKind, clang_getTokenSpelling, clang_getTranslationUnitCursor
    clang_getTypeDeclaration, clang_getTypeKindSpelling, clang_getTypeSpelling, clang_getTypedefDeclUnderlyingType
    clang_isCursorDefinition, clang_isDeclaration, clang_isExpression, clang_parseTranslationUnit2
    clang_saveTranslationUnit, clang_tokenize, clang_visitChildren
}
import utility { allocate }
import extern c "stdlib.h" {
    extern fn free(anon ptr: raw c_char)
}

fn bitcast<D, S>(anon value: S) -> D {
    mut x = null<D>()
    let f = fn[&x, &value]() {
        unsafe { cpp { "x = bit_cast<RemoveReference<decltype(x)>>(value);" } }
    }
    f()
    return x
}

fn name_from(anon cursor: CXCursor) throws -> String {
    let spelling = clang_getCursorSpelling(cursor)
    return string_from(spelling)
}

fn string_from(anon string: CXString, dispose: bool = true) throws -> String {
    defer {
        if dispose {
            clang_disposeString(string)
        }
    }

    mut value: StringView = ""
    unsafe { cpp {
        "value = { clang_getCString(string), strlen(clang_getCString(string)) };"
    } }
    return String::from_string_literal(value)
}

fn const_value_from(
    program: &mut CheckedProgram
    scope_id: ScopeId
    module_id: ModuleId
    anon cursor: CXCursor
) throws -> Value {
    if not clang_isExpression(clang_getCursorKind(cursor)) {
        eprintln(
            "[ICE] Const type input '{}' is not an expression, it's a {}"
            name_from(cursor)
            string_from(clang_getCursorKindSpelling(clang_getCursorKind(cursor)))
        )
        return Value(
            impl: ValueImpl::Void,
            span: empty_span()
        )
    }

    let eval_result = clang_Cursor_Evaluate(cursor)
    defer clang_EvalResult_dispose(eval_result)

    let value_impl = match clang_EvalResult_getKind(eval_result) {
        CXEval_Int => match clang_EvalResult_isUnsignedInt(eval_result) {
            true => cast_to_type(clang_EvalResult_getAsUnsigned(eval_result) as! u64, clang_getCursorType(cursor))
            false => cast_to_type(clang_EvalResult_getAsLongLong(eval_result) as! i64, clang_getCursorType(cursor))
        }
        CXEval_UnExposed => cast_to_type(clang_EvalResult_getAsInt(eval_result) as! i64, clang_getCursorType(cursor))
        CXEval_Float => cast_to_type(clang_EvalResult_getAsDouble(eval_result), clang_getCursorType(cursor))
        CXEval_StrLiteral
        | CXEval_ObjCStrLiteral
        | CXEval_CFStr
        | CXEval_Other => {
            eprintln("Const value input kind {} not supported", clang_EvalResult_getKind(eval_result) as! c_int)
            return Value(
                impl: ValueImpl::Void,
                span: empty_span()
            )
        }
    }

    return Value(impl: value_impl, span: empty_span())
}

fn const_type_from(
    program: &mut CheckedProgram
    scope_id: ScopeId
    module_id: ModuleId
    anon cursor: CXCursor
) throws -> TypeId {
    let value = const_value_from(program, scope_id, module_id, cursor)
    return program.find_or_add_type_id(type: Type::Const(value), module_id)
}

fn cpp_static_cast<T, U>(value: U) -> T {
    mut x = null<T>()
    unsafe { cpp { "x = static_cast<decltype(x)>(value);" } }
    return x
}

fn cast_to_type(
    anon value: i64
    anon type: CXType
) throws -> ValueImpl => match clang_getCanonicalType(type).kind {
    CXType_Bool => ValueImpl::Bool(cpp_static_cast<bool>(value))
    CXType_Char_U => ValueImpl::U8(cpp_static_cast<u8>(value))
    CXType_UChar => ValueImpl::U8(cpp_static_cast<u8>(value))
    CXType_Char16 => ValueImpl::U16(cpp_static_cast<u16>(value))
    CXType_Char32 => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_UShort => ValueImpl::U16(cpp_static_cast<u16>(value))
    CXType_UInt => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_ULong => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_ULongLong => ValueImpl::U64(cpp_static_cast<u64>(value))
    CXType_Char_S => ValueImpl::I8(cpp_static_cast<i8>(value))
    CXType_SChar => ValueImpl::I8(cpp_static_cast<i8>(value))
    CXType_Short => ValueImpl::I16(cpp_static_cast<i16>(value))
    CXType_Int => ValueImpl::I32(cpp_static_cast<i32>(value))
    CXType_Long => ValueImpl::I32(cpp_static_cast<i32>(value))
    CXType_LongLong => ValueImpl::I64(cpp_static_cast<i64>(value))
    else => ValueImpl::Void
}

fn cast_to_type(
    anon value: u64
    anon type: CXType
) throws -> ValueImpl => match clang_getCanonicalType(type).kind {
    CXType_Bool => ValueImpl::Bool(cpp_static_cast<bool>(value))
    CXType_Char_U => ValueImpl::U8(cpp_static_cast<u8>(value))
    CXType_UChar => ValueImpl::U8(cpp_static_cast<u8>(value))
    CXType_Char16 => ValueImpl::U16(cpp_static_cast<u16>(value))
    CXType_Char32 => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_UShort => ValueImpl::U16(cpp_static_cast<u16>(value))
    CXType_UInt => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_ULong => ValueImpl::U32(cpp_static_cast<u32>(value))
    CXType_ULongLong => ValueImpl::U64(cpp_static_cast<u64>(value))
    CXType_Char_S => ValueImpl::I8(cpp_static_cast<i8>(value))
    CXType_SChar => ValueImpl::I8(cpp_static_cast<i8>(value))
    CXType_Short => ValueImpl::I16(cpp_static_cast<i16>(value))
    CXType_Int => ValueImpl::I32(cpp_static_cast<i32>(value))
    CXType_Long => ValueImpl::I32(cpp_static_cast<i32>(value))
    CXType_LongLong => ValueImpl::I64(cpp_static_cast<i64>(value))
    else => ValueImpl::Void
}

fn cast_to_type(
    anon value: f64
    anon type: CXType
) throws -> ValueImpl => match clang_getCanonicalType(type).kind {
    CXType_Float => ValueImpl::F32(cpp_static_cast<f32>(value))
    CXType_Double => ValueImpl::F64(value)
    else => ValueImpl::Void
}

fn type_from(
    program: &mut CheckedProgram
    scope_id: ScopeId
    module_id: ModuleId
    anon t: CXType
) throws -> TypeId {
    return match t.kind {
        CXType_Void => program.find_or_add_type_id(type: Type::Void, module_id)
        CXType_Bool => program.find_or_add_type_id(type: Type::Bool, module_id)
        CXType_Char_U => program.find_or_add_type_id(type: Type::U8, module_id)
        CXType_UChar => program.find_or_add_type_id(type: Type::U8, module_id)
        CXType_Char16 => program.find_or_add_type_id(type: Type::U16, module_id)
        CXType_Char32 => program.find_or_add_type_id(type: Type::U32, module_id)
        CXType_UShort => program.find_or_add_type_id(type: Type::U16, module_id)
        CXType_UInt => program.find_or_add_type_id(type: Type::U32, module_id)
        CXType_ULong => program.find_or_add_type_id(type: Type::U32, module_id)
        CXType_ULongLong => program.find_or_add_type_id(type: Type::U64, module_id)
        CXType_Char_S => program.find_or_add_type_id(type: Type::CChar, module_id)
        CXType_SChar => program.find_or_add_type_id(type: Type::I8, module_id)
        CXType_Short => program.find_or_add_type_id(type: Type::I16, module_id)
        CXType_Int => program.find_or_add_type_id(type: Type::CInt, module_id)
        CXType_Long => program.find_or_add_type_id(type: Type::I32, module_id)
        CXType_LongLong => program.find_or_add_type_id(type: Type::I64, module_id)
        CXType_Float => program.find_or_add_type_id(type: Type::F32, module_id)
        CXType_Double => program.find_or_add_type_id(type: Type::F64, module_id)
        CXType_Typedef => {
            let typedef_name = string_from(clang_getTypeSpelling(t))
            let type_id = program.find_type_in_scope(
                scope_id
                name: typedef_name
            )
            if type_id.has_value() {
                return type_id!
            }

            yield type_from(program, scope_id, module_id, clang_getCanonicalType(t))
        }
        CXType_Pointer => {
            let pointee_type = clang_getPointeeType(t)
            yield match pointee_type.kind {
                CXType_FunctionProto | CXType_FunctionNoProto => type_from(program, scope_id, module_id, pointee_type)
                else => program.find_or_add_type_id(
                    type: Type::RawPtr(
                        type_from(program, scope_id, module_id, clang_getPointeeType(t))
                    )
                    module_id
                )
            }
        }
        CXType_Record => {
            let struct_id = program.find_struct_in_scope(
                scope_id
                name: name_from(clang_getTypeDeclaration(t))
            )
            yield match struct_id.has_value() {
                true => program.find_or_add_type_id(Type::Struct(struct_id!), module_id)
                false => program.find_or_add_type_id(Type::Unknown, module_id)
            }
        }
        CXType_Enum => {
            let enum_id = program.find_enum_in_scope(
                scope_id
                name: name_from(clang_getTypeDeclaration(t))
            )
            yield match enum_id.has_value() {
                true => program.find_or_add_type_id(Type::Enum(enum_id!), module_id)
                false => program.find_or_add_type_id(Type::Unknown, module_id)
            }
        }
        CXType_Elaborated => type_from(program, scope_id, module_id, clang_Type_getNamedType(t))
        CXType_Unexposed => program.find_or_add_type_id(Type::Unknown, module_id)
        CXType_LValueReference => program.find_or_add_type_id(
            type: Type::Reference(
                type_from(program, scope_id, module_id, clang_getPointeeType(t))
            )
            module_id
        )
        CXType_RValueReference => type_from(program, scope_id, module_id, clang_getPointeeType(t))
        CXType_FunctionProto => {
            let arg_count = clang_getNumArgTypes(t)
            mut arg_types = [unknown_type_id(); arg_count]
            for i in 0..arg_count {
                arg_types[i] = type_from(program, scope_id, module_id, clang_getArgType(t, i))
            }

            let return_type = clang_getResultType(t)
            let return_type_id = type_from(program, scope_id, module_id, return_type)

            // Function(params: [TypeId], can_throw: bool, return_type_id: TypeId, pseudo_function_id: FunctionId)
            mut module = program.get_module(module_id)
            mut function_params: [CheckedParameter] = []
            for i in 0..arg_count {
                let variable = CheckedVariable(
                    name: format("arg_{}", i) // FIXME: Use the declared name if available.
                    type_id: arg_types[i]
                    is_mutable: false
                    definition_span: empty_span()
                    type_span: empty_span()
                    visibility: CheckedVisibility::Public
                    owner_scope: scope_id
                )
                function_params.push(CheckedParameter(
                    requires_label: false
                    variable
                    default_value: None
                ))
            }
            let function = CheckedFunction(
                name: "pseudo_anon"
                name_span: empty_span()
                visibility: CheckedVisibility::Public
                return_type_id
                return_type_span: None
                params: function_params
                generics: FunctionGenerics(
                    base_scope_id: scope_id
                    base_params: function_params
                    params: []
                    specializations: []
                )
                block: CheckedBlock(
                    statements: []
                    scope_id
                    control_flow: BlockControlFlow::MayReturn
                    yielded_type: None
                    yielded_none: false
                )
                can_throw: false
                type: FunctionType::Normal
                linkage: FunctionLinkage::External
                function_scope_id: scope_id
                struct_id: None
                is_instantiated: true
                parsed_function: None
                is_comptime: false
                is_virtual: false
                is_override: false
                is_unsafe: false
                specialization_index: None

                owner_scope: scope_id
                is_fully_checked: true
                external_name: None
            )
            let pseudo_function_id = module.add_function(checked_function: function)
            yield program.find_or_add_type_id(
                type: Type::Function(
                    params: arg_types
                    can_throw: false
                    return_type_id
                    pseudo_function_id
                )
                module_id
            )
        }
        else => {
            let v = clang_getTypeSpelling(t)
            eprintln("Unknown type kind: {} ({})", string_from(v), t.kind as! c_int)
            yield program.find_or_add_type_id(type: Type::Unknown, module_id)
        }
    }
}

struct Context {
    program: CheckedProgram
    module_id: ModuleId
    scope_id: ScopeId
    this_type: TypeId?
    extra: raw void
}

fn empty_span() -> Span => Span(
    file_id: FileId(id: 0)
    start: 0
    end: 0
)

enum AllowedContents {
    OnlyTypes
    OnlyFunctions
    Everything
}

fn process_namespace_contents(
    program: &mut CheckedProgram
    scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
    allowed_contents: AllowedContents
    this_type: TypeId?
    alias_type_name: String? = None
) throws {
    let extra = (allowed_contents, alias_type_name)
    mut context = Context(
        program: *program
        module_id
        scope_id
        this_type
        extra: bitcast<raw void>(&raw extra)
    )

    clang_visitChildren(
        parent: cursor
        visitor: fn(c: CXCursor, parent: CXCursor, data: CXClientData) -> CXChildVisitResult {
            mut context = unsafe *bitcast<raw Context>(data)
            let this_type = context.this_type
            let (allowed_contents, alias_type_name) = unsafe *bitcast<raw (AllowedContents, String?)>(context.extra)

            return match clang_getCursorKind(cursor: c) {
                CXCursor_StructDecl | CXCursor_ClassDecl => {
                    match allowed_contents {
                        OnlyTypes | Everything => {
                            try process_struct(
                                program: &mut context.program
                                parent_scope_id: context.scope_id
                                module_id: context.module_id
                                cursor: c
                                alias_type_name
                            )
                        }
                        else => {}
                    }
                    yield CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_EnumDecl => {
                    match allowed_contents {
                        OnlyTypes | Everything => {
                            try process_enum(
                                program: &mut context.program
                                parent_scope_id: context.scope_id
                                module_id: context.module_id
                                cursor: c
                                alias_type_name
                            )
                        }
                        else => {}
                    }
                    yield CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_Namespace => {
                    try process_namespace(
                        program: &mut context.program
                        parent_scope_id: context.scope_id
                        module_id: context.module_id
                        cursor: c
                    )
                    yield CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_CXXMethod | CXCursor_FunctionDecl => match allowed_contents {
                    OnlyFunctions | Everything => {
                        try process_function(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            this_type
                            kind: ExternFunctionKind::Normal
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_FunctionTemplate => match allowed_contents {
                    OnlyFunctions | Everything => {
                        try process_function_template(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            this_type
                            kind: ExternFunctionKind::Normal
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_Constructor => match allowed_contents {
                    OnlyFunctions | Everything => {
                        try process_function(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            this_type
                            kind: ExternFunctionKind::Constructor
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_Destructor => match allowed_contents {
                    OnlyFunctions | Everything => {
                        try process_function(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            this_type
                            kind: ExternFunctionKind::Destructor
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_FieldDecl => match allowed_contents {
                    OnlyFunctions | Everything => {
                        if clang_getCursorType(c).kind is CXType_FunctionProto {
                            try process_function(
                                program: &mut context.program
                                parent_scope_id: context.scope_id
                                module_id: context.module_id
                                this_type
                                kind: ExternFunctionKind::Normal
                                cursor: c
                            )
                        }
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_TypeAliasDecl | CXCursor_TypedefDecl => match allowed_contents {
                    OnlyTypes | Everything => {
                        try process_type_alias(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            this_type_id: this_type
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Recurse
                }
                CXCursor_ClassTemplate => match allowed_contents {
                    Everything => {
                        try process_class_template(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_ClassTemplatePartialSpecialization => match allowed_contents {
                    Everything => {
                        try process_class_template_partial_specialization(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                CXCursor_MacroDefinition => match allowed_contents {
                    Everything => {
                        try process_macro(
                            program: &mut context.program
                            parent_scope_id: context.scope_id
                            module_id: context.module_id
                            cursor: c
                        )
                        yield CXChildVisitResult::CXChildVisit_Continue
                    }
                    else => CXChildVisitResult::CXChildVisit_Continue
                }
                else => CXChildVisitResult::CXChildVisit_Continue
            }
        }
        client_data: CXClientData(bitcast<raw void>(&raw context))
    )
}

unsafe fn read_at_offset<T>(anon xs: raw T, anon i: u32) -> T {
    return unsafe *bitcast<raw T>(bitcast<u64>(xs) + (i as! u64 * (sizeof T as! u64)))
}

fn process_class_template_partial_specialization(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
) throws {
    let name = name_from(cursor)
    let template_parameters = extract_cursors_of_kinds(
        cursor
        kinds: {CXCursorKind::CXCursor_TemplateTypeParameter, CXCursorKind::CXCursor_NonTypeTemplateParameter}
    )
    let specialization_template_parameters = extract_template_parameters(program, parent_scope_id, module_id, cursor)

    // Resolve arguments
    let template_arguments = extract_matching_cursors_breaking_at_boundary(
        cursor
        &fn(anon kind: CXCursorKind) -> bool => not clang_isDeclaration(kind)
        skip: template_parameters.size()
    )

    let struct_id = program.find_struct_in_scope(
        scope_id: parent_scope_id
        name
    )
    if not struct_id.has_value() {
        eprintln("[ICE] Couldn't find struct for partial specialization named {}", name)
        return
    }

    let base_struct = program.get_struct(struct_id!)

    // Make a specialization
    mut arguments: [TypeId] = []
    for argument in template_arguments {
        mut type = match clang_isExpression(clang_getCursorKind(argument)) {
            true => const_type_from(
                program
                scope_id: parent_scope_id
                module_id
                cursor: argument
            )
            false => type_from(
                program
                scope_id: parent_scope_id
                module_id
                clang_getCursorType(argument)
            )
        }
        arguments.push(type)
    }

    mut specialized_name = ""
    for argument in arguments {
        specialized_name = specialized_name + ", " + program.type_name(argument)
    }
    if specialized_name.length() > 0 {
        specialized_name = specialized_name.substring(start: 2, length: specialized_name.length() - 2)
    }

    process_struct(
        program
        parent_scope_id
        module_id
        cursor
        generic_parameters: base_struct.generic_parameters
        generic_parameter_defaults: base_struct.generic_parameter_defaults
        named_specialization_disambiguator: specialized_name
    )

    let base_type_id = program.find_or_add_type_id(Type::Struct(struct_id!), module_id)
    let specialized_struct_id = program.find_struct_in_scope(
        scope_id: parent_scope_id
        name: format("{}<{}>", name, specialized_name)
    )
    if not specialized_struct_id.has_value() {
        eprintln("[ICE] Couldn't find struct for partial specialization named {}", name)
        abort()
    }

    let type_id = program.find_or_add_type_id(
        Type::Struct(specialized_struct_id!)
        module_id
    )
    let specialization = SpecializedType(
        base_type_id
        arguments
        type_id
    )

    mut scope = program.get_scope(parent_scope_id)
    scope.explicitly_specialized_types.set(name, specialization)
}

fn process_macro(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
) throws {
    // Turn regular macros into variables in the parent scope
    // Ignore function-like macros
    let name = name_from(cursor)
    if clang_Cursor_isMacroFunctionLike(cursor) {
        return
    }

    mut scope = program.get_scope(parent_scope_id)
    mut module = program.get_module(module_id)
    let var_id = module.add_variable(CheckedVariable(
        name
        type_id: unknown_type_id()
        is_mutable: false
        definition_span: empty_span()
        type_span: None
        visibility: CheckedVisibility::Public
        owner_scope: parent_scope_id
        external_name: ExternalName::PreprocessorName(name)
    ))

    scope.vars.set(name, var_id)
}

struct TemplateParameters {
    params: [CheckedGenericParameter]
    defaults: [TypeId?]
}

fn extract_template_parameters(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
) throws -> TemplateParameters {
    let template_parameters = extract_cursors_of_kinds(
        cursor
        kinds: {CXCursorKind::CXCursor_TemplateTypeParameter, CXCursorKind::CXCursor_NonTypeTemplateParameter}
    )
    mut params: [CheckedGenericParameter] = []
    mut defaults: [TypeId?] = []
    for parameter in template_parameters {
        let spelling = string_from(clang_getCursorSpelling(parameter))
        let name = name_from(parameter)
        mut constraints_and_default_value = extract_cursors_of_kinds(
            cursor: parameter
            kinds: {}
        )
        mut default_value_cursor: CXCursor? = None
        mut constraint_cursor: CXCursor? = None

        match constraints_and_default_value.size() {
            0 => {}
            1 => {
                // We need to figure out if this is a constraint or a default value
                // Thanks clang-c <3
                let cursor = constraints_and_default_value[0]
                if clang_getCursorType(cursor).kind is CXType_Invalid {
                    // This is not a 'type', so it's a constraint.
                    constraint_cursor = cursor
                } else {
                    default_value_cursor = cursor
                }
            }
            else => {
                // We're good, [0] is the constraint, and [1] is the default value
                constraint_cursor = constraints_and_default_value[0]
                default_value_cursor = constraints_and_default_value[1]
            }
        }

        mut default_type: TypeId? = None
        if default_value_cursor.has_value() {
            default_type = match clang_isExpression(clang_getCursorKind(default_value_cursor!)) {
                true => const_type_from(
                    program
                    scope_id: parent_scope_id
                    module_id
                    cursor: default_value_cursor!
                )
                false => type_from(
                    program
                    scope_id: parent_scope_id
                    module_id
                    clang_getCursorType(default_value_cursor!)
                )
            }

            let name = name_from(cursor)
            if name == "Vector" {
                eprintln("Vector default value: {} '{}' = {}"
                    string_from(clang_getTypeSpelling(clang_getCursorType(default_value_cursor!)))
                    string_from(clang_getCursorSpelling(default_value_cursor!))
                    program.type_name(default_type!, debug_mode: true)
                )
                for entry in constraints_and_default_value {
                    eprintln("  {} '{}'"
                        string_from(clang_getTypeSpelling(clang_getCursorType(entry)))
                        string_from(clang_getCursorSpelling(entry))
                    )
                }
            }
        }

        // FIXME: Constraints, etc.
        params.push(
            CheckedGenericParameter(
                type_id: program.find_or_add_type_id(
                    Type::TypeVariable(
                        name
                        trait_implementations: []
                        is_value: clang_getCursorKind(parameter) is CXCursor_NonTypeTemplateParameter
                    )
                    module_id
                )
                constraints: []
                span: empty_span()
            )
        )
        defaults.push(default_type)
    }

    if defaults.size() != params.size() {
        eprintln("[ICE] Template parameters ({}) and defaults ({}) don't match", params, defaults)
        abort()
    }

    return TemplateParameters(
        params
        defaults
    )
}

fn process_class_template(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
) throws {
    let name = name_from(cursor)
    match clang_getTemplateCursorKind(cursor) {
        CXCursor_StructDecl | CXCursor_ClassDecl => {
            let template_parameters = extract_template_parameters(program, parent_scope_id, module_id, cursor)
            process_struct(
                program
                parent_scope_id
                module_id
                cursor
                generic_parameters: template_parameters.params
                generic_parameter_defaults: template_parameters.defaults
            )
        }
        else => {
            let k = clang_getCursorKind(cursor)
            let v = clang_getCursorKindSpelling(k)
            eprintln("Unsupported template cursor kind: {}", string_from(v))
        }
    }
}

struct CursorSearchContext {
    kinds: {CXCursorKind}
    result: [CXCursor]
}
fn extract_cursors_of_kinds(
    cursor: CXCursor
    kinds: {CXCursorKind}
) throws -> [CXCursor] {
    mut context = CursorSearchContext(
        kinds
        result: []
    )
    clang_visitChildren(
        parent: cursor
        visitor: fn(c: CXCursor, parent: CXCursor, data: CXClientData) -> CXChildVisitResult {
            mut ptr = bitcast<raw CursorSearchContext>(data)
            mut context = &mut unsafe *ptr

            let kind = clang_getCursorKind(c)
            if context.kinds.is_empty() or context.kinds.contains(kind) {
                try context.result.push(c)
            }

            return CXChildVisitResult::CXChildVisit_Continue
        }
        client_data: CXClientData(bitcast<raw void>(&raw context))
    )
    return context.result
}

fn extract_matching_cursors_breaking_at_boundary(
    cursor: CXCursor
    anon predicate: &fn(anon kind: CXCursorKind) -> bool
    skip: usize = 0
) throws -> [CXCursor] {
    mut results: [CXCursor] = []
    mut context = (&raw predicate, results, skip)

    clang_visitChildren(
        parent: cursor
        visitor: fn(c: CXCursor, parent: CXCursor, data: CXClientData) -> CXChildVisitResult {
            mut ptr = bitcast<raw (raw fn(anon kind: CXCursorKind) -> bool, [CXCursor], usize)>(data)
            mut context = &mut unsafe *ptr
            let predicate = &unsafe *context.0

            let kind = clang_getCursorKind(c)
            if predicate(kind) {
                try context.1.push(c)
            } else if context.2 == 0 {
                return CXChildVisitResult::CXChildVisit_Break
            } else if context.2 > 0 {
                context.2 -= 1
            }

            return CXChildVisitResult::CXChildVisit_Continue
        }
        client_data: CXClientData(bitcast<raw void>(&raw context))
    )

    return results
}

fn process_type_alias(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    this_type_id: TypeId?
    cursor: CXCursor
) throws {
    let name = name_from(cursor)
    let type = clang_getTypedefDeclUnderlyingType(cursor)

    process_namespace_contents(
        program: program
        scope_id: parent_scope_id
        module_id: module_id
        cursor: cursor
        allowed_contents: AllowedContents::OnlyTypes
        this_type: this_type_id
        alias_type_name: name
    )

    if string_from(clang_getTypeSpelling(type)).is_empty() {
        // This is the fun `typedef decl <unnamed> {} name;` pattern, we don't need to produce a new typename.
        return
    }

    let type_id = type_from(program, scope_id: parent_scope_id, module_id, type)
    mut scope = program.get_scope(parent_scope_id)
    scope.types.set(name, type_id)
}

fn process_namespace(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
) throws {
    mut parent_scope = program.get_scope(parent_scope_id)

    let name = name_from(cursor)
    let existing_scope_id = program.find_namespace_in_immediate_children_of_scope(
        scope_id: parent_scope_id
        name
    )
    let (scope_id, scope_was_just_made) = match existing_scope_id.has_value() {
        true => (existing_scope_id!, false)
        false => (
            program.create_scope(
                parent_scope_id
                can_throw: false
                debug_name: format("cpp-namespace({})", name)
                module_id
                for_block: false
            ),
            true
        )
    }

    if scope_was_just_made {
        mut scope = program.get_scope(scope_id)
        scope.namespace_name = name
        parent_scope.children.push(scope_id)
    }

    process_namespace_contents(
        program: program
        scope_id
        module_id
        cursor
        allowed_contents: AllowedContents::Everything
        this_type: None
    )
}

enum ExternFunctionKind {
    Normal
    Constructor
    Destructor
}

fn function_names_from(cursor: CXCursor) throws -> (String, ExternalName?) {
    mut name_builder = StringBuilder::create()
    let name_a = name_from(cursor).replace(replace: "[]", with: "_brackets").replace(replace: "()", with: "_parens")
    for code_point in name_a.code_points() {
        match code_point {
            'a'..'z' | 'z' | 'A'..'Z' | 'Z' | '0'..'9' | '9' | '_' => name_builder.append(code_point)
            // C++ Operator names
            '&' => name_builder.append("_and")
            '*' => name_builder.append("_star")
            '+' => name_builder.append("_plus")
            '-' => name_builder.append("_minus")
            '/' => name_builder.append("_slash")
            '%' => name_builder.append("_percent")
            '=' => name_builder.append("_equals")
            '<' => name_builder.append("_less")
            '>' => name_builder.append("_greater")
            '!' => name_builder.append("_bang")
            '~' => name_builder.append("_tilde")
            '^' => name_builder.append("_caret")
            '|' => name_builder.append("_pipe")
            else => name_builder.append('_')
        }
    }
    let name = name_builder.to_string()
    let simple_extern_name = name_from(cursor)
    let extern_name = match simple_extern_name.starts_with("operator") {
        true => Some(ExternalName::Operator(name: simple_extern_name.substring(start: 8, length: simple_extern_name.length() - 8)))
        false => match simple_extern_name == name {
            true => None
            false => Some(ExternalName::Plain(simple_extern_name))
        }
    }

    return (name, extern_name)
}

fn process_function_template(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    this_type: TypeId?
    kind: ExternFunctionKind
    cursor: CXCursor
) throws {
    let template_parameters = extract_template_parameters(program, parent_scope_id, module_id, cursor)
    process_function(
        program
        parent_scope_id
        module_id
        this_type
        kind
        cursor
        template_parameters
    )
}

fn function_generic_parameters_from(
    anon params: [CheckedGenericParameter]?
) throws -> [FunctionGenericParameter] {
    mut result: [FunctionGenericParameter] = []
    if params.has_value() {
        for param in params! {
            result.push(FunctionGenericParameter(
                kind: FunctionGenericParameterKind::Parameter
                checked_parameter: param
            ))
        }
    }
    return result
}

fn process_function(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    this_type: TypeId?
    kind: ExternFunctionKind
    cursor: CXCursor
    template_parameters: TemplateParameters? = None
) throws {
    if not this_type.has_value() and (kind is Constructor or kind is Destructor) {
        eprintln("[ICE] Constructor or destructor ({}) without a this type", name_from(cursor))
        return
    }

    let struct_id = match this_type.has_value() {
        true => match program.get_type(this_type!) {
            Struct(id) | GenericInstance(id) => Some(id)
            else => None
        }
        false => None
    }

    let (name, external_name) = match kind {
        Normal => function_names_from(cursor)
        Constructor => (program.get_struct(struct_id!).name, None)
        Destructor => ("destructor", None)
    }

    let function_scope = program.create_scope(
        parent_scope_id
        can_throw: false
        debug_name: format("cpp-function({})", name)
        module_id
        for_block: true
    )

    mut params: [CheckedParameter] = []
    mut is_mutating = not clang_CXXMethod_isConst(cursor)
    mut is_static = not this_type.has_value() or kind is Constructor or kind is Destructor or clang_CXXMethod_isStatic(cursor)

    if not is_static {
        let variable = CheckedVariable(
            name: "this"
            type_id: this_type!
            is_mutable: is_mutating
            definition_span: empty_span()
            type_span: empty_span()
            visibility: CheckedVisibility::Public
            owner_scope: function_scope
        )
        params.push(CheckedParameter(
            requires_label: false
            variable
            default_value: None
        ))
    }

    let parameters = extract_cursors_of_kinds(
        cursor
        kinds: {CXCursorKind::CXCursor_ParmDecl}
    )
    for parameter in parameters {
        let arg_type = clang_getCursorType(parameter)
        mut arg_name = name_from(parameter)
        if arg_name.is_empty() {
            arg_name = format("anon_{}", params.size() + 1)
        }
        let arg_type_id = type_from(
            program
            scope_id: function_scope
            module_id
            arg_type
        )
        let variable = CheckedVariable(
            name: arg_name
            type_id: arg_type_id
            is_mutable: false // FIXME: Const
            definition_span: empty_span()
            type_span: empty_span()
            visibility: CheckedVisibility::Public
            owner_scope: function_scope
        )
        params.push(CheckedParameter(
            requires_label: false
            variable
            default_value: None
        ))
    }

    let return_type = match kind {
        Normal => type_from(
            program
            scope_id: function_scope
            module_id
            clang_getCursorResultType(cursor)
        )
        Constructor => this_type!
        Destructor => program.find_or_add_type_id(Type::Void, module_id)
    }

    let function = CheckedFunction(
        name
        name_span: empty_span()
        visibility: CheckedVisibility::Public
        return_type_id: return_type
        return_type_span: None
        params
        generics: FunctionGenerics(
            base_scope_id: function_scope
            base_params: params
            params: function_generic_parameters_from(template_parameters?.params)
            specializations: []
        )
        block: CheckedBlock(
            statements: []
            scope_id: function_scope
            control_flow: BlockControlFlow::MayReturn
            yielded_type: None
            yielded_none: false
        )
        can_throw: false // FIXME: ErrorOr
        type: match kind {
            Normal => FunctionType::Normal
            Constructor => FunctionType::ImplicitConstructor
            Destructor => FunctionType::Destructor
        }
        linkage: FunctionLinkage::External
        function_scope_id: function_scope
        struct_id
        is_instantiated: true
        parsed_function: None
        is_comptime: false
        is_virtual: false
        is_override: false
        is_unsafe: false
        specialization_index: None

        owner_scope: function_scope
        is_fully_checked: true
        external_name
    )

    mut module = program.get_module(module_id)
    let id = module.add_function(checked_function: function)

    mut scope = program.get_scope(parent_scope_id)
    if scope.functions.contains(name) {
        scope.functions[name].push(id)
    } else {
        scope.functions.set(name, [id])
    }

    if kind is Constructor and scope.parent is Some(parent_scope_id) {
        mut parent_scope = program.get_scope(parent_scope_id)
        if parent_scope.functions.contains(name) {
            parent_scope.functions[name].push(id)
        } else {
            parent_scope.functions.set(name, [id])
        }
    }
}

fn debug_description_of(anon program: &CheckedProgram, anon scope_id: ScopeId) throws -> String {
    mut ss: [String] = []
    mut current_scope_id = scope_id
    loop {
        let scope = program.get_scope(current_scope_id)
        let d = format("{} (named {})", scope.debug_name, scope.namespace_name)
        ss.insert(before_index: 0, value: d)
        if scope.parent.has_value() {
            current_scope_id = scope.parent!
        } else {
            break
        }
    }

    return join(ss, separator: " -> ")
}

fn process_enum(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
    alias_type_name: String? = None
) throws {
    mut name = name_from(cursor)
    if name.is_empty() {
        name = alias_type_name ?? format("<anonymous@{}>", &raw cursor)
    }

    mut module = program.get_module(module_id)
    let existing_enum_id = program.get_scope(parent_scope_id).enums.get(name)

    let (enum_scope, scope_was_just_made) = match existing_enum_id.has_value() {
        true => (program.get_enum(existing_enum_id!).scope_id, false)
        false => {
            let enum_scope = program.create_scope(
                parent_scope_id
                can_throw: false
                debug_name: format("cpp-enum({})", name)
                module_id
                for_block: true
            )
            yield (enum_scope, true)
        }
    }

    mut scope = program.get_scope(enum_scope)
    scope.namespace_name = name

    mut parent_scope = program.get_scope(parent_scope_id)
    if scope_was_just_made {
        parent_scope.children.push(enum_scope)
    }

    let enum_id = existing_enum_id ?? EnumId(
        module: module_id
        id: module.enums.size()
    )

    let enum_type_id = program.find_or_add_type_id(
        Type::Enum(enum_id)
        module_id
    )

    parent_scope.enums.set(name, enum_id)
    parent_scope.types.set(name, enum_type_id)

    let underlying_type_id = type_from(
        program
        scope_id: enum_scope
        module_id
        clang_getEnumDeclIntegerType(cursor)
    )

    if scope_was_just_made {
        // This is a predecl, so just add an empty struct for now.
        // We'll fill it in later.
        let the_enum = CheckedEnum(
            name
            name_span: empty_span()
            generic_parameters: []
            variants: []
            fields: []
            scope_id: enum_scope
            definition_linkage: DefinitionLinkage::External
            trait_implementations: [:]
            record_type: RecordType::ValueEnum(
                underlying_type: ParsedType::Empty
                variants: []
            )
            underlying_type_id
            type_id: enum_type_id
            is_boxed: false
        )
        module.enums.push(the_enum)
    }

    if clang_isCursorDefinition(cursor) == 0 {
        return
    }

    let variant_cursors = extract_cursors_of_kinds(
        cursor
        kinds: {CXCursorKind::CXCursor_EnumConstantDecl}
    )
    // Untyped(enum_id: EnumId, name: String, span: Span)
    mut variants: [CheckedEnumVariant] = []
    for cursor in variant_cursors {
        let variant_name = name_from(cursor)
        let variant = CheckedEnumVariant::Untyped(
            enum_id
            name: variant_name
            span: empty_span()
        )
        variants.push(variant)
        let var_id = module.add_variable(CheckedVariable(
            name: variant_name
            type_id: enum_type_id
            is_mutable: false
            definition_span: empty_span()
            type_span: None
            visibility: CheckedVisibility::Public
            owner_scope: enum_scope
        ))
        scope.vars.set(key: variant_name, value: var_id)
    }

    let existing_enum = program.get_enum(enum_id)
    module.enums[enum_id.id] = CheckedEnum(
        name
        name_span: empty_span()
        generic_parameters: []
        variants
        fields: []
        scope_id: enum_scope
        definition_linkage: DefinitionLinkage::External
        trait_implementations: [:]
        record_type: RecordType::ValueEnum(
            underlying_type: ParsedType::Empty
            variants: []
        )
        underlying_type_id
        type_id: enum_type_id
        is_boxed: false
    )
}

fn inherits_from_refcounted_base(anon cursor: CXCursor) throws -> bool {
    mut definition = clang_getCursorDefinition(cursor)
    let maybe_template = clang_getSpecializedCursorTemplate(cursor: definition)
    if not clang_Cursor_isNull(cursor: maybe_template) {
        definition = maybe_template
    }

    mut kind = clang_getCursorKind(definition)
    if kind is CXCursor_ClassTemplate {
        let def = extract_cursors_of_kinds(
            cursor: definition
            kinds: {CXCursorKind::CXCursor_StructDecl, CXCursorKind::CXCursor_ClassDecl}
        ).first()

        if def.has_value() {
            definition = clang_getCanonicalCursor(clang_getCursorDefinition(cursor: def!))
            kind = clang_getCursorKind(definition)
        }
    }

    let usr = string_from(clang_getCursorUSR(cursor: definition))
    if usr == "c:@N@AK@S@RefCountedBase" {
        return true
    }
    // FIXME: Figure out why ::Core::Object doesn't have any CXXBaseSpecifier children.
    if usr == "c:@N@Core@S@Object" {
        return true
    }

    for base in extract_cursors_of_kinds(
        cursor: definition
        kinds: {CXCursorKind::CXCursor_CXXBaseSpecifier}
    ) {
        if inherits_from_refcounted_base(base) {
            return true
        }
    }

    return false
}

fn process_struct(
    program: &mut CheckedProgram
    parent_scope_id: ScopeId
    module_id: ModuleId
    cursor: CXCursor
    generic_parameters: [CheckedGenericParameter]? = None
    generic_parameter_defaults: [TypeId?]? = None
    named_specialization_disambiguator: String? = None
    alias_type_name: String? = None
) throws {
    if generic_parameters.has_value() and generic_parameter_defaults.has_value() {
        if generic_parameters!.size() != generic_parameter_defaults!.size() {
            eprintln("[ICE] Generic parameters and defaults have different lengths")
            abort()
        }
    }

    mut name = name_from(cursor)
    if name.is_empty() {
        name = alias_type_name ?? format("<anonymous@{}>", &raw cursor)
    }

    let specialized_name = match named_specialization_disambiguator.has_value() {
        true => format("{}<{}>", name, named_specialization_disambiguator!),
        false => name
    }

    let bases = extract_cursors_of_kinds(
        cursor
        kinds: {CXCursorKind::CXCursor_CXXBaseSpecifier}
    )

    mut module = program.get_module(module_id)
    let existing_struct_id = program.get_scope(parent_scope_id).structs.get(specialized_name)

    let (struct_scope, scope_was_just_made) = match existing_struct_id.has_value() {
        true => (program.get_struct(existing_struct_id!).scope_id, false)
        false => (
            program.create_scope(
                parent_scope_id
                can_throw: false
                debug_name: format("cpp-struct({})", specialized_name)
                module_id
                for_block: false
            ),
            true
        )
    }

    mut scope = program.get_scope(struct_scope)
    scope.namespace_name = specialized_name

    if generic_parameters.has_value() {
        for parameter in generic_parameters! {
            if program.get_type(parameter.type_id) is TypeVariable(name) {
                scope.types.set(name, parameter.type_id)
            }
        }
    }

    mut parent_scope = program.get_scope(parent_scope_id)
    if scope_was_just_made {
        parent_scope.children.push(struct_scope)
    }

    let struct_id = existing_struct_id ?? StructId(
        module: module_id
        id: module.structures.size()
    )

    let struct_type_id = program.find_or_add_type_id(
        match generic_parameters.has_value() {
            false => Type::Struct(struct_id)
            true => {
                mut args: [TypeId] = []
                for param in generic_parameters! {
                    args.push(param.type_id)
                }

                yield Type::GenericInstance(
                    id: struct_id
                    args
                )
            }
        }
        module_id
    )

    parent_scope.structs.set(specialized_name, struct_id)
    parent_scope.types.set(specialized_name, struct_type_id)

    if scope_was_just_made {
        // This is a predecl, so just add an empty struct for now.
        // We'll fill it in later.
        let empty_parameters: [CheckedGenericParameter] = []
        let the_struct = CheckedStruct(
            name
            name_span: empty_span()
            generic_parameters: generic_parameters ?? empty_parameters
            generic_parameter_defaults
            fields: []
            scope_id: struct_scope
            definition_linkage: DefinitionLinkage::External
            trait_implementations: [:]
            record_type: RecordType::Struct(fields: [], super_type: None)
            type_id: struct_type_id
            super_struct_id: None
        )
        module.structures.push(the_struct)
    }

    if clang_isCursorDefinition(cursor) == 0 {
        return
    }

    // If the struct somehow inherits from AK::RefCountedBase, we'll make it boxed.
    mut is_class = false
    for base in bases {
        if inherits_from_refcounted_base(base) {
            is_class = true
            break
        }
    }

    mut super_struct_ids: [StructId] = []
    for base in bases {
        match program.get_type(type_from(
            &mut program
            scope_id: parent_scope_id
            module_id
            clang_getCursorType(base)
        )) {
            GenericInstance(id) | Struct(id) => { super_struct_ids.push(id) }
            else => {}
        }
    }

    process_namespace_contents(
        program
        scope_id: struct_scope
        module_id
        cursor
        allowed_contents: AllowedContents::OnlyTypes
        this_type: struct_type_id
    )

    mut fields: [CheckedField] = []
    mut context = Context(
        program: *program
        module_id
        scope_id: struct_scope
        this_type: struct_type_id
        extra: bitcast<raw void>(&raw fields)
    )

    clang_visitChildren(
        parent: cursor
        visitor: fn(c: CXCursor, parent: CXCursor, data: CXClientData) -> CXChildVisitResult {
            mut context = unsafe *bitcast<raw Context>(data)
            mut program = context.program
            let module_id = context.module_id
            let struct_scope = context.scope_id
            mut fields_ptr = bitcast<raw [CheckedField]>(context.extra)
            let fields = &mut unsafe *fields_ptr
            mut module = program.get_module(module_id)

            let kind = clang_getCursorKind(cursor: c) as! c_int
            try {
                if kind == (CXCursorKind::CXCursor_FieldDecl as! c_int) {
                    // if the field is a function (and not a function pointer), skip it here
                    if not (clang_getCursorType(c).kind is CXType_FunctionProto) {
                        let name = name_from(c)
                        let type_id = type_from(
                            &mut program
                            scope_id: struct_scope
                            module_id
                            clang_getCursorType(c)
                        )
                        let variable = CheckedVariable(
                            name
                            type_id
                            is_mutable: false // FIXME: Const
                            definition_span: empty_span()
                            type_span: None
                            visibility: CheckedVisibility::Public
                            owner_scope: struct_scope
                        )

                        let variable_id = module.add_variable(variable)
                        let field = CheckedField(
                            variable_id
                            default_value: None
                            default_value_expression: None
                        )
                        fields.push(field)
                    }
                }
            } catch e {
                return CXChildVisitResult::CXChildVisit_Break
            }
            return CXChildVisitResult::CXChildVisit_Continue
        }
        client_data: CXClientData(bitcast<raw void>(&raw context))
    )

    let existing_struct = module.structures[struct_id.id]

    let the_struct = CheckedStruct(
        name
        name_span: empty_span()
        generic_parameters: existing_struct.generic_parameters
        generic_parameter_defaults: existing_struct.generic_parameter_defaults
        fields
        scope_id: existing_struct.scope_id
        definition_linkage: DefinitionLinkage::External
        trait_implementations: existing_struct.trait_implementations
        record_type: match is_class {
            true => RecordType::Class(fields: [], super_type: None)
            false => RecordType::Struct(fields: [], super_type: None)
        }
        type_id: struct_type_id
        // FIXME: Multiple inheritance?
        super_struct_id: super_struct_ids.first()
    )
    module.structures[struct_id.id] = the_struct

    // Now process the functions
    process_namespace_contents(
        program
        scope_id: struct_scope
        module_id
        cursor
        allowed_contents: AllowedContents::OnlyFunctions
        this_type: struct_type_id
    )

    // Don't synthesize a constructor for classes, we can't create an instance that way.
    if is_class {
        return
    }

    // Look for a constructor, generate one with the fields if none exist
    let ctors = program.find_functions_with_name_in_scope(
        parent_scope_id
        function_name: name
    )

    if not ctors.has_value() or ctors!.is_empty() {
        mut params: [CheckedParameter] = []
        for field in fields {
            let variable = program.get_variable(field.variable_id)
            params.push(CheckedParameter(
                requires_label: false
                variable
                default_value: None
            ))
        }
        let function_scope = program.create_scope(
            parent_scope_id
            can_throw: false
            debug_name: format("cpp-function({})", name)
            module_id
            for_block: true
        )
        mut generic_params: [FunctionGenericParameter] = []
        let empty_parameters: [CheckedGenericParameter] = []
        for generic in generic_parameters ?? empty_parameters {
            generic_params.push(FunctionGenericParameter(
                kind: FunctionGenericParameterKind::InferenceGuide
                checked_parameter: generic
            ))
        }

        let function = CheckedFunction(
            name
            name_span: empty_span()
            visibility: CheckedVisibility::Public
            return_type_id: struct_type_id
            return_type_span: None
            params
            generics: FunctionGenerics(
                base_scope_id: function_scope
                base_params: params
                params: generic_params
                specializations: []
            )
            block: CheckedBlock(
                statements: []
                scope_id: function_scope
                control_flow: BlockControlFlow::MayReturn
                yielded_type: None
                yielded_none: false
            )
            can_throw: false // FIXME: ErrorOr
            type: FunctionType::ImplicitConstructor
            linkage: FunctionLinkage::External
            function_scope_id: function_scope
            struct_id
            is_instantiated: true
            parsed_function: None
            is_comptime: false
            is_virtual: false
            is_override: false
            is_unsafe: false
            specialization_index: None

            owner_scope: function_scope
            is_fully_checked: true
        )

        mut module = program.get_module(module_id)
        let id = module.add_function(checked_function: function)

        mut scope = program.get_scope(struct_scope)
        if scope.functions.contains(name) {
            scope.functions[name].push(id)
        } else {
            scope.functions.set(name, [id])
        }

        mut parent_scope = program.get_scope(parent_scope_id)
        if parent_scope.functions.contains(name) {
            parent_scope.functions[name].push(id)
        } else {
            parent_scope.functions.set(name, [id])
        }
    }
}

fn process_cpp_import(
    program: &mut CheckedProgram
    import_path: Path
    scope_id: ScopeId
    is_c: bool
    defines: [String:String]
) throws -> ScopeId {
    let module_id = scope_id.module_id
    let import_scope_id = program.create_scope(
        parent_scope_id: scope_id
        can_throw: false
        debug_name: format("cpp-import-module({})", import_path.to_string())
        module_id
        for_block: false
    )

    let found_path = program.compiler.find_in_search_paths(import_path)
    if not found_path.has_value() {
        throw Error::from_string_literal(CppImportErrors::path_not_found())
    }

    let filename = real_path(path: found_path!.to_string())

    mut scope = program.get_scope(import_scope_id)
    mut parent_scope = program.get_scope(scope_id)
    parent_scope.children.push(import_scope_id)
    scope.import_path_if_extern = filename

    let span = Span(
        file_id: FileId(id: 0)
        start: 0
        end: 0
    )

    let index = clang_createIndex(excludeDeclarationsFromPCH: false, displayDiagnostics: true)

    // Check if a PCH exists for this file
    mut tu = CXTranslationUnit()

    let path_separator_string = format("{:c}", get_path_separator())
    let pch_file_path = program.compiler.binary_dir.join(
        filename.replace(replace: path_separator_string, with: "_")
    ).replace_extension("pch")

    if pch_file_path.exists() {
        // Parse the TU from the PCH
        tu = clang_createTranslationUnit(index, file_name: pch_file_path.to_string().c_string())
    }

    if tu == CXTranslationUnit() {
        mut args_storage = [""; 2 + program.compiler.include_paths.size() + defines.size()]
        if is_c {
            args_storage[0] = "-xc"
            args_storage[1] = "-std=c11"
        } else {
            args_storage[0] = "-xc++-header"
            args_storage[1] = "-std=c++20"
        }
        for i in 0..program.compiler.include_paths.size() {
            args_storage[i + 2] = format("-I{}", program.compiler.include_paths[i])
        }

        mut defines_it = defines.iterator()
        for i in 0..defines.size() {
            let (key, value) = defines_it.next()!
            args_storage[i + 2 + program.compiler.include_paths.size()] = format("-D{}={}", key, value)
        }

        mut args = allocate<raw c_char>(count: args_storage.size())
        let r = bitcast<raw c_char>(args)
        defer free(r)

        for i in 0..args_storage.size() {
            unsafe { cpp { "args[i] = const_cast<char*>(args_storage[i].characters());" } }
        }

        let err = clang_parseTranslationUnit2(
            index
            source_filename: filename.c_string()
            command_line_args: args
            num_command_line_args: args_storage.size() as! c_int
            unsaved_files: null<raw CXUnsavedFile>()
            num_unsaved_files: 0
            options: (
                CXTranslationUnit_Flags::CXTranslationUnit_SkipFunctionBodies as! c_int |
                CXTranslationUnit_Flags::CXTranslationUnit_DetailedPreprocessingRecord as! c_int
            )
            out_tu: &raw tu
        )
        if not (err is CXError_Success) {
            eprintln("Error: {}", match err {
                CXError_Failure => "Failure"
                CXError_Crashed => "Crashed"
                CXError_InvalidArguments => "InvalidArguments"
                CXError_ASTReadError => "ASTReadError"
                else => "Unknown"
            })
            throw Error::from_string_literal(CppImportErrors::path_not_found())
        }

        clang_saveTranslationUnit(
            tu
            file_name: pch_file_path.to_string().c_string()
            options: 0
        )
    }

    let cursor = clang_getTranslationUnitCursor(tu)

    process_namespace_contents(
        program
        scope_id: import_scope_id
        module_id
        cursor
        allowed_contents: AllowedContents::Everything
        this_type: None
    )

    clang_disposeTranslationUnit(tu)
    clang_disposeIndex(index)

    // dump_scope(import_scope_id, &program)

    return import_scope_id
}

fn dump_scope(anon scope_id: ScopeId, anon program: &CheckedProgram, indent: i64 = 0) throws {
    mut scope = program.get_scope(scope_id)
    eprintln("{: >{}}Scope (ns={}) {}", "", indent, scope.namespace_name, scope.debug_name)
    let cindent = indent + 2
    eprintln("{: >{}}Types:", "", cindent)
    for (name, type_id) in scope.types {
        let type = program.get_type(type_id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, program.type_name(type_id, debug_mode: true))
    }
    eprintln("{: >{}}Specializations:", "", cindent)
    for (name, type) in scope.explicitly_specialized_types {
        let type_name = program.type_name(type.type_id, debug_mode: true)
        mut args = ""
        for arg in type.arguments {
            args = args + program.type_name(arg, debug_mode: true) + ", "
        }

        eprintln("{: >{}}{}<{}> = {}", "", cindent + 2, name, args, type_name)
    }
    eprintln("{: >{}}Variables:", "", cindent)
    for (name, var_id) in scope.vars {
        let var = program.get_variable(var_id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, program.type_name(var.type_id, debug_mode: true))
    }
    eprintln("{: >{}}Functions:", "", cindent)
    for (name, ids) in scope.functions {
        eprintln("{: >{}}{}:", "", cindent + 2, name)
        for id in ids {
            let function = program.get_function(id)
            mut args = ""
            for arg in function.params {
                args = args + program.type_name(arg.variable.type_id, debug_mode: true) + ", "
            }

            eprintln("{: >{}}fn({}) -> {}", "", cindent + 4, args, program.type_name(function.return_type_id, debug_mode: true))
        }
    }
    eprintln("{: >{}}Structs:", "", cindent)
    for (name, id) in scope.structs {
        let struct_ = program.get_struct(id)
        eprintln("{: >{}}{}@{}: {}", "", cindent + 2, id.id, id.module, struct_.name)
    }
    eprintln("{: >{}}Aliases:", "", cindent)
    for (name, id) in scope.aliases {
        let scope = program.get_scope(id)
        eprintln("{: >{}}{}: {}", "", cindent + 2, name, scope.debug_name)
    }
    eprintln("{: >{}}Children:", "", cindent)
    for id in scope.children {
        dump_scope(id, program, indent: cindent + 2)
    }
}
