import typechecker { Typechecker, Interpreter, LoadedModule, ModuleId, ScopeId, TypeId, CheckedProgram, SafetyMode, InterpreterScope }
import compiler { Compiler, FilePath }
import lexer { Lexer }
import parser { Parser }
import utility { Span }
import error { JaktError }
import codegen { CodeGenerator, CodegenDebugInfo, ControlFlowState, AllowedControlExits }

import extern c "stdio.h" {
    extern function fopen(pathname: raw c_char, mode: raw c_char) -> raw FILE
    extern function fclose(stream: raw FILE) -> raw c_int
    // Blame windows for this.
    extern function fgets(s: raw c_char, n: usize, stream: raw FILE) -> raw c_char
}

function null<T>() -> raw T {
    unsafe {
        cpp {
            "return nullptr;"
        }
    }

    abort()
}

function allocate<T>(count: usize) -> raw T {
    unsafe {
        cpp {
            "return static_cast<T*>(malloc(count * sizeof(T)));"
        }
    }

    abort()
}

enum LineResult {
    Line(String)
    Eof
}

struct Editor {
    standard_input_file: raw FILE
    line_pointer: raw c_char
    prompt: String

    function create(prompt: String) throws -> Editor {
        mut std_in = fopen("/dev/stdin".c_string(), "r".c_string())
        if std_in == null<FILE>() {
            eprintln("Could not open /dev/stdin for reading")
            throw Error::from_errno(42)
        }

        let editor = Editor(
            standard_input_file: std_in
            line_pointer: allocate<c_char>(count: 4096)
            prompt
        )
        return editor
    }

    function get_line(mut this) throws -> LineResult {
        eprint("{}", .prompt)

        mut builder = StringBuilder::create()
        unsafe {
            let c_string = fgets(
                s: .line_pointer
                n: 4096
                stream: .standard_input_file)

            if c_string == null<c_char>() {
                return LineResult::Eof
            }

            builder.append_c_string(c_string)
        }

        return LineResult::Line(builder.to_string())
    }

    function destroy(mut this) {
        fclose(stream: .standard_input_file)
        unsafe {
            cpp {
                "free(line_pointer);"
            }
        }
    }
}

function handle_possible_error(compiler: &mut Compiler) throws -> bool {
    compiler.print_errors()
    let has_error = compiler.errors.size() > 0
    let arr: [JaktError] = []
    compiler.errors = arr
    return has_error
}

function is_ascii_upper_case(anon c: u8) -> bool {
    return c >= 65 && c <= 90
}

function start_repl() throws {
    mut compiler = Compiler(
        files: []
        file_ids: [:]
        errors: []
        current_file: None
        current_file_contents: []
        dump_lexer: false
        dump_parser: false
        ignore_parser_errors: false
        debug_print: false
        include_paths: []
        json_errors: false
        dump_type_hints: false
        dump_try_hints: false
    )

    compiler.load_prelude()
    let file_id = compiler.get_file_id_or_register(file: FilePath::make("<repl>"))

    let placeholder_module_id = ModuleId(id: 0)

    mut typechecker = Typechecker(
        compiler
        program: CheckedProgram(compiler, modules: [], loaded_modules: [:]),
        current_module_id: placeholder_module_id,
        current_struct_type_id: TypeId::none()
        current_function_id: None
        inside_defer: false
        checkidx: 0uz
        ignore_errors: false
        dump_type_hints: compiler.dump_type_hints
        dump_try_hints: compiler.dump_try_hints
        lambda_count: 0
    )

    compiler.current_file = file_id
    typechecker.include_prelude()

    let root_module_name = "<repl>"
    let root_module_id = typechecker.create_module(name: root_module_name, is_root: true)
    typechecker.current_module_id = root_module_id
    typechecker.program.set_loaded_module(
        module_name: root_module_name
        loaded_module: LoadedModule(
            module_id: root_module_id
            file_id: file_id
        )
    )

    let PRELUDE_SCOPE_ID: ScopeId = typechecker.prelude_scope_id()
    let root_scope_id = typechecker.create_scope(parent_scope_id: PRELUDE_SCOPE_ID, can_throw: true,  debug_name: "root")

    let root_interpreter_scope = InterpreterScope(
        bindings: [:]
        parent: None
    )

    mut generator = CodeGenerator(
        compiler
        program: typechecker.program
        control_flow_state: ControlFlowState(
            allowed_exits: AllowedControlExits::Nothing
            passes_through_match: false
            passes_through_try: false
            match_nest_level: 0
        )
        entered_yieldable_blocks: []
        deferred_output: ""
        current_function: None
        debug_info: CodegenDebugInfo(
            compiler
            line_spans: [:]
            statement_span_comments: false
        )
        namespace_stack: []
        fresh_var_counter: 0
        fresh_label_counter: 0
    )

    mut editor = Editor::create(prompt: "> ")
    defer editor.destroy()

    loop {
        if not compiler.errors.is_empty() {
            compiler.print_errors()
            let arr: [JaktError] = []
            compiler.errors = arr
        }

        let line_result = try editor.get_line() catch error {
            return
        }

        guard line_result is Line(line) else {
            break
        }

        if line == ".exit\n" {
            break
        }

        mut pos: usize = 0
        mut bytes_: [u8] = []
        bytes_.ensure_capacity(line.length())
        while pos < line.length() {
            bytes_.push(line.byte_at(pos)) 
            ++pos
        }

        compiler.current_file = file_id
        compiler.current_file_contents = bytes_

        let tokens = try Lexer::lex(compiler) catch {
            continue
        }

        mut parser = Parser(index: 0, tokens, compiler)
        let parsed_statement = try parser.parse_statement(inside_block: true) catch {
            handle_possible_error(&mut compiler)
            continue
        }

        if handle_possible_error(&mut compiler) {
            continue
        }

        let checked_statement = try typechecker.typecheck_statement(statement: parsed_statement, scope_id: root_scope_id, safety_mode: SafetyMode::Safe) catch {
            handle_possible_error(&mut compiler)
            continue
        }

        if handle_possible_error(&mut compiler) {
            continue
        }

        mut interpreter = Interpreter(
            compiler,
            program: typechecker.program,
            spans: []
        )

        let result = try interpreter.execute_statement(
            statement: checked_statement
            scope: root_interpreter_scope
            call_span: Span(
                file_id
                start: 0
                end: line.length()
            )
        ) catch {
            handle_possible_error(&mut compiler)
            continue
        }

        if handle_possible_error(&mut compiler) {
            continue
        }

        match result {
            Return(value) | JustValue(value) | Throw(value) => {
                if value.impl is Void {
                    continue
                }
            }
            Break | Continue => {}
        }

        let output = match result {
            Return(value) | JustValue(value) => generator.codegen_expression(expr: value.to_checked_expression(interpreter))
            Throw(value) => "throw " + generator.codegen_expression(expr: value.to_checked_expression(interpreter))
            Break | Continue => {
                continue
            }
        }
        println("= {}", output)
    }
}