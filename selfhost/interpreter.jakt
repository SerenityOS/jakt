import types {
    BinaryOperator, BlockControlFlow, BuiltinType, CheckedBlock, CheckedCall, CheckedEnum, CheckedEnumVariant
    CheckedExpression, CheckedField, CheckedFunction, CheckedMatchBody, CheckedNumericConstant, CheckedParameter
    CheckedProgram, CheckedStatement, CheckedStringLiteral, CheckedTypeCast, CheckedUnaryOperator, CheckedVariable
    CheckedVisibility, EnumId, EnumVariantPatternArgument, FunctionGenerics, FunctionId, GenericInferences, ModuleId
    NumericOrStringValue, ParsedStatement, ResolvedNamespace, SafetyMode, Scope, ScopeId, Span, StringLiteral
    StructId, Type, TypeId, TypecheckFunctions, Value, ValueImpl, VarId, builtin, comptime_format_impl
    unknown_type_id, void_type_id
}
import parser { FunctionLinkage, FunctionType, ParsedBlock, ParsedExpression }
import utility { escape_for_quotes, interpret_escapes, panic }
import error { JaktError }
import compiler { Compiler }
import jakt::platform { Target }

enum InterpretError : i32 {
    CallToExternalFunction = 42i32
    MismatchingArguments
    InvalidThisArgument
    InvalidOperation
    InvalidType
    UnknownVariable
    Unimplemented
    UnwrapOptionalNone
    InvalidCharacterConstant
}

trait TargetSize {
    fn size_t_size(this) throws -> usize
    fn pointer_size(this) throws -> usize
    fn int_size(this) throws -> usize
    fn size_t_alignment(this) throws -> usize => .size_t_size()
    fn pointer_alignment(this) throws -> usize => .pointer_size()
    fn int_alignment(this) throws -> usize => .int_size()
}

type Target implements(TargetSize) {
    fn size_t_size(this) throws -> usize => match .arch {
        "x86_64" => 8
        "x86" => 4
        else => {
            throw Error::from_string_literal("size_t size is unknown for this architecture")
        }
    }

    fn pointer_size(this) throws -> usize => match .arch {
        "x86_64" => 8
        "x86" => 4
        else => {
            throw Error::from_string_literal("pointer size is unknown for this architecture")
        }
    }

    fn int_size(this) throws -> usize => match .arch {
        "x86_64" => 4
        "x86" => 4
        else => {
            throw Error::from_string_literal("int size is unknown for this architecture")
        }
    }
}

fn align_of_impl(
    type_id: TypeId
    anon interpreter: Interpreter
) throws -> usize => match interpreter.program.get_type(type_id) {
    Void | Unknown | Never => 0
    Bool => 1
    I8 | U8 => 1
    I16 | U16 => 2
    I32 | U32 => 4
    I64 | U64 => 8
    F32 => 4
    F64 => 8
    Usize => Target::active().size_t_alignment()
    JaktString => Target::active().pointer_alignment()
    CChar => 1
    CInt => Target::active().int_alignment()
    TypeVariable
    | Const
    | Dependent
    | GenericTraitInstance => 0
    GenericInstance(id: struct_id, args)
    | Struct(struct_id) default(args: [TypeId] = []) => {
        let struct_ = interpreter.program.get_struct(struct_id)
        let resolve_type_id = fn[&struct_, &args](anon type_id: TypeId) -> TypeId {
            mut i = 0
            for param in struct_.generic_parameters {
                defer i += 1
                if param.type_id.equals(type_id) {
                    return args[i]
                }
            }

            return type_id
        }
        mut align = 0uz
        for field in struct_.fields {
            let field_alignment = align_of_impl(
                type_id: resolve_type_id(interpreter.program.get_variable(field.variable_id).type_id)
                interpreter
            )
            if field_alignment > align {
                align = field_alignment
            }
        }
        yield align
    }
    GenericEnumInstance(id: enum_id, args)
    | Enum(enum_id) default(args: [TypeId] = []) => {
        let enum_ = interpreter.program.get_enum(enum_id)
        let resolve_type_id = fn[&enum_, &args](anon type_id: TypeId) -> TypeId {
            mut i = 0
            for param in enum_.generic_parameters {
                defer i += 1
                if param.type_id.equals(type_id) {
                    return args[i]
                }
            }

            return type_id
        }

        yield match enum_.underlying_type_id.equals(void_type_id()) {
            true => {
                mut align = 0uz
                for variant in enum_.variants {
                    let variant_align = match variant {
                        Untyped => 0uz
                        Typed(type_id) => align_of_impl(type_id: resolve_type_id(type_id), interpreter)
                        // NOTE: Cannot occur here.
                        WithValue => 0uz
                        StructLike(fields) => {
                            mut align = 0uz
                            for field in fields {
                                let field_alignment = align_of_impl(
                                    type_id: resolve_type_id(interpreter.program.get_variable(field).type_id)
                                    interpreter
                                )
                                if field_alignment > align {
                                    align = field_alignment
                                }
                            }
                            yield align
                        }
                    }

                    if variant_align > align {
                        align = variant_align
                    }
                }

                let index_type = match enum_.variants.size() {
                    0uz..256uz => BuiltinType::U8
                    else => BuiltinType::Usize
                }
                let index_align = align_of_impl(type_id: builtin(index_type), interpreter)
                if index_align > align {
                    align = index_align
                }

                yield align
            }
            else => align_of_impl(type_id: enum_.underlying_type_id, interpreter)
        }
    }
    RawPtr => Target::active().pointer_alignment()
    Trait => 0
    Reference => Target::active().pointer_alignment()
    MutableReference => Target::active().pointer_alignment()
    Function => 0
    Self => 0
}

fn size_of_impl(
    type_id: TypeId
    anon interpreter: Interpreter
) throws -> usize => match interpreter.program.get_type(type_id) {
    Void | Unknown | Never => 0
    Bool => 1
    I8 | U8 => 1
    I16 | U16 => 2
    I32 | U32 => 4
    I64 | U64 => 8
    F32 => 4
    F64 => 8
    Usize => Target::active().size_t_size()
    JaktString => Target::active().pointer_size()
    CChar => 1
    CInt => Target::active().int_size()
    TypeVariable
    | Const
    | Dependent
    | GenericTraitInstance => 0

    GenericInstance(id: struct_id, args)
    | Struct(struct_id) default(args: [TypeId] = []) => {
        let struct_ = interpreter.program.get_struct(struct_id)
        let resolve_type_id = fn[&struct_, &args](anon type_id: TypeId) -> TypeId {
            mut i = 0
            for param in struct_.generic_parameters {
                defer i += 1
                if param.type_id.equals(type_id) {
                    return args[i]
                }
            }

            return type_id
        }

        mut size = 0uz
        mut align = 0uz
        for field in struct_.fields {
            mut type_id = resolve_type_id(interpreter.program.get_variable(field.variable_id).type_id)
            let field_size = size_of_impl(type_id, interpreter)
            let field_align = align_of_impl(type_id, interpreter)
            let slack = size % field_align
            if slack != 0 {
                size += field_align - slack
            }
            if align < field_align {
                align = field_align
            }

            size += field_size
        }

        if size == 0 {
            size = 1 // NOTE: Empty structs are 1 byte in C++, we're talking to C++.
        } else {
            // Align to the struct's alignment.
            let total_slack = size % align
            if total_slack != 0 {
                size += align - total_slack
            }
        }

        yield size
    }

    GenericEnumInstance(id: enum_id, args)
    | Enum(enum_id) default(args: [TypeId] = []) => {
        let enum_ = interpreter.program.get_enum(enum_id)
        let resolve_type_id = fn[&enum_, &args](anon type_id: TypeId) -> TypeId {
            mut i = 0
            for param in enum_.generic_parameters {
                defer i += 1
                if param.type_id.equals(type_id) {
                    return args[i]
                }
            }

            return type_id
        }
        yield match enum_.underlying_type_id.equals(void_type_id()) {
            true => {
                mut size = 0uz
                mut container_align = 0uz
                for variant in enum_.variants {
                    let variant_size = match variant {
                        Untyped => 0uz
                        Typed(type_id) => {
                            let align = align_of_impl(type_id: resolve_type_id(type_id), interpreter)
                            if align > container_align {
                                container_align = align
                            }

                            yield size_of_impl(type_id, interpreter)
                        }
                        // NOTE: Cannot occur here.
                        WithValue => 0uz
                        StructLike(fields) => {
                            mut size = 0uz
                            mut align = 0uz
                            for field in fields {
                                let type_id = resolve_type_id(interpreter.program.get_variable(field).type_id)
                                let field_size = size_of_impl(type_id, interpreter)
                                let field_alignment = align_of_impl(type_id, interpreter)
                                let slack = size % field_alignment
                                if slack != 0 {
                                    size += field_alignment - slack
                                }
                                if align < field_alignment {
                                    align = field_alignment
                                }
                                size += field_size
                            }

                            if size == 0 {
                                size = 1
                            } else {
                                let total_slack = size % align
                                if total_slack != 0 {
                                    size += align - total_slack
                                }
                            }

                            if align > container_align {
                                container_align = align
                            }

                            yield size
                        }
                    }

                    if variant_size > size {
                        size = variant_size
                    }
                }

                let index_type = match enum_.variants.size() {
                    0uz..256uz => BuiltinType::U8
                    else => BuiltinType::Usize
                }
                let index_align = align_of_impl(type_id: builtin(index_type), interpreter)
                let index_size = size_of_impl(type_id: builtin(index_type), interpreter)
                let index_slack = size % index_align
                if index_slack != 0 {
                    size += index_align - index_slack
                }
                size += index_size

                if container_align > index_align {
                    let slack = size % container_align
                    if slack != 0 {
                        size += container_align - slack
                    }
                }

                yield size
            }
            else => align_of_impl(type_id: enum_.underlying_type_id, interpreter)
        }
    }
    RawPtr => Target::active().pointer_size()
    Trait => 0
    Reference => Target::active().pointer_size()
    MutableReference => Target::active().pointer_size()
    Function => 0
    Self => 0
}

fn cast_value_to_type(anon this_value: Value, anon type_id: TypeId, interpreter: Interpreter, saturating: bool = false) throws -> Value {
    let type = interpreter.program.get_type(type_id)
    let is_optional = match type {
        GenericInstance(id) => id.equals(interpreter.program.find_struct_in_prelude("Optional"))
        else => false
    }

    return match type {
        U8 => match this_value.impl {
            U16(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        U16 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        U32 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            U16(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        U64 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            U16(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        I8 => match this_value.impl {
            I16(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        I16 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        I32 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            I16(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        I64 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            I16(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        Usize => match this_value.impl {
            U64(value) => Value(impl: ValueImpl::USize(value as! usize), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                false => this_value
            }
        }
        else => match is_optional {
            true => match this_value.impl {
                OptionalSome | OptionalNone => this_value
                else => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
            }
            else => this_value
        }
    }
}

fn value_to_checked_expression(anon this_value: Value, anon mut interpreter: Interpreter) throws -> CheckedExpression => match this_value.impl {
    Void => {
        interpreter.error("Cannot convert void to expression", this_value.span)
        interpreter.compiler.panic("Invalid type")
    }
    Bool(x)  => CheckedExpression::Boolean(val: x, span: this_value.span)
    U8(x)    => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(x), span: this_value.span, type_id: builtin(BuiltinType::U8))
    U16(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(x), span: this_value.span, type_id: builtin(BuiltinType::U16))
    U32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(x), span: this_value.span, type_id: builtin(BuiltinType::U32))
    U64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(x), span: this_value.span, type_id: builtin(BuiltinType::U64))
    I8(x)    => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(x), span: this_value.span, type_id: builtin(BuiltinType::I8))
    I16(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(x), span: this_value.span, type_id: builtin(BuiltinType::I16))
    I32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(x), span: this_value.span, type_id: builtin(BuiltinType::I32))
    I64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(x), span: this_value.span, type_id: builtin(BuiltinType::I64))
    F32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F32(x), span: this_value.span, type_id: builtin(BuiltinType::F32))
    F64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F64(x), span: this_value.span, type_id: builtin(BuiltinType::F64))
    USize(x) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(x as! u64), span: this_value.span, type_id: builtin(BuiltinType::Usize))
    JaktString(x) => CheckedExpression::QuotedString(
        val: CheckedStringLiteral(
            value: StringLiteral::Static(escape_for_quotes(x))
            type_id: interpreter.program.find_or_add_type_id(
                type: Type::Struct(interpreter.program.find_struct_in_prelude("String"))
                module_id: interpreter.program.prelude_module_id()
            )
            may_throw: false
        )
        span: this_value.span
    )
    // FIXME: Translate this to an actual StringView lel
    StringView(x) => CheckedExpression::QuotedString(
        val: CheckedStringLiteral(
            value: StringLiteral::Static(escape_for_quotes(x))
            type_id: interpreter.program.find_or_add_type_id(
                type: Type::Struct(interpreter.program.find_struct_in_prelude("StringView"))
                module_id: interpreter.program.prelude_module_id()
            )
            may_throw: false
        )
        span: this_value.span
    )
    CChar(x) => CheckedExpression::CCharacterConstant(val: format("{}", x), span: this_value.span)
    CInt(x)  => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(x as! i32), span: this_value.span, type_id: builtin(BuiltinType::CInt))
    OptionalNone => CheckedExpression::OptionalNone(span: this_value.span, type_id: unknown_type_id())
    OptionalSome(value) => {
        let expr = value_to_checked_expression(value, interpreter)
        let inner_type_id = expr.type()
        let optional_struct_id = interpreter.program.find_struct_in_prelude("Optional")
        let type = Type::GenericInstance(id: optional_struct_id, args: [inner_type_id])
        let type_id = interpreter.find_or_add_type_id(type)
        yield CheckedExpression::OptionalSome(expr, span: this_value.span, type_id)
    }
    JaktTuple(fields, type_id) => {
        mut vals: [CheckedExpression] = []
        for field in fields {
            vals.push(value_to_checked_expression(field, interpreter))
        }
        yield CheckedExpression::JaktTuple(vals, span: this_value.span, type_id)
    }
    Struct(fields, struct_id, constructor)
    | Class(fields, struct_id, constructor) => {
        if not constructor.has_value() {
            interpreter.error_with_hint(
                "Cannot convert struct to expression without constructor", this_value.span,
                "Given struct cannot be created from its contents in any known way", this_value.span)
            interpreter.compiler.panic("Invalid type")
        }

        mut materialised_fields: [CheckedExpression] = []
        for field in fields {
            materialised_fields.push(value_to_checked_expression(field, interpreter))
        }

        let struct_ = interpreter.program.get_struct(struct_id)
        mut reversed_namespace: [ResolvedNamespace] = []
        mut scope_id: ScopeId? = struct_.scope_id
        while scope_id.has_value() {
            let scope = interpreter.program.get_scope(scope_id!)
            if scope.namespace_name.has_value() {
                reversed_namespace.push(ResolvedNamespace(name: scope.namespace_name!, generic_parameters: None))
            }
            scope_id = scope.parent
        }
        mut namespace_: [ResolvedNamespace] = []
        for i in reversed_namespace.size()..0 {
            namespace_.push(reversed_namespace[i - 1])
        }

        let callee = interpreter.program.get_function(constructor!)
        if materialised_fields.size() > callee.params.size() {
            interpreter.error_with_hint(
                "Too many arguments for constructor", this_value.span,
                format("Expected at most {} arguments, got {}", callee.params.size(), materialised_fields.size()), this_value.span)
            interpreter.compiler.panic("Invalid type")
        }

        let name = struct_.name
        mut args: [(String, CheckedExpression)] = []
        for i in 0..materialised_fields.size() {
            let arg = materialised_fields[i]
            let label = callee.params[i].variable.name
            args.push((label, arg))
        }

        let call = CheckedCall(
            namespace_
            name
            args
            function_id: constructor
            return_type: struct_.type_id
            callee_throws: callee.can_throw
        )

        yield CheckedExpression::Call(
            call
            span: this_value.span
            type_id: struct_.type_id
        )
    }
    Enum(fields, enum_id, constructor) => {
        mut materialised_fields: [CheckedExpression] = []
        for field in fields {
            materialised_fields.push(value_to_checked_expression(field, interpreter))
        }

        let enum_ = interpreter.program.get_enum(enum_id)
        mut reversed_namespace: [ResolvedNamespace] = []
        mut scope_id: ScopeId? = enum_.scope_id
        while scope_id.has_value() {
            let scope = interpreter.program.get_scope(scope_id!)
            if scope.namespace_name.has_value() {
                reversed_namespace.push(ResolvedNamespace(name: scope.namespace_name!, generic_parameters: None))
            }
            scope_id = scope.parent
        }
        mut namespace_: [ResolvedNamespace] = []
        for i in reversed_namespace.size()..0 {
            namespace_.push(reversed_namespace[i - 1])
        }

        // FIXME: Fill these in.
        namespace_.push(ResolvedNamespace(name: enum_.name, generic_parameters: None))

        let name = enum_.name
        mut args: [(String, CheckedExpression)] = []
        for i in 0..materialised_fields.size() {
            let arg = materialised_fields[i]
            // FIXME: Fill this thing
            // let label = interpreter.program.get_variable(enum_.fields[i]).name
            args.push(("", arg))
        }

        let callee = interpreter.program.get_function(constructor)

        let call = CheckedCall(
            namespace_
            name: callee.name
            args
            function_id: constructor
            return_type: enum_.type_id
            callee_throws: callee.can_throw
        )

        yield CheckedExpression::Call(
            call
            span: this_value.span
            type_id: enum_.type_id
        )
    }
    JaktArray(values, type_id) => {
        mut vals: [CheckedExpression] = []
        for value in values {
            vals.push(value_to_checked_expression(value, interpreter))
        }

        let inner_type_id = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => args[0]
            else => {
                interpreter.compiler.panic("Expected generic instance of Array while materialising an array")
            }
        }

        yield CheckedExpression::JaktArray(
            vals
            repeat: None
            span: this_value.span
            type_id
            inner_type_id
        )
    }
    JaktDictionary(keys, values, type_id) => {
        mut vals: [(CheckedExpression, CheckedExpression)] = []
        for i in 0..keys.size() {
            vals.push((
                value_to_checked_expression(keys[i], interpreter),
                value_to_checked_expression(values[i], interpreter)
            ))
        }

        let (key_type_id, value_type_id) = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => (args[0], args[1])
            else => {
                interpreter.compiler.panic("Expected generic instance of Dictionary while materialising an array")
            }
        }

        yield CheckedExpression::JaktDictionary(
            vals
            span: this_value.span
            type_id
            key_type_id
            value_type_id
        )
    }
    JaktSet(values, type_id) => {
        mut vals: [CheckedExpression] = []
        for i in 0..values.size() {
            vals.push(value_to_checked_expression(values[i], interpreter))
        }

        let value_type_id = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => args[0]
            else => {
                interpreter.compiler.panic("Expected generic instance of Set while materialising an array")
            }
        }

        yield CheckedExpression::JaktSet(
            vals
            span: this_value.span
            type_id
            inner_type_id: value_type_id
        )
    }
    Function(captures, can_throw, return_type_id, type_id, block, checked_params, scope_id) => {
        // As all the captures are compiletime objects, we can simply inline them as assignments inside the block :P
        let parent_scope = interpreter.program.get_scope(block.scope_id)
        let inherited_scope_id = interpreter.program.create_scope(
            parent_scope_id: block.scope_id
            can_throw: parent_scope.can_throw
            debug_name: format("synthetic({})", parent_scope.debug_name)
            module_id: type_id.module)

        mut inherited_scope = interpreter.program.get_scope(inherited_scope_id)
        mut statements: [CheckedStatement] = []
        for capture in captures {
            let value = value_to_checked_expression(capture.1, interpreter)
            let var_id = interpreter.program.get_module(id: type_id.module).add_variable(CheckedVariable(
                name: capture.0
                type_id: value.type()
                is_mutable: false
                definition_span: this_value.span
                type_span: None
                visibility: CheckedVisibility::Public
            ))
            statements.push(CheckedStatement::VarDecl(
                var_id
                init: value
                span: this_value.span
            ))

            inherited_scope.comptime_bindings.set(capture.0, capture.1)
        }

        // Then append all the statements in the block
        statements.push_values(&block.statements)

        let new_block = CheckedBlock(
            statements
            scope_id: inherited_scope_id
            control_flow: block.control_flow
            yielded_type: block.yielded_type
            yielded_none: block.yielded_none
        )

        let checked_function = CheckedFunction(
            name: "synthetic_lambda"
            name_span: this_value.span
            visibility: CheckedVisibility::Public
            return_type_id
            return_type_span: None
            params: checked_params
            generics: FunctionGenerics(
                base_scope_id: inherited_scope_id
                base_params: checked_params
            )
            block: new_block
            can_throw
            type: FunctionType::Expression
            linkage: FunctionLinkage::Internal
            function_scope_id: inherited_scope_id
            struct_id: None
            is_instantiated: true
            parsed_function: None
            is_comptime: false
            is_virtual: false
            is_override: false
            is_unsafe: false
        )

        let register_function = &interpreter.typecheck_functions.register_function
        let pseudo_function_id = register_function(checked_function)

        yield CheckedExpression::Function(
            captures: []
            params: checked_params
            can_throw
            return_type_id
            block: new_block
            span: this_value.span
            type_id
            pseudo_function_id
            scope_id
        )
    }
    else => {
        interpreter.error(
            format("Cannot materialise the type {}", this_value.impl)
            this_value.span
        )
        interpreter.compiler.panic("Not yet implemented")
    }
}

enum Deferred {
    Expression(CheckedExpression)
    Statement(CheckedStatement)
}

class InterpreterScope {
    public bindings: [String:Value]
    public parent: InterpreterScope?
    public type_bindings: [TypeId:TypeId] = [:]
    public defers: [Deferred] = []
    compiler: Compiler
    public runtime_scope_id: ScopeId? = None

    public fn create(
        bindings: [String:Value] = [:]
        parent: InterpreterScope? = None
        type_bindings: [TypeId:TypeId] = [:]
        compiler: Compiler
        runtime_scope_id: ScopeId?
    ) -> InterpreterScope => InterpreterScope(
        bindings
        parent
        type_bindings
        compiler
        runtime_scope_id
    )

    public fn from_runtime_scope(scope_id: ScopeId, program: CheckedProgram, parent: InterpreterScope? = None) -> InterpreterScope {
        mut bindings: [String:Value] = [:]
        mut current_id: ScopeId? = scope_id
        while current_id.has_value() {
            let scope = program.get_scope(current_id!)
            for pair in scope.comptime_bindings {
                if bindings.contains(pair.0) {
                    continue
                }

                bindings.set(pair.0, pair.1)
            }
            for mixin in scope.resolution_mixins {
                let mixin_scope = program.get_scope(mixin.scope_id)
                for pair in mixin_scope.comptime_bindings {
                    if bindings.contains(pair.0) {
                        continue
                    }

                    bindings.set(pair.0, pair.1)
                }
            }
            current_id = scope.parent
        }

        return InterpreterScope(
            bindings
            parent
            compiler: program.compiler
            runtime_scope_id: scope_id
        )
    }

    public fn must_get(this, anon name: String) throws -> Value {
        if .bindings.contains(name) {
            return .bindings[name]
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.bindings.contains(name) {
                return scope!.bindings[name]
            }
            scope = scope!.parent
        }

        // How did this pass typecheck?
        .compiler.panic("Could not find binding")
    }

    public fn set(mut this, anon name: String, anon value: Value) throws {
        if .bindings.contains(name) {
            .bindings[name] = value
            return
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.bindings.contains(name) {
                scope!.bindings[name] = value
                return
            }
            scope = scope!.parent
        }

        // How did this pass typecheck?
        .compiler.panic("Could not find binding")
    }

    public fn all_bindings(this) -> [String:Value] {
        mut bindings: [String:Value] = [:]
        mut scope = Some(this)
        while scope.has_value() {
            for pair in scope!.bindings {
                if bindings.contains(pair.0) {
                    continue
                }

                bindings.set(pair.0, pair.1)
            }
            scope = scope!.parent
        }

        return bindings
    }

    public fn map_type(this, anon id: TypeId) -> TypeId {
        if .type_bindings.contains(id) {
            return .type_bindings[id]
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.type_bindings.contains(id) {
                return scope!.type_bindings[id]
            }
            scope = scope!.parent
        }

        return id
    }

    fn type_map_for_substitution_helper(this, map: &mut [TypeId:TypeId]) {
        if .parent.has_value() {
            .parent!.type_map_for_substitution_helper(map)
        }

        for pair in .type_bindings {
            map.set(pair.0, pair.1)
        }
    }

    public fn type_map_for_substitution(this) -> GenericInferences {
        mut map: [TypeId:TypeId] = [:]
        .type_map_for_substitution_helper(&mut map)
        return GenericInferences(values: map)
    }

    public fn perform_defers(mut this, mut interpreter: Interpreter, span: Span) throws {
        while not .defers.is_empty() {
            let deferred = .defers.pop()
            match deferred! {
                Expression(expr) => interpreter.execute_expression(expr, scope: this)
                Statement(statement) => interpreter.execute_statement(statement, scope: this, call_span: span)
            }
        }
    }

    public fn defer_expression(mut this, expr: CheckedExpression) {
        .defers.push(Deferred::Expression(expr))
    }

    public fn defer_statement(mut this, statement: CheckedStatement) {
        .defers.push(Deferred::Statement(statement))
    }
}

enum ExecutionResult {
    Return(Value)
    Throw(Value)
}

enum StatementResult {
    Return(Value)
    Throw(Value)
    Yield(Value)
    Continue
    Break
    JustValue(Value)
}

class Interpreter {
    public compiler: Compiler
    public program: CheckedProgram
    public spans: [Span]
    public reflected_type_cache: [TypeId:Value]
    public seen_reflected_types: {TypeId}
    public current_function_id: FunctionId?
    public typecheck_functions: TypecheckFunctions

    public fn create(
        compiler: Compiler
        program: CheckedProgram
        typecheck_functions: TypecheckFunctions
        spans: [Span]
    ) -> Interpreter {
        return Interpreter(
            compiler
            program
            spans
            reflected_type_cache: [:]
            seen_reflected_types: {}
            current_function_id: None
            typecheck_functions
        )
    }

    public fn enter_span(mut this, anon span: Span) {
        .spans.push(span)
    }

    public fn leave_span(mut this) {
        // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
        let dummy = .spans.pop()
    }

    public fn perform_final_interpretation_pass(
        mut this
        block: CheckedBlock
        runtime_scope: ScopeId? = None
        scope: InterpreterScope
        function_id: FunctionId?
    ) throws -> CheckedBlock {
        mut statements: [CheckedStatement] = []
        for statement in block.statements {
            let new_statement = .perform_final_interpretation_pass(statement, scope, function_id)
            statements.push(new_statement)
        }
        return CheckedBlock(
            statements
            scope_id: block.scope_id
            control_flow: block.control_flow
            yielded_type: block.yielded_type
            yielded_none: block.yielded_none
        )
    }

    private fn typecheck_block(mut this, block: ParsedBlock, scope: ScopeId, function_id: FunctionId?) throws -> CheckedBlock {
        return invoke_typecheck_block(&.typecheck_functions.block, block, scope, function_id)
    }

    private fn invoke_typecheck_block(
        anon function: &fn(
            parsed_block: ParsedBlock
            parent_scope_id: ScopeId
            safety_mode: SafetyMode
            yield_type_hint: TypeId?
            function_id: FunctionId?
        ) throws -> CheckedBlock
        anon block: ParsedBlock
        anon parent_scope_id: ScopeId
        anon function_id: FunctionId?
    ) throws -> CheckedBlock {
        return function(
            parsed_block: block
            parent_scope_id
            safety_mode: SafetyMode::Safe
            yield_type_hint: None
            containing_function_id: function_id
        )
    }


    public fn perform_final_interpretation_pass(
        mut this
        block: ParsedBlock
        runtime_scope: ScopeId
        scope: InterpreterScope
        function_id: FunctionId?
    ) throws -> CheckedBlock {
        mut rscope = .program.get_scope(runtime_scope)
        for (name, value) in scope.all_bindings() {
            rscope.comptime_bindings.set(name, value)
        }

        return .perform_final_interpretation_pass(
            block: .typecheck_block(block, scope: runtime_scope, function_id)
            runtime_scope
            scope
            function_id
        )
    }

    public fn perform_final_interpretation_pass(
        mut this
        statement: CheckedStatement
        scope: InterpreterScope
        function_id: FunctionId?
    ) throws -> CheckedStatement => match statement {
        Expression(expr, span) => CheckedStatement::Expression(expr: .perform_final_interpretation_expr_pass(expr, scope, function_id), span)
        Defer(statement, span) => CheckedStatement::Defer(statement: .perform_final_interpretation_pass(statement, scope, function_id), span)
        DestructuringDeclaration(vars, var_decl, span) => CheckedStatement::DestructuringDeclaration(vars: vars, var_decl: .perform_final_interpretation_pass(statement: var_decl, scope, function_id), span)
        VarDecl(var_id, init, span) => CheckedStatement::VarDecl(var_id, init: .perform_final_interpretation_expr_pass(expr: init, scope, function_id), span)
        If(condition, then_block, else_statement, span) => {
            let new_condition = .perform_final_interpretation_expr_pass(expr: condition, scope, function_id)
            mut then_statements: [CheckedStatement] = []
            for statement in then_block.statements.iterator() {
                then_statements.push(.perform_final_interpretation_pass(statement, scope, function_id))
            }
            let new_then_block = CheckedBlock(
                statements: then_statements
                scope_id: then_block.scope_id
                control_flow: then_block.control_flow
                yielded_type: then_block.yielded_type
                yielded_none: then_block.yielded_none
            )
            let new_else_statement = match else_statement.has_value() {
                true => Some(.perform_final_interpretation_pass(statement: else_statement!, scope, function_id))
                else => None
            }
            yield CheckedStatement::If(
                condition: new_condition
                then_block: new_then_block
                else_statement: new_else_statement
                span)
        }
        Block(block, span) => {
            mut statements: [CheckedStatement] = []
            for statement in block.statements.iterator() {
                statements.push(.perform_final_interpretation_pass(statement, scope, function_id))
            }
            let new_block = CheckedBlock(
                statements: statements
                scope_id: block.scope_id
                control_flow: block.control_flow
                yielded_type: block.yielded_type
                yielded_none: block.yielded_none
            )
            yield CheckedStatement::Block(block: new_block, span)
        }
        Loop(block, span) => {
            mut statements: [CheckedStatement] = []
            for statement in block.statements.iterator() {
                statements.push(.perform_final_interpretation_pass(statement, scope, function_id))
            }
            let new_block = CheckedBlock(
                statements: statements
                scope_id: block.scope_id
                control_flow: block.control_flow
                yielded_type: block.yielded_type
                yielded_none: block.yielded_none
            )
            yield CheckedStatement::Loop(block: new_block, span)
        }
        While(condition, block, span) => {
            let new_condition = .perform_final_interpretation_expr_pass(expr: condition, scope, function_id)
            mut statements: [CheckedStatement] = []
            for statement in block.statements.iterator() {
                statements.push(.perform_final_interpretation_pass(statement, scope, function_id))
            }
            let new_block = CheckedBlock(
                statements: statements
                scope_id: block.scope_id
                control_flow: block.control_flow
                yielded_type: block.yielded_type
                yielded_none: block.yielded_none
            )
            yield CheckedStatement::While(
                condition: new_condition
                block: new_block
                span)
        }
        Return(val, span) => match val.has_value() {
            true => CheckedStatement::Return(val: .perform_final_interpretation_expr_pass(expr: val!, scope, function_id), span)
            false => statement
        }
        Break | Continue | InlineCpp | Garbage => statement
        Throw(expr, span) => CheckedStatement::Throw(expr: .perform_final_interpretation_expr_pass(expr, scope, function_id), span)
        Yield(expr, span) => match expr.has_value() {
            true => CheckedStatement::Yield(expr: .perform_final_interpretation_expr_pass(expr: expr!, scope, function_id), span)
            false => statement
        }
    }

    public fn perform_final_interpretation_expr_pass(
        mut this
        expr: CheckedExpression
        scope: InterpreterScope
        function_id: FunctionId?
    ) throws -> CheckedExpression {
        if expr is UnaryOp(op) and op is TypeCast {
            eprintln("{0:c}[31mFixup{0:c}[0m {1}", 0x1b, expr)
        }
        return match expr {
        ComptimeIndex(expr, index, is_optional, span) => {
            let index_result = .execute_expression(expr: index, scope)

            let index_constant = match index_result {
                JustValue(value) => match value.impl {
                    JaktString(val) => NumericOrStringValue::StringValue(val)
                    U8(val) | U16(val) | U32(val) | U64(val) | USize(val) => NumericOrStringValue::UnsignedNumericValue(val as! u64)
                    I8(val) | I16(val) | I32(val) | I64(val) => NumericOrStringValue::SignedNumericValue(val as! i64)
                    else => {
                        .error(format("Index expression evaluation failed: expected numeric or string type, found {}", value.impl), span)
                        return CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
                    }
                }
                else => {
                    .error(format("Index expression evaluation returned an invalid object {}", index_result), span)
                    return CheckedExpression::Garbage(span, type_id: builtin(BuiltinType::Void))
                }
            }

            match index_constant {
                StringValue(field) => {
                    let checked_expr_type_id = scope.map_type(expr.type())
                    let checked_expr_type = .program.get_type(checked_expr_type_id)
                    let optional_struct_id = .program.find_struct_in_prelude("Optional")
                    match checked_expr_type {
                        Type::GenericInstance(id, args) => {
                            mut type_id = checked_expr_type_id

                            if is_optional {
                                if not id.equals(optional_struct_id) {
                                    .error("Optional chaining is only allowed on optional types", span)
                                    .compiler.panic("Invalid operation")
                                }

                                type_id = args[0]
                            }

                            match .program.get_type(type_id) {
                                GenericInstance(id: struct_id) | Struct(struct_id) => {
                                    let structure = .program.get_struct(struct_id)
                                    for member_id in structure.fields.iterator() {
                                        let member = .program.get_variable(member_id.variable_id)

                                        if member.name == field {
                                            mut resolved_type_id = scope.map_type(member.type_id)
                                            if is_optional {
                                                resolved_type_id = .find_or_add_type_id(Type::GenericInstance(id: optional_struct_id, args: [resolved_type_id]))
                                            }
                                            // FIXME: Check access perms
                                            return CheckedExpression::IndexedStruct(
                                                expr
                                                name: field
                                                index: member_id.variable_id
                                                span
                                                is_optional
                                                type_id: resolved_type_id)
                                        }
                                    }

                                    .error(format("unknown member of struct: {}.{}", structure.name, field), span)
                                    .compiler.panic("Invalid operation")
                                }
                                else => {
                                    .error(format("Member field access on value of non-struct type ‘{}’", .program.type_name(checked_expr_type_id)), span)
                                    .compiler.panic("Invalid operation")
                                }
                            }
                        }
                        Type::Struct(struct_id) => {
                            if is_optional {
                                .error("Optional chaining is not allowed on non-optional types", span)
                                .compiler.panic("Invalid operation")
                            }

                            let structure = .program.get_struct(struct_id)
                            for member_id in structure.fields {
                                let member = .program.get_variable(member_id.variable_id)

                                if member.name == field {
                                    let resolved_type_id = scope.map_type(member.type_id)
                                    // FIXME: Check access perms
                                    return CheckedExpression::IndexedStruct(
                                        expr
                                        name: field
                                        index: member_id.variable_id
                                        span
                                        is_optional
                                        type_id: resolved_type_id)
                                }
                            }

                            .error(format("unknown member of struct: {}.{}", structure.name, field), span)
                            .compiler.panic("Invalid operation")
                        }
                        else => {
                            .error(format("Member field access on value of non-struct type ‘{}’", .program.type_name(checked_expr_type_id)), span)
                            .compiler.panic("Invalid operation")
                        }
                    }
                }
                UnsignedNumericValue(val) | SignedNumericValue(val) => {
                    .error("Unimplemented expression", span)
                    .compiler.panic("Not yet implemented")
                }
            }
        }
        UnaryOp(expr, op, span, type_id) => CheckedExpression::UnaryOp(
            expr: .perform_final_interpretation_expr_pass(expr, scope, function_id),
            op: match op {
                TypeCast(cast) => CheckedUnaryOperator::TypeCast(match cast {
                    Fallible(type_id) => CheckedTypeCast::Fallible(scope.map_type(type_id))
                    Infallible(type_id) => CheckedTypeCast::Infallible(scope.map_type(type_id))
                    Identity(type_id) => CheckedTypeCast::Identity(scope.map_type(type_id))
                })
                else => op
            },
            span: span,
            type_id: scope.map_type(type_id)
        )
        BinaryOp(lhs, op, rhs, span, type_id) => CheckedExpression::BinaryOp(
            lhs: .perform_final_interpretation_expr_pass(expr: lhs, scope, function_id),
            op: op,
            rhs: .perform_final_interpretation_expr_pass(expr: rhs, scope, function_id),
            span: span,
            type_id: scope.map_type(type_id)
        )
        Call(call, span, type_id) => {
            mut new_args: [(String, CheckedExpression)] = []
            for arg in call.args.iterator() {
                new_args.push((
                    arg.0,
                    .perform_final_interpretation_expr_pass(expr: arg.1, scope, function_id)
                ))
            }
            yield CheckedExpression::Call(
                call: CheckedCall(
                    namespace_: call.namespace_
                    name: call.name
                    args: new_args
                    type_args: call.type_args
                    function_id: call.function_id
                    return_type: call.return_type
                    callee_throws: call.callee_throws
                )
                span
                type_id
            )
        }
        MethodCall(expr, call, span, is_optional, type_id) => {
            mut new_args: [(String, CheckedExpression)] = []
            for arg in call.args.iterator() {
                new_args.push((
                    arg.0,
                    .perform_final_interpretation_expr_pass(expr: arg.1, scope, function_id)
                ))
            }
            yield CheckedExpression::MethodCall(
                expr: .perform_final_interpretation_expr_pass(expr, scope, function_id)
                call: CheckedCall(
                    namespace_: call.namespace_
                    name: call.name
                    args: new_args
                    type_args: call.type_args
                    function_id: call.function_id
                    return_type: call.return_type
                    callee_throws: call.callee_throws
                )
                span
                is_optional
                type_id
            )
        }
        // FIXME: Implement the rest
        else => expr
    }}

    public fn get_prelude_function(this, anon scope_id: ScopeId) -> bool {
        mut current_scope_id = scope_id
        let prelude_scope_id = .program.prelude_scope_id()
        loop {
            if current_scope_id.equals(prelude_scope_id) {
                return true
            }

            let scope = .program.get_scope(current_scope_id)
            if scope.parent.has_value() {
                current_scope_id = scope.parent!
                continue
            }

            return false
        }
    }

    public fn find_or_add_type_id(mut this, anon type: Type) -> TypeId {
        let type_hash = type.hash()
        for index in 0...program.modules.size() {
            let module = &.program.modules[index]
            let types = &module.types
            if module.type_skip_list.get(type_hash) is Some(head) {
                mut current = head
                while true {
                    let other = &types[current.id]
                    if other.type.equals(type) {
                        return current
                    }
                    guard other.next_with_same_hash.has_value() else { break }
                    current = other.next_with_same_hash!
                }
            }
        }

        .program.modules[0].add_type(type)
        return TypeId(module: ModuleId(id: 0), id: .program.modules[0].types.size() - 1)
    }

    public fn call_prelude_function(
        mut this
        anon prelude_function: String
        anon namespace_: [ResolvedNamespace]
        this_argument: Value?
        arguments: [Value]
        call_span: Span
        type_bindings: [TypeId:TypeId]
        runtime_scope_id: ScopeId?
    ) throws -> StatementResult {
        if namespace_.size() != 1 {
            return match prelude_function {
                "format" => {
                    let format_string = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Expected string as first argument to format, got {}", arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::JaktString(
                                comptime_format_impl(format_string, arguments: arguments[1..], program: &.program)
                            )
                            span: call_span
                        )
                    )
                }
                "println" | "eprintln" | "print" | "eprint" => {
                    let format_string = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(format( "println expects a string as its first argument, but got {}", arguments[0].impl), call_span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    let formatted_string = comptime_format_impl(format_string, arguments: arguments[1..], program: &.program)
                    match prelude_function {
                        "println" => println("{}", formatted_string)
                        "eprintln" => eprintln("{}", formatted_string)
                        "print" => print("{}", formatted_string)
                        else => eprint("{}", formatted_string)
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Void
                            span: call_span
                        )
                    )
                }
                "as_saturated" => {
                    let function = .program.get_function(.program.find_functions_with_name_in_scope(
                        parent_scope_id: .program.prelude_scope_id()
                        function_name: "as_saturated")![0])

                    let output_type_id = type_bindings.get(function.generics.params[0].type_id())
                    yield StatementResult::JustValue(
                        cast_value_to_type(arguments[0], output_type_id!, interpreter: this, saturating: true)
                    )
                }
                "unchecked_mul" => {
                    let lhs_value = arguments[0]
                    let rhs_value = arguments[1]
                    let span = call_span

                    yield StatementResult::JustValue(
                        Value(
                            impl: match lhs_value.impl {
                                U8(x) => match rhs_value.impl {
                                    U8(y) => ValueImpl::U8(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U16(x) => match rhs_value.impl {
                                    U16(y) => ValueImpl::U16(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U32(x) => match rhs_value.impl {
                                    U32(y) => ValueImpl::U32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U64(x) => match rhs_value.impl {
                                    U64(y) => ValueImpl::U64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I8(x) => match rhs_value.impl {
                                    I8(y) => ValueImpl::I8(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I16(x) => match rhs_value.impl {
                                    I16(y) => ValueImpl::I16(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I32(x) => match rhs_value.impl {
                                    I32(y) => ValueImpl::I32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I64(x) => match rhs_value.impl {
                                    I64(y) => ValueImpl::I64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                F32(x) => match rhs_value.impl {
                                    F32(y) => ValueImpl::F32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                F64(x) => match rhs_value.impl {
                                    F64(y) => ValueImpl::F64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                USize(x) => match rhs_value.impl {
                                    USize(y) => ValueImpl::USize(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                else => {
                                    .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                    .compiler.panic("Invalid type")
                                }
                            }
                            span
                        )
                    )
                }
                "unchecked_add" => {
                    let lhs_value = arguments[0]
                    let rhs_value = arguments[1]
                    let span = call_span

                    yield StatementResult::JustValue(
                        Value(
                            impl: match lhs_value.impl {
                                U8(x) => match rhs_value.impl {
                                    U8(y) => ValueImpl::U8(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U16(x) => match rhs_value.impl {
                                    U16(y) => ValueImpl::U16(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U32(x) => match rhs_value.impl {
                                    U32(y) => ValueImpl::U32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                U64(x) => match rhs_value.impl {
                                    U64(y) => ValueImpl::U64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I8(x) => match rhs_value.impl {
                                    I8(y) => ValueImpl::I8(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I16(x) => match rhs_value.impl {
                                    I16(y) => ValueImpl::I16(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I32(x) => match rhs_value.impl {
                                    I32(y) => ValueImpl::I32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                I64(x) => match rhs_value.impl {
                                    I64(y) => ValueImpl::I64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                F32(x) => match rhs_value.impl {
                                    F32(y) => ValueImpl::F32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                F64(x) => match rhs_value.impl {
                                    F64(y) => ValueImpl::F64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                USize(x) => match rhs_value.impl {
                                    USize(y) => ValueImpl::USize(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        .compiler.panic("Invalid type")
                                    }
                                }
                                else => {
                                    .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                    .compiler.panic("Invalid type")
                                }
                            }
                            span
                        )
                    )
                }
                "abort" => {abort()}
                "Set" => {
                    if type_bindings.size() != 1 {
                        .error("Set constructor expects one generic argument", call_span)
                        .compiler.panic("Invalid type")
                    }
                    let set_struct_id = .program.find_struct_in_prelude("Set")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [type_bindings.get(type_bindings.keys()[0])!]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktSet(values: [], type_id)
                        span: call_span
                    ))
                }
                "Dictionary" => {
                    if type_bindings.size() != 2 {
                        .error("Dictionary constructor expects two generic argumenst", call_span)
                        .compiler.panic("Invalid type")
                    }
                    let dictionary_struct_id = .program.find_struct_in_prelude("Dictionary")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: dictionary_struct_id, args: [
                        type_bindings.get(type_bindings.keys()[0])!,
                        type_bindings.get(type_bindings.keys()[1])!,
                    ]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktDictionary(keys: [], values: [], type_id)
                        span: call_span
                    ))
                }
                "from_string_literal" => {
                    yield StatementResult::JustValue(arguments[0])
                }
                else => {
                    .error(
                        format("Prelude function {}::{} is not implemented yet", namespace_, prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
        }

        return match namespace_[0].name {
            "Error" => match prelude_function {
                "from_errno" => {
                    let err = arguments[0]
                    let error_struct_id = .program.find_struct_in_prelude("Error")
                    let error_struct = .program.get_struct(error_struct_id)
                    let scope = .program.get_scope(error_struct.scope_id)
                    let constructors = scope.functions.get("from_errno")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    err
                                ],
                                struct_id: error_struct_id
                                constructor: constructors![0]
                            )
                            span: call_span
                        )
                    )
                }
                "from_string_literal" => {
                    let err = arguments[0]
                    let error_struct_id = .program.find_struct_in_prelude("Error")
                    let error_struct = .program.get_struct(error_struct_id)
                    let scope = .program.get_scope(error_struct.scope_id)
                    let constructors = scope.functions.get("from_string_literal")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    err
                                ],
                                struct_id: error_struct_id
                                constructor: constructors![0]
                            )
                            span: call_span
                        )
                    )
                }
                "code" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        I32(code) => StatementResult::JustValue(Value(impl: ValueImpl::I32(code), span: call_span))
                        else => {
                            .error(
                                format("Error should have `i32` as its code, but got {}", fields[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `Error::code` expects an Error as its this argument, but got {}", this_argument!.impl),
                            call_span
                        )
                        .compiler.panic("Invalid type")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Error::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "File" => match prelude_function {
                "open_for_reading" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    let path_value = Value(
                        impl: ValueImpl::JaktString(path.to_string())
                        span: call_span
                    )
                    .compiler.files_used_in_build.add(path.to_string())
                    if not path.exists() {
                        return StatementResult::Throw(.error_value(format("Could not find file at path {}", path.to_string()), call_span))
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let constructors = scope.functions.get("open_for_reading")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    path_value
                                ],
                                struct_id: file_struct_id
                                constructor: constructors![0]
                            )
                            span: call_span
                        )
                    )
                }
                "open_for_writing" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    let path_value = Value(
                        impl: ValueImpl::JaktString(path.to_string())
                        span: call_span
                    )
                    .compiler.files_used_in_build.add(path.to_string())
                    if not path.exists() {
                        return StatementResult::Throw(.error_value(format("Could not find file at path {}", path.to_string()), call_span))
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let constructor = scope.functions.get("open_for_writing")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    path_value
                                ],
                                struct_id: file_struct_id
                                constructor: constructor![0]
                            )
                            span: call_span
                        )
                    )
                }
                "read_all" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::read_all")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::read_all` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_reading = scope.functions.get("open_for_reading")![0]
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_reading) {
                                .error(
                                    "Cannot read from a file not opened for reading"
                                    call_span
                                )
                                // FIXME: This could contain a better error
                                // message
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }

                    mut file = File::open_for_reading(path)
                    mut result_values: [Value] = []
                    for byte in file.read_all() {
                        result_values.push(Value(
                            impl: ValueImpl::U8(byte)
                            span: call_span
                        ))
                    }
                    let array_struct_id = .program.find_struct_in_prelude("Array")

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::JaktArray(
                                values: result_values
                                type_id: .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [builtin(BuiltinType::U8)]))
                            )
                            span: call_span
                        )
                    )
                }
                "read" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::read")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::read` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_reading = scope.functions.get("open_for_reading")![0]
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_reading) {
                                .error(
                                    "Cannot read from a file not opened for reading"
                                    call_span
                                )
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }
                    mut file = File::open_for_reading(path)
                    mut values_buffer = match arguments[0].impl {
                        JaktArray(values) => values
                        else => {
                            .error(
                                format("Prelude function `File::read` expects a `[u8]` as its argument, but got {}", arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    mut byte_buffer: [u8] = [0; values_buffer.size()]
                    let bytes_read = file.read(byte_buffer)

                    for i in 0..byte_buffer.size() {
                        values_buffer[i] = Value(
                            impl: ValueImpl::U8(byte_buffer[i])
                            span: call_span
                        )
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(bytes_read)
                            span: call_span
                        )
                    )
                }
                "exists" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    .compiler.files_used_in_build.add(path.to_string())
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Bool(path.exists())
                            span: call_span
                        )
                    )
                }
                "write" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::write")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::write` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_writing = scope.functions.get("open_for_writing")![0]
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_writing) {
                                .error(
                                    "Cannot write to a file not opened for writing"
                                    call_span
                                )
                                // FIXME: This could have a better message
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }
                    mut file = File::open_for_writing(path)
                    mut data_values = match arguments[0].impl {
                        JaktArray(values) => values
                        else => {
                            .error(
                                format("Prelude function `File::write` expects a `[u8]` as its argument, but got {}", arguments[0].impl),
                                call_span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    mut data: [u8] = []
                    for val in data_values {
                        data.push(match val.impl {
                            U8(x) => x
                            else => {panic("expected byte")}
                        })
                    }
                    let bytes_written = file.write(data)

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(bytes_written)
                            span: call_span
                        )
                    )
                }
                else => {
                    .error(
                        format("Prelude function `File::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "StringBuilder" => match prelude_function {
                "create" => {
                    let string_builder_struct_id = .program.find_struct_in_prelude("StringBuilder")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [Value(impl: ValueImpl::JaktString(""), span: call_span)],
                                struct_id: string_builder_struct_id,
                                constructor: None
                            )
                            span: call_span
                        )
                    )
                }
                "append" | "append_code_point" | "append_escaped_for_json" => {
                    mut (fields, current_string) = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(value) => (fields, value)
                            else => {
                                panic("Invalid use of prelude StringBuilder")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                                call_span
                            )
                            .compiler.panic("Invalid call")
                        }
                    }

                    mut builder = StringBuilder::create()
                    builder.append(current_string)
                    match prelude_function {
                        "append" => match arguments[0].impl {
                            U8(value) => builder.append(value)
                            StringView(value) => builder.append(value)
                            JaktString(value) => builder.append(value)
                            // FIXME: When we can represent raw pointers in the interpreter, implement the 2 arg overload
                            else => {
                                .error(format("Invalid use of StringBuilder::append({})", arguments[0].impl), call_span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        "append_escaped_for_json" => builder.append_escaped_for_json(match arguments[0].impl {
                            JaktString(value) => value
                            else => {
                                .error("Invalid use of StringBuilder::append_escaped_for_json()", call_span)
                                .compiler.panic("Invalid type")
                            }
                        })
                        "append_code_point" => builder.append_code_point(match arguments[0].impl {
                            U32(value) => value
                            else => {
                                .error("Invalid use of StringBuilder::append_code_point()", call_span)
                                .compiler.panic("Invalid type")
                            }
                        })
                        else => {
                            abort()
                        }
                    }

                    fields[0] = Value(
                        impl: ValueImpl::JaktString(builder.to_string())
                        span: call_span
                    )

                    yield StatementResult::JustValue(
                        Value(impl: ValueImpl::Void, span: call_span)
                    )
                }
                "to_string" => match this_argument!.impl {
                    Struct(fields) => StatementResult::JustValue(fields[0])
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        .compiler.panic("Not yet implemented")
                    }
                }
                "is_empty" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_empty()), span: call_span))
                        else => {
                            panic("Invalid use of prelude StringBuilder")
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        .compiler.panic("Not yet implemented")
                    }
                }
                "length" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::USize(value.length()), span: call_span))
                        else => {
                            panic("Invalid use of prelude StringBuilder")
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        .compiler.panic("Not yet implemented")
                    }
                }
                "clear" => match this_argument!.impl {
                    Struct(fields) => {
                        mut mutable_fields = fields
                        mutable_fields[0].impl = ValueImpl::JaktString(value: "")
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        .compiler.panic("Not yet implemented")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `StringBuilder::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "Dictionary" => match prelude_function {
                "Dictionary" => {
                    if type_bindings.size() != 2 {
                        .error("Dictionary constructor expects two generic argumenst", call_span)
                        .compiler.panic("Invalid type")
                    }
                    let dictionary_struct_id = .program.find_struct_in_prelude("Dictionary")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: dictionary_struct_id, args: [
                        type_bindings.get(type_bindings.keys()[0])!,
                        type_bindings.get(type_bindings.keys()[1])!,
                    ]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktDictionary(keys: [], values: [], type_id)
                        span: call_span
                    ))
                }
                "get" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }

                        yield StatementResult::JustValue(match found_index.has_value() {
                            true => Value(
                                impl: ValueImpl::OptionalSome(value: values[found_index!])
                                span: call_span
                            )
                            else => Value(
                                impl: ValueImpl::OptionalNone
                                span: call_span
                            )
                        })
                    }
                    else => {
                        panic("Invalid use of Dictionary::get()")
                    }
                }
                "set" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }

                        mut mutable_keys = keys
                        mut mutable_values = values

                        if found_index.has_value() {
                            mutable_values[found_index!] = arguments[1]
                        } else {
                            mutable_keys.push(arguments[0])
                            mutable_values.push(arguments[1])
                        }

                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::Void,
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::set()")
                    }
                }
                "is_empty" => match this_argument!.impl {
                    JaktDictionary(keys, values) => StatementResult::JustValue(Value(
                        impl: ValueImpl::Bool(keys.is_empty() and values.is_empty())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::is_empty()")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktDictionary(keys) => {
                        mut found = false
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }

                        yield StatementResult::JustValue(Value(
                                impl: ValueImpl::Bool(found)
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::contains()")
                    }
                }
                "remove" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }
                        if found_index.has_value() {
                            mut keys_without: [Value] = []
                            mut values_without: [Value] = []

                            for i in 0..keys.size() {
                                if i == found_index! {
                                    continue
                                }
                                keys_without.push(keys[i])
                                values_without.push(values[i])
                            }

                            mut mutable_keys = keys
                            mut mutable_values = values
                            mutable_keys.shrink(0)
                            mutable_values.shrink(0)
                            for i in 0..keys_without.size() {
                                mutable_keys.push(keys_without[i])
                                mutable_values.push(values_without[i])
                            }
                        }

                        yield StatementResult::JustValue(Value(
                                impl: ValueImpl::Bool(found_index.has_value())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::remove()")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktDictionary(keys, values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_keys = keys
                            mut mutable_values = values
                            mutable_keys.ensure_capacity(capacity)
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Dictionary::ensure_capacity must be called with a usize", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid use of Dictionary::ensure_capacity()")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktDictionary(keys) => StatementResult::JustValue(Value(
                        impl: ValueImpl::USize(keys.capacity())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::capacity()")
                    }
                }
                "clear" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut mutable_keys = keys
                        mut mutable_values = values
                        mutable_keys.shrink(0)
                        mutable_values.shrink(0)
                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::Void
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::clear()")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktDictionary(keys) => StatementResult::JustValue(Value(
                        impl: ValueImpl::USize(keys.size())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::size()")
                    }
                }
                "keys" => match this_argument!.impl {
                    JaktDictionary(keys, type_id) => {
                        let generics = match .program.get_type(type_id) {
                            GenericInstance(args) => args
                            else => {
                                panic("expected generic instance")
                            }
                        }
                        guard generics.size() == 2 else {
                            panic("dictionary should have 2 generic args. one for keys, one for values")
                        }
                        let array_struct_id = .program.find_struct_in_prelude("Array")
                        let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [generics[0]]))
                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::JaktArray(values: keys, type_id)
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::keys()")
                    }
                }
                "iterator" => match this_argument!.impl {
                    JaktDictionary => {
                        let struct_id = .program.find_struct_in_prelude("DictionaryIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::iterator()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Dictionary::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "Array" => match prelude_function {
                "iterator" => match this_argument!.impl {
                    JaktArray => {
                        let struct_id = .program.find_struct_in_prelude("ArrayIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::iterator()")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktArray(values) => {
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::USize(values.size())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::size()")
                    }
                }
                "push" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        mutable_values.push(arguments[0])
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void,
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "push_values" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        match arguments[0].impl {
                            JaktArray(values) => {
                                for value in values {
                                    mutable_values.push(value)
                                }
                            }
                            else => .error("Only argument to push_values needs to be another Array", call_span)
                        }
                        yield StatementResult::JustValue(
                            Value(impl: ValueImpl::Void, span: call_span)
                        )
                    }
                    else => {
                        panic("Invalid use of Array::push_values()")
                    }
                }
                "pop" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.pop()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            false => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "first" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.first()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            false => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "last" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.last()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            false => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut found = false
                        for value in values {
                            if value.impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Bool(found),
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::contains()")
                    }
                }
                "is_empty" => match this_argument!.impl {
                    JaktArray(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Bool(values.is_empty()),
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid use of Array::is_empty()")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktArray(values) => {
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::USize(values.capacity())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::capacity()")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::ensure_capacity must be called with a usize", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid use of Array::ensure_capacity()")
                    }
                }
                "add_capacity" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.add_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::add_capacity must be called with a usize", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid use of Array::add_capacity()")
                    }
                }
                "shrink" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(size) => {
                            mut mutable_values = values
                            mutable_values.shrink(size)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::shrink must be called with a usize", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid use of Array::shrink()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Array::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "ArrayIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid ArrayIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktArray(values) => match values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    yield Value(impl: ValueImpl::OptionalSome(value: values[index]), span: call_span)
                                }
                                else => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid ArrayIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid ArrayIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `ArrayIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            // Note: This does _not_ share the same layout in the rt, but we can just increment/decrement the start value.
            "Range" => match prelude_function {
                "next" => {
                    mut fields = match this_argument!.impl {
                        Struct(fields) => fields
                        else => {
                            panic("Invalid use of Range::next()")
                        }
                    }

                    let start = match fields[0].impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for comptime range")
                        }
                    }

                    let end = match fields[1].impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for comptime range")
                        }
                    }

                    if start == end {
                        return StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                    }

                    if start > end {
                        fields[0] = Value(
                            impl: ValueImpl::U64(start - 1)
                            span: call_span
                        )
                    } else {
                        fields[0] = Value(
                            impl: ValueImpl::U64(start + 1)
                            span: call_span
                        )
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::OptionalSome(value: Value(
                                impl: ValueImpl::U64(start)
                                span: call_span
                            )),
                            span: call_span
                        )
                    )
                }
                "inclusive" => match this_argument!.impl {
                    Struct(fields, struct_id, constructor) => {
                        mut mutable_fields = fields
                        let end = match fields[1].impl {
                            I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                            else => {
                                panic("Invalid type for comptime range")
                            }
                        }
                        mutable_fields[1].impl =  ValueImpl::U64(end + 1)
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Struct(fields, struct_id, constructor), span: this_argument!.span))
                    }
                    else => {
                        panic("Invalid use of Range::inclusive()")
                    }
                }
                "exclusive" => match this_argument!.impl {
                    Struct => StatementResult::JustValue(this_argument!)
                    else => {
                        panic("Invalid use of Range::exclusive()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Range::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "String" => match prelude_function {
                "is_empty" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_empty()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "length" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::USize(value.length()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "hash" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::U32(value.hash()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "substring" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        USize(start)
                        | U64(start)
                        | U32(start)
                        | U16(start)
                        | U8(start)
                        => match arguments[1].impl {
                            USize(length)
                            | U64(length)
                            | U32(length)
                            | U16(length)
                            | U8(length)
                            => {
                                let result = value.substring(start: start as! usize, length: length as! usize)
                                yield StatementResult::JustValue(Value(impl: ValueImpl::JaktString(result), span: call_span))
                            }
                            else => {
                                .error("String::substring must be called with unsigned arguments", arguments[1].span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            .error("String::substring must be called with unsigned arguments", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "number" => match arguments[0].impl {
                    I64(number)
                    | U32(number)
                    | I32(number)
                    | U16(number)
                    | I16(number)
                    | U8(number)
                    | I8(number)
                    => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(String::number(number as! i64)), span: call_span))
                    USize() | U64() => {
                        .error("String::number must not be called with a usize or u64", arguments[0].span)
                        .compiler.panic("Invalid type")
                    }
                    else => {
                        .error("String::number must be called with an integer", arguments[0].span)
                        .compiler.panic("Invalid type")
                    }
                }
                "to_number" => match this_argument!.impl {
                    JaktString(value) => {
                        if type_bindings.size() < 1 {
                            .error("to_number expects one generic argument", call_span)
                            .compiler.panic("Invalid type")
                        }

                        let target_type = .program.get_type(type_bindings.get(type_bindings.keys()[0])!)
                        yield match target_type {
                            I32 => {
                                let v = value.to_number<i32>()
                                let impl = match v.has_value() {
                                    true => ValueImpl::OptionalSome(value: Value(impl: ValueImpl::I32(v!), span: call_span))
                                    false => ValueImpl::OptionalNone
                                }
                                yield StatementResult::JustValue(Value(impl, span: call_span))
                            }
                            U32 => {
                                let v = value.to_number<u32>()
                                let impl = match v.has_value() {
                                    true => ValueImpl::OptionalSome(value: Value(impl: ValueImpl::U32(v!), span: call_span))
                                    false => ValueImpl::OptionalNone
                                }
                                yield StatementResult::JustValue(Value(impl, span: call_span))
                            }
                            // FIXME: Add support for other number types
                            else => {
                                .compiler.panic("Invalid or unsupported type for String::to_number")
                            }
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "is_whitespace" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_whitespace()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.contains(arg)), span: call_span))
                        else => {
                            .error("String::contains must be called with a string", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "replace" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(replace) => match arguments[1].impl {
                            JaktString(with) => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(value.replace(replace, with)), span: call_span))
                            else => {
                                .error("String::replace must be called with strings", arguments[1].span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            .error("String::replace must be called with strings", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "byte_at" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        USize(index)
                        | U64(index)
                        | U32(index)
                        | U16(index)
                        | U8(index)
                        => StatementResult::JustValue(Value(impl: ValueImpl::U8(value.byte_at(index as! usize)), span: call_span))
                        else => {
                            .error("String::byte_at must be called with an unsigned integer", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "split" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        CChar(c) => {
                            let values = value.split(c)
                            mut result: [Value] = []
                            for value in values {
                                result.push(Value(impl: ValueImpl::JaktString(value), span: call_span))
                            }
                            let array_struct_id = .program.find_struct_in_prelude("Array")
                            yield StatementResult::JustValue(Value(
                                impl: ValueImpl::JaktArray(
                                    values: result
                                    type_id: .find_or_add_type_id(
                                        Type::GenericInstance(id: array_struct_id, args: [.string_type()])
                                    )
                                )
                                span: call_span
                            ))
                        }
                        else => {
                            .error("String::split must be called with a c_char", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "starts_with" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.starts_with(arg)), span: call_span))
                        else => {
                            .error("String::starts_with must be called with a string", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "ends_with" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.ends_with(arg)), span: call_span))
                        else => {
                            .error("String::ends_with must be called with a string", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "repeated" => {
                    if arguments.size() != 2 {
                        .error("String::repeated must be called with a c_char and a usize", call_span)
                        .compiler.panic("Invalid type")
                    }
                    let (character, count) = match arguments[0].impl {
                        CChar(arg) => match arguments[1].impl {
                            USize(c) => (arg, c)
                            else => {
                                .error("String::repeated must be called with a usize", arguments[1].span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        else => {
                            .error("String::repeated must be called with a c_char", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    yield StatementResult::JustValue(Value(impl: ValueImpl::JaktString(String::repeated(character, count)), span: call_span))
                }
                else => {
                    .error(
                        format("Prelude function `String::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "Set" => match prelude_function {
                "Set" => {
                    if type_bindings.size() != 1 {
                        .error("Set constructor expects one generic argument", call_span)
                        .compiler.panic("Invalid type")
                    }
                    let set_struct_id = .program.find_struct_in_prelude("Set")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [type_bindings.get(type_bindings.keys()[0])!]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktSet(values: [], type_id)
                        span: call_span
                    ))
                }
                "is_empty" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(values.is_empty()), span: call_span))
                    else => {
                        panic("Invalid Set")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut found = false
                        for i in 0..values.size() {
                            if values[i].impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Bool(found), span: call_span))
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "add" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut mutable_values = values
                        mutable_values.push(arguments[0])
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void,
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "remove" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut found = false
                        mut values_without: [Value] = []
                        for i in 0..values.size() {
                            if values[i].impl.equals(arguments[0].impl) {
                                found = true
                                continue
                            }
                            values_without.push(values[i])
                        }
                        mut mutable_values = values
                        mutable_values.shrink(0)
                        for i in 0..values_without.size() {
                            mutable_values.push(values_without[i])
                        }
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Bool(found),
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "clear" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut mutable_values = values
                        mutable_values.shrink(0)
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(values.size())
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid Set")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(values.capacity())
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid Set")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktSet(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Set::ensure_capacity must be called with a usize", arguments[0].span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "iterator" => match this_argument!.impl {
                    JaktSet => {
                        let struct_id = .program.find_struct_in_prelude("SetIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Set::iterator()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Set::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "SetIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid SetIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktSet(values) => match values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    yield Value(impl: ValueImpl::OptionalSome(value: values[index]), span: call_span)
                                }
                                else => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid SetIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid SetIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `ArrayIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "DictionaryIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid DictionaryIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktDictionary(keys, values, type_id) => match keys.size() > index and values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    let generics = match .program.get_type(type_id) {
                                        GenericInstance(args) => args
                                        else => {
                                            panic("expected generic instance")
                                        }
                                    }
                                    let tuple_struct_id = .program.find_struct_in_prelude("Tuple")
                                    let tuple_type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: generics))

                                    yield Value(
                                        impl: ValueImpl::OptionalSome(
                                            value: Value(
                                                impl: ValueImpl::JaktTuple(
                                                    fields: [keys[index], values[index]]
                                                    type_id: tuple_type_id
                                                )
                                                span: call_span
                                            )
                                        )
                                        span: call_span
                                    )
                                }
                                false => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid DictionaryIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid DictionaryIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `DictionaryIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            "Optional" => match prelude_function {
                "has_value" => match this_argument!.impl {
                    OptionalSome => StatementResult::JustValue(Value(impl: ValueImpl::Bool(true), span: call_span))
                    OptionalNone => StatementResult::JustValue(Value(impl: ValueImpl::Bool(false), span: call_span))
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                "value" => match this_argument!.impl {
                    OptionalSome(value) => StatementResult::JustValue(value)
                    OptionalNone => {
                        .error(
                            format("Cannot unwrap optional none", prelude_function),
                            call_span
                        )
                        yield StatementResult::Throw(.error_value("Attempt to unwrap None", call_span))
                    }
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                "map" => match this_argument!.impl {
                    OptionalSome(value) => {
                        let mapper_value = arguments[0]
                        guard mapper_value.impl is Function(block, params, return_type_id, checked_params) else {
                            panic("Invalid mapper type in Optional::map")
                        }
                        mut scope = InterpreterScope::create(
                            compiler: .compiler
                            runtime_scope_id
                        )
                        mut first = true
                        for declared_param in checked_params {
                            let name = declared_param.variable.name
                            let (param_type_id, _) = params[name]
                            if first {
                                first = false
                                scope.bindings.set(
                                    name
                                    value: cast_value_to_type(value, param_type_id, interpreter: this)
                                )
                            } else {
                                // FIXME: Should probably evaluate the default arguments somehow
                                break
                            }
                        }

                        let result = .execute_block(block, scope, call_span)
                        guard result is JustValue(blk) else {
                            return result
                        }

                        yield StatementResult::JustValue(blk)
                    }
                    OptionalNone => StatementResult::JustValue(this_argument!)
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                "value_or" => match this_argument!.impl {
                    OptionalSome(value) => StatementResult::JustValue(value)
                    OptionalNone => StatementResult::JustValue(arguments[0])
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Optional::{}` is not implemented", prelude_function),
                        call_span
                    )
                    .compiler.panic("Not yet implemented")
                }
            }
            else => {
                .error(
                    format("Prelude function `{}::{}` is not implemented", namespace_[0].name, prelude_function),
                    call_span
                )
                .compiler.panic("Not yet implemented")
            }
        }
    }

    fn call_compiler_interface_function(
        mut this
        anon function: CheckedFunction
        arguments: [Value]
        call_span: Span
        scope_id: ScopeId?
    ) throws -> StatementResult {
        if function.params.size() != arguments.size() {
            .error(
                format("Compiler interface function '{}' called with wrong number of arguments, expected {} but got {}", function.name, function.params.size(), arguments.size()),
                call_span
            )
            .compiler.panic("Mismatching arguments")
        }

        return match function.name {
            "target_triple_string" => StatementResult::JustValue(Value(
                impl: ValueImpl::JaktString(.compiler.target_triple ?? Target::active().name())
                span: call_span
            ))
            "user_configuration_value" => {
                mut impl = ValueImpl::OptionalNone
                let value = .compiler.user_configuration.get(.string_from_value(arguments[0]))
                if value.has_value() {
                    impl = ValueImpl::OptionalSome(value: .string_value(value!, span: call_span))
                }

                yield StatementResult::JustValue(Value(impl, span: call_span))
            }
            "debug_this_scope" => {
                // Just dump out the current scope, if we have one.
                if scope_id is None {
                    eprintln("No scoping information available")
                }

                mut scope_count = 0i32
                mut current_scope_id = scope_id
                while current_scope_id.has_value() {
                    scope_count += 1
                    let scope = .program.get_scope(current_scope_id!)
                    eprintln("====== Scope {} ({}) ======", scope.debug_name, current_scope_id!)
                    eprintln("{:#}", scope)
                    eprintln("====== Scope {} ======", scope.debug_name)
                    eprintln("")

                    current_scope_id = scope.parent
                }

                if arguments[0].impl is Bool(value) and value {
                    // breakpoint, fail the compilation.
                    return StatementResult::Throw(.error_value("Debugging breakpoint", call_span))
                }

                yield StatementResult::JustValue(Value(impl: ValueImpl::I32(scope_count), span: call_span))
            }
            else => {
                eprintln("Compiler interface function '{}' is not implemented", function.name)
                .compiler.panic("Not yet implemented")
            }
        }
    }

    public fn execute(
        mut this
        anon function_to_run_id: FunctionId
        mut namespace_: [ResolvedNamespace]?
        this_argument: Value?
        arguments: [Value]
        call_span: Span
        invocation_scope: InterpreterScope? = None
        is_main: bool = false
    ) throws -> ExecutionResult {
        let function_to_run = .program.get_function(function_to_run_id)
        .enter_span(call_span)
        let old_function_id = .current_function_id
        .current_function_id = function_to_run_id

        defer {
            .current_function_id = old_function_id
            .leave_span()
        }

        mut is_prelude_function = false
        let runtime_scope_id = match invocation_scope.has_value() {
            true => match invocation_scope!.runtime_scope_id.has_value() {
                true => invocation_scope!.runtime_scope_id
                false => None
            }
            false => None
        }

        if function_to_run.linkage is External {
            // If this is a compiler interface function, or a prelude function, we can run it directly
            let function_scope = .program.get_scope(function_to_run.function_scope_id)
            // HACK: We shouldn't do this...
            let parent_scope_name = match function_scope.parent.has_value() {
                true => .program.get_scope(function_scope.parent!).debug_name
                false => ""
            }
            if parent_scope_name == "module(jakt__compiler)" {
                return match .call_compiler_interface_function(
                    function_to_run,
                    arguments,
                    call_span,
                    scope_id: runtime_scope_id
                ) {
                    JustValue(value) | Return(value) => ExecutionResult::Return(value)
                    Throw(value) => ExecutionResult::Throw(value)
                    Continue | Break | Yield => {
                        panic("Invalid control flow")
                    }
                }
            }

            if not .get_prelude_function(function_to_run.function_scope_id) {
                .error(
                    format("Cannot call external function '{}'", function_to_run.name)
                    call_span
                )
                return ExecutionResult::Throw(.error_value("Attempt to call external function", call_span))
            }

            is_prelude_function = true
        }

        if function_to_run.is_static() == this_argument.has_value() {
            mut expected = "did not expect"
            if not function_to_run.is_static() {
                expected = "expected"
            }

            mut not_provided = " not"
            if this_argument.has_value() {
                not_provided = ""
            }

            .compiler.errors.push(JaktError::Message(
                message: format("function call {} a this argument, yet one was{} provided", expected, not_provided),
                span: function_to_run.name_span
            ));
            .compiler.panic("Invalid this argument")
        }

        mut this_offset = 0uz
        if this_argument.has_value() {
            this_offset = 1
        }

        if function_to_run.params.size() - this_offset != arguments.size() {
            .error(
                message: format("Function called with wrong number of arguments, expected {} but got {}", function_to_run.params.size(), arguments.size()),
                span: call_span
            )
            .compiler.panic("Mismatching arguments")
        }

        if is_prelude_function {
            if this_argument.has_value() and (not namespace_.has_value() or namespace_!.is_empty()) {
                mut effective_namespace: [ResolvedNamespace] = []
                match this_argument!.impl {
                    JaktString => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(ResolvedNamespace(name: "String", generic_parameters))
                    }
                    JaktArray(type_id) => {
                        let generic_parameters = match .program.get_type(id: type_id) {
                            GenericInstance(args) => args
                            else => {
                                .error("Attempted to call a prelude function  on a non-generic array", call_span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Array", generic_parameters))
                    }
                    JaktDictionary(type_id) => {
                        let generic_parameters = match .program.get_type(id: type_id) {
                            GenericInstance(args) => args
                            else => {
                                .error("Attempted to call a prelude function  on a non-generic dictionary", call_span)
                                .compiler.panic("Invalid type")
                            }
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Dictionary", generic_parameters))
                    }
                    JaktSet(type_id) => {
                        guard .program.get_type(id: type_id) is GenericInstance(args: generic_parameters) else {
                            .error("Attempted to call a prelude function  on a non-generic set", call_span)
                            .compiler.panic("Invalid type")
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Set", generic_parameters))
                    }
                    Struct(struct_id) | Class(struct_id) => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(
                            ResolvedNamespace(name: .program.get_struct(struct_id).name, generic_parameters))
                    }
                    Enum(enum_id) => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(
                            ResolvedNamespace(name: .program.get_enum(enum_id).name, generic_parameters))
                    }
                    OptionalNone | OptionalSome => {
                        // FIXME: We should have these at this point.
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(ResolvedNamespace(name: "Optional", generic_parameters))
                    }
                    else => {
                        .error("Attempted to call an instance method on a non-struct/enum type", call_span)
                        .compiler.panic("Invalid type")
                    }
                }

                namespace_ = effective_namespace
            }

            mut type_bindings: [TypeId:TypeId] = [:]
            if invocation_scope.has_value() {
                type_bindings = invocation_scope!.type_bindings
            }
            return match .call_prelude_function(
                function_to_run.name,
                namespace_!,
                this_argument,
                arguments,
                call_span,
                type_bindings
                runtime_scope_id
            ) {
                JustValue(value) | Return(value) => ExecutionResult::Return(value)
                Throw(value) => ExecutionResult::Throw(value)
                Continue | Break | Yield => {
                    panic("Invalid control flow")
                }
            }
        }

        match function_to_run.type {
            Normal => {
                mut scope = InterpreterScope::create(parent: invocation_scope, compiler: .compiler, runtime_scope_id)
                defer {
                    scope.perform_defers(interpreter: this, span: call_span)
                }

                for i in 0..function_to_run.params.size() {
                    if this_offset != 0 and i == 0 {
                        continue
                    }
                    let param_name = function_to_run.params[i].variable.name
                    let param_value = arguments[i - this_offset]
                    scope.bindings[param_name] = param_value
                }

                if this_argument.has_value() {
                    scope.bindings.set("this", this_argument!)
                }

                let blk = .execute_block(block: function_to_run.block, scope, call_span)
                return match blk {
                    Return(value) | JustValue(value) => ExecutionResult::Return(cast_value_to_type(value, function_to_run.return_type_id, interpreter: this))
                    Throw(value) => ExecutionResult::Throw(value)
                    Continue | Break | Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            Closure | Expression => {
                mut scope = InterpreterScope::create(parent: invocation_scope, compiler: .compiler, runtime_scope_id)
                defer {
                    scope.perform_defers(interpreter: this, span: call_span)
                }

                for i in 0..function_to_run.params.size() {
                    if this_offset != 0 and i == 0 {
                        continue
                    }
                    let param_name = function_to_run.params[i].variable.name
                    let param_value = arguments[i - this_offset]
                    scope.bindings[param_name] = param_value
                }

                if this_argument.has_value() {
                    scope.bindings.set("this", this_argument!)
                }

                return match .execute_block(block: function_to_run.block, scope, call_span) {
                    Return(value) | JustValue(value) => ExecutionResult::Return(cast_value_to_type(value, function_to_run.return_type_id, interpreter: this))
                    Throw(value) => ExecutionResult::Throw(value)
                    Continue | Break | Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            ImplicitConstructor => {
                let result_type = .program.get_type(function_to_run.return_type_id)
                match result_type {
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        let struct_ = .program.get_struct(struct_id)
                        let constructor = function_to_run_id
                        let impl = match struct_.record_type {
                            Struct => ValueImpl::Struct(
                                fields: arguments
                                struct_id
                                constructor
                            )
                            Class => ValueImpl::Class(
                                fields: arguments
                                struct_id
                                constructor
                            )
                            else => {
                                .error(
                                    format("Cannot create instance of non-struct type {}", struct_.name),
                                    call_span
                                )
                                .compiler.panic("Invalid type")
                            }
                        }
                        return ExecutionResult::Return(Value(
                            impl
                            span: call_span
                        ))
                    }
                    else => {
                        .error(
                            format("Implicit constructor can only return a struct or a generic instance"),
                            call_span
                        )
                        .compiler.panic("Invalid type")
                    }
                }
            }
            ImplicitEnumConstructor => {
                let result_type = .program.get_type(function_to_run.return_type_id)
                match result_type {
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        let enum_ = .program.get_enum(enum_id)
                        let constructor = function_to_run_id
                        let impl = ValueImpl::Enum(
                            fields: arguments
                            enum_id
                            constructor
                        )
                        return ExecutionResult::Return(Value(
                            impl
                            span: call_span
                        ))
                    }
                    else => {
                        .error(
                            format("Implicit enum constructor can only return an enum or a generic instance of one"),
                            call_span
                        )
                        .compiler.panic("Invalid type")
                    }
                }
            }
            else => {}
        }

        .error(
            format("Function type {} is not implemented", function_to_run.type),
            call_span
        )
        .compiler.panic("Not yet implemented")
    }

    public fn execute_statement(mut this, statement: CheckedStatement, mut scope: InterpreterScope, call_span: Span) throws -> StatementResult {
        match statement {
            Expression(expr) => {
                return .execute_expression(expr, scope)
            }
            Defer(statement) => {
                scope.defer_statement(statement)
            }
            DestructuringDeclaration(vars, var_decl) => {
                guard var_decl is VarDecl(var_id, init) else {
                    panic("expected vardecl")
                }
                match .execute_expression(init, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(var_value) => {
                        scope.bindings[.program.get_variable(id: var_id).name] = var_value
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }

                for var in vars {
                    guard var is VarDecl(var_id, init) else {
                        panic("expected vardecl")
                    }
                    match .execute_expression(init, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(var_value) => {
                            scope.bindings[.program.get_variable(id: var_id).name] = var_value
                        }
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            VarDecl(var_id, init, span) => {
                match .execute_expression(init, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(var_value) => {
                        scope.bindings[.program.get_variable(id: var_id).name] = var_value
                        if var_value.impl is Function(block, pseudo_function_id) and pseudo_function_id is Some(id) {
                            .program.get_function(id).block = block
                        }
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            If(condition, then_block, else_statement, span) => {
                let cond = match .execute_expression(expr: condition, scope) {
                    JustValue(value) => match value.impl {
                        Bool(x) => x
                        else => {
                            .error(
                                format("if condition must be a boolean, but got {}", value.impl),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }

                let block = match cond {
                    true => Some(then_block)
                    false => match else_statement.has_value() {
                        true => Some(CheckedBlock(
                            statements: [else_statement!]
                            scope_id: then_block.scope_id
                            control_flow: BlockControlFlow::MayReturn
                        ))
                        false => None
                    }
                }

                if block.has_value() {
                    return match .execute_block(block: block!, scope, call_span: span) {
                        Return(value) => StatementResult::Return(value)
                        Throw(value) => StatementResult::Throw(value)
                        JustValue => StatementResult::JustValue(Value(impl: ValueImpl::Void, span))
                        Continue => StatementResult::Continue
                        Break => StatementResult::Break
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            Block(block, span) => {
                mut new_scope = InterpreterScope::create(parent: scope, compiler: .compiler, runtime_scope_id: scope.runtime_scope_id)
                defer new_scope.perform_defers(interpreter: this, span)

                return .execute_block(block, scope: new_scope, call_span: span)
            }
            Loop(block, span) => {
                loop {
                    match .execute_block(block, scope, call_span: span) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            continue
                        }
                        Break => {
                            break
                        }
                        JustValue => {}
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            While(condition, block, span) => {
                loop {
                    match .execute_expression(condition, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        JustValue(x) => {
                            if x.impl is Bool(cond) and not cond {
                                break
                            }
                        }
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                    match .execute_block(block, scope, call_span: span) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            continue
                        }
                        Break => {
                            break
                        }
                        JustValue => {}
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            Return(val) => {
                if val.has_value() {
                    return match .execute_expression(val!, scope) {
                        Return(value) => StatementResult::Return(value)
                        Throw(value) => StatementResult::Throw(value)
                        JustValue(value) => StatementResult::Return(value)
                        Continue => StatementResult::Continue
                        Break => StatementResult::Break
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
                return StatementResult::Return(Value(impl: ValueImpl::Void, span: call_span))
            }
            Break => {
                return StatementResult::Break
            }
            Continue => {
                return StatementResult::Continue
            }
            Yield(expr) => {
                if not expr.has_value() {
                    return StatementResult::Yield(Value(impl: ValueImpl::Void, span: call_span))
                }

                return match .execute_expression(expr!, scope) {
                    JustValue(value) => {
                        return StatementResult::Yield(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            Throw(expr) => match .execute_expression(expr, scope) {
                Return(value) | JustValue(value) | Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            InlineCpp(span) => .error("Cannot run inline cpp at compile time", span)
            Garbage(span) => .error("Cannot run invalid statements at compile time", span)
        }

        return StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
    }

    public fn execute_block(mut this, block: CheckedBlock, mut scope: InterpreterScope, call_span: Span) throws -> StatementResult {
        for statement in block.statements {
            .enter_span(statement.span() ?? call_span)
            defer .leave_span()
            match .execute_statement(statement, scope, call_span) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                JustValue => {}
                Yield(value) => {
                    return StatementResult::Yield(value)
                }
            }
        }

        return StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
    }

    public fn error(mut this, anon message: String, anon span: Span) throws -> void {
        .compiler.errors.push(JaktError::Message(
            message: message,
            span: span
        ))

        // FIXME: This shouldn't be necessary
        .compiler.print_errors()
    }

    public fn error_with_hint(mut this, anon message: String, anon span: Span, anon hint_message: String, anon hint_span: Span) throws -> void {
        .compiler.errors.push(JaktError::MessageWithHint(
            message,
            span,
            hint: hint_message,
            hint_span,
        ))

        // FIXME: This shouldn't be necessary
        .compiler.print_errors()
    }

    public fn execute_binary_operator(mut this, anon lhs_value: Value, anon rhs_value: Value, anon op: BinaryOperator, anon span: Span, anon scope: InterpreterScope) throws -> StatementResult => match op {
        Add => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::JaktString(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        Subtract => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        Multiply => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        Divide => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        Equal => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    CInt(x) => match rhs_value.impl {
                        CInt(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    CChar(x) => match rhs_value.impl {
                        CChar(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        NotEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    CInt(x) => match rhs_value.impl {
                        CInt(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    CChar(x) => match rhs_value.impl {
                        CChar(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        LessThan => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        LessThanOrEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        GreaterThan => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        GreaterThanOrEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        BitwiseAnd => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x & y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x & y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x & y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x & y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        BitwiseOr => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x | y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x | y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x | y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x | y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        BitwiseXor => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x ^ y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x ^ y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x ^ y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x ^ y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        BitwiseLeftShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x << y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x << y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x << y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x << y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        BitwiseRightShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x >> y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x >> y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x >> y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x >> y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        ArithmeticLeftShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x <<< y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x <<< y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x <<< y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x <<< y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        ArithmeticRightShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        LogicalOr => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    Bool(x) => match rhs_value.impl {
                        Bool(y) => ValueImpl::Bool(x or y),
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        LogicalAnd => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    Bool(x) => match rhs_value.impl {
                        Bool(y) => ValueImpl::Bool(x and y),
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                }
                span
            )
        )
        Assign => StatementResult::JustValue(rhs_value)
        BitwiseAndAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseAnd, span, scope)
        BitwiseOrAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseOr, span, scope)
        BitwiseXorAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseXor, span, scope)
        BitwiseLeftShiftAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseLeftShift, span, scope)
        BitwiseRightShiftAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseRightShift, span, scope)
        AddAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Add, span, scope)
        SubtractAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Subtract, span, scope)
        MultiplyAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Multiply, span, scope)
        ModuloAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Modulo, span, scope)
        DivideAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Divide, span, scope)
        else => {
            .error(
                format("Unimplemented binary operator '{}'", op),
                span
            )
            .compiler.panic("Not yet implemented")
        }
    }

    public fn update_binding(
        mut this
        anon binding: CheckedExpression
        mut scope: InterpreterScope
        anon value: Value
        span: Span
    ) throws {
        match binding {
            Var(var) => {
                scope.set(var.name, value)
                if value.impl is Function(block, pseudo_function_id) and pseudo_function_id is Some(id) {
                    .program.get_function(id).block = block
                }
            }
            IndexedStruct(expr, name) => {
                // FIXME: This should not be evaluated twice.
                mut (fields, struct_id) = match .execute_expression(expr, scope) {
                    JustValue(value) => match value.impl {
                        Class(fields, struct_id) | Struct(fields, struct_id) => (fields, struct_id)
                        else => {
                            panic("Invalid left-hand side in assignment")
                        }
                    }
                    else => {
                        panic("Should not be happening here")
                    }
                }

                let field_decls = .program.get_struct(struct_id).fields
                mut field_index = 0uz
                for i in 0..field_decls.size() {
                    if .program.get_variable(field_decls[i].variable_id).name == name {
                        field_index = i
                        break
                    }
                }

                fields[field_index] = value
            }
            IndexedCommonEnumMember(expr, index) => {
                // FIXME: This should not be evaluated twice.
                mut (fields, enum_id) = match .execute_expression(expr, scope) {
                    JustValue(value) => match value.impl {
                        Enum(fields, enum_id) => (fields, enum_id)
                        else => {
                            panic("Invalid left-hand side in assignment")
                        }
                    }
                    else => {
                        panic("Should not be happening here")
                    }
                }

                let field_decls = .program.get_enum(enum_id).fields
                mut field_index = 0uz
                for i in 0..field_decls.size() {
                    if .program.get_variable(field_decls[i].variable_id).name == index {
                        field_index = i
                        break
                    }
                }

                fields[field_index] = value
            }
            else => {
                .error(
                    format("Invalid left-hand side of assignment {}", binding),
                    span
                )
                .compiler.panic("Invalid type")
            }
        }
    }

    public fn execute_expression(mut this, anon expr: CheckedExpression, anon mut scope: InterpreterScope) throws -> StatementResult => match .current_function_id.has_value() {
        false => .execute_expression_without_cast(expr, scope)
        else => match .execute_expression_without_cast(expr, scope) {
            Return(value) => StatementResult::Return(cast_value_to_type(value, .program.get_function(.current_function_id!).return_type_id, interpreter: this))
            JustValue(value) => StatementResult::JustValue(cast_value_to_type(value, expr.type(), interpreter: this))
            Throw(value) => StatementResult::Throw(value)
            Yield(value) => StatementResult::Yield(value)
            Break => StatementResult::Break
            Continue => StatementResult::Continue
        }
    }

    public fn execute_expression_without_cast(mut this, anon expr: CheckedExpression, anon mut scope: InterpreterScope) throws -> StatementResult => match expr {
        BinaryOp(lhs, op, rhs, span) => {
            let lhs_value = match .execute_expression(lhs, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            let value = match op.op {
                NoneCoalescing | NoneCoalescingAssign => StatementResult::JustValue(match lhs_value.impl {
                    OptionalNone => match .execute_expression(rhs, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }
                    OptionalSome(value) => value
                    else => {
                        panic("Invalid left-hand side of NoneCoalescing")
                    }
                })
                LogicalAnd | LogicalOr => StatementResult::JustValue(match lhs_value.impl {
                    Bool(x) => match x {
                        (op.op is LogicalAnd) => match .execute_expression(rhs, scope) {
                            Return(value) => {
                                return StatementResult::Return(value)
                            }
                            Throw(value) => {
                                return StatementResult::Throw(value)
                            }
                            JustValue(value) => value
                            Continue => {
                                return StatementResult::Continue
                            }
                            Break => {
                                return StatementResult::Break
                            }
                            Yield(expr) => {
                                panic("Invalid control flow")
                            }
                        }.cast(lhs_value, span)
                        else => lhs_value
                    }
                    else => {
                        .error(format("Invalid operand '{}' to binary operation", lhs_value.type_name()), span)
                        .compiler.panic("Invalid type")
                    }
                })
                else => {
                    let rhs_value = match .execute_expression(rhs, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }.cast(lhs_value, span)
                    yield .execute_binary_operator(lhs_value, rhs_value, op.op, span, scope)
                }
            }

            match value {
                JustValue(value) => match op.op {
                    Assign
                    | BitwiseAndAssign
                    | BitwiseOrAssign
                    | BitwiseXorAssign
                    | BitwiseLeftShiftAssign
                    | BitwiseRightShiftAssign
                    | AddAssign
                    | SubtractAssign
                    | MultiplyAssign
                    | ModuloAssign
                    | DivideAssign
                    | NoneCoalescingAssign => {
                        .update_binding(lhs, scope, value, span)
                    }
                    else => {}
                }
                else => {}
            }

            yield value
        }
        UnaryOp(expr, op, span) => match op {
            Sizeof(type_id) => StatementResult::JustValue(Value(
                impl: ValueImpl::USize(size_of_impl(type_id, this))
                span
            ))
            else => {
                let value = match .execute_expression(expr, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                yield match op {
                    LogicalNot => match value.impl {
                        Bool(value) => StatementResult::JustValue(Value(
                            impl: ValueImpl::Bool(not value)
                            span
                        ))
                        else => {
                            .error(
                                format("Invalid type for unary operator"),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    PostIncrement => StatementResult::JustValue(match value.impl {
                        U8(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U8(x + 1), span), span)
                            yield value
                        }
                        I8(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I8(x + 1), span), span)
                            yield value
                        }
                        U16(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U16(x + 1), span), span)
                            yield value
                        }
                        I16(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I16(x + 1), span), span)
                            yield value
                        }
                        U32(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U32(x + 1), span), span)
                            yield value
                        }
                        I32(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I32(x + 1), span), span)
                            yield value
                        }
                        U64(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U64(x + 1), span), span)
                            yield value
                        }
                        I64(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I64(x + 1), span), span)
                            yield value
                        }
                        CChar(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::CChar(x + 1), span), span)
                            yield value
                        }
                        CInt(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::CInt(x + 1), span), span)
                            yield value
                        }
                        USize(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::USize(x + 1), span), span)
                            yield value
                        }
                        else => {
                            .error(
                                format("Invalid type for unary operator"),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    })
                    PreIncrement => StatementResult::JustValue(match value.impl {
                        U8(x) => {
                            let value = Value(impl: ValueImpl::U8(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I8(x) => {
                            let value = Value(impl: ValueImpl::I8(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U16(x) => {
                            let value = Value(impl: ValueImpl::U16(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I16(x) => {
                            let value = Value(impl: ValueImpl::I16(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U32(x) => {
                            let value = Value(impl: ValueImpl::U32(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I32(x) => {
                            let value = Value(impl: ValueImpl::I32(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U64(x) => {
                            let value = Value(impl: ValueImpl::U64(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I64(x) => {
                            let value = Value(impl: ValueImpl::I64(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        CChar(x) => {
                            let value = Value(impl: ValueImpl::CChar(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        CInt(x) => {
                            let value = Value(impl: ValueImpl::CInt(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        USize(x) => {
                            let value = Value(impl: ValueImpl::USize(x + 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        else => {
                            .error(
                                format("Invalid type for unary operator"),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    })
                    PostDecrement => StatementResult::JustValue(match value.impl {
                        U8(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U8(x - 1), span), span)
                            yield value
                        }
                        I8(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I8(x - 1), span), span)
                            yield value
                        }
                        U16(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U16(x - 1), span), span)
                            yield value
                        }
                        I16(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I16(x - 1), span), span)
                            yield value
                        }
                        U32(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U32(x - 1), span), span)
                            yield value
                        }
                        I32(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I32(x - 1), span), span)
                            yield value
                        }
                        U64(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::U64(x - 1), span), span)
                            yield value
                        }
                        I64(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::I64(x - 1), span), span)
                            yield value
                        }
                        CChar(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::CChar(x - 1), span), span)
                            yield value
                        }
                        CInt(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::CInt(x - 1), span), span)
                            yield value
                        }
                        USize(x) => {
                            .update_binding(expr, scope, Value(impl: ValueImpl::USize(x - 1), span), span)
                            yield value
                        }
                        else => {
                            .error(
                                format("Invalid type for unary operator"),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    })
                    PreDecrement => StatementResult::JustValue(match value.impl {
                        U8(x) => {
                            let value = Value(impl: ValueImpl::U8(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I8(x) => {
                            let value = Value(impl: ValueImpl::I8(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U16(x) => {
                            let value = Value(impl: ValueImpl::U16(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I16(x) => {
                            let value = Value(impl: ValueImpl::I16(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U32(x) => {
                            let value = Value(impl: ValueImpl::U32(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I32(x) => {
                            let value = Value(impl: ValueImpl::I32(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        U64(x) => {
                            let value = Value(impl: ValueImpl::U64(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        I64(x) => {
                            let value = Value(impl: ValueImpl::I64(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        CChar(x) => {
                            let value = Value(impl: ValueImpl::CChar(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        CInt(x) => {
                            let value = Value(impl: ValueImpl::CInt(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        USize(x) => {
                            let value = Value(impl: ValueImpl::USize(x - 1), span)
                            .update_binding(expr, scope, value, span)
                            yield value
                        }
                        else => {
                            .error(
                                format("Invalid type for unary operator"),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    })
                    TypeCast(cast) => match cast {
                        Identity(type_id) | Infallible(type_id) => StatementResult::JustValue(cast_value_to_type(value, type_id, interpreter: this))
                        Fallible(type_id) => {
                            // FIXME: Actually implement this :)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::OptionalSome(value: cast_value_to_type(value, type_id, interpreter: this))
                                    span
                                )
                            )
                        }
                    }
                    IsEnumVariant(enum_variant, bindings) => match value.impl {
                        Enum(fields, constructor) => {
                            let constructor_name = .program.get_function(constructor).name
                            if enum_variant.name() != constructor_name {
                                return StatementResult::JustValue(
                                    Value(
                                        impl: ValueImpl::Bool(false)
                                        span
                                    )
                                )
                            }

                            // FIXME: Bindings
                            // match enum_variant {
                            //     Typed => {
                            //     }
                            //     Untyped
                            //     StructLike
                            //     WithValue => {
                            //         .error(
                            //             format("Unimplemented value enum for unary operator '{}'", op),
                            //             span
                            //         )
                            //         .compiler.panic("Not yet implemented")
                            //     }
                            // }

                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Bool(true)
                                    span
                                )
                            )
                        }
                        else => {
                            .error(
                                format("Invalid value for unary operator '{}'", op),
                                span
                            )
                            .compiler.panic("Invalid type")
                        }
                    }
                    else => {
                        .error(
                            format("Unimplemented unary operator '{}'", op),
                            span
                        )
                        .compiler.panic("Not yet implemented")
                    }
                }
            }
        }
        Range(from, to, span) => {
            let start = match from.has_value() {
                true => match .execute_expression(expr: from!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                false => {
                    .error("Partial ranges are not implemented", span)
                    .compiler.panic("Not yet implemented")
                }
            }
            let end = match to.has_value() {
                true => match .execute_expression(expr: to!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                false => {
                    .error("Partial ranges are not implemented", span)
                    .compiler.panic("Not yet implemented")
                }
            }

            let range_struct_id = .program.find_struct_in_prelude("Range")
            let range_constructors = .program.find_functions_with_name_in_scope(
                parent_scope_id: .program.get_struct(range_struct_id).scope_id,
                function_name: "Range")!

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Struct(
                    fields: [start, end]
                    struct_id: range_struct_id
                    constructor: range_constructors[0]
                )
                span
            ))
        }
        Call(call, span) => {
            if not call.function_id.has_value() {
                mut arguments: [Value] = []
                for arg in call.args {
                    arguments.push(match .execute_expression(arg.1, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    })
                }

                return .call_prelude_function(
                    prelude_function: call.name
                    namespace_: []
                    this_argument: None
                    arguments
                    call_span: span
                    type_bindings: [:]
                    runtime_scope_id: scope.runtime_scope_id
                )
            }

            let function_to_run = .program.get_function(id: call.function_id!)
            if function_to_run.type is Closure {
                .error(
                    format("Cannot call a closure (nyi)"),
                    span
                )
                .compiler.panic("Not yet implemented")
            }
            mut this_argument: Value? = None
            mut arguments: [Value] = []
            for arg in call.args {
                arguments.push(match .execute_expression(arg.1, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                })
            }

            mut type_bindings: [TypeId:TypeId] = [:]
            for i in 0..function_to_run.generics.params.size() {
                let param = function_to_run.generics.params[i]

                type_bindings.set(
                    param.type_id()
                    call.type_args[i]
                )
            }

            let empty_bindings: [String:Value] = [:]
            yield match .execute(
                call.function_id!
                namespace_: Some(call.namespace_)
                this_argument
                arguments
                call_span: span
                invocation_scope: InterpreterScope::create(type_bindings, compiler: .compiler, runtime_scope_id: scope.runtime_scope_id)
            ) {
                Return(value) => StatementResult::JustValue(value)
                Throw(value) => StatementResult::Throw(value)
            }
        }
        MethodCall(expr, call, span) => {
            let this_argument = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            mut effective_namespace: [ResolvedNamespace] = []
            match this_argument.impl {
                JaktString => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(ResolvedNamespace(name: "String", generic_parameters))
                }
                JaktArray(type_id) => {
                    let generic_parameters = match .program.get_type(id: type_id) {
                        GenericInstance(args) => args
                        else => {
                            .error("Attempted to call a prelude function  on a non-generic array", this_argument.span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Array", generic_parameters))
                }
                JaktDictionary(type_id) => {
                    let generic_parameters = match .program.get_type(id: type_id) {
                        GenericInstance(args) => args
                        else => {
                            .error("Attempted to call a prelude function  on a non-generic dictionary", this_argument.span)
                            .compiler.panic("Invalid type")
                        }
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Dictionary", generic_parameters))
                }
                JaktSet(type_id) => {
                    guard .program.get_type(id: type_id) is GenericInstance(args: generic_parameters) else {
                        .error("Attempted to call a prelude function  on a non-generic set", this_argument.span)
                        .compiler.panic("Invalid type")
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Set", generic_parameters))
                }
                Struct(struct_id) | Class(struct_id) => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(
                        ResolvedNamespace(name: .program.get_struct(struct_id).name, generic_parameters))
                }
                Enum(enum_id) => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(
                        ResolvedNamespace(name: .program.get_enum(enum_id).name, generic_parameters))
                }
                OptionalNone | OptionalSome => {
                    // FIXME: We should have these at this point.
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(ResolvedNamespace(name: "Optional", generic_parameters))
                }
                else => {
                    .error("Attempted to call an instance method on a non-struct/enum type", this_argument.span)
                    .compiler.panic("Invalid type")
                }
            }

            if not call.function_id.has_value() {
                mut arguments: [Value] = []
                for arg in call.args {
                    arguments.push(match .execute_expression(arg.1, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    })
                }

                return .call_prelude_function(
                    prelude_function: call.name
                    namespace_: effective_namespace
                    this_argument
                    arguments
                    call_span: span
                    type_bindings: [:]
                    runtime_scope_id: scope.runtime_scope_id
                )
            }

            let function_to_run = .program.get_function(id: call.function_id!)
            mut arguments: [Value] = []
            for arg in call.args {
                arguments.push(match .execute_expression(arg.1, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                })
            }

            mut type_bindings: [TypeId:TypeId] = [:]
            for i in 0..function_to_run.generics.params.size() {
                let param = function_to_run.generics.params[i]

                type_bindings.set(
                    param.type_id()
                    call.type_args[i]
                )
            }
            yield match .execute(
                call.function_id!
                namespace_: Some(call.namespace_)
                this_argument
                arguments
                call_span: span
                invocation_scope: InterpreterScope::create(type_bindings, compiler: .compiler, runtime_scope_id: scope.runtime_scope_id)
            ) {
                Return(value) => StatementResult::JustValue(value)
                Throw(value) => StatementResult::Throw(value)
            }
        }
        OptionalNone(span) => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone(), span))
        OptionalSome(expr, span) => {
            let result = .execute_expression(expr, scope)
            if result is JustValue(value) {
                return StatementResult::JustValue(Value(impl: ValueImpl::OptionalSome(value), span))
            }
            return result
        }
        ForcedUnwrap(expr) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            if value.impl is OptionalNone {
                .error("Attempted to unwrap an optional value that was None", value.span)
                .compiler.panic("Invalid type")
            }

            yield match value.impl {
                OptionalSome(value) => StatementResult::JustValue(value)
                else => {
                    .error("Invalid type for unwrap", value.span)
                    .compiler.panic("Invalid type")
                }
            }
        }
        Block(block, span) => .execute_block(block, scope, call_span: span)
        ByteConstant(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::U8(val.byte_at(0)), span: span))
        // IndexedDictionary
        Var(var) => StatementResult::JustValue(scope.must_get(var.name))
        // Garbage
        IndexedExpression(expr, index: index_expr, span) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            let index = match .execute_expression(index_expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            yield match value.impl {
                JaktArray(values) => {
                    let numeric_index = match index.impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for repeat")
                        }
                    }

                    if numeric_index >= (values.size() as! u64) {
                        .error(
                            format("Index {} out of bounds (max={})", numeric_index, values.size())
                            span)
                        return StatementResult::Throw(.error_value("Invalid type", span))
                    }

                    yield StatementResult::JustValue(values[numeric_index])
                }
                else => {
                    .error("Invalid or unsupported indexed expression", span)
                    .compiler.panic("Invalid type")
                }
            }
        }
        Boolean(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(val), span: span))
        IndexedStruct(expr, name) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Struct(fields, struct_id)
                | Class(fields, struct_id) => {
                    let struct_ = .program.get_struct(struct_id)
                    mut idx = 0
                    mut found_index: i64? = None
                    for field in struct_.fields {
                        if .program.get_variable(field.variable_id).name == name {
                            found_index = idx
                            break
                        }
                        idx += 1
                    }
                    if not found_index.has_value() {
                        .error("Attempted to access a field that does not exist", value.span)
                        .compiler.panic("Invalid type")
                    }

                    yield StatementResult::JustValue(fields[found_index!])
                }
                else => {
                    .error("Attempted to access a field on a non-struct/enum type", value.span)
                    .compiler.panic("Invalid type")
                }
            }
        }
        IndexedCommonEnumMember(expr, index) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields, enum_id) => {
                    let enum_ = .program.get_enum(enum_id)
                    mut idx = 0
                    mut found_index: i64? = None
                    for field in enum_.fields {
                        if .program.get_variable(field.variable_id).name == index {
                            found_index = idx
                            break
                        }
                        idx += 1
                    }
                    if not found_index.has_value() {
                        .error("Attempted to access a field that does not exist", value.span)
                        .compiler.panic("Invalid type")
                    }

                    yield StatementResult::JustValue(fields[found_index!])
                }
                else => {
                    .error("Attempted to access a field on a non-struct/enum type", value.span)
                    .compiler.panic("Invalid type")
                }
            }
        }
        JaktDictionary(vals, span, type_id) => {
            mut keys: [Value] = []
            mut values: [Value] = []
            for (k, v) in vals {
                let key = match .execute_expression(k, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                let val = match .execute_expression(v, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }

                keys.push(key)
                values.push(val)
            }

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::JaktDictionary(
                    keys
                    values
                    type_id
                )
                span: span
            ))
        }
        // NamespacedVar
        NumericConstant(val, span) => StatementResult::JustValue(match val {
            I8(x) => Value(impl: ValueImpl::I8(x), span: span)
            I16(x) => Value(impl: ValueImpl::I16(x), span: span)
            I32(x) => Value(impl: ValueImpl::I32(x), span: span)
            I64(x) => Value(impl: ValueImpl::I64(x), span: span)
            U8(x) => Value(impl: ValueImpl::U8(x), span: span)
            U16(x) => Value(impl: ValueImpl::U16(x), span: span)
            U32(x) => Value(impl: ValueImpl::U32(x), span: span)
            U64(x) => Value(impl: ValueImpl::U64(x), span: span)
            USize(x) => Value(impl: ValueImpl::USize(x as! usize), span: span)
            F32(x) => Value(impl: ValueImpl::F32(x), span: span)
            F64(x) => Value(impl: ValueImpl::F64(x), span: span)
        })
        QuotedString(val, span) => match val.type_id.equals(builtin(BuiltinType::JaktString)) {
            true => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(interpret_escapes(val.to_string())), span: span))
            false => {
                let function_id = match .program.get_type(val.type_id) {
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        let scope = .program.get_scope(.program.get_struct(struct_id).scope_id)
                        let overloads = scope.functions.get("from_string_literal")
                        if not overloads.has_value() {
                            panic(format("Failed to find a from_string_literal overload in {}", .program.type_name(val.type_id)))
                        }
                        // For now, pick the first.
                        // FIXME: Pick the correct overload
                        yield overloads!.first()!
                    }
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        let scope = .program.get_scope(.program.get_enum(enum_id).scope_id)
                        let overloads = scope.functions.get("from_string_literal")
                        if not overloads.has_value() {
                            panic("Failed to find a from_string_literal overload")
                        }
                        // For now, pick the first.
                        // FIXME: Pick the correct overload
                        yield overloads!.first()!
                    }
                    else => {
                        .error(format("Invalid type {} for string literal", .program.get_type(val.type_id)), span)
                        .compiler.panic("Invalid type")
                    }
                }

                let ns: [ResolvedNamespace] = []
                yield match .execute(
                    function_to_run_id: function_id
                    namespace_: Some(ns)
                    this_argument: None
                    arguments: [Value(
                        impl: ValueImpl::JaktString(interpret_escapes(val.to_string()))
                        span: span
                    )]
                    call_span: span
                    invocation_scope: scope
                ) {
                    Return(value) => StatementResult::JustValue(value)
                    Throw(value) => StatementResult::Throw(value)
                }
            }
        }
        CCharacterConstant(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::CChar(val.byte_at(0) as! c_char), span: span))
        CharacterConstant(val, span) => {
            mut code_points = val.code_points()
            let code_point = code_points.next()
            if not code_point.has_value() {
                .error("Invalid character constant", span)
                .compiler.panic("Invalid character constant")
            }

            yield StatementResult::JustValue(Value(impl: ValueImpl::U32(code_point!), span: span))
        }
        JaktArray(vals, repeat, span, type_id) => match repeat.has_value() {
            true => {
                let count = match .execute_expression(repeat!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => match value.impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! usize
                        else => {
                            panic("Invalid type for repeat")
                        }
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                let value_to_repeat = match .execute_expression(vals[0], scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                yield StatementResult::JustValue(Value(
                    impl: ValueImpl::JaktArray(
                        values: [value_to_repeat; count]
                        type_id: .program.substitute_typevars_in_type(
                            type_id
                            generic_inferences: scope.type_map_for_substitution()
                            module_id: type_id.module)
                    )
                    span: span
                ))
            }
            else => {
                mut values: [Value] = []
                for value in vals {
                    let val = match .execute_expression(value, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }
                    values.push(val)
                }
                yield StatementResult::JustValue(Value(
                    impl: ValueImpl::JaktArray(
                        values
                        type_id: .program.substitute_typevars_in_type(
                            type_id
                            generic_inferences: scope.type_map_for_substitution()
                            module_id: type_id.module)
                    )
                    span: span
                ))
            }
        }
        IndexedTuple(expr, index) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            guard value.impl is JaktTuple(fields) else {
                panic("expected tuple")
            }

            yield StatementResult::JustValue(fields[index])
        }
        Match(expr, match_cases, all_variants_constant, span) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields,  enum_id, constructor) => {
                    let constructor_name = .program.get_function(constructor).name

                    mut catch_all_case: CheckedMatchBody? = None
                    mut found_body: CheckedMatchBody? = None
                    mut found_args: [EnumVariantPatternArgument]? = None
                    mut found_variant_index: usize? = None
                    mut span: Span? = None

                    for match_case in match_cases {
                        let body = match_case.body
                        for pattern in match_case.patterns {
                            match pattern {
                                EnumVariant(name, args, index, marker_span) => {
                                    if name != constructor_name {
                                        continue
                                    }

                                    // A match!
                                    found_body = body
                                    found_args = args
                                    found_variant_index = index
                                    span = marker_span
                                    break
                                }
                                ClassInstance(marker_span) | Expression(marker_span) => {
                                    .error("Value matches are not allowed on enums", marker_span)
                                    .compiler.panic("Invalid type")
                                }
                                CatchAll(marker_span) => {
                                    catch_all_case = body
                                    span = marker_span
                                    continue
                                }
                            }
                        }
                    }

                    if not catch_all_case.has_value() and not found_body.has_value() {
                        .error("Match is not exhaustive", span!)
                        .compiler.panic("Invalid type")
                    }

                    found_body = found_body ?? catch_all_case!
                    let empty_args: [EnumVariantPatternArgument] = []
                    found_args = found_args ?? empty_args

                    mut new_scope = InterpreterScope::create(parent: scope, compiler: .compiler, runtime_scope_id: scope.runtime_scope_id)
                    defer new_scope.perform_defers(interpreter: this, span: span!)

                    if found_variant_index.has_value() and not found_args!.is_empty() {
                        let variant = .program.get_enum(enum_id).variants[found_variant_index!]
                        match variant {
                            Untyped => {}
                            WithValue => {}
                            Typed => {
                                if found_args!.size() > 0 {
                                    new_scope.bindings.set(
                                        found_args![0].binding
                                        fields[0]
                                    )
                                }
                            }
                            StructLike(fields: variant_fields) => {
                                mut i = 0
                                for var_id in variant_fields {
                                    let field = .program.get_variable(var_id)
                                    for arg in found_args! {
                                        let matched_name = arg.name ?? arg.binding
                                        if matched_name == field.name {
                                            new_scope.bindings.set(
                                                arg.binding
                                                fields[i]
                                            )
                                            break
                                        }
                                    }
                                    i += 1
                                }
                            }
                        }
                    }

                    yield match found_body! {
                        Expression(expr) => {
                            let result = .execute_expression(expr, scope: new_scope)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                        Block(block) => {
                            let result = .execute_block(block, scope: new_scope, call_span: span!)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                    }
                }
                else => {
                    mut catch_all_case: CheckedMatchBody? = None
                    mut found_body: CheckedMatchBody? = None
                    mut span: Span? = None

                    for match_case in match_cases {
                        let body = match_case.body
                        for pattern in match_case.patterns {
                            match pattern {
                                Expression(expression, marker_span) => {
                                    let value_to_match_against = match .execute_expression(expression, scope) {
                                        Return(value) => {
                                            return StatementResult::Return(value)
                                        }
                                        Throw(value) => {
                                            return StatementResult::Throw(value)
                                        }
                                        JustValue(value) => value
                                        Continue => {
                                            return StatementResult::Continue
                                        }
                                        Break => {
                                            return StatementResult::Break
                                        }
                                        Yield => {
                                            panic("Invalid control flow")
                                        }
                                    }

                                    if value_to_match_against.impl.equals(value.impl) {
                                        found_body = Some(body)
                                        span = Some(marker_span)
                                        break
                                    }
                                }
                                CatchAll(marker_span) => {
                                    catch_all_case = body
                                    span = marker_span
                                    continue
                                }
                                ClassInstance(marker_span) => {
                                    // FIXME: Implement this
                                    .error("Class instance matches are not implemented yet", marker_span)
                                    .compiler.panic("Invalid type")
                                }
                                EnumVariant(marker_span) => {
                                    .error(
                                        format("Value matches cannot have enum variant arms (matching on {})", value.type_name()),
                                        marker_span)
                                    .compiler.panic("Invalid type")
                                }
                            }
                        }
                    }

                    if found_body is None and catch_all_case is None {
                        .error(
                            format("No match found for value of type {}", value.type_name()),
                            .spans.last()!)
                        .compiler.panic("Invalid type")
                    }
                    found_body = found_body ?? catch_all_case!
                    mut new_scope = InterpreterScope::create(parent: scope, compiler: .compiler, runtime_scope_id: scope.runtime_scope_id)
                    defer new_scope.perform_defers(interpreter: this, span: span!)

                    yield match found_body! {
                        Expression(expr) => {
                            let result = .execute_expression(expr, scope: new_scope)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                        Block(block) => {
                            let result = .execute_block(block, scope: new_scope, call_span: span!)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                    }
                }
            }
        }
        EnumVariantArg(expr, arg, enum_variant, span) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields,  enum_id, constructor) => {
                    mut found_variant: CheckedEnumVariant? = None
                    for variant in .program.get_enum(enum_id).variants {
                        if variant.name() == enum_variant.name() {
                            found_variant = variant
                            break
                        }
                    }

                    yield match found_variant! {
                        Typed => StatementResult::JustValue(fields[0])
                        StructLike(fields: variant_fields) => {
                            mut i = 0
                            for var_id in variant_fields {
                                let field = .program.get_variable(var_id)
                                let matched_name = arg.name ?? arg.binding
                                if matched_name == field.name {
                                    break
                                }
                                i += 1
                            }
                            yield StatementResult::JustValue(fields[i])
                        }
                        else => StatementResult::JustValue(Value(impl: ValueImpl::Void, span))
                    }
                }
                else => {
                    .error(
                        format("Value matches cannot have enum variant arms (matching on {})", value.type_name()),
                        span)
                    .compiler.panic("Invalid type")
                }
            }
        }
        JaktTuple(vals, span, type_id) => {
            mut fields: [Value] = []
            for val in vals {
                let value = match .execute_expression(val, scope) {
                    JustValue(value) => value
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        .compiler.panic("Invalid control flow")
                    }
                }
                fields.push(value)
            }
            yield StatementResult::JustValue(Value(impl: ValueImpl::JaktTuple(fields, type_id), span))
        }
        JaktSet(vals, span, type_id) => {
            mut values: [Value] = []
            for v in vals {
                let val = match .execute_expression(v, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }

                values.push(val)
            }

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::JaktSet(
                    values
                    type_id
                )
                span: span
            ))
        }
        DependentFunction(captures, params, return_type_id, type_id, block, span, can_throw, scope_id, pseudo_function_id)
        | Function(captures, params, return_type_id, type_id, block, span, can_throw, scope_id, pseudo_function_id) => {
            // First, resolve the captures
            mut resolved_captures: [String:Value] = [:]
            for capture in captures {
                let name = capture.name
                guard capture is ByValue or capture is ByComptimeDependency else {
                    .error(
                        format("Cannot capture by reference in a comptime function (nyi)"),
                        span)
                    .compiler.panic("Not yet implemented")
                }

                resolved_captures.set(name, scope.must_get(name))
            }

            // Next, resolve the parameters
            let type_map = scope.type_map_for_substitution()
            mut resolved_params: [String:(TypeId, (ParsedExpression, ScopeId)?)] = [:]
            mut checked_params: [CheckedParameter] = []
            for param in params {
                let param_type_id = .program.substitute_typevars_in_type(
                    type_id: param.variable.type_id
                    generic_inferences: type_map
                    module_id: param.variable.type_id.module)

                resolved_params.set(
                    param.variable.name
                    (
                        param_type_id,
                        param.default_value_expression
                    )
                )

                checked_params.push(CheckedParameter(
                    requires_label: param.requires_label
                    variable: CheckedVariable(
                        name: param.variable.name
                        type_id: param_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.definition_span
                        type_span: param.variable.type_span
                        visibility: param.variable.visibility
                    )
                    default_value_expression: param.default_value_expression
                ))
            }

            let fixed_block = .perform_final_interpretation_pass(
                block
                runtime_scope: scope_id
                scope: InterpreterScope::create(bindings: resolved_captures, parent: scope, compiler: .compiler, runtime_scope_id: scope_id)
                function_id: pseudo_function_id
            )

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Function(
                    captures: resolved_captures,
                    params: resolved_params
                    return_type_id: .program.substitute_typevars_in_type(
                        type_id: return_type_id
                        generic_inferences: type_map
                        module_id: return_type_id.module)
                    type_id: .program.substitute_typevars_in_type(
                        type_id
                        generic_inferences: type_map
                        module_id: type_id.module)
                    block: fixed_block
                    can_throw
                    checked_params
                    scope_id
                    pseudo_function_id
                )
                span
            ))
        }
        TryBlock(stmt, catch_block, error_name, span) => {
            match .execute_statement(statement: stmt, scope, call_span: span) {
                JustValue => {}
                Throw(value) => {
                    mut catch_scope = InterpreterScope::create(
                        parent: scope
                        compiler: .compiler
                        runtime_scope_id: scope.runtime_scope_id
                    )
                    defer catch_scope.perform_defers(interpreter: this, span)

                    catch_scope.bindings.set(
                        error_name
                        value
                    )
                    let result = .execute_block(block: catch_block, scope: catch_scope, call_span: span)
                    match result {
                        Continue | Break | Return | Throw => {
                            return result
                        }
                        else => {}
                    }
                }
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Break => {
                    return StatementResult::Break
                }
                Continue => {
                    return StatementResult::Continue
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Void
                span
            ))
        }
        Reflect(type: type_id, span) => StatementResult::JustValue(.reflect_type(type_id, span, scope))
        else => {
            .error(format("expression not implemented: {}", expr), expr.span())
            .compiler.panic("Not yet implemented")
        }
    }

    public fn array_type_of_struct(mut this, anon struct_id: StructId) throws -> TypeId {
        let array_struct_id = .program.find_struct_in_prelude("Array")
        let type = Type::GenericInstance(
            id: array_struct_id
            args: [
                .program.get_struct(struct_id).type_id
            ]
        )
        return .find_or_add_type_id(type)
    }

    public fn array_value_of_type(mut this, values: [Value], type: TypeId, span: Span) throws -> Value {
        let array_struct_id = .program.find_struct_in_prelude("Array")
        let array_type = Type::GenericInstance(
            id: array_struct_id
            args: [type]
        )
        let array_type_id = .find_or_add_type_id(array_type)

        return Value(
            impl: ValueImpl::JaktArray(
                values
                type_id: array_type_id
            )
            span
        )
    }

    public fn tuple_type(mut this, anon members: [TypeId]) throws -> TypeId {
        let tuple_struct_id = .program.find_struct_in_prelude("Tuple")
        let type = Type::GenericInstance(
            id: tuple_struct_id
            args: members
        )
        return .find_or_add_type_id(type)
    }

    public fn tuple_value(mut this, members: [Value], type: TypeId, span: Span) throws -> Value {
        return Value(
            impl: ValueImpl::JaktTuple(
                fields: members
                type_id: type
            )
            span
        )
    }

    public fn bool_value(mut this, anon value: bool, span: Span) throws -> Value => Value(
        impl: ValueImpl::Bool(value)
        span
    )

    public fn error_value(mut this, anon string: String, anon span: Span) throws -> Value {
        let struct_id = .program.find_struct_in_prelude("Error")
        let constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_struct(struct_id).scope_id
            function_name: "from_string_literal"
        )!
        return Value(
            impl: ValueImpl::Struct(
                fields: [.string_value(string, span)]
                struct_id
                constructor
            )
            span
        )
    }

    public fn string_type(mut this) throws -> TypeId {
        let string_struct_id = .program.find_struct_in_prelude("String")
        let type = Type::Struct(string_struct_id)
        return .find_or_add_type_id(type)
    }

    public fn string_value(mut this, anon string: String, span: Span) throws -> Value => Value(
        impl: ValueImpl::JaktString(string)
        span
    )

    public fn string_from_value(mut this, anon value: Value) throws -> String => match value.impl {
        JaktString(x) => x
        else => {
            .error("Expected string value", value.span)
            .compiler.panic("Invalid type")
        }
    }

    public fn reflect_methods(
        mut this
        anon scope_id: ScopeId
        span: Span
        anon interpreter_scope: InterpreterScope
    ) throws -> Value {
        let method_struct_id = match .program.find_reflected_primitive("Method") {
            Struct(id) => id
            else => {
                panic("Expected Method to be a struct")
            }
        }

        let function_struct_id = match .program.find_reflected_primitive("Function") {
            Struct(id) => id
            else => {
                panic("Expected Function to be a struct")
            }
        }

        let method_struct_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_struct(method_struct_id).scope_id
            function_name: "Method"
        )!

        let function_struct_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_struct(function_struct_id).scope_id
            function_name: "Function"
        )!

        let type_type_id = match .program.find_reflected_primitive("Type") {
            Enum(id) => .program.get_enum(id).type_id
            else => {
                panic("Expected Type to be an enum")
            }
        }

        mut method_values: [Value] = []
        let scope = .program.get_scope(scope_id)
        for (name, ids) in scope.functions {
            for id in ids {
                let function = .program.get_function(id)
                let value = Value(
                    impl: ValueImpl::Struct(
                        fields: [
                            // name:
                            .string_value(name, span)
                            // generic_parameters:
                            .array_value_of_type(
                                values: []
                                type: type_type_id
                                span
                            )
                            // return_type:
                            .reflect_type(type_id: function.return_type_id, span, scope: interpreter_scope)
                            // can_throw:
                            .bool_value(function.can_throw, span)
                            // is_comptime:
                            .bool_value(function.is_comptime, span)
                        ]
                        struct_id: function_struct_id
                        constructor: function_struct_constructor
                    )
                    span
                )

                method_values.push(Value(
                    impl: ValueImpl::Struct(
                        fields: [
                            // function:
                            value
                            // visibility:
                            // FIXME.
                        ]
                        struct_id: method_struct_id
                        constructor: method_struct_constructor
                    )
                    span
                ))
            }
        }

        return Value(
            impl: ValueImpl::JaktArray(
                values: method_values
                type_id: .array_type_of_struct(method_struct_id)
            )
            span
        )
    }

    public fn reflect_fields(mut this, fields: [VarId], span: Span, scope: InterpreterScope) throws -> [Value] {
        let field_struct_id = match .program.find_reflected_primitive("Field") {
            Struct(id) => id
            else => {
                panic("Expected Field to be a struct")
            }
        }
        let field_struct_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_struct(field_struct_id).scope_id
            function_name: "Field")!

        let visibility_enum_id = match .program.find_reflected_primitive("Visibility") {
            Enum(id) => id
            else => {
                panic("Expected Visibility to be an enum")
            }
        }

        let visibility_public_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_enum(visibility_enum_id).scope_id
            function_name: "Public")!
        let visibility_private_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_enum(visibility_enum_id).scope_id
            function_name: "Private")!

        let variable_declaration_struct_id = match .program.find_reflected_primitive("VariableDeclaration") {
            Struct(id) => id
            else => {
                panic("Expected VariableDeclaration to be a struct")
            }
        }

        let variable_declaration_struct_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_struct(variable_declaration_struct_id).scope_id
            function_name: "VariableDeclaration")!

        mut record_type_fields: [Value] = []
        for var_id in fields.iterator() {
            let field = .program.get_variable(var_id)
            let variable = Value(
                impl: ValueImpl::Struct(
                    fields: [
                        // name:
                        Value(
                            impl: ValueImpl::JaktString(field.name)
                            span
                        )
                        // type:
                        .reflect_type(type_id: field.type_id, span, scope)
                        // is_mutable:
                        Value(
                            impl: ValueImpl::Bool(field.is_mutable)
                            span
                        )
                    ]
                    struct_id: variable_declaration_struct_id
                    constructor: variable_declaration_struct_constructor
                )
                span
            )
            let field_value = Value(
                impl: ValueImpl::Struct(
                    fields: [
                        // variable:
                        variable
                        // visibility:
                        Value(
                            impl: ValueImpl::Enum(
                                fields: []
                                enum_id: visibility_enum_id
                                constructor: match field.visibility {
                                    Public => visibility_public_constructor
                                    Private => visibility_private_constructor
                                    else => {
                                        panic("Not implemented")
                                    }
                                }
                            )
                            span
                        )
                    ]
                    struct_id: field_struct_id
                    constructor: field_struct_constructor
                )
                span
            )
            record_type_fields.push(field_value)
        }

        return record_type_fields
    }

    public fn reflect_value_enum_variants(mut this, subject_enum: CheckedEnum, span: Span, scope: InterpreterScope) throws -> [Value] {
        // [String], names of the variants
        let type = .array_type_of_struct(.program.find_struct_in_prelude("String"))
        mut result_elements: [Value] = []
        for entry in subject_enum.variants {
            match entry {
                Untyped(name) | WithValue(name) => {
                    result_elements.push(.string_value(name, span))
                }
                else => {
                    .error("Expected untyped or with-value variant", span)
                    .compiler.panic("Invalid type")
                }
            }
        }

        return [.array_value_of_type(values: result_elements, type: type, span)]
    }

    public fn reflect_sum_enum_variants(mut this, subject_enum: CheckedEnum, span: Span, scope: InterpreterScope) throws -> [Value] {
        let sum_enum_variant_enum_id = match .program.find_reflected_primitive("SumEnumVariant") {
            Enum(id) => id
            else => {
                panic("Expected SumEnumVariant to be an enum")
            }
        }

        let typed_variant_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_enum(sum_enum_variant_enum_id).scope_id
            function_name: "Typed")!
        let struct_like_variant_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_enum(sum_enum_variant_enum_id).scope_id
            function_name: "StructLike")!
        let untyped_variant_constructor = .program.find_function_in_scope(
            parent_scope_id: .program.get_enum(sum_enum_variant_enum_id).scope_id
            function_name: "Untyped")!
        let field_struct_id = match .program.find_reflected_primitive("Field") {
            Struct(id) => id
            else => {
                panic("Expected Field to be a struct")
            }
        }

        mut result: [Value] = []
        for variant in subject_enum.variants.iterator() {
            match variant {
                Typed(name, type_id) => {
                    let type_value = .reflect_type(type_id: type_id, span, scope)
                    let variant_value = Value(
                        impl: ValueImpl::Enum(
                            fields: [
                                // name:
                                .string_value(name, span)
                                // type:
                                type_value
                            ]
                            enum_id: sum_enum_variant_enum_id
                            constructor: typed_variant_constructor
                        )
                        span
                    )
                    result.push(variant_value)
                }
                Untyped(name) => {
                    let variant_value = Value(
                        impl: ValueImpl::Enum(
                            fields: [
                                // name:
                                .string_value(name, span)
                            ]
                            enum_id: sum_enum_variant_enum_id
                            constructor: untyped_variant_constructor
                        )
                        span
                    )
                    result.push(variant_value)
                }
                StructLike(name, fields) => {
                    let reflected_fields = .reflect_fields(fields, span, scope)
                    let variant_value = Value(
                        impl: ValueImpl::Enum(
                            fields: [
                                // name:
                                .string_value(name, span)
                                // fields:
                                .array_value_of_type(
                                    values: reflected_fields
                                    type: .array_type_of_struct(field_struct_id)
                                    span)
                            ]
                            enum_id: sum_enum_variant_enum_id
                            constructor: struct_like_variant_constructor
                        )
                        span
                    )
                    result.push(variant_value)
                }
                else => {}
            }
        }

        return result
    }

    public fn reflect_type(mut this, type_id: TypeId, span: Span, scope: InterpreterScope) throws -> Value {
        let mapped_type_id = scope.map_type(type_id)

        if .reflected_type_cache.contains(mapped_type_id) {
            return .reflected_type_cache.get(mapped_type_id)!
        }

        .seen_reflected_types.add(mapped_type_id)
        defer .seen_reflected_types.remove(mapped_type_id)

        let type = .program.get_type(mapped_type_id)
        let reflected_enum_id = match .program.find_reflected_primitive("Type") {
            Enum(id) => id
            else => {
                panic("Expected Reflect::Type to be an enum")
            }
        }
        let reflected_enum = .program.get_enum(reflected_enum_id)
        mut result = Value(
            impl: ValueImpl::Enum(
                fields: []
                enum_id: reflected_enum_id
                constructor: FunctionId(module: type_id.module, id: 0)
            )
            span
        )
        .reflected_type_cache.set(mapped_type_id, result)

        mut fields: [Value] = []
        let found_constructor = match type {
            Void | I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | Usize | F32 | F64 | JaktString | CChar | CInt | Bool | Unknown | Never => {
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: type.constructor_name())

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                yield constructor!
            }
            Trait | GenericTraitInstance => {
                // FIXME: Actually implement this.
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "TypeVariable")

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                fields = [.string_value("anon$trait_impl", span)]
                yield constructor!
            }
            TypeVariable(name) => {
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "TypeVariable")

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                fields = [.string_value(name, span)]
                yield constructor!
            }
            RawPtr(type_id) | Reference(type_id) | MutableReference(type_id) => {
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: type.constructor_name())!

                fields = [.reflect_type(type_id, span, scope)]
                yield constructor
            }
            GenericInstance(id: struct_id) | Struct(struct_id) => {
                let subject_struct = .program.get_struct(struct_id)

                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "StructureOrEnum")

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                let record_struct_id = match .program.find_reflected_primitive("Record") {
                    Struct(id) => id
                    else => {
                        panic("Expected Record to be a struct")
                    }
                }
                let record_struct_constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_struct(record_struct_id).scope_id
                    function_name: "Record")!

                let record_type_enum_id = match .program.find_reflected_primitive("RecordType") {
                    Enum(id) => id
                    else => {
                        panic("Expected RecordType to be an enum")
                    }
                }
                let record_type_struct_constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(record_type_enum_id).scope_id
                    function_name: "Struct")!

                let methods = .reflect_methods(subject_struct.scope_id, span, scope)
                let tuple_type = .tuple_type([.string_type(), reflected_enum.type_id])
                let generic_parameters = .array_value_of_type(
                    values: match type {
                        GenericInstance(args) => {
                            mut i = 0uz
                            mut result: [Value] = []
                            for generic_parameter in subject_struct.generic_parameters {
                                let name = match .program.get_type(generic_parameter.type_id) {
                                    TypeVariable(name) => name
                                    else => {
                                        panic("Unknown kind of generic parameter in struct definition")
                                    }
                                }
                                let t = match i < args.size() {
                                    true => args[i]
                                    false => builtin(BuiltinType::Unknown)
                                }
                                result.push(.tuple_value(
                                    members: [
                                        .string_value(name, span)
                                        .reflect_type(type_id: t, span, scope)
                                    ]
                                    type: tuple_type
                                    span))
                                i += 1
                            }
                            yield result
                        }
                        else => []
                    }
                    type: tuple_type
                    span
                )

                mut reflected_fields: [VarId] = []
                for field in subject_struct.fields {
                    reflected_fields.push(field.variable_id)
                }
                let record_type_fields = .reflect_fields(fields: reflected_fields, span, scope)

                let field_struct_id = match .program.find_reflected_primitive("Field") {
                    Struct(id) => id
                    else => {
                        panic("Expected Field to be a struct")
                    }
                }

                fields = [
                    Value(
                        impl: ValueImpl::Struct(
                            fields: [
                                // name:
                                .string_value(subject_struct.name, span)
                                methods
                                generic_parameters
                                // record_type:
                                Value(
                                    impl: ValueImpl::Enum(
                                        fields: [
                                            Value(
                                                impl: ValueImpl::JaktArray(
                                                    values: record_type_fields
                                                    type_id: .array_type_of_struct(field_struct_id)
                                                )
                                                span
                                            )
                                        ]
                                        enum_id: record_type_enum_id
                                        constructor: record_type_struct_constructor
                                    )
                                    span
                                )
                            ]
                            struct_id: record_struct_id
                            constructor: record_struct_constructor
                        )
                        span
                    )
                ]

                yield constructor!
            }
            GenericEnumInstance(id: enum_id) | Enum(enum_id) => {
                let subject_enum = .program.get_enum(enum_id)

                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "StructureOrEnum")

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                let record_struct_id = match .program.find_reflected_primitive("Record") {
                    Struct(id) => id
                    else => {
                        panic("Expected Record to be a struct")
                    }
                }
                let record_struct_constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_struct(record_struct_id).scope_id
                    function_name: "Record")!

                let record_type_enum_id = match .program.find_reflected_primitive("RecordType") {
                    Enum(id) => id
                    else => {
                        panic("Expected RecordType to be an enum")
                    }
                }

                let is_value_enum = subject_enum.underlying_type_id.equals(unknown_type_id())

                let record_type_struct_constructor = match is_value_enum {
                    true => .program.find_function_in_scope(
                        parent_scope_id: .program.get_enum(record_type_enum_id).scope_id
                        function_name: "ValueEnum")!
                    false => .program.find_function_in_scope(
                        parent_scope_id: .program.get_enum(record_type_enum_id).scope_id
                        function_name: "SumEnum")!
                }

                let methods = .reflect_methods(subject_enum.scope_id, span, scope)
                let tuple_type = .tuple_type([.string_type(), reflected_enum.type_id])
                let generic_parameters = .array_value_of_type(
                    values: match type {
                        GenericInstance(args) => {
                            mut i = 0uz
                            mut result: [Value] = []
                            for generic_parameter in subject_enum.generic_parameters {
                                let name = match .program.get_type(generic_parameter.type_id) {
                                    TypeVariable(name) => name
                                    else => {
                                        panic("Unknown kind of generic parameter in struct definition")
                                    }
                                }
                                let t = match i < args.size() {
                                    true => args[i]
                                    false => builtin(BuiltinType::Unknown)
                                }
                                result.push(.tuple_value(
                                    members: [
                                        .string_value(name, span)
                                        .reflect_type(type_id: t, span, scope)
                                    ]
                                    type: tuple_type
                                    span))
                                i += 1
                            }
                            yield result
                        }
                        else => []
                    }
                    type: tuple_type
                    span)

                let field_struct_id = match .program.find_reflected_primitive("Field") {
                    Struct(id) => id
                    else => {
                        panic("Expected Field to be a struct")
                    }
                }
                mut record_type_fields: [Value] = []
                if is_value_enum {
                    let variants = .reflect_value_enum_variants(subject_enum, span, scope)
                    record_type_fields = [
                        // underlying_type:
                        .reflect_type(type_id: subject_enum.underlying_type_id, span, scope)
                        // variants:
                        Value(
                            impl: ValueImpl::JaktArray(
                                values: variants
                                type_id: .array_type_of_struct(field_struct_id)
                            )
                            span
                        )
                    ]
                } else {
                    let variants = .reflect_sum_enum_variants(subject_enum, span, scope)
                    record_type_fields = [
                        // is_boxed:
                        .bool_value(subject_enum.is_boxed, span),
                        // variants:
                        Value(
                            impl: ValueImpl::JaktArray(
                                values: variants
                                type_id: .array_type_of_struct(field_struct_id)
                            )
                            span
                        )
                    ]
                }

                fields = [
                    Value(
                        impl: ValueImpl::Struct(
                            fields: [
                                // name:
                                .string_value(subject_enum.name, span)
                                methods
                                generic_parameters
                                // record_type:
                                Value(
                                    impl: ValueImpl::Enum(
                                        fields: record_type_fields
                                        enum_id: record_type_enum_id
                                        constructor: record_type_struct_constructor
                                    )
                                    span
                                )
                            ]
                            struct_id: record_struct_id
                            constructor: record_struct_constructor
                        )
                        span
                    )
                ]

                yield constructor!
            }
            Function => {
                // FIXME: Actually fill the contents.
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "Function")

                if not constructor.has_value() {
                    .error("Attempted to access a variant that does not exist", span)
                    .compiler.panic("Invalid type")
                }

                fields = []
                yield constructor!
            }
            else => {
                // FIXME: Implement these
                let constructor = .program.find_function_in_scope(
                    parent_scope_id: .program.get_enum(reflected_enum_id).scope_id
                    function_name: "Unknown")!
                fields = []
                yield constructor
            }
        }

        match result.impl {
            Enum(&mut fields: x, &mut constructor) => {
                constructor = found_constructor
                x = fields
            }
            else => {}
        }

        return result
    }
}
