import types {
    BlockControlFlow, BuiltinType, CheckedBlock, CheckedCall, CheckedExpression, CheckedEnum,
    CheckedMatchBody, CheckedNumericConstant, CheckedProgram, CheckedStatement, EnumId,
    BinaryOperator, CheckedEnumVariant, CheckedVariable, CheckedVisibility, CheckedParameter,
    EnumVariantPatternArgument, FunctionId, ModuleId, ResolvedNamespace, ScopeId, Span, StructId,
    GenericInferences, Scope, Type, TypeId, VarId, Value, ValueImpl, builtin, unknown_type_id,
}
import utility { escape_for_quotes, interpret_escapes, panic }
import error { JaktError }
import compiler { Compiler }

enum InterpretError : i32 {
    CallToExternalFunction = 42i32
    MismatchingArguments
    InvalidThisArgument
    InvalidType
    UnknownVariable
    Unimplemented
    UnwrapOptionalNone
}

function cast_value_to_type(anon this_value: Value, anon type_id: TypeId, interpreter: Interpreter, saturating: bool = false) throws -> Value {
    let type = interpreter.program.get_type(type_id)
    let is_optional = match type {
        GenericInstance(id) => id.equals(interpreter.program.find_struct_in_prelude("Optional"))
        else => false
    }

    return match type {
        U8 => match this_value.impl {
            U16(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U8(value as! u8), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        U16 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U16(value as! u16), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        U32 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            U16(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            U64(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U32(value as! u32), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        U64 => match this_value.impl {
            U8(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            U16(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            U32(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            USize(value) => Value(impl: ValueImpl::U64(value as! u64), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        I8 => match this_value.impl {
            I16(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I8(value as! i8), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        I16 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I16(value as! i16), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        I32 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            I16(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            I64(value) => Value(impl: ValueImpl::I32(value as! i32), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        I64 => match this_value.impl {
            I8(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            I16(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            I32(value) => Value(impl: ValueImpl::I64(value as! i64), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        Usize => match this_value.impl {
            U64(value) => Value(impl: ValueImpl::USize(value as! usize), span: this_value.span)
            else => match is_optional {
                true => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
                else => this_value
            }
        }
        else => match is_optional {
            true => match this_value.impl {
                OptionalSome | OptionalNone => this_value
                else => Value(impl: ValueImpl::OptionalSome(value: this_value), span: this_value.span),
            }
            else => this_value
        }
    }
}

function value_to_checked_expression(anon this_value: Value, anon mut interpreter: Interpreter) throws -> CheckedExpression => match this_value.impl {
    Void => {
        interpreter.error("Cannot convert void to expression", this_value.span)
        throw Error::from_errno(InterpretError::InvalidType as! i32)
    }
    Bool(x)  => CheckedExpression::Boolean(val: x, span: this_value.span)
    U8(x)    => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U8(x), span: this_value.span, type_id: builtin(BuiltinType::U8))
    U16(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U16(x), span: this_value.span, type_id: builtin(BuiltinType::U16))
    U32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U32(x), span: this_value.span, type_id: builtin(BuiltinType::U32))
    U64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::U64(x), span: this_value.span, type_id: builtin(BuiltinType::U64))
    I8(x)    => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I8(x), span: this_value.span, type_id: builtin(BuiltinType::I8))
    I16(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I16(x), span: this_value.span, type_id: builtin(BuiltinType::I16))
    I32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(x), span: this_value.span, type_id: builtin(BuiltinType::I32))
    I64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I64(x), span: this_value.span, type_id: builtin(BuiltinType::I64))
    F32(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F32(x), span: this_value.span, type_id: builtin(BuiltinType::F32))
    F64(x)   => CheckedExpression::NumericConstant(val: CheckedNumericConstant::F64(x), span: this_value.span, type_id: builtin(BuiltinType::F64))
    USize(x) => CheckedExpression::NumericConstant(val: CheckedNumericConstant::USize(x as! u64), span: this_value.span, type_id: builtin(BuiltinType::Usize))
    JaktString(x) => CheckedExpression::QuotedString(val: escape_for_quotes(x), span: this_value.span)
    CChar(x) => CheckedExpression::CharacterConstant(val: format("{}", x), span: this_value.span)
    CInt(x)  => CheckedExpression::NumericConstant(val: CheckedNumericConstant::I32(x as! i32), span: this_value.span, type_id: builtin(BuiltinType::CInt))
    OptionalNone => CheckedExpression::OptionalNone(span: this_value.span, type_id: unknown_type_id())
    OptionalSome(value) => {
        let expr = value_to_checked_expression(value, interpreter)
        let inner_type_id = expr.type()
        let optional_struct_id = interpreter.program.find_struct_in_prelude("Optional")
        let type = Type::GenericInstance(id: optional_struct_id, args: [inner_type_id])
        let type_id = interpreter.find_or_add_type_id(type)
        yield CheckedExpression::OptionalSome(expr, span: this_value.span, type_id)
    }
    JaktTuple(fields, type_id) => {
        mut vals: [CheckedExpression] = []
        for field in fields.iterator() {
            vals.push(value_to_checked_expression(field, interpreter))
        }
        yield CheckedExpression::JaktTuple(vals, span: this_value.span, type_id)
    }
    Struct(fields, struct_id, constructor)
    | Class(fields, struct_id, constructor) => {
        if not constructor.has_value() {
            interpreter.error_with_hint(
                "Cannot convert struct to expression without constructor", this_value.span,
                "Given struct cannot be created from its contents in any known way", this_value.span)
            throw Error::from_errno(InterpretError::InvalidType as! i32)
        }

        mut materialised_fields: [CheckedExpression] = []
        for field in fields.iterator() {
            materialised_fields.push(value_to_checked_expression(field, interpreter))
        }

        let struct_ = interpreter.program.get_struct(struct_id)
        mut reversed_namespace: [ResolvedNamespace] = []
        mut scope_id: ScopeId? = struct_.scope_id
        while scope_id.has_value() {
            let scope = interpreter.program.get_scope(scope_id!)
            if scope.namespace_name.has_value() {
                reversed_namespace.push(ResolvedNamespace(name: scope.namespace_name!, generic_parameters: None))
            }
            scope_id = scope.parent
        }
        mut namespace_: [ResolvedNamespace] = []
        for i in reversed_namespace.size()..0 {
            namespace_.push(reversed_namespace[i - 1])
        }

        let name = struct_.name
        mut args: [(String, CheckedExpression)] = []
        for i in 0..materialised_fields.size() {
            let arg = materialised_fields[i]
            let label = interpreter.program.get_variable(struct_.fields[i].variable_id).name
            args.push((label, arg))
        }

        let callee = interpreter.program.get_function(constructor!)

        let call = CheckedCall(
            namespace_
            name
            args
            type_args: []
            function_id: constructor
            return_type: struct_.type_id
            callee_throws: callee.can_throw
        )

        yield CheckedExpression::Call(
            call
            span: this_value.span
            type_id: struct_.type_id
        )
    }
    Enum(fields, enum_id, constructor) => {
        mut materialised_fields: [CheckedExpression] = []
        for field in fields.iterator() {
            materialised_fields.push(value_to_checked_expression(field, interpreter))
        }

        let enum_ = interpreter.program.get_enum(enum_id)
        mut reversed_namespace: [ResolvedNamespace] = []
        mut scope_id: ScopeId? = enum_.scope_id
        while scope_id.has_value() {
            let scope = interpreter.program.get_scope(scope_id!)
            if scope.namespace_name.has_value() {
                reversed_namespace.push(ResolvedNamespace(name: scope.namespace_name!, generic_parameters: None))
            }
            scope_id = scope.parent
        }
        mut namespace_: [ResolvedNamespace] = []
        for i in reversed_namespace.size()..0 {
            namespace_.push(reversed_namespace[i - 1])
        }

        // FIXME: Fill these in.
        namespace_.push(ResolvedNamespace(name: enum_.name, generic_parameters: None))

        let name = enum_.name
        mut args: [(String, CheckedExpression)] = []
        for i in 0..materialised_fields.size() {
            let arg = materialised_fields[i]
            // FIXME: Fill this thing
            // let label = interpreter.program.get_variable(enum_.fields[i]).name
            args.push(("", arg))
        }

        let callee = interpreter.program.get_function(constructor)

        let call = CheckedCall(
            namespace_
            name: callee.name
            args
            type_args: []
            function_id: constructor
            return_type: enum_.type_id
            callee_throws: callee.can_throw
        )

        yield CheckedExpression::Call(
            call
            span: this_value.span
            type_id: enum_.type_id
        )
    }
    JaktArray(values, type_id) => {
        mut vals: [CheckedExpression] = []
        for value in values.iterator() {
            vals.push(value_to_checked_expression(value, interpreter))
        }

        let inner_type_id = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => args[0]
            else => {
                panic("Expected generic instance of Array while materialising an array")
            }
        }

        yield CheckedExpression::JaktArray(
            vals
            repeat: None
            span: this_value.span
            type_id
            inner_type_id
        )
    }
    JaktDictionary(keys, values, type_id) => {
        mut vals: [(CheckedExpression, CheckedExpression)] = []
        for i in 0..keys.size() {
            vals.push((
                value_to_checked_expression(keys[i], interpreter),
                value_to_checked_expression(values[i], interpreter)
            ))
        }

        let (key_type_id, value_type_id) = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => (args[0], args[1])
            else => {
                panic("Expected generic instance of Dictionary while materialising an array")
            }
        }

        yield CheckedExpression::JaktDictionary(
            vals
            span: this_value.span
            type_id
            key_type_id
            value_type_id
        )
    }
    JaktSet(values, type_id) => {
        mut vals: [CheckedExpression] = []
        for i in 0..values.size() {
            vals.push(value_to_checked_expression(values[i], interpreter))
        }

        let value_type_id = match interpreter.program.get_type(type_id) {
            GenericInstance(args) => args[0]
            else => {
                panic("Expected generic instance of Set while materialising an array")
            }
        }

        yield CheckedExpression::JaktSet(
            vals
            span: this_value.span
            type_id
            inner_type_id: value_type_id
        )
    }
    Function(captures, can_throw, return_type_id, type_id, block, checked_params) => {
        // As all the captures are compiletime objects, we can simply inline them as assignments inside the block :P
        let parent_scope = interpreter.program.get_scope(block.scope_id)
        let inherited_scope_id = interpreter.program.create_scope(
            parent_scope_id: block.scope_id
            can_throw: parent_scope.can_throw
            debug_name: format("synthetic({})", parent_scope.debug_name)
            module_id: type_id.module)

        mut inherited_scope = interpreter.program.get_scope(inherited_scope_id)
        mut statements: [CheckedStatement] = []
        for capture in captures.iterator() {
            let value = value_to_checked_expression(capture.1, interpreter)
            let var_id = interpreter.program.get_module(id: type_id.module).add_variable(CheckedVariable(
                name: capture.0
                type_id: value.type()
                is_mutable: false
                definition_span: this_value.span
                type_span: None
                visibility: CheckedVisibility::Public
            ))
            statements.push(CheckedStatement::VarDecl(
                var_id
                init: value
                span: this_value.span
            ))

            inherited_scope.comptime_bindings.set(capture.0, capture.1)
        }

        // Then append all the statements in the block
        for statement in block.statements.iterator() {
            statements.push(statement)
        }

        let new_block = CheckedBlock(
            statements
            scope_id: inherited_scope_id
            control_flow: block.control_flow
            yielded_type: block.yielded_type
            yielded_none: block.yielded_none
        )

        for param in checked_params.iterator() {
            println("Param: {}", interpreter.program.type_name(param.variable.type_id))
        }

        yield CheckedExpression::Function(
            captures: []
            params: checked_params
            can_throw
            return_type_id
            block: new_block
            span: this_value.span
            type_id
            pseudo_function_id: None
        )
    }
    else => {
        interpreter.error(
            format("Cannot materialise the type {}", this_value.impl)
            this_value.span
        )
        throw Error::from_errno(InterpretError::Unimplemented as! i32);
    }
}

enum Deferred {
    Expression(CheckedExpression)
    Statement(CheckedStatement)
}

class InterpreterScope {
    public bindings: [String:Value]
    public parent: InterpreterScope?
    public type_bindings: [String:TypeId]
    public defers: [Deferred]

    public function create(bindings: [String:Value] = [:], parent: InterpreterScope? = None, type_bindings: [String:TypeId] = [:]) throws => InterpreterScope(
        bindings
        parent
        type_bindings
        defers: []
    )

    public function from_runtime_scope(scope_id: ScopeId, program: CheckedProgram, parent: InterpreterScope? = None) throws -> InterpreterScope {
        mut bindings: [String:Value] = [:]
        mut current_id: ScopeId? = scope_id
        while current_id.has_value() {
            let scope = program.get_scope(current_id!)
            for pair in scope.comptime_bindings.iterator() {
                if bindings.contains(pair.0) {
                    continue
                }

                bindings.set(pair.0, pair.1)
            }
            current_id = scope.parent
        }

        return InterpreterScope(
            bindings
            parent
            type_bindings: [:]
            defers: []
        )
    }

    public function must_get(this, anon name: String) throws -> Value {
        if .bindings.contains(name) {
            return .bindings[name]
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.bindings.contains(name) {
                return scope!.bindings[name]
            }
            scope = scope!.parent
        }

        // How did this pass typecheck?
        panic(format("Could not find binding for {}", name))
    }

    public function set(mut this, anon name: String, anon value: Value) throws {
        if .bindings.contains(name) {
            .bindings[name] = value
            return
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.bindings.contains(name) {
                scope!.bindings[name] = value
                return
            }
            scope = scope!.parent
        }

        // How did this pass typecheck?
        panic(format("Could not find binding for {}", name))
    }

    public function map_type(this, anon id: TypeId) throws -> TypeId {
        let name = id.to_string()
        if .type_bindings.contains(name) {
            return .type_bindings[name]
        }

        mut scope = .parent
        while scope.has_value() {
            if scope!.type_bindings.contains(name) {
                return scope!.type_bindings[name]
            }
            scope = scope!.parent
        }

        return id
    }

    function type_map_for_substitution_helper(this, map: &mut [String:String]) throws {
        if .parent.has_value() {
            .parent!.type_map_for_substitution_helper(map)
        }

        for pair in .type_bindings.iterator() {
            map.set(pair.0, pair.1.to_string())
        }
    }

    public function type_map_for_substitution(this) throws -> GenericInferences {
        mut map: [String:String] = [:]
        .type_map_for_substitution_helper(&mut map)
        return GenericInferences(values: map)
    }

    public function perform_defers(mut this, mut interpreter: Interpreter, span: Span) throws {
        while not .defers.is_empty() {
            let deferred = .defers.pop()
            match deferred! {
                Expression(expr) => interpreter.execute_expression(expr, scope: this)
                Statement(statement) => interpreter.execute_statement(statement, scope: this, call_span: span)
            }
        }
    }

    public function defer_expression(mut this, expr: CheckedExpression) throws {
        .defers.push(Deferred::Expression(expr))
    }

    public function defer_statement(mut this, statement: CheckedStatement) throws {
        .defers.push(Deferred::Statement(statement))
    }
}

enum ExecutionResult {
    Return(Value)
    Throw(Value)
}

enum StatementResult {
    Return(Value)
    Throw(Value)
    Yield(Value)
    Continue
    Break
    JustValue(Value)
}

class Interpreter {
    public compiler: Compiler
    public program: CheckedProgram
    public spans: [Span]
    public current_function_id: FunctionId?

    public function create(compiler: Compiler, program: CheckedProgram, spans: [Span]) throws -> Interpreter {
        return Interpreter(
            compiler
            program
            spans
            current_function_id: None
        )
    }

    public function enter_span(mut this, anon span: Span) throws {
        .spans.push(span)
    }
    
    public function leave_span(mut this) {
        // FIXME: It's awkward that we need a temporary to avoid the C++ nodiscard warning
        let dummy = .spans.pop()
    }

    public function get_prelude_function(this, anon scope_id: ScopeId) throws -> bool {
        mut current_scope_id = scope_id
        let prelude_scope_id = .program.prelude_scope_id()
        loop {
            if current_scope_id.equals(prelude_scope_id) {
                return true
            }

            let scope = .program.get_scope(current_scope_id)
            if scope.parent.has_value() {
                current_scope_id = scope.parent!
                continue
            }

            return false
        }
    }

    public function find_or_add_type_id(mut this, anon type: Type) throws -> TypeId {

        for module in .program.modules.iterator() {
            for id in 0..module.types.size() {
                if module.types[id].equals(type) {
                    return TypeId(module: module.id, id)
                }
            }
        }

        .program.modules[0].types.push(type)

        return TypeId(module: ModuleId(id: 0), id: .program.modules[0].types.size() - 1)
    }

    public function call_prelude_function(mut this, anon prelude_function: String, anon namespace_: [ResolvedNamespace], this_argument: Value?, arguments: [Value], call_span: Span, type_bindings: [String:TypeId]) throws -> StatementResult {
        if namespace_.size() != 1 {
            return match prelude_function {
                "format" => {
                    let format_string = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Expected string as first argument to format, got {}", arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32);
                        }
                    }
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::JaktString(
                                match arguments.size() {
                                    1uz => format(format_string)
                                    2uz => match arguments[1].impl {
                                        Bool(x)
                                        | U8(x)
                                        | U16(x)
                                        | U32(x)
                                        | U64(x)
                                        | I8(x)
                                        | I16(x)
                                        | I32(x)
                                        | I64(x)
                                        | F32(x)
                                        | F64(x)
                                        | USize(x)
                                        | JaktString(x)
                                        | CChar(x)
                                        | CInt(x)
                                        => format(format_string, x)
                                        else => {
                                            .error(format("comptime format can only format primitves, got {}", arguments[1].impl), call_span)
                                            throw Error::from_errno(InterpretError::InvalidType as! i32);
                                        }
                                    }
                                    else => {
                                        .error(format("comptime format accepts at most two arguments, but got {}", arguments.size()), call_span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32);
                                    }
                                }
                            )
                            span: call_span
                        )
                    )
                }
                "println" | "eprintln" | "print" | "eprint" => {
                    let format_string = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(format( "println expects a string as its first argument, but got {}", arguments[0].impl), call_span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32);
                        }
                    }
                    match arguments.size() {
                        1uz => match prelude_function {
                            "println" => println(format_string)
                            "eprintln" => eprintln(format_string)
                            "print" => print(format_string)
                            else => eprint(format_string)
                        }
                        2uz => match arguments[1].impl {
                            Bool(x)
                            | U8(x)
                            | U16(x)
                            | U32(x)
                            | U64(x)
                            | I8(x)
                            | I16(x)
                            | I32(x)
                            | I64(x)
                            | F32(x)
                            | F64(x)
                            | USize(x)
                            | JaktString(x)
                            | CChar(x)
                            | CInt(x)
                            => match prelude_function {
                                "println" => println(format_string, x)
                                "eprintln" => eprintln(format_string, x)
                                "print" => print(format_string, x)
                                else => eprint(format_string, x)
                            }
                            else => {
                                .error(format( "comptime format can only format primitves, got {}", arguments[1].impl), call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32);
                            }
                        }
                        else => {
                            .error(format("comptime format accepts at most two arguments, but got {}", arguments.size()), call_span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32);
                        }
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Void
                            span: call_span
                        )
                    )
                }
                "as_saturated" => {
                    let function_ = .program.get_function(.program.find_function_in_scope(
                        parent_scope_id: .program.prelude_scope_id()
                        function_name: "as_saturated")!)

                    let output_type_id = type_bindings.get(function_.generics.params[0].type_id().to_string())
                    yield StatementResult::JustValue(
                        cast_value_to_type(arguments[0], output_type_id!, interpreter: this, saturating: true)
                    )
                }
                "unchecked_mul" => {
                    let lhs_value = arguments[0]
                    let rhs_value = arguments[1]
                    let span = call_span

                    yield StatementResult::JustValue(
                        Value(
                            impl: match lhs_value.impl {
                                U8(x) => match rhs_value.impl {
                                    U8(y) => ValueImpl::U8(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U16(x) => match rhs_value.impl {
                                    U16(y) => ValueImpl::U16(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U32(x) => match rhs_value.impl {
                                    U32(y) => ValueImpl::U32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U64(x) => match rhs_value.impl {
                                    U64(y) => ValueImpl::U64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I8(x) => match rhs_value.impl {
                                    I8(y) => ValueImpl::I8(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I16(x) => match rhs_value.impl {
                                    I16(y) => ValueImpl::I16(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I32(x) => match rhs_value.impl {
                                    I32(y) => ValueImpl::I32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I64(x) => match rhs_value.impl {
                                    I64(y) => ValueImpl::I64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                F32(x) => match rhs_value.impl {
                                    F32(y) => ValueImpl::F32(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                F64(x) => match rhs_value.impl {
                                    F64(y) => ValueImpl::F64(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                USize(x) => match rhs_value.impl {
                                    USize(y) => ValueImpl::USize(unchecked_mul(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                else => {
                                    .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                                }
                            }
                            span
                        )
                    )
                }
                "unchecked_add" => {
                    let lhs_value = arguments[0]
                    let rhs_value = arguments[1]
                    let span = call_span

                    yield StatementResult::JustValue(
                        Value(
                            impl: match lhs_value.impl {
                                U8(x) => match rhs_value.impl {
                                    U8(y) => ValueImpl::U8(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U16(x) => match rhs_value.impl {
                                    U16(y) => ValueImpl::U16(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U32(x) => match rhs_value.impl {
                                    U32(y) => ValueImpl::U32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                U64(x) => match rhs_value.impl {
                                    U64(y) => ValueImpl::U64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I8(x) => match rhs_value.impl {
                                    I8(y) => ValueImpl::I8(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I16(x) => match rhs_value.impl {
                                    I16(y) => ValueImpl::I16(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I32(x) => match rhs_value.impl {
                                    I32(y) => ValueImpl::I32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                I64(x) => match rhs_value.impl {
                                    I64(y) => ValueImpl::I64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                F32(x) => match rhs_value.impl {
                                    F32(y) => ValueImpl::F32(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                F64(x) => match rhs_value.impl {
                                    F64(y) => ValueImpl::F64(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                USize(x) => match rhs_value.impl {
                                    USize(y) => ValueImpl::USize(unchecked_add(x, y))
                                    else => {
                                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                                    }
                                }
                                else => {
                                    .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                                }
                            }
                            span
                        )
                    )
                }
                "___jakt_get_target_triple_string" => StatementResult::JustValue(Value(
                    impl: ValueImpl::JaktString(.compiler.target_triple ?? ___jakt_get_target_triple_string())
                    span: call_span
                ))
                "abort" => {abort()}
                "Set" => {
                    if type_bindings.size() != 1 {
                        .error("Set constructor expects one generic argument", call_span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    let set_struct_id = .program.find_struct_in_prelude("Set")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: set_struct_id, args: [type_bindings.get(type_bindings.keys()[0])!]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktSet(values: [], type_id)
                        span: call_span
                    ))
                }
                "Dictionary" => {
                    if type_bindings.size() != 2 {
                        .error("Dictionary constructor expects two generic argumenst", call_span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    let dictionary_struct_id = .program.find_struct_in_prelude("Dictionary")
                    let type_id = .find_or_add_type_id(Type::GenericInstance(id: dictionary_struct_id, args: [
                        type_bindings.get(type_bindings.keys()[0])!,
                        type_bindings.get(type_bindings.keys()[1])!,
                    ]))

                    yield StatementResult::JustValue(Value(
                        impl: ValueImpl::JaktDictionary(keys: [], values: [], type_id)
                        span: call_span
                    ))
                }
                else => {
                    .error(
                        format("Prelude function {}::{} is not implemented yet", namespace_, prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
        }

        return match namespace_[0].name {
            "Error" => match prelude_function {
                "from_errno" => {
                    let err = arguments[0]
                    let error_struct_id = .program.find_struct_in_prelude("Error")
                    let error_struct = .program.get_struct(error_struct_id)
                    let scope = .program.get_scope(error_struct.scope_id)
                    let constructor = scope.functions.get("from_errno")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    err
                                ],
                                struct_id: error_struct_id
                                constructor: constructor!
                            )
                            span: call_span
                        )
                    )
                }
                "code" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        I32(code) => StatementResult::JustValue(Value(impl: ValueImpl::I32(code), span: call_span))
                        else => {
                            .error(
                                format("Error should have `i32` as its code, but got {}", fields[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `Error::code` expects an Error as its this argument, but got {}", this_argument!.impl),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Error::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "File" => match prelude_function {
                "open_for_reading" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    let path_value = Value(
                        impl: ValueImpl::JaktString(path.to_string())
                        span: call_span
                    )
                    if not path.exists() {
                        // FIXME: This should `return StatementResult::Throw(...)`, but we currently can't put strings in Error, so the output result looks vague and unhelpful.
                        .error(
                            format("Prelude function `File::{}` could not find file at path {}", prelude_function, path.to_string()),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let constructor = scope.functions.get("open_for_reading")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    path_value
                                ],
                                struct_id: file_struct_id
                                constructor: constructor!
                            )
                            span: call_span
                        )
                    )
                }
                "open_for_writing" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    let path_value = Value(
                        impl: ValueImpl::JaktString(path.to_string())
                        span: call_span
                    )
                    if not path.exists() {
                        // FIXME: This should `return StatementResult::Throw(...)`, but we currently can't put strings in Error, so the output result looks vague and unhelpful.
                        .error(
                            format("Prelude function `File::{}` could not find file at path {}", prelude_function, path.to_string()),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let constructor = scope.functions.get("open_for_writing")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [
                                    path_value
                                ],
                                struct_id: file_struct_id
                                constructor: constructor!
                            )
                            span: call_span
                        )
                    )
                }
                "read_all" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::read_all")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::read_all` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_reading = scope.functions.get("open_for_reading")!
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_reading) {
                                .error(
                                    "Cannot read from a file not opened for reading"
                                    call_span
                                )
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }
                    
                    mut file = File::open_for_reading(path)
                    mut result_values: [Value] = []
                    for byte in file.read_all().iterator() {
                        result_values.push(Value(
                            impl: ValueImpl::U8(byte)
                            span: call_span
                        ))
                    }
                    let array_struct_id = .program.find_struct_in_prelude("Array")

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::JaktArray(
                                values: result_values
                                type_id: .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [builtin(BuiltinType::U8)]))
                            )
                            span: call_span
                        )
                    )
                }
                "read" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::read")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::read` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_reading = scope.functions.get("open_for_reading")!
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_reading) {
                                .error(
                                    "Cannot read from a file not opened for reading"
                                    call_span
                                )
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }
                    mut file = File::open_for_reading(path)
                    mut values_buffer = match arguments[0].impl {
                        JaktArray(values) => values
                        else => {
                            .error(
                                format("Prelude function `File::read` expects a `[u8]` as its argument, but got {}", arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    mut byte_buffer: [u8] = [0; values_buffer.size()]
                    let bytes_read = file.read(byte_buffer)

                    for i in 0..byte_buffer.size() {
                        values_buffer[i] = Value(
                            impl: ValueImpl::U8(byte_buffer[i])
                            span: call_span
                        )
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(bytes_read)
                            span: call_span
                        )
                    )
                }
                "exists" => {
                    let requested_path = match arguments[0].impl {
                        JaktString(x) => x
                        else => {
                            .error(
                                format("Prelude function `File::{}` expects a string as its first argument, but got {}", prelude_function, arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let path = .program.compiler.get_file_path(call_span.file_id)!.parent().join(requested_path)
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Bool(path.exists())
                            span: call_span
                        )
                    )
                }
                "write" => {
                    let path = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(x) => x
                            else => {
                                panic("invalid type for File::write")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `File::write` expects a `File` as its this argument, but got {}", this_argument!.impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    let file_struct_id = .program.find_struct_in_prelude("File")
                    let file_struct = .program.get_struct(file_struct_id)
                    let scope = .program.get_scope(file_struct.scope_id)
                    let open_for_writing = scope.functions.get("open_for_writing")!
                    match this_argument!.impl {
                        Struct(constructor) => {
                            if not constructor.has_value() or not constructor!.equals(open_for_writing) {
                                .error(
                                    "Cannot write to a file not opened for writing"
                                    call_span
                                )
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            panic("expected struct as this argument")
                        }
                    }
                    mut file = File::open_for_writing(path)
                    mut data_values = match arguments[0].impl {
                        JaktArray(values) => values
                        else => {
                            .error(
                                format("Prelude function `File::write` expects a `[u8]` as its argument, but got {}", arguments[0].impl),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    mut data: [u8] = []
                    for val in data_values.iterator() {
                        data.push(match val.impl {
                            U8(x) => x
                            else => {panic("expected byte")}
                        })
                    }
                    let bytes_written = file.write(data)

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(bytes_written)
                            span: call_span
                        )
                    )
                }
                else => {
                    .error(
                        format("Prelude function `File::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "StringBuilder" => match prelude_function {
                "create" => {
                    let string_builder_struct_id = .program.find_struct_in_prelude("StringBuilder")
                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Struct(
                                fields: [Value(impl: ValueImpl::JaktString(""), span: call_span)],
                                struct_id: string_builder_struct_id,
                                constructor: None
                            )
                            span: call_span
                        )
                    )
                }
                "append" | "append_string" | "append_code_point" | "append_escaped_for_json" => {
                    mut (fields, current_string) = match this_argument!.impl {
                        Struct(fields) => match fields[0].impl {
                            JaktString(value) => (fields, value)
                            else => {
                                panic("Invalid use of prelude StringBuilder")
                            }
                        }
                        else => {
                            .error(
                                format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                                call_span
                            )
                            throw Error::from_errno(InterpretError::Unimplemented as! i32)
                        }
                    }

                    mut builder = StringBuilder::create()
                    builder.append_string(current_string)
                    match prelude_function {
                        "append" => builder.append(match arguments[0].impl {
                            U8(value) => value
                            else => {
                                .error(format("Invalid use of StringBuilder::append({})", arguments[0].impl), call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        })
                        "append_string" => builder.append_string(match arguments[0].impl {
                            JaktString(value) => value
                            else => {
                                .error("Invalid use of StringBuilder::append_string()", call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        })
                        "append_escaped_for_json" => builder.append_escaped_for_json(match arguments[0].impl {
                            JaktString(value) => value
                            else => {
                                .error("Invalid use of StringBuilder::append_escaped_for_json()", call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        })
                        "append_code_point" => builder.append_code_point(match arguments[0].impl {
                            U32(value) => value
                            else => {
                                .error("Invalid use of StringBuilder::append_code_point()", call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        })
                        else => {
                            abort()
                        }
                    }

                    fields[0] = Value(
                        impl: ValueImpl::JaktString(builder.to_string())
                        span: call_span
                    )

                    yield StatementResult::JustValue(
                        Value(impl: ValueImpl::Void, span: call_span)
                    )
                }
                "to_string" => match this_argument!.impl {
                    Struct(fields) => StatementResult::JustValue(fields[0])
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::Unimplemented as! i32)
                    }
                }
                "is_empty" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_empty()), span: call_span))
                        else => {
                            panic("Invalid use of prelude StringBuilder")
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::Unimplemented as! i32)
                    }
                }
                "length" => match this_argument!.impl {
                    Struct(fields) => match fields[0].impl {
                        JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::USize(value.length()), span: call_span))
                        else => {
                            panic("Invalid use of prelude StringBuilder")
                        }
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::Unimplemented as! i32)
                    }
                }
                "clear" => match this_argument!.impl {
                    Struct(fields) => {
                        mut mutable_fields = fields
                        mutable_fields[0].impl = ValueImpl::JaktString(value: "")
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
                    }
                    else => {
                        .error(
                            format("Prelude function `StringBuilder::{}` expects a StringBuilder as its this argument", prelude_function),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::Unimplemented as! i32)
                    }
                }
                else => {
                    .error(
                        format("Prelude function `StringBuilder::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "Dictionary" => match prelude_function {
                "get" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }

                        yield StatementResult::JustValue(match found_index.has_value() {
                            true => Value(
                                impl: ValueImpl::OptionalSome(value: values[found_index!])
                                span: call_span
                            )
                            else => Value(
                                impl: ValueImpl::OptionalNone
                                span: call_span
                            )
                        })
                    }
                    else => {
                        panic("Invalid use of Dictionary::get()")
                    }
                }
                "set" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }

                        mut mutable_keys = keys
                        mut mutable_values = values

                        if found_index.has_value() {
                            mutable_values[found_index!] = arguments[1]
                        } else {
                            mutable_keys.push(arguments[0])
                            mutable_values.push(arguments[1])
                        }

                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::Void,
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::set()")
                    }
                }
                "is_empty" => match this_argument!.impl {
                    JaktDictionary(keys, values) => StatementResult::JustValue(Value(
                        impl: ValueImpl::Bool(keys.is_empty() and values.is_empty())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::is_empty()")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktDictionary(keys) => {
                        mut found = false
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }

                        yield StatementResult::JustValue(Value(
                                impl: ValueImpl::Bool(found)
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::contains()")
                    }
                }
                "remove" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut found_index: usize? = None
                        for i in 0..keys.size() {
                            if keys[i].impl.equals(arguments[0].impl) {
                                found_index = i
                                break
                            }
                        }
                        if found_index.has_value() {
                            mut keys_without: [Value] = []
                            mut values_without: [Value] = []

                            for i in 0..keys.size() {
                                if i == found_index! {
                                    continue
                                }
                                keys_without.push(keys[i])
                                values_without.push(values[i])
                            }

                            mut mutable_keys = keys
                            mut mutable_values = values
                            mutable_keys.shrink(0)
                            mutable_values.shrink(0)
                            for i in 0..keys_without.size() {
                                mutable_keys.push(keys_without[i])
                                mutable_values.push(values_without[i])
                            }
                        }

                        yield StatementResult::JustValue(Value(
                                impl: ValueImpl::Bool(found_index.has_value())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::remove()")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktDictionary(keys, values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_keys = keys
                            mut mutable_values = values
                            mutable_keys.ensure_capacity(capacity)
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Dictionary::ensure_capacity must be called with a usize", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid use of Dictionary::ensure_capacity()")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktDictionary(keys) => StatementResult::JustValue(Value(
                        impl: ValueImpl::USize(keys.capacity())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::capacity()")
                    }
                }
                "clear" => match this_argument!.impl {
                    JaktDictionary(keys, values) => {
                        mut mutable_keys = keys
                        mut mutable_values = values
                        mutable_keys.shrink(0)
                        mutable_values.shrink(0)
                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::Void
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::clear()")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktDictionary(keys) => StatementResult::JustValue(Value(
                        impl: ValueImpl::USize(keys.size())
                        span: call_span
                    ))
                    else => {
                        panic("Invalid use of Dictionary::size()")
                    }
                }
                "keys" => match this_argument!.impl {
                    JaktDictionary(keys, type_id) => {
                        let generics = match .program.get_type(type_id) {
                            GenericInstance(args) => args
                            else => {
                                panic("expected generic instance")
                            }
                        }
                        guard generics.size() == 2 else {
                            panic("dictionary should have 2 generic args. one for keys, one for values")
                        }
                        let array_struct_id = .program.find_struct_in_prelude("Array")
                        let type_id = .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [generics[0]]))
                        yield StatementResult::JustValue(Value(
                            impl: ValueImpl::JaktArray(values: keys, type_id)
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid use of Dictionary::keys()")
                    }
                }
                "iterator" => match this_argument!.impl {
                    JaktDictionary => {
                        let struct_id = .program.find_struct_in_prelude("DictionaryIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Dictionary::iterator()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Dictionary::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "Array" => match prelude_function {
                "iterator" => match this_argument!.impl {
                    JaktArray => {
                        let struct_id = .program.find_struct_in_prelude("ArrayIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::iterator()")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktArray(values) => {
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::USize(values.size())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::size()")
                    }
                }
                "push" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        mutable_values.push(arguments[0])
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void,
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "pop" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.pop()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            else => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "first" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.first()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            else => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "last" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut mutable_values = values
                        let value = mutable_values.last()
                        yield match value.has_value() {
                            true => StatementResult::JustValue(value!)
                            else => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                        }
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktArray(values) => {
                        mut found = false
                        for value in values.iterator() {
                            if value.impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Bool(found),
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::push()")
                    }
                }
                "is_empty" => match this_argument!.impl {
                    JaktArray(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::Bool(values.is_empty()),
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid use of Array::is_empty()")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktArray(values) => {
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::USize(values.capacity())
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Array::capacity()")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::ensure_capacity must be called with a usize", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid use of Array::ensure_capacity()")
                    }
                }
                "add_capacity" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.add_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::add_capacity must be called with a usize", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid use of Array::add_capacity()")
                    }
                }
                "shrink" => match this_argument!.impl {
                    JaktArray(values) => match arguments[0].impl {
                        USize(size) => {
                            mut mutable_values = values
                            mutable_values.shrink(size)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Array::shrink must be called with a usize", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid use of Array::shrink()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Array::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "ArrayIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid ArrayIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktArray(values) => match values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    yield Value(impl: ValueImpl::OptionalSome(value: values[index]), span: call_span)
                                }
                                else => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid ArrayIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid ArrayIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `ArrayIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            // Note: This does _not_ share the same layout in the rt, but we can just increment/decrement the start value.
            "Range" => match prelude_function {
                "next" => {
                    mut fields = match this_argument!.impl {
                        Struct(fields) => fields
                        else => {
                            panic("Invalid use of Range::next()")
                        }
                    }

                    let start = match fields[0].impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for comptime range")
                        }
                    }

                    let end = match fields[1].impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for comptime range")
                        }
                    }

                    if start == end {
                        return StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone, span: call_span))
                    }

                    if start > end {
                        fields[0] = Value(
                            impl: ValueImpl::U64(start - 1)
                            span: call_span
                        )
                    } else {
                        fields[0] = Value(
                            impl: ValueImpl::U64(start + 1)
                            span: call_span
                        )
                    }

                    yield StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::OptionalSome(value: Value(
                                impl: ValueImpl::U64(start)
                                span: call_span
                            )),
                            span: call_span
                        )
                    )
                }
                "inclusive" => match this_argument!.impl {
                    Struct(fields, struct_id, constructor) => {
                        mut mutable_fields = fields
                        let end = match fields[1].impl {
                            I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                            else => {
                                panic("Invalid type for comptime range")
                            }
                        }
                        mutable_fields[1].impl =  ValueImpl::U64(end + 1)
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Struct(fields, struct_id, constructor), span: this_argument!.span))
                    }
                    else => {
                        panic("Invalid use of Range::inclusive()")
                    }
                }
                "exclusive" => match this_argument!.impl {
                    Struct => StatementResult::JustValue(this_argument!)
                    else => {
                        panic("Invalid use of Range::exclusive()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Range::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "String" => match prelude_function {
                "is_empty" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_empty()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "length" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::USize(value.length()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "hash" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::U32(value.hash()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "substring" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        USize(start)
                        | U64(start)
                        | U32(start)
                        | U16(start)
                        | U8(start)
                        => match arguments[1].impl {
                            USize(length)
                            | U64(length)
                            | U32(length)
                            | U16(length)
                            | U8(length)
                            => {
                                let result = value.substring(start: start as! usize, length: length as! usize)
                                yield StatementResult::JustValue(Value(impl: ValueImpl::JaktString(result), span: call_span))
                            }
                            else => {
                                .error("String::substring must be called with unsigned arguments", arguments[1].span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            .error("String::substring must be called with unsigned arguments", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "number" => match arguments[0].impl {
                    I64(number)
                    | U32(number)
                    | I32(number)
                    | U16(number)
                    | I16(number)
                    | U8(number)
                    | I8(number)
                    => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(String::number(number as! i64)), span: call_span))
                    USize() | U64() => {
                        .error("String::number must not be called with a usize or u64", arguments[0].span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    else => {
                        .error("String::number must be called with an integer", arguments[0].span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                "to_uint" => match this_argument!.impl {
                    JaktString(value) => {
                        let result = value.to_uint()
                        yield StatementResult::JustValue(Value(
                            impl: match result.has_value() {
                                true => ValueImpl::OptionalSome(value: Value(impl: ValueImpl::U32(result!), span: call_span))
                                else => ValueImpl::OptionalNone()
                            }
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "to_int" => match this_argument!.impl {
                    JaktString(value) => {
                        let result = value.to_int()
                        yield StatementResult::JustValue(Value(
                            impl: match result.has_value() {
                                true => ValueImpl::OptionalSome(value: Value(impl: ValueImpl::I32(result!), span: call_span))
                                else => ValueImpl::OptionalNone()
                            }
                            span: call_span
                        ))
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "is_whitespace" => match this_argument!.impl {
                    JaktString(value) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.is_whitespace()), span: call_span))
                    else => {
                        panic("Invalid String")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.contains(arg)), span: call_span))
                        else => {
                            .error("String::contains must be called with a string", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "replace" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(replace) => match arguments[1].impl {
                            JaktString(with) => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(value.replace(replace, with)), span: call_span))
                            else => {
                                .error("String::replace must be called with strings", arguments[1].span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            .error("String::replace must be called with strings", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "byte_at" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        USize(index)
                        | U64(index)
                        | U32(index)
                        | U16(index)
                        | U8(index)
                        => StatementResult::JustValue(Value(impl: ValueImpl::U8(value.byte_at(index as! usize)), span: call_span))
                        else => {
                            .error("String::byte_at must be called with an unsigned integer", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "split" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        CChar(c) => {
                            let values = value.split(c)
                            mut result: [Value] = []
                            for value in values.iterator() {
                                result.push(Value(impl: ValueImpl::JaktString(value), span: call_span))
                            }
                            let array_struct_id = .program.find_struct_in_prelude("Array")
                            yield StatementResult::JustValue(Value(
                                impl: ValueImpl::JaktArray(
                                    values: result
                                    type_id: .find_or_add_type_id(Type::GenericInstance(id: array_struct_id, args: [builtin(BuiltinType::JaktString)]))
                                )
                                span: call_span
                            ))
                        }
                        else => {
                            .error("String::split must be called with a c_char", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "starts_with" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.starts_with(arg)), span: call_span))
                        else => {
                            .error("String::starts_with must be called with a string", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "ends_with" => match this_argument!.impl {
                    JaktString(value) => match arguments[0].impl {
                        JaktString(arg) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(value.ends_with(arg)), span: call_span))
                        else => {
                            .error("String::ends_with must be called with a string", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid String")
                    }
                }
                "repeated" => {
                    if arguments.size() != 2 {
                        .error("String::repeated must be called with a c_char and a usize", call_span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    let (character, count) = match arguments[0].impl {
                        CChar(arg) => match arguments[1].impl {
                            USize(c) => (arg, c)
                            else => {
                                .error("String::repeated must be called with a usize", arguments[1].span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        else => {
                            .error("String::repeated must be called with a c_char", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    yield StatementResult::JustValue(Value(impl: ValueImpl::JaktString(String::repeated(character, count)), span: call_span))
                }
                else => {
                    .error(
                        format("Prelude function `String::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "Set" => match prelude_function {
                "is_empty" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(values.is_empty()), span: call_span))
                    else => {
                        panic("Invalid Set")
                    }
                }
                "contains" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut found = false
                        for i in 0..values.size() {
                            if values[i].impl.equals(arguments[0].impl) {
                                found = true
                                break
                            }
                        }
                        yield StatementResult::JustValue(Value(impl: ValueImpl::Bool(found), span: call_span))
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "add" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut mutable_values = values
                        mutable_values.push(arguments[0])
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void,
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "remove" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut found = false
                        mut values_without: [Value] = []
                        for i in 0..values.size() {
                            if values[i].impl.equals(arguments[0].impl) {
                                found = true
                                continue
                            }
                            values_without.push(values[i])
                        }
                        mut mutable_values = values
                        mutable_values.shrink(0)
                        for i in 0..values_without.size() {
                            mutable_values.push(values_without[i])
                        }
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Bool(found),
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "clear" => match this_argument!.impl {
                    JaktSet(values) => {
                        mut mutable_values = values
                        mutable_values.shrink(0)
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Void
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "size" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(values.size())
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid Set")
                    }
                }
                "capacity" => match this_argument!.impl {
                    JaktSet(values) => StatementResult::JustValue(
                        Value(
                            impl: ValueImpl::USize(values.capacity())
                            span: call_span
                        )
                    )
                    else => {
                        panic("Invalid Set")
                    }
                }
                "ensure_capacity" => match this_argument!.impl {
                    JaktSet(values) => match arguments[0].impl {
                        USize(capacity) => {
                            mut mutable_values = values
                            mutable_values.ensure_capacity(capacity)
                            yield StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Void
                                    span: call_span
                                )
                            )
                        }
                        else => {
                            .error("Set::ensure_capacity must be called with a usize", arguments[0].span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        panic("Invalid Set")
                    }
                }
                "iterator" => match this_argument!.impl {
                    JaktSet => {
                        let struct_id = .program.find_struct_in_prelude("SetIterator")
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Struct(
                                    fields: [
                                        this_argument!
                                        Value(
                                            impl: ValueImpl::USize(0uz)
                                            span: call_span
                                        )
                                    ]
                                    struct_id
                                    constructor: None
                                )
                                span: call_span
                            )
                        )
                    }
                    else => {
                        panic("Invalid use of Set::iterator()")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Set::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "SetIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid SetIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktSet(values) => match values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    yield Value(impl: ValueImpl::OptionalSome(value: values[index]), span: call_span)
                                }
                                else => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid SetIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid SetIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `ArrayIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "DictionaryIterator" => match prelude_function {
                "next" => match this_argument!.impl {
                    Struct(fields) => {
                        let index = match fields[1].impl {
                            USize(value) => value
                            else => {
                                panic("Invalid DictionaryIterator index configuration")
                            }
                        }
                        mut mutable_fields = fields
                        yield StatementResult::JustValue(match fields[0].impl {
                            JaktDictionary(keys, values, type_id) => match keys.size() > index and values.size() > index {
                                true => {
                                    mutable_fields[1] = Value(
                                        impl: ValueImpl::USize(index + 1)
                                        span: call_span
                                    )
                                    let generics = match .program.get_type(type_id) {
                                        GenericInstance(args) => args
                                        else => {
                                            panic("expected generic instance")
                                        }
                                    }
                                    let tuple_struct_id = .program.find_struct_in_prelude("Tuple")
                                    let tuple_type_id = .find_or_add_type_id(Type::GenericInstance(id: tuple_struct_id, args: generics))

                                    yield Value(
                                        impl: ValueImpl::OptionalSome(
                                            value: Value(
                                                impl: ValueImpl::JaktTuple(
                                                    fields: [keys[index], values[index]]
                                                    type_id: tuple_type_id
                                                )
                                                span: call_span
                                            )
                                        )
                                        span: call_span
                                    )
                                }
                                else => Value(impl: ValueImpl::OptionalNone, span: call_span)
                            }
                            else => {
                                panic("Invalid DictionaryIterator configuration")
                            }
                        })
                    }
                    else => {
                        panic("Invalid DictionaryIterator configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `DictionaryIterator::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            "Optional" => match prelude_function {
                "has_value" => match this_argument!.impl {
                    OptionalSome => StatementResult::JustValue(Value(impl: ValueImpl::Bool(true), span: call_span))
                    OptionalNone => StatementResult::JustValue(Value(impl: ValueImpl::Bool(false), span: call_span))
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                "value" => match this_argument!.impl {
                    OptionalSome(value) => StatementResult::JustValue(value)
                    OptionalNone => {
                        .error(
                            format("Cannot unwrap optional none", prelude_function),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::UnwrapOptionalNone as! i32)
                    }
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                "value_or" => match this_argument!.impl {
                    OptionalSome(value) => StatementResult::JustValue(value)
                    OptionalNone => StatementResult::JustValue(arguments[0])
                    else => {
                        panic("Invalid Optional configuration")
                    }
                }
                else => {
                    .error(
                        format("Prelude function `Optional::{}` is not implemented", prelude_function),
                        call_span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            else => {
                .error(
                    format("Prelude function `{}::{}` is not implemented", namespace_[0].name, prelude_function),
                    call_span
                )
                throw Error::from_errno(InterpretError::Unimplemented as! i32)
            }
        }
    }

    public function execute(mut this, anon function_to_run_id: FunctionId, mut namespace_: [ResolvedNamespace]?, this_argument: Value?, arguments: [Value], call_span: Span, invocation_scope: InterpreterScope? = None) throws -> ExecutionResult {
        let function_to_run = .program.get_function(function_to_run_id)
        .enter_span(call_span)
        let old_function_id = .current_function_id
        .current_function_id = function_to_run_id

        defer {
            .current_function_id = old_function_id
            .leave_span()
        }

        mut is_prelude_function = false

        if function_to_run.linkage is External {
            // If this is a prelude function, run it manually
            let function_scope = .program.get_scope(function_to_run.function_scope_id)
            
            if not .get_prelude_function(function_to_run.function_scope_id) {
                .error(
                    format("Cannot call external function '{}'", function_to_run.name)
                    call_span
                )
                throw Error::from_errno(InterpretError::CallToExternalFunction as! i32)
            }

            is_prelude_function = true
        }

        if function_to_run.is_static() == this_argument.has_value() {
            mut expected = "did not expect"
            if not function_to_run.is_static() {
                expected = "expected"
            }

            mut not_provided = " not"
            if this_argument.has_value() {
                not_provided = ""
            }

            .compiler.errors.push(JaktError::Message(
                message: format("function call {} a this argument, yet one was{} provided", expected, not_provided),
                span: function_to_run.name_span
            ));
            throw Error::from_errno(InterpretError::InvalidThisArgument as! i32)
        }

        mut this_offset = 0uz
        if this_argument.has_value() {
            this_offset = 1
        }

        if function_to_run.params.size() - this_offset != arguments.size() {
            .compiler.errors.push(JaktError::Message(
                message: format("Function called with wrong number of arguments, expected {} but got {}", function_to_run.params.size(), arguments.size()),
                span: call_span
            ));
            throw Error::from_errno(InterpretError::MismatchingArguments as! i32)
        }

        if is_prelude_function {
            if this_argument.has_value() and (not namespace_.has_value() or namespace_!.is_empty()) {
                mut effective_namespace: [ResolvedNamespace] = []
                match this_argument!.impl {
                    JaktString => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(ResolvedNamespace(name: "String", generic_parameters))
                    }
                    JaktArray(type_id) => {
                        let generic_parameters = match .program.get_type(id: type_id) {
                            GenericInstance(args) => args
                            else => {
                                .error("Attempted to call a prelude function on a non-generic array", call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Array", generic_parameters))
                    }
                    JaktDictionary(type_id) => {
                        let generic_parameters = match .program.get_type(id: type_id) {
                            GenericInstance(args) => args
                            else => {
                                .error("Attempted to call a prelude function on a non-generic dictionary", call_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Dictionary", generic_parameters))
                    }
                    JaktSet(type_id) => {
                        guard .program.get_type(id: type_id) is GenericInstance(args: generic_parameters) else {
                            .error("Attempted to call a prelude function on a non-generic set", call_span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                        effective_namespace.push(ResolvedNamespace(name: "Set", generic_parameters))
                    }
                    Struct(struct_id) | Class(struct_id) => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(
                            ResolvedNamespace(name: .program.get_struct(struct_id).name, generic_parameters))
                    }
                    Enum(enum_id) => {
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(
                            ResolvedNamespace(name: .program.get_enum(enum_id).name, generic_parameters))
                    }
                    OptionalNone | OptionalSome => {
                        // FIXME: We should have these at this point.
                        let generic_parameters: [TypeId] = []
                        effective_namespace.push(ResolvedNamespace(name: "Optional", generic_parameters))
                    }
                    else => {
                        .error("Attempted to call an instance method on a non-struct/enum type", call_span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }

                namespace_ = effective_namespace
            }

            mut type_bindings: [String:TypeId] = [:]
            if invocation_scope.has_value() {
                type_bindings = invocation_scope!.type_bindings
            }
            return match .call_prelude_function(
                function_to_run.name,
                namespace_!,
                this_argument,
                arguments,
                call_span,
                type_bindings
            ) {
                JustValue(value) | Return(value) => ExecutionResult::Return(value)
                Throw(value) => ExecutionResult::Throw(value)
                Continue | Break | Yield => {
                    panic("Invalid control flow")
                }
            }
        }

        match function_to_run.type {
            Normal => {
                mut scope = InterpreterScope::create(parent: invocation_scope)
                defer {
                    scope.perform_defers(interpreter: this, span: call_span)
                }
                
                for i in 0..function_to_run.params.size() {
                    if this_offset != 0 and i == 0 {
                        continue
                    }
                    let param_name = function_to_run.params[i].variable.name
                    let param_value = arguments[i - this_offset]
                    scope.bindings[param_name] = param_value
                }

                if this_argument.has_value() {
                    scope.bindings.set("this", this_argument!)
                }

                return match .execute_block(block: function_to_run.block, scope, call_span) {
                    Return(value) | JustValue(value) => ExecutionResult::Return(cast_value_to_type(value, function_to_run.return_type_id, interpreter: this))
                    Throw(value) => ExecutionResult::Throw(value)
                    Continue | Break | Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            ImplicitConstructor => {
                let result_type = .program.get_type(function_to_run.return_type_id)
                match result_type {
                    Struct(struct_id) | GenericInstance(id: struct_id) => {
                        let struct_ = .program.get_struct(struct_id)
                        let constructor = function_to_run_id
                        let impl = match struct_.record_type {
                            Struct => ValueImpl::Struct(
                                fields: arguments
                                struct_id
                                constructor
                            )
                            Class => ValueImpl::Class(
                                fields: arguments
                                struct_id
                                constructor
                            )
                            else => {
                                .error(
                                    format("Cannot create instance of non-struct type {}", struct_.name),
                                    call_span
                                )
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                        return ExecutionResult::Return(Value(
                            impl
                            span: call_span
                        )) 
                    }
                    else => {
                        .error(
                            format("Implicit constructor can only return a struct or a generic instance"),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
            }
            ImplicitEnumConstructor => {
                let result_type = .program.get_type(function_to_run.return_type_id)
                match result_type {
                    Enum(enum_id) | GenericEnumInstance(id: enum_id) => {
                        let enum_ = .program.get_enum(enum_id)
                        let constructor = function_to_run_id
                        let impl = ValueImpl::Enum(
                            fields: arguments
                            enum_id
                            constructor
                        )
                        return ExecutionResult::Return(Value(
                            impl
                            span: call_span
                        )) 
                    }
                    else => {
                        .error(
                            format("Implicit enum constructor can only return an enum or a generic instance of one"),
                            call_span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
            }
            else => {}
        }

        .error(
            format("Function type {} is not implemented", function_to_run.type),
            call_span
        )
        throw Error::from_errno(InterpretError::Unimplemented as! i32)
    }

    public function execute_statement(mut this, statement: CheckedStatement, mut scope: InterpreterScope, call_span: Span) throws -> StatementResult {
        match statement {
            Expression(expr) => {
                return .execute_expression(expr, scope)
            }
            Defer(statement) => {
                scope.defer_statement(statement)
            }
            DestructuringAssignment(vars, var_decl) => {
                guard var_decl is VarDecl(var_id, init) else {
                    panic("expected vardecl")
                }
                match .execute_expression(init, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(var_value) => {
                        scope.bindings[.program.get_variable(id: var_id).name] = var_value
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }

                for var in vars.iterator() {
                    guard var is VarDecl(var_id, init) else {
                        panic("expected vardecl")
                    }
                    match .execute_expression(init, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(var_value) => {
                            scope.bindings[.program.get_variable(id: var_id).name] = var_value
                        }
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            VarDecl(var_id, init, span) => {
                match .execute_expression(init, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(var_value) => {
                        scope.bindings[.program.get_variable(id: var_id).name] = var_value
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }
            }
            If(condition, then_block, else_statement, span) => {
                let cond = match .execute_expression(expr: condition, scope) {
                    JustValue(value) => match value.impl {
                        Bool(x) => x
                        else => {
                            .error(
                                format("if condition must be a boolean, but got {}", value.impl),
                                span
                            )
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield => {
                        panic("Invalid control flow")
                    }
                }

                let block = match cond {
                    true => Some(then_block)
                    else => match else_statement.has_value() {
                        true => Some(CheckedBlock(
                            statements: [else_statement!]
                            scope_id: then_block.scope_id
                            control_flow: BlockControlFlow::MayReturn
                            yielded_type: None
                            yielded_none: false
                        ))
                        else => None
                    }
                }

                if block.has_value() {
                    return match .execute_block(block: block!, scope, call_span: span) {
                        Return(value) => StatementResult::Return(value)
                        Throw(value) => StatementResult::Throw(value)
                        JustValue => StatementResult::JustValue(Value(impl: ValueImpl::Void, span))
                        Continue => StatementResult::Continue
                        Break => StatementResult::Break
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            Block(block, span) => {
                mut new_scope = InterpreterScope::create(parent: scope)
                defer new_scope.perform_defers(interpreter: this, span)

                return .execute_block(block, scope: new_scope, call_span: span)
            }
            Loop(block, span) => {
                loop {
                    match .execute_block(block, scope, call_span: span) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            continue
                        }
                        Break => {
                            break
                        }
                        JustValue => {}
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            While(condition, block, span) => {
                loop {
                    match .execute_expression(condition, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        JustValue(x) => {
                            if x.impl is Bool(cond) and not cond {
                                break
                            }
                        }
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                    match .execute_block(block, scope, call_span: span) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        Continue => {
                            continue
                        }
                        Break => {
                            break
                        }
                        JustValue => {}
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
            }
            Return(val) => {
                if val.has_value() {
                    return match .execute_expression(val!, scope) {
                        Return(value) => StatementResult::Return(value)
                        Throw(value) => StatementResult::Throw(value)
                        JustValue(value) => StatementResult::Return(value)
                        Continue => StatementResult::Continue
                        Break => StatementResult::Break
                        Yield => {
                            panic("Invalid control flow")
                        }
                    }
                }
                return StatementResult::Return(Value(impl: ValueImpl::Void, span: call_span))
            }
            Break => {
                return StatementResult::Break
            }
            Continue => {
                return StatementResult::Continue
            }
            Yield(expr) => match .execute_expression(expr, scope) {
                JustValue(value) => {
                    return StatementResult::Yield(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            Throw(expr) => match .execute_expression(expr, scope) {
                Return(value) | JustValue(value) | Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            InlineCpp(span) => .error("Cannot run inline cpp at compile time", span)
            Garbage(span) => .error("Cannot run invalid statements at compile time", span)
        }

        return StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
    }

    public function execute_block(mut this, block: CheckedBlock, mut scope: InterpreterScope, call_span: Span) throws -> StatementResult {
        for statement in block.statements.iterator() {
            .enter_span(statement.span() ?? call_span)
            defer .leave_span()
            match .execute_statement(statement, scope, call_span) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                JustValue => {}
                Yield(value) => {
                    return StatementResult::Yield(value)
                }
            }
        }

        return StatementResult::JustValue(Value(impl: ValueImpl::Void, span: call_span))
    }

    public function error(mut this, anon message: String, anon span: Span) throws -> void {
        .compiler.errors.push(JaktError::Message(
            message: message,
            span: span
        ))

        // FIXME: This shouldn't be necessary
        .compiler.print_errors()
    }

    public function error_with_hint(mut this, anon message: String, anon span: Span, anon hint_message: String, anon hint_span: Span) throws -> void {
        .compiler.errors.push(JaktError::MessageWithHint(
            message,
            span,
            hint: hint_message,
            hint_span,
        ))

        // FIXME: This shouldn't be necessary
        .compiler.print_errors()
    }

    public function execute_binary_operator(mut this, anon lhs_value: Value, anon rhs_value: Value, anon op: BinaryOperator, anon span: Span, anon scope: InterpreterScope) throws -> StatementResult => match op {
        Add => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::JaktString(x + y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        Subtract => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x - y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        Multiply => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x * y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        Divide => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::F32(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::F64(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x / y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        Equal => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    CInt(x) => match rhs_value.impl {
                        CInt(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    CChar(x) => match rhs_value.impl {
                        CChar(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x == y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        NotEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    CInt(x) => match rhs_value.impl {
                        CInt(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    CChar(x) => match rhs_value.impl {
                        CChar(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x != y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        LessThan => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x < y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        LessThanOrEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x <= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        GreaterThan => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x > y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        GreaterThanOrEqual => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F32(x) => match rhs_value.impl {
                        F32(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    F64(x) => match rhs_value.impl {
                        F64(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    JaktString(x) => match rhs_value.impl {
                        JaktString(y) => ValueImpl::Bool(x >= y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        BitwiseAnd => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x & y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x & y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x & y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x & y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x & y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        BitwiseOr => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x | y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x | y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x | y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x | y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x | y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        BitwiseXor => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x ^ y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x ^ y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x ^ y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x ^ y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x ^ y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        BitwiseLeftShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x << y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x << y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x << y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x << y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x << y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        BitwiseRightShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x >> y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x >> y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x >> y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x >> y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x >> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        ArithmeticLeftShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8((x <<< y) as! u8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16((x <<< y) as! u16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8((x <<< y) as! i8)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16((x <<< y) as! i16)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x <<< y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        ArithmeticRightShift => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    U8(x) => match rhs_value.impl {
                        U8(y) => ValueImpl::U8(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U16(x) => match rhs_value.impl {
                        U16(y) => ValueImpl::U16(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U32(x) => match rhs_value.impl {
                        U32(y) => ValueImpl::U32(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    U64(x) => match rhs_value.impl {
                        U64(y) => ValueImpl::U64(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I8(x) => match rhs_value.impl {
                        I8(y) => ValueImpl::I8(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I16(x) => match rhs_value.impl {
                        I16(y) => ValueImpl::I16(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I32(x) => match rhs_value.impl {
                        I32(y) => ValueImpl::I32(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    I64(x) => match rhs_value.impl {
                        I64(y) => ValueImpl::I64(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    USize(x) => match rhs_value.impl {
                        USize(y) => ValueImpl::USize(x >>> y)
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        LogicalOr => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    Bool(x) => match rhs_value.impl {
                        Bool(y) => ValueImpl::Bool(x or y),
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        LogicalAnd => StatementResult::JustValue(
            Value(
                impl: match lhs_value.impl {
                    Bool(x) => match rhs_value.impl {
                        Bool(y) => ValueImpl::Bool(x and y),
                        else => {
                            .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    else => {
                        .error(format("Invalid operands '{}' and '{}' to binary operation", lhs_value.type_name(), rhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                span
            )
        )
        Assign => StatementResult::JustValue(rhs_value)
        BitwiseAndAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseAnd, span, scope)
        BitwiseOrAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseOr, span, scope)
        BitwiseXorAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseXor, span, scope)
        BitwiseLeftShiftAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseLeftShift, span, scope)
        BitwiseRightShiftAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::BitwiseRightShift, span, scope)
        AddAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Add, span, scope)
        SubtractAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Subtract, span, scope)
        MultiplyAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Multiply, span, scope)
        ModuloAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Modulo, span, scope)
        DivideAssign => .execute_binary_operator(lhs_value, rhs_value, BinaryOperator::Divide, span, scope)
        else => {
            .error(
                format("Unimplemented binary operator '{}'", op),
                span
            )
            throw Error::from_errno(InterpretError::Unimplemented as! i32)
        }
    }

    public function update_binding(mut this, anon binding: CheckedExpression, mut scope: InterpreterScope, anon value: Value, span: Span) throws {
        match binding {
            Var(var) => {
                scope.set(var.name, value)
            }
            IndexedStruct(expr, index) => {
                // FIXME: This should not be evaluated twice.
                mut (fields, struct_id) = match .execute_expression(expr, scope) {
                    JustValue(value) => match value.impl {
                        Class(fields, struct_id) | Struct(fields, struct_id) => (fields, struct_id)
                        else => {
                            panic("Invalid left-hand side in assignment")
                        }
                    }
                    else => {
                        panic("Should not be happening here")
                    }
                }

                let field_decls = .program.get_struct(struct_id).fields
                mut field_index = 0uz
                for i in 0..field_decls.size() {
                    if .program.get_variable(field_decls[i].variable_id).name == index {
                        field_index = i
                        break
                    }
                }

                fields[field_index] = value
            }
            IndexedCommonEnumMember(expr, index) => {
                // FIXME: This should not be evaluated twice.
                mut (fields, enum_id) = match .execute_expression(expr, scope) {
                    JustValue(value) => match value.impl {
                        Enum(fields, enum_id) => (fields, enum_id)
                        else => {
                            panic("Invalid left-hand side in assignment")
                        }
                    }
                    else => {
                        panic("Should not be happening here")
                    }
                }

                let field_decls = .program.get_enum(enum_id).fields
                mut field_index = 0uz
                for i in 0..field_decls.size() {
                    if .program.get_variable(field_decls[i].variable_id).name == index {
                        field_index = i
                        break
                    }
                }

                fields[field_index] = value
            }
            else => {
                .error(
                    format("Invalid left-hand side of assignment {}", binding),
                    span
                )
                throw Error::from_errno(InterpretError::InvalidType as! i32)
            }
        }
    }

    public function execute_expression(mut this, anon expr: CheckedExpression, anon mut scope: InterpreterScope) throws -> StatementResult => match .current_function_id.has_value() { 
        false => .execute_expression_without_cast(expr, scope)
        else => match .execute_expression_without_cast(expr, scope) {
            Return(value) => StatementResult::Return(cast_value_to_type(value, .program.get_function(.current_function_id!).return_type_id, interpreter: this))
            JustValue(value) => StatementResult::JustValue(cast_value_to_type(value, expr.type(), interpreter: this))
            Throw(value) => StatementResult::Throw(value)
            Yield(value) => StatementResult::Yield(value)
            Break => StatementResult::Break
            Continue => StatementResult::Continue
        }
    }

    public function execute_expression_without_cast(mut this, anon expr: CheckedExpression, anon mut scope: InterpreterScope) throws -> StatementResult => match expr {
        BinaryOp(lhs, op, rhs, span) => {
            let lhs_value = match .execute_expression(lhs, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            let value = match op {
                NoneCoalescing | NoneCoalescingAssign => StatementResult::JustValue(match lhs_value.impl {
                    OptionalNone => match .execute_expression(rhs, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }
                    OptionalSome(value) => value
                    else => {
                        panic("Invalid left-hand side of NoneCoalescing")
                    }
                })
                LogicalAnd | LogicalOr => StatementResult::JustValue(match lhs_value.impl {
                    Bool(x) => match x {
                        (op is LogicalAnd) => match .execute_expression(rhs, scope) {
                            Return(value) => {
                                return StatementResult::Return(value)
                            }
                            Throw(value) => {
                                return StatementResult::Throw(value)
                            }
                            JustValue(value) => value
                            Continue => {
                                return StatementResult::Continue
                            }
                            Break => {
                                return StatementResult::Break
                            }
                            Yield(expr) => {
                                panic("Invalid control flow")
                            }
                        }.cast(lhs_value, span)
                        else => lhs_value
                    }
                    else => {
                        .error(format("Invalid operand '{}' to binary operation", lhs_value.type_name()), span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                })
                else => {
                    let rhs_value = match .execute_expression(rhs, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }.cast(lhs_value, span)
                    yield .execute_binary_operator(lhs_value, rhs_value, op, span, scope)
                }
            }

            match value {
                JustValue(value) => match op {
                    Assign
                    | BitwiseAndAssign
                    | BitwiseOrAssign
                    | BitwiseXorAssign
                    | BitwiseLeftShiftAssign
                    | BitwiseRightShiftAssign
                    | AddAssign
                    | SubtractAssign
                    | MultiplyAssign
                    | ModuloAssign
                    | DivideAssign
                    | NoneCoalescingAssign => {
                        .update_binding(lhs, scope, value, span)
                    }
                    else => {}
                }
                else => {}
            }

            yield value
        }
        UnaryOp(expr, op, span) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            yield match op {
                LogicalNot => match value.impl {
                    Bool(value) => StatementResult::JustValue(Value(
                        impl: ValueImpl::Bool(not value)
                        span
                    ))
                    else => {
                        .error(
                            format("Invalid type for unary operator"),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                PostIncrement => StatementResult::JustValue(match value.impl {
                    U8(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U8(x + 1), span), span)
                        yield value
                    }
                    I8(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I8(x + 1), span), span)
                        yield value
                    }
                    U16(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U16(x + 1), span), span)
                        yield value
                    }
                    I16(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I16(x + 1), span), span)
                        yield value
                    }
                    U32(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U32(x + 1), span), span)
                        yield value
                    }
                    I32(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I32(x + 1), span), span)
                        yield value
                    }
                    U64(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U64(x + 1), span), span)
                        yield value
                    }
                    I64(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I64(x + 1), span), span)
                        yield value
                    }
                    CChar(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::CChar(x + 1), span), span)
                        yield value
                    }
                    CInt(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::CInt(x + 1), span), span)
                        yield value
                    }
                    USize(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::USize(x + 1), span), span)
                        yield value
                    }
                    else => {
                        .error(
                            format("Invalid type for unary operator"),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                })
                PreIncrement => StatementResult::JustValue(match value.impl {
                    U8(x) => {
                        let value = Value(impl: ValueImpl::U8(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I8(x) => {
                        let value = Value(impl: ValueImpl::I8(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U16(x) => {
                        let value = Value(impl: ValueImpl::U16(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I16(x) => {
                        let value = Value(impl: ValueImpl::I16(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U32(x) => {
                        let value = Value(impl: ValueImpl::U32(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I32(x) => {
                        let value = Value(impl: ValueImpl::I32(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U64(x) => {
                        let value = Value(impl: ValueImpl::U64(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I64(x) => {
                        let value = Value(impl: ValueImpl::I64(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    CChar(x) => {
                        let value = Value(impl: ValueImpl::CChar(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    CInt(x) => {
                        let value = Value(impl: ValueImpl::CInt(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    USize(x) => {
                        let value = Value(impl: ValueImpl::USize(x + 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    else => {
                        .error(
                            format("Invalid type for unary operator"),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                })
                PostDecrement => StatementResult::JustValue(match value.impl {
                    U8(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U8(x - 1), span), span)
                        yield value
                    }
                    I8(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I8(x - 1), span), span)
                        yield value
                    }
                    U16(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U16(x - 1), span), span)
                        yield value
                    }
                    I16(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I16(x - 1), span), span)
                        yield value
                    }
                    U32(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U32(x - 1), span), span)
                        yield value
                    }
                    I32(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I32(x - 1), span), span)
                        yield value
                    }
                    U64(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::U64(x - 1), span), span)
                        yield value
                    }
                    I64(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::I64(x - 1), span), span)
                        yield value
                    }
                    CChar(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::CChar(x - 1), span), span)
                        yield value
                    }
                    CInt(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::CInt(x - 1), span), span)
                        yield value
                    }
                    USize(x) => {
                        .update_binding(expr, scope, Value(impl: ValueImpl::USize(x - 1), span), span)
                        yield value
                    }
                    else => {
                        .error(
                            format("Invalid type for unary operator"),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                })
                PreDecrement => StatementResult::JustValue(match value.impl {
                    U8(x) => {
                        let value = Value(impl: ValueImpl::U8(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I8(x) => {
                        let value = Value(impl: ValueImpl::I8(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U16(x) => {
                        let value = Value(impl: ValueImpl::U16(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I16(x) => {
                        let value = Value(impl: ValueImpl::I16(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U32(x) => {
                        let value = Value(impl: ValueImpl::U32(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I32(x) => {
                        let value = Value(impl: ValueImpl::I32(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    U64(x) => {
                        let value = Value(impl: ValueImpl::U64(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    I64(x) => {
                        let value = Value(impl: ValueImpl::I64(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    CChar(x) => {
                        let value = Value(impl: ValueImpl::CChar(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    CInt(x) => {
                        let value = Value(impl: ValueImpl::CInt(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    USize(x) => {
                        let value = Value(impl: ValueImpl::USize(x - 1), span)
                        .update_binding(expr, scope, value, span)
                        yield value
                    }
                    else => {
                        .error(
                            format("Invalid type for unary operator"),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                })
                TypeCast(cast) => match cast {
                    Infallible(type_id) => StatementResult::JustValue(cast_value_to_type(value, type_id, interpreter: this))
                    Fallible(type_id) => {
                        // FIXME: Actually implement this :)
                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::OptionalSome(value: cast_value_to_type(value, type_id, interpreter: this))
                                span
                            )
                        )

                    }
                }
                IsEnumVariant(enum_variant, bindings) => match value.impl {
                    Enum(fields, constructor) => {
                        let constructor_name = .program.get_function(constructor).name
                        if enum_variant.name() != constructor_name {
                            return StatementResult::JustValue(
                                Value(
                                    impl: ValueImpl::Bool(false)
                                    span
                                )
                            )
                        }

                        // FIXME: Bindings
                        // match enum_variant {
                        //     Typed => {
                        //     }
                        //     Untyped
                        //     StructLike
                        //     WithValue => {
                        //         .error(
                        //             format("Unimplemented value enum for unary operator '{}'", op),
                        //             span
                        //         )
                        //         throw Error::from_errno(InterpretError::Unimplemented as! i32)
                        //     }
                        // }

                        yield StatementResult::JustValue(
                            Value(
                                impl: ValueImpl::Bool(true)
                                span
                            )
                        )
                    }
                    else => {
                        .error(
                            format("Invalid value for unary operator '{}'", op),
                            span
                        )
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                }
                else => {
                    .error(
                        format("Unimplemented unary operator '{}'", op),
                        span
                    )
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
        }
        Range(from, to, span) => {
            let start = match from.has_value() {
                true => match .execute_expression(expr: from!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                else => {
                    .error("Partial ranges are not implemented", span)
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }
            let end = match to.has_value() {
                true => match .execute_expression(expr: to!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                else => {
                    .error("Partial ranges are not implemented", span)
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }
            }

            let range_struct_id = .program.find_struct_in_prelude("Range")
            let range_constructor = .program.find_function_in_scope(
                parent_scope_id: .program.get_struct(range_struct_id).scope_id,
                function_name: "Range")!

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Struct(
                    fields: [start, end]
                    struct_id: range_struct_id
                    constructor: range_constructor
                )
                span
            ))
        }
        Call(call, span) => {
            if not call.function_id.has_value() {
                mut arguments: [Value] = []
                for arg in call.args.iterator() {
                    arguments.push(match .execute_expression(arg.1, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    })
                }

                return .call_prelude_function(
                    prelude_function: call.name
                    namespace_: []
                    this_argument: None
                    arguments
                    call_span: span
                    type_bindings: [:]
                )
            }

            let function_to_run = .program.get_function(id: call.function_id!)
            if function_to_run.type is Closure {
                .error(
                    format("Cannot call a closure (nyi)"),
                    span
                )
                throw Error::from_errno(InterpretError::Unimplemented as! i32)
            }
            mut this_argument: Value? = None
            mut arguments: [Value] = []
            for arg in call.args.iterator() {
                arguments.push(match .execute_expression(arg.1, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                })
            }

            mut type_bindings: [String:TypeId] = [:]
            for i in 0..function_to_run.generics.params.size() {
                let param = function_to_run.generics.params[i]

                type_bindings.set(
                    param.type_id().to_string()
                    call.type_args[i]
                )
            }

            let empty_bindings: [String:Value] = [:]
            yield match .execute(
                call.function_id!
                namespace_: Some(call.namespace_)
                this_argument
                arguments
                call_span: span
                invocation_scope: InterpreterScope::create(
                    type_bindings
                )
            ) {
                Return(value) => StatementResult::JustValue(value)
                Throw(value) => StatementResult::Throw(value)
            }
        }
        MethodCall(expr, call, span) => {
            let this_argument = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            mut effective_namespace: [ResolvedNamespace] = []
            match this_argument.impl {
                JaktString => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(ResolvedNamespace(name: "String", generic_parameters))
                }
                JaktArray(type_id) => {
                    let generic_parameters = match .program.get_type(id: type_id) {
                        GenericInstance(args) => args
                        else => {
                            .error("Attempted to call a prelude function on a non-generic array", this_argument.span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Array", generic_parameters))
                }
                JaktDictionary(type_id) => {
                    let generic_parameters = match .program.get_type(id: type_id) {
                        GenericInstance(args) => args
                        else => {
                            .error("Attempted to call a prelude function on a non-generic dictionary", this_argument.span)
                            throw Error::from_errno(InterpretError::InvalidType as! i32)
                        }
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Dictionary", generic_parameters))
                }
                JaktSet(type_id) => {
                    guard .program.get_type(id: type_id) is GenericInstance(args: generic_parameters) else {
                        .error("Attempted to call a prelude function on a non-generic set", this_argument.span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }
                    effective_namespace.push(ResolvedNamespace(name: "Set", generic_parameters))
                }
                Struct(struct_id) | Class(struct_id) => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(
                        ResolvedNamespace(name: .program.get_struct(struct_id).name, generic_parameters))
                }
                Enum(enum_id) => {
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(
                        ResolvedNamespace(name: .program.get_enum(enum_id).name, generic_parameters))
                }
                OptionalNone | OptionalSome => {
                    // FIXME: We should have these at this point.
                    let generic_parameters: [TypeId] = []
                    effective_namespace.push(ResolvedNamespace(name: "Optional", generic_parameters))
                }
                else => {
                    .error("Attempted to call an instance method on a non-struct/enum type", this_argument.span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }

            if not call.function_id.has_value() {
                mut arguments: [Value] = []
                for arg in call.args.iterator() {
                    arguments.push(match .execute_expression(arg.1, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    })
                }

                return .call_prelude_function(
                    prelude_function: call.name
                    namespace_: effective_namespace
                    this_argument
                    arguments
                    call_span: span
                    type_bindings: [:]
                )
            }

            let function_to_run = .program.get_function(id: call.function_id!)
            mut arguments: [Value] = []
            for arg in call.args.iterator() {
                arguments.push(match .execute_expression(arg.1, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                })
            }

            yield match .execute(call.function_id!, namespace_: Some(call.namespace_), this_argument, arguments, call_span: span) {
                Return(value) => StatementResult::JustValue(value)
                Throw(value) => StatementResult::Throw(value)
            }
        }
        OptionalNone(span) => StatementResult::JustValue(Value(impl: ValueImpl::OptionalNone(), span))
        OptionalSome(expr, span) => {
            let result = .execute_expression(expr, scope)
            if result is JustValue(value) {
                return StatementResult::JustValue(Value(impl: ValueImpl::OptionalSome(value), span))
            }
            return result
        }
        ForcedUnwrap(expr) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            if value.impl is OptionalNone {
                .error("Attempted to unwrap an optional value that was None", value.span)
                throw Error::from_errno(InterpretError::InvalidType as! i32)
            }

            yield match value.impl {
                OptionalSome(value) => StatementResult::JustValue(value)
                else => {
                    .error("Invalid type for unwrap", value.span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }
        }
        Block(block, span) => .execute_block(block, scope, call_span: span)
        ByteConstant(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::U8(val.byte_at(0)), span: span))
        // IndexedDictionary
        Var(var) => StatementResult::JustValue(scope.must_get(var.name))
        // Garbage
        IndexedExpression(expr, index: index_expr, span) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            let index = match .execute_expression(index_expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }

            yield match value.impl {
                JaktArray(values) => {
                    let numeric_index = match index.impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! u64
                        else => {
                            panic("Invalid type for repeat")
                        }
                    }

                    if numeric_index >= (values.size() as! u64) {
                        .error(
                            format("Index {} out of bounds (max={})", numeric_index, values.size())
                            span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }

                    yield StatementResult::JustValue(values[numeric_index])
                }
                else => {
                    .error("Invalid or unsupported indexed expression", span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }
        }
        Boolean(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::Bool(val), span: span))
        IndexedStruct(expr, index) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Struct(fields, struct_id)
                | Class(fields, struct_id) => {
                    let struct_ = .program.get_struct(struct_id)
                    mut idx = 0
                    mut found_index: i64? = None
                    for field in struct_.fields.iterator() {
                        if .program.get_variable(field.variable_id).name == index {
                            found_index = idx
                            break
                        }
                        idx += 1
                    }
                    if not found_index.has_value() {
                        .error("Attempted to access a field that does not exist", value.span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }

                    yield StatementResult::JustValue(fields[found_index!])
                }
                else => {
                    .error("Attempted to access a field on a non-struct/enum type", value.span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }
        }
        IndexedCommonEnumMember(expr, index) => {
            let value = match .execute_expression(expr, scope) {
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                JustValue(value) => value
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield(expr) => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields, enum_id) => {
                    let enum_ = .program.get_enum(enum_id)
                    mut idx = 0
                    mut found_index: i64? = None
                    for field in enum_.fields.iterator() {
                        if .program.get_variable(field.variable_id).name == index {
                            found_index = idx
                            break
                        }
                        idx += 1
                    }
                    if not found_index.has_value() {
                        .error("Attempted to access a field that does not exist", value.span)
                        throw Error::from_errno(InterpretError::InvalidType as! i32)
                    }

                    yield StatementResult::JustValue(fields[found_index!])
                }
                else => {
                    .error("Attempted to access a field on a non-struct/enum type", value.span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }
        }
        JaktDictionary(vals, span, type_id) => {
            mut keys: [Value] = []
            mut values: [Value] = []
            for (k, v) in vals.iterator() {
                let key = match .execute_expression(k, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                let val = match .execute_expression(v, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }

                keys.push(key)
                values.push(val)
            }

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::JaktDictionary(
                    keys
                    values
                    type_id
                )
                span: span
            ))
        }
        // NamespacedVar
        NumericConstant(val, span) => StatementResult::JustValue(match val {
            I8(x) => Value(impl: ValueImpl::I8(x), span: span)
            I16(x) => Value(impl: ValueImpl::I16(x), span: span)
            I32(x) => Value(impl: ValueImpl::I32(x), span: span)
            I64(x) => Value(impl: ValueImpl::I64(x), span: span)
            U8(x) => Value(impl: ValueImpl::U8(x), span: span)
            U16(x) => Value(impl: ValueImpl::U16(x), span: span)
            U32(x) => Value(impl: ValueImpl::U32(x), span: span)
            U64(x) => Value(impl: ValueImpl::U64(x), span: span)
            USize(x) => Value(impl: ValueImpl::USize(x as! usize), span: span)
            F32(x) => Value(impl: ValueImpl::F32(x), span: span)
            F64(x) => Value(impl: ValueImpl::F64(x), span: span)
        })
        QuotedString(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::JaktString(interpret_escapes(val)), span: span))
        CharacterConstant(val, span) => StatementResult::JustValue(Value(impl: ValueImpl::CChar(val.byte_at(0) as! c_char), span: span))
        JaktArray(vals, repeat, span, type_id) => match repeat.has_value() {
            true => {
                let count = match .execute_expression(repeat!, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => match value.impl {
                        I8(x) | I16(x) | I32(x) | I64(x) | U8(x) | U16(x) | U32(x) | U64(x) | USize(x) => x as! usize
                        else => {
                            panic("Invalid type for repeat")
                        }
                    }
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                let value_to_repeat = match .execute_expression(vals[0], scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }
                yield StatementResult::JustValue(Value(
                    impl: ValueImpl::JaktArray(
                        values: [value_to_repeat; count]
                        type_id: .program.substitute_typevars_in_type(
                            type_id
                            generic_inferences: scope.type_map_for_substitution()
                            module_id: type_id.module)
                    )
                    span: span
                ))
            }
            else => {
                mut values: [Value] = []
                for value in vals.iterator() {
                    let val = match .execute_expression(value, scope) {
                        Return(value) => {
                            return StatementResult::Return(value)
                        }
                        Throw(value) => {
                            return StatementResult::Throw(value)
                        }
                        JustValue(value) => value
                        Continue => {
                            return StatementResult::Continue
                        }
                        Break => {
                            return StatementResult::Break
                        }
                        Yield(expr) => {
                            panic("Invalid control flow")
                        }
                    }
                    values.push(val)
                }
                yield StatementResult::JustValue(Value(
                    impl: ValueImpl::JaktArray(
                        values
                        type_id: .program.substitute_typevars_in_type(
                            type_id
                            generic_inferences: scope.type_map_for_substitution()
                            module_id: type_id.module)
                    )
                    span: span
                ))
            }
        }
        IndexedTuple(expr, index) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            guard value.impl is JaktTuple(fields) else {
                panic("expected tuple")
            }

            yield StatementResult::JustValue(fields[index])
        }
        Match(expr, match_cases, all_variants_constant, span) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields,  enum_id, constructor) => {
                    let constructor_name = .program.get_function(constructor).name

                    mut catch_all_case: CheckedMatchBody? = None
                    mut found_body: CheckedMatchBody? = None
                    mut found_args: [EnumVariantPatternArgument]? = None
                    mut found_variant_index: usize? = None
                    mut span: Span? = None

                    for match_case in match_cases.iterator() {
                        match match_case {
                            EnumVariant(name, args, index, body, marker_span) => {
                                if name != constructor_name {
                                    continue
                                }

                                // A match!
                                found_body = body
                                found_args = args
                                found_variant_index = index
                                span = marker_span
                                break
                            }
                            Expression(marker_span) => {
                                .error("Value matches are not allowed on enums", marker_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                            CatchAll(body, marker_span) => {
                                catch_all_case = body
                                span = marker_span
                                continue
                            }
                        }
                    }

                    found_body = found_body ?? catch_all_case!
                    let empty_args: [EnumVariantPatternArgument] = []
                    found_args = found_args ?? empty_args

                    mut new_scope = InterpreterScope::create(parent: scope)
                    defer new_scope.perform_defers(interpreter: this, span: span!)

                    if found_variant_index.has_value() and not found_args!.is_empty() {
                        let variant = .program.get_enum(enum_id).variants[found_variant_index!]
                        match variant {
                            Untyped => {}
                            WithValue => {}
                            Typed => {
                                new_scope.bindings.set(
                                    found_args![0].binding
                                    fields[0]
                                )
                            }
                            StructLike(fields: variant_fields) => {
                                mut i = 0
                                for var_id in variant_fields.iterator() {
                                    let field = .program.get_variable(var_id)
                                    for arg in found_args!.iterator() {
                                        let matched_name = arg.name ?? arg.binding
                                        if matched_name == field.name {
                                            new_scope.bindings.set(
                                                arg.binding
                                                fields[i]
                                            )
                                            break
                                        }
                                    }
                                    i += 1
                                }
                            }
                        }
                    }

                    yield match found_body! {
                        Expression(expr) => {
                            let result = .execute_expression(expr, scope: new_scope)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                        Block(block) => {
                            let result = .execute_block(block, scope: new_scope, call_span: span!)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                    }
                }
                else => {
                    mut catch_all_case: CheckedMatchBody? = None
                    mut found_body: CheckedMatchBody? = None
                    mut span: Span? = None

                    for match_case in match_cases.iterator() {
                        match match_case {
                            Expression(body, expression, marker_span) => {
                                let value_to_match_against = match .execute_expression(expression, scope) {
                                    Return(value) => {
                                        return StatementResult::Return(value)
                                    }
                                    Throw(value) => {
                                        return StatementResult::Throw(value)
                                    }
                                    JustValue(value) => value
                                    Continue => {
                                        return StatementResult::Continue
                                    }
                                    Break => {
                                        return StatementResult::Break
                                    }
                                    Yield => {
                                        panic("Invalid control flow")
                                    }
                                }

                                if value_to_match_against.impl.equals(value.impl) {
                                    found_body = Some(body)
                                    span = Some(marker_span)
                                    break
                                }
                            }
                            CatchAll(body, marker_span) => {
                                catch_all_case = body
                                span = marker_span
                                continue
                            }
                            EnumVariant(marker_span) => {
                                .error(
                                    format("Value matches cannot have enum variant arms (matching on {})", value.type_name()),
                                    marker_span)
                                throw Error::from_errno(InterpretError::InvalidType as! i32)
                            }
                        }
                    }

                    found_body = found_body ?? catch_all_case!
                    mut new_scope = InterpreterScope::create(parent: scope)
                    defer new_scope.perform_defers(interpreter: this, span: span!)

                    yield match found_body! {
                        Expression(expr) => {
                            let result = .execute_expression(expr, scope: new_scope)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                        Block(block) => {
                            let result = .execute_block(block, scope: new_scope, call_span: span!)
                            yield match result {
                                Yield(value) => StatementResult::JustValue(value)
                                Continue | Break | JustValue | Return | Throw => result
                            }
                        }
                    }
                }
            }
        }
        EnumVariantArg(expr, arg, enum_variant, span) => {
            let value = match .execute_expression(expr, scope) {
                JustValue(value) => value
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Throw(value) => {
                    return StatementResult::Throw(value)
                }
                Continue => {
                    return StatementResult::Continue
                }
                Break => {
                    return StatementResult::Break
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield match value.impl {
                Enum(fields,  enum_id, constructor) => {
                    mut found_variant: CheckedEnumVariant? = None
                    for variant in .program.get_enum(enum_id).variants.iterator() {
                        if variant.name() == enum_variant.name() {
                            found_variant = variant
                            break
                        }
                    }

                    yield match found_variant! {
                        Typed => StatementResult::JustValue(fields[0])
                        StructLike(fields: variant_fields) => {
                            mut i = 0
                            for var_id in variant_fields.iterator() {
                                let field = .program.get_variable(var_id)
                                let matched_name = arg.name ?? arg.binding
                                if matched_name == field.name {
                                    break
                                }
                                i += 1
                            }
                            yield StatementResult::JustValue(fields[i])
                        }
                        else => StatementResult::JustValue(Value(impl: ValueImpl::Void, span))
                    }
                }
                else => {
                    .error(
                        format("Value matches cannot have enum variant arms (matching on {})", value.type_name()),
                        span)
                    throw Error::from_errno(InterpretError::InvalidType as! i32)
                }
            }
        }
        // JaktTuple
        JaktSet(vals, span, type_id) => {
            mut values: [Value] = []
            for v in vals.iterator() {
                let val = match .execute_expression(v, scope) {
                    Return(value) => {
                        return StatementResult::Return(value)
                    }
                    Throw(value) => {
                        return StatementResult::Throw(value)
                    }
                    JustValue(value) => value
                    Continue => {
                        return StatementResult::Continue
                    }
                    Break => {
                        return StatementResult::Break
                    }
                    Yield(expr) => {
                        panic("Invalid control flow")
                    }
                }

                values.push(val)
            }

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::JaktSet(
                    values
                    type_id
                )
                span: span
            ))
        }
        Function(captures, params, return_type_id, type_id, block, span, can_throw) => {
            // First, resolve the captures
            mut resolved_captures: [String:Value] = [:]
            for capture in captures.iterator() {
                let name = capture.name()
                guard capture is ByValue else {
                    .error(
                        format("Cannot capture by reference in a comptime function (nyi)"),
                        span)
                    throw Error::from_errno(InterpretError::Unimplemented as! i32)
                }

                resolved_captures.set(name, scope.must_get(name))
            }

            // Next, resolve the parameters
            let type_map = scope.type_map_for_substitution()
            mut resolved_params: [String:(TypeId, CheckedExpression?)] = [:]
            mut checked_params: [CheckedParameter] = []
            for param in params.iterator() {
                let param_type_id = .program.substitute_typevars_in_type(
                    type_id: param.variable.type_id
                    generic_inferences: type_map
                    module_id: param.variable.type_id.module)

                resolved_params.set(
                    param.variable.name
                    (
                        param_type_id,
                        param.default_value
                    )
                )

                checked_params.push(CheckedParameter(
                    requires_label: param.requires_label
                    variable: CheckedVariable(
                        name: param.variable.name
                        type_id: param_type_id
                        is_mutable: param.variable.is_mutable
                        definition_span: param.variable.definition_span
                        type_span: param.variable.type_span
                        visibility: param.variable.visibility
                    )
                    default_value: param.default_value
                ))
            }

            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Function(
                    captures: resolved_captures,
                    params: resolved_params
                    return_type_id: .program.substitute_typevars_in_type(
                        type_id: return_type_id
                        generic_inferences: type_map
                        module_id: return_type_id.module)
                    type_id: .program.substitute_typevars_in_type(
                        type_id
                        generic_inferences: type_map
                        module_id: type_id.module)
                    block
                    can_throw
                    checked_params
                )
                span
            ))
        }
        TryBlock(stmt, catch_block, error_name, span) => {
            match .execute_statement(statement: stmt, scope, call_span: span) {
                JustValue => {}
                Throw(value) => {
                    mut catch_scope = InterpreterScope::create(parent: scope)
                    defer catch_scope.perform_defers(interpreter: this, span)

                    catch_scope.bindings.set(
                        error_name
                        value
                    )
                    let result = .execute_block(block: catch_block, scope: catch_scope, call_span: span)
                    match result {
                        Continue | Break | Return | Throw => {
                            return result
                        }
                        else => {}
                    }
                }
                Return(value) => {
                    return StatementResult::Return(value)
                }
                Break => {
                    return StatementResult::Break
                }
                Continue => {
                    return StatementResult::Continue
                }
                Yield => {
                    panic("Invalid control flow")
                }
            }
            yield StatementResult::JustValue(Value(
                impl: ValueImpl::Void
                span
            ))
        }
        else => {
            .error(format("expression not implemented: {}", expr), expr.span())
            throw Error::from_errno(InterpretError::Unimplemented as! i32)
        }
    }
}
